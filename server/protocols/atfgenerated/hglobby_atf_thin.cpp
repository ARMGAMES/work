/**
 * hglobby_atf_thin.cpp
 *
 * This file was auto-generated from hglobby_atf.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor -thin hglobby_atf.txt
 */
 
#include "hglobby_atf_thin.h"

//=================================================================
//                    UserId
//=================================================================

hglobby::lobby_client::UserId::UserId()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::UserId::UserId(UserId&& _o)
	: userId(std::move(_o.userId))
{
}

hglobby::lobby_client::UserId& hglobby::lobby_client::UserId::operator=(UserId&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
	}
	return *this;
}

#endif

void hglobby::lobby_client::UserId::clear()
{
	userId.clear();
}

bool hglobby::lobby_client::UserId::equals(const UserId& _o) const
{
	return userId.equals(_o.userId);
}

const char *hglobby::lobby_client::UserId::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append('}');
	return _buf.c_str();
}

void hglobby::lobby_client::UserId::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
}

void hglobby::lobby_client::UserId::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
}

/*static*/ void hglobby::lobby_client::UserId::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, 20, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_HG_CREATE_CLUB
//=================================================================

hglobby::lobby_client::Protocol_HG_CREATE_CLUB::Protocol_HG_CREATE_CLUB()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_CREATE_CLUB::Protocol_HG_CREATE_CLUB(Protocol_HG_CREATE_CLUB&& _o)
	: clubName(std::move(_o.clubName))
	, password(std::move(_o.password))
{
}

hglobby::lobby_client::Protocol_HG_CREATE_CLUB& hglobby::lobby_client::Protocol_HG_CREATE_CLUB::operator=(Protocol_HG_CREATE_CLUB&& _o)
{
	if(this != &_o)
	{
		clubName = std::move(_o.clubName);
		password = std::move(_o.password);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB::clear()
{
	clubName.clear();
	password.clear();
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB::equals(const Protocol_HG_CREATE_CLUB& _o) const
{
	return clubName.equals(_o.clubName) &&
		password.equals(_o.password);
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CREATE_CLUB).append(")");
	_buf.append(',');
	_buf.append("clubName=");
	_buf.append(clubName);
	_buf.append(',');
	_buf.append("password=");
	_buf.append(password);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(clubName);
	_msg.composeString(password);
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(clubName);
	_parser.parseStringP(password);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CREATE_CLUB::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CREATE_CLUB";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "clubName"); size_t szClubName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "clubName", szClubName, 128, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "password"); size_t szPassword = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "password", szPassword, 128, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CREATE_CLUB_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_CREATE_CLUB_REPLY::Protocol_HG_CREATE_CLUB_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_CREATE_CLUB_REPLY::Protocol_HG_CREATE_CLUB_REPLY(Protocol_HG_CREATE_CLUB_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, clubId(std::move(_o.clubId))
	, socialToken(std::move(_o.socialToken))
{
}

hglobby::lobby_client::Protocol_HG_CREATE_CLUB_REPLY& hglobby::lobby_client::Protocol_HG_CREATE_CLUB_REPLY::operator=(Protocol_HG_CREATE_CLUB_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		clubId = std::move(_o.clubId);
		socialToken = std::move(_o.socialToken);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	clubId = 0;
	socialToken.clear();
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB_REPLY::equals(const Protocol_HG_CREATE_CLUB_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		clubId == _o.clubId &&
		socialToken.equals(_o.socialToken);
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CREATE_CLUB_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("clubId=");
		_buf.appendUint(clubId);
		_buf.append(',');
		_buf.append("socialToken=");
		_buf.append(socialToken);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeUINT32(clubId);
		_msg.composeString(socialToken);
	}
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseUINT32(clubId);
		_parser.parseStringP(socialToken);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CREATE_CLUB_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 clubId; _parser.parseUINT32(clubId);
		AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "socialToken"); size_t szSocialToken = strlen(_dummy);
		AtfValidator::validateInt(_descr, "socialToken", szSocialToken, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    HgClubInfo
//=================================================================

hglobby::lobby_client::HgClubInfo::HgClubInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::HgClubInfo::HgClubInfo(HgClubInfo&& _o)
	: clubId(std::move(_o.clubId))
	, clubName(std::move(_o.clubName))
	, nbMembers(std::move(_o.nbMembers))
	, roleForUser(std::move(_o.roleForUser))
	, memberFlags(std::move(_o.memberFlags))
	, ordinal(std::move(_o.ordinal))
	, favoriteClub(std::move(_o.favoriteClub))
	, clubNameColor(std::move(_o.clubNameColor))
{
}

hglobby::lobby_client::HgClubInfo& hglobby::lobby_client::HgClubInfo::operator=(HgClubInfo&& _o)
{
	if(this != &_o)
	{
		clubId = std::move(_o.clubId);
		clubName = std::move(_o.clubName);
		nbMembers = std::move(_o.nbMembers);
		roleForUser = std::move(_o.roleForUser);
		memberFlags = std::move(_o.memberFlags);
		ordinal = std::move(_o.ordinal);
		favoriteClub = std::move(_o.favoriteClub);
		clubNameColor = std::move(_o.clubNameColor);
	}
	return *this;
}

#endif

void hglobby::lobby_client::HgClubInfo::clear()
{
	clubId = 0;
	clubName.clear();
	nbMembers = 0;
	roleForUser = 0;
	memberFlags = 0;
	ordinal = 0;
	favoriteClub = false;
	clubNameColor = 0;
}

bool hglobby::lobby_client::HgClubInfo::equals(const HgClubInfo& _o) const
{
	return clubId == _o.clubId &&
		clubName.equals(_o.clubName) &&
		nbMembers == _o.nbMembers &&
		roleForUser == _o.roleForUser &&
		memberFlags == _o.memberFlags &&
		ordinal == _o.ordinal &&
		favoriteClub == _o.favoriteClub &&
		clubNameColor == _o.clubNameColor;
}

const char *hglobby::lobby_client::HgClubInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("clubName=");
	_buf.append(clubName);
	_buf.append(',');
	_buf.append("nbMembers=");
	_buf.appendUint(nbMembers);
	_buf.append(',');
	_buf.append("roleForUser=");
	_buf.appendUint(roleForUser);
	_buf.append(',');
	_buf.append("memberFlags=");
	_buf.appendUint(memberFlags);
	_buf.append(',');
	_buf.append("ordinal=");
	_buf.appendUint(ordinal);
	_buf.append(',');
	_buf.append("favoriteClub=");
	_buf.appendUint(favoriteClub);
	_buf.append(',');
	_buf.append("clubNameColor=");
	_buf.appendUint(clubNameColor);
	_buf.append('}');
	return _buf.c_str();
}

void hglobby::lobby_client::HgClubInfo::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(HgClubInfo())) // not empty
	{
		_body.composeUINT32(clubId);
		_body.composeString(clubName);
		_body.composeUINT32(nbMembers);
		_body.composeUINT32(roleForUser);
		_body.composeUINT32(memberFlags);
		_body.composeUINT32(ordinal);
		_body.composeBOOL(favoriteClub);
		_body.composeUINT32(clubNameColor);
	}

	_msg.composeMsgBody(_body);
}

void hglobby::lobby_client::HgClubInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(clubId);
	_parser0.parseStringP(clubName);
	_parser0.parseUINT32(nbMembers);
	_parser0.parseUINT32(roleForUser);
	_parser0.parseUINT32(memberFlags);
	_parser0.parseUINT32(ordinal);
	_parser0.parseBOOL(favoriteClub);
	_parser0.parseUINT32(clubNameColor);
}

/*static*/ void hglobby::lobby_client::HgClubInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 clubId; _parser0.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "clubName"); size_t szClubName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "clubName", szClubName, _checker, __FILE__, __LINE__);
	UINT32 nbMembers; _parser0.parseUINT32(nbMembers);
	AtfValidator::validateInt(_descr, "nbMembers", nbMembers, _checker, __FILE__, __LINE__);
	UINT32 roleForUser; _parser0.parseUINT32(roleForUser);
	AtfValidator::validateInt(_descr, "roleForUser", roleForUser, _checker, __FILE__, __LINE__);
	UINT32 memberFlags; _parser0.parseUINT32(memberFlags);
	AtfValidator::validateInt(_descr, "memberFlags", memberFlags, _checker, __FILE__, __LINE__);
	UINT32 ordinal; _parser0.parseUINT32(ordinal);
	AtfValidator::validateInt(_descr, "ordinal", ordinal, _checker, __FILE__, __LINE__);
	bool favoriteClub; _parser0.parseBOOL(favoriteClub);
	AtfValidator::validateInt(_descr, "favoriteClub", favoriteClub, _checker, __FILE__, __LINE__);
	UINT32 clubNameColor; _parser0.parseUINT32(clubNameColor);
	AtfValidator::validateInt(_descr, "clubNameColor", clubNameColor, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_HG_GET_USER_CLUBS
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS::Protocol_HG_GET_USER_CLUBS()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS::clear()
{
	isNewBehavior = false;
}

bool hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS::equals(const Protocol_HG_GET_USER_CLUBS& _o) const
{
	return isNewBehavior == _o.isNewBehavior;
}

const char *hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_USER_CLUBS).append(")");
	_buf.append(',');
	_buf.append("isNewBehavior=");
	_buf.appendUint(isNewBehavior);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBOOL(isNewBehavior);
}

void hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(isNewBehavior);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_USER_CLUBS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(_parser.parseEnded()) return;
	bool isNewBehavior; _parser.parseBOOL(isNewBehavior);
	AtfValidator::validateInt(_descr, "isNewBehavior", isNewBehavior, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_USER_CLUBS_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS_REPLY::Protocol_HG_GET_USER_CLUBS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS_REPLY::Protocol_HG_GET_USER_CLUBS_REPLY(Protocol_HG_GET_USER_CLUBS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, clubInfoListForClient(std::move(_o.clubInfoListForClient))
{
}

hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS_REPLY& hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS_REPLY::operator=(Protocol_HG_GET_USER_CLUBS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		clubInfoListForClient = std::move(_o.clubInfoListForClient);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	clubInfoListForClient.clear();
}

bool hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS_REPLY::equals(const Protocol_HG_GET_USER_CLUBS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		clubInfoListForClient.equals(_o.clubInfoListForClient);
}

const char *hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_USER_CLUBS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("clubInfoListForClient=");
		clubInfoListForClient.toTraceString(_buf);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		clubInfoListForClient.composeMsg(_msg);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		clubInfoListForClient.parseMsg(_parser);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_USER_CLUBS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szClubInfoListForClient = ThinAtf::LAtfVector< HgClubInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clubInfoListForClient"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "clubInfoListForClient", szClubInfoListForClient, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_ADD_USER_CLUB
//=================================================================

hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB::Protocol_HG_ADD_USER_CLUB()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB::Protocol_HG_ADD_USER_CLUB(Protocol_HG_ADD_USER_CLUB&& _o)
	: clubId(std::move(_o.clubId))
	, clubPassword(std::move(_o.clubPassword))
	, comment(std::move(_o.comment))
	, notUsedUserId(std::move(_o.notUsedUserId))
{
}

hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB& hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB::operator=(Protocol_HG_ADD_USER_CLUB&& _o)
{
	if(this != &_o)
	{
		clubId = std::move(_o.clubId);
		clubPassword = std::move(_o.clubPassword);
		comment = std::move(_o.comment);
		notUsedUserId = std::move(_o.notUsedUserId);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB::clear()
{
	clubId = 0;
	clubPassword.clear();
	comment.clear();
	notUsedUserId.clear();
}

bool hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB::equals(const Protocol_HG_ADD_USER_CLUB& _o) const
{
	return clubId == _o.clubId &&
		clubPassword.equals(_o.clubPassword) &&
		comment.equals(_o.comment) &&
		notUsedUserId.equals(_o.notUsedUserId);
}

const char *hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_ADD_USER_CLUB).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("clubPassword=");
	_buf.append(clubPassword);
	_buf.append(',');
	_buf.append("comment=");
	_buf.append(comment);
	_buf.append(',');
	_buf.append("notUsedUserId=");
	_buf.append(notUsedUserId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(clubId);
	_msg.composeString(clubPassword);
	_msg.composeString(comment);
	_msg.composeString(notUsedUserId);
}

void hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	_parser.parseStringP(clubPassword);
	_parser.parseStringP(comment);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(notUsedUserId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_ADD_USER_CLUB";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "clubPassword"); size_t szClubPassword = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "clubPassword", szClubPassword, 128, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "comment"); size_t szComment = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "comment", szComment, 4096, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "notUsedUserId"); size_t szNotUsedUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedUserId", szNotUsedUserId, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_ADD_USER_CLUB_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB_REPLY::Protocol_HG_ADD_USER_CLUB_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB_REPLY::Protocol_HG_ADD_USER_CLUB_REPLY(Protocol_HG_ADD_USER_CLUB_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, clubName(std::move(_o.clubName))
	, socialToken(std::move(_o.socialToken))
{
}

hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB_REPLY& hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB_REPLY::operator=(Protocol_HG_ADD_USER_CLUB_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		clubName = std::move(_o.clubName);
		socialToken = std::move(_o.socialToken);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	clubName.clear();
	socialToken.clear();
}

bool hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB_REPLY::equals(const Protocol_HG_ADD_USER_CLUB_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		clubName.equals(_o.clubName) &&
		socialToken.equals(_o.socialToken);
}

const char *hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_ADD_USER_CLUB_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("clubName=");
		_buf.append(clubName);
		_buf.append(',');
		_buf.append("socialToken=");
		_buf.append(socialToken);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeString(clubName);
		_msg.composeString(socialToken);
	}
}

void hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseStringP(clubName);
		_parser.parseStringP(socialToken);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_ADD_USER_CLUB_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "clubName"); size_t szClubName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "clubName", szClubName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "socialToken"); size_t szSocialToken = strlen(_dummy);
		AtfValidator::validateInt(_descr, "socialToken", szSocialToken, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    GamesMembershipStatus
//=================================================================

hglobby::lobby_client::GamesMembershipStatus::GamesMembershipStatus()
{
	clear();
}

void hglobby::lobby_client::GamesMembershipStatus::clear()
{
	status = 0;
}

bool hglobby::lobby_client::GamesMembershipStatus::equals(const GamesMembershipStatus& _o) const
{
	return status == _o.status;
}

const char *hglobby::lobby_client::GamesMembershipStatus::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("status=");
	_buf.appendUint(status);
	_buf.append('}');
	return _buf.c_str();
}

void hglobby::lobby_client::GamesMembershipStatus::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(status);
}

void hglobby::lobby_client::GamesMembershipStatus::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(status);
}

/*static*/ void hglobby::lobby_client::GamesMembershipStatus::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 status; _parser.parseUINT32(status);
	AtfValidator::validateIntRange(_descr, "status", status, eHgMembershipStatusApproved, eHgMembershipStatusLastAndInvalid, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_HG_GET_PLAYERS_BASED_ON_STATUS
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS(Protocol_HG_GET_PLAYERS_BASED_ON_STATUS&& _o)
	: clubId(std::move(_o.clubId))
	, statuses(std::move(_o.statuses))
{
}

hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS& hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS::operator=(Protocol_HG_GET_PLAYERS_BASED_ON_STATUS&& _o)
{
	if(this != &_o)
	{
		clubId = std::move(_o.clubId);
		statuses = std::move(_o.statuses);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS::clear()
{
	clubId = 0;
	statuses.clear();
}

bool hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS::equals(const Protocol_HG_GET_PLAYERS_BASED_ON_STATUS& _o) const
{
	return clubId == _o.clubId &&
		statuses.equals(_o.statuses);
}

const char *hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_PLAYERS_BASED_ON_STATUS).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("statuses=");
	statuses.toTraceString(_buf);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(clubId);
	statuses.composeMsg(_msg);
}

void hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	statuses.parseMsg(_parser);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_PLAYERS_BASED_ON_STATUS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szStatuses = ThinAtf::LAtfVector< GamesMembershipStatus, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("statuses"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "statuses", szStatuses, 10240, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    PlayerListElement
//=================================================================

hglobby::lobby_client::PlayerListElement::PlayerListElement()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::PlayerListElement::PlayerListElement(PlayerListElement&& _o)
	: userId(std::move(_o.userId))
	, city(std::move(_o.city))
	, comment(std::move(_o.comment))
	, status(std::move(_o.status))
	, role(std::move(_o.role))
	, enrolled(std::move(_o.enrolled))
	, flags(std::move(_o.flags))
{
}

hglobby::lobby_client::PlayerListElement& hglobby::lobby_client::PlayerListElement::operator=(PlayerListElement&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		city = std::move(_o.city);
		comment = std::move(_o.comment);
		status = std::move(_o.status);
		role = std::move(_o.role);
		enrolled = std::move(_o.enrolled);
		flags = std::move(_o.flags);
	}
	return *this;
}

#endif

void hglobby::lobby_client::PlayerListElement::clear()
{
	userId.clear();
	city.clear();
	comment.clear();
	status = 0;
	role = 0;
	enrolled.setNull();
	flags = 0;
}

bool hglobby::lobby_client::PlayerListElement::equals(const PlayerListElement& _o) const
{
	return userId.equals(_o.userId) &&
		city.equals(_o.city) &&
		comment.equals(_o.comment) &&
		status == _o.status &&
		role == _o.role &&
		enrolled.equals(_o.enrolled) &&
		flags == _o.flags;
}

const char *hglobby::lobby_client::PlayerListElement::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("city=");
	_buf.append(city);
	_buf.append(',');
	_buf.append("comment=");
	_buf.append(comment);
	_buf.append(',');
	_buf.append("status=");
	_buf.appendUint(status);
	_buf.append(',');
	_buf.append("role=");
	_buf.appendUint(role);
	_buf.append(',');
	_buf.append("enrolled=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, enrolled);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append('}');
	return _buf.c_str();
}

void hglobby::lobby_client::PlayerListElement::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(PlayerListElement())) // not empty
	{
		_body.composeString(userId);
		_body.composeString(city);
		_body.composeString(comment);
		_body.composeUINT32(status);
		_body.composeUINT32(role);
		_body.composeSrvTime(enrolled);
		_body.composeUINT32(flags);
	}

	_msg.composeMsgBody(_body);
}

void hglobby::lobby_client::PlayerListElement::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(userId);
	_parser0.parseStringP(city);
	_parser0.parseStringP(comment);
	_parser0.parseUINT32(status);
	_parser0.parseUINT32(role);
	_parser0.parseSrvTime(enrolled);
	_parser0.parseUINT32(flags);
}

/*static*/ void hglobby::lobby_client::PlayerListElement::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
	AtfValidator::validateInt(_descr, "city", szCity, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "comment"); size_t szComment = strlen(_dummy);
	AtfValidator::validateInt(_descr, "comment", szComment, _checker, __FILE__, __LINE__);
	UINT32 status; _parser0.parseUINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	UINT32 role; _parser0.parseUINT32(role);
	AtfValidator::validateInt(_descr, "role", role, _checker, __FILE__, __LINE__);
	SrvTime enrolled; _parser0.parseSrvTime(enrolled);
	AtfValidator::validateSrvDateTime(_descr, "enrolled", enrolled, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser0.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_HG_GET_PLAYERS_BASED_ON_STATUS_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS_REPLY::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS_REPLY::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS_REPLY(Protocol_HG_GET_PLAYERS_BASED_ON_STATUS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, playerList(std::move(_o.playerList))
{
}

hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS_REPLY& hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS_REPLY::operator=(Protocol_HG_GET_PLAYERS_BASED_ON_STATUS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		playerList = std::move(_o.playerList);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	playerList.clear();
}

bool hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS_REPLY::equals(const Protocol_HG_GET_PLAYERS_BASED_ON_STATUS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		playerList.equals(_o.playerList);
}

const char *hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_PLAYERS_BASED_ON_STATUS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("playerList=");
		playerList.toTraceString(_buf);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		playerList.composeMsg(_msg);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		playerList.parseMsg(_parser);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_PLAYERS_BASED_ON_STATUS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szPlayerList = ThinAtf::LAtfVector< PlayerListElement, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("playerList"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "playerList", szPlayerList, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CHANGE_PLAYERS_STATUS
//=================================================================

hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS::Protocol_HG_CHANGE_PLAYERS_STATUS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS::Protocol_HG_CHANGE_PLAYERS_STATUS(Protocol_HG_CHANGE_PLAYERS_STATUS&& _o)
	: clubId(std::move(_o.clubId))
	, action(std::move(_o.action))
	, usersToChange(std::move(_o.usersToChange))
{
}

hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS& hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS::operator=(Protocol_HG_CHANGE_PLAYERS_STATUS&& _o)
{
	if(this != &_o)
	{
		clubId = std::move(_o.clubId);
		action = std::move(_o.action);
		usersToChange = std::move(_o.usersToChange);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS::clear()
{
	clubId = 0;
	action = 0;
	usersToChange.clear();
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS::equals(const Protocol_HG_CHANGE_PLAYERS_STATUS& _o) const
{
	return clubId == _o.clubId &&
		action == _o.action &&
		usersToChange.equals(_o.usersToChange);
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CHANGE_PLAYERS_STATUS).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("action=");
	_buf.appendUint(action);
	_buf.append(',');
	_buf.append("usersToChange=");
	usersToChange.toTraceString(_buf);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(clubId);
	_msg.composeUINT32(action);
	usersToChange.composeMsg(_msg);
}

void hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	_parser.parseUINT32(action);
	usersToChange.parseMsg(_parser);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CHANGE_PLAYERS_STATUS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 action; _parser.parseUINT32(action);
	AtfValidator::validateIntRange(_descr, "action", action, eHgAcceptPlayer, eHgRemoveApplication, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szUsersToChange = ThinAtf::LAtfVector< UserId, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("usersToChange"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "usersToChange", szUsersToChange, 10000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CHANGE_PLAYERS_STATUS_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS_REPLY::Protocol_HG_CHANGE_PLAYERS_STATUS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS_REPLY::Protocol_HG_CHANGE_PLAYERS_STATUS_REPLY(Protocol_HG_CHANGE_PLAYERS_STATUS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, socialToken(std::move(_o.socialToken))
{
}

hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS_REPLY& hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS_REPLY::operator=(Protocol_HG_CHANGE_PLAYERS_STATUS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		socialToken = std::move(_o.socialToken);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	socialToken.clear();
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS_REPLY::equals(const Protocol_HG_CHANGE_PLAYERS_STATUS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		socialToken.equals(_o.socialToken);
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CHANGE_PLAYERS_STATUS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("socialToken=");
		_buf.append(socialToken);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeString(socialToken);
	}
}

void hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseStringP(socialToken);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CHANGE_PLAYERS_STATUS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "socialToken"); size_t szSocialToken = strlen(_dummy);
		AtfValidator::validateInt(_descr, "socialToken", szSocialToken, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CHANGE_CLUB_PASSWORD
//=================================================================

hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD::Protocol_HG_CHANGE_CLUB_PASSWORD()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD::Protocol_HG_CHANGE_CLUB_PASSWORD(Protocol_HG_CHANGE_CLUB_PASSWORD&& _o)
	: clubId(std::move(_o.clubId))
	, password(std::move(_o.password))
{
}

hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD& hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD::operator=(Protocol_HG_CHANGE_CLUB_PASSWORD&& _o)
{
	if(this != &_o)
	{
		clubId = std::move(_o.clubId);
		password = std::move(_o.password);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD::clear()
{
	clubId = 0;
	password.clear();
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD::equals(const Protocol_HG_CHANGE_CLUB_PASSWORD& _o) const
{
	return clubId == _o.clubId &&
		password.equals(_o.password);
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CHANGE_CLUB_PASSWORD).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("password=");
	_buf.append(password);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(clubId);
	_msg.composeString(password);
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	_parser.parseStringP(password);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CHANGE_CLUB_PASSWORD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "password"); size_t szPassword = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "password", szPassword, 128, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CHANGE_CLUB_PASSWORD_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD_REPLY::Protocol_HG_CHANGE_CLUB_PASSWORD_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD_REPLY::Protocol_HG_CHANGE_CLUB_PASSWORD_REPLY(Protocol_HG_CHANGE_CLUB_PASSWORD_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD_REPLY& hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD_REPLY::operator=(Protocol_HG_CHANGE_CLUB_PASSWORD_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD_REPLY::equals(const Protocol_HG_CHANGE_CLUB_PASSWORD_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc);
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CHANGE_CLUB_PASSWORD_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CHANGE_CLUB_PASSWORD_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CHANGE_CLUB_OPTIONS
//=================================================================

hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS::Protocol_HG_CHANGE_CLUB_OPTIONS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS::Protocol_HG_CHANGE_CLUB_OPTIONS(Protocol_HG_CHANGE_CLUB_OPTIONS&& _o)
	: clubId(std::move(_o.clubId))
	, seasonLength(std::move(_o.seasonLength))
	, showClubStandings(std::move(_o.showClubStandings))
	, showPlayerStats(std::move(_o.showPlayerStats))
	, currency(std::move(_o.currency))
	, showFounderFullName(std::move(_o.showFounderFullName))
{
}

hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS& hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS::operator=(Protocol_HG_CHANGE_CLUB_OPTIONS&& _o)
{
	if(this != &_o)
	{
		clubId = std::move(_o.clubId);
		seasonLength = std::move(_o.seasonLength);
		showClubStandings = std::move(_o.showClubStandings);
		showPlayerStats = std::move(_o.showPlayerStats);
		currency = std::move(_o.currency);
		showFounderFullName = std::move(_o.showFounderFullName);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS::clear()
{
	clubId = 0;
	seasonLength = 0;
	showClubStandings = false;
	showPlayerStats = false;
	currency.clear();
	showFounderFullName = false;
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS::equals(const Protocol_HG_CHANGE_CLUB_OPTIONS& _o) const
{
	return clubId == _o.clubId &&
		seasonLength == _o.seasonLength &&
		showClubStandings == _o.showClubStandings &&
		showPlayerStats == _o.showPlayerStats &&
		currency.equals(_o.currency) &&
		showFounderFullName == _o.showFounderFullName;
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CHANGE_CLUB_OPTIONS).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("seasonLength=");
	_buf.appendUint(seasonLength);
	_buf.append(',');
	_buf.append("showClubStandings=");
	_buf.appendUint(showClubStandings);
	_buf.append(',');
	_buf.append("showPlayerStats=");
	_buf.appendUint(showPlayerStats);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("showFounderFullName=");
	_buf.appendUint(showFounderFullName);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(clubId);
	_msg.composeUINT32(seasonLength);
	_msg.composeBOOL(showClubStandings);
	_msg.composeBOOL(showPlayerStats);
	_msg.composeString(currency);
	_msg.composeBOOL(showFounderFullName);
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	_parser.parseUINT32(seasonLength);
	_parser.parseBOOL(showClubStandings);
	_parser.parseBOOL(showPlayerStats);
	_parser.parseStringP(currency);
	_parser.parseBOOL(showFounderFullName);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CHANGE_CLUB_OPTIONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 seasonLength; _parser.parseUINT32(seasonLength);
	AtfValidator::validateIntRange(_descr, "seasonLength", seasonLength, eHgClubSeasonsYearly, eHgClubSeasonsMonthly, _checker, __FILE__, __LINE__);
	bool showClubStandings; _parser.parseBOOL(showClubStandings);
	AtfValidator::validateInt(_descr, "showClubStandings", showClubStandings, _checker, __FILE__, __LINE__);
	bool showPlayerStats; _parser.parseBOOL(showPlayerStats);
	AtfValidator::validateInt(_descr, "showPlayerStats", showPlayerStats, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, 5, _checker, __FILE__, __LINE__);
	bool showFounderFullName; _parser.parseBOOL(showFounderFullName);
	AtfValidator::validateInt(_descr, "showFounderFullName", showFounderFullName, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CHANGE_CLUB_OPTIONS_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS_REPLY::Protocol_HG_CHANGE_CLUB_OPTIONS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS_REPLY::Protocol_HG_CHANGE_CLUB_OPTIONS_REPLY(Protocol_HG_CHANGE_CLUB_OPTIONS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS_REPLY& hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS_REPLY::operator=(Protocol_HG_CHANGE_CLUB_OPTIONS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS_REPLY::equals(const Protocol_HG_CHANGE_CLUB_OPTIONS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc);
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CHANGE_CLUB_OPTIONS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CHANGE_CLUB_OPTIONS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CHANGE_CLUB_IMAGE
//=================================================================

hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE::Protocol_HG_CHANGE_CLUB_IMAGE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE::Protocol_HG_CHANGE_CLUB_IMAGE(Protocol_HG_CHANGE_CLUB_IMAGE&& _o)
	: clubId(std::move(_o.clubId))
	, image(std::move(_o.image))
	, isHeader(std::move(_o.isHeader))
{
}

hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE& hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE::operator=(Protocol_HG_CHANGE_CLUB_IMAGE&& _o)
{
	if(this != &_o)
	{
		clubId = std::move(_o.clubId);
		image = std::move(_o.image);
		isHeader = std::move(_o.isHeader);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE::clear()
{
	clubId = 0;
	image.clear();
	isHeader = false;
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE::equals(const Protocol_HG_CHANGE_CLUB_IMAGE& _o) const
{
	return clubId == _o.clubId &&
		image.size() == _o.image.size() && memcmp(image.ptr(), _o.image.ptr(), image.size()) == 0 &&
		isHeader == _o.isHeader;
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CHANGE_CLUB_IMAGE).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("image=");
	ThinAtf::AtfTempl<PBlock>::ToTraceString(_buf, image);
	_buf.append(',');
	_buf.append("isHeader=");
	_buf.appendUint(isHeader);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(clubId);
	_msg._composeVarBlock(image.ptr(), image.size());
	_msg.composeBOOL(isHeader);
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	_parser.parsePBlock(image);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(isHeader);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CHANGE_CLUB_IMAGE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	const BYTE* image; size_t szImage; _parser._parseVarBlock(image, szImage);  /*image*/
	AtfValidator::validateIntMax(_descr, "image", szImage, 10485760, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool isHeader; _parser.parseBOOL(isHeader);
	AtfValidator::validateInt(_descr, "isHeader", isHeader, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CHANGE_CLUB_IMAGE_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE_REPLY::Protocol_HG_CHANGE_CLUB_IMAGE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE_REPLY::Protocol_HG_CHANGE_CLUB_IMAGE_REPLY(Protocol_HG_CHANGE_CLUB_IMAGE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE_REPLY& hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE_REPLY::operator=(Protocol_HG_CHANGE_CLUB_IMAGE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE_REPLY::equals(const Protocol_HG_CHANGE_CLUB_IMAGE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc);
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CHANGE_CLUB_IMAGE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CHANGE_CLUB_IMAGE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUB_SEASONS
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS::Protocol_HG_GET_CLUB_SEASONS()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS::clear()
{
	clubId = 0;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS::equals(const Protocol_HG_GET_CLUB_SEASONS& _o) const
{
	return clubId == _o.clubId;
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_SEASONS).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(clubId);
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_SEASONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    ClubSeason
//=================================================================

hglobby::lobby_client::ClubSeason::ClubSeason()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::ClubSeason::ClubSeason(ClubSeason&& _o)
	: seasonId(std::move(_o.seasonId))
	, timeFrom(std::move(_o.timeFrom))
	, timeTo(std::move(_o.timeTo))
	, closed(std::move(_o.closed))
	, seasonType(std::move(_o.seasonType))
	, seasonName(std::move(_o.seasonName))
{
}

hglobby::lobby_client::ClubSeason& hglobby::lobby_client::ClubSeason::operator=(ClubSeason&& _o)
{
	if(this != &_o)
	{
		seasonId = std::move(_o.seasonId);
		timeFrom = std::move(_o.timeFrom);
		timeTo = std::move(_o.timeTo);
		closed = std::move(_o.closed);
		seasonType = std::move(_o.seasonType);
		seasonName = std::move(_o.seasonName);
	}
	return *this;
}

#endif

void hglobby::lobby_client::ClubSeason::clear()
{
	seasonId = 0;
	timeFrom.setNull();
	timeTo.setNull();
	closed = false;
	seasonType = 0;
	seasonName.clear();
}

bool hglobby::lobby_client::ClubSeason::equals(const ClubSeason& _o) const
{
	return seasonId == _o.seasonId &&
		timeFrom.equals(_o.timeFrom) &&
		timeTo.equals(_o.timeTo) &&
		closed == _o.closed &&
		seasonType == _o.seasonType &&
		seasonName.equals(_o.seasonName);
}

const char *hglobby::lobby_client::ClubSeason::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("seasonId=");
	_buf.appendUint(seasonId);
	_buf.append(',');
	_buf.append("timeFrom=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, timeFrom);
	_buf.append(',');
	_buf.append("timeTo=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, timeTo);
	_buf.append(',');
	_buf.append("closed=");
	_buf.appendUint(closed);
	_buf.append(',');
	_buf.append("seasonType=");
	_buf.appendUint(seasonType);
	_buf.append(',');
	_buf.append("seasonName=");
	_buf.append(seasonName);
	_buf.append('}');
	return _buf.c_str();
}

void hglobby::lobby_client::ClubSeason::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(ClubSeason())) // not empty
	{
		_body.composeUINT32(seasonId);
		_body.composeSrvTime(timeFrom);
		_body.composeSrvTime(timeTo);
		_body.composeBOOL(closed);
		_body.composeUINT32(seasonType);
		_body.composeString(seasonName);
	}

	_msg.composeMsgBody(_body);
}

void hglobby::lobby_client::ClubSeason::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(seasonId);
	_parser0.parseSrvTime(timeFrom);
	_parser0.parseSrvTime(timeTo);
	_parser0.parseBOOL(closed);
	_parser0.parseUINT32(seasonType);
	_parser0.parseStringP(seasonName);
}

/*static*/ void hglobby::lobby_client::ClubSeason::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 seasonId; _parser0.parseUINT32(seasonId);
	AtfValidator::validateInt(_descr, "seasonId", seasonId, _checker, __FILE__, __LINE__);
	SrvTime timeFrom; _parser0.parseSrvTime(timeFrom);
	AtfValidator::validateSrvDateTime(_descr, "timeFrom", timeFrom, _checker, __FILE__, __LINE__);
	SrvTime timeTo; _parser0.parseSrvTime(timeTo);
	AtfValidator::validateSrvDateTime(_descr, "timeTo", timeTo, _checker, __FILE__, __LINE__);
	bool closed; _parser0.parseBOOL(closed);
	AtfValidator::validateInt(_descr, "closed", closed, _checker, __FILE__, __LINE__);
	UINT32 seasonType; _parser0.parseUINT32(seasonType);
	AtfValidator::validateInt(_descr, "seasonType", seasonType, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "seasonName"); size_t szSeasonName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "seasonName", szSeasonName, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_HG_GET_CLUB_SEASONS_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS_REPLY::Protocol_HG_GET_CLUB_SEASONS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS_REPLY::Protocol_HG_GET_CLUB_SEASONS_REPLY(Protocol_HG_GET_CLUB_SEASONS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, seasons(std::move(_o.seasons))
{
}

hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS_REPLY& hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS_REPLY::operator=(Protocol_HG_GET_CLUB_SEASONS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		seasons = std::move(_o.seasons);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	seasons.clear();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS_REPLY::equals(const Protocol_HG_GET_CLUB_SEASONS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		seasons.equals(_o.seasons);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_SEASONS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("seasons=");
		seasons.toTraceString(_buf);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		seasons.composeMsg(_msg);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		seasons.parseMsg(_parser);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_SEASONS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szSeasons = ThinAtf::LAtfVector< ClubSeason, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("seasons"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "seasons", szSeasons, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUB_SEASON_RANKS
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS::Protocol_HG_GET_CLUB_SEASON_RANKS()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS::clear()
{
	clubId = 0;
	seasonId = 0;
	isPlayMoney = false;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS::equals(const Protocol_HG_GET_CLUB_SEASON_RANKS& _o) const
{
	return clubId == _o.clubId &&
		seasonId == _o.seasonId &&
		isPlayMoney == _o.isPlayMoney;
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_SEASON_RANKS).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("seasonId=");
	_buf.appendUint(seasonId);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(clubId);
	_msg.composeUINT32(seasonId);
	_msg.composeBOOL(isPlayMoney);
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	_parser.parseUINT32(seasonId);
	_parser.parseBOOL(isPlayMoney);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_SEASON_RANKS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 seasonId; _parser.parseUINT32(seasonId);
	AtfValidator::validateInt(_descr, "seasonId", seasonId, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    ClubSeasonUserRank
//=================================================================

hglobby::lobby_client::ClubSeasonUserRank::ClubSeasonUserRank()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::ClubSeasonUserRank::ClubSeasonUserRank(ClubSeasonUserRank&& _o)
	: userId(std::move(_o.userId))
	, pointsTotal(std::move(_o.pointsTotal))
	, gamesPlayed(std::move(_o.gamesPlayed))
	, rank(std::move(_o.rank))
{
}

hglobby::lobby_client::ClubSeasonUserRank& hglobby::lobby_client::ClubSeasonUserRank::operator=(ClubSeasonUserRank&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		pointsTotal = std::move(_o.pointsTotal);
		gamesPlayed = std::move(_o.gamesPlayed);
		rank = std::move(_o.rank);
	}
	return *this;
}

#endif

void hglobby::lobby_client::ClubSeasonUserRank::clear()
{
	userId.clear();
	pointsTotal = 0;
	gamesPlayed = 0;
	rank = 0;
}

bool hglobby::lobby_client::ClubSeasonUserRank::equals(const ClubSeasonUserRank& _o) const
{
	return userId.equals(_o.userId) &&
		pointsTotal == _o.pointsTotal &&
		gamesPlayed == _o.gamesPlayed &&
		rank == _o.rank;
}

const char *hglobby::lobby_client::ClubSeasonUserRank::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("pointsTotal=");
	_buf.appendUint64(pointsTotal);
	_buf.append(',');
	_buf.append("gamesPlayed=");
	_buf.appendUint(gamesPlayed);
	_buf.append(',');
	_buf.append("rank=");
	_buf.appendUint(rank);
	_buf.append('}');
	return _buf.c_str();
}

void hglobby::lobby_client::ClubSeasonUserRank::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(ClubSeasonUserRank())) // not empty
	{
		_body.composeString(userId);
		_body.composeUINT64(pointsTotal);
		_body.composeUINT32(gamesPlayed);
		_body.composeUINT32(rank);
	}

	_msg.composeMsgBody(_body);
}

void hglobby::lobby_client::ClubSeasonUserRank::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(userId);
	_parser0.parseUINT64(pointsTotal);
	_parser0.parseUINT32(gamesPlayed);
	_parser0.parseUINT32(rank);
}

/*static*/ void hglobby::lobby_client::ClubSeasonUserRank::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	UINT64 pointsTotal; _parser0.parseUINT64(pointsTotal);
	AtfValidator::validateUint(_descr, "pointsTotal", pointsTotal, _checker, __FILE__, __LINE__);
	UINT32 gamesPlayed; _parser0.parseUINT32(gamesPlayed);
	AtfValidator::validateInt(_descr, "gamesPlayed", gamesPlayed, _checker, __FILE__, __LINE__);
	UINT32 rank; _parser0.parseUINT32(rank);
	AtfValidator::validateInt(_descr, "rank", rank, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_HG_GET_CLUB_SEASON_RANKS_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS_REPLY::Protocol_HG_GET_CLUB_SEASON_RANKS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS_REPLY::Protocol_HG_GET_CLUB_SEASON_RANKS_REPLY(Protocol_HG_GET_CLUB_SEASON_RANKS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, ranks(std::move(_o.ranks))
{
}

hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS_REPLY& hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS_REPLY::operator=(Protocol_HG_GET_CLUB_SEASON_RANKS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		ranks = std::move(_o.ranks);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	ranks.clear();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS_REPLY::equals(const Protocol_HG_GET_CLUB_SEASON_RANKS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		ranks.equals(_o.ranks);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_SEASON_RANKS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("ranks=");
		ranks.toTraceString(_buf);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		ranks.composeMsg(_msg);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		ranks.parseMsg(_parser);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_SEASON_RANKS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szRanks = ThinAtf::LAtfVector< ClubSeasonUserRank, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("ranks"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "ranks", szRanks, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUB_SEASON_STATS
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS::Protocol_HG_GET_CLUB_SEASON_STATS()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS::clear()
{
	clubId = 0;
	seasonId = 0;
	isPlayMoney = false;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS::equals(const Protocol_HG_GET_CLUB_SEASON_STATS& _o) const
{
	return clubId == _o.clubId &&
		seasonId == _o.seasonId &&
		isPlayMoney == _o.isPlayMoney;
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_SEASON_STATS).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("seasonId=");
	_buf.appendUint(seasonId);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(clubId);
	_msg.composeUINT32(seasonId);
	_msg.composeBOOL(isPlayMoney);
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	_parser.parseUINT32(seasonId);
	_parser.parseBOOL(isPlayMoney);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_SEASON_STATS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 seasonId; _parser.parseUINT32(seasonId);
	AtfValidator::validateInt(_descr, "seasonId", seasonId, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    ClubSeasonUserStats
//=================================================================

hglobby::lobby_client::ClubSeasonUserStats::ClubSeasonUserStats()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::ClubSeasonUserStats::ClubSeasonUserStats(ClubSeasonUserStats&& _o)
	: userId(std::move(_o.userId))
	, userCity(std::move(_o.userCity))
	, userAvatar(std::move(_o.userAvatar))
	, qualifiedGames(std::move(_o.qualifiedGames))
	, bestTournPlace(std::move(_o.bestTournPlace))
	, bestTournPlaceTo(std::move(_o.bestTournPlaceTo))
	, playersInbestTourn(std::move(_o.playersInbestTourn))
	, worstTournPlace(std::move(_o.worstTournPlace))
	, worstTournPlaceTo(std::move(_o.worstTournPlaceTo))
	, playersInWorstTourn(std::move(_o.playersInWorstTourn))
	, inTheMoney(std::move(_o.inTheMoney))
	, points(std::move(_o.points))
	, goldFinishes(std::move(_o.goldFinishes))
	, silverFinishes(std::move(_o.silverFinishes))
	, bronzeFinishes(std::move(_o.bronzeFinishes))
	, averagePlace(std::move(_o.averagePlace))
	, rank(std::move(_o.rank))
	, knockouts(std::move(_o.knockouts))
	, memberFrom(std::move(_o.memberFrom))
{
}

hglobby::lobby_client::ClubSeasonUserStats& hglobby::lobby_client::ClubSeasonUserStats::operator=(ClubSeasonUserStats&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		userCity = std::move(_o.userCity);
		userAvatar = std::move(_o.userAvatar);
		qualifiedGames = std::move(_o.qualifiedGames);
		bestTournPlace = std::move(_o.bestTournPlace);
		bestTournPlaceTo = std::move(_o.bestTournPlaceTo);
		playersInbestTourn = std::move(_o.playersInbestTourn);
		worstTournPlace = std::move(_o.worstTournPlace);
		worstTournPlaceTo = std::move(_o.worstTournPlaceTo);
		playersInWorstTourn = std::move(_o.playersInWorstTourn);
		inTheMoney = std::move(_o.inTheMoney);
		points = std::move(_o.points);
		goldFinishes = std::move(_o.goldFinishes);
		silverFinishes = std::move(_o.silverFinishes);
		bronzeFinishes = std::move(_o.bronzeFinishes);
		averagePlace = std::move(_o.averagePlace);
		rank = std::move(_o.rank);
		knockouts = std::move(_o.knockouts);
		memberFrom = std::move(_o.memberFrom);
	}
	return *this;
}

#endif

void hglobby::lobby_client::ClubSeasonUserStats::clear()
{
	userId.clear();
	userCity.clear();
	userAvatar = 0;
	qualifiedGames = 0;
	bestTournPlace = 0;
	bestTournPlaceTo = 0;
	playersInbestTourn = 0;
	worstTournPlace = 0;
	worstTournPlaceTo = 0;
	playersInWorstTourn = 0;
	inTheMoney = 0;
	points = 0;
	goldFinishes = 0;
	silverFinishes = 0;
	bronzeFinishes = 0;
	averagePlace = 0;
	rank = 0;
	knockouts = 0;
	memberFrom.setNull();
}

bool hglobby::lobby_client::ClubSeasonUserStats::equals(const ClubSeasonUserStats& _o) const
{
	return userId.equals(_o.userId) &&
		userCity.equals(_o.userCity) &&
		userAvatar == _o.userAvatar &&
		qualifiedGames == _o.qualifiedGames &&
		bestTournPlace == _o.bestTournPlace &&
		bestTournPlaceTo == _o.bestTournPlaceTo &&
		playersInbestTourn == _o.playersInbestTourn &&
		worstTournPlace == _o.worstTournPlace &&
		worstTournPlaceTo == _o.worstTournPlaceTo &&
		playersInWorstTourn == _o.playersInWorstTourn &&
		inTheMoney == _o.inTheMoney &&
		points == _o.points &&
		goldFinishes == _o.goldFinishes &&
		silverFinishes == _o.silverFinishes &&
		bronzeFinishes == _o.bronzeFinishes &&
		averagePlace == _o.averagePlace &&
		rank == _o.rank &&
		knockouts == _o.knockouts &&
		memberFrom.equals(_o.memberFrom);
}

const char *hglobby::lobby_client::ClubSeasonUserStats::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("userCity=");
	_buf.append(userCity);
	_buf.append(',');
	_buf.append("userAvatar=");
	_buf.appendUint(userAvatar);
	_buf.append(',');
	_buf.append("qualifiedGames=");
	_buf.appendUint(qualifiedGames);
	_buf.append(',');
	_buf.append("bestTournPlace=");
	_buf.appendUint(bestTournPlace);
	_buf.append(',');
	_buf.append("bestTournPlaceTo=");
	_buf.appendUint(bestTournPlaceTo);
	_buf.append(',');
	_buf.append("playersInbestTourn=");
	_buf.appendUint(playersInbestTourn);
	_buf.append(',');
	_buf.append("worstTournPlace=");
	_buf.appendUint(worstTournPlace);
	_buf.append(',');
	_buf.append("worstTournPlaceTo=");
	_buf.appendUint(worstTournPlaceTo);
	_buf.append(',');
	_buf.append("playersInWorstTourn=");
	_buf.appendUint(playersInWorstTourn);
	_buf.append(',');
	_buf.append("inTheMoney=");
	_buf.appendUint(inTheMoney);
	_buf.append(',');
	_buf.append("points=");
	_buf.appendUint64(points);
	_buf.append(',');
	_buf.append("goldFinishes=");
	_buf.appendUint(goldFinishes);
	_buf.append(',');
	_buf.append("silverFinishes=");
	_buf.appendUint(silverFinishes);
	_buf.append(',');
	_buf.append("bronzeFinishes=");
	_buf.appendUint(bronzeFinishes);
	_buf.append(',');
	_buf.append("averagePlace=");
	_buf.appendUint(averagePlace);
	_buf.append(',');
	_buf.append("rank=");
	_buf.appendUint(rank);
	_buf.append(',');
	_buf.append("knockouts=");
	_buf.appendUint(knockouts);
	_buf.append(',');
	_buf.append("memberFrom=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, memberFrom);
	_buf.append('}');
	return _buf.c_str();
}

void hglobby::lobby_client::ClubSeasonUserStats::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(ClubSeasonUserStats())) // not empty
	{
		_body.composeString(userId);
		_body.composeString(userCity);
		_body.composeUINT32(userAvatar);
		_body.composeUINT32(qualifiedGames);
		_body.composeUINT32(bestTournPlace);
		_body.composeUINT32(bestTournPlaceTo);
		_body.composeUINT32(playersInbestTourn);
		_body.composeUINT32(worstTournPlace);
		_body.composeUINT32(worstTournPlaceTo);
		_body.composeUINT32(playersInWorstTourn);
		_body.composeUINT32(inTheMoney);
		_body.composeUINT64(points);
		_body.composeUINT32(goldFinishes);
		_body.composeUINT32(silverFinishes);
		_body.composeUINT32(bronzeFinishes);
		_body.composeUINT32(averagePlace);
		_body.composeUINT32(rank);
		_body.composeUINT32(knockouts);
		_body.composeSrvTime(memberFrom);
	}

	_msg.composeMsgBody(_body);
}

void hglobby::lobby_client::ClubSeasonUserStats::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(userId);
	_parser0.parseStringP(userCity);
	_parser0.parseUINT32(userAvatar);
	_parser0.parseUINT32(qualifiedGames);
	_parser0.parseUINT32(bestTournPlace);
	_parser0.parseUINT32(bestTournPlaceTo);
	_parser0.parseUINT32(playersInbestTourn);
	_parser0.parseUINT32(worstTournPlace);
	_parser0.parseUINT32(worstTournPlaceTo);
	_parser0.parseUINT32(playersInWorstTourn);
	_parser0.parseUINT32(inTheMoney);
	_parser0.parseUINT64(points);
	_parser0.parseUINT32(goldFinishes);
	_parser0.parseUINT32(silverFinishes);
	_parser0.parseUINT32(bronzeFinishes);
	_parser0.parseUINT32(averagePlace);
	_parser0.parseUINT32(rank);
	_parser0.parseUINT32(knockouts);
	_parser0.parseSrvTime(memberFrom);
}

/*static*/ void hglobby::lobby_client::ClubSeasonUserStats::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "userCity"); size_t szUserCity = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userCity", szUserCity, _checker, __FILE__, __LINE__);
	UINT32 userAvatar; _parser0.parseUINT32(userAvatar);
	AtfValidator::validateInt(_descr, "userAvatar", userAvatar, _checker, __FILE__, __LINE__);
	UINT32 qualifiedGames; _parser0.parseUINT32(qualifiedGames);
	AtfValidator::validateInt(_descr, "qualifiedGames", qualifiedGames, _checker, __FILE__, __LINE__);
	UINT32 bestTournPlace; _parser0.parseUINT32(bestTournPlace);
	AtfValidator::validateInt(_descr, "bestTournPlace", bestTournPlace, _checker, __FILE__, __LINE__);
	UINT32 bestTournPlaceTo; _parser0.parseUINT32(bestTournPlaceTo);
	AtfValidator::validateInt(_descr, "bestTournPlaceTo", bestTournPlaceTo, _checker, __FILE__, __LINE__);
	UINT32 playersInbestTourn; _parser0.parseUINT32(playersInbestTourn);
	AtfValidator::validateInt(_descr, "playersInbestTourn", playersInbestTourn, _checker, __FILE__, __LINE__);
	UINT32 worstTournPlace; _parser0.parseUINT32(worstTournPlace);
	AtfValidator::validateInt(_descr, "worstTournPlace", worstTournPlace, _checker, __FILE__, __LINE__);
	UINT32 worstTournPlaceTo; _parser0.parseUINT32(worstTournPlaceTo);
	AtfValidator::validateInt(_descr, "worstTournPlaceTo", worstTournPlaceTo, _checker, __FILE__, __LINE__);
	UINT32 playersInWorstTourn; _parser0.parseUINT32(playersInWorstTourn);
	AtfValidator::validateInt(_descr, "playersInWorstTourn", playersInWorstTourn, _checker, __FILE__, __LINE__);
	UINT32 inTheMoney; _parser0.parseUINT32(inTheMoney);
	AtfValidator::validateInt(_descr, "inTheMoney", inTheMoney, _checker, __FILE__, __LINE__);
	UINT64 points; _parser0.parseUINT64(points);
	AtfValidator::validateUint(_descr, "points", points, _checker, __FILE__, __LINE__);
	UINT32 goldFinishes; _parser0.parseUINT32(goldFinishes);
	AtfValidator::validateInt(_descr, "goldFinishes", goldFinishes, _checker, __FILE__, __LINE__);
	UINT32 silverFinishes; _parser0.parseUINT32(silverFinishes);
	AtfValidator::validateInt(_descr, "silverFinishes", silverFinishes, _checker, __FILE__, __LINE__);
	UINT32 bronzeFinishes; _parser0.parseUINT32(bronzeFinishes);
	AtfValidator::validateInt(_descr, "bronzeFinishes", bronzeFinishes, _checker, __FILE__, __LINE__);
	UINT32 averagePlace; _parser0.parseUINT32(averagePlace);
	AtfValidator::validateInt(_descr, "averagePlace", averagePlace, _checker, __FILE__, __LINE__);
	UINT32 rank; _parser0.parseUINT32(rank);
	AtfValidator::validateInt(_descr, "rank", rank, _checker, __FILE__, __LINE__);
	UINT32 knockouts; _parser0.parseUINT32(knockouts);
	AtfValidator::validateInt(_descr, "knockouts", knockouts, _checker, __FILE__, __LINE__);
	SrvTime memberFrom; _parser0.parseSrvTime(memberFrom);
	AtfValidator::validateSrvDateTime(_descr, "memberFrom", memberFrom, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_HG_GET_CLUB_SEASON_STATS_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS_REPLY::Protocol_HG_GET_CLUB_SEASON_STATS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS_REPLY::Protocol_HG_GET_CLUB_SEASON_STATS_REPLY(Protocol_HG_GET_CLUB_SEASON_STATS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, stats(std::move(_o.stats))
{
}

hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS_REPLY& hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS_REPLY::operator=(Protocol_HG_GET_CLUB_SEASON_STATS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		stats = std::move(_o.stats);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	stats.clear();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS_REPLY::equals(const Protocol_HG_GET_CLUB_SEASON_STATS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		stats.equals(_o.stats);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_SEASON_STATS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("stats=");
		stats.toTraceString(_buf);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		stats.composeMsg(_msg);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		stats.parseMsg(_parser);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_SEASON_STATS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szStats = ThinAtf::LAtfVector< ClubSeasonUserStats, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("stats"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "stats", szStats, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_RECENT_TOURN_SUMMARIES
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES::Protocol_HG_GET_RECENT_TOURN_SUMMARIES()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES::clear()
{
	clubId = 0;
}

bool hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES::equals(const Protocol_HG_GET_RECENT_TOURN_SUMMARIES& _o) const
{
	return clubId == _o.clubId;
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_RECENT_TOURN_SUMMARIES).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(clubId);
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_RECENT_TOURN_SUMMARIES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    ClubRecentTournamentSummary
//=================================================================

hglobby::lobby_client::ClubRecentTournamentSummary::ClubRecentTournamentSummary()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::ClubRecentTournamentSummary::ClubRecentTournamentSummary(ClubRecentTournamentSummary&& _o)
	: tournId(std::move(_o.tournId))
	, tournName(std::move(_o.tournName))
	, currency(std::move(_o.currency))
	, started(std::move(_o.started))
	, closed(std::move(_o.closed))
	, numPlayers(std::move(_o.numPlayers))
	, prizePool(std::move(_o.prizePool))
	, seasonId(std::move(_o.seasonId))
	, playMoney(std::move(_o.playMoney))
	, rebuys(std::move(_o.rebuys))
	, rebuyRake(std::move(_o.rebuyRake))
	, countingToStats(std::move(_o.countingToStats))
	, scalePM(std::move(_o.scalePM))
{
}

hglobby::lobby_client::ClubRecentTournamentSummary& hglobby::lobby_client::ClubRecentTournamentSummary::operator=(ClubRecentTournamentSummary&& _o)
{
	if(this != &_o)
	{
		tournId = std::move(_o.tournId);
		tournName = std::move(_o.tournName);
		currency = std::move(_o.currency);
		started = std::move(_o.started);
		closed = std::move(_o.closed);
		numPlayers = std::move(_o.numPlayers);
		prizePool = std::move(_o.prizePool);
		seasonId = std::move(_o.seasonId);
		playMoney = std::move(_o.playMoney);
		rebuys = std::move(_o.rebuys);
		rebuyRake = std::move(_o.rebuyRake);
		countingToStats = std::move(_o.countingToStats);
		scalePM = std::move(_o.scalePM);
	}
	return *this;
}

#endif

void hglobby::lobby_client::ClubRecentTournamentSummary::clear()
{
	tournId = 0;
	tournName.clear();
	currency.clear();
	started.setNull();
	closed.setNull();
	numPlayers = 0;
	prizePool = 0;
	seasonId = 0;
	playMoney = false;
	rebuys = 0;
	rebuyRake = 0;
	countingToStats = false;
	scalePM = 0;
}

bool hglobby::lobby_client::ClubRecentTournamentSummary::equals(const ClubRecentTournamentSummary& _o) const
{
	return tournId == _o.tournId &&
		tournName.equals(_o.tournName) &&
		currency.equals(_o.currency) &&
		started.equals(_o.started) &&
		closed.equals(_o.closed) &&
		numPlayers == _o.numPlayers &&
		prizePool == _o.prizePool &&
		seasonId == _o.seasonId &&
		playMoney == _o.playMoney &&
		rebuys == _o.rebuys &&
		rebuyRake == _o.rebuyRake &&
		countingToStats == _o.countingToStats &&
		scalePM == _o.scalePM;
}

const char *hglobby::lobby_client::ClubRecentTournamentSummary::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("tournName=");
	_buf.append(tournName);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("started=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, started);
	_buf.append(',');
	_buf.append("closed=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, closed);
	_buf.append(',');
	_buf.append("numPlayers=");
	_buf.appendUint(numPlayers);
	_buf.append(',');
	_buf.append("prizePool=");
	_buf.appendUint64(prizePool);
	_buf.append(',');
	_buf.append("seasonId=");
	_buf.appendUint(seasonId);
	_buf.append(',');
	_buf.append("playMoney=");
	_buf.appendUint(playMoney);
	_buf.append(',');
	_buf.append("rebuys=");
	_buf.appendUint(rebuys);
	_buf.append(',');
	_buf.append("rebuyRake=");
	_buf.appendUint(rebuyRake);
	_buf.append(',');
	_buf.append("countingToStats=");
	_buf.appendUint(countingToStats);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendInt(scalePM);
	_buf.append('}');
	return _buf.c_str();
}

void hglobby::lobby_client::ClubRecentTournamentSummary::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(ClubRecentTournamentSummary())) // not empty
	{
		_body.composeUINT32(tournId);
		_body.composeString(tournName);
		_body.composeString(currency);
		_body.composeSrvTime(started);
		_body.composeSrvTime(closed);
		_body.composeUINT32(numPlayers);
		_body.composeUINT64(prizePool);
		_body.composeUINT32(seasonId);
		_body.composeBOOL(playMoney);
		_body.composeUINT32(rebuys);
		_body.composeUINT32(rebuyRake);
		_body.composeBOOL(countingToStats);
		_body.composeINT32(scalePM);
	}

	_msg.composeMsgBody(_body);
}

void hglobby::lobby_client::ClubRecentTournamentSummary::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(tournId);
	_parser0.parseStringP(tournName);
	_parser0.parseStringP(currency);
	_parser0.parseSrvTime(started);
	_parser0.parseSrvTime(closed);
	_parser0.parseUINT32(numPlayers);
	_parser0.parseUINT64(prizePool);
	_parser0.parseUINT32(seasonId);
	_parser0.parseBOOL(playMoney);
	_parser0.parseUINT32(rebuys);
	_parser0.parseUINT32(rebuyRake);
	_parser0.parseBOOL(countingToStats);
	_parser0.parseINT32(scalePM);
}

/*static*/ void hglobby::lobby_client::ClubRecentTournamentSummary::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 tournId; _parser0.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "tournName"); size_t szTournName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tournName", szTournName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	SrvTime started; _parser0.parseSrvTime(started);
	AtfValidator::validateSrvDateTime(_descr, "started", started, _checker, __FILE__, __LINE__);
	SrvTime closed; _parser0.parseSrvTime(closed);
	AtfValidator::validateSrvDateTime(_descr, "closed", closed, _checker, __FILE__, __LINE__);
	UINT32 numPlayers; _parser0.parseUINT32(numPlayers);
	AtfValidator::validateInt(_descr, "numPlayers", numPlayers, _checker, __FILE__, __LINE__);
	UINT64 prizePool; _parser0.parseUINT64(prizePool);
	AtfValidator::validateUint(_descr, "prizePool", prizePool, _checker, __FILE__, __LINE__);
	UINT32 seasonId; _parser0.parseUINT32(seasonId);
	AtfValidator::validateInt(_descr, "seasonId", seasonId, _checker, __FILE__, __LINE__);
	bool playMoney; _parser0.parseBOOL(playMoney);
	AtfValidator::validateInt(_descr, "playMoney", playMoney, _checker, __FILE__, __LINE__);
	UINT32 rebuys; _parser0.parseUINT32(rebuys);
	AtfValidator::validateInt(_descr, "rebuys", rebuys, _checker, __FILE__, __LINE__);
	UINT32 rebuyRake; _parser0.parseUINT32(rebuyRake);
	AtfValidator::validateInt(_descr, "rebuyRake", rebuyRake, _checker, __FILE__, __LINE__);
	bool countingToStats; _parser0.parseBOOL(countingToStats);
	AtfValidator::validateInt(_descr, "countingToStats", countingToStats, _checker, __FILE__, __LINE__);
	INT32 scalePM; _parser0.parseINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY(Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, summaries(std::move(_o.summaries))
{
}

hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY& hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY::operator=(Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		summaries = std::move(_o.summaries);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	summaries.clear();
}

bool hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY::equals(const Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		summaries.equals(_o.summaries);
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_RECENT_TOURN_SUMMARIES_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("summaries=");
		summaries.toTraceString(_buf);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		summaries.composeMsg(_msg);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		summaries.parseMsg(_parser);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_RECENT_TOURN_SUMMARIES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szSummaries = ThinAtf::LAtfVector< ClubRecentTournamentSummary, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("summaries"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "summaries", szSummaries, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_RECENT_TOURN_RESULTS
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS::Protocol_HG_GET_RECENT_TOURN_RESULTS()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS::clear()
{
	tournId = 0;
}

bool hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS::equals(const Protocol_HG_GET_RECENT_TOURN_RESULTS& _o) const
{
	return tournId == _o.tournId;
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_RECENT_TOURN_RESULTS).append(")");
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(tournId);
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tournId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_RECENT_TOURN_RESULTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    ClubRecentTournPlayerResult
//=================================================================

hglobby::lobby_client::ClubRecentTournPlayerResult::ClubRecentTournPlayerResult()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::ClubRecentTournPlayerResult::ClubRecentTournPlayerResult(ClubRecentTournPlayerResult&& _o)
	: tournRank(std::move(_o.tournRank))
	, userId(std::move(_o.userId))
	, place(std::move(_o.place))
	, placeTo(std::move(_o.placeTo))
	, prize(std::move(_o.prize))
	, pointsEarned(std::move(_o.pointsEarned))
	, knockouts(std::move(_o.knockouts))
	, scalePM(std::move(_o.scalePM))
{
}

hglobby::lobby_client::ClubRecentTournPlayerResult& hglobby::lobby_client::ClubRecentTournPlayerResult::operator=(ClubRecentTournPlayerResult&& _o)
{
	if(this != &_o)
	{
		tournRank = std::move(_o.tournRank);
		userId = std::move(_o.userId);
		place = std::move(_o.place);
		placeTo = std::move(_o.placeTo);
		prize = std::move(_o.prize);
		pointsEarned = std::move(_o.pointsEarned);
		knockouts = std::move(_o.knockouts);
		scalePM = std::move(_o.scalePM);
	}
	return *this;
}

#endif

void hglobby::lobby_client::ClubRecentTournPlayerResult::clear()
{
	tournRank = 0;
	userId.clear();
	place = 0;
	placeTo = 0;
	prize = 0;
	pointsEarned = 0;
	knockouts = 0;
	scalePM = 0;
}

bool hglobby::lobby_client::ClubRecentTournPlayerResult::equals(const ClubRecentTournPlayerResult& _o) const
{
	return tournRank == _o.tournRank &&
		userId.equals(_o.userId) &&
		place == _o.place &&
		placeTo == _o.placeTo &&
		prize == _o.prize &&
		pointsEarned == _o.pointsEarned &&
		knockouts == _o.knockouts &&
		scalePM == _o.scalePM;
}

const char *hglobby::lobby_client::ClubRecentTournPlayerResult::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournRank=");
	_buf.appendUint(tournRank);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("place=");
	_buf.appendUint(place);
	_buf.append(',');
	_buf.append("placeTo=");
	_buf.appendUint(placeTo);
	_buf.append(',');
	_buf.append("prize=");
	_buf.appendUint(prize);
	_buf.append(',');
	_buf.append("pointsEarned=");
	_buf.appendUint(pointsEarned);
	_buf.append(',');
	_buf.append("knockouts=");
	_buf.appendUint(knockouts);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendInt(scalePM);
	_buf.append('}');
	return _buf.c_str();
}

void hglobby::lobby_client::ClubRecentTournPlayerResult::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(ClubRecentTournPlayerResult())) // not empty
	{
		_body.composeUINT32(tournRank);
		_body.composeString(userId);
		_body.composeUINT32(place);
		_body.composeUINT32(placeTo);
		_body.composeUINT32(prize);
		_body.composeUINT32(pointsEarned);
		_body.composeUINT32(knockouts);
		_body.composeINT32(scalePM);
	}

	_msg.composeMsgBody(_body);
}

void hglobby::lobby_client::ClubRecentTournPlayerResult::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(tournRank);
	_parser0.parseStringP(userId);
	_parser0.parseUINT32(place);
	_parser0.parseUINT32(placeTo);
	_parser0.parseUINT32(prize);
	_parser0.parseUINT32(pointsEarned);
	_parser0.parseUINT32(knockouts);
	_parser0.parseINT32(scalePM);
}

/*static*/ void hglobby::lobby_client::ClubRecentTournPlayerResult::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 tournRank; _parser0.parseUINT32(tournRank);
	AtfValidator::validateInt(_descr, "tournRank", tournRank, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	UINT32 place; _parser0.parseUINT32(place);
	AtfValidator::validateInt(_descr, "place", place, _checker, __FILE__, __LINE__);
	UINT32 placeTo; _parser0.parseUINT32(placeTo);
	AtfValidator::validateInt(_descr, "placeTo", placeTo, _checker, __FILE__, __LINE__);
	UINT32 prize; _parser0.parseUINT32(prize);
	AtfValidator::validateInt(_descr, "prize", prize, _checker, __FILE__, __LINE__);
	UINT32 pointsEarned; _parser0.parseUINT32(pointsEarned);
	AtfValidator::validateInt(_descr, "pointsEarned", pointsEarned, _checker, __FILE__, __LINE__);
	UINT32 knockouts; _parser0.parseUINT32(knockouts);
	AtfValidator::validateInt(_descr, "knockouts", knockouts, _checker, __FILE__, __LINE__);
	INT32 scalePM; _parser0.parseINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY(Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, tournResults(std::move(_o.tournResults))
{
}

hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY& hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY::operator=(Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		tournResults = std::move(_o.tournResults);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	tournResults.clear();
}

bool hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY::equals(const Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		tournResults.equals(_o.tournResults);
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_RECENT_TOURN_RESULTS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("tournResults=");
		tournResults.toTraceString(_buf);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		tournResults.composeMsg(_msg);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		tournResults.parseMsg(_parser);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_RECENT_TOURN_RESULTS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szTournResults = ThinAtf::LAtfVector< ClubRecentTournPlayerResult, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournResults"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tournResults", szTournResults, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_SET_CLUB_COLOR
//=================================================================

hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR::Protocol_HG_SET_CLUB_COLOR()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR::clear()
{
	clubId = 0;
	color = 0;
}

bool hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR::equals(const Protocol_HG_SET_CLUB_COLOR& _o) const
{
	return clubId == _o.clubId &&
		color == _o.color;
}

const char *hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_SET_CLUB_COLOR).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("color=");
	_buf.appendUint(color);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(clubId);
	_msg.composeUINT32(color);
}

void hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	_parser.parseUINT32(color);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_SET_CLUB_COLOR";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 color; _parser.parseUINT32(color);
	AtfValidator::validateInt(_descr, "color", color, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_SET_CLUB_COLOR_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR_REPLY::Protocol_HG_SET_CLUB_COLOR_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR_REPLY::Protocol_HG_SET_CLUB_COLOR_REPLY(Protocol_HG_SET_CLUB_COLOR_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR_REPLY& hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR_REPLY::operator=(Protocol_HG_SET_CLUB_COLOR_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR_REPLY::equals(const Protocol_HG_SET_CLUB_COLOR_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc);
}

const char *hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_SET_CLUB_COLOR_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_SET_CLUB_COLOR_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CHANGE_CLUB_NAME
//=================================================================

hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME::Protocol_HG_CHANGE_CLUB_NAME()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME::Protocol_HG_CHANGE_CLUB_NAME(Protocol_HG_CHANGE_CLUB_NAME&& _o)
	: clubId(std::move(_o.clubId))
	, clubName(std::move(_o.clubName))
{
}

hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME& hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME::operator=(Protocol_HG_CHANGE_CLUB_NAME&& _o)
{
	if(this != &_o)
	{
		clubId = std::move(_o.clubId);
		clubName = std::move(_o.clubName);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME::clear()
{
	clubId = 0;
	clubName.clear();
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME::equals(const Protocol_HG_CHANGE_CLUB_NAME& _o) const
{
	return clubId == _o.clubId &&
		clubName.equals(_o.clubName);
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CHANGE_CLUB_NAME).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("clubName=");
	_buf.append(clubName);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(clubId);
	_msg.composeString(clubName);
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	_parser.parseStringP(clubName);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CHANGE_CLUB_NAME";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "clubName"); size_t szClubName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "clubName", szClubName, 128, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CHANGE_CLUB_NAME_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME_REPLY::Protocol_HG_CHANGE_CLUB_NAME_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME_REPLY::Protocol_HG_CHANGE_CLUB_NAME_REPLY(Protocol_HG_CHANGE_CLUB_NAME_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME_REPLY& hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME_REPLY::operator=(Protocol_HG_CHANGE_CLUB_NAME_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME_REPLY::equals(const Protocol_HG_CHANGE_CLUB_NAME_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc);
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CHANGE_CLUB_NAME_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CHANGE_CLUB_NAME_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUB_OPTIONS
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS::Protocol_HG_GET_CLUB_OPTIONS()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS::clear()
{
	clubId = 0;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS::equals(const Protocol_HG_GET_CLUB_OPTIONS& _o) const
{
	return clubId == _o.clubId;
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_OPTIONS).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(clubId);
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_OPTIONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUB_OPTIONS_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS_REPLY::Protocol_HG_GET_CLUB_OPTIONS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS_REPLY::Protocol_HG_GET_CLUB_OPTIONS_REPLY(Protocol_HG_GET_CLUB_OPTIONS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, clubId(std::move(_o.clubId))
	, seasonType(std::move(_o.seasonType))
	, showClubStandings(std::move(_o.showClubStandings))
	, showPlayerStats(std::move(_o.showPlayerStats))
	, currency(std::move(_o.currency))
	, showFounderFullName(std::move(_o.showFounderFullName))
{
}

hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS_REPLY& hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS_REPLY::operator=(Protocol_HG_GET_CLUB_OPTIONS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		clubId = std::move(_o.clubId);
		seasonType = std::move(_o.seasonType);
		showClubStandings = std::move(_o.showClubStandings);
		showPlayerStats = std::move(_o.showPlayerStats);
		currency = std::move(_o.currency);
		showFounderFullName = std::move(_o.showFounderFullName);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	clubId = 0;
	seasonType = 0;
	showClubStandings = false;
	showPlayerStats = false;
	currency.clear();
	showFounderFullName = false;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS_REPLY::equals(const Protocol_HG_GET_CLUB_OPTIONS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		clubId == _o.clubId &&
		seasonType == _o.seasonType &&
		showClubStandings == _o.showClubStandings &&
		showPlayerStats == _o.showPlayerStats &&
		currency.equals(_o.currency) &&
		showFounderFullName == _o.showFounderFullName;
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_OPTIONS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("clubId=");
		_buf.appendUint(clubId);
		_buf.append(',');
		_buf.append("seasonType=");
		_buf.appendUint(seasonType);
		_buf.append(',');
		_buf.append("showClubStandings=");
		_buf.appendUint(showClubStandings);
		_buf.append(',');
		_buf.append("showPlayerStats=");
		_buf.appendUint(showPlayerStats);
		_buf.append(',');
		_buf.append("currency=");
		_buf.append(currency);
		_buf.append(',');
		_buf.append("showFounderFullName=");
		_buf.appendUint(showFounderFullName);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeUINT32(clubId);
		_msg.composeUINT32(seasonType);
		_msg.composeBOOL(showClubStandings);
		_msg.composeBOOL(showPlayerStats);
		_msg.composeString(currency);
		_msg.composeBOOL(showFounderFullName);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseUINT32(clubId);
		_parser.parseUINT32(seasonType);
		_parser.parseBOOL(showClubStandings);
		_parser.parseBOOL(showPlayerStats);
		_parser.parseStringP(currency);
		_parser.parseBOOL(showFounderFullName);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_OPTIONS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 clubId; _parser.parseUINT32(clubId);
		AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
		UINT32 seasonType; _parser.parseUINT32(seasonType);
		AtfValidator::validateInt(_descr, "seasonType", seasonType, _checker, __FILE__, __LINE__);
		bool showClubStandings; _parser.parseBOOL(showClubStandings);
		AtfValidator::validateInt(_descr, "showClubStandings", showClubStandings, _checker, __FILE__, __LINE__);
		bool showPlayerStats; _parser.parseBOOL(showPlayerStats);
		AtfValidator::validateInt(_descr, "showPlayerStats", showPlayerStats, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
		bool showFounderFullName; _parser.parseBOOL(showFounderFullName);
		AtfValidator::validateInt(_descr, "showFounderFullName", showFounderFullName, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUB_TOURN_STRUCTURES
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES::Protocol_HG_GET_CLUB_TOURN_STRUCTURES()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES::clear()
{
	clubId = 0;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES::equals(const Protocol_HG_GET_CLUB_TOURN_STRUCTURES& _o) const
{
	return clubId == _o.clubId;
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_TOURN_STRUCTURES).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(clubId);
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_TOURN_STRUCTURES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    GameStructure
//=================================================================

hglobby::lobby_client::GameStructure::GameStructure()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::GameStructure::GameStructure(GameStructure&& _o)
	: handType(std::move(_o.handType))
	, isHiLo(std::move(_o.isHiLo))
	, description(std::move(_o.description))
	, potTypes(std::move(_o.potTypes))
	, tableSizes(std::move(_o.tableSizes))
	, moneyTypes(std::move(_o.moneyTypes))
{
}

hglobby::lobby_client::GameStructure& hglobby::lobby_client::GameStructure::operator=(GameStructure&& _o)
{
	if(this != &_o)
	{
		handType = std::move(_o.handType);
		isHiLo = std::move(_o.isHiLo);
		description = std::move(_o.description);
		potTypes = std::move(_o.potTypes);
		tableSizes = std::move(_o.tableSizes);
		moneyTypes = std::move(_o.moneyTypes);
	}
	return *this;
}

#endif

void hglobby::lobby_client::GameStructure::clear()
{
	handType = 0;
	isHiLo = false;
	description.clear();
	potTypes.clear();
	tableSizes.clear();
	moneyTypes.clear();
}

bool hglobby::lobby_client::GameStructure::equals(const GameStructure& _o) const
{
	return handType == _o.handType &&
		isHiLo == _o.isHiLo &&
		description.equals(_o.description) &&
		potTypes.equals(_o.potTypes) &&
		tableSizes.equals(_o.tableSizes) &&
		moneyTypes.equals(_o.moneyTypes);
}

const char *hglobby::lobby_client::GameStructure::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("handType=");
	_buf.appendUint(handType);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("description=");
	_buf.append(description);
	_buf.append(',');
	_buf.append("potTypes=");
	potTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableSizes=");
	tableSizes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("moneyTypes=");
	moneyTypes.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void hglobby::lobby_client::GameStructure::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(GameStructure())) // not empty
	{
		_body.composeBYTE(handType);
		_body.composeBOOL(isHiLo);
		_body.composeString(description);
		potTypes.composeMsg(_body);
		tableSizes.composeMsg(_body);
		moneyTypes.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void hglobby::lobby_client::GameStructure::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(handType);
	_parser0.parseBOOL(isHiLo);
	_parser0.parseStringP(description);
	potTypes.parseMsg(_parser0);
	tableSizes.parseMsg(_parser0);
	moneyTypes.parseMsg(_parser0);
}

/*static*/ void hglobby::lobby_client::GameStructure::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	BYTE handType; _parser0.parseBYTE(handType);
	AtfValidator::validateInt(_descr, "handType", handType, _checker, __FILE__, __LINE__);
	bool isHiLo; _parser0.parseBOOL(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "description"); size_t szDescription = strlen(_dummy);
	AtfValidator::validateInt(_descr, "description", szDescription, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szPotTypes = ThinAtf::LAtfVector< BYTE, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("potTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "potTypes", szPotTypes, _checker, __FILE__, __LINE__);
	int szTableSizes = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tableSizes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tableSizes", szTableSizes, _checker, __FILE__, __LINE__);
	int szMoneyTypes = ThinAtf::LAtfVector< bool, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("moneyTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "moneyTypes", szMoneyTypes, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TournBuyIn
//=================================================================

hglobby::lobby_client::TournBuyIn::TournBuyIn()
{
	clear();
}

void hglobby::lobby_client::TournBuyIn::clear()
{
	buyIn = 0;
	rake = 0;
	bounty = 0;
}

bool hglobby::lobby_client::TournBuyIn::equals(const TournBuyIn& _o) const
{
	return buyIn == _o.buyIn &&
		rake == _o.rake &&
		bounty == _o.bounty;
}

const char *hglobby::lobby_client::TournBuyIn::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("buyIn=");
	_buf.appendUint(buyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendUint(rake);
	_buf.append(',');
	_buf.append("bounty=");
	_buf.appendUint(bounty);
	_buf.append('}');
	return _buf.c_str();
}

void hglobby::lobby_client::TournBuyIn::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(TournBuyIn())) // not empty
	{
		_body.composeUINT32(buyIn);
		_body.composeUINT32(rake);
		_body.composeUINT32(bounty);
	}

	_msg.composeMsgBody(_body);
}

void hglobby::lobby_client::TournBuyIn::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(buyIn);
	_parser0.parseUINT32(rake);
	_parser0.parseUINT32(bounty);
}

/*static*/ void hglobby::lobby_client::TournBuyIn::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 buyIn; _parser0.parseUINT32(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT32 rake; _parser0.parseUINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	UINT32 bounty; _parser0.parseUINT32(bounty);
	AtfValidator::validateInt(_descr, "bounty", bounty, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TournBuyIn2
//=================================================================

hglobby::lobby_client::TournBuyIn2::TournBuyIn2()
{
	clear();
}

void hglobby::lobby_client::TournBuyIn2::clear()
{
	buyIn = 0;
	rake = 0;
	bounty = 0;
	scalePM = 0;
}

bool hglobby::lobby_client::TournBuyIn2::equals(const TournBuyIn2& _o) const
{
	return buyIn == _o.buyIn &&
		rake == _o.rake &&
		bounty == _o.bounty &&
		scalePM == _o.scalePM;
}

const char *hglobby::lobby_client::TournBuyIn2::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("buyIn=");
	_buf.appendUint(buyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendUint(rake);
	_buf.append(',');
	_buf.append("bounty=");
	_buf.appendUint(bounty);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append('}');
	return _buf.c_str();
}

void hglobby::lobby_client::TournBuyIn2::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(TournBuyIn2())) // not empty
	{
		_body.composeUINT32(buyIn);
		_body.composeUINT32(rake);
		_body.composeUINT32(bounty);
		_body.composeUINT32(scalePM);
	}

	_msg.composeMsgBody(_body);
}

void hglobby::lobby_client::TournBuyIn2::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(buyIn);
	_parser0.parseUINT32(rake);
	_parser0.parseUINT32(bounty);
	_parser0.parseUINT32(scalePM);
}

/*static*/ void hglobby::lobby_client::TournBuyIn2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 buyIn; _parser0.parseUINT32(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT32 rake; _parser0.parseUINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	UINT32 bounty; _parser0.parseUINT32(bounty);
	AtfValidator::validateInt(_descr, "bounty", bounty, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser0.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TournCurrencyBuyIns
//=================================================================

hglobby::lobby_client::TournCurrencyBuyIns::TournCurrencyBuyIns()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::TournCurrencyBuyIns::TournCurrencyBuyIns(TournCurrencyBuyIns&& _o)
	: currency(std::move(_o.currency))
	, tournBuyInBodies(std::move(_o.tournBuyInBodies))
{
}

hglobby::lobby_client::TournCurrencyBuyIns& hglobby::lobby_client::TournCurrencyBuyIns::operator=(TournCurrencyBuyIns&& _o)
{
	if(this != &_o)
	{
		currency = std::move(_o.currency);
		tournBuyInBodies = std::move(_o.tournBuyInBodies);
	}
	return *this;
}

#endif

void hglobby::lobby_client::TournCurrencyBuyIns::clear()
{
	currency.clear();
	tournBuyInBodies.clear();
}

bool hglobby::lobby_client::TournCurrencyBuyIns::equals(const TournCurrencyBuyIns& _o) const
{
	return currency.equals(_o.currency) &&
		tournBuyInBodies.equals(_o.tournBuyInBodies);
}

const char *hglobby::lobby_client::TournCurrencyBuyIns::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("tournBuyInBodies=");
	tournBuyInBodies.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void hglobby::lobby_client::TournCurrencyBuyIns::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(currency);
	tournBuyInBodies.composeMsg(_msg);
}

void hglobby::lobby_client::TournCurrencyBuyIns::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(currency);
	tournBuyInBodies.parseMsg(_parser);
}

/*static*/ void hglobby::lobby_client::TournCurrencyBuyIns::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTournBuyInBodies = ThinAtf::LAtfVector< TournBuyIn, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournBuyInBodies"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tournBuyInBodies", szTournBuyInBodies, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournCurrencyBuyIns2
//=================================================================

hglobby::lobby_client::TournCurrencyBuyIns2::TournCurrencyBuyIns2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::TournCurrencyBuyIns2::TournCurrencyBuyIns2(TournCurrencyBuyIns2&& _o)
	: currency(std::move(_o.currency))
	, tournBuyInBodies(std::move(_o.tournBuyInBodies))
{
}

hglobby::lobby_client::TournCurrencyBuyIns2& hglobby::lobby_client::TournCurrencyBuyIns2::operator=(TournCurrencyBuyIns2&& _o)
{
	if(this != &_o)
	{
		currency = std::move(_o.currency);
		tournBuyInBodies = std::move(_o.tournBuyInBodies);
	}
	return *this;
}

#endif

void hglobby::lobby_client::TournCurrencyBuyIns2::clear()
{
	currency.clear();
	tournBuyInBodies.clear();
}

bool hglobby::lobby_client::TournCurrencyBuyIns2::equals(const TournCurrencyBuyIns2& _o) const
{
	return currency.equals(_o.currency) &&
		tournBuyInBodies.equals(_o.tournBuyInBodies);
}

const char *hglobby::lobby_client::TournCurrencyBuyIns2::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("tournBuyInBodies=");
	tournBuyInBodies.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void hglobby::lobby_client::TournCurrencyBuyIns2::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(currency);
	tournBuyInBodies.composeMsg(_msg);
}

void hglobby::lobby_client::TournCurrencyBuyIns2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(currency);
	tournBuyInBodies.parseMsg(_parser);
}

/*static*/ void hglobby::lobby_client::TournCurrencyBuyIns2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTournBuyInBodies = ThinAtf::LAtfVector< TournBuyIn2, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournBuyInBodies"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tournBuyInBodies", szTournBuyInBodies, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY(Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, tournKnockoutPrize(std::move(_o.tournKnockoutPrize))
	, tournMaxPlayers(std::move(_o.tournMaxPlayers))
	, tournFastDealing(std::move(_o.tournFastDealing))
	, tournSyncBreaks(std::move(_o.tournSyncBreaks))
	, tournPayouts(std::move(_o.tournPayouts))
	, tournStartingChips(std::move(_o.tournStartingChips))
	, tournLevelLengths(std::move(_o.tournLevelLengths))
	, tournFormats(std::move(_o.tournFormats))
	, gameStructures(std::move(_o.gameStructures))
	, tournBuyInsPM(std::move(_o.tournBuyInsPM))
	, currencyBuyIns(std::move(_o.currencyBuyIns))
	, isVoiceEnabled(std::move(_o.isVoiceEnabled))
	, numMaxDaysForTournCreation(std::move(_o.numMaxDaysForTournCreation))
{
}

hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY& hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY::operator=(Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		tournKnockoutPrize = std::move(_o.tournKnockoutPrize);
		tournMaxPlayers = std::move(_o.tournMaxPlayers);
		tournFastDealing = std::move(_o.tournFastDealing);
		tournSyncBreaks = std::move(_o.tournSyncBreaks);
		tournPayouts = std::move(_o.tournPayouts);
		tournStartingChips = std::move(_o.tournStartingChips);
		tournLevelLengths = std::move(_o.tournLevelLengths);
		tournFormats = std::move(_o.tournFormats);
		gameStructures = std::move(_o.gameStructures);
		tournBuyInsPM = std::move(_o.tournBuyInsPM);
		currencyBuyIns = std::move(_o.currencyBuyIns);
		isVoiceEnabled = std::move(_o.isVoiceEnabled);
		numMaxDaysForTournCreation = std::move(_o.numMaxDaysForTournCreation);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	tournKnockoutPrize = 0;
	tournMaxPlayers = 0;
	tournFastDealing.clear();
	tournSyncBreaks.clear();
	tournPayouts.clear();
	tournStartingChips.clear();
	tournLevelLengths.clear();
	tournFormats.clear();
	gameStructures.clear();
	tournBuyInsPM.clear();
	currencyBuyIns.clear();
	isVoiceEnabled = false;
	numMaxDaysForTournCreation = 0;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY::equals(const Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		tournKnockoutPrize == _o.tournKnockoutPrize &&
		tournMaxPlayers == _o.tournMaxPlayers &&
		tournFastDealing.equals(_o.tournFastDealing) &&
		tournSyncBreaks.equals(_o.tournSyncBreaks) &&
		tournPayouts.equals(_o.tournPayouts) &&
		tournStartingChips.equals(_o.tournStartingChips) &&
		tournLevelLengths.equals(_o.tournLevelLengths) &&
		tournFormats.equals(_o.tournFormats) &&
		gameStructures.equals(_o.gameStructures) &&
		tournBuyInsPM.equals(_o.tournBuyInsPM) &&
		currencyBuyIns.equals(_o.currencyBuyIns) &&
		isVoiceEnabled == _o.isVoiceEnabled &&
		numMaxDaysForTournCreation == _o.numMaxDaysForTournCreation;
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_TOURN_STRUCTURES_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("tournKnockoutPrize=");
		_buf.appendUint(tournKnockoutPrize);
		_buf.append(',');
		_buf.append("tournMaxPlayers=");
		_buf.appendUint(tournMaxPlayers);
		_buf.append(',');
		_buf.append("tournFastDealing=");
		tournFastDealing.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tournSyncBreaks=");
		tournSyncBreaks.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tournPayouts=");
		tournPayouts.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tournStartingChips=");
		tournStartingChips.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tournLevelLengths=");
		tournLevelLengths.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tournFormats=");
		tournFormats.toTraceString(_buf);
		_buf.append(',');
		_buf.append("gameStructures=");
		gameStructures.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tournBuyInsPM=");
		tournBuyInsPM.toTraceString(_buf);
		_buf.append(',');
		_buf.append("currencyBuyIns=");
		currencyBuyIns.toTraceString(_buf);
		_buf.append(',');
		_buf.append("isVoiceEnabled=");
		_buf.appendUint(isVoiceEnabled);
		_buf.append(',');
		_buf.append("numMaxDaysForTournCreation=");
		_buf.appendUint(numMaxDaysForTournCreation);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeUINT32(tournKnockoutPrize);
		_msg.composeUINT32(tournMaxPlayers);
		tournFastDealing.composeMsg(_msg);
		tournSyncBreaks.composeMsg(_msg);
		tournPayouts.composeMsg(_msg);
		tournStartingChips.composeMsg(_msg);
		tournLevelLengths.composeMsg(_msg);
		tournFormats.composeMsg(_msg);
		gameStructures.composeMsg(_msg);
		tournBuyInsPM.composeMsg(_msg);
		currencyBuyIns.composeMsg(_msg);
		_msg.composeBOOL(isVoiceEnabled);
		_msg.composeUINT32(numMaxDaysForTournCreation);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseUINT32(tournKnockoutPrize);
		_parser.parseUINT32(tournMaxPlayers);
		tournFastDealing.parseMsg(_parser);
		tournSyncBreaks.parseMsg(_parser);
		tournPayouts.parseMsg(_parser);
		tournStartingChips.parseMsg(_parser);
		tournLevelLengths.parseMsg(_parser);
		tournFormats.parseMsg(_parser);
		gameStructures.parseMsg(_parser);
		tournBuyInsPM.parseMsg(_parser);
		currencyBuyIns.parseMsg(_parser);
		_parser.parseBOOL(isVoiceEnabled);
		_parser.parseUINT32(numMaxDaysForTournCreation);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_TOURN_STRUCTURES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 tournKnockoutPrize; _parser.parseUINT32(tournKnockoutPrize);
		AtfValidator::validateInt(_descr, "tournKnockoutPrize", tournKnockoutPrize, _checker, __FILE__, __LINE__);
		UINT32 tournMaxPlayers; _parser.parseUINT32(tournMaxPlayers);
		AtfValidator::validateInt(_descr, "tournMaxPlayers", tournMaxPlayers, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szTournFastDealing = ThinAtf::LAtfVector< bool, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournFastDealing"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tournFastDealing", szTournFastDealing, _checker, __FILE__, __LINE__);
		int szTournSyncBreaks = ThinAtf::LAtfVector< bool, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournSyncBreaks"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tournSyncBreaks", szTournSyncBreaks, _checker, __FILE__, __LINE__);
		int szTournPayouts = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournPayouts"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tournPayouts", szTournPayouts, _checker, __FILE__, __LINE__);
		int szTournStartingChips = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournStartingChips"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tournStartingChips", szTournStartingChips, _checker, __FILE__, __LINE__);
		int szTournLevelLengths = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournLevelLengths"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tournLevelLengths", szTournLevelLengths, _checker, __FILE__, __LINE__);
		int szTournFormats = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournFormats"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tournFormats", szTournFormats, _checker, __FILE__, __LINE__);
		int szGameStructures = ThinAtf::LAtfVector< GameStructure, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("gameStructures"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "gameStructures", szGameStructures, _checker, __FILE__, __LINE__);
		int szTournBuyInsPM = ThinAtf::LAtfVector< TournBuyIn, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournBuyInsPM"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tournBuyInsPM", szTournBuyInsPM, _checker, __FILE__, __LINE__);
		int szCurrencyBuyIns = ThinAtf::LAtfVector< TournCurrencyBuyIns, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("currencyBuyIns"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "currencyBuyIns", szCurrencyBuyIns, _checker, __FILE__, __LINE__);
		bool isVoiceEnabled; _parser.parseBOOL(isVoiceEnabled);
		AtfValidator::validateInt(_descr, "isVoiceEnabled", isVoiceEnabled, _checker, __FILE__, __LINE__);
		UINT32 numMaxDaysForTournCreation; _parser.parseUINT32(numMaxDaysForTournCreation);
		AtfValidator::validateInt(_descr, "numMaxDaysForTournCreation", numMaxDaysForTournCreation, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUB_TABLE_STRUCTURES
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES::Protocol_HG_GET_CLUB_TABLE_STRUCTURES()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES::clear()
{
	clubId = 0;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES::equals(const Protocol_HG_GET_CLUB_TABLE_STRUCTURES& _o) const
{
	return clubId == _o.clubId;
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_TABLE_STRUCTURES).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(clubId);
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_TABLE_STRUCTURES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    TableParamsStruct
//=================================================================

hglobby::lobby_client::TableParamsStruct::TableParamsStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::TableParamsStruct::TableParamsStruct(TableParamsStruct&& _o)
	: isHiLo(std::move(_o.isHiLo))
	, tableSize(std::move(_o.tableSize))
	, isFastDealing(std::move(_o.isFastDealing))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, currency(std::move(_o.currency))
	, handType(std::move(_o.handType))
	, potStruct(std::move(_o.potStruct))
	, ante(std::move(_o.ante))
	, cap(std::move(_o.cap))
	, minBuyIn(std::move(_o.minBuyIn))
	, maxBuyIn(std::move(_o.maxBuyIn))
	, stakesLow(std::move(_o.stakesLow))
	, stakesHigh(std::move(_o.stakesHigh))
	, tableName(std::move(_o.tableName))
	, scalePM(std::move(_o.scalePM))
{
}

hglobby::lobby_client::TableParamsStruct& hglobby::lobby_client::TableParamsStruct::operator=(TableParamsStruct&& _o)
{
	if(this != &_o)
	{
		isHiLo = std::move(_o.isHiLo);
		tableSize = std::move(_o.tableSize);
		isFastDealing = std::move(_o.isFastDealing);
		isPlayMoney = std::move(_o.isPlayMoney);
		currency = std::move(_o.currency);
		handType = std::move(_o.handType);
		potStruct = std::move(_o.potStruct);
		ante = std::move(_o.ante);
		cap = std::move(_o.cap);
		minBuyIn = std::move(_o.minBuyIn);
		maxBuyIn = std::move(_o.maxBuyIn);
		stakesLow = std::move(_o.stakesLow);
		stakesHigh = std::move(_o.stakesHigh);
		tableName = std::move(_o.tableName);
		scalePM = std::move(_o.scalePM);
	}
	return *this;
}

#endif

void hglobby::lobby_client::TableParamsStruct::clear()
{
	isHiLo = false;
	tableSize = 0;
	isFastDealing = false;
	isPlayMoney = false;
	currency.clear();
	handType = 0;
	potStruct = 0;
	ante = 0;
	cap = 0;
	minBuyIn = 0;
	maxBuyIn = 0;
	stakesLow = 0;
	stakesHigh = 0;
	tableName.clear();
	scalePM = 0;
}

bool hglobby::lobby_client::TableParamsStruct::equals(const TableParamsStruct& _o) const
{
	return isHiLo == _o.isHiLo &&
		tableSize == _o.tableSize &&
		isFastDealing == _o.isFastDealing &&
		isPlayMoney == _o.isPlayMoney &&
		currency.equals(_o.currency) &&
		handType == _o.handType &&
		potStruct == _o.potStruct &&
		ante == _o.ante &&
		cap == _o.cap &&
		minBuyIn == _o.minBuyIn &&
		maxBuyIn == _o.maxBuyIn &&
		stakesLow == _o.stakesLow &&
		stakesHigh == _o.stakesHigh &&
		tableName.equals(_o.tableName) &&
		scalePM == _o.scalePM;
}

const char *hglobby::lobby_client::TableParamsStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("tableSize=");
	_buf.appendUint(tableSize);
	_buf.append(',');
	_buf.append("isFastDealing=");
	_buf.appendUint(isFastDealing);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("handType=");
	_buf.appendUint(handType);
	_buf.append(',');
	_buf.append("potStruct=");
	_buf.appendUint(potStruct);
	_buf.append(',');
	_buf.append("ante=");
	_buf.appendUint(ante);
	_buf.append(',');
	_buf.append("cap=");
	_buf.appendUint(cap);
	_buf.append(',');
	_buf.append("minBuyIn=");
	_buf.appendUint(minBuyIn);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendUint(maxBuyIn);
	_buf.append(',');
	_buf.append("stakesLow=");
	_buf.appendUint(stakesLow);
	_buf.append(',');
	_buf.append("stakesHigh=");
	_buf.appendUint(stakesHigh);
	_buf.append(',');
	_buf.append("tableName=");
	_buf.append(tableName);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendInt(scalePM);
	_buf.append('}');
	return _buf.c_str();
}

void hglobby::lobby_client::TableParamsStruct::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBOOL(isHiLo);
	_msg.composeUINT32(tableSize);
	_msg.composeBOOL(isFastDealing);
	_msg.composeBOOL(isPlayMoney);
	_msg.composeString(currency);
	_msg.composeBYTE(handType);
	_msg.composeBYTE(potStruct);
	_msg.composeUINT32(ante);
	_msg.composeUINT32(cap);
	_msg.composeUINT32(minBuyIn);
	_msg.composeUINT32(maxBuyIn);
	_msg.composeUINT32(stakesLow);
	_msg.composeUINT32(stakesHigh);
	_msg.composeString(tableName);
	_msg.composeINT32(scalePM);
}

void hglobby::lobby_client::TableParamsStruct::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(isHiLo);
	_parser.parseUINT32(tableSize);
	_parser.parseBOOL(isFastDealing);
	_parser.parseBOOL(isPlayMoney);
	_parser.parseStringP(currency);
	_parser.parseBYTE(handType);
	_parser.parseBYTE(potStruct);
	_parser.parseUINT32(ante);
	_parser.parseUINT32(cap);
	_parser.parseUINT32(minBuyIn);
	_parser.parseUINT32(maxBuyIn);
	_parser.parseUINT32(stakesLow);
	_parser.parseUINT32(stakesHigh);
	_parser.parseStringP(tableName);
	if(_parser.parseEnded()) return;
	_parser.parseINT32(scalePM);
}

/*static*/ void hglobby::lobby_client::TableParamsStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	bool isHiLo; _parser.parseBOOL(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	UINT32 tableSize; _parser.parseUINT32(tableSize);
	AtfValidator::validateIntRange(_descr, "tableSize", tableSize, 2, MAX_TABLE_PLAYERS, _checker, __FILE__, __LINE__);
	bool isFastDealing; _parser.parseBOOL(isFastDealing);
	AtfValidator::validateInt(_descr, "isFastDealing", isFastDealing, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, 5, _checker, __FILE__, __LINE__);
	BYTE handType; _parser.parseBYTE(handType);
	AtfValidator::validateIntRange(_descr, "handType", handType, 1, HandType_Last, _checker, __FILE__, __LINE__);
	BYTE potStruct; _parser.parseBYTE(potStruct);
	AtfValidator::validateIntRange(_descr, "potStruct", potStruct, StructLimit, PotStruct_Last, _checker, __FILE__, __LINE__);
	UINT32 ante; _parser.parseUINT32(ante);
	AtfValidator::validateIntMax(_descr, "ante", ante, 1000000, _checker, __FILE__, __LINE__);
	UINT32 cap; _parser.parseUINT32(cap);
	AtfValidator::validateIntMax(_descr, "cap", cap, 1000000, _checker, __FILE__, __LINE__);
	UINT32 minBuyIn; _parser.parseUINT32(minBuyIn);
	AtfValidator::validateIntMax(_descr, "minBuyIn", minBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 maxBuyIn; _parser.parseUINT32(maxBuyIn);
	AtfValidator::validateIntMax(_descr, "maxBuyIn", maxBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 stakesLow; _parser.parseUINT32(stakesLow);
	AtfValidator::validateIntMax(_descr, "stakesLow", stakesLow, 100000000, _checker, __FILE__, __LINE__);
	UINT32 stakesHigh; _parser.parseUINT32(stakesHigh);
	AtfValidator::validateIntMax(_descr, "stakesHigh", stakesHigh, 100000000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "tableName"); size_t szTableName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "tableName", szTableName, TABLE_NAME_LEN, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	INT32 scalePM; _parser.parseINT32(scalePM);
	AtfValidator::validateIntRange(_descr, "scalePM", scalePM, 1, 1000000, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TableParams
//=================================================================

hglobby::lobby_client::TableParams::TableParams()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::TableParams::TableParams(TableParams&& _o)
	: tableParamsStruct(std::move(_o.tableParamsStruct))
{
}

hglobby::lobby_client::TableParams& hglobby::lobby_client::TableParams::operator=(TableParams&& _o)
{
	if(this != &_o)
	{
		tableParamsStruct = std::move(_o.tableParamsStruct);
	}
	return *this;
}

#endif

void hglobby::lobby_client::TableParams::clear()
{
	tableParamsStruct.clear();
}

bool hglobby::lobby_client::TableParams::equals(const TableParams& _o) const
{
	return tableParamsStruct.equals(_o.tableParamsStruct);
}

const char *hglobby::lobby_client::TableParams::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tableParamsStruct=");
	tableParamsStruct.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void hglobby::lobby_client::TableParams::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(TableParams())) // not empty
	{
		tableParamsStruct.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void hglobby::lobby_client::TableParams::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	tableParamsStruct.parseMsg(_parser0);
}

/*static*/ void hglobby::lobby_client::TableParams::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	TableParamsStruct::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tableParamsStruct"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY(Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, tableParams(std::move(_o.tableParams))
	, isVoceEnabled(std::move(_o.isVoceEnabled))
{
}

hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY& hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY::operator=(Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		tableParams = std::move(_o.tableParams);
		isVoceEnabled = std::move(_o.isVoceEnabled);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	tableParams.clear();
	isVoceEnabled = false;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY::equals(const Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		tableParams.equals(_o.tableParams) &&
		isVoceEnabled == _o.isVoceEnabled;
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_TABLE_STRUCTURES_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("tableParams=");
		tableParams.toTraceString(_buf);
		_buf.append(',');
		_buf.append("isVoceEnabled=");
		_buf.appendUint(isVoceEnabled);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		tableParams.composeMsg(_msg);
		_msg.composeBOOL(isVoceEnabled);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		tableParams.parseMsg(_parser);
		_parser.parseBOOL(isVoceEnabled);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_TABLE_STRUCTURES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szTableParams = ThinAtf::LAtfVector< TableParams, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableParams"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tableParams", szTableParams, _checker, __FILE__, __LINE__);
		bool isVoceEnabled; _parser.parseBOOL(isVoceEnabled);
		AtfValidator::validateInt(_descr, "isVoceEnabled", isVoceEnabled, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CreateTournParams
//=================================================================

hglobby::lobby_client::CreateTournParams::CreateTournParams()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::CreateTournParams::CreateTournParams(CreateTournParams&& _o)
	: clubId(std::move(_o.clubId))
	, tournamentLobbyText(std::move(_o.tournamentLobbyText))
	, gameName(std::move(_o.gameName))
	, countTowardsClubStandings(std::move(_o.countTowardsClubStandings))
	, isHiLo(std::move(_o.isHiLo))
	, tableSize(std::move(_o.tableSize))
	, isFastDealing(std::move(_o.isFastDealing))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, currency(std::move(_o.currency))
	, handType(std::move(_o.handType))
	, potStruct(std::move(_o.potStruct))
	, buyIn(std::move(_o.buyIn))
	, isSyncBreaksOn(std::move(_o.isSyncBreaksOn))
	, tournFormat(std::move(_o.tournFormat))
	, payout(std::move(_o.payout))
	, startingChips(std::move(_o.startingChips))
	, levelLength(std::move(_o.levelLength))
	, tournKnockoutPrize(std::move(_o.tournKnockoutPrize))
	, tournMaxPlayers(std::move(_o.tournMaxPlayers))
	, year(std::move(_o.year))
	, month(std::move(_o.month))
	, day(std::move(_o.day))
	, hour(std::move(_o.hour))
	, minute(std::move(_o.minute))
	, scalePM(std::move(_o.scalePM))
{
}

hglobby::lobby_client::CreateTournParams& hglobby::lobby_client::CreateTournParams::operator=(CreateTournParams&& _o)
{
	if(this != &_o)
	{
		clubId = std::move(_o.clubId);
		tournamentLobbyText = std::move(_o.tournamentLobbyText);
		gameName = std::move(_o.gameName);
		countTowardsClubStandings = std::move(_o.countTowardsClubStandings);
		isHiLo = std::move(_o.isHiLo);
		tableSize = std::move(_o.tableSize);
		isFastDealing = std::move(_o.isFastDealing);
		isPlayMoney = std::move(_o.isPlayMoney);
		currency = std::move(_o.currency);
		handType = std::move(_o.handType);
		potStruct = std::move(_o.potStruct);
		buyIn = std::move(_o.buyIn);
		isSyncBreaksOn = std::move(_o.isSyncBreaksOn);
		tournFormat = std::move(_o.tournFormat);
		payout = std::move(_o.payout);
		startingChips = std::move(_o.startingChips);
		levelLength = std::move(_o.levelLength);
		tournKnockoutPrize = std::move(_o.tournKnockoutPrize);
		tournMaxPlayers = std::move(_o.tournMaxPlayers);
		year = std::move(_o.year);
		month = std::move(_o.month);
		day = std::move(_o.day);
		hour = std::move(_o.hour);
		minute = std::move(_o.minute);
		scalePM = std::move(_o.scalePM);
	}
	return *this;
}

#endif

void hglobby::lobby_client::CreateTournParams::clear()
{
	clubId = 0;
	tournamentLobbyText.clear();
	gameName.clear();
	countTowardsClubStandings = false;
	isHiLo = false;
	tableSize = 0;
	isFastDealing = false;
	isPlayMoney = false;
	currency.clear();
	handType = 0;
	potStruct = 0;
	buyIn = 0;
	isSyncBreaksOn = false;
	tournFormat = 0;
	payout = 0;
	startingChips = 0;
	levelLength = 0;
	tournKnockoutPrize = 0;
	tournMaxPlayers = 0;
	year = 0;
	month = 0;
	day = 0;
	hour = 0;
	minute = 0;
	scalePM = 0;
}

bool hglobby::lobby_client::CreateTournParams::equals(const CreateTournParams& _o) const
{
	return clubId == _o.clubId &&
		tournamentLobbyText.equals(_o.tournamentLobbyText) &&
		gameName.equals(_o.gameName) &&
		countTowardsClubStandings == _o.countTowardsClubStandings &&
		isHiLo == _o.isHiLo &&
		tableSize == _o.tableSize &&
		isFastDealing == _o.isFastDealing &&
		isPlayMoney == _o.isPlayMoney &&
		currency.equals(_o.currency) &&
		handType == _o.handType &&
		potStruct == _o.potStruct &&
		buyIn == _o.buyIn &&
		isSyncBreaksOn == _o.isSyncBreaksOn &&
		tournFormat == _o.tournFormat &&
		payout == _o.payout &&
		startingChips == _o.startingChips &&
		levelLength == _o.levelLength &&
		tournKnockoutPrize == _o.tournKnockoutPrize &&
		tournMaxPlayers == _o.tournMaxPlayers &&
		year == _o.year &&
		month == _o.month &&
		day == _o.day &&
		hour == _o.hour &&
		minute == _o.minute &&
		scalePM == _o.scalePM;
}

const char *hglobby::lobby_client::CreateTournParams::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("tournamentLobbyText=");
	_buf.append(tournamentLobbyText);
	_buf.append(',');
	_buf.append("gameName=");
	_buf.append(gameName);
	_buf.append(',');
	_buf.append("countTowardsClubStandings=");
	_buf.appendUint(countTowardsClubStandings);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("tableSize=");
	_buf.appendUint(tableSize);
	_buf.append(',');
	_buf.append("isFastDealing=");
	_buf.appendUint(isFastDealing);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("handType=");
	_buf.appendUint(handType);
	_buf.append(',');
	_buf.append("potStruct=");
	_buf.appendUint(potStruct);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendUint(buyIn);
	_buf.append(',');
	_buf.append("isSyncBreaksOn=");
	_buf.appendUint(isSyncBreaksOn);
	_buf.append(',');
	_buf.append("tournFormat=");
	_buf.appendUint(tournFormat);
	_buf.append(',');
	_buf.append("payout=");
	_buf.appendUint(payout);
	_buf.append(',');
	_buf.append("startingChips=");
	_buf.appendUint(startingChips);
	_buf.append(',');
	_buf.append("levelLength=");
	_buf.appendUint(levelLength);
	_buf.append(',');
	_buf.append("tournKnockoutPrize=");
	_buf.appendUint(tournKnockoutPrize);
	_buf.append(',');
	_buf.append("tournMaxPlayers=");
	_buf.appendUint(tournMaxPlayers);
	_buf.append(',');
	_buf.append("year=");
	_buf.appendUint(year);
	_buf.append(',');
	_buf.append("month=");
	_buf.appendUint(month);
	_buf.append(',');
	_buf.append("day=");
	_buf.appendUint(day);
	_buf.append(',');
	_buf.append("hour=");
	_buf.appendUint(hour);
	_buf.append(',');
	_buf.append("minute=");
	_buf.appendUint(minute);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendInt(scalePM);
	_buf.append('}');
	return _buf.c_str();
}

void hglobby::lobby_client::CreateTournParams::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(clubId);
	_msg.composeString(tournamentLobbyText);
	_msg.composeString(gameName);
	_msg.composeBOOL(countTowardsClubStandings);
	_msg.composeBOOL(isHiLo);
	_msg.composeUINT32(tableSize);
	_msg.composeBOOL(isFastDealing);
	_msg.composeBOOL(isPlayMoney);
	_msg.composeString(currency);
	_msg.composeBYTE(handType);
	_msg.composeBYTE(potStruct);
	_msg.composeUINT32(buyIn);
	_msg.composeBOOL(isSyncBreaksOn);
	_msg.composeUINT32(tournFormat);
	_msg.composeUINT32(payout);
	_msg.composeUINT32(startingChips);
	_msg.composeUINT32(levelLength);
	_msg.composeUINT32(tournKnockoutPrize);
	_msg.composeUINT32(tournMaxPlayers);
	_msg.composeUINT16(year);
	_msg.composeBYTE(month);
	_msg.composeBYTE(day);
	_msg.composeBYTE(hour);
	_msg.composeBYTE(minute);
	_msg.composeINT32(scalePM);
}

void hglobby::lobby_client::CreateTournParams::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	_parser.parseStringP(tournamentLobbyText);
	_parser.parseStringP(gameName);
	_parser.parseBOOL(countTowardsClubStandings);
	_parser.parseBOOL(isHiLo);
	_parser.parseUINT32(tableSize);
	_parser.parseBOOL(isFastDealing);
	_parser.parseBOOL(isPlayMoney);
	_parser.parseStringP(currency);
	_parser.parseBYTE(handType);
	_parser.parseBYTE(potStruct);
	_parser.parseUINT32(buyIn);
	_parser.parseBOOL(isSyncBreaksOn);
	_parser.parseUINT32(tournFormat);
	_parser.parseUINT32(payout);
	_parser.parseUINT32(startingChips);
	_parser.parseUINT32(levelLength);
	_parser.parseUINT32(tournKnockoutPrize);
	_parser.parseUINT32(tournMaxPlayers);
	_parser.parseUINT16(year);
	_parser.parseBYTE(month);
	_parser.parseBYTE(day);
	_parser.parseBYTE(hour);
	_parser.parseBYTE(minute);
	if(_parser.parseEnded()) return;
	_parser.parseINT32(scalePM);
}

/*static*/ void hglobby::lobby_client::CreateTournParams::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "tournamentLobbyText"); size_t szTournamentLobbyText = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "tournamentLobbyText", szTournamentLobbyText, 1024, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "gameName"); size_t szGameName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "gameName", szGameName, 128, _checker, __FILE__, __LINE__);
	bool countTowardsClubStandings; _parser.parseBOOL(countTowardsClubStandings);
	AtfValidator::validateInt(_descr, "countTowardsClubStandings", countTowardsClubStandings, _checker, __FILE__, __LINE__);
	bool isHiLo; _parser.parseBOOL(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	UINT32 tableSize; _parser.parseUINT32(tableSize);
	AtfValidator::validateIntRange(_descr, "tableSize", tableSize, 2, 10, _checker, __FILE__, __LINE__);
	bool isFastDealing; _parser.parseBOOL(isFastDealing);
	AtfValidator::validateInt(_descr, "isFastDealing", isFastDealing, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, 5, _checker, __FILE__, __LINE__);
	BYTE handType; _parser.parseBYTE(handType);
	AtfValidator::validateIntRange(_descr, "handType", handType, 1, HandType_Last, _checker, __FILE__, __LINE__);
	BYTE potStruct; _parser.parseBYTE(potStruct);
	AtfValidator::validateIntRange(_descr, "potStruct", potStruct, StructLimit, PotStruct_Last, _checker, __FILE__, __LINE__);
	UINT32 buyIn; _parser.parseUINT32(buyIn);
	AtfValidator::validateIntMax(_descr, "buyIn", buyIn, 2000000000, _checker, __FILE__, __LINE__);
	bool isSyncBreaksOn; _parser.parseBOOL(isSyncBreaksOn);
	AtfValidator::validateInt(_descr, "isSyncBreaksOn", isSyncBreaksOn, _checker, __FILE__, __LINE__);
	UINT32 tournFormat; _parser.parseUINT32(tournFormat);
	AtfValidator::validateIntMax(_descr, "tournFormat", tournFormat, eHgTournFormatRebuy2RnoA, _checker, __FILE__, __LINE__);
	UINT32 payout; _parser.parseUINT32(payout);
	AtfValidator::validateIntMax(_descr, "payout", payout, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 startingChips; _parser.parseUINT32(startingChips);
	AtfValidator::validateIntMax(_descr, "startingChips", startingChips, 100000, _checker, __FILE__, __LINE__);
	UINT32 levelLength; _parser.parseUINT32(levelLength);
	AtfValidator::validateIntMax(_descr, "levelLength", levelLength, 10000, _checker, __FILE__, __LINE__);
	UINT32 tournKnockoutPrize; _parser.parseUINT32(tournKnockoutPrize);
	AtfValidator::validateIntMax(_descr, "tournKnockoutPrize", tournKnockoutPrize, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 tournMaxPlayers; _parser.parseUINT32(tournMaxPlayers);
	AtfValidator::validateIntMax(_descr, "tournMaxPlayers", tournMaxPlayers, 1000000, _checker, __FILE__, __LINE__);
	UINT16 year; _parser.parseUINT16(year);
	AtfValidator::validateIntRange(_descr, "year", year, 2016, 3000, _checker, __FILE__, __LINE__);
	BYTE month; _parser.parseBYTE(month);
	AtfValidator::validateIntRange(_descr, "month", month, 1, 12, _checker, __FILE__, __LINE__);
	BYTE day; _parser.parseBYTE(day);
	AtfValidator::validateIntRange(_descr, "day", day, 1, 31, _checker, __FILE__, __LINE__);
	BYTE hour; _parser.parseBYTE(hour);
	AtfValidator::validateIntMax(_descr, "hour", hour, 23, _checker, __FILE__, __LINE__);
	BYTE minute; _parser.parseBYTE(minute);
	AtfValidator::validateIntMax(_descr, "minute", minute, 59, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	INT32 scalePM; _parser.parseINT32(scalePM);
	AtfValidator::validateIntRange(_descr, "scalePM", scalePM, 1, 10000, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_HG_CREATE_CLUB_TOURN
//=================================================================

hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN::Protocol_HG_CREATE_CLUB_TOURN()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN::Protocol_HG_CREATE_CLUB_TOURN(Protocol_HG_CREATE_CLUB_TOURN&& _o)
	: createTournParams(std::move(_o.createTournParams))
	, recurringPatternType(std::move(_o.recurringPatternType))
	, nbOccurences(std::move(_o.nbOccurences))
	, endDate(std::move(_o.endDate))
	, numberOfDays(std::move(_o.numberOfDays))
	, everyWeekday(std::move(_o.everyWeekday))
	, numberOfWeeks(std::move(_o.numberOfWeeks))
	, recurringDays(std::move(_o.recurringDays))
	, dayOfMonth(std::move(_o.dayOfMonth))
	, numberMonths(std::move(_o.numberMonths))
	, whichRecurringDay(std::move(_o.whichRecurringDay))
	, recurringDay(std::move(_o.recurringDay))
	, nbConsecutiveCancellation(std::move(_o.nbConsecutiveCancellation))
{
}

hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN& hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN::operator=(Protocol_HG_CREATE_CLUB_TOURN&& _o)
{
	if(this != &_o)
	{
		createTournParams = std::move(_o.createTournParams);
		recurringPatternType = std::move(_o.recurringPatternType);
		nbOccurences = std::move(_o.nbOccurences);
		endDate = std::move(_o.endDate);
		numberOfDays = std::move(_o.numberOfDays);
		everyWeekday = std::move(_o.everyWeekday);
		numberOfWeeks = std::move(_o.numberOfWeeks);
		recurringDays = std::move(_o.recurringDays);
		dayOfMonth = std::move(_o.dayOfMonth);
		numberMonths = std::move(_o.numberMonths);
		whichRecurringDay = std::move(_o.whichRecurringDay);
		recurringDay = std::move(_o.recurringDay);
		nbConsecutiveCancellation = std::move(_o.nbConsecutiveCancellation);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN::clear()
{
	createTournParams.clear();
	recurringPatternType = 0;
	nbOccurences = 0;
	endDate.setNull();
	numberOfDays = 0;
	everyWeekday = false;
	numberOfWeeks = 0;
	recurringDays = 0;
	dayOfMonth = 0;
	numberMonths = 0;
	whichRecurringDay = 0;
	recurringDay = 0;
	nbConsecutiveCancellation = 0;
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN::equals(const Protocol_HG_CREATE_CLUB_TOURN& _o) const
{
	return createTournParams.equals(_o.createTournParams) &&
		recurringPatternType == _o.recurringPatternType &&
		nbOccurences == _o.nbOccurences &&
		endDate.equals(_o.endDate) &&
		numberOfDays == _o.numberOfDays &&
		everyWeekday == _o.everyWeekday &&
		numberOfWeeks == _o.numberOfWeeks &&
		recurringDays == _o.recurringDays &&
		dayOfMonth == _o.dayOfMonth &&
		numberMonths == _o.numberMonths &&
		whichRecurringDay == _o.whichRecurringDay &&
		recurringDay == _o.recurringDay &&
		nbConsecutiveCancellation == _o.nbConsecutiveCancellation;
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CREATE_CLUB_TOURN).append(")");
	_buf.append(',');
	_buf.append("createTournParams=");
	createTournParams.toTraceString(_buf);
	_buf.append(',');
	_buf.append("recurringPatternType=");
	_buf.appendUint(recurringPatternType);
	_buf.append(',');
	_buf.append("nbOccurences=");
	_buf.appendUint(nbOccurences);
	_buf.append(',');
	_buf.append("endDate=");
	ThinAtf::AtfTempl<SrvDate>::ToTraceString(_buf, endDate);
	if (recurringPatternType == eHgRecurringDaily)
	{
		_buf.append(',');
		_buf.append("numberOfDays=");
		_buf.appendUint(numberOfDays);
		_buf.append(',');
		_buf.append("everyWeekday=");
		_buf.appendUint(everyWeekday);
	}
	else if (recurringPatternType == eHgRecurringWeekly)
	{
		_buf.append(',');
		_buf.append("numberOfWeeks=");
		_buf.appendUint(numberOfWeeks);
		_buf.append(',');
		_buf.append("recurringDays=");
		_buf.appendUint(recurringDays);
	}
	else if (recurringPatternType == eHgRecurringMonthly)
	{
		_buf.append(',');
		_buf.append("dayOfMonth=");
		_buf.appendUint(dayOfMonth);
		_buf.append(',');
		_buf.append("numberMonths=");
		_buf.appendUint(numberMonths);
		_buf.append(',');
		_buf.append("whichRecurringDay=");
		_buf.appendUint(whichRecurringDay);
		_buf.append(',');
		_buf.append("recurringDay=");
		_buf.appendUint(recurringDay);
	}
	_buf.append(',');
	_buf.append("nbConsecutiveCancellation=");
	_buf.appendUint(nbConsecutiveCancellation);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN::composeMsg(CommMsgBody& _msg) const
{
	createTournParams.composeMsg(_msg);
	_msg.composeUINT32(recurringPatternType);
	_msg.composeUINT32(nbOccurences);
	_msg.composeSrvDate(endDate);
	if (recurringPatternType == eHgRecurringDaily)
	{
		CommMsgBody _msg0;
		_msg0.composeUINT32(numberOfDays);
		_msg0.composeBOOL(everyWeekday);
		_msg.composeMsgBody(_msg0);
	}
	else if (recurringPatternType == eHgRecurringWeekly)
	{
		CommMsgBody _msg1;
		_msg1.composeUINT32(numberOfWeeks);
		_msg1.composeUINT32(recurringDays);
		_msg.composeMsgBody(_msg1);
	}
	else if (recurringPatternType == eHgRecurringMonthly)
	{
		CommMsgBody _msg2;
		_msg2.composeBYTE(dayOfMonth);
		_msg2.composeBYTE(numberMonths);
		_msg2.composeUINT32(whichRecurringDay);
		_msg2.composeUINT32(recurringDay);
		_msg.composeMsgBody(_msg2);
	}
	_msg.composeUINT32(nbConsecutiveCancellation);
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN::parseMsg(CommMsgParser& _parser)
{
	createTournParams.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(recurringPatternType);
	_parser.parseUINT32(nbOccurences);
	_parser.parseSrvDate(endDate);
	if (recurringPatternType == eHgRecurringDaily)
	{
		parseAnonymousMsgBody0(_parser);
	}
	else if (recurringPatternType == eHgRecurringWeekly)
	{
		parseAnonymousMsgBody1(_parser);
	}
	else if (recurringPatternType == eHgRecurringMonthly)
	{
		parseAnonymousMsgBody2(_parser);
	}
	_parser.parseUINT32(nbConsecutiveCancellation);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CREATE_CLUB_TOURN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 recurringPatternType = 0;
	PString _descbuf;
	CreateTournParams::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("createTournParams"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(recurringPatternType);
	AtfValidator::validateIntMax(_descr, "recurringPatternType", recurringPatternType, eHgRecurringMonthly, _checker, __FILE__, __LINE__);
	UINT32 nbOccurences; _parser.parseUINT32(nbOccurences);
	AtfValidator::validateIntMax(_descr, "nbOccurences", nbOccurences, 10000, _checker, __FILE__, __LINE__);
	SrvDate endDate; _parser.parseSrvDate(endDate);
	AtfValidator::validateSrvDateTime(_descr, "endDate", endDate, _checker, __FILE__, __LINE__);
	if (recurringPatternType == eHgRecurringDaily)
	{
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (recurringPatternType == eHgRecurringWeekly)
	{
		validateAnonymousMsgBody1(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (recurringPatternType == eHgRecurringMonthly)
	{
		validateAnonymousMsgBody2(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	UINT32 nbConsecutiveCancellation; _parser.parseUINT32(nbConsecutiveCancellation);
	AtfValidator::validateIntMax(_descr, "nbConsecutiveCancellation", nbConsecutiveCancellation, 10000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(numberOfDays);
	_parser0.parseBOOL(everyWeekday);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 numberOfDays; _parser0.parseUINT32(numberOfDays);
	AtfValidator::validateIntMax(_descr, "numberOfDays", numberOfDays, 10000, _checker, __FILE__, __LINE__);
	bool everyWeekday; _parser0.parseBOOL(everyWeekday);
	AtfValidator::validateInt(_descr, "everyWeekday", everyWeekday, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN::parseAnonymousMsgBody1(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(numberOfWeeks);
	_parser0.parseUINT32(recurringDays);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN::validateAnonymousMsgBody1(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 numberOfWeeks; _parser0.parseUINT32(numberOfWeeks);
	AtfValidator::validateIntMax(_descr, "numberOfWeeks", numberOfWeeks, 1000, _checker, __FILE__, __LINE__);
	UINT32 recurringDays; _parser0.parseUINT32(recurringDays);
	AtfValidator::validateIntRange(_descr, "recurringDays", recurringDays, eHgRdNone, eHgRdEveryday, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN::parseAnonymousMsgBody2(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(dayOfMonth);
	_parser0.parseBYTE(numberMonths);
	_parser0.parseUINT32(whichRecurringDay);
	_parser0.parseUINT32(recurringDay);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN::validateAnonymousMsgBody2(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	BYTE dayOfMonth; _parser0.parseBYTE(dayOfMonth);
	AtfValidator::validateIntMax(_descr, "dayOfMonth", dayOfMonth, 31, _checker, __FILE__, __LINE__);
	BYTE numberMonths; _parser0.parseBYTE(numberMonths);
	AtfValidator::validateIntMax(_descr, "numberMonths", numberMonths, 100, _checker, __FILE__, __LINE__);
	UINT32 whichRecurringDay; _parser0.parseUINT32(whichRecurringDay);
	AtfValidator::validateIntRange(_descr, "whichRecurringDay", whichRecurringDay, eHgWrdNone, eHgWrdLast, _checker, __FILE__, __LINE__);
	UINT32 recurringDay; _parser0.parseUINT32(recurringDay);
	AtfValidator::validateIntRange(_descr, "recurringDay", recurringDay, eHgRdNone, eHgRdEveryday, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_HG_CREATE_CLUB_TOURN_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY::Protocol_HG_CREATE_CLUB_TOURN_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY::Protocol_HG_CREATE_CLUB_TOURN_REPLY(Protocol_HG_CREATE_CLUB_TOURN_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, socialToken(std::move(_o.socialToken))
	, tournId(std::move(_o.tournId))
	, restartWarning(std::move(_o.restartWarning))
{
}

hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY& hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY::operator=(Protocol_HG_CREATE_CLUB_TOURN_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		socialToken = std::move(_o.socialToken);
		tournId = std::move(_o.tournId);
		restartWarning = std::move(_o.restartWarning);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	socialToken.clear();
	tournId = 0;
	restartWarning.clear();
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY::equals(const Protocol_HG_CREATE_CLUB_TOURN_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		socialToken.equals(_o.socialToken) &&
		tournId == _o.tournId &&
		restartWarning.equals(_o.restartWarning);
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CREATE_CLUB_TOURN_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("socialToken=");
		_buf.append(socialToken);
		_buf.append(',');
		_buf.append("tournId=");
		_buf.appendUint(tournId);
		_buf.append(',');
		_buf.append("restartWarning=");
		_buf.append(restartWarning);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeString(socialToken);
		_msg.composeUINT32(tournId);
		_msg.composeString(restartWarning);
	}
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseStringP(socialToken);
		_parser.parseUINT32(tournId);
		_parser.parseStringP(restartWarning);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CREATE_CLUB_TOURN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "socialToken"); size_t szSocialToken = strlen(_dummy);
		AtfValidator::validateInt(_descr, "socialToken", szSocialToken, _checker, __FILE__, __LINE__);
		UINT32 tournId; _parser.parseUINT32(tournId);
		AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "restartWarning"); size_t szRestartWarning = strlen(_dummy);
		AtfValidator::validateInt(_descr, "restartWarning", szRestartWarning, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CREATE_CLUB_TABLE
//=================================================================

hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE::Protocol_HG_CREATE_CLUB_TABLE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE::Protocol_HG_CREATE_CLUB_TABLE(Protocol_HG_CREATE_CLUB_TABLE&& _o)
	: clubId(std::move(_o.clubId))
	, tableParamsStruct(std::move(_o.tableParamsStruct))
	, voiceEnabled(std::move(_o.voiceEnabled))
{
}

hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE& hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE::operator=(Protocol_HG_CREATE_CLUB_TABLE&& _o)
{
	if(this != &_o)
	{
		clubId = std::move(_o.clubId);
		tableParamsStruct = std::move(_o.tableParamsStruct);
		voiceEnabled = std::move(_o.voiceEnabled);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE::clear()
{
	clubId = 0;
	tableParamsStruct.clear();
	voiceEnabled = false;
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE::equals(const Protocol_HG_CREATE_CLUB_TABLE& _o) const
{
	return clubId == _o.clubId &&
		tableParamsStruct.equals(_o.tableParamsStruct) &&
		voiceEnabled == _o.voiceEnabled;
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CREATE_CLUB_TABLE).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("tableParamsStruct=");
	tableParamsStruct.toTraceString(_buf);
	_buf.append(',');
	_buf.append("voiceEnabled=");
	_buf.appendUint(voiceEnabled);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(clubId);
	tableParamsStruct.composeMsg(_msg);
	_msg.composeBOOL(voiceEnabled);
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	tableParamsStruct.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(voiceEnabled);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CREATE_CLUB_TABLE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	TableParamsStruct::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableParamsStruct"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	bool voiceEnabled; _parser.parseBOOL(voiceEnabled);
	AtfValidator::validateInt(_descr, "voiceEnabled", voiceEnabled, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CREATE_CLUB_TABLE_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE_REPLY::Protocol_HG_CREATE_CLUB_TABLE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE_REPLY::Protocol_HG_CREATE_CLUB_TABLE_REPLY(Protocol_HG_CREATE_CLUB_TABLE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, socialToken(std::move(_o.socialToken))
	, tableId32(std::move(_o.tableId32))
	, restartWarning(std::move(_o.restartWarning))
	, tableId(std::move(_o.tableId))
{
}

hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE_REPLY& hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE_REPLY::operator=(Protocol_HG_CREATE_CLUB_TABLE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		socialToken = std::move(_o.socialToken);
		tableId32 = std::move(_o.tableId32);
		restartWarning = std::move(_o.restartWarning);
		tableId = std::move(_o.tableId);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	socialToken.clear();
	tableId32 = 0;
	restartWarning.clear();
	tableId = 0;
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE_REPLY::equals(const Protocol_HG_CREATE_CLUB_TABLE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		socialToken.equals(_o.socialToken) &&
		tableId32 == _o.tableId32 &&
		restartWarning.equals(_o.restartWarning) &&
		tableId == _o.tableId;
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CREATE_CLUB_TABLE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("socialToken=");
		_buf.append(socialToken);
		_buf.append(',');
		_buf.append("tableId32=");
		_buf.appendUint(tableId32);
		_buf.append(',');
		_buf.append("restartWarning=");
		_buf.append(restartWarning);
		_buf.append(',');
		_buf.append("tableId=");
		_buf.appendUint64(tableId);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeString(socialToken);
		_msg.composeUINT32(tableId32);
		_msg.composeString(restartWarning);
		_msg.composeUINT64(tableId);
	}
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseStringP(socialToken);
		_parser.parseUINT32(tableId32);
		_parser.parseStringP(restartWarning);
		if(_parser.parseEnded()) return;
		_parser.parseUINT64(tableId);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CREATE_CLUB_TABLE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "socialToken"); size_t szSocialToken = strlen(_dummy);
		AtfValidator::validateInt(_descr, "socialToken", szSocialToken, _checker, __FILE__, __LINE__);
		UINT32 tableId32; _parser.parseUINT32(tableId32);
		AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "restartWarning"); size_t szRestartWarning = strlen(_dummy);
		AtfValidator::validateInt(_descr, "restartWarning", szRestartWarning, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		UINT64 tableId; _parser.parseUINT64(tableId);
		AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_UPDATE_MEMBERSHIP_FLAGS
//=================================================================

hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS(Protocol_HG_UPDATE_MEMBERSHIP_FLAGS&& _o)
	: clubId(std::move(_o.clubId))
	, userId(std::move(_o.userId))
	, flags(std::move(_o.flags))
	, mask(std::move(_o.mask))
{
}

hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS& hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS::operator=(Protocol_HG_UPDATE_MEMBERSHIP_FLAGS&& _o)
{
	if(this != &_o)
	{
		clubId = std::move(_o.clubId);
		userId = std::move(_o.userId);
		flags = std::move(_o.flags);
		mask = std::move(_o.mask);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS::clear()
{
	clubId = 0;
	userId.clear();
	flags = 0;
	mask = 0;
}

bool hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS::equals(const Protocol_HG_UPDATE_MEMBERSHIP_FLAGS& _o) const
{
	return clubId == _o.clubId &&
		userId.equals(_o.userId) &&
		flags == _o.flags &&
		mask == _o.mask;
}

const char *hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_UPDATE_MEMBERSHIP_FLAGS).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("mask=");
	_buf.appendUint(mask);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(clubId);
	_msg.composeString(userId);
	_msg.composeUINT32(flags);
	_msg.composeUINT32(mask);
}

void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	_parser.parseStringP(userId);
	_parser.parseUINT32(flags);
	_parser.parseUINT32(mask);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_UPDATE_MEMBERSHIP_FLAGS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, 20, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser.parseUINT32(flags);
	AtfValidator::validateIntMax(_descr, "flags", flags, HgMemberFlags_Last, _checker, __FILE__, __LINE__);
	UINT32 mask; _parser.parseUINT32(mask);
	AtfValidator::validateIntMax(_descr, "mask", mask, (2*HgMemberFlags_Last-1), _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_UPDATE_MEMBERSHIP_FLAGS_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS_REPLY::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS_REPLY::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS_REPLY(Protocol_HG_UPDATE_MEMBERSHIP_FLAGS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS_REPLY& hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS_REPLY::operator=(Protocol_HG_UPDATE_MEMBERSHIP_FLAGS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS_REPLY::equals(const Protocol_HG_UPDATE_MEMBERSHIP_FLAGS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc);
}

const char *hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_UPDATE_MEMBERSHIP_FLAGS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_UPDATE_MEMBERSHIP_FLAGS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CANCEL_CLUB_TOURNAMENT
//=================================================================

hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT::Protocol_HG_CANCEL_CLUB_TOURNAMENT()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT::clear()
{
	clubId = 0;
	tournId = 0;
	cancelRecurrence = false;
}

bool hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT::equals(const Protocol_HG_CANCEL_CLUB_TOURNAMENT& _o) const
{
	return clubId == _o.clubId &&
		tournId == _o.tournId &&
		cancelRecurrence == _o.cancelRecurrence;
}

const char *hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CANCEL_CLUB_TOURNAMENT).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("cancelRecurrence=");
	_buf.appendUint(cancelRecurrence);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(clubId);
	_msg.composeUINT32(tournId);
	_msg.composeBOOL(cancelRecurrence);
}

void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	_parser.parseUINT32(tournId);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(cancelRecurrence);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CANCEL_CLUB_TOURNAMENT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool cancelRecurrence; _parser.parseBOOL(cancelRecurrence);
	AtfValidator::validateInt(_descr, "cancelRecurrence", cancelRecurrence, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CANCEL_CLUB_TOURNAMENT_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT_REPLY::Protocol_HG_CANCEL_CLUB_TOURNAMENT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT_REPLY::Protocol_HG_CANCEL_CLUB_TOURNAMENT_REPLY(Protocol_HG_CANCEL_CLUB_TOURNAMENT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT_REPLY& hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT_REPLY::operator=(Protocol_HG_CANCEL_CLUB_TOURNAMENT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT_REPLY::equals(const Protocol_HG_CANCEL_CLUB_TOURNAMENT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc);
}

const char *hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CANCEL_CLUB_TOURNAMENT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CANCEL_CLUB_TOURNAMENT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CANCEL_CLUB_TABLE
//=================================================================

hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE::Protocol_HG_CANCEL_CLUB_TABLE()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE::clear()
{
	clubId = 0;
	tableId32 = 0;
	tableId = 0;
}

bool hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE::equals(const Protocol_HG_CANCEL_CLUB_TABLE& _o) const
{
	return clubId == _o.clubId &&
		tableId32 == _o.tableId32 &&
		tableId == _o.tableId;
}

const char *hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CANCEL_CLUB_TABLE).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("tableId32=");
	_buf.appendUint(tableId32);
	_buf.append(',');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(clubId);
	_msg.composeUINT32(tableId32);
	_msg.composeUINT64(tableId);
}

void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	_parser.parseUINT32(tableId32);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(tableId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CANCEL_CLUB_TABLE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 tableId32; _parser.parseUINT32(tableId32);
	AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 tableId; _parser.parseUINT64(tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CANCEL_CLUB_TABLE_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE_REPLY::Protocol_HG_CANCEL_CLUB_TABLE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE_REPLY::Protocol_HG_CANCEL_CLUB_TABLE_REPLY(Protocol_HG_CANCEL_CLUB_TABLE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE_REPLY& hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE_REPLY::operator=(Protocol_HG_CANCEL_CLUB_TABLE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE_REPLY::equals(const Protocol_HG_CANCEL_CLUB_TABLE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc);
}

const char *hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CANCEL_CLUB_TABLE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CANCEL_CLUB_TABLE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_TRANSLATE_SOCIAL_EVENT
//=================================================================

hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT::Protocol_HG_TRANSLATE_SOCIAL_EVENT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT::Protocol_HG_TRANSLATE_SOCIAL_EVENT(Protocol_HG_TRANSLATE_SOCIAL_EVENT&& _o)
	: socialEventToken(std::move(_o.socialEventToken))
{
}

hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT& hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT::operator=(Protocol_HG_TRANSLATE_SOCIAL_EVENT&& _o)
{
	if(this != &_o)
	{
		socialEventToken = std::move(_o.socialEventToken);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT::clear()
{
	socialEventToken.clear();
}

bool hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT::equals(const Protocol_HG_TRANSLATE_SOCIAL_EVENT& _o) const
{
	return socialEventToken.equals(_o.socialEventToken);
}

const char *hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_TRANSLATE_SOCIAL_EVENT).append(")");
	_buf.append(',');
	_buf.append("socialEventToken=");
	_buf.append(socialEventToken);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(socialEventToken);
}

void hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(socialEventToken);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_TRANSLATE_SOCIAL_EVENT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "socialEventToken"); size_t szSocialEventToken = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "socialEventToken", szSocialEventToken, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_TRANSLATE_SOCIAL_EVENT_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT_REPLY::Protocol_HG_TRANSLATE_SOCIAL_EVENT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT_REPLY::Protocol_HG_TRANSLATE_SOCIAL_EVENT_REPLY(Protocol_HG_TRANSLATE_SOCIAL_EVENT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, encUrl(std::move(_o.encUrl))
{
}

hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT_REPLY& hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT_REPLY::operator=(Protocol_HG_TRANSLATE_SOCIAL_EVENT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		encUrl = std::move(_o.encUrl);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	encUrl.clear();
}

bool hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT_REPLY::equals(const Protocol_HG_TRANSLATE_SOCIAL_EVENT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		encUrl.equals(_o.encUrl);
}

const char *hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_TRANSLATE_SOCIAL_EVENT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("encUrl=");
		_buf.append(encUrl);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeString(encUrl);
	}
}

void hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseStringP(encUrl);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_TRANSLATE_SOCIAL_EVENT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "encUrl"); size_t szEncUrl = strlen(_dummy);
		AtfValidator::validateInt(_descr, "encUrl", szEncUrl, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUB_TABLE_INFO
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO::Protocol_HG_GET_CLUB_TABLE_INFO()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO::clear()
{
	tableId32 = 0;
	tournId = 0;
	clubId = 0;
	tableId = 0;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO::equals(const Protocol_HG_GET_CLUB_TABLE_INFO& _o) const
{
	return tableId32 == _o.tableId32 &&
		tournId == _o.tournId &&
		clubId == _o.clubId &&
		tableId == _o.tableId;
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_TABLE_INFO).append(")");
	_buf.append(',');
	_buf.append("tableId32=");
	_buf.appendUint(tableId32);
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(tableId32);
	_msg.composeUINT32(tournId);
	_msg.composeUINT32(clubId);
	_msg.composeUINT64(tableId);
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tableId32);
	_parser.parseUINT32(tournId);
	_parser.parseUINT32(clubId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(tableId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_TABLE_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 tableId32; _parser.parseUINT32(tableId32);
	AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 tableId; _parser.parseUINT64(tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUB_TABLE_INFO_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO_REPLY::Protocol_HG_GET_CLUB_TABLE_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO_REPLY::Protocol_HG_GET_CLUB_TABLE_INFO_REPLY(Protocol_HG_GET_CLUB_TABLE_INFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, server(std::move(_o.server))
	, serverObject(std::move(_o.serverObject))
	, clubName(std::move(_o.clubName))
	, game(std::move(_o.game))
	, maxPlayers(std::move(_o.maxPlayers))
	, memberRole(std::move(_o.memberRole))
	, memberFlags(std::move(_o.memberFlags))
{
}

hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO_REPLY& hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO_REPLY::operator=(Protocol_HG_GET_CLUB_TABLE_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		server = std::move(_o.server);
		serverObject = std::move(_o.serverObject);
		clubName = std::move(_o.clubName);
		game = std::move(_o.game);
		maxPlayers = std::move(_o.maxPlayers);
		memberRole = std::move(_o.memberRole);
		memberFlags = std::move(_o.memberFlags);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	server.clear();
	serverObject.clear();
	clubName.clear();
	game = 0;
	maxPlayers = 0;
	memberRole = 0;
	memberFlags = 0;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO_REPLY::equals(const Protocol_HG_GET_CLUB_TABLE_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		server.equals(_o.server) &&
		serverObject.equals(_o.serverObject) &&
		clubName.equals(_o.clubName) &&
		game == _o.game &&
		maxPlayers == _o.maxPlayers &&
		memberRole == _o.memberRole &&
		memberFlags == _o.memberFlags;
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_TABLE_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("server=");
		_buf.append(server);
		_buf.append(',');
		_buf.append("serverObject=");
		_buf.append(serverObject);
		_buf.append(',');
		_buf.append("clubName=");
		_buf.append(clubName);
		_buf.append(',');
		_buf.append("game=");
		_buf.appendUint(game);
		_buf.append(',');
		_buf.append("maxPlayers=");
		_buf.appendUint(maxPlayers);
		_buf.append(',');
		_buf.append("memberRole=");
		_buf.appendUint(memberRole);
		_buf.append(',');
		_buf.append("memberFlags=");
		_buf.appendUint(memberFlags);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeString(server);
		_msg.composeString(serverObject);
		_msg.composeString(clubName);
		_msg.composeBYTE(game);
		_msg.composeBYTE(maxPlayers);
		_msg.composeUINT32(memberRole);
		_msg.composeUINT32(memberFlags);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseStringP(server);
		_parser.parseStringP(serverObject);
		_parser.parseStringP(clubName);
		_parser.parseBYTE(game);
		_parser.parseBYTE(maxPlayers);
		_parser.parseUINT32(memberRole);
		_parser.parseUINT32(memberFlags);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_TABLE_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "serverObject"); size_t szServerObject = strlen(_dummy);
		AtfValidator::validateInt(_descr, "serverObject", szServerObject, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "clubName"); size_t szClubName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "clubName", szClubName, _checker, __FILE__, __LINE__);
		BYTE game; _parser.parseBYTE(game);
		AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
		BYTE maxPlayers; _parser.parseBYTE(maxPlayers);
		AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
		UINT32 memberRole; _parser.parseUINT32(memberRole);
		AtfValidator::validateInt(_descr, "memberRole", memberRole, _checker, __FILE__, __LINE__);
		UINT32 memberFlags; _parser.parseUINT32(memberFlags);
		AtfValidator::validateInt(_descr, "memberFlags", memberFlags, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUB_TOURN_INFO
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO::Protocol_HG_GET_CLUB_TOURN_INFO()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO::clear()
{
	tourId = 0;
	clubId = 0;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO::equals(const Protocol_HG_GET_CLUB_TOURN_INFO& _o) const
{
	return tourId == _o.tourId &&
		clubId == _o.clubId;
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_TOURN_INFO).append(")");
	_buf.append(',');
	_buf.append("tourId=");
	_buf.appendUint(tourId);
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(tourId);
	_msg.composeUINT32(clubId);
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tourId);
	_parser.parseUINT32(clubId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_TOURN_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 tourId; _parser.parseUINT32(tourId);
	AtfValidator::validateInt(_descr, "tourId", tourId, _checker, __FILE__, __LINE__);
	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUB_TOURN_INFO_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO_REPLY::Protocol_HG_GET_CLUB_TOURN_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO_REPLY::Protocol_HG_GET_CLUB_TOURN_INFO_REPLY(Protocol_HG_GET_CLUB_TOURN_INFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, server(std::move(_o.server))
	, serverObject(std::move(_o.serverObject))
	, clubName(std::move(_o.clubName))
	, memberRole(std::move(_o.memberRole))
	, memberFlags(std::move(_o.memberFlags))
{
}

hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO_REPLY& hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO_REPLY::operator=(Protocol_HG_GET_CLUB_TOURN_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		server = std::move(_o.server);
		serverObject = std::move(_o.serverObject);
		clubName = std::move(_o.clubName);
		memberRole = std::move(_o.memberRole);
		memberFlags = std::move(_o.memberFlags);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	server.clear();
	serverObject.clear();
	clubName.clear();
	memberRole = 0;
	memberFlags = 0;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO_REPLY::equals(const Protocol_HG_GET_CLUB_TOURN_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		server.equals(_o.server) &&
		serverObject.equals(_o.serverObject) &&
		clubName.equals(_o.clubName) &&
		memberRole == _o.memberRole &&
		memberFlags == _o.memberFlags;
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_TOURN_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("server=");
		_buf.append(server);
		_buf.append(',');
		_buf.append("serverObject=");
		_buf.append(serverObject);
		_buf.append(',');
		_buf.append("clubName=");
		_buf.append(clubName);
		_buf.append(',');
		_buf.append("memberRole=");
		_buf.appendUint(memberRole);
		_buf.append(',');
		_buf.append("memberFlags=");
		_buf.appendUint(memberFlags);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeString(server);
		_msg.composeString(serverObject);
		_msg.composeString(clubName);
		_msg.composeUINT32(memberRole);
		_msg.composeUINT32(memberFlags);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseStringP(server);
		_parser.parseStringP(serverObject);
		_parser.parseStringP(clubName);
		_parser.parseUINT32(memberRole);
		_parser.parseUINT32(memberFlags);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_TOURN_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "serverObject"); size_t szServerObject = strlen(_dummy);
		AtfValidator::validateInt(_descr, "serverObject", szServerObject, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "clubName"); size_t szClubName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "clubName", szClubName, _checker, __FILE__, __LINE__);
		UINT32 memberRole; _parser.parseUINT32(memberRole);
		AtfValidator::validateInt(_descr, "memberRole", memberRole, _checker, __FILE__, __LINE__);
		UINT32 memberFlags; _parser.parseUINT32(memberFlags);
		AtfValidator::validateInt(_descr, "memberFlags", memberFlags, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUB_INFO
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO::Protocol_HG_GET_CLUB_INFO()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO::clear()
{
	clubId = 0;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO::equals(const Protocol_HG_GET_CLUB_INFO& _o) const
{
	return clubId == _o.clubId;
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_INFO).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(clubId);
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUB_INFO_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY::Protocol_HG_GET_CLUB_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY::Protocol_HG_GET_CLUB_INFO_REPLY(Protocol_HG_GET_CLUB_INFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, clubName(std::move(_o.clubName))
	, tablePubName(std::move(_o.tablePubName))
	, tournPubName(std::move(_o.tournPubName))
	, memberRole(std::move(_o.memberRole))
	, memberFlags(std::move(_o.memberFlags))
	, wallPubName(std::move(_o.wallPubName))
	, announcePubName(std::move(_o.announcePubName))
	, membershipPubName(std::move(_o.membershipPubName))
{
}

hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY& hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY::operator=(Protocol_HG_GET_CLUB_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		clubName = std::move(_o.clubName);
		tablePubName = std::move(_o.tablePubName);
		tournPubName = std::move(_o.tournPubName);
		memberRole = std::move(_o.memberRole);
		memberFlags = std::move(_o.memberFlags);
		wallPubName = std::move(_o.wallPubName);
		announcePubName = std::move(_o.announcePubName);
		membershipPubName = std::move(_o.membershipPubName);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	clubName.clear();
	tablePubName.clear();
	tournPubName.clear();
	memberRole = 0;
	memberFlags = 0;
	wallPubName.clear();
	announcePubName.clear();
	membershipPubName.clear();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY::equals(const Protocol_HG_GET_CLUB_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		clubName.equals(_o.clubName) &&
		tablePubName.equals(_o.tablePubName) &&
		tournPubName.equals(_o.tournPubName) &&
		memberRole == _o.memberRole &&
		memberFlags == _o.memberFlags &&
		wallPubName.equals(_o.wallPubName) &&
		announcePubName.equals(_o.announcePubName) &&
		membershipPubName.equals(_o.membershipPubName);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("clubName=");
		_buf.append(clubName);
		_buf.append(',');
		_buf.append("tablePubName=");
		_buf.append(tablePubName);
		_buf.append(',');
		_buf.append("tournPubName=");
		_buf.append(tournPubName);
		_buf.append(',');
		_buf.append("memberRole=");
		_buf.appendUint(memberRole);
		_buf.append(',');
		_buf.append("memberFlags=");
		_buf.appendUint(memberFlags);
		_buf.append(',');
		_buf.append("wallPubName=");
		_buf.append(wallPubName);
		_buf.append(',');
		_buf.append("announcePubName=");
		_buf.append(announcePubName);
		_buf.append(',');
		_buf.append("membershipPubName=");
		_buf.append(membershipPubName);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeString(clubName);
		_msg.composeString(tablePubName);
		_msg.composeString(tournPubName);
		_msg.composeUINT32(memberRole);
		_msg.composeUINT32(memberFlags);
		_msg.composeString(wallPubName);
		_msg.composeString(announcePubName);
		_msg.composeString(membershipPubName);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseStringP(clubName);
		_parser.parseStringP(tablePubName);
		_parser.parseStringP(tournPubName);
		_parser.parseUINT32(memberRole);
		_parser.parseUINT32(memberFlags);
		_parser.parseStringP(wallPubName);
		_parser.parseStringP(announcePubName);
		_parser.parseStringP(membershipPubName);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "clubName"); size_t szClubName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "clubName", szClubName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "tablePubName"); size_t szTablePubName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tablePubName", szTablePubName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "tournPubName"); size_t szTournPubName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tournPubName", szTournPubName, _checker, __FILE__, __LINE__);
		UINT32 memberRole; _parser.parseUINT32(memberRole);
		AtfValidator::validateInt(_descr, "memberRole", memberRole, _checker, __FILE__, __LINE__);
		UINT32 memberFlags; _parser.parseUINT32(memberFlags);
		AtfValidator::validateInt(_descr, "memberFlags", memberFlags, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "wallPubName"); size_t szWallPubName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "wallPubName", szWallPubName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "announcePubName"); size_t szAnnouncePubName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "announcePubName", szAnnouncePubName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "membershipPubName"); size_t szMembershipPubName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "membershipPubName", szMembershipPubName, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_SCHEDULED_GAMES
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES::Protocol_HG_GET_SCHEDULED_GAMES()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES::clear()
{
}

bool hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES::equals(const Protocol_HG_GET_SCHEDULED_GAMES& _o) const
{
	return true;
}

const char *hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_SCHEDULED_GAMES).append(")");
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES::composeMsg(CommMsgBody& _msg) const
{
}

void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_SCHEDULED_GAMES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    ScheduledTourn
//=================================================================

hglobby::lobby_client::ScheduledTourn::ScheduledTourn()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::ScheduledTourn::ScheduledTourn(ScheduledTourn&& _o)
	: startTime(std::move(_o.startTime))
	, clubId(std::move(_o.clubId))
	, clubName(std::move(_o.clubName))
	, tournId(std::move(_o.tournId))
	, tournName(std::move(_o.tournName))
	, gameType(std::move(_o.gameType))
	, isHiLo(std::move(_o.isHiLo))
	, buyin(std::move(_o.buyin))
	, rake(std::move(_o.rake))
	, knockoutBounty(std::move(_o.knockoutBounty))
	, numPlayers(std::move(_o.numPlayers))
	, isRegistered(std::move(_o.isRegistered))
	, limit(std::move(_o.limit))
	, currency(std::move(_o.currency))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, maxPlayers(std::move(_o.maxPlayers))
	, tournState(std::move(_o.tournState))
	, server(std::move(_o.server))
	, serverObject(std::move(_o.serverObject))
	, flags(std::move(_o.flags))
	, scalePM(std::move(_o.scalePM))
{
}

hglobby::lobby_client::ScheduledTourn& hglobby::lobby_client::ScheduledTourn::operator=(ScheduledTourn&& _o)
{
	if(this != &_o)
	{
		startTime = std::move(_o.startTime);
		clubId = std::move(_o.clubId);
		clubName = std::move(_o.clubName);
		tournId = std::move(_o.tournId);
		tournName = std::move(_o.tournName);
		gameType = std::move(_o.gameType);
		isHiLo = std::move(_o.isHiLo);
		buyin = std::move(_o.buyin);
		rake = std::move(_o.rake);
		knockoutBounty = std::move(_o.knockoutBounty);
		numPlayers = std::move(_o.numPlayers);
		isRegistered = std::move(_o.isRegistered);
		limit = std::move(_o.limit);
		currency = std::move(_o.currency);
		isPlayMoney = std::move(_o.isPlayMoney);
		maxPlayers = std::move(_o.maxPlayers);
		tournState = std::move(_o.tournState);
		server = std::move(_o.server);
		serverObject = std::move(_o.serverObject);
		flags = std::move(_o.flags);
		scalePM = std::move(_o.scalePM);
	}
	return *this;
}

#endif

void hglobby::lobby_client::ScheduledTourn::clear()
{
	startTime.setNull();
	clubId = 0;
	clubName.clear();
	tournId = 0;
	tournName.clear();
	gameType = 0;
	isHiLo = false;
	buyin = 0;
	rake = 0;
	knockoutBounty = 0;
	numPlayers = 0;
	isRegistered = false;
	limit = 0;
	currency.clear();
	isPlayMoney = false;
	maxPlayers = 0;
	tournState = 0;
	server.clear();
	serverObject.clear();
	flags = 0;
	scalePM = 0;
}

bool hglobby::lobby_client::ScheduledTourn::equals(const ScheduledTourn& _o) const
{
	return startTime.equals(_o.startTime) &&
		clubId == _o.clubId &&
		clubName.equals(_o.clubName) &&
		tournId == _o.tournId &&
		tournName.equals(_o.tournName) &&
		gameType == _o.gameType &&
		isHiLo == _o.isHiLo &&
		buyin == _o.buyin &&
		rake == _o.rake &&
		knockoutBounty == _o.knockoutBounty &&
		numPlayers == _o.numPlayers &&
		isRegistered == _o.isRegistered &&
		limit == _o.limit &&
		currency.equals(_o.currency) &&
		isPlayMoney == _o.isPlayMoney &&
		maxPlayers == _o.maxPlayers &&
		tournState == _o.tournState &&
		server.equals(_o.server) &&
		serverObject.equals(_o.serverObject) &&
		flags == _o.flags &&
		scalePM == _o.scalePM;
}

const char *hglobby::lobby_client::ScheduledTourn::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("startTime=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, startTime);
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("clubName=");
	_buf.append(clubName);
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("tournName=");
	_buf.append(tournName);
	_buf.append(',');
	_buf.append("gameType=");
	_buf.appendUint(gameType);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("buyin=");
	_buf.appendUint(buyin);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendUint(rake);
	_buf.append(',');
	_buf.append("knockoutBounty=");
	_buf.appendUint(knockoutBounty);
	_buf.append(',');
	_buf.append("numPlayers=");
	_buf.appendUint(numPlayers);
	_buf.append(',');
	_buf.append("isRegistered=");
	_buf.appendUint(isRegistered);
	_buf.append(',');
	_buf.append("limit=");
	_buf.appendUint(limit);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendUint(maxPlayers);
	_buf.append(',');
	_buf.append("tournState=");
	_buf.appendUint(tournState);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("serverObject=");
	_buf.append(serverObject);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append('}');
	return _buf.c_str();
}

void hglobby::lobby_client::ScheduledTourn::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(ScheduledTourn())) // not empty
	{
		_body.composeSrvTime(startTime);
		_body.composeUINT32(clubId);
		_body.composeString(clubName);
		_body.composeUINT32(tournId);
		_body.composeString(tournName);
		_body.composeBYTE(gameType);
		_body.composeBOOL(isHiLo);
		_body.composeUINT32(buyin);
		_body.composeUINT32(rake);
		_body.composeUINT32(knockoutBounty);
		_body.composeUINT32(numPlayers);
		_body.composeBOOL(isRegistered);
		_body.composeBYTE(limit);
		_body.composeString(currency);
		_body.composeBOOL(isPlayMoney);
		_body.composeUINT32(maxPlayers);
		_body.composeUINT32(tournState);
		_body.composeString(server);
		_body.composeString(serverObject);
		_body.composeUINT32(flags);
		_body.composeUINT32(scalePM);
	}

	_msg.composeMsgBody(_body);
}

void hglobby::lobby_client::ScheduledTourn::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseSrvTime(startTime);
	_parser0.parseUINT32(clubId);
	_parser0.parseStringP(clubName);
	_parser0.parseUINT32(tournId);
	_parser0.parseStringP(tournName);
	_parser0.parseBYTE(gameType);
	_parser0.parseBOOL(isHiLo);
	_parser0.parseUINT32(buyin);
	_parser0.parseUINT32(rake);
	_parser0.parseUINT32(knockoutBounty);
	_parser0.parseUINT32(numPlayers);
	_parser0.parseBOOL(isRegistered);
	_parser0.parseBYTE(limit);
	_parser0.parseStringP(currency);
	_parser0.parseBOOL(isPlayMoney);
	_parser0.parseUINT32(maxPlayers);
	_parser0.parseUINT32(tournState);
	_parser0.parseStringP(server);
	_parser0.parseStringP(serverObject);
	_parser0.parseUINT32(flags);
	_parser0.parseUINT32(scalePM);
}

/*static*/ void hglobby::lobby_client::ScheduledTourn::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	SrvTime startTime; _parser0.parseSrvTime(startTime);
	AtfValidator::validateSrvDateTime(_descr, "startTime", startTime, _checker, __FILE__, __LINE__);
	UINT32 clubId; _parser0.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "clubName"); size_t szClubName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "clubName", szClubName, _checker, __FILE__, __LINE__);
	UINT32 tournId; _parser0.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "tournName"); size_t szTournName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tournName", szTournName, _checker, __FILE__, __LINE__);
	BYTE gameType; _parser0.parseBYTE(gameType);
	AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
	bool isHiLo; _parser0.parseBOOL(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	UINT32 buyin; _parser0.parseUINT32(buyin);
	AtfValidator::validateInt(_descr, "buyin", buyin, _checker, __FILE__, __LINE__);
	UINT32 rake; _parser0.parseUINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	UINT32 knockoutBounty; _parser0.parseUINT32(knockoutBounty);
	AtfValidator::validateInt(_descr, "knockoutBounty", knockoutBounty, _checker, __FILE__, __LINE__);
	UINT32 numPlayers; _parser0.parseUINT32(numPlayers);
	AtfValidator::validateInt(_descr, "numPlayers", numPlayers, _checker, __FILE__, __LINE__);
	bool isRegistered; _parser0.parseBOOL(isRegistered);
	AtfValidator::validateInt(_descr, "isRegistered", isRegistered, _checker, __FILE__, __LINE__);
	BYTE limit; _parser0.parseBYTE(limit);
	AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _parser0.parseBOOL(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 maxPlayers; _parser0.parseUINT32(maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	UINT32 tournState; _parser0.parseUINT32(tournState);
	AtfValidator::validateInt(_descr, "tournState", tournState, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "serverObject"); size_t szServerObject = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObject", szServerObject, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser0.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser0.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ScheduledRingGame
//=================================================================

hglobby::lobby_client::ScheduledRingGame::ScheduledRingGame()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::ScheduledRingGame::ScheduledRingGame(ScheduledRingGame&& _o)
	: clubId(std::move(_o.clubId))
	, clubName(std::move(_o.clubName))
	, tableId32(std::move(_o.tableId32))
	, tableName(std::move(_o.tableName))
	, gameType(std::move(_o.gameType))
	, isHiLo(std::move(_o.isHiLo))
	, buyin(std::move(_o.buyin))
	, numPlayers(std::move(_o.numPlayers))
	, isSeated(std::move(_o.isSeated))
	, limit(std::move(_o.limit))
	, currency(std::move(_o.currency))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, lowStake(std::move(_o.lowStake))
	, highStake(std::move(_o.highStake))
	, tableObject(std::move(_o.tableObject))
	, maxNumPlayers(std::move(_o.maxNumPlayers))
	, playersSeated(std::move(_o.playersSeated))
	, flags(std::move(_o.flags))
	, tableId(std::move(_o.tableId))
	, scalePM(std::move(_o.scalePM))
{
}

hglobby::lobby_client::ScheduledRingGame& hglobby::lobby_client::ScheduledRingGame::operator=(ScheduledRingGame&& _o)
{
	if(this != &_o)
	{
		clubId = std::move(_o.clubId);
		clubName = std::move(_o.clubName);
		tableId32 = std::move(_o.tableId32);
		tableName = std::move(_o.tableName);
		gameType = std::move(_o.gameType);
		isHiLo = std::move(_o.isHiLo);
		buyin = std::move(_o.buyin);
		numPlayers = std::move(_o.numPlayers);
		isSeated = std::move(_o.isSeated);
		limit = std::move(_o.limit);
		currency = std::move(_o.currency);
		isPlayMoney = std::move(_o.isPlayMoney);
		lowStake = std::move(_o.lowStake);
		highStake = std::move(_o.highStake);
		tableObject = std::move(_o.tableObject);
		maxNumPlayers = std::move(_o.maxNumPlayers);
		playersSeated = std::move(_o.playersSeated);
		flags = std::move(_o.flags);
		tableId = std::move(_o.tableId);
		scalePM = std::move(_o.scalePM);
	}
	return *this;
}

#endif

void hglobby::lobby_client::ScheduledRingGame::clear()
{
	clubId = 0;
	clubName.clear();
	tableId32 = 0;
	tableName.clear();
	gameType = 0;
	isHiLo = false;
	buyin = 0;
	numPlayers = 0;
	isSeated = false;
	limit = 0;
	currency.clear();
	isPlayMoney = false;
	lowStake = 0;
	highStake = 0;
	tableObject.clear();
	maxNumPlayers = 0;
	playersSeated = 0;
	flags = 0;
	tableId = 0;
	scalePM = 0;
}

bool hglobby::lobby_client::ScheduledRingGame::equals(const ScheduledRingGame& _o) const
{
	return clubId == _o.clubId &&
		clubName.equals(_o.clubName) &&
		tableId32 == _o.tableId32 &&
		tableName.equals(_o.tableName) &&
		gameType == _o.gameType &&
		isHiLo == _o.isHiLo &&
		buyin == _o.buyin &&
		numPlayers == _o.numPlayers &&
		isSeated == _o.isSeated &&
		limit == _o.limit &&
		currency.equals(_o.currency) &&
		isPlayMoney == _o.isPlayMoney &&
		lowStake == _o.lowStake &&
		highStake == _o.highStake &&
		tableObject.equals(_o.tableObject) &&
		maxNumPlayers == _o.maxNumPlayers &&
		playersSeated == _o.playersSeated &&
		flags == _o.flags &&
		tableId == _o.tableId &&
		scalePM == _o.scalePM;
}

const char *hglobby::lobby_client::ScheduledRingGame::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("clubName=");
	_buf.append(clubName);
	_buf.append(',');
	_buf.append("tableId32=");
	_buf.appendUint(tableId32);
	_buf.append(',');
	_buf.append("tableName=");
	_buf.append(tableName);
	_buf.append(',');
	_buf.append("gameType=");
	_buf.appendUint(gameType);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("buyin=");
	_buf.appendUint(buyin);
	_buf.append(',');
	_buf.append("numPlayers=");
	_buf.appendUint(numPlayers);
	_buf.append(',');
	_buf.append("isSeated=");
	_buf.appendUint(isSeated);
	_buf.append(',');
	_buf.append("limit=");
	_buf.appendUint(limit);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("lowStake=");
	_buf.appendUint(lowStake);
	_buf.append(',');
	_buf.append("highStake=");
	_buf.appendUint(highStake);
	_buf.append(',');
	_buf.append("tableObject=");
	_buf.append(tableObject);
	_buf.append(',');
	_buf.append("maxNumPlayers=");
	_buf.appendUint(maxNumPlayers);
	_buf.append(',');
	_buf.append("playersSeated=");
	_buf.appendUint(playersSeated);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendInt(scalePM);
	_buf.append('}');
	return _buf.c_str();
}

void hglobby::lobby_client::ScheduledRingGame::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(ScheduledRingGame())) // not empty
	{
		_body.composeUINT32(clubId);
		_body.composeString(clubName);
		_body.composeUINT32(tableId32);
		_body.composeString(tableName);
		_body.composeBYTE(gameType);
		_body.composeBOOL(isHiLo);
		_body.composeUINT32(buyin);
		_body.composeUINT32(numPlayers);
		_body.composeBOOL(isSeated);
		_body.composeBYTE(limit);
		_body.composeString(currency);
		_body.composeBOOL(isPlayMoney);
		_body.composeUINT32(lowStake);
		_body.composeUINT32(highStake);
		_body.composeString(tableObject);
		_body.composeUINT32(maxNumPlayers);
		_body.composeUINT32(playersSeated);
		_body.composeUINT32(flags);
		_body.composeUINT64(tableId);
		_body.composeINT32(scalePM);
	}

	_msg.composeMsgBody(_body);
}

void hglobby::lobby_client::ScheduledRingGame::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(clubId);
	_parser0.parseStringP(clubName);
	_parser0.parseUINT32(tableId32);
	_parser0.parseStringP(tableName);
	_parser0.parseBYTE(gameType);
	_parser0.parseBOOL(isHiLo);
	_parser0.parseUINT32(buyin);
	_parser0.parseUINT32(numPlayers);
	_parser0.parseBOOL(isSeated);
	_parser0.parseBYTE(limit);
	_parser0.parseStringP(currency);
	_parser0.parseBOOL(isPlayMoney);
	_parser0.parseUINT32(lowStake);
	_parser0.parseUINT32(highStake);
	_parser0.parseStringP(tableObject);
	_parser0.parseUINT32(maxNumPlayers);
	_parser0.parseUINT32(playersSeated);
	_parser0.parseUINT32(flags);
	_parser0.parseUINT64(tableId);
	_parser0.parseINT32(scalePM);
}

/*static*/ void hglobby::lobby_client::ScheduledRingGame::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 clubId; _parser0.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "clubName"); size_t szClubName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "clubName", szClubName, _checker, __FILE__, __LINE__);
	UINT32 tableId32; _parser0.parseUINT32(tableId32);
	AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "tableName"); size_t szTableName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tableName", szTableName, _checker, __FILE__, __LINE__);
	BYTE gameType; _parser0.parseBYTE(gameType);
	AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
	bool isHiLo; _parser0.parseBOOL(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	UINT32 buyin; _parser0.parseUINT32(buyin);
	AtfValidator::validateInt(_descr, "buyin", buyin, _checker, __FILE__, __LINE__);
	UINT32 numPlayers; _parser0.parseUINT32(numPlayers);
	AtfValidator::validateInt(_descr, "numPlayers", numPlayers, _checker, __FILE__, __LINE__);
	bool isSeated; _parser0.parseBOOL(isSeated);
	AtfValidator::validateInt(_descr, "isSeated", isSeated, _checker, __FILE__, __LINE__);
	BYTE limit; _parser0.parseBYTE(limit);
	AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _parser0.parseBOOL(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 lowStake; _parser0.parseUINT32(lowStake);
	AtfValidator::validateInt(_descr, "lowStake", lowStake, _checker, __FILE__, __LINE__);
	UINT32 highStake; _parser0.parseUINT32(highStake);
	AtfValidator::validateInt(_descr, "highStake", highStake, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "tableObject"); size_t szTableObject = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tableObject", szTableObject, _checker, __FILE__, __LINE__);
	UINT32 maxNumPlayers; _parser0.parseUINT32(maxNumPlayers);
	AtfValidator::validateInt(_descr, "maxNumPlayers", maxNumPlayers, _checker, __FILE__, __LINE__);
	UINT32 playersSeated; _parser0.parseUINT32(playersSeated);
	AtfValidator::validateInt(_descr, "playersSeated", playersSeated, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser0.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT64 tableId; _parser0.parseUINT64(tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	INT32 scalePM; _parser0.parseINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_HG_GET_SCHEDULED_GAMES_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY::Protocol_HG_GET_SCHEDULED_GAMES_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY::Protocol_HG_GET_SCHEDULED_GAMES_REPLY(Protocol_HG_GET_SCHEDULED_GAMES_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, tourns(std::move(_o.tourns))
	, ringGames(std::move(_o.ringGames))
	, msgBoard(std::move(_o.msgBoard))
{
}

hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY& hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY::operator=(Protocol_HG_GET_SCHEDULED_GAMES_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		tourns = std::move(_o.tourns);
		ringGames = std::move(_o.ringGames);
		msgBoard = std::move(_o.msgBoard);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	tourns.clear();
	ringGames.clear();
	msgBoard.clear();
}

bool hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY::equals(const Protocol_HG_GET_SCHEDULED_GAMES_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		tourns.equals(_o.tourns) &&
		ringGames.equals(_o.ringGames) &&
		msgBoard.equals(_o.msgBoard);
}

const char *hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_SCHEDULED_GAMES_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("tourns=");
		tourns.toTraceString(_buf);
		_buf.append(',');
		_buf.append("ringGames=");
		ringGames.toTraceString(_buf);
		_buf.append(',');
		_buf.append("msgBoard=");
		_buf.append(msgBoard);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		tourns.composeMsg(_msg);
		ringGames.composeMsg(_msg);
		_msg.composeString(msgBoard);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		tourns.parseMsg(_parser);
		ringGames.parseMsg(_parser);
		_parser.parseStringP(msgBoard);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_SCHEDULED_GAMES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szTourns = ThinAtf::LAtfVector< ScheduledTourn, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
		int szRingGames = ThinAtf::LAtfVector< ScheduledRingGame, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("ringGames"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "ringGames", szRingGames, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "msgBoard"); size_t szMsgBoard = strlen(_dummy);
		AtfValidator::validateInt(_descr, "msgBoard", szMsgBoard, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_FOUNDER_GET_CLUB_PASSWORD
//=================================================================

hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD::clear()
{
	clubId = 0;
}

bool hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD::equals(const Protocol_HG_FOUNDER_GET_CLUB_PASSWORD& _o) const
{
	return clubId == _o.clubId;
}

const char *hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_FOUNDER_GET_CLUB_PASSWORD).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(clubId);
}

void hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_FOUNDER_GET_CLUB_PASSWORD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_FOUNDER_GET_CLUB_PASSWORD_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD_REPLY::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD_REPLY::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD_REPLY(Protocol_HG_FOUNDER_GET_CLUB_PASSWORD_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, password(std::move(_o.password))
{
}

hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD_REPLY& hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD_REPLY::operator=(Protocol_HG_FOUNDER_GET_CLUB_PASSWORD_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		password = std::move(_o.password);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	password.clear();
}

bool hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD_REPLY::equals(const Protocol_HG_FOUNDER_GET_CLUB_PASSWORD_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		password.equals(_o.password);
}

const char *hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_FOUNDER_GET_CLUB_PASSWORD_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("password=");
		_buf.append(password);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeString(password);
	}
}

void hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseStringP(password);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_FOUNDER_GET_CLUB_PASSWORD_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "password"); size_t szPassword = strlen(_dummy);
		AtfValidator::validateInt(_descr, "password", szPassword, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN::clear()
{
	clubId = 0;
}

bool hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN::equals(const Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN& _o) const
{
	return clubId == _o.clubId;
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_RECRUIT_SOCIAL_TOKEN).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(clubId);
}

void hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_RECRUIT_SOCIAL_TOKEN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY(Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, sotialToken(std::move(_o.sotialToken))
{
}

hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY& hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY::operator=(Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		sotialToken = std::move(_o.sotialToken);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	sotialToken.clear();
}

bool hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY::equals(const Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		sotialToken.equals(_o.sotialToken);
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("sotialToken=");
		_buf.append(sotialToken);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeString(sotialToken);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseStringP(sotialToken);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "sotialToken"); size_t szSotialToken = strlen(_dummy);
		AtfValidator::validateInt(_descr, "sotialToken", szSotialToken, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CLOSE_CLUB_BY_FOUNDER
//=================================================================

hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER::Protocol_HG_CLOSE_CLUB_BY_FOUNDER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER::Protocol_HG_CLOSE_CLUB_BY_FOUNDER(Protocol_HG_CLOSE_CLUB_BY_FOUNDER&& _o)
	: clubId(std::move(_o.clubId))
	, playerStatus(std::move(_o.playerStatus))
	, dummy(std::move(_o.dummy))
	, userId(std::move(_o.userId))
{
}

hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER& hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER::operator=(Protocol_HG_CLOSE_CLUB_BY_FOUNDER&& _o)
{
	if(this != &_o)
	{
		clubId = std::move(_o.clubId);
		playerStatus = std::move(_o.playerStatus);
		dummy = std::move(_o.dummy);
		userId = std::move(_o.userId);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER::clear()
{
	clubId = 0;
	playerStatus = 0;
	dummy = 0;
	userId.clear();
}

bool hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER::equals(const Protocol_HG_CLOSE_CLUB_BY_FOUNDER& _o) const
{
	return clubId == _o.clubId &&
		playerStatus == _o.playerStatus &&
		dummy == _o.dummy &&
		userId.equals(_o.userId);
}

const char *hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CLOSE_CLUB_BY_FOUNDER).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("playerStatus=");
	_buf.appendUint(playerStatus);
	_buf.append(',');
	_buf.append("dummy=");
	_buf.appendUint(dummy);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(clubId);
	_msg.composeUINT32(playerStatus);
	_msg.composeUINT32(dummy);
	_msg.composeString(userId);
}

void hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(playerStatus);
	_parser.parseUINT32(dummy);
	_parser.parseStringP(userId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CLOSE_CLUB_BY_FOUNDER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 playerStatus; _parser.parseUINT32(playerStatus);
	AtfValidator::validateIntMax(_descr, "playerStatus", playerStatus, HgChangePlayerStatusAction_Last, _checker, __FILE__, __LINE__);
	UINT32 dummy; _parser.parseUINT32(dummy);
	AtfValidator::validateInt(_descr, "dummy", dummy, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CLOSE_CLUB_BY_FOUNDER_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER_REPLY::Protocol_HG_CLOSE_CLUB_BY_FOUNDER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER_REPLY::Protocol_HG_CLOSE_CLUB_BY_FOUNDER_REPLY(Protocol_HG_CLOSE_CLUB_BY_FOUNDER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER_REPLY& hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER_REPLY::operator=(Protocol_HG_CLOSE_CLUB_BY_FOUNDER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER_REPLY::equals(const Protocol_HG_CLOSE_CLUB_BY_FOUNDER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc);
}

const char *hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CLOSE_CLUB_BY_FOUNDER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errDesc=");
	_buf.append(errDesc);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errDesc);
}

void hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(errDesc);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CLOSE_CLUB_BY_FOUNDER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CHANGE_SEASON_NAME
//=================================================================

hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME::Protocol_HG_CHANGE_SEASON_NAME()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME::Protocol_HG_CHANGE_SEASON_NAME(Protocol_HG_CHANGE_SEASON_NAME&& _o)
	: clubId(std::move(_o.clubId))
	, seasonId(std::move(_o.seasonId))
	, seasonName(std::move(_o.seasonName))
{
}

hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME& hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME::operator=(Protocol_HG_CHANGE_SEASON_NAME&& _o)
{
	if(this != &_o)
	{
		clubId = std::move(_o.clubId);
		seasonId = std::move(_o.seasonId);
		seasonName = std::move(_o.seasonName);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME::clear()
{
	clubId = 0;
	seasonId = 0;
	seasonName.clear();
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME::equals(const Protocol_HG_CHANGE_SEASON_NAME& _o) const
{
	return clubId == _o.clubId &&
		seasonId == _o.seasonId &&
		seasonName.equals(_o.seasonName);
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CHANGE_SEASON_NAME).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("seasonId=");
	_buf.appendUint(seasonId);
	_buf.append(',');
	_buf.append("seasonName=");
	_buf.append(seasonName);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(clubId);
	_msg.composeUINT32(seasonId);
	_msg.composeString(seasonName);
}

void hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	_parser.parseUINT32(seasonId);
	_parser.parseStringP(seasonName);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CHANGE_SEASON_NAME";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 seasonId; _parser.parseUINT32(seasonId);
	AtfValidator::validateInt(_descr, "seasonId", seasonId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "seasonName"); size_t szSeasonName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "seasonName", szSeasonName, 128, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CHANGE_SEASON_NAME_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME_REPLY::Protocol_HG_CHANGE_SEASON_NAME_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME_REPLY::Protocol_HG_CHANGE_SEASON_NAME_REPLY(Protocol_HG_CHANGE_SEASON_NAME_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME_REPLY& hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME_REPLY::operator=(Protocol_HG_CHANGE_SEASON_NAME_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME_REPLY::equals(const Protocol_HG_CHANGE_SEASON_NAME_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc);
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CHANGE_SEASON_NAME_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errDesc=");
	_buf.append(errDesc);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errDesc);
}

void hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(errDesc);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CHANGE_SEASON_NAME_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_PROCESS_SEASON_CLOSED
//=================================================================

hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED::Protocol_HG_PROCESS_SEASON_CLOSED()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED::Protocol_HG_PROCESS_SEASON_CLOSED(Protocol_HG_PROCESS_SEASON_CLOSED&& _o)
	: seasonId(std::move(_o.seasonId))
	, timeFrom(std::move(_o.timeFrom))
	, timeTo(std::move(_o.timeTo))
	, closed(std::move(_o.closed))
	, seasonType(std::move(_o.seasonType))
	, seasonName(std::move(_o.seasonName))
	, clubId(std::move(_o.clubId))
{
}

hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED& hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED::operator=(Protocol_HG_PROCESS_SEASON_CLOSED&& _o)
{
	if(this != &_o)
	{
		seasonId = std::move(_o.seasonId);
		timeFrom = std::move(_o.timeFrom);
		timeTo = std::move(_o.timeTo);
		closed = std::move(_o.closed);
		seasonType = std::move(_o.seasonType);
		seasonName = std::move(_o.seasonName);
		clubId = std::move(_o.clubId);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED::clear()
{
	seasonId = 0;
	timeFrom.setNull();
	timeTo.setNull();
	closed = false;
	seasonType = 0;
	seasonName.clear();
	clubId = 0;
}

bool hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED::equals(const Protocol_HG_PROCESS_SEASON_CLOSED& _o) const
{
	return seasonId == _o.seasonId &&
		timeFrom.equals(_o.timeFrom) &&
		timeTo.equals(_o.timeTo) &&
		closed == _o.closed &&
		seasonType == _o.seasonType &&
		seasonName.equals(_o.seasonName) &&
		clubId == _o.clubId;
}

const char *hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_PROCESS_SEASON_CLOSED).append(")");
	_buf.append(',');
	_buf.append("seasonId=");
	_buf.appendUint(seasonId);
	_buf.append(',');
	_buf.append("timeFrom=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, timeFrom);
	_buf.append(',');
	_buf.append("timeTo=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, timeTo);
	_buf.append(',');
	_buf.append("closed=");
	_buf.appendUint(closed);
	_buf.append(',');
	_buf.append("seasonType=");
	_buf.appendUint(seasonType);
	_buf.append(',');
	_buf.append("seasonName=");
	_buf.append(seasonName);
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(seasonId);
	_msg.composeSrvTime(timeFrom);
	_msg.composeSrvTime(timeTo);
	_msg.composeBOOL(closed);
	_msg.composeUINT32(seasonType);
	_msg.composeString(seasonName);
	_msg.composeUINT32(clubId);
}

void hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(seasonId);
	_parser.parseSrvTime(timeFrom);
	_parser.parseSrvTime(timeTo);
	_parser.parseBOOL(closed);
	_parser.parseUINT32(seasonType);
	_parser.parseStringP(seasonName);
	_parser.parseUINT32(clubId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_PROCESS_SEASON_CLOSED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 seasonId; _parser.parseUINT32(seasonId);
	AtfValidator::validateInt(_descr, "seasonId", seasonId, _checker, __FILE__, __LINE__);
	SrvTime timeFrom; _parser.parseSrvTime(timeFrom);
	AtfValidator::validateSrvDateTime(_descr, "timeFrom", timeFrom, _checker, __FILE__, __LINE__);
	SrvTime timeTo; _parser.parseSrvTime(timeTo);
	AtfValidator::validateSrvDateTime(_descr, "timeTo", timeTo, _checker, __FILE__, __LINE__);
	bool closed; _parser.parseBOOL(closed);
	AtfValidator::validateInt(_descr, "closed", closed, _checker, __FILE__, __LINE__);
	UINT32 seasonType; _parser.parseUINT32(seasonType);
	AtfValidator::validateIntRange(_descr, "seasonType", seasonType, eHgClubSeasonsYearly, eHgClubSeasonsMonthly, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "seasonName"); size_t szSeasonName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "seasonName", szSeasonName, 128, _checker, __FILE__, __LINE__);
	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_PROCESS_SEASON_CLOSED_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED_REPLY::Protocol_HG_PROCESS_SEASON_CLOSED_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED_REPLY::Protocol_HG_PROCESS_SEASON_CLOSED_REPLY(Protocol_HG_PROCESS_SEASON_CLOSED_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED_REPLY& hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED_REPLY::operator=(Protocol_HG_PROCESS_SEASON_CLOSED_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED_REPLY::equals(const Protocol_HG_PROCESS_SEASON_CLOSED_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc);
}

const char *hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_PROCESS_SEASON_CLOSED_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_PROCESS_SEASON_CLOSED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_MODIFY_MEMBERSHIP_FLAGS
//=================================================================

hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS::clear()
{
	clubId = 0;
	flags = 0;
}

bool hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS::equals(const Protocol_HG_MODIFY_MEMBERSHIP_FLAGS& _o) const
{
	return clubId == _o.clubId &&
		flags == _o.flags;
}

const char *hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_MODIFY_MEMBERSHIP_FLAGS).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(clubId);
	_msg.composeUINT32(flags);
}

void hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	_parser.parseUINT32(flags);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_MODIFY_MEMBERSHIP_FLAGS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser.parseUINT32(flags);
	AtfValidator::validateIntRange(_descr, "flags", flags, eHgTournFormatRegular, eHgTournFormatRebuy2RnoA, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_MODIFY_MEMBERSHIP_FLAGS_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS_REPLY::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS_REPLY::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS_REPLY(Protocol_HG_MODIFY_MEMBERSHIP_FLAGS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS_REPLY& hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS_REPLY::operator=(Protocol_HG_MODIFY_MEMBERSHIP_FLAGS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS_REPLY::equals(const Protocol_HG_MODIFY_MEMBERSHIP_FLAGS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc);
}

const char *hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_MODIFY_MEMBERSHIP_FLAGS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_MODIFY_MEMBERSHIP_FLAGS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_SET_FAVORITE_CLUB
//=================================================================

hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB::Protocol_HG_SET_FAVORITE_CLUB()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB::clear()
{
	clubId = 0;
	isFavoriteClub = false;
}

bool hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB::equals(const Protocol_HG_SET_FAVORITE_CLUB& _o) const
{
	return clubId == _o.clubId &&
		isFavoriteClub == _o.isFavoriteClub;
}

const char *hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_SET_FAVORITE_CLUB).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("isFavoriteClub=");
	_buf.appendUint(isFavoriteClub);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(clubId);
	_msg.composeBOOL(isFavoriteClub);
}

void hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	_parser.parseBOOL(isFavoriteClub);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_SET_FAVORITE_CLUB";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	bool isFavoriteClub; _parser.parseBOOL(isFavoriteClub);
	AtfValidator::validateInt(_descr, "isFavoriteClub", isFavoriteClub, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_SET_FAVORITE_CLUB_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB_REPLY::Protocol_HG_SET_FAVORITE_CLUB_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB_REPLY::Protocol_HG_SET_FAVORITE_CLUB_REPLY(Protocol_HG_SET_FAVORITE_CLUB_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB_REPLY& hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB_REPLY::operator=(Protocol_HG_SET_FAVORITE_CLUB_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB_REPLY::equals(const Protocol_HG_SET_FAVORITE_CLUB_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc);
}

const char *hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_SET_FAVORITE_CLUB_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_SET_FAVORITE_CLUB_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_TABLE_SOCIAL_TOKEN
//=================================================================

hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN::Protocol_HG_TABLE_SOCIAL_TOKEN()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN::clear()
{
	clubId = 0;
	tableId32 = 0;
	tableId = 0;
}

bool hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN::equals(const Protocol_HG_TABLE_SOCIAL_TOKEN& _o) const
{
	return clubId == _o.clubId &&
		tableId32 == _o.tableId32 &&
		tableId == _o.tableId;
}

const char *hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_TABLE_SOCIAL_TOKEN).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("tableId32=");
	_buf.appendUint(tableId32);
	_buf.append(',');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(clubId);
	_msg.composeUINT32(tableId32);
	_msg.composeUINT64(tableId);
}

void hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	_parser.parseUINT32(tableId32);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(tableId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_TABLE_SOCIAL_TOKEN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 tableId32; _parser.parseUINT32(tableId32);
	AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 tableId; _parser.parseUINT64(tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_TABLE_SOCIAL_TOKEN_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN_REPLY::Protocol_HG_TABLE_SOCIAL_TOKEN_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN_REPLY::Protocol_HG_TABLE_SOCIAL_TOKEN_REPLY(Protocol_HG_TABLE_SOCIAL_TOKEN_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, socialToken(std::move(_o.socialToken))
{
}

hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN_REPLY& hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN_REPLY::operator=(Protocol_HG_TABLE_SOCIAL_TOKEN_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		socialToken = std::move(_o.socialToken);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	socialToken.clear();
}

bool hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN_REPLY::equals(const Protocol_HG_TABLE_SOCIAL_TOKEN_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		socialToken.equals(_o.socialToken);
}

const char *hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_TABLE_SOCIAL_TOKEN_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("socialToken=");
		_buf.append(socialToken);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeString(socialToken);
	}
}

void hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseStringP(socialToken);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_TABLE_SOCIAL_TOKEN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "socialToken"); size_t szSocialToken = strlen(_dummy);
		AtfValidator::validateInt(_descr, "socialToken", szSocialToken, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_TOURN_SOCIAL_TOKEN
//=================================================================

hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN::Protocol_HG_TOURN_SOCIAL_TOKEN()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN::clear()
{
	clubId = 0;
	tournId = 0;
}

bool hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN::equals(const Protocol_HG_TOURN_SOCIAL_TOKEN& _o) const
{
	return clubId == _o.clubId &&
		tournId == _o.tournId;
}

const char *hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_TOURN_SOCIAL_TOKEN).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(clubId);
	_msg.composeUINT32(tournId);
}

void hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	_parser.parseUINT32(tournId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_TOURN_SOCIAL_TOKEN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_TOURN_SOCIAL_TOKEN_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN_REPLY::Protocol_HG_TOURN_SOCIAL_TOKEN_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN_REPLY::Protocol_HG_TOURN_SOCIAL_TOKEN_REPLY(Protocol_HG_TOURN_SOCIAL_TOKEN_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, socialToken(std::move(_o.socialToken))
{
}

hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN_REPLY& hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN_REPLY::operator=(Protocol_HG_TOURN_SOCIAL_TOKEN_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		socialToken = std::move(_o.socialToken);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	socialToken.clear();
}

bool hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN_REPLY::equals(const Protocol_HG_TOURN_SOCIAL_TOKEN_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		socialToken.equals(_o.socialToken);
}

const char *hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_TOURN_SOCIAL_TOKEN_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("socialToken=");
		_buf.append(socialToken);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeString(socialToken);
	}
}

void hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseStringP(socialToken);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_TOURN_SOCIAL_TOKEN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "socialToken"); size_t szSocialToken = strlen(_dummy);
		AtfValidator::validateInt(_descr, "socialToken", szSocialToken, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    ClubMessageData
//=================================================================

hglobby::lobby_client::ClubMessageData::ClubMessageData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::ClubMessageData::ClubMessageData(ClubMessageData&& _o)
	: type(std::move(_o.type))
	, id(std::move(_o.id))
	, clubId(std::move(_o.clubId))
	, pinnedPos(std::move(_o.pinnedPos))
	, parentId(std::move(_o.parentId))
	, userIntId(std::move(_o.userIntId))
	, created(std::move(_o.created))
	, userId(std::move(_o.userId))
	, content(std::move(_o.content))
	, obsolete(std::move(_o.obsolete))
	, roleFlags(std::move(_o.roleFlags))
	, flags(std::move(_o.flags))
{
}

hglobby::lobby_client::ClubMessageData& hglobby::lobby_client::ClubMessageData::operator=(ClubMessageData&& _o)
{
	if(this != &_o)
	{
		type = std::move(_o.type);
		id = std::move(_o.id);
		clubId = std::move(_o.clubId);
		pinnedPos = std::move(_o.pinnedPos);
		parentId = std::move(_o.parentId);
		userIntId = std::move(_o.userIntId);
		created = std::move(_o.created);
		userId = std::move(_o.userId);
		content = std::move(_o.content);
		obsolete = std::move(_o.obsolete);
		roleFlags = std::move(_o.roleFlags);
		flags = std::move(_o.flags);
	}
	return *this;
}

#endif

void hglobby::lobby_client::ClubMessageData::clear()
{
	type = 0;
	id = 0;
	clubId = 0;
	pinnedPos = 0;
	parentId = 0;
	userIntId = 0;
	created.setNull();
	userId.clear();
	content.clear();
	obsolete = false;
	roleFlags = 0;
	flags = 0;
}

bool hglobby::lobby_client::ClubMessageData::equals(const ClubMessageData& _o) const
{
	return type == _o.type &&
		id == _o.id &&
		clubId == _o.clubId &&
		pinnedPos == _o.pinnedPos &&
		parentId == _o.parentId &&
		userIntId == _o.userIntId &&
		created.equals(_o.created) &&
		userId.equals(_o.userId) &&
		content.equals(_o.content) &&
		obsolete == _o.obsolete &&
		roleFlags == _o.roleFlags &&
		flags == _o.flags;
}

const char *hglobby::lobby_client::ClubMessageData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("type=");
	_buf.appendUint(type);
	_buf.append(',');
	_buf.append("id=");
	_buf.appendUint64(id);
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("pinnedPos=");
	_buf.appendUint(pinnedPos);
	_buf.append(',');
	_buf.append("parentId=");
	_buf.appendUint64(parentId);
	_buf.append(',');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	_buf.append(',');
	_buf.append("created=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, created);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("content=");
	_buf.append(content);
	_buf.append(',');
	_buf.append("obsolete=");
	_buf.appendUint(obsolete);
	_buf.append(',');
	_buf.append("roleFlags=");
	_buf.appendUint(roleFlags);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append('}');
	return _buf.c_str();
}

void hglobby::lobby_client::ClubMessageData::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(type);
	_msg.composeUINT64(id);
	_msg.composeUINT32(clubId);
	_msg.composeUINT32(pinnedPos);
	_msg.composeUINT64(parentId);
	_msg.composeUINT32(userIntId);
	_msg.composeSrvTime(created);
	_msg.composeString(userId);
	_msg.composeString(content);
	_msg.composeBOOL(obsolete);
	_msg.composeUINT32(roleFlags);
	_msg.composeUINT32(flags);
}

void hglobby::lobby_client::ClubMessageData::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(type);
	_parser.parseUINT64(id);
	_parser.parseUINT32(clubId);
	_parser.parseUINT32(pinnedPos);
	_parser.parseUINT64(parentId);
	_parser.parseUINT32(userIntId);
	_parser.parseSrvTime(created);
	_parser.parseStringP(userId);
	_parser.parseStringP(content);
	_parser.parseBOOL(obsolete);
	_parser.parseUINT32(roleFlags);
	_parser.parseUINT32(flags);
}

/*static*/ void hglobby::lobby_client::ClubMessageData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 type; _parser.parseUINT32(type);
	AtfValidator::validateIntRange(_descr, "type", type, eHgMessageTypeWall, eHgMessageTypeLast, _checker, __FILE__, __LINE__);
	UINT64 id; _parser.parseUINT64(id);
	AtfValidator::validateUint(_descr, "id", id, _checker, __FILE__, __LINE__);
	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 pinnedPos; _parser.parseUINT32(pinnedPos);
	AtfValidator::validateInt(_descr, "pinnedPos", pinnedPos, _checker, __FILE__, __LINE__);
	UINT64 parentId; _parser.parseUINT64(parentId);
	AtfValidator::validateUint(_descr, "parentId", parentId, _checker, __FILE__, __LINE__);
	UINT32 userIntId; _parser.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	SrvTime created; _parser.parseSrvTime(created);
	AtfValidator::validateSrvDateTime(_descr, "created", created, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, 20, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "content"); size_t szContent = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "content", szContent, 10000, _checker, __FILE__, __LINE__);
	bool obsolete; _parser.parseBOOL(obsolete);
	AtfValidator::validateInt(_descr, "obsolete", obsolete, _checker, __FILE__, __LINE__);
	UINT32 roleFlags; _parser.parseUINT32(roleFlags);
	AtfValidator::validateIntRange(_descr, "roleFlags", roleFlags, eHrMemberRoleMember, eHrMemberRoleSuspended, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser.parseUINT32(flags);
	AtfValidator::validateIntRange(_descr, "flags", flags, eHgTournFormatRegular, eHgTournFormatRebuy2RnoA, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_HG_SAVE_CLUB_MESSAGE
//=================================================================

hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE::Protocol_HG_SAVE_CLUB_MESSAGE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE::Protocol_HG_SAVE_CLUB_MESSAGE(Protocol_HG_SAVE_CLUB_MESSAGE&& _o)
	: clubMessageData(std::move(_o.clubMessageData))
{
}

hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE& hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE::operator=(Protocol_HG_SAVE_CLUB_MESSAGE&& _o)
{
	if(this != &_o)
	{
		clubMessageData = std::move(_o.clubMessageData);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE::clear()
{
	clubMessageData.clear();
}

bool hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE::equals(const Protocol_HG_SAVE_CLUB_MESSAGE& _o) const
{
	return clubMessageData.equals(_o.clubMessageData);
}

const char *hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_SAVE_CLUB_MESSAGE).append(")");
	_buf.append(',');
	_buf.append("clubMessageData=");
	clubMessageData.toTraceString(_buf);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE::composeMsg(CommMsgBody& _msg) const
{
	clubMessageData.composeMsg(_msg);
}

void hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE::parseMsg(CommMsgParser& _parser)
{
	clubMessageData.parseMsg(_parser);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_SAVE_CLUB_MESSAGE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	ClubMessageData::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clubMessageData"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_SAVE_CLUB_MESSAGE_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE_REPLY::Protocol_HG_SAVE_CLUB_MESSAGE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE_REPLY::Protocol_HG_SAVE_CLUB_MESSAGE_REPLY(Protocol_HG_SAVE_CLUB_MESSAGE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, clubMessageData(std::move(_o.clubMessageData))
{
}

hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE_REPLY& hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE_REPLY::operator=(Protocol_HG_SAVE_CLUB_MESSAGE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		clubMessageData = std::move(_o.clubMessageData);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	clubMessageData.clear();
}

bool hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE_REPLY::equals(const Protocol_HG_SAVE_CLUB_MESSAGE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		clubMessageData.equals(_o.clubMessageData);
}

const char *hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_SAVE_CLUB_MESSAGE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("clubMessageData=");
		clubMessageData.toTraceString(_buf);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		clubMessageData.composeMsg(_msg);
	}
}

void hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		clubMessageData.parseMsg(_parser);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_SAVE_CLUB_MESSAGE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		ClubMessageData::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clubMessageData"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CLUB_LOGIN
//=================================================================

hglobby::lobby_client::Protocol_HG_CLUB_LOGIN::Protocol_HG_CLUB_LOGIN()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_CLUB_LOGIN::clear()
{
	clubId = 0;
}

bool hglobby::lobby_client::Protocol_HG_CLUB_LOGIN::equals(const Protocol_HG_CLUB_LOGIN& _o) const
{
	return clubId == _o.clubId;
}

const char *hglobby::lobby_client::Protocol_HG_CLUB_LOGIN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CLUB_LOGIN).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CLUB_LOGIN::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(clubId);
}

void hglobby::lobby_client::Protocol_HG_CLUB_LOGIN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CLUB_LOGIN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CLUB_LOGIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CLUB_LOGIN_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_CLUB_LOGIN_REPLY::Protocol_HG_CLUB_LOGIN_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_CLUB_LOGIN_REPLY::Protocol_HG_CLUB_LOGIN_REPLY(Protocol_HG_CLUB_LOGIN_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

hglobby::lobby_client::Protocol_HG_CLUB_LOGIN_REPLY& hglobby::lobby_client::Protocol_HG_CLUB_LOGIN_REPLY::operator=(Protocol_HG_CLUB_LOGIN_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_CLUB_LOGIN_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool hglobby::lobby_client::Protocol_HG_CLUB_LOGIN_REPLY::equals(const Protocol_HG_CLUB_LOGIN_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc);
}

const char *hglobby::lobby_client::Protocol_HG_CLUB_LOGIN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CLUB_LOGIN_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CLUB_LOGIN_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void hglobby::lobby_client::Protocol_HG_CLUB_LOGIN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CLUB_LOGIN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CLUB_LOGIN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CLUB_LOGOUT
//=================================================================

hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT::Protocol_HG_CLUB_LOGOUT()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT::clear()
{
	clubId = 0;
}

bool hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT::equals(const Protocol_HG_CLUB_LOGOUT& _o) const
{
	return clubId == _o.clubId;
}

const char *hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CLUB_LOGOUT).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(clubId);
}

void hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CLUB_LOGOUT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CLUB_LOGOUT_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT_REPLY::Protocol_HG_CLUB_LOGOUT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT_REPLY::Protocol_HG_CLUB_LOGOUT_REPLY(Protocol_HG_CLUB_LOGOUT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT_REPLY& hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT_REPLY::operator=(Protocol_HG_CLUB_LOGOUT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT_REPLY::equals(const Protocol_HG_CLUB_LOGOUT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc);
}

const char *hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CLUB_LOGOUT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CLUB_LOGOUT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2
//=================================================================

hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2(Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2&& _o)
	: clubId(std::move(_o.clubId))
	, flags(std::move(_o.flags))
	, mask(std::move(_o.mask))
	, userIds(std::move(_o.userIds))
{
}

hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2& hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2::operator=(Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2&& _o)
{
	if(this != &_o)
	{
		clubId = std::move(_o.clubId);
		flags = std::move(_o.flags);
		mask = std::move(_o.mask);
		userIds = std::move(_o.userIds);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2::clear()
{
	clubId = 0;
	flags = 0;
	mask = 0;
	userIds.clear();
}

bool hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2::equals(const Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2& _o) const
{
	return clubId == _o.clubId &&
		flags == _o.flags &&
		mask == _o.mask &&
		userIds.equals(_o.userIds);
}

const char *hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_UPDATE_MEMBERSHIP_FLAGS2).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("mask=");
	_buf.appendUint(mask);
	_buf.append(',');
	_buf.append("userIds=");
	userIds.toTraceString(_buf);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(clubId);
	_msg.composeUINT32(flags);
	_msg.composeUINT32(mask);
	userIds.composeMsg(_msg);
}

void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	_parser.parseUINT32(flags);
	_parser.parseUINT32(mask);
	userIds.parseMsg(_parser);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_UPDATE_MEMBERSHIP_FLAGS2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser.parseUINT32(flags);
	AtfValidator::validateIntMax(_descr, "flags", flags, HgMemberFlags_Last, _checker, __FILE__, __LINE__);
	UINT32 mask; _parser.parseUINT32(mask);
	AtfValidator::validateIntMax(_descr, "mask", mask, (2*HgMemberFlags_Last-1), _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szUserIds = ThinAtf::LAtfVector< UserId, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("userIds"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "userIds", szUserIds, 10240, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY(Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY& hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY::operator=(Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY::equals(const Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc);
}

const char *hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    RecurringTournament
//=================================================================

hglobby::lobby_client::RecurringTournament::RecurringTournament()
{
	clear();
}

void hglobby::lobby_client::RecurringTournament::clear()
{
	recurringPatternType = 0;
	nbOccurences = 0;
	endDate.setNull();
	numberOfDays = 0;
	everyWeekday = false;
	numberOfWeeks = 0;
	recurringDays = 0;
	dayOfMonth = 0;
	numberMonths = 0;
	whichRecurringDay = 0;
	recurringDay = 0;
	nbConsecutiveCancellation = 0;
}

bool hglobby::lobby_client::RecurringTournament::equals(const RecurringTournament& _o) const
{
	return recurringPatternType == _o.recurringPatternType &&
		nbOccurences == _o.nbOccurences &&
		endDate.equals(_o.endDate) &&
		numberOfDays == _o.numberOfDays &&
		everyWeekday == _o.everyWeekday &&
		numberOfWeeks == _o.numberOfWeeks &&
		recurringDays == _o.recurringDays &&
		dayOfMonth == _o.dayOfMonth &&
		numberMonths == _o.numberMonths &&
		whichRecurringDay == _o.whichRecurringDay &&
		recurringDay == _o.recurringDay &&
		nbConsecutiveCancellation == _o.nbConsecutiveCancellation;
}

const char *hglobby::lobby_client::RecurringTournament::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("recurringPatternType=");
	_buf.appendUint(recurringPatternType);
	_buf.append(',');
	_buf.append("nbOccurences=");
	_buf.appendUint(nbOccurences);
	_buf.append(',');
	_buf.append("endDate=");
	ThinAtf::AtfTempl<SrvDate>::ToTraceString(_buf, endDate);
	if (recurringPatternType == eHgRecurringDaily)
	{
		_buf.append(',');
		_buf.append("numberOfDays=");
		_buf.appendUint(numberOfDays);
		_buf.append(',');
		_buf.append("everyWeekday=");
		_buf.appendUint(everyWeekday);
	}
	else if (recurringPatternType == eHgRecurringWeekly)
	{
		_buf.append(',');
		_buf.append("numberOfWeeks=");
		_buf.appendUint(numberOfWeeks);
		_buf.append(',');
		_buf.append("recurringDays=");
		_buf.appendUint(recurringDays);
	}
	else if (recurringPatternType == eHgRecurringMonthly)
	{
		_buf.append(',');
		_buf.append("dayOfMonth=");
		_buf.appendUint(dayOfMonth);
		_buf.append(',');
		_buf.append("numberMonths=");
		_buf.appendUint(numberMonths);
		_buf.append(',');
		_buf.append("whichRecurringDay=");
		_buf.appendUint(whichRecurringDay);
		_buf.append(',');
		_buf.append("recurringDay=");
		_buf.appendUint(recurringDay);
	}
	_buf.append(',');
	_buf.append("nbConsecutiveCancellation=");
	_buf.appendUint(nbConsecutiveCancellation);
	_buf.append('}');
	return _buf.c_str();
}

void hglobby::lobby_client::RecurringTournament::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(RecurringTournament())) // not empty
	{
		_body.composeUINT32(recurringPatternType);
		_body.composeUINT32(nbOccurences);
		_body.composeSrvDate(endDate);
		if (recurringPatternType == eHgRecurringDaily)
		{
			CommMsgBody _body0;
			_body0.composeUINT32(numberOfDays);
			_body0.composeBOOL(everyWeekday);
			_body.composeMsgBody(_body0);
		}
		else if (recurringPatternType == eHgRecurringWeekly)
		{
			CommMsgBody _body1;
			_body1.composeUINT32(numberOfWeeks);
			_body1.composeUINT32(recurringDays);
			_body.composeMsgBody(_body1);
		}
		else if (recurringPatternType == eHgRecurringMonthly)
		{
			CommMsgBody _body2;
			_body2.composeBYTE(dayOfMonth);
			_body2.composeBYTE(numberMonths);
			_body2.composeUINT32(whichRecurringDay);
			_body2.composeUINT32(recurringDay);
			_body.composeMsgBody(_body2);
		}
		_body.composeUINT32(nbConsecutiveCancellation);
	}

	_msg.composeMsgBody(_body);
}

void hglobby::lobby_client::RecurringTournament::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(recurringPatternType);
	_parser0.parseUINT32(nbOccurences);
	_parser0.parseSrvDate(endDate);
	if (recurringPatternType == eHgRecurringDaily)
	{
		parseAnonymousMsgBody0(_parser0);
	}
	else if (recurringPatternType == eHgRecurringWeekly)
	{
		parseAnonymousMsgBody1(_parser0);
	}
	else if (recurringPatternType == eHgRecurringMonthly)
	{
		parseAnonymousMsgBody2(_parser0);
	}
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT32(nbConsecutiveCancellation);
}

/*static*/ void hglobby::lobby_client::RecurringTournament::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 recurringPatternType = 0;
	_parser0.parseUINT32(recurringPatternType);
	AtfValidator::validateIntRange(_descr, "recurringPatternType", recurringPatternType, eHgNotRecurring, eHgRecurringMonthly, _checker, __FILE__, __LINE__);
	UINT32 nbOccurences; _parser0.parseUINT32(nbOccurences);
	AtfValidator::validateIntMax(_descr, "nbOccurences", nbOccurences, 10000, _checker, __FILE__, __LINE__);
	SrvDate endDate; _parser0.parseSrvDate(endDate);
	AtfValidator::validateSrvDateTime(_descr, "endDate", endDate, _checker, __FILE__, __LINE__);
	if (recurringPatternType == eHgRecurringDaily)
	{
		validateAnonymousMsgBody0(_parser0, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (recurringPatternType == eHgRecurringWeekly)
	{
		validateAnonymousMsgBody1(_parser0, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (recurringPatternType == eHgRecurringMonthly)
	{
		validateAnonymousMsgBody2(_parser0, _checker, _descr, _fieldsWithUnparsedContent);
	}
	if(_parser0.parseEnded()) return;
	UINT32 nbConsecutiveCancellation; _parser0.parseUINT32(nbConsecutiveCancellation);
	AtfValidator::validateIntMax(_descr, "nbConsecutiveCancellation", nbConsecutiveCancellation, 10000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void hglobby::lobby_client::RecurringTournament::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(numberOfDays);
	_parser0.parseBOOL(everyWeekday);
}

/*static*/ void hglobby::lobby_client::RecurringTournament::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 numberOfDays; _parser0.parseUINT32(numberOfDays);
	AtfValidator::validateIntMax(_descr, "numberOfDays", numberOfDays, 10000, _checker, __FILE__, __LINE__);
	bool everyWeekday; _parser0.parseBOOL(everyWeekday);
	AtfValidator::validateInt(_descr, "everyWeekday", everyWeekday, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void hglobby::lobby_client::RecurringTournament::parseAnonymousMsgBody1(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(numberOfWeeks);
	_parser0.parseUINT32(recurringDays);
}

/*static*/ void hglobby::lobby_client::RecurringTournament::validateAnonymousMsgBody1(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 numberOfWeeks; _parser0.parseUINT32(numberOfWeeks);
	AtfValidator::validateIntMax(_descr, "numberOfWeeks", numberOfWeeks, 1000, _checker, __FILE__, __LINE__);
	UINT32 recurringDays; _parser0.parseUINT32(recurringDays);
	AtfValidator::validateIntRange(_descr, "recurringDays", recurringDays, eHgRdNone, eHgRdEveryday, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void hglobby::lobby_client::RecurringTournament::parseAnonymousMsgBody2(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(dayOfMonth);
	_parser0.parseBYTE(numberMonths);
	_parser0.parseUINT32(whichRecurringDay);
	_parser0.parseUINT32(recurringDay);
}

/*static*/ void hglobby::lobby_client::RecurringTournament::validateAnonymousMsgBody2(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	BYTE dayOfMonth; _parser0.parseBYTE(dayOfMonth);
	AtfValidator::validateIntMax(_descr, "dayOfMonth", dayOfMonth, 31, _checker, __FILE__, __LINE__);
	BYTE numberMonths; _parser0.parseBYTE(numberMonths);
	AtfValidator::validateIntMax(_descr, "numberMonths", numberMonths, 100, _checker, __FILE__, __LINE__);
	UINT32 whichRecurringDay; _parser0.parseUINT32(whichRecurringDay);
	AtfValidator::validateIntRange(_descr, "whichRecurringDay", whichRecurringDay, eHgWrdNone, eHgWrdLast, _checker, __FILE__, __LINE__);
	UINT32 recurringDay; _parser0.parseUINT32(recurringDay);
	AtfValidator::validateIntRange(_descr, "recurringDay", recurringDay, eHgRdNone, eHgRdEveryday, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CreateTournParams2
//=================================================================

hglobby::lobby_client::CreateTournParams2::CreateTournParams2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::CreateTournParams2::CreateTournParams2(CreateTournParams2&& _o)
	: createTournParams(std::move(_o.createTournParams))
	, voiceEnabled(std::move(_o.voiceEnabled))
{
}

hglobby::lobby_client::CreateTournParams2& hglobby::lobby_client::CreateTournParams2::operator=(CreateTournParams2&& _o)
{
	if(this != &_o)
	{
		createTournParams = std::move(_o.createTournParams);
		voiceEnabled = std::move(_o.voiceEnabled);
	}
	return *this;
}

#endif

void hglobby::lobby_client::CreateTournParams2::clear()
{
	createTournParams.clear();
	voiceEnabled = false;
}

bool hglobby::lobby_client::CreateTournParams2::equals(const CreateTournParams2& _o) const
{
	return createTournParams.equals(_o.createTournParams) &&
		voiceEnabled == _o.voiceEnabled;
}

const char *hglobby::lobby_client::CreateTournParams2::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("createTournParams=");
	createTournParams.toTraceString(_buf);
	_buf.append(',');
	_buf.append("voiceEnabled=");
	_buf.appendUint(voiceEnabled);
	_buf.append('}');
	return _buf.c_str();
}

void hglobby::lobby_client::CreateTournParams2::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CreateTournParams2())) // not empty
	{
		createTournParams.composeMsg(_body);
		_body.composeBOOL(voiceEnabled);
	}

	_msg.composeMsgBody(_body);
}

void hglobby::lobby_client::CreateTournParams2::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	createTournParams.parseMsg(_parser0);
	_parser0.parseBOOL(voiceEnabled);
}

/*static*/ void hglobby::lobby_client::CreateTournParams2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	CreateTournParams::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("createTournParams"), _fieldsWithUnparsedContent);
	bool voiceEnabled; _parser0.parseBOOL(voiceEnabled);
	AtfValidator::validateInt(_descr, "voiceEnabled", voiceEnabled, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_HG_CREATE_CLUB_TOURN2
//=================================================================

hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN2::Protocol_HG_CREATE_CLUB_TOURN2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN2::Protocol_HG_CREATE_CLUB_TOURN2(Protocol_HG_CREATE_CLUB_TOURN2&& _o)
	: createTournParams2(std::move(_o.createTournParams2))
	, recurringTournament(std::move(_o.recurringTournament))
{
}

hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN2& hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN2::operator=(Protocol_HG_CREATE_CLUB_TOURN2&& _o)
{
	if(this != &_o)
	{
		createTournParams2 = std::move(_o.createTournParams2);
		recurringTournament = std::move(_o.recurringTournament);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN2::clear()
{
	createTournParams2.clear();
	recurringTournament.clear();
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN2::equals(const Protocol_HG_CREATE_CLUB_TOURN2& _o) const
{
	return createTournParams2.equals(_o.createTournParams2) &&
		recurringTournament.equals(_o.recurringTournament);
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CREATE_CLUB_TOURN2).append(")");
	_buf.append(',');
	_buf.append("createTournParams2=");
	createTournParams2.toTraceString(_buf);
	_buf.append(',');
	_buf.append("recurringTournament=");
	recurringTournament.toTraceString(_buf);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN2::composeMsg(CommMsgBody& _msg) const
{
	createTournParams2.composeMsg(_msg);
	recurringTournament.composeMsg(_msg);
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN2::parseMsg(CommMsgParser& _parser)
{
	createTournParams2.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	recurringTournament.parseMsg(_parser);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CREATE_CLUB_TOURN2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	CreateTournParams2::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("createTournParams2"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	RecurringTournament::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("recurringTournament"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CREATE_CLUB_TOURN_REPLY2
//=================================================================

hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY2::Protocol_HG_CREATE_CLUB_TOURN_REPLY2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY2::Protocol_HG_CREATE_CLUB_TOURN_REPLY2(Protocol_HG_CREATE_CLUB_TOURN_REPLY2&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, socialToken(std::move(_o.socialToken))
	, tournId(std::move(_o.tournId))
	, restartWarning(std::move(_o.restartWarning))
{
}

hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY2& hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY2::operator=(Protocol_HG_CREATE_CLUB_TOURN_REPLY2&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		socialToken = std::move(_o.socialToken);
		tournId = std::move(_o.tournId);
		restartWarning = std::move(_o.restartWarning);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY2::clear()
{
	errCode = 0;
	errDesc.clear();
	socialToken.clear();
	tournId = 0;
	restartWarning.clear();
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY2::equals(const Protocol_HG_CREATE_CLUB_TOURN_REPLY2& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		socialToken.equals(_o.socialToken) &&
		tournId == _o.tournId &&
		restartWarning.equals(_o.restartWarning);
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CREATE_CLUB_TOURN_REPLY2).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("socialToken=");
		_buf.append(socialToken);
		_buf.append(',');
		_buf.append("tournId=");
		_buf.appendUint(tournId);
		_buf.append(',');
		_buf.append("restartWarning=");
		_buf.append(restartWarning);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY2::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeString(socialToken);
		_msg.composeUINT32(tournId);
		_msg.composeString(restartWarning);
	}
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseStringP(socialToken);
		_parser.parseUINT32(tournId);
		_parser.parseStringP(restartWarning);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CREATE_CLUB_TOURN_REPLY2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "socialToken"); size_t szSocialToken = strlen(_dummy);
		AtfValidator::validateInt(_descr, "socialToken", szSocialToken, _checker, __FILE__, __LINE__);
		UINT32 tournId; _parser.parseUINT32(tournId);
		AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "restartWarning"); size_t szRestartWarning = strlen(_dummy);
		AtfValidator::validateInt(_descr, "restartWarning", szRestartWarning, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES::clear()
{
	isNewBehavior = false;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES::equals(const Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES& _o) const
{
	return isNewBehavior == _o.isNewBehavior;
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUBS_AND_SCHEDULED_GAMES).append(")");
	_buf.append(',');
	_buf.append("isNewBehavior=");
	_buf.appendUint(isNewBehavior);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBOOL(isNewBehavior);
}

void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(isNewBehavior);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUBS_AND_SCHEDULED_GAMES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(_parser.parseEnded()) return;
	bool isNewBehavior; _parser.parseBOOL(isNewBehavior);
	AtfValidator::validateInt(_descr, "isNewBehavior", isNewBehavior, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY(Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, clubInfoListForClient(std::move(_o.clubInfoListForClient))
	, tourns(std::move(_o.tourns))
	, ringGames(std::move(_o.ringGames))
	, msgBoard(std::move(_o.msgBoard))
{
}

hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY& hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY::operator=(Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		clubInfoListForClient = std::move(_o.clubInfoListForClient);
		tourns = std::move(_o.tourns);
		ringGames = std::move(_o.ringGames);
		msgBoard = std::move(_o.msgBoard);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	clubInfoListForClient.clear();
	tourns.clear();
	ringGames.clear();
	msgBoard.clear();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY::equals(const Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		clubInfoListForClient.equals(_o.clubInfoListForClient) &&
		tourns.equals(_o.tourns) &&
		ringGames.equals(_o.ringGames) &&
		msgBoard.equals(_o.msgBoard);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("clubInfoListForClient=");
		clubInfoListForClient.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tourns=");
		tourns.toTraceString(_buf);
		_buf.append(',');
		_buf.append("ringGames=");
		ringGames.toTraceString(_buf);
		_buf.append(',');
		_buf.append("msgBoard=");
		_buf.append(msgBoard);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		clubInfoListForClient.composeMsg(_msg);
		tourns.composeMsg(_msg);
		ringGames.composeMsg(_msg);
		_msg.composeString(msgBoard);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		clubInfoListForClient.parseMsg(_parser);
		tourns.parseMsg(_parser);
		ringGames.parseMsg(_parser);
		_parser.parseStringP(msgBoard);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szClubInfoListForClient = ThinAtf::LAtfVector< HgClubInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clubInfoListForClient"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "clubInfoListForClient", szClubInfoListForClient, _checker, __FILE__, __LINE__);
		int szTourns = ThinAtf::LAtfVector< ScheduledTourn, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
		int szRingGames = ThinAtf::LAtfVector< ScheduledRingGame, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("ringGames"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "ringGames", szRingGames, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "msgBoard"); size_t szMsgBoard = strlen(_dummy);
		AtfValidator::validateInt(_descr, "msgBoard", szMsgBoard, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_SET_ARCHIVE_PENDING
//=================================================================

hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING::Protocol_HG_SET_ARCHIVE_PENDING()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING::Protocol_HG_SET_ARCHIVE_PENDING(Protocol_HG_SET_ARCHIVE_PENDING&& _o)
	: archiveDate(std::move(_o.archiveDate))
	, clubIds(std::move(_o.clubIds))
{
}

hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING& hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING::operator=(Protocol_HG_SET_ARCHIVE_PENDING&& _o)
{
	if(this != &_o)
	{
		archiveDate = std::move(_o.archiveDate);
		clubIds = std::move(_o.clubIds);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING::clear()
{
	archiveDate.setNull();
	clubIds.clear();
}

bool hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING::equals(const Protocol_HG_SET_ARCHIVE_PENDING& _o) const
{
	return archiveDate.equals(_o.archiveDate) &&
		clubIds.equals(_o.clubIds);
}

const char *hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_SET_ARCHIVE_PENDING).append(")");
	_buf.append(',');
	_buf.append("archiveDate=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, archiveDate);
	_buf.append(',');
	_buf.append("clubIds=");
	clubIds.toTraceString(_buf);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeSrvTime(archiveDate);
	clubIds.composeMsg(_msg);
}

void hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING::parseMsg(CommMsgParser& _parser)
{
	_parser.parseSrvTime(archiveDate);
	clubIds.parseMsg(_parser);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_SET_ARCHIVE_PENDING";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	SrvTime archiveDate; _parser.parseSrvTime(archiveDate);
	AtfValidator::validateSrvDateTime(_descr, "archiveDate", archiveDate, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szClubIds = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clubIds"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "clubIds", szClubIds, 10240, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_SET_ARCHIVE_PENDING_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING_REPLY::Protocol_HG_SET_ARCHIVE_PENDING_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING_REPLY::Protocol_HG_SET_ARCHIVE_PENDING_REPLY(Protocol_HG_SET_ARCHIVE_PENDING_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING_REPLY& hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING_REPLY::operator=(Protocol_HG_SET_ARCHIVE_PENDING_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING_REPLY::equals(const Protocol_HG_SET_ARCHIVE_PENDING_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc);
}

const char *hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_SET_ARCHIVE_PENDING_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_SET_ARCHIVE_PENDING_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_ARCHIVE_CLUBS
//=================================================================

hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS::Protocol_HG_ARCHIVE_CLUBS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS::Protocol_HG_ARCHIVE_CLUBS(Protocol_HG_ARCHIVE_CLUBS&& _o)
	: clubIds(std::move(_o.clubIds))
{
}

hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS& hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS::operator=(Protocol_HG_ARCHIVE_CLUBS&& _o)
{
	if(this != &_o)
	{
		clubIds = std::move(_o.clubIds);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS::clear()
{
	clubIds.clear();
}

bool hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS::equals(const Protocol_HG_ARCHIVE_CLUBS& _o) const
{
	return clubIds.equals(_o.clubIds);
}

const char *hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_ARCHIVE_CLUBS).append(")");
	_buf.append(',');
	_buf.append("clubIds=");
	clubIds.toTraceString(_buf);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS::composeMsg(CommMsgBody& _msg) const
{
	clubIds.composeMsg(_msg);
}

void hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS::parseMsg(CommMsgParser& _parser)
{
	clubIds.parseMsg(_parser);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_ARCHIVE_CLUBS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szClubIds = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clubIds"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "clubIds", szClubIds, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_ARCHIVE_CLUBS_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS_REPLY::Protocol_HG_ARCHIVE_CLUBS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS_REPLY::Protocol_HG_ARCHIVE_CLUBS_REPLY(Protocol_HG_ARCHIVE_CLUBS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS_REPLY& hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS_REPLY::operator=(Protocol_HG_ARCHIVE_CLUBS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS_REPLY::equals(const Protocol_HG_ARCHIVE_CLUBS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc);
}

const char *hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_ARCHIVE_CLUBS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_ARCHIVE_CLUBS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUB_TABLE_STRUCTURES2
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES2::Protocol_HG_GET_CLUB_TABLE_STRUCTURES2()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES2::clear()
{
	clubId = 0;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES2::equals(const Protocol_HG_GET_CLUB_TABLE_STRUCTURES2& _o) const
{
	return clubId == _o.clubId;
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_TABLE_STRUCTURES2).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES2::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(clubId);
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_TABLE_STRUCTURES2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY2
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY2::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY2::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY2(Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY2&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, tableParams(std::move(_o.tableParams))
	, isVoceEnabled(std::move(_o.isVoceEnabled))
{
}

hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY2& hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY2::operator=(Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY2&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		tableParams = std::move(_o.tableParams);
		isVoceEnabled = std::move(_o.isVoceEnabled);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY2::clear()
{
	errCode = 0;
	errDesc.clear();
	tableParams.clear();
	isVoceEnabled = false;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY2::equals(const Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY2& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		tableParams.equals(_o.tableParams) &&
		isVoceEnabled == _o.isVoceEnabled;
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_TABLE_STRUCTURES_REPLY2).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("tableParams=");
		tableParams.toTraceString(_buf);
		_buf.append(',');
		_buf.append("isVoceEnabled=");
		_buf.appendUint(isVoceEnabled);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY2::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		tableParams.composeMsg(_msg);
		_msg.composeBOOL(isVoceEnabled);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		tableParams.parseMsg(_parser);
		_parser.parseBOOL(isVoceEnabled);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_TABLE_STRUCTURES_REPLY2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szTableParams = ThinAtf::LAtfVector< TableParams, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableParams"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tableParams", szTableParams, _checker, __FILE__, __LINE__);
		bool isVoceEnabled; _parser.parseBOOL(isVoceEnabled);
		AtfValidator::validateInt(_descr, "isVoceEnabled", isVoceEnabled, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES2
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES2::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES2()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES2::clear()
{
	isNewBehavior = false;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES2::equals(const Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES2& _o) const
{
	return isNewBehavior == _o.isNewBehavior;
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUBS_AND_SCHEDULED_GAMES2).append(")");
	_buf.append(',');
	_buf.append("isNewBehavior=");
	_buf.appendUint(isNewBehavior);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES2::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBOOL(isNewBehavior);
}

void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES2::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(isNewBehavior);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUBS_AND_SCHEDULED_GAMES2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(_parser.parseEnded()) return;
	bool isNewBehavior; _parser.parseBOOL(isNewBehavior);
	AtfValidator::validateInt(_descr, "isNewBehavior", isNewBehavior, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2(Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, clubInfoListForClient(std::move(_o.clubInfoListForClient))
	, tourns(std::move(_o.tourns))
	, ringGames(std::move(_o.ringGames))
	, msgBoard(std::move(_o.msgBoard))
{
}

hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2& hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2::operator=(Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		clubInfoListForClient = std::move(_o.clubInfoListForClient);
		tourns = std::move(_o.tourns);
		ringGames = std::move(_o.ringGames);
		msgBoard = std::move(_o.msgBoard);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2::clear()
{
	errCode = 0;
	errDesc.clear();
	clubInfoListForClient.clear();
	tourns.clear();
	ringGames.clear();
	msgBoard.clear();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2::equals(const Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		clubInfoListForClient.equals(_o.clubInfoListForClient) &&
		tourns.equals(_o.tourns) &&
		ringGames.equals(_o.ringGames) &&
		msgBoard.equals(_o.msgBoard);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("clubInfoListForClient=");
		clubInfoListForClient.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tourns=");
		tourns.toTraceString(_buf);
		_buf.append(',');
		_buf.append("ringGames=");
		ringGames.toTraceString(_buf);
		_buf.append(',');
		_buf.append("msgBoard=");
		_buf.append(msgBoard);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		clubInfoListForClient.composeMsg(_msg);
		tourns.composeMsg(_msg);
		ringGames.composeMsg(_msg);
		_msg.composeString(msgBoard);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		clubInfoListForClient.parseMsg(_parser);
		tourns.parseMsg(_parser);
		ringGames.parseMsg(_parser);
		_parser.parseStringP(msgBoard);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szClubInfoListForClient = ThinAtf::LAtfVector< HgClubInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clubInfoListForClient"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "clubInfoListForClient", szClubInfoListForClient, _checker, __FILE__, __LINE__);
		int szTourns = ThinAtf::LAtfVector< ScheduledTourn, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
		int szRingGames = ThinAtf::LAtfVector< ScheduledRingGame, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("ringGames"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "ringGames", szRingGames, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "msgBoard"); size_t szMsgBoard = strlen(_dummy);
		AtfValidator::validateInt(_descr, "msgBoard", szMsgBoard, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_SCHEDULED_GAMES2
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES2::Protocol_HG_GET_SCHEDULED_GAMES2()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES2::clear()
{
}

bool hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES2::equals(const Protocol_HG_GET_SCHEDULED_GAMES2& _o) const
{
	return true;
}

const char *hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_SCHEDULED_GAMES2).append(")");
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES2::composeMsg(CommMsgBody& _msg) const
{
}

void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES2::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_SCHEDULED_GAMES2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_SCHEDULED_GAMES_REPLY2
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY2::Protocol_HG_GET_SCHEDULED_GAMES_REPLY2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY2::Protocol_HG_GET_SCHEDULED_GAMES_REPLY2(Protocol_HG_GET_SCHEDULED_GAMES_REPLY2&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, tourns(std::move(_o.tourns))
	, ringGames(std::move(_o.ringGames))
	, msgBoard(std::move(_o.msgBoard))
{
}

hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY2& hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY2::operator=(Protocol_HG_GET_SCHEDULED_GAMES_REPLY2&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		tourns = std::move(_o.tourns);
		ringGames = std::move(_o.ringGames);
		msgBoard = std::move(_o.msgBoard);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY2::clear()
{
	errCode = 0;
	errDesc.clear();
	tourns.clear();
	ringGames.clear();
	msgBoard.clear();
}

bool hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY2::equals(const Protocol_HG_GET_SCHEDULED_GAMES_REPLY2& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		tourns.equals(_o.tourns) &&
		ringGames.equals(_o.ringGames) &&
		msgBoard.equals(_o.msgBoard);
}

const char *hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_SCHEDULED_GAMES_REPLY2).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("tourns=");
		tourns.toTraceString(_buf);
		_buf.append(',');
		_buf.append("ringGames=");
		ringGames.toTraceString(_buf);
		_buf.append(',');
		_buf.append("msgBoard=");
		_buf.append(msgBoard);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY2::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		tourns.composeMsg(_msg);
		ringGames.composeMsg(_msg);
		_msg.composeString(msgBoard);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		tourns.parseMsg(_parser);
		ringGames.parseMsg(_parser);
		_parser.parseStringP(msgBoard);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_SCHEDULED_GAMES_REPLY2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szTourns = ThinAtf::LAtfVector< ScheduledTourn, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
		int szRingGames = ThinAtf::LAtfVector< ScheduledRingGame, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("ringGames"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "ringGames", szRingGames, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "msgBoard"); size_t szMsgBoard = strlen(_dummy);
		AtfValidator::validateInt(_descr, "msgBoard", szMsgBoard, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUB_TOURN_STRUCTURES2
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES2::Protocol_HG_GET_CLUB_TOURN_STRUCTURES2()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES2::clear()
{
	clubId = 0;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES2::equals(const Protocol_HG_GET_CLUB_TOURN_STRUCTURES2& _o) const
{
	return clubId == _o.clubId;
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_TOURN_STRUCTURES2).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES2::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(clubId);
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_TOURN_STRUCTURES2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY2
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY2::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY2::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY2(Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY2&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, tournKnockoutPrize(std::move(_o.tournKnockoutPrize))
	, tournMaxPlayers(std::move(_o.tournMaxPlayers))
	, tournFastDealing(std::move(_o.tournFastDealing))
	, tournSyncBreaks(std::move(_o.tournSyncBreaks))
	, tournPayouts(std::move(_o.tournPayouts))
	, tournStartingChips(std::move(_o.tournStartingChips))
	, tournLevelLengths(std::move(_o.tournLevelLengths))
	, tournFormats(std::move(_o.tournFormats))
	, gameStructures(std::move(_o.gameStructures))
	, tournBuyInsPM(std::move(_o.tournBuyInsPM))
	, currencyBuyIns(std::move(_o.currencyBuyIns))
	, isVoiceEnabled(std::move(_o.isVoiceEnabled))
	, numMaxDaysForTournCreation(std::move(_o.numMaxDaysForTournCreation))
{
}

hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY2& hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY2::operator=(Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY2&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		tournKnockoutPrize = std::move(_o.tournKnockoutPrize);
		tournMaxPlayers = std::move(_o.tournMaxPlayers);
		tournFastDealing = std::move(_o.tournFastDealing);
		tournSyncBreaks = std::move(_o.tournSyncBreaks);
		tournPayouts = std::move(_o.tournPayouts);
		tournStartingChips = std::move(_o.tournStartingChips);
		tournLevelLengths = std::move(_o.tournLevelLengths);
		tournFormats = std::move(_o.tournFormats);
		gameStructures = std::move(_o.gameStructures);
		tournBuyInsPM = std::move(_o.tournBuyInsPM);
		currencyBuyIns = std::move(_o.currencyBuyIns);
		isVoiceEnabled = std::move(_o.isVoiceEnabled);
		numMaxDaysForTournCreation = std::move(_o.numMaxDaysForTournCreation);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY2::clear()
{
	errCode = 0;
	errDesc.clear();
	tournKnockoutPrize = 0;
	tournMaxPlayers = 0;
	tournFastDealing.clear();
	tournSyncBreaks.clear();
	tournPayouts.clear();
	tournStartingChips.clear();
	tournLevelLengths.clear();
	tournFormats.clear();
	gameStructures.clear();
	tournBuyInsPM.clear();
	currencyBuyIns.clear();
	isVoiceEnabled = false;
	numMaxDaysForTournCreation = 0;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY2::equals(const Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY2& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		tournKnockoutPrize == _o.tournKnockoutPrize &&
		tournMaxPlayers == _o.tournMaxPlayers &&
		tournFastDealing.equals(_o.tournFastDealing) &&
		tournSyncBreaks.equals(_o.tournSyncBreaks) &&
		tournPayouts.equals(_o.tournPayouts) &&
		tournStartingChips.equals(_o.tournStartingChips) &&
		tournLevelLengths.equals(_o.tournLevelLengths) &&
		tournFormats.equals(_o.tournFormats) &&
		gameStructures.equals(_o.gameStructures) &&
		tournBuyInsPM.equals(_o.tournBuyInsPM) &&
		currencyBuyIns.equals(_o.currencyBuyIns) &&
		isVoiceEnabled == _o.isVoiceEnabled &&
		numMaxDaysForTournCreation == _o.numMaxDaysForTournCreation;
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_TOURN_STRUCTURES_REPLY2).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("tournKnockoutPrize=");
		_buf.appendUint(tournKnockoutPrize);
		_buf.append(',');
		_buf.append("tournMaxPlayers=");
		_buf.appendUint(tournMaxPlayers);
		_buf.append(',');
		_buf.append("tournFastDealing=");
		tournFastDealing.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tournSyncBreaks=");
		tournSyncBreaks.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tournPayouts=");
		tournPayouts.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tournStartingChips=");
		tournStartingChips.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tournLevelLengths=");
		tournLevelLengths.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tournFormats=");
		tournFormats.toTraceString(_buf);
		_buf.append(',');
		_buf.append("gameStructures=");
		gameStructures.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tournBuyInsPM=");
		tournBuyInsPM.toTraceString(_buf);
		_buf.append(',');
		_buf.append("currencyBuyIns=");
		currencyBuyIns.toTraceString(_buf);
		_buf.append(',');
		_buf.append("isVoiceEnabled=");
		_buf.appendUint(isVoiceEnabled);
		_buf.append(',');
		_buf.append("numMaxDaysForTournCreation=");
		_buf.appendUint(numMaxDaysForTournCreation);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY2::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeUINT32(tournKnockoutPrize);
		_msg.composeUINT32(tournMaxPlayers);
		tournFastDealing.composeMsg(_msg);
		tournSyncBreaks.composeMsg(_msg);
		tournPayouts.composeMsg(_msg);
		tournStartingChips.composeMsg(_msg);
		tournLevelLengths.composeMsg(_msg);
		tournFormats.composeMsg(_msg);
		gameStructures.composeMsg(_msg);
		tournBuyInsPM.composeMsg(_msg);
		currencyBuyIns.composeMsg(_msg);
		_msg.composeBOOL(isVoiceEnabled);
		_msg.composeUINT32(numMaxDaysForTournCreation);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseUINT32(tournKnockoutPrize);
		_parser.parseUINT32(tournMaxPlayers);
		tournFastDealing.parseMsg(_parser);
		tournSyncBreaks.parseMsg(_parser);
		tournPayouts.parseMsg(_parser);
		tournStartingChips.parseMsg(_parser);
		tournLevelLengths.parseMsg(_parser);
		tournFormats.parseMsg(_parser);
		gameStructures.parseMsg(_parser);
		tournBuyInsPM.parseMsg(_parser);
		currencyBuyIns.parseMsg(_parser);
		_parser.parseBOOL(isVoiceEnabled);
		_parser.parseUINT32(numMaxDaysForTournCreation);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_TOURN_STRUCTURES_REPLY2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 tournKnockoutPrize; _parser.parseUINT32(tournKnockoutPrize);
		AtfValidator::validateInt(_descr, "tournKnockoutPrize", tournKnockoutPrize, _checker, __FILE__, __LINE__);
		UINT32 tournMaxPlayers; _parser.parseUINT32(tournMaxPlayers);
		AtfValidator::validateInt(_descr, "tournMaxPlayers", tournMaxPlayers, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szTournFastDealing = ThinAtf::LAtfVector< bool, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournFastDealing"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tournFastDealing", szTournFastDealing, _checker, __FILE__, __LINE__);
		int szTournSyncBreaks = ThinAtf::LAtfVector< bool, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournSyncBreaks"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tournSyncBreaks", szTournSyncBreaks, _checker, __FILE__, __LINE__);
		int szTournPayouts = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournPayouts"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tournPayouts", szTournPayouts, _checker, __FILE__, __LINE__);
		int szTournStartingChips = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournStartingChips"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tournStartingChips", szTournStartingChips, _checker, __FILE__, __LINE__);
		int szTournLevelLengths = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournLevelLengths"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tournLevelLengths", szTournLevelLengths, _checker, __FILE__, __LINE__);
		int szTournFormats = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournFormats"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tournFormats", szTournFormats, _checker, __FILE__, __LINE__);
		int szGameStructures = ThinAtf::LAtfVector< GameStructure, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("gameStructures"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "gameStructures", szGameStructures, _checker, __FILE__, __LINE__);
		int szTournBuyInsPM = ThinAtf::LAtfVector< TournBuyIn2, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournBuyInsPM"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tournBuyInsPM", szTournBuyInsPM, _checker, __FILE__, __LINE__);
		int szCurrencyBuyIns = ThinAtf::LAtfVector< TournCurrencyBuyIns2, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("currencyBuyIns"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "currencyBuyIns", szCurrencyBuyIns, _checker, __FILE__, __LINE__);
		bool isVoiceEnabled; _parser.parseBOOL(isVoiceEnabled);
		AtfValidator::validateInt(_descr, "isVoiceEnabled", isVoiceEnabled, _checker, __FILE__, __LINE__);
		UINT32 numMaxDaysForTournCreation; _parser.parseUINT32(numMaxDaysForTournCreation);
		AtfValidator::validateInt(_descr, "numMaxDaysForTournCreation", numMaxDaysForTournCreation, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CREATE_CLUB_TOURN3
//=================================================================

hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN3::Protocol_HG_CREATE_CLUB_TOURN3()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN3::Protocol_HG_CREATE_CLUB_TOURN3(Protocol_HG_CREATE_CLUB_TOURN3&& _o)
	: createTournParams2(std::move(_o.createTournParams2))
	, recurringTournament(std::move(_o.recurringTournament))
{
}

hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN3& hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN3::operator=(Protocol_HG_CREATE_CLUB_TOURN3&& _o)
{
	if(this != &_o)
	{
		createTournParams2 = std::move(_o.createTournParams2);
		recurringTournament = std::move(_o.recurringTournament);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN3::clear()
{
	createTournParams2.clear();
	recurringTournament.clear();
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN3::equals(const Protocol_HG_CREATE_CLUB_TOURN3& _o) const
{
	return createTournParams2.equals(_o.createTournParams2) &&
		recurringTournament.equals(_o.recurringTournament);
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN3::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CREATE_CLUB_TOURN3).append(")");
	_buf.append(',');
	_buf.append("createTournParams2=");
	createTournParams2.toTraceString(_buf);
	_buf.append(',');
	_buf.append("recurringTournament=");
	recurringTournament.toTraceString(_buf);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN3::composeMsg(CommMsgBody& _msg) const
{
	createTournParams2.composeMsg(_msg);
	recurringTournament.composeMsg(_msg);
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN3::parseMsg(CommMsgParser& _parser)
{
	createTournParams2.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	recurringTournament.parseMsg(_parser);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN3::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CREATE_CLUB_TOURN3";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	CreateTournParams2::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("createTournParams2"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	RecurringTournament::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("recurringTournament"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CREATE_CLUB_TOURN_REPLY3
//=================================================================

hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY3::Protocol_HG_CREATE_CLUB_TOURN_REPLY3()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY3::Protocol_HG_CREATE_CLUB_TOURN_REPLY3(Protocol_HG_CREATE_CLUB_TOURN_REPLY3&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, socialToken(std::move(_o.socialToken))
	, tournId(std::move(_o.tournId))
	, restartWarning(std::move(_o.restartWarning))
{
}

hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY3& hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY3::operator=(Protocol_HG_CREATE_CLUB_TOURN_REPLY3&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		socialToken = std::move(_o.socialToken);
		tournId = std::move(_o.tournId);
		restartWarning = std::move(_o.restartWarning);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY3::clear()
{
	errCode = 0;
	errDesc.clear();
	socialToken.clear();
	tournId = 0;
	restartWarning.clear();
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY3::equals(const Protocol_HG_CREATE_CLUB_TOURN_REPLY3& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		socialToken.equals(_o.socialToken) &&
		tournId == _o.tournId &&
		restartWarning.equals(_o.restartWarning);
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY3::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CREATE_CLUB_TOURN_REPLY3).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("socialToken=");
		_buf.append(socialToken);
		_buf.append(',');
		_buf.append("tournId=");
		_buf.appendUint(tournId);
		_buf.append(',');
		_buf.append("restartWarning=");
		_buf.append(restartWarning);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY3::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeString(socialToken);
		_msg.composeUINT32(tournId);
		_msg.composeString(restartWarning);
	}
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY3::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseStringP(socialToken);
		_parser.parseUINT32(tournId);
		_parser.parseStringP(restartWarning);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY3::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CREATE_CLUB_TOURN_REPLY3";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "socialToken"); size_t szSocialToken = strlen(_dummy);
		AtfValidator::validateInt(_descr, "socialToken", szSocialToken, _checker, __FILE__, __LINE__);
		UINT32 tournId; _parser.parseUINT32(tournId);
		AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "restartWarning"); size_t szRestartWarning = strlen(_dummy);
		AtfValidator::validateInt(_descr, "restartWarning", szRestartWarning, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_RECENT_TOURN_SUMMARIES2
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES2::Protocol_HG_GET_RECENT_TOURN_SUMMARIES2()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES2::clear()
{
	clubId = 0;
}

bool hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES2::equals(const Protocol_HG_GET_RECENT_TOURN_SUMMARIES2& _o) const
{
	return clubId == _o.clubId;
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_RECENT_TOURN_SUMMARIES2).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES2::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(clubId);
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_RECENT_TOURN_SUMMARIES2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY2
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY2::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY2::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY2(Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY2&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, summaries(std::move(_o.summaries))
{
}

hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY2& hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY2::operator=(Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY2&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		summaries = std::move(_o.summaries);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY2::clear()
{
	errCode = 0;
	errDesc.clear();
	summaries.clear();
}

bool hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY2::equals(const Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY2& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		summaries.equals(_o.summaries);
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_RECENT_TOURN_SUMMARIES_REPLY2).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("summaries=");
		summaries.toTraceString(_buf);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY2::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		summaries.composeMsg(_msg);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		summaries.parseMsg(_parser);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_RECENT_TOURN_SUMMARIES_REPLY2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szSummaries = ThinAtf::LAtfVector< ClubRecentTournamentSummary, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("summaries"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "summaries", szSummaries, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_RECENT_TOURN_RESULTS2
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS2::Protocol_HG_GET_RECENT_TOURN_RESULTS2()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS2::clear()
{
	tournId = 0;
}

bool hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS2::equals(const Protocol_HG_GET_RECENT_TOURN_RESULTS2& _o) const
{
	return tournId == _o.tournId;
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_RECENT_TOURN_RESULTS2).append(")");
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS2::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(tournId);
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tournId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_RECENT_TOURN_RESULTS2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY2
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY2::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY2::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY2(Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY2&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, tournResults(std::move(_o.tournResults))
{
}

hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY2& hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY2::operator=(Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY2&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		tournResults = std::move(_o.tournResults);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY2::clear()
{
	errCode = 0;
	errDesc.clear();
	tournResults.clear();
}

bool hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY2::equals(const Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY2& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		tournResults.equals(_o.tournResults);
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_RECENT_TOURN_RESULTS_REPLY2).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("tournResults=");
		tournResults.toTraceString(_buf);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY2::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		tournResults.composeMsg(_msg);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		tournResults.parseMsg(_parser);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_RECENT_TOURN_RESULTS_REPLY2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szTournResults = ThinAtf::LAtfVector< ClubRecentTournPlayerResult, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournResults"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tournResults", szTournResults, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUB_INFO2
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO2::Protocol_HG_GET_CLUB_INFO2()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO2::clear()
{
	clubId = 0;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO2::equals(const Protocol_HG_GET_CLUB_INFO2& _o) const
{
	return clubId == _o.clubId;
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_INFO2).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO2::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(clubId);
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_INFO2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUB_INFO_REPLY2
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY2::Protocol_HG_GET_CLUB_INFO_REPLY2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY2::Protocol_HG_GET_CLUB_INFO_REPLY2(Protocol_HG_GET_CLUB_INFO_REPLY2&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, clubName(std::move(_o.clubName))
	, tablePubName(std::move(_o.tablePubName))
	, tournPubName(std::move(_o.tournPubName))
	, memberRole(std::move(_o.memberRole))
	, memberFlags(std::move(_o.memberFlags))
	, wallPubName(std::move(_o.wallPubName))
	, announcePubName(std::move(_o.announcePubName))
	, membershipPubName(std::move(_o.membershipPubName))
{
}

hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY2& hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY2::operator=(Protocol_HG_GET_CLUB_INFO_REPLY2&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		clubName = std::move(_o.clubName);
		tablePubName = std::move(_o.tablePubName);
		tournPubName = std::move(_o.tournPubName);
		memberRole = std::move(_o.memberRole);
		memberFlags = std::move(_o.memberFlags);
		wallPubName = std::move(_o.wallPubName);
		announcePubName = std::move(_o.announcePubName);
		membershipPubName = std::move(_o.membershipPubName);
	}
	return *this;
}

#endif

void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY2::clear()
{
	errCode = 0;
	errDesc.clear();
	clubName.clear();
	tablePubName.clear();
	tournPubName.clear();
	memberRole = 0;
	memberFlags = 0;
	wallPubName.clear();
	announcePubName.clear();
	membershipPubName.clear();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY2::equals(const Protocol_HG_GET_CLUB_INFO_REPLY2& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		clubName.equals(_o.clubName) &&
		tablePubName.equals(_o.tablePubName) &&
		tournPubName.equals(_o.tournPubName) &&
		memberRole == _o.memberRole &&
		memberFlags == _o.memberFlags &&
		wallPubName.equals(_o.wallPubName) &&
		announcePubName.equals(_o.announcePubName) &&
		membershipPubName.equals(_o.membershipPubName);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_INFO_REPLY2).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("clubName=");
		_buf.append(clubName);
		_buf.append(',');
		_buf.append("tablePubName=");
		_buf.append(tablePubName);
		_buf.append(',');
		_buf.append("tournPubName=");
		_buf.append(tournPubName);
		_buf.append(',');
		_buf.append("memberRole=");
		_buf.appendUint(memberRole);
		_buf.append(',');
		_buf.append("memberFlags=");
		_buf.appendUint(memberFlags);
		_buf.append(',');
		_buf.append("wallPubName=");
		_buf.append(wallPubName);
		_buf.append(',');
		_buf.append("announcePubName=");
		_buf.append(announcePubName);
		_buf.append(',');
		_buf.append("membershipPubName=");
		_buf.append(membershipPubName);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY2::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeString(clubName);
		_msg.composeString(tablePubName);
		_msg.composeString(tournPubName);
		_msg.composeUINT32(memberRole);
		_msg.composeUINT32(memberFlags);
		_msg.composeString(wallPubName);
		_msg.composeString(announcePubName);
		_msg.composeString(membershipPubName);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseStringP(clubName);
		_parser.parseStringP(tablePubName);
		_parser.parseStringP(tournPubName);
		_parser.parseUINT32(memberRole);
		_parser.parseUINT32(memberFlags);
		_parser.parseStringP(wallPubName);
		_parser.parseStringP(announcePubName);
		_parser.parseStringP(membershipPubName);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_INFO_REPLY2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "clubName"); size_t szClubName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "clubName", szClubName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "tablePubName"); size_t szTablePubName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tablePubName", szTablePubName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "tournPubName"); size_t szTournPubName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tournPubName", szTournPubName, _checker, __FILE__, __LINE__);
		UINT32 memberRole; _parser.parseUINT32(memberRole);
		AtfValidator::validateInt(_descr, "memberRole", memberRole, _checker, __FILE__, __LINE__);
		UINT32 memberFlags; _parser.parseUINT32(memberFlags);
		AtfValidator::validateInt(_descr, "memberFlags", memberFlags, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "wallPubName"); size_t szWallPubName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "wallPubName", szWallPubName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "announcePubName"); size_t szAnnouncePubName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "announcePubName", szAnnouncePubName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "membershipPubName"); size_t szMembershipPubName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "membershipPubName", szMembershipPubName, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ bool hglobby::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "lobby_client"))
	{
		switch(_msgId)
		{
			case HG_ADD_USER_CLUB: lobby_client::Protocol_HG_ADD_USER_CLUB::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_ADD_USER_CLUB_REPLY: lobby_client::Protocol_HG_ADD_USER_CLUB_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_ARCHIVE_CLUBS: lobby_client::Protocol_HG_ARCHIVE_CLUBS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_ARCHIVE_CLUBS_REPLY: lobby_client::Protocol_HG_ARCHIVE_CLUBS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CANCEL_CLUB_TABLE: lobby_client::Protocol_HG_CANCEL_CLUB_TABLE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CANCEL_CLUB_TABLE_REPLY: lobby_client::Protocol_HG_CANCEL_CLUB_TABLE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CANCEL_CLUB_TOURNAMENT: lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CANCEL_CLUB_TOURNAMENT_REPLY: lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CHANGE_CLUB_IMAGE: lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CHANGE_CLUB_IMAGE_REPLY: lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CHANGE_CLUB_NAME: lobby_client::Protocol_HG_CHANGE_CLUB_NAME::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CHANGE_CLUB_NAME_REPLY: lobby_client::Protocol_HG_CHANGE_CLUB_NAME_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CHANGE_CLUB_OPTIONS: lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CHANGE_CLUB_OPTIONS_REPLY: lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CHANGE_CLUB_PASSWORD: lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CHANGE_CLUB_PASSWORD_REPLY: lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CHANGE_PLAYERS_STATUS: lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CHANGE_PLAYERS_STATUS_REPLY: lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CHANGE_SEASON_NAME: lobby_client::Protocol_HG_CHANGE_SEASON_NAME::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CHANGE_SEASON_NAME_REPLY: lobby_client::Protocol_HG_CHANGE_SEASON_NAME_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CLOSE_CLUB_BY_FOUNDER: lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CLOSE_CLUB_BY_FOUNDER_REPLY: lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CLUB_LOGIN: lobby_client::Protocol_HG_CLUB_LOGIN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CLUB_LOGIN_REPLY: lobby_client::Protocol_HG_CLUB_LOGIN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CLUB_LOGOUT: lobby_client::Protocol_HG_CLUB_LOGOUT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CLUB_LOGOUT_REPLY: lobby_client::Protocol_HG_CLUB_LOGOUT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CREATE_CLUB: lobby_client::Protocol_HG_CREATE_CLUB::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CREATE_CLUB_REPLY: lobby_client::Protocol_HG_CREATE_CLUB_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CREATE_CLUB_TABLE: lobby_client::Protocol_HG_CREATE_CLUB_TABLE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CREATE_CLUB_TABLE_REPLY: lobby_client::Protocol_HG_CREATE_CLUB_TABLE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CREATE_CLUB_TOURN: lobby_client::Protocol_HG_CREATE_CLUB_TOURN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CREATE_CLUB_TOURN2: lobby_client::Protocol_HG_CREATE_CLUB_TOURN2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CREATE_CLUB_TOURN3: lobby_client::Protocol_HG_CREATE_CLUB_TOURN3::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CREATE_CLUB_TOURN_REPLY: lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CREATE_CLUB_TOURN_REPLY2: lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CREATE_CLUB_TOURN_REPLY3: lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY3::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_FOUNDER_GET_CLUB_PASSWORD: lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_FOUNDER_GET_CLUB_PASSWORD_REPLY: lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUBS_AND_SCHEDULED_GAMES: lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUBS_AND_SCHEDULED_GAMES2: lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY: lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2: lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_INFO: lobby_client::Protocol_HG_GET_CLUB_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_INFO2: lobby_client::Protocol_HG_GET_CLUB_INFO2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_INFO_REPLY: lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_INFO_REPLY2: lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_OPTIONS: lobby_client::Protocol_HG_GET_CLUB_OPTIONS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_OPTIONS_REPLY: lobby_client::Protocol_HG_GET_CLUB_OPTIONS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_SEASONS: lobby_client::Protocol_HG_GET_CLUB_SEASONS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_SEASONS_REPLY: lobby_client::Protocol_HG_GET_CLUB_SEASONS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_SEASON_RANKS: lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_SEASON_RANKS_REPLY: lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_SEASON_STATS: lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_SEASON_STATS_REPLY: lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_TABLE_INFO: lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_TABLE_INFO_REPLY: lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_TABLE_STRUCTURES: lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_TABLE_STRUCTURES2: lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_TABLE_STRUCTURES_REPLY: lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_TABLE_STRUCTURES_REPLY2: lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_TOURN_INFO: lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_TOURN_INFO_REPLY: lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_TOURN_STRUCTURES: lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_TOURN_STRUCTURES2: lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_TOURN_STRUCTURES_REPLY: lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_TOURN_STRUCTURES_REPLY2: lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_PLAYERS_BASED_ON_STATUS: lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_PLAYERS_BASED_ON_STATUS_REPLY: lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_RECENT_TOURN_RESULTS: lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_RECENT_TOURN_RESULTS2: lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_RECENT_TOURN_RESULTS_REPLY: lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_RECENT_TOURN_RESULTS_REPLY2: lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_RECENT_TOURN_SUMMARIES: lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_RECENT_TOURN_SUMMARIES2: lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_RECENT_TOURN_SUMMARIES_REPLY: lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_RECENT_TOURN_SUMMARIES_REPLY2: lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_RECRUIT_SOCIAL_TOKEN: lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY: lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_SCHEDULED_GAMES: lobby_client::Protocol_HG_GET_SCHEDULED_GAMES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_SCHEDULED_GAMES2: lobby_client::Protocol_HG_GET_SCHEDULED_GAMES2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_SCHEDULED_GAMES_REPLY: lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_SCHEDULED_GAMES_REPLY2: lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_USER_CLUBS: lobby_client::Protocol_HG_GET_USER_CLUBS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_USER_CLUBS_REPLY: lobby_client::Protocol_HG_GET_USER_CLUBS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_MODIFY_MEMBERSHIP_FLAGS: lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_MODIFY_MEMBERSHIP_FLAGS_REPLY: lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_PROCESS_SEASON_CLOSED: lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_PROCESS_SEASON_CLOSED_REPLY: lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_SAVE_CLUB_MESSAGE: lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_SAVE_CLUB_MESSAGE_REPLY: lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_SET_ARCHIVE_PENDING: lobby_client::Protocol_HG_SET_ARCHIVE_PENDING::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_SET_ARCHIVE_PENDING_REPLY: lobby_client::Protocol_HG_SET_ARCHIVE_PENDING_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_SET_CLUB_COLOR: lobby_client::Protocol_HG_SET_CLUB_COLOR::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_SET_CLUB_COLOR_REPLY: lobby_client::Protocol_HG_SET_CLUB_COLOR_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_SET_FAVORITE_CLUB: lobby_client::Protocol_HG_SET_FAVORITE_CLUB::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_SET_FAVORITE_CLUB_REPLY: lobby_client::Protocol_HG_SET_FAVORITE_CLUB_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_TABLE_SOCIAL_TOKEN: lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_TABLE_SOCIAL_TOKEN_REPLY: lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_TOURN_SOCIAL_TOKEN: lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_TOURN_SOCIAL_TOKEN_REPLY: lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_TRANSLATE_SOCIAL_EVENT: lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_TRANSLATE_SOCIAL_EVENT_REPLY: lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_UPDATE_MEMBERSHIP_FLAGS: lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_UPDATE_MEMBERSHIP_FLAGS2: lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY: lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_UPDATE_MEMBERSHIP_FLAGS_REPLY: lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

