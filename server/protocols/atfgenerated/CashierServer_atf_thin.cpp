/**
 * CashierServer_atf_thin.cpp
 *
 * This file was auto-generated from CashierServer_atf.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor -thin CashierServer_atf.txt
 */
 
#include "CashierServer_atf_thin.h"

//=================================================================
//                    SetUserRollStatus
//=================================================================

CashierServer::common_structs::SetUserRollStatus::SetUserRollStatus()
{
	clear();
}

void CashierServer::common_structs::SetUserRollStatus::clear()
{
	userRollId = 0;
	curStatus = 0;
	action = 0;
}

bool CashierServer::common_structs::SetUserRollStatus::equals(const SetUserRollStatus& _o) const
{
	return userRollId == _o.userRollId &&
		curStatus == _o.curStatus &&
		action == _o.action;
}

const char *CashierServer::common_structs::SetUserRollStatus::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userRollId=");
	_buf.appendUint(userRollId);
	_buf.append(',');
	_buf.append("curStatus=");
	_buf.appendInt(curStatus);
	_buf.append(',');
	_buf.append("action=");
	_buf.appendInt(action);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::common_structs::SetUserRollStatus::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(userRollId);
	_msg.composeINT32(curStatus);
	_msg.composeINT32(action);
}

void CashierServer::common_structs::SetUserRollStatus::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(userRollId);
	_parser.parseINT32(curStatus);
	_parser.parseINT32(action);
}

/*static*/ void CashierServer::common_structs::SetUserRollStatus::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 userRollId; _parser.parseUINT32(userRollId);
	AtfValidator::validateInt(_descr, "userRollId", userRollId, _checker, __FILE__, __LINE__);
	INT32 curStatus; _parser.parseINT32(curStatus);
	AtfValidator::validateIntRange(_descr, "curStatus", curStatus, eUserRollStatus_Undefined, eUserRollStatus_Last, _checker, __FILE__, __LINE__);
	INT32 action; _parser.parseINT32(action);
	{ const INT32 action_enum[] = {eUserRollAction_AcceptIssued, eUserRollAction_Void, eUserRollAction_Surrender, eUserRollAction_Pause, eUserRollAction_Resume }; AtfValidator::validateEnum(_descr, "action", action, action_enum, _checker, __FILE__, __LINE__); }
}

//=================================================================
//                    SetUserRollStatusReply
//=================================================================

CashierServer::common_structs::SetUserRollStatusReply::SetUserRollStatusReply()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::common_structs::SetUserRollStatusReply::SetUserRollStatusReply(SetUserRollStatusReply&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::common_structs::SetUserRollStatusReply& CashierServer::common_structs::SetUserRollStatusReply::operator=(SetUserRollStatusReply&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::common_structs::SetUserRollStatusReply::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::common_structs::SetUserRollStatusReply::equals(const SetUserRollStatusReply& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::common_structs::SetUserRollStatusReply::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::common_structs::SetUserRollStatusReply::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::common_structs::SetUserRollStatusReply::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::common_structs::SetUserRollStatusReply::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
}

//=================================================================
//                    SetGameTicketStatus
//=================================================================

CashierServer::common_structs::SetGameTicketStatus::SetGameTicketStatus()
{
	clear();
}

void CashierServer::common_structs::SetGameTicketStatus::clear()
{
	gameTicketId = 0;
	curStatus = 0;
	action = 0;
}

bool CashierServer::common_structs::SetGameTicketStatus::equals(const SetGameTicketStatus& _o) const
{
	return gameTicketId == _o.gameTicketId &&
		curStatus == _o.curStatus &&
		action == _o.action;
}

const char *CashierServer::common_structs::SetGameTicketStatus::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("gameTicketId=");
	_buf.appendUint64(gameTicketId);
	_buf.append(',');
	_buf.append("curStatus=");
	_buf.appendInt(curStatus);
	_buf.append(',');
	_buf.append("action=");
	_buf.appendInt(action);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::common_structs::SetGameTicketStatus::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT64(gameTicketId);
	_msg.composeINT32(curStatus);
	_msg.composeINT32(action);
}

void CashierServer::common_structs::SetGameTicketStatus::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(gameTicketId);
	_parser.parseINT32(curStatus);
	_parser.parseINT32(action);
}

/*static*/ void CashierServer::common_structs::SetGameTicketStatus::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT64 gameTicketId; _parser.parseUINT64(gameTicketId);
	AtfValidator::validateUint(_descr, "gameTicketId", gameTicketId, _checker, __FILE__, __LINE__);
	INT32 curStatus; _parser.parseINT32(curStatus);
	AtfValidator::validateIntRange(_descr, "curStatus", curStatus, eGameTicketStatus_Issued, eGameTicketStatus_Last, _checker, __FILE__, __LINE__);
	INT32 action; _parser.parseINT32(action);
	{ const INT32 action_enum[] = { eGameTicketAction_Accept, eGameTicketAction_Reject, eGameTicketAction_Void }; AtfValidator::validateEnum(_descr, "action", action, action_enum, _checker, __FILE__, __LINE__); }
}

//=================================================================
//                    SetGameTicketStatusReply
//=================================================================

CashierServer::common_structs::SetGameTicketStatusReply::SetGameTicketStatusReply()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::common_structs::SetGameTicketStatusReply::SetGameTicketStatusReply(SetGameTicketStatusReply&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::common_structs::SetGameTicketStatusReply& CashierServer::common_structs::SetGameTicketStatusReply::operator=(SetGameTicketStatusReply&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::common_structs::SetGameTicketStatusReply::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::common_structs::SetGameTicketStatusReply::equals(const SetGameTicketStatusReply& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::common_structs::SetGameTicketStatusReply::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::common_structs::SetGameTicketStatusReply::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::common_structs::SetGameTicketStatusReply::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::common_structs::SetGameTicketStatusReply::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
}

//=================================================================
//                    CashierRollBody
//=================================================================

CashierServer::common_structs::CashierRollBody::CashierRollBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::common_structs::CashierRollBody::CashierRollBody(CashierRollBody&& _o)
	: rollId(std::move(_o.rollId))
	, rollAmount(std::move(_o.rollAmount))
	, bonusCurrency(std::move(_o.bonusCurrency))
	, rollAmountInAcctCur(std::move(_o.rollAmountInAcctCur))
	, acctCurrency(std::move(_o.acctCurrency))
	, cashPriceInAcctCur(std::move(_o.cashPriceInAcctCur))
	, acctCurrency2(std::move(_o.acctCurrency2))
	, rollProducts(std::move(_o.rollProducts))
	, clearPointsInCentsRounded(std::move(_o.clearPointsInCentsRounded))
	, clearBets(std::move(_o.clearBets))
	, redemptionLimit(std::move(_o.redemptionLimit))
	, clearStakes(std::move(_o.clearStakes))
{
}

CashierServer::common_structs::CashierRollBody& CashierServer::common_structs::CashierRollBody::operator=(CashierRollBody&& _o)
{
	if(this != &_o)
	{
		rollId = std::move(_o.rollId);
		rollAmount = std::move(_o.rollAmount);
		bonusCurrency = std::move(_o.bonusCurrency);
		rollAmountInAcctCur = std::move(_o.rollAmountInAcctCur);
		acctCurrency = std::move(_o.acctCurrency);
		cashPriceInAcctCur = std::move(_o.cashPriceInAcctCur);
		acctCurrency2 = std::move(_o.acctCurrency2);
		rollProducts = std::move(_o.rollProducts);
		clearPointsInCentsRounded = std::move(_o.clearPointsInCentsRounded);
		clearBets = std::move(_o.clearBets);
		redemptionLimit = std::move(_o.redemptionLimit);
		clearStakes = std::move(_o.clearStakes);
	}
	return *this;
}

#endif

void CashierServer::common_structs::CashierRollBody::clear()
{
	rollId = 0;
	rollAmount = 0;
	bonusCurrency.clear();
	rollAmountInAcctCur = 0;
	acctCurrency.clear();
	cashPriceInAcctCur = 0;
	acctCurrency2.clear();
	rollProducts = 0;
	clearPointsInCentsRounded = 0;
	clearBets = 0;
	redemptionLimit = 0;
	clearStakes = 0;
}

bool CashierServer::common_structs::CashierRollBody::equals(const CashierRollBody& _o) const
{
	return rollId == _o.rollId &&
		rollAmount == _o.rollAmount &&
		bonusCurrency.equals(_o.bonusCurrency) &&
		rollAmountInAcctCur == _o.rollAmountInAcctCur &&
		acctCurrency.equals(_o.acctCurrency) &&
		cashPriceInAcctCur == _o.cashPriceInAcctCur &&
		acctCurrency2.equals(_o.acctCurrency2) &&
		rollProducts == _o.rollProducts &&
		clearPointsInCentsRounded == _o.clearPointsInCentsRounded &&
		clearBets == _o.clearBets &&
		redemptionLimit == _o.redemptionLimit &&
		clearStakes == _o.clearStakes;
}

const char *CashierServer::common_structs::CashierRollBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("rollId=");
	_buf.appendUint(rollId);
	_buf.append(',');
	_buf.append("rollAmount=");
	_buf.appendInt(rollAmount);
	_buf.append(',');
	_buf.append("bonusCurrency=");
	_buf.append(bonusCurrency);
	_buf.append(',');
	_buf.append("rollAmountInAcctCur=");
	_buf.appendInt(rollAmountInAcctCur);
	_buf.append(',');
	_buf.append("acctCurrency=");
	_buf.append(acctCurrency);
	_buf.append(',');
	_buf.append("cashPriceInAcctCur=");
	_buf.appendInt(cashPriceInAcctCur);
	_buf.append(',');
	_buf.append("acctCurrency2=");
	_buf.append(acctCurrency2);
	_buf.append(',');
	_buf.append("rollProducts=");
	_buf.appendUint(rollProducts);
	_buf.append(',');
	_buf.append("clearPointsInCentsRounded=");
	_buf.appendInt(clearPointsInCentsRounded);
	_buf.append(',');
	_buf.append("clearBets=");
	_buf.appendInt(clearBets);
	_buf.append(',');
	_buf.append("redemptionLimit=");
	_buf.appendInt(redemptionLimit);
	_buf.append(',');
	_buf.append("clearStakes=");
	_buf.appendInt(clearStakes);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::common_structs::CashierRollBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CashierRollBody())) // not empty
	{
		_body.composeUINT32(rollId);
		_body.composeINT32(rollAmount);
		_body.composeString(bonusCurrency);
		_body.composeINT32(rollAmountInAcctCur);
		_body.composeString(acctCurrency);
		_body.composeINT32(cashPriceInAcctCur);
		_body.composeString(acctCurrency2);
		_body.composeUINT32(rollProducts);
		_body.composeINT32(clearPointsInCentsRounded);
		_body.composeINT32(clearBets);
		_body.composeINT32(redemptionLimit);
		_body.composeINT32(clearStakes);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::common_structs::CashierRollBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT32(rollId);
	_parser0.parseINT32(rollAmount);
	_parser0.parseStringP(bonusCurrency);
	_parser0.parseINT32(rollAmountInAcctCur);
	_parser0.parseStringP(acctCurrency);
	_parser0.parseINT32(cashPriceInAcctCur);
	_parser0.parseStringP(acctCurrency2);
	_parser0.parseUINT32(rollProducts);
	_parser0.parseINT32(clearPointsInCentsRounded);
	_parser0.parseINT32(clearBets);
	_parser0.parseINT32(redemptionLimit);
	_parser0.parseINT32(clearStakes);
}

/*static*/ void CashierServer::common_structs::CashierRollBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	if(_parser0.parseEnded()) return;
	UINT32 rollId; _parser0.parseUINT32(rollId);
	AtfValidator::validateInt(_descr, "rollId", rollId, _checker, __FILE__, __LINE__);
	INT32 rollAmount; _parser0.parseINT32(rollAmount);
	AtfValidator::validateInt(_descr, "rollAmount", rollAmount, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "bonusCurrency"); size_t szBonusCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "bonusCurrency", szBonusCurrency, _checker, __FILE__, __LINE__);
	INT32 rollAmountInAcctCur; _parser0.parseINT32(rollAmountInAcctCur);
	AtfValidator::validateInt(_descr, "rollAmountInAcctCur", rollAmountInAcctCur, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "acctCurrency"); size_t szAcctCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "acctCurrency", szAcctCurrency, _checker, __FILE__, __LINE__);
	INT32 cashPriceInAcctCur; _parser0.parseINT32(cashPriceInAcctCur);
	AtfValidator::validateInt(_descr, "cashPriceInAcctCur", cashPriceInAcctCur, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "acctCurrency2"); size_t szAcctCurrency2 = strlen(_dummy);
	AtfValidator::validateInt(_descr, "acctCurrency2", szAcctCurrency2, _checker, __FILE__, __LINE__);
	UINT32 rollProducts; _parser0.parseUINT32(rollProducts);
	AtfValidator::validateInt(_descr, "rollProducts", rollProducts, _checker, __FILE__, __LINE__);
	INT32 clearPointsInCentsRounded; _parser0.parseINT32(clearPointsInCentsRounded);
	AtfValidator::validateInt(_descr, "clearPointsInCentsRounded", clearPointsInCentsRounded, _checker, __FILE__, __LINE__);
	INT32 clearBets; _parser0.parseINT32(clearBets);
	AtfValidator::validateInt(_descr, "clearBets", clearBets, _checker, __FILE__, __LINE__);
	INT32 redemptionLimit; _parser0.parseINT32(redemptionLimit);
	AtfValidator::validateInt(_descr, "redemptionLimit", redemptionLimit, _checker, __FILE__, __LINE__);
	INT32 clearStakes; _parser0.parseINT32(clearStakes);
	AtfValidator::validateInt(_descr, "clearStakes", clearStakes, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PaysystemLimit
//=================================================================

CashierServer::common_structs::PaysystemLimit::PaysystemLimit()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::common_structs::PaysystemLimit::PaysystemLimit(PaysystemLimit&& _o)
	: paySystemByte(std::move(_o.paySystemByte))
	, paysystemName(std::move(_o.paysystemName))
	, minDeposit(std::move(_o.minDeposit))
	, maxCashinMonthly(std::move(_o.maxCashinMonthly))
	, maxCashinWeekly(std::move(_o.maxCashinWeekly))
	, maxCashinDaily(std::move(_o.maxCashinDaily))
	, feeStr(std::move(_o.feeStr))
	, empty(std::move(_o.empty))
	, maxDeposits(std::move(_o.maxDeposits))
	, depositsHours(std::move(_o.depositsHours))
	, userLimitText(std::move(_o.userLimitText))
	, maxCashin1Trans(std::move(_o.maxCashin1Trans))
	, fastDepositIsOk(std::move(_o.fastDepositIsOk))
	, psAvailFlagToClient(std::move(_o.psAvailFlagToClient))
{
}

CashierServer::common_structs::PaysystemLimit& CashierServer::common_structs::PaysystemLimit::operator=(PaysystemLimit&& _o)
{
	if(this != &_o)
	{
		paySystemByte = std::move(_o.paySystemByte);
		paysystemName = std::move(_o.paysystemName);
		minDeposit = std::move(_o.minDeposit);
		maxCashinMonthly = std::move(_o.maxCashinMonthly);
		maxCashinWeekly = std::move(_o.maxCashinWeekly);
		maxCashinDaily = std::move(_o.maxCashinDaily);
		feeStr = std::move(_o.feeStr);
		empty = std::move(_o.empty);
		maxDeposits = std::move(_o.maxDeposits);
		depositsHours = std::move(_o.depositsHours);
		userLimitText = std::move(_o.userLimitText);
		maxCashin1Trans = std::move(_o.maxCashin1Trans);
		fastDepositIsOk = std::move(_o.fastDepositIsOk);
		psAvailFlagToClient = std::move(_o.psAvailFlagToClient);
	}
	return *this;
}

#endif

void CashierServer::common_structs::PaysystemLimit::clear()
{
	paySystemByte = 0;
	paysystemName.clear();
	minDeposit = 0;
	maxCashinMonthly = 0;
	maxCashinWeekly = 0;
	maxCashinDaily = 0;
	feeStr.clear();
	empty.clear();
	maxDeposits = 0;
	depositsHours = 0;
	userLimitText.clear();
	maxCashin1Trans = 0;
	fastDepositIsOk = false;
	psAvailFlagToClient = 0;
}

bool CashierServer::common_structs::PaysystemLimit::equals(const PaysystemLimit& _o) const
{
	return paySystemByte == _o.paySystemByte &&
		paysystemName.equals(_o.paysystemName) &&
		minDeposit == _o.minDeposit &&
		maxCashinMonthly == _o.maxCashinMonthly &&
		maxCashinWeekly == _o.maxCashinWeekly &&
		maxCashinDaily == _o.maxCashinDaily &&
		feeStr.equals(_o.feeStr) &&
		empty.equals(_o.empty) &&
		maxDeposits == _o.maxDeposits &&
		depositsHours == _o.depositsHours &&
		userLimitText.equals(_o.userLimitText) &&
		maxCashin1Trans == _o.maxCashin1Trans &&
		fastDepositIsOk == _o.fastDepositIsOk &&
		psAvailFlagToClient == _o.psAvailFlagToClient;
}

const char *CashierServer::common_structs::PaysystemLimit::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("paySystemByte=");
	_buf.appendUint(paySystemByte);
	_buf.append(',');
	_buf.append("paysystemName=");
	_buf.append(paysystemName);
	_buf.append(',');
	_buf.append("minDeposit=");
	_buf.appendInt(minDeposit);
	_buf.append(',');
	_buf.append("maxCashinMonthly=");
	_buf.appendInt(maxCashinMonthly);
	_buf.append(',');
	_buf.append("maxCashinWeekly=");
	_buf.appendInt(maxCashinWeekly);
	_buf.append(',');
	_buf.append("maxCashinDaily=");
	_buf.appendInt(maxCashinDaily);
	_buf.append(',');
	_buf.append("feeStr=");
	_buf.append(feeStr);
	_buf.append(',');
	_buf.append("empty=");
	_buf.append(empty);
	_buf.append(',');
	_buf.append("maxDeposits=");
	_buf.appendInt(maxDeposits);
	_buf.append(',');
	_buf.append("depositsHours=");
	_buf.appendInt(depositsHours);
	_buf.append(',');
	_buf.append("userLimitText=");
	_buf.append(userLimitText);
	_buf.append(',');
	_buf.append("maxCashin1Trans=");
	_buf.appendInt(maxCashin1Trans);
	_buf.append(',');
	_buf.append("fastDepositIsOk=");
	_buf.appendUint(fastDepositIsOk);
	_buf.append(',');
	_buf.append("psAvailFlagToClient=");
	_buf.appendUint(psAvailFlagToClient);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::common_structs::PaysystemLimit::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(paySystemByte);
	_msg.composeString(paysystemName);
	_msg.composeINT32(minDeposit);
	_msg.composeINT32(maxCashinMonthly);
	_msg.composeINT32(maxCashinWeekly);
	_msg.composeINT32(maxCashinDaily);
	_msg.composeString(feeStr);
	_msg.composeString(empty);
	_msg.composeINT32(maxDeposits);
	_msg.composeINT32(depositsHours);
	_msg.composeString(userLimitText);
	_msg.composeINT32(maxCashin1Trans);
	_msg.composeBOOL(fastDepositIsOk);
	_msg.composeUINT32(psAvailFlagToClient);
}

void CashierServer::common_structs::PaysystemLimit::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(paySystemByte);
	_parser.parseStringP(paysystemName);
	_parser.parseINT32(minDeposit);
	_parser.parseINT32(maxCashinMonthly);
	_parser.parseINT32(maxCashinWeekly);
	_parser.parseINT32(maxCashinDaily);
	_parser.parseStringP(feeStr);
	_parser.parseStringP(empty);
	_parser.parseINT32(maxDeposits);
	_parser.parseINT32(depositsHours);
	_parser.parseStringP(userLimitText);
	_parser.parseINT32(maxCashin1Trans);
	_parser.parseBOOL(fastDepositIsOk);
	_parser.parseUINT32(psAvailFlagToClient);
}

/*static*/ void CashierServer::common_structs::PaysystemLimit::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	BYTE paySystemByte; _parser.parseBYTE(paySystemByte);
	AtfValidator::validateInt(_descr, "paySystemByte", paySystemByte, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "paysystemName"); size_t szPaysystemName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "paysystemName", szPaysystemName, _checker, __FILE__, __LINE__);
	INT32 minDeposit; _parser.parseINT32(minDeposit);
	AtfValidator::validateInt(_descr, "minDeposit", minDeposit, _checker, __FILE__, __LINE__);
	INT32 maxCashinMonthly; _parser.parseINT32(maxCashinMonthly);
	AtfValidator::validateInt(_descr, "maxCashinMonthly", maxCashinMonthly, _checker, __FILE__, __LINE__);
	INT32 maxCashinWeekly; _parser.parseINT32(maxCashinWeekly);
	AtfValidator::validateInt(_descr, "maxCashinWeekly", maxCashinWeekly, _checker, __FILE__, __LINE__);
	INT32 maxCashinDaily; _parser.parseINT32(maxCashinDaily);
	AtfValidator::validateInt(_descr, "maxCashinDaily", maxCashinDaily, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "feeStr"); size_t szFeeStr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "feeStr", szFeeStr, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "empty"); size_t szEmpty = strlen(_dummy);
	AtfValidator::validateInt(_descr, "empty", szEmpty, _checker, __FILE__, __LINE__);
	INT32 maxDeposits; _parser.parseINT32(maxDeposits);
	AtfValidator::validateInt(_descr, "maxDeposits", maxDeposits, _checker, __FILE__, __LINE__);
	INT32 depositsHours; _parser.parseINT32(depositsHours);
	AtfValidator::validateInt(_descr, "depositsHours", depositsHours, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userLimitText"); size_t szUserLimitText = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userLimitText", szUserLimitText, _checker, __FILE__, __LINE__);
	INT32 maxCashin1Trans; _parser.parseINT32(maxCashin1Trans);
	AtfValidator::validateInt(_descr, "maxCashin1Trans", maxCashin1Trans, _checker, __FILE__, __LINE__);
	bool fastDepositIsOk; _parser.parseBOOL(fastDepositIsOk);
	AtfValidator::validateInt(_descr, "fastDepositIsOk", fastDepositIsOk, _checker, __FILE__, __LINE__);
	UINT32 psAvailFlagToClient; _parser.parseUINT32(psAvailFlagToClient);
	AtfValidator::validateInt(_descr, "psAvailFlagToClient", psAvailFlagToClient, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TransactionHistoryCacheItem
//=================================================================

CashierServer::common_structs::TransactionHistoryCacheItem::TransactionHistoryCacheItem()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::common_structs::TransactionHistoryCacheItem::TransactionHistoryCacheItem(TransactionHistoryCacheItem&& _o)
	: whenAccountWasImpacted(std::move(_o.whenAccountWasImpacted))
	, typeDescr(std::move(_o.typeDescr))
	, transAcctAmount(std::move(_o.transAcctAmount))
	, obsoleteSystemFee(std::move(_o.obsoleteSystemFee))
	, cardMaskedOrReference(std::move(_o.cardMaskedOrReference))
	, transId(std::move(_o.transId))
	, transBalanceCurrency(std::move(_o.transBalanceCurrency))
	, descriptor(std::move(_o.descriptor))
	, transConverted(std::move(_o.transConverted))
	, transCurrency(std::move(_o.transCurrency))
	, transCardTypeByte(std::move(_o.transCardTypeByte))
	, referenceHint(std::move(_o.referenceHint))
	, historyFlags(std::move(_o.historyFlags))
{
}

CashierServer::common_structs::TransactionHistoryCacheItem& CashierServer::common_structs::TransactionHistoryCacheItem::operator=(TransactionHistoryCacheItem&& _o)
{
	if(this != &_o)
	{
		whenAccountWasImpacted = std::move(_o.whenAccountWasImpacted);
		typeDescr = std::move(_o.typeDescr);
		transAcctAmount = std::move(_o.transAcctAmount);
		obsoleteSystemFee = std::move(_o.obsoleteSystemFee);
		cardMaskedOrReference = std::move(_o.cardMaskedOrReference);
		transId = std::move(_o.transId);
		transBalanceCurrency = std::move(_o.transBalanceCurrency);
		descriptor = std::move(_o.descriptor);
		transConverted = std::move(_o.transConverted);
		transCurrency = std::move(_o.transCurrency);
		transCardTypeByte = std::move(_o.transCardTypeByte);
		referenceHint = std::move(_o.referenceHint);
		historyFlags = std::move(_o.historyFlags);
	}
	return *this;
}

#endif

void CashierServer::common_structs::TransactionHistoryCacheItem::clear()
{
	whenAccountWasImpacted.setNull();
	typeDescr.clear();
	transAcctAmount = 0;
	obsoleteSystemFee = 0;
	cardMaskedOrReference.clear();
	transId = 0;
	transBalanceCurrency.clear();
	descriptor.clear();
	transConverted = 0;
	transCurrency.clear();
	transCardTypeByte = 0;
	referenceHint.clear();
	historyFlags = 0;
}

bool CashierServer::common_structs::TransactionHistoryCacheItem::equals(const TransactionHistoryCacheItem& _o) const
{
	return whenAccountWasImpacted.equals(_o.whenAccountWasImpacted) &&
		typeDescr.equals(_o.typeDescr) &&
		transAcctAmount == _o.transAcctAmount &&
		obsoleteSystemFee == _o.obsoleteSystemFee &&
		cardMaskedOrReference.equals(_o.cardMaskedOrReference) &&
		transId == _o.transId &&
		transBalanceCurrency.equals(_o.transBalanceCurrency) &&
		descriptor.equals(_o.descriptor) &&
		transConverted == _o.transConverted &&
		transCurrency.equals(_o.transCurrency) &&
		transCardTypeByte == _o.transCardTypeByte &&
		referenceHint.equals(_o.referenceHint) &&
		historyFlags == _o.historyFlags;
}

const char *CashierServer::common_structs::TransactionHistoryCacheItem::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("whenAccountWasImpacted=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, whenAccountWasImpacted);
	_buf.append(',');
	_buf.append("typeDescr=");
	_buf.append(typeDescr);
	_buf.append(',');
	_buf.append("transAcctAmount=");
	_buf.appendInt(transAcctAmount);
	_buf.append(',');
	_buf.append("obsoleteSystemFee=");
	_buf.appendUint(obsoleteSystemFee);
	_buf.append(',');
	_buf.append("cardMaskedOrReference=");
	_buf.append(cardMaskedOrReference);
	_buf.append(',');
	_buf.append("transId=");
	_buf.appendUint(transId);
	_buf.append(',');
	_buf.append("transBalanceCurrency=");
	_buf.append(transBalanceCurrency);
	_buf.append(',');
	_buf.append("descriptor=");
	_buf.append(descriptor);
	_buf.append(',');
	_buf.append("transConverted=");
	_buf.appendInt(transConverted);
	_buf.append(',');
	_buf.append("transCurrency=");
	_buf.append(transCurrency);
	_buf.append(',');
	_buf.append("transCardTypeByte=");
	_buf.appendUint(transCardTypeByte);
	_buf.append(',');
	_buf.append("referenceHint=");
	_buf.append(referenceHint);
	_buf.append(',');
	_buf.append("historyFlags=");
	_buf.appendUint(historyFlags);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::common_structs::TransactionHistoryCacheItem::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(TransactionHistoryCacheItem())) // not empty
	{
		_body.composeSrvTime(whenAccountWasImpacted);
		_body.composeString(typeDescr);
		_body.composeINT32(transAcctAmount);
		_body.composeUINT32(obsoleteSystemFee);
		_body.composeString(cardMaskedOrReference);
		_body.composeUINT32(transId);
		_body.composeString(transBalanceCurrency);
		_body.composeString(descriptor);
		_body.composeINT32(transConverted);
		_body.composeString(transCurrency);
		_body.composeBYTE(transCardTypeByte);
		_body.composeString(referenceHint);
		_body.composeUINT32(historyFlags);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::common_structs::TransactionHistoryCacheItem::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseSrvTime(whenAccountWasImpacted);
	_parser0.parseStringP(typeDescr);
	_parser0.parseINT32(transAcctAmount);
	_parser0.parseUINT32(obsoleteSystemFee);
	_parser0.parseStringP(cardMaskedOrReference);
	_parser0.parseUINT32(transId);
	_parser0.parseStringP(transBalanceCurrency);
	_parser0.parseStringP(descriptor);
	_parser0.parseINT32(transConverted);
	_parser0.parseStringP(transCurrency);
	_parser0.parseBYTE(transCardTypeByte);
	_parser0.parseStringP(referenceHint);
	_parser0.parseUINT32(historyFlags);
}

/*static*/ void CashierServer::common_structs::TransactionHistoryCacheItem::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	SrvTime whenAccountWasImpacted; _parser0.parseSrvTime(whenAccountWasImpacted);
	AtfValidator::validateSrvDateTime(_descr, "whenAccountWasImpacted", whenAccountWasImpacted, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "typeDescr"); size_t szTypeDescr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "typeDescr", szTypeDescr, _checker, __FILE__, __LINE__);
	INT32 transAcctAmount; _parser0.parseINT32(transAcctAmount);
	AtfValidator::validateInt(_descr, "transAcctAmount", transAcctAmount, _checker, __FILE__, __LINE__);
	UINT32 obsoleteSystemFee; _parser0.parseUINT32(obsoleteSystemFee);
	AtfValidator::validateInt(_descr, "obsoleteSystemFee", obsoleteSystemFee, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "cardMaskedOrReference"); size_t szCardMaskedOrReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "cardMaskedOrReference", szCardMaskedOrReference, _checker, __FILE__, __LINE__);
	UINT32 transId; _parser0.parseUINT32(transId);
	AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "transBalanceCurrency"); size_t szTransBalanceCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "transBalanceCurrency", szTransBalanceCurrency, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "descriptor"); size_t szDescriptor = strlen(_dummy);
	AtfValidator::validateInt(_descr, "descriptor", szDescriptor, _checker, __FILE__, __LINE__);
	INT32 transConverted; _parser0.parseINT32(transConverted);
	AtfValidator::validateInt(_descr, "transConverted", transConverted, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "transCurrency"); size_t szTransCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "transCurrency", szTransCurrency, _checker, __FILE__, __LINE__);
	BYTE transCardTypeByte; _parser0.parseBYTE(transCardTypeByte);
	AtfValidator::validateInt(_descr, "transCardTypeByte", transCardTypeByte, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "referenceHint"); size_t szReferenceHint = strlen(_dummy);
	AtfValidator::validateInt(_descr, "referenceHint", szReferenceHint, _checker, __FILE__, __LINE__);
	UINT32 historyFlags; _parser0.parseUINT32(historyFlags);
	AtfValidator::validateInt(_descr, "historyFlags", historyFlags, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_CHIPS_INFO2
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2::Protocol_MSG_CASHIER_CHIPS_INFO2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2::Protocol_MSG_CASHIER_CHIPS_INFO2(Protocol_MSG_CASHIER_CHIPS_INFO2&& _o)
	: userId(std::move(_o.userId))
	, clientVersionInfo(std::move(_o.clientVersionInfo))
	, infoFlags(std::move(_o.infoFlags))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2& CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2::operator=(Protocol_MSG_CASHIER_CHIPS_INFO2&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		clientVersionInfo = std::move(_o.clientVersionInfo);
		infoFlags = std::move(_o.infoFlags);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2::clear()
{
	userId.clear();
	clientVersionInfo.clear();
	infoFlags = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2::equals(const Protocol_MSG_CASHIER_CHIPS_INFO2& _o) const
{
	return userId.equals(_o.userId) &&
		clientVersionInfo.equals(_o.clientVersionInfo) &&
		infoFlags == _o.infoFlags;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CHIPS_INFO2).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("clientVersionInfo=");
	_buf.append(clientVersionInfo);
	_buf.append(',');
	_buf.append("infoFlags=");
	_buf.appendUint(infoFlags);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeString(clientVersionInfo);
	_msg.composeUINT32(infoFlags);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(clientVersionInfo);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(infoFlags);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CHIPS_INFO2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "clientVersionInfo"); size_t szClientVersionInfo = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "clientVersionInfo", szClientVersionInfo, 1000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 infoFlags; _parser.parseUINT32(infoFlags);
	AtfValidator::validateIntMax(_descr, "infoFlags", infoFlags, ((((UINT32)eCashierChipsInfoFlag_Last)<<1)-1), _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    PhoneValidationInfo
//=================================================================

CashierServer::cli::PhoneValidationInfo::PhoneValidationInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::PhoneValidationInfo::PhoneValidationInfo(PhoneValidationInfo&& _o)
	: result(std::move(_o.result))
	, contryPhoneCode(std::move(_o.contryPhoneCode))
	, verifiedPhoneNumber(std::move(_o.verifiedPhoneNumber))
	, dialingInfo(std::move(_o.dialingInfo))
	, phoneNumber(std::move(_o.phoneNumber))
{
}

CashierServer::cli::PhoneValidationInfo& CashierServer::cli::PhoneValidationInfo::operator=(PhoneValidationInfo&& _o)
{
	if(this != &_o)
	{
		result = std::move(_o.result);
		contryPhoneCode = std::move(_o.contryPhoneCode);
		verifiedPhoneNumber = std::move(_o.verifiedPhoneNumber);
		dialingInfo = std::move(_o.dialingInfo);
		phoneNumber = std::move(_o.phoneNumber);
	}
	return *this;
}

#endif

void CashierServer::cli::PhoneValidationInfo::clear()
{
	result = 0;
	contryPhoneCode.clear();
	verifiedPhoneNumber.clear();
	dialingInfo.clear();
	phoneNumber.clear();
}

bool CashierServer::cli::PhoneValidationInfo::equals(const PhoneValidationInfo& _o) const
{
	return result == _o.result &&
		contryPhoneCode.equals(_o.contryPhoneCode) &&
		verifiedPhoneNumber.equals(_o.verifiedPhoneNumber) &&
		dialingInfo.equals(_o.dialingInfo) &&
		phoneNumber.equals(_o.phoneNumber);
}

const char *CashierServer::cli::PhoneValidationInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("result=");
	_buf.appendUint(result);
	_buf.append(',');
	_buf.append("contryPhoneCode=");
	_buf.append(contryPhoneCode);
	_buf.append(',');
	_buf.append("verifiedPhoneNumber=");
	_buf.append(verifiedPhoneNumber);
	_buf.append(',');
	_buf.append("dialingInfo=");
	_buf.append(dialingInfo);
	_buf.append(',');
	_buf.append("phoneNumber=");
	_buf.append(phoneNumber);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::PhoneValidationInfo::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(result);
	_msg.composeString(contryPhoneCode);
	_msg.composeString(verifiedPhoneNumber);
	_msg.composeString(dialingInfo);
	_msg.composeString(phoneNumber);
}

void CashierServer::cli::PhoneValidationInfo::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(result);
	_parser.parseStringP(contryPhoneCode);
	_parser.parseStringP(verifiedPhoneNumber);
	_parser.parseStringP(dialingInfo);
	_parser.parseStringP(phoneNumber);
}

/*static*/ void CashierServer::cli::PhoneValidationInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	BYTE result; _parser.parseBYTE(result);
	AtfValidator::validateInt(_descr, "result", result, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "contryPhoneCode"); size_t szContryPhoneCode = strlen(_dummy);
	AtfValidator::validateInt(_descr, "contryPhoneCode", szContryPhoneCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "verifiedPhoneNumber"); size_t szVerifiedPhoneNumber = strlen(_dummy);
	AtfValidator::validateInt(_descr, "verifiedPhoneNumber", szVerifiedPhoneNumber, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "dialingInfo"); size_t szDialingInfo = strlen(_dummy);
	AtfValidator::validateInt(_descr, "dialingInfo", szDialingInfo, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "phoneNumber"); size_t szPhoneNumber = strlen(_dummy);
	AtfValidator::validateInt(_descr, "phoneNumber", szPhoneNumber, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    UserBalanceInfo
//=================================================================

CashierServer::cli::UserBalanceInfo::UserBalanceInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::UserBalanceInfo::UserBalanceInfo(UserBalanceInfo&& _o)
	: balanceFlags(std::move(_o.balanceFlags))
	, currency(std::move(_o.currency))
	, availForSpending(std::move(_o.availForSpending))
	, unclearedForSpending(std::move(_o.unclearedForSpending))
	, availForCashout(std::move(_o.availForCashout))
	, unclearedForCashout(std::move(_o.unclearedForCashout))
	, owedChips(std::move(_o.owedChips))
	, tChips(std::move(_o.tChips))
	, wChips(std::move(_o.wChips))
	, chips(std::move(_o.chips))
	, markedForCashoutOnly(std::move(_o.markedForCashoutOnly))
	, userRollsWalletAmount(std::move(_o.userRollsWalletAmount))
	, fsbTotalBetsNumber(std::move(_o.fsbTotalBetsNumber))
	, userRollsAllocAmount(std::move(_o.userRollsAllocAmount))
{
}

CashierServer::cli::UserBalanceInfo& CashierServer::cli::UserBalanceInfo::operator=(UserBalanceInfo&& _o)
{
	if(this != &_o)
	{
		balanceFlags = std::move(_o.balanceFlags);
		currency = std::move(_o.currency);
		availForSpending = std::move(_o.availForSpending);
		unclearedForSpending = std::move(_o.unclearedForSpending);
		availForCashout = std::move(_o.availForCashout);
		unclearedForCashout = std::move(_o.unclearedForCashout);
		owedChips = std::move(_o.owedChips);
		tChips = std::move(_o.tChips);
		wChips = std::move(_o.wChips);
		chips = std::move(_o.chips);
		markedForCashoutOnly = std::move(_o.markedForCashoutOnly);
		userRollsWalletAmount = std::move(_o.userRollsWalletAmount);
		fsbTotalBetsNumber = std::move(_o.fsbTotalBetsNumber);
		userRollsAllocAmount = std::move(_o.userRollsAllocAmount);
	}
	return *this;
}

#endif

void CashierServer::cli::UserBalanceInfo::clear()
{
	balanceFlags = 0;
	currency.clear();
	availForSpending = 0;
	unclearedForSpending = 0;
	availForCashout = 0;
	unclearedForCashout = 0;
	owedChips = 0;
	tChips = 0;
	wChips = 0;
	chips = 0;
	markedForCashoutOnly = 0;
	userRollsWalletAmount = 0;
	fsbTotalBetsNumber = 0;
	userRollsAllocAmount = 0;
}

bool CashierServer::cli::UserBalanceInfo::equals(const UserBalanceInfo& _o) const
{
	return balanceFlags == _o.balanceFlags &&
		currency.equals(_o.currency) &&
		availForSpending == _o.availForSpending &&
		unclearedForSpending == _o.unclearedForSpending &&
		availForCashout == _o.availForCashout &&
		unclearedForCashout == _o.unclearedForCashout &&
		owedChips == _o.owedChips &&
		tChips == _o.tChips &&
		wChips == _o.wChips &&
		chips == _o.chips &&
		markedForCashoutOnly == _o.markedForCashoutOnly &&
		userRollsWalletAmount == _o.userRollsWalletAmount &&
		fsbTotalBetsNumber == _o.fsbTotalBetsNumber &&
		userRollsAllocAmount == _o.userRollsAllocAmount;
}

const char *CashierServer::cli::UserBalanceInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("balanceFlags=");
	_buf.appendUint(balanceFlags);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("availForSpending=");
	_buf.appendInt(availForSpending);
	_buf.append(',');
	_buf.append("unclearedForSpending=");
	_buf.appendInt(unclearedForSpending);
	_buf.append(',');
	_buf.append("availForCashout=");
	_buf.appendInt(availForCashout);
	_buf.append(',');
	_buf.append("unclearedForCashout=");
	_buf.appendInt(unclearedForCashout);
	_buf.append(',');
	_buf.append("owedChips=");
	_buf.appendInt(owedChips);
	_buf.append(',');
	_buf.append("tChips=");
	_buf.appendInt(tChips);
	_buf.append(',');
	_buf.append("wChips=");
	_buf.appendInt(wChips);
	_buf.append(',');
	_buf.append("chips=");
	_buf.appendInt(chips);
	_buf.append(',');
	_buf.append("markedForCashoutOnly=");
	_buf.appendInt(markedForCashoutOnly);
	_buf.append(',');
	_buf.append("userRollsWalletAmount=");
	_buf.appendInt(userRollsWalletAmount);
	_buf.append(',');
	_buf.append("fsbTotalBetsNumber=");
	_buf.appendInt(fsbTotalBetsNumber);
	_buf.append(',');
	_buf.append("userRollsAllocAmount=");
	_buf.appendInt(userRollsAllocAmount);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::UserBalanceInfo::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(UserBalanceInfo())) // not empty
	{
		_body.composeUINT32(balanceFlags);
		_body.composeString(currency);
		_body.composeINT32(availForSpending);
		_body.composeINT32(unclearedForSpending);
		_body.composeINT32(availForCashout);
		_body.composeINT32(unclearedForCashout);
		_body.composeINT32(owedChips);
		_body.composeINT32(tChips);
		_body.composeINT32(wChips);
		_body.composeINT32(chips);
		_body.composeINT32(markedForCashoutOnly);
		_body.composeINT32(userRollsWalletAmount);
		_body.composeINT32(fsbTotalBetsNumber);
		_body.composeINT32(userRollsAllocAmount);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::UserBalanceInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(balanceFlags);
	_parser0.parseStringP(currency);
	_parser0.parseINT32(availForSpending);
	_parser0.parseINT32(unclearedForSpending);
	_parser0.parseINT32(availForCashout);
	_parser0.parseINT32(unclearedForCashout);
	_parser0.parseINT32(owedChips);
	_parser0.parseINT32(tChips);
	_parser0.parseINT32(wChips);
	_parser0.parseINT32(chips);
	_parser0.parseINT32(markedForCashoutOnly);
	_parser0.parseINT32(userRollsWalletAmount);
	_parser0.parseINT32(fsbTotalBetsNumber);
	_parser0.parseINT32(userRollsAllocAmount);
}

/*static*/ void CashierServer::cli::UserBalanceInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 balanceFlags; _parser0.parseUINT32(balanceFlags);
	AtfValidator::validateInt(_descr, "balanceFlags", balanceFlags, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT32 availForSpending; _parser0.parseINT32(availForSpending);
	AtfValidator::validateInt(_descr, "availForSpending", availForSpending, _checker, __FILE__, __LINE__);
	INT32 unclearedForSpending; _parser0.parseINT32(unclearedForSpending);
	AtfValidator::validateInt(_descr, "unclearedForSpending", unclearedForSpending, _checker, __FILE__, __LINE__);
	INT32 availForCashout; _parser0.parseINT32(availForCashout);
	AtfValidator::validateInt(_descr, "availForCashout", availForCashout, _checker, __FILE__, __LINE__);
	INT32 unclearedForCashout; _parser0.parseINT32(unclearedForCashout);
	AtfValidator::validateInt(_descr, "unclearedForCashout", unclearedForCashout, _checker, __FILE__, __LINE__);
	INT32 owedChips; _parser0.parseINT32(owedChips);
	AtfValidator::validateInt(_descr, "owedChips", owedChips, _checker, __FILE__, __LINE__);
	INT32 tChips; _parser0.parseINT32(tChips);
	AtfValidator::validateInt(_descr, "tChips", tChips, _checker, __FILE__, __LINE__);
	INT32 wChips; _parser0.parseINT32(wChips);
	AtfValidator::validateInt(_descr, "wChips", wChips, _checker, __FILE__, __LINE__);
	INT32 chips; _parser0.parseINT32(chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	INT32 markedForCashoutOnly; _parser0.parseINT32(markedForCashoutOnly);
	AtfValidator::validateInt(_descr, "markedForCashoutOnly", markedForCashoutOnly, _checker, __FILE__, __LINE__);
	INT32 userRollsWalletAmount; _parser0.parseINT32(userRollsWalletAmount);
	AtfValidator::validateInt(_descr, "userRollsWalletAmount", userRollsWalletAmount, _checker, __FILE__, __LINE__);
	INT32 fsbTotalBetsNumber; _parser0.parseINT32(fsbTotalBetsNumber);
	AtfValidator::validateInt(_descr, "fsbTotalBetsNumber", fsbTotalBetsNumber, _checker, __FILE__, __LINE__);
	INT32 userRollsAllocAmount; _parser0.parseINT32(userRollsAllocAmount);
	AtfValidator::validateInt(_descr, "userRollsAllocAmount", userRollsAllocAmount, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    UserFundsInfo
//=================================================================

CashierServer::cli::UserFundsInfo::UserFundsInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::UserFundsInfo::UserFundsInfo(UserFundsInfo&& _o)
	: currency(std::move(_o.currency))
	, amount(std::move(_o.amount))
{
}

CashierServer::cli::UserFundsInfo& CashierServer::cli::UserFundsInfo::operator=(UserFundsInfo&& _o)
{
	if(this != &_o)
	{
		currency = std::move(_o.currency);
		amount = std::move(_o.amount);
	}
	return *this;
}

#endif

void CashierServer::cli::UserFundsInfo::clear()
{
	currency.clear();
	amount = 0;
}

bool CashierServer::cli::UserFundsInfo::equals(const UserFundsInfo& _o) const
{
	return currency.equals(_o.currency) &&
		amount == _o.amount;
}

const char *CashierServer::cli::UserFundsInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendInt(amount);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::UserFundsInfo::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(UserFundsInfo())) // not empty
	{
		_body.composeString(currency);
		_body.composeINT32(amount);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::UserFundsInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(currency);
	_parser0.parseINT32(amount);
}

/*static*/ void CashierServer::cli::UserFundsInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT32 amount; _parser0.parseINT32(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    UserNonUsdCurrency
//=================================================================

CashierServer::cli::UserNonUsdCurrency::UserNonUsdCurrency()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::UserNonUsdCurrency::UserNonUsdCurrency(UserNonUsdCurrency&& _o)
	: name(std::move(_o.name))
{
}

CashierServer::cli::UserNonUsdCurrency& CashierServer::cli::UserNonUsdCurrency::operator=(UserNonUsdCurrency&& _o)
{
	if(this != &_o)
	{
		name = std::move(_o.name);
	}
	return *this;
}

#endif

void CashierServer::cli::UserNonUsdCurrency::clear()
{
	name.clear();
}

bool CashierServer::cli::UserNonUsdCurrency::equals(const UserNonUsdCurrency& _o) const
{
	return name.equals(_o.name);
}

const char *CashierServer::cli::UserNonUsdCurrency::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("name=");
	_buf.append(name);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::UserNonUsdCurrency::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(UserNonUsdCurrency())) // not empty
	{
		_body.composeString(name);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::UserNonUsdCurrency::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(name);
}

/*static*/ void CashierServer::cli::UserNonUsdCurrency::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CashierExtraInfo
//=================================================================

CashierServer::cli::CashierExtraInfo::CashierExtraInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::CashierExtraInfo::CashierExtraInfo(CashierExtraInfo&& _o)
	: type(std::move(_o.type))
	, currency(std::move(_o.currency))
	, greekDailyGameProfit(std::move(_o.greekDailyGameProfit))
	, greekNotAvailForCashout(std::move(_o.greekNotAvailForCashout))
	, hasCashoutHistory(std::move(_o.hasCashoutHistory))
{
}

CashierServer::cli::CashierExtraInfo& CashierServer::cli::CashierExtraInfo::operator=(CashierExtraInfo&& _o)
{
	if(this != &_o)
	{
		type = std::move(_o.type);
		currency = std::move(_o.currency);
		greekDailyGameProfit = std::move(_o.greekDailyGameProfit);
		greekNotAvailForCashout = std::move(_o.greekNotAvailForCashout);
		hasCashoutHistory = std::move(_o.hasCashoutHistory);
	}
	return *this;
}

#endif

void CashierServer::cli::CashierExtraInfo::clear()
{
	type = 0;
	currency.clear();
	greekDailyGameProfit = 0;
	greekNotAvailForCashout = 0;
	hasCashoutHistory = false;
}

bool CashierServer::cli::CashierExtraInfo::equals(const CashierExtraInfo& _o) const
{
	return type == _o.type &&
		currency.equals(_o.currency) &&
		greekDailyGameProfit == _o.greekDailyGameProfit &&
		greekNotAvailForCashout == _o.greekNotAvailForCashout &&
		hasCashoutHistory == _o.hasCashoutHistory;
}

const char *CashierServer::cli::CashierExtraInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("type=");
	_buf.appendInt(type);
	if (type == eCashierExtraInfoType_Greek)
	{
		_buf.append(',');
		_buf.append("currency=");
		_buf.append(currency);
		_buf.append(',');
		_buf.append("greekDailyGameProfit=");
		_buf.appendInt64(greekDailyGameProfit);
		_buf.append(',');
		_buf.append("greekNotAvailForCashout=");
		_buf.appendInt64(greekNotAvailForCashout);
	}
	else if (type == eCashierExtraInfoType_UserHasCashoutHistory)
	{
		_buf.append(',');
		_buf.append("hasCashoutHistory=");
		_buf.appendUint(hasCashoutHistory);
	}
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashierExtraInfo::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(type);
	if (type == eCashierExtraInfoType_Greek)
	{
		CommMsgBody _msg0;
		_msg0.composeString(currency);
		_msg0.composeINT64(greekDailyGameProfit);
		_msg0.composeINT64(greekNotAvailForCashout);
		_msg.composeMsgBody(_msg0);
	}
	else if (type == eCashierExtraInfoType_UserHasCashoutHistory)
	{
		CommMsgBody _msg1;
		_msg1.composeBOOL(hasCashoutHistory);
		_msg.composeMsgBody(_msg1);
	}
}

void CashierServer::cli::CashierExtraInfo::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(type);
	if (type == eCashierExtraInfoType_Greek)
	{
		parseAnonymousMsgBody0(_parser);
	}
	else if (type == eCashierExtraInfoType_UserHasCashoutHistory)
	{
		parseAnonymousMsgBody1(_parser);
	}
}

/*static*/ void CashierServer::cli::CashierExtraInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT32 type = 0;
	_parser.parseINT32(type);
	AtfValidator::validateInt(_descr, "type", type, _checker, __FILE__, __LINE__);
	if (type == eCashierExtraInfoType_Greek)
	{
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (type == eCashierExtraInfoType_UserHasCashoutHistory)
	{
		validateAnonymousMsgBody1(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
}

void CashierServer::cli::CashierExtraInfo::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(currency);
	_parser0.parseINT64(greekDailyGameProfit);
	_parser0.parseINT64(greekNotAvailForCashout);
}

/*static*/ void CashierServer::cli::CashierExtraInfo::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT64 greekDailyGameProfit; _parser0.parseINT64(greekDailyGameProfit);
	AtfValidator::validateInt(_descr, "greekDailyGameProfit", greekDailyGameProfit, _checker, __FILE__, __LINE__);
	INT64 greekNotAvailForCashout; _parser0.parseINT64(greekNotAvailForCashout);
	AtfValidator::validateInt(_descr, "greekNotAvailForCashout", greekNotAvailForCashout, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::CashierExtraInfo::parseAnonymousMsgBody1(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(hasCashoutHistory);
}

/*static*/ void CashierServer::cli::CashierExtraInfo::validateAnonymousMsgBody1(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	bool hasCashoutHistory; _parser0.parseBOOL(hasCashoutHistory);
	AtfValidator::validateInt(_descr, "hasCashoutHistory", hasCashoutHistory, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY(Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, email(std::move(_o.email))
	, addr1(std::move(_o.addr1))
	, addr2(std::move(_o.addr2))
	, city(std::move(_o.city))
	, state(std::move(_o.state))
	, country(std::move(_o.country))
	, zipCode(std::move(_o.zipCode))
	, fullName(std::move(_o.fullName))
	, birthDate(std::move(_o.birthDate))
	, homePhoneValidation(std::move(_o.homePhoneValidation))
	, firstName(std::move(_o.firstName))
	, onlyLastName(std::move(_o.onlyLastName))
	, fiscalCode(std::move(_o.fiscalCode))
	, userProperties(std::move(_o.userProperties))
	, sex(std::move(_o.sex))
	, mobilePhoneValidation(std::move(_o.mobilePhoneValidation))
	, registered(std::move(_o.registered))
	, flags(std::move(_o.flags))
	, bitMask(std::move(_o.bitMask))
	, realMoneyOk(std::move(_o.realMoneyOk))
	, vipStatus(std::move(_o.vipStatus))
	, playChips(std::move(_o.playChips))
	, allocPlayChips(std::move(_o.allocPlayChips))
	, fpWithCents(std::move(_o.fpWithCents))
	, showBonusButton(std::move(_o.showBonusButton))
	, showBonusButton2(std::move(_o.showBonusButton2))
	, balances(std::move(_o.balances))
	, funds(std::move(_o.funds))
	, nonUsdCurrencies(std::move(_o.nonUsdCurrencies))
	, defaultCurrencyForCountry(std::move(_o.defaultCurrencyForCountry))
	, totalBalanceInPreferredCurrency(std::move(_o.totalBalanceInPreferredCurrency))
	, totalTBalanceInPreferredCurrency(std::move(_o.totalTBalanceInPreferredCurrency))
	, fastDepositPaysystemByte(std::move(_o.fastDepositPaysystemByte))
	, beProtectedFromGaming(std::move(_o.beProtectedFromGaming))
	, beUnusedLossLimit(std::move(_o.beUnusedLossLimit))
	, playChips2(std::move(_o.playChips2))
	, allocPlayChips2(std::move(_o.allocPlayChips2))
	, fulltiltUserId(std::move(_o.fulltiltUserId))
	, ftCashoutMinLimit(std::move(_o.ftCashoutMinLimit))
	, cashierExtraInfo(std::move(_o.cashierExtraInfo))
	, userRolls(std::move(_o.userRolls))
	, totalForCashoutInPrefCur(std::move(_o.totalForCashoutInPrefCur))
	, flags3(std::move(_o.flags3))
	, totalBalanceInUsd(std::move(_o.totalBalanceInUsd))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::operator=(Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		email = std::move(_o.email);
		addr1 = std::move(_o.addr1);
		addr2 = std::move(_o.addr2);
		city = std::move(_o.city);
		state = std::move(_o.state);
		country = std::move(_o.country);
		zipCode = std::move(_o.zipCode);
		fullName = std::move(_o.fullName);
		birthDate = std::move(_o.birthDate);
		homePhoneValidation = std::move(_o.homePhoneValidation);
		firstName = std::move(_o.firstName);
		onlyLastName = std::move(_o.onlyLastName);
		fiscalCode = std::move(_o.fiscalCode);
		userProperties = std::move(_o.userProperties);
		sex = std::move(_o.sex);
		mobilePhoneValidation = std::move(_o.mobilePhoneValidation);
		registered = std::move(_o.registered);
		flags = std::move(_o.flags);
		bitMask = std::move(_o.bitMask);
		realMoneyOk = std::move(_o.realMoneyOk);
		vipStatus = std::move(_o.vipStatus);
		playChips = std::move(_o.playChips);
		allocPlayChips = std::move(_o.allocPlayChips);
		fpWithCents = std::move(_o.fpWithCents);
		showBonusButton = std::move(_o.showBonusButton);
		showBonusButton2 = std::move(_o.showBonusButton2);
		balances = std::move(_o.balances);
		funds = std::move(_o.funds);
		nonUsdCurrencies = std::move(_o.nonUsdCurrencies);
		defaultCurrencyForCountry = std::move(_o.defaultCurrencyForCountry);
		totalBalanceInPreferredCurrency = std::move(_o.totalBalanceInPreferredCurrency);
		totalTBalanceInPreferredCurrency = std::move(_o.totalTBalanceInPreferredCurrency);
		fastDepositPaysystemByte = std::move(_o.fastDepositPaysystemByte);
		beProtectedFromGaming = std::move(_o.beProtectedFromGaming);
		beUnusedLossLimit = std::move(_o.beUnusedLossLimit);
		playChips2 = std::move(_o.playChips2);
		allocPlayChips2 = std::move(_o.allocPlayChips2);
		fulltiltUserId = std::move(_o.fulltiltUserId);
		ftCashoutMinLimit = std::move(_o.ftCashoutMinLimit);
		cashierExtraInfo = std::move(_o.cashierExtraInfo);
		userRolls = std::move(_o.userRolls);
		totalForCashoutInPrefCur = std::move(_o.totalForCashoutInPrefCur);
		flags3 = std::move(_o.flags3);
		totalBalanceInUsd = std::move(_o.totalBalanceInUsd);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	email.clear();
	addr1.clear();
	addr2.clear();
	city.clear();
	state.clear();
	country.clear();
	zipCode.clear();
	fullName.clear();
	birthDate.setNull();
	homePhoneValidation.clear();
	firstName.clear();
	onlyLastName.clear();
	fiscalCode.clear();
	userProperties.clear();
	sex.clear();
	mobilePhoneValidation.clear();
	registered.setNull();
	flags = 0;
	bitMask = 0;
	realMoneyOk = 0;
	vipStatus = 0;
	playChips = 0;
	allocPlayChips = 0;
	fpWithCents = 0;
	showBonusButton = 0;
	showBonusButton2 = 0;
	balances.clear();
	funds.clear();
	nonUsdCurrencies.clear();
	defaultCurrencyForCountry.clear();
	totalBalanceInPreferredCurrency = 0;
	totalTBalanceInPreferredCurrency = 0;
	fastDepositPaysystemByte = 0;
	beProtectedFromGaming = 0;
	beUnusedLossLimit = 0;
	playChips2 = 0;
	allocPlayChips2 = 0;
	fulltiltUserId.clear();
	ftCashoutMinLimit = 0;
	cashierExtraInfo.clear();
	userRolls.clear();
	totalForCashoutInPrefCur = 0;
	flags3 = 0;
	totalBalanceInUsd = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::equals(const Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		email.equals(_o.email) &&
		addr1.equals(_o.addr1) &&
		addr2.equals(_o.addr2) &&
		city.equals(_o.city) &&
		state.equals(_o.state) &&
		country.equals(_o.country) &&
		zipCode.equals(_o.zipCode) &&
		fullName.equals(_o.fullName) &&
		birthDate.equals(_o.birthDate) &&
		homePhoneValidation.equals(_o.homePhoneValidation) &&
		firstName.equals(_o.firstName) &&
		onlyLastName.equals(_o.onlyLastName) &&
		fiscalCode.equals(_o.fiscalCode) &&
		userProperties.equals(_o.userProperties) &&
		sex.equals(_o.sex) &&
		mobilePhoneValidation.equals(_o.mobilePhoneValidation) &&
		registered.equals(_o.registered) &&
		flags == _o.flags &&
		bitMask == _o.bitMask &&
		realMoneyOk == _o.realMoneyOk &&
		vipStatus == _o.vipStatus &&
		playChips == _o.playChips &&
		allocPlayChips == _o.allocPlayChips &&
		fpWithCents == _o.fpWithCents &&
		showBonusButton == _o.showBonusButton &&
		showBonusButton2 == _o.showBonusButton2 &&
		balances.equals(_o.balances) &&
		funds.equals(_o.funds) &&
		nonUsdCurrencies.equals(_o.nonUsdCurrencies) &&
		defaultCurrencyForCountry.equals(_o.defaultCurrencyForCountry) &&
		totalBalanceInPreferredCurrency == _o.totalBalanceInPreferredCurrency &&
		totalTBalanceInPreferredCurrency == _o.totalTBalanceInPreferredCurrency &&
		fastDepositPaysystemByte == _o.fastDepositPaysystemByte &&
		beProtectedFromGaming == _o.beProtectedFromGaming &&
		beUnusedLossLimit == _o.beUnusedLossLimit &&
		playChips2 == _o.playChips2 &&
		allocPlayChips2 == _o.allocPlayChips2 &&
		fulltiltUserId.equals(_o.fulltiltUserId) &&
		ftCashoutMinLimit == _o.ftCashoutMinLimit &&
		cashierExtraInfo.equals(_o.cashierExtraInfo) &&
		userRolls.equals(_o.userRolls) &&
		totalForCashoutInPrefCur == _o.totalForCashoutInPrefCur &&
		flags3 == _o.flags3 &&
		totalBalanceInUsd == _o.totalBalanceInUsd;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CHIPS_INFO2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("email=");
		_buf.append(email);
		_buf.append(',');
		_buf.append("addr1=");
		_buf.append(addr1);
		_buf.append(',');
		_buf.append("addr2=");
		_buf.append(addr2);
		_buf.append(',');
		_buf.append("city=");
		_buf.append(city);
		_buf.append(',');
		_buf.append("state=");
		_buf.append(state);
		_buf.append(',');
		_buf.append("country=");
		_buf.append(country);
		_buf.append(',');
		_buf.append("zipCode=");
		_buf.append(zipCode);
		_buf.append(',');
		_buf.append("fullName=");
		_buf.append(fullName);
		_buf.append(',');
		_buf.append("birthDate=");
		ThinAtf::AtfTempl<SrvDate>::ToTraceString(_buf, birthDate);
		_buf.append(',');
		_buf.append("homePhoneValidation=");
		homePhoneValidation.toTraceString(_buf);
		_buf.append(',');
		_buf.append("firstName=");
		_buf.append(firstName);
		_buf.append(',');
		_buf.append("onlyLastName=");
		_buf.append(onlyLastName);
		_buf.append(',');
		_buf.append("fiscalCode=");
		_buf.append(fiscalCode);
		_buf.append(',');
		_buf.append("userProperties=");
		userProperties.toTraceString(_buf);
		_buf.append(',');
		_buf.append("sex=");
		_buf.append(sex);
		_buf.append(',');
		_buf.append("mobilePhoneValidation=");
		mobilePhoneValidation.toTraceString(_buf);
		_buf.append(',');
		_buf.append("registered=");
		ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, registered);
		_buf.append(',');
		_buf.append("flags=");
		_buf.appendUint(flags);
		_buf.append(',');
		_buf.append("bitMask=");
		_buf.appendUint(bitMask);
		_buf.append(',');
		_buf.append("realMoneyOk=");
		_buf.appendUint(realMoneyOk);
		_buf.append(',');
		_buf.append("vipStatus=");
		_buf.appendInt(vipStatus);
		_buf.append(',');
		_buf.append("playChips=");
		_buf.appendInt(playChips);
		_buf.append(',');
		_buf.append("allocPlayChips=");
		_buf.appendInt(allocPlayChips);
		_buf.append(',');
		_buf.append("fpWithCents=");
		_buf.appendInt(fpWithCents);
		_buf.append(',');
		_buf.append("showBonusButton=");
		_buf.appendUint(showBonusButton);
		_buf.append(',');
		_buf.append("showBonusButton2=");
		_buf.appendUint(showBonusButton2);
		_buf.append(',');
		_buf.append("balances=");
		balances.toTraceString(_buf);
		_buf.append(',');
		_buf.append("funds=");
		funds.toTraceString(_buf);
		_buf.append(',');
		_buf.append("nonUsdCurrencies=");
		nonUsdCurrencies.toTraceString(_buf);
		_buf.append(',');
		_buf.append("defaultCurrencyForCountry=");
		_buf.append(defaultCurrencyForCountry);
		_buf.append(',');
		_buf.append("totalBalanceInPreferredCurrency=");
		_buf.appendInt(totalBalanceInPreferredCurrency);
		_buf.append(',');
		_buf.append("totalTBalanceInPreferredCurrency=");
		_buf.appendInt(totalTBalanceInPreferredCurrency);
		_buf.append(',');
		_buf.append("fastDepositPaysystemByte=");
		_buf.appendUint(fastDepositPaysystemByte);
		_buf.append(',');
		_buf.append("beProtectedFromGaming=");
		_buf.appendInt(beProtectedFromGaming);
		_buf.append(',');
		_buf.append("beUnusedLossLimit=");
		_buf.appendInt(beUnusedLossLimit);
		_buf.append(',');
		_buf.append("playChips2=");
		_buf.appendInt64(playChips2);
		_buf.append(',');
		_buf.append("allocPlayChips2=");
		_buf.appendInt64(allocPlayChips2);
		_buf.append(',');
		_buf.append("fulltiltUserId=");
		_buf.append(fulltiltUserId);
		_buf.append(',');
		_buf.append("ftCashoutMinLimit=");
		_buf.appendInt(ftCashoutMinLimit);
		_buf.append(',');
		_buf.append("cashierExtraInfo=");
		cashierExtraInfo.toTraceString(_buf);
		_buf.append(',');
		_buf.append("userRolls=");
		userRolls.toTraceString(_buf);
		_buf.append(',');
		_buf.append("totalForCashoutInPrefCur=");
		_buf.appendInt(totalForCashoutInPrefCur);
		_buf.append(',');
		_buf.append("flags3=");
		_buf.appendUint64(flags3);
		_buf.append(',');
		_buf.append(',');
		_buf.append("totalBalanceInUsd=");
		_buf.appendInt64(totalBalanceInUsd);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		CommMsgBody _msg0;
		_msg0.composeString(email);
		_msg0.composeString(addr1);
		_msg0.composeString(addr2);
		_msg0.composeString(city);
		_msg0.composeString(state);
		_msg0.composeString(country);
		_msg0.composeString(zipCode);
		_msg0.composeString(fullName);
		_msg0.composeSrvDate(birthDate);
		CommMsgBody _msg1;
		homePhoneValidation.composeMsg(_msg1);
		_msg0.composeMsgBody(_msg1);
		_msg0.composeString(firstName);
		_msg0.composeString(onlyLastName);
		_msg0.composeString(fiscalCode);
		userProperties.composeMsg(_msg0);
		_msg0.composeString(sex);
		CommMsgBody _msg2;
		mobilePhoneValidation.composeMsg(_msg2);
		_msg0.composeMsgBody(_msg2);
		_msg0.composeSrvTime(registered);
		_msg.composeMsgBody(_msg0);
		_msg.composeUINT32(flags);
		_msg.composeUINT32(bitMask);
		_msg.composeBYTE(realMoneyOk);
		_msg.composeINT32(vipStatus);
		_msg.composeINT32(playChips);
		_msg.composeINT32(allocPlayChips);
		_msg.composeINT32(fpWithCents);
		_msg.composeBYTE(showBonusButton);
		_msg.composeBYTE(showBonusButton2);
		balances.composeMsg(_msg);
		funds.composeMsg(_msg);
		nonUsdCurrencies.composeMsg(_msg);
		_msg.composeString(defaultCurrencyForCountry);
		_msg.composeINT32(totalBalanceInPreferredCurrency);
		_msg.composeINT32(totalTBalanceInPreferredCurrency);
		_msg.composeBYTE(fastDepositPaysystemByte);
		_msg.composeINT32(beProtectedFromGaming);
		_msg.composeINT32(beUnusedLossLimit);
		_msg.composeINT64(playChips2);
		_msg.composeINT64(allocPlayChips2);
		_msg.composeString(fulltiltUserId);
		_msg.composeINT32(ftCashoutMinLimit);
		cashierExtraInfo.composeMsg(_msg);
		userRolls.composeMsg(_msg);
		_msg.composeINT32(totalForCashoutInPrefCur);
		_msg.composeUINT64(flags3);
		CommMsgBody _msg3;
		_msg.composeMsgBody(_msg3);
		_msg.composeINT64(totalBalanceInUsd);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		parseAnonymousMsgBody0(_parser);
		_parser.parseUINT32(flags);
		_parser.parseUINT32(bitMask);
		_parser.parseBYTE(realMoneyOk);
		_parser.parseINT32(vipStatus);
		_parser.parseINT32(playChips);
		_parser.parseINT32(allocPlayChips);
		_parser.parseINT32(fpWithCents);
		_parser.parseBYTE(showBonusButton);
		_parser.parseBYTE(showBonusButton2);
		balances.parseMsg(_parser);
		funds.parseMsg(_parser);
		nonUsdCurrencies.parseMsg(_parser);
		_parser.parseStringP(defaultCurrencyForCountry);
		_parser.parseINT32(totalBalanceInPreferredCurrency);
		_parser.parseINT32(totalTBalanceInPreferredCurrency);
		_parser.parseBYTE(fastDepositPaysystemByte);
		_parser.parseINT32(beProtectedFromGaming);
		_parser.parseINT32(beUnusedLossLimit);
		_parser.parseINT64(playChips2);
		_parser.parseINT64(allocPlayChips2);
		_parser.parseStringP(fulltiltUserId);
		_parser.parseINT32(ftCashoutMinLimit);
		cashierExtraInfo.parseMsg(_parser);
		userRolls.parseMsg(_parser);
		_parser.parseINT32(totalForCashoutInPrefCur);
		_parser.parseUINT64(flags3);
		parseAnonymousMsgBody3(_parser);
		_parser.parseINT64(totalBalanceInUsd);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CHIPS_INFO2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
		UINT32 flags; _parser.parseUINT32(flags);
		AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
		UINT32 bitMask; _parser.parseUINT32(bitMask);
		AtfValidator::validateInt(_descr, "bitMask", bitMask, _checker, __FILE__, __LINE__);
		BYTE realMoneyOk; _parser.parseBYTE(realMoneyOk);
		AtfValidator::validateInt(_descr, "realMoneyOk", realMoneyOk, _checker, __FILE__, __LINE__);
		INT32 vipStatus; _parser.parseINT32(vipStatus);
		AtfValidator::validateInt(_descr, "vipStatus", vipStatus, _checker, __FILE__, __LINE__);
		INT32 playChips; _parser.parseINT32(playChips);
		AtfValidator::validateInt(_descr, "playChips", playChips, _checker, __FILE__, __LINE__);
		INT32 allocPlayChips; _parser.parseINT32(allocPlayChips);
		AtfValidator::validateInt(_descr, "allocPlayChips", allocPlayChips, _checker, __FILE__, __LINE__);
		INT32 fpWithCents; _parser.parseINT32(fpWithCents);
		AtfValidator::validateInt(_descr, "fpWithCents", fpWithCents, _checker, __FILE__, __LINE__);
		BYTE showBonusButton; _parser.parseBYTE(showBonusButton);
		AtfValidator::validateIntRange(_descr, "showBonusButton", showBonusButton, 0, 1, _checker, __FILE__, __LINE__);
		BYTE showBonusButton2; _parser.parseBYTE(showBonusButton2);
		AtfValidator::validateIntRange(_descr, "showBonusButton2", showBonusButton2, 0, 1, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szBalances = ThinAtf::LAtfVector< UserBalanceInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("balances"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "balances", szBalances, _checker, __FILE__, __LINE__);
		int szFunds = ThinAtf::LAtfVector< UserFundsInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("funds"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "funds", szFunds, _checker, __FILE__, __LINE__);
		int szNonUsdCurrencies = ThinAtf::LAtfVector< UserNonUsdCurrency, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("nonUsdCurrencies"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "nonUsdCurrencies", szNonUsdCurrencies, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "defaultCurrencyForCountry"); size_t szDefaultCurrencyForCountry = strlen(_dummy);
		AtfValidator::validateInt(_descr, "defaultCurrencyForCountry", szDefaultCurrencyForCountry, _checker, __FILE__, __LINE__);
		INT32 totalBalanceInPreferredCurrency; _parser.parseINT32(totalBalanceInPreferredCurrency);
		AtfValidator::validateInt(_descr, "totalBalanceInPreferredCurrency", totalBalanceInPreferredCurrency, _checker, __FILE__, __LINE__);
		INT32 totalTBalanceInPreferredCurrency; _parser.parseINT32(totalTBalanceInPreferredCurrency);
		AtfValidator::validateInt(_descr, "totalTBalanceInPreferredCurrency", totalTBalanceInPreferredCurrency, _checker, __FILE__, __LINE__);
		BYTE fastDepositPaysystemByte; _parser.parseBYTE(fastDepositPaysystemByte);
		AtfValidator::validateInt(_descr, "fastDepositPaysystemByte", fastDepositPaysystemByte, _checker, __FILE__, __LINE__);
		INT32 beProtectedFromGaming; _parser.parseINT32(beProtectedFromGaming);
		AtfValidator::validateInt(_descr, "beProtectedFromGaming", beProtectedFromGaming, _checker, __FILE__, __LINE__);
		INT32 beUnusedLossLimit; _parser.parseINT32(beUnusedLossLimit);
		AtfValidator::validateInt(_descr, "beUnusedLossLimit", beUnusedLossLimit, _checker, __FILE__, __LINE__);
		INT64 playChips2; _parser.parseINT64(playChips2);
		AtfValidator::validateInt(_descr, "playChips2", playChips2, _checker, __FILE__, __LINE__);
		INT64 allocPlayChips2; _parser.parseINT64(allocPlayChips2);
		AtfValidator::validateInt(_descr, "allocPlayChips2", allocPlayChips2, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "fulltiltUserId"); size_t szFulltiltUserId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "fulltiltUserId", szFulltiltUserId, _checker, __FILE__, __LINE__);
		INT32 ftCashoutMinLimit; _parser.parseINT32(ftCashoutMinLimit);
		AtfValidator::validateInt(_descr, "ftCashoutMinLimit", ftCashoutMinLimit, _checker, __FILE__, __LINE__);
		int szCashierExtraInfo = ThinAtf::LAtfVector< CashierExtraInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cashierExtraInfo"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "cashierExtraInfo", szCashierExtraInfo, _checker, __FILE__, __LINE__);
		int szUserRolls = ThinAtf::LAtfVector< common_structs::CashierRollBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("userRolls"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "userRolls", szUserRolls, _checker, __FILE__, __LINE__);
		INT32 totalForCashoutInPrefCur; _parser.parseINT32(totalForCashoutInPrefCur);
		AtfValidator::validateInt(_descr, "totalForCashoutInPrefCur", totalForCashoutInPrefCur, _checker, __FILE__, __LINE__);
		UINT64 flags3; _parser.parseUINT64(flags3);
		AtfValidator::validateUint(_descr, "flags3", flags3, _checker, __FILE__, __LINE__);
		validateAnonymousMsgBody3(_parser, _checker, _descr, _fieldsWithUnparsedContent);
		INT64 totalBalanceInUsd; _parser.parseINT64(totalBalanceInUsd);
		AtfValidator::validateInt(_descr, "totalBalanceInUsd", totalBalanceInUsd, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(email);
	_parser0.parseStringP(addr1);
	_parser0.parseStringP(addr2);
	_parser0.parseStringP(city);
	_parser0.parseStringP(state);
	_parser0.parseStringP(country);
	_parser0.parseStringP(zipCode);
	_parser0.parseStringP(fullName);
	_parser0.parseSrvDate(birthDate);
	parseAnonymousMsgBody1(_parser0);
	_parser0.parseStringP(firstName);
	_parser0.parseStringP(onlyLastName);
	_parser0.parseStringP(fiscalCode);
	userProperties.parseMsg(_parser0);
	_parser0.parseStringP(sex);
	parseAnonymousMsgBody2(_parser0);
	_parser0.parseSrvTime(registered);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
	AtfValidator::validateInt(_descr, "email", szEmail, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "addr1"); size_t szAddr1 = strlen(_dummy);
	AtfValidator::validateInt(_descr, "addr1", szAddr1, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "addr2"); size_t szAddr2 = strlen(_dummy);
	AtfValidator::validateInt(_descr, "addr2", szAddr2, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
	AtfValidator::validateInt(_descr, "city", szCity, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "state"); size_t szState = strlen(_dummy);
	AtfValidator::validateInt(_descr, "state", szState, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "zipCode"); size_t szZipCode = strlen(_dummy);
	AtfValidator::validateInt(_descr, "zipCode", szZipCode, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "fullName"); size_t szFullName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "fullName", szFullName, _checker, __FILE__, __LINE__);
	SrvDate birthDate; _parser0.parseSrvDate(birthDate);
	AtfValidator::validateSrvDateTime(_descr, "birthDate", birthDate, _checker, __FILE__, __LINE__);
	validateAnonymousMsgBody1(_parser0, _checker, _descr, _fieldsWithUnparsedContent);
	_parser0.parseStringN(_dummy, 0, "firstName"); size_t szFirstName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "firstName", szFirstName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "onlyLastName"); size_t szOnlyLastName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "onlyLastName", szOnlyLastName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "fiscalCode"); size_t szFiscalCode = strlen(_dummy);
	AtfValidator::validateInt(_descr, "fiscalCode", szFiscalCode, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szUserProperties = ThinAtf::LAtfVector< Common::AtfShared::UserPropertyBody, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("userProperties"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "userProperties", szUserProperties, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "sex"); size_t szSex = strlen(_dummy);
	AtfValidator::validateInt(_descr, "sex", szSex, _checker, __FILE__, __LINE__);
	validateAnonymousMsgBody2(_parser0, _checker, _descr, _fieldsWithUnparsedContent);
	SrvTime registered; _parser0.parseSrvTime(registered);
	AtfValidator::validateSrvDateTime(_descr, "registered", registered, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::parseAnonymousMsgBody1(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	homePhoneValidation.parseMsg(_parser0);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::validateAnonymousMsgBody1(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	PhoneValidationInfo::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("homePhoneValidation"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::parseAnonymousMsgBody2(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	mobilePhoneValidation.parseMsg(_parser0);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::validateAnonymousMsgBody2(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	PhoneValidationInfo::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("mobilePhoneValidation"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::parseAnonymousMsgBody3(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::validateAnonymousMsgBody3(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

//=================================================================
//                    PaymentSpecificDataOne
//=================================================================

CashierServer::cli::PaymentSpecificDataOne::PaymentSpecificDataOne()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::PaymentSpecificDataOne::PaymentSpecificDataOne(PaymentSpecificDataOne&& _o)
	: dataId(std::move(_o.dataId))
	, worldpay3DS2_referenceId(std::move(_o.worldpay3DS2_referenceId))
	, worldpay3DS2_windowSize(std::move(_o.worldpay3DS2_windowSize))
	, starswallet_mTan(std::move(_o.starswallet_mTan))
	, cbsUrl(std::move(_o.cbsUrl))
	, cbsUrl_wc2mt(std::move(_o.cbsUrl_wc2mt))
	, applePay_encrPaymentToken(std::move(_o.applePay_encrPaymentToken))
	, childTransId(std::move(_o.childTransId))
	, clientAcceptHeader(std::move(_o.clientAcceptHeader))
	, clientJavaEnabled(std::move(_o.clientJavaEnabled))
	, clientScreenColorDepth(std::move(_o.clientScreenColorDepth))
	, clientScreenHeight(std::move(_o.clientScreenHeight))
	, clientScreenWidth(std::move(_o.clientScreenWidth))
	, clientUserAgent(std::move(_o.clientUserAgent))
	, clientTzOffsetInMin(std::move(_o.clientTzOffsetInMin))
	, clientBrowserLocale(std::move(_o.clientBrowserLocale))
	, clientChallengeWinSize(std::move(_o.clientChallengeWinSize))
{
}

CashierServer::cli::PaymentSpecificDataOne& CashierServer::cli::PaymentSpecificDataOne::operator=(PaymentSpecificDataOne&& _o)
{
	if(this != &_o)
	{
		dataId = std::move(_o.dataId);
		worldpay3DS2_referenceId = std::move(_o.worldpay3DS2_referenceId);
		worldpay3DS2_windowSize = std::move(_o.worldpay3DS2_windowSize);
		starswallet_mTan = std::move(_o.starswallet_mTan);
		cbsUrl = std::move(_o.cbsUrl);
		cbsUrl_wc2mt = std::move(_o.cbsUrl_wc2mt);
		applePay_encrPaymentToken = std::move(_o.applePay_encrPaymentToken);
		childTransId = std::move(_o.childTransId);
		clientAcceptHeader = std::move(_o.clientAcceptHeader);
		clientJavaEnabled = std::move(_o.clientJavaEnabled);
		clientScreenColorDepth = std::move(_o.clientScreenColorDepth);
		clientScreenHeight = std::move(_o.clientScreenHeight);
		clientScreenWidth = std::move(_o.clientScreenWidth);
		clientUserAgent = std::move(_o.clientUserAgent);
		clientTzOffsetInMin = std::move(_o.clientTzOffsetInMin);
		clientBrowserLocale = std::move(_o.clientBrowserLocale);
		clientChallengeWinSize = std::move(_o.clientChallengeWinSize);
	}
	return *this;
}

#endif

void CashierServer::cli::PaymentSpecificDataOne::clear()
{
	dataId = 0;
	worldpay3DS2_referenceId.clear();
	worldpay3DS2_windowSize.clear();
	starswallet_mTan.clear();
	cbsUrl.clear();
	cbsUrl_wc2mt.clear();
	applePay_encrPaymentToken.clear();
	childTransId = 0;
	clientAcceptHeader.clear();
	clientJavaEnabled.clear();
	clientScreenColorDepth.clear();
	clientScreenHeight.clear();
	clientScreenWidth.clear();
	clientUserAgent.clear();
	clientTzOffsetInMin.clear();
	clientBrowserLocale.clear();
	clientChallengeWinSize.clear();
}

bool CashierServer::cli::PaymentSpecificDataOne::equals(const PaymentSpecificDataOne& _o) const
{
	return dataId == _o.dataId &&
		worldpay3DS2_referenceId.equals(_o.worldpay3DS2_referenceId) &&
		worldpay3DS2_windowSize.equals(_o.worldpay3DS2_windowSize) &&
		starswallet_mTan.equals(_o.starswallet_mTan) &&
		cbsUrl.equals(_o.cbsUrl) &&
		cbsUrl_wc2mt.equals(_o.cbsUrl_wc2mt) &&
		applePay_encrPaymentToken.equals(_o.applePay_encrPaymentToken) &&
		childTransId == _o.childTransId &&
		clientAcceptHeader.equals(_o.clientAcceptHeader) &&
		clientJavaEnabled.equals(_o.clientJavaEnabled) &&
		clientScreenColorDepth.equals(_o.clientScreenColorDepth) &&
		clientScreenHeight.equals(_o.clientScreenHeight) &&
		clientScreenWidth.equals(_o.clientScreenWidth) &&
		clientUserAgent.equals(_o.clientUserAgent) &&
		clientTzOffsetInMin.equals(_o.clientTzOffsetInMin) &&
		clientBrowserLocale.equals(_o.clientBrowserLocale) &&
		clientChallengeWinSize.equals(_o.clientChallengeWinSize);
}

const char *CashierServer::cli::PaymentSpecificDataOne::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("dataId=");
	_buf.appendUint(dataId);
	if (dataId == ePaymentSpecificData_Worldpay3DS2_ReferenceId)
	{
		_buf.append(',');
		_buf.append("worldpay3DS2_referenceId=");
		_buf.append(worldpay3DS2_referenceId);
		_buf.append(',');
		_buf.append("worldpay3DS2_windowSize=");
		_buf.append(worldpay3DS2_windowSize);
	}
	else if (dataId == ePaymentSpecificData_StarswalletMtan)
	{
		_buf.append(',');
		_buf.append("starswallet_mTan=");
		_buf.append(starswallet_mTan);
	}
	else if (dataId == ePaymentSpecificData_CbsUrl)
	{
		_buf.append(',');
		_buf.append("cbsUrl=");
		_buf.append(cbsUrl);
		_buf.append(',');
		_buf.append("cbsUrl_wc2mt=");
		_buf.append(cbsUrl_wc2mt);
	}
	else if (dataId == ePaymentSpecificData_ApplePay)
	{
		_buf.append(',');
		_buf.append("applePay_encrPaymentToken=");
		_buf.append(applePay_encrPaymentToken);
	}
	else if (dataId == ePaymentSpecificData_3dFormDone)
	{
		_buf.append(',');
		_buf.append("childTransId=");
		_buf.appendUint(childTransId);
	}
	else if (dataId == ePaymentSpecificData_ClientCapability)
	{
		_buf.append(',');
		_buf.append("clientAcceptHeader=");
		_buf.append(clientAcceptHeader);
		_buf.append(',');
		_buf.append("clientJavaEnabled=");
		_buf.append(clientJavaEnabled);
		_buf.append(',');
		_buf.append("clientScreenColorDepth=");
		_buf.append(clientScreenColorDepth);
		_buf.append(',');
		_buf.append("clientScreenHeight=");
		_buf.append(clientScreenHeight);
		_buf.append(',');
		_buf.append("clientScreenWidth=");
		_buf.append(clientScreenWidth);
		_buf.append(',');
		_buf.append("clientUserAgent=");
		_buf.append(clientUserAgent);
		_buf.append(',');
		_buf.append("clientTzOffsetInMin=");
		_buf.append(clientTzOffsetInMin);
		_buf.append(',');
		_buf.append("clientBrowserLocale=");
		_buf.append(clientBrowserLocale);
		_buf.append(',');
		_buf.append("clientChallengeWinSize=");
		_buf.append(clientChallengeWinSize);
	}
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::PaymentSpecificDataOne::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(dataId);
	if (dataId == ePaymentSpecificData_Worldpay3DS2_ReferenceId)
	{
		CommMsgBody _msg0;
		_msg0.composeString(worldpay3DS2_referenceId);
		_msg0.composeString(worldpay3DS2_windowSize);
		_msg.composeMsgBody(_msg0);
	}
	else if (dataId == ePaymentSpecificData_StarswalletMtan)
	{
		CommMsgBody _msg1;
		_msg1.composeString(starswallet_mTan);
		_msg.composeMsgBody(_msg1);
	}
	else if (dataId == ePaymentSpecificData_CbsUrl)
	{
		CommMsgBody _msg2;
		_msg2.composeString(cbsUrl);
		_msg2.composeString(cbsUrl_wc2mt);
		_msg.composeMsgBody(_msg2);
	}
	else if (dataId == ePaymentSpecificData_ApplePay)
	{
		CommMsgBody _msg3;
		_msg3.composeString(applePay_encrPaymentToken);
		_msg.composeMsgBody(_msg3);
	}
	else if (dataId == ePaymentSpecificData_3dFormDone)
	{
		CommMsgBody _msg4;
		_msg4.composeUINT32(childTransId);
		_msg.composeMsgBody(_msg4);
	}
	else if (dataId == ePaymentSpecificData_ClientCapability)
	{
		CommMsgBody _msg5;
		_msg5.composeString(clientAcceptHeader);
		_msg5.composeString(clientJavaEnabled);
		_msg5.composeString(clientScreenColorDepth);
		_msg5.composeString(clientScreenHeight);
		_msg5.composeString(clientScreenWidth);
		_msg5.composeString(clientUserAgent);
		_msg5.composeString(clientTzOffsetInMin);
		_msg5.composeString(clientBrowserLocale);
		_msg5.composeString(clientChallengeWinSize);
		_msg.composeMsgBody(_msg5);
	}
}

void CashierServer::cli::PaymentSpecificDataOne::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(dataId);
	if (dataId == ePaymentSpecificData_Worldpay3DS2_ReferenceId)
	{
		parseAnonymousMsgBody0(_parser);
	}
	else if (dataId == ePaymentSpecificData_StarswalletMtan)
	{
		parseAnonymousMsgBody1(_parser);
	}
	else if (dataId == ePaymentSpecificData_CbsUrl)
	{
		parseAnonymousMsgBody2(_parser);
	}
	else if (dataId == ePaymentSpecificData_ApplePay)
	{
		parseAnonymousMsgBody3(_parser);
	}
	else if (dataId == ePaymentSpecificData_3dFormDone)
	{
		parseAnonymousMsgBody4(_parser);
	}
	else if (dataId == ePaymentSpecificData_ClientCapability)
	{
		parseAnonymousMsgBody5(_parser);
	}
}

/*static*/ void CashierServer::cli::PaymentSpecificDataOne::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 dataId = 0;
	_parser.parseUINT32(dataId);
	{ const UINT32 dataId_enum[] = {
				ePaymentSpecificData_Worldpay3DS2_ReferenceId, 
				ePaymentSpecificData_StarswalletMtan,          
				ePaymentSpecificData_ApplePay,                 
				ePaymentSpecificData_CbsUrl,                   
				ePaymentSpecificData_3dFormDone,               
				ePaymentSpecificData_ClientCapability          
			}; AtfValidator::validateEnum(_descr, "dataId", dataId, dataId_enum, _checker, __FILE__, __LINE__); }
	if (dataId == ePaymentSpecificData_Worldpay3DS2_ReferenceId)
	{
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (dataId == ePaymentSpecificData_StarswalletMtan)
	{
		validateAnonymousMsgBody1(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (dataId == ePaymentSpecificData_CbsUrl)
	{
		validateAnonymousMsgBody2(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (dataId == ePaymentSpecificData_ApplePay)
	{
		validateAnonymousMsgBody3(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (dataId == ePaymentSpecificData_3dFormDone)
	{
		validateAnonymousMsgBody4(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (dataId == ePaymentSpecificData_ClientCapability)
	{
		validateAnonymousMsgBody5(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
}

void CashierServer::cli::PaymentSpecificDataOne::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(worldpay3DS2_referenceId);
	_parser0.parseStringP(worldpay3DS2_windowSize);
}

/*static*/ void CashierServer::cli::PaymentSpecificDataOne::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "worldpay3DS2_referenceId"); size_t szWorldpay3DS2_referenceId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "worldpay3DS2_referenceId", szWorldpay3DS2_referenceId, 10000, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "worldpay3DS2_windowSize"); size_t szWorldpay3DS2_windowSize = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "worldpay3DS2_windowSize", szWorldpay3DS2_windowSize, 10000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::PaymentSpecificDataOne::parseAnonymousMsgBody1(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(starswallet_mTan);
}

/*static*/ void CashierServer::cli::PaymentSpecificDataOne::validateAnonymousMsgBody1(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "starswallet_mTan"); size_t szStarswallet_mTan = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "starswallet_mTan", szStarswallet_mTan, 10000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::PaymentSpecificDataOne::parseAnonymousMsgBody2(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(cbsUrl);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(cbsUrl_wc2mt);
}

/*static*/ void CashierServer::cli::PaymentSpecificDataOne::validateAnonymousMsgBody2(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "cbsUrl"); size_t szCbsUrl = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "cbsUrl", szCbsUrl, 10000, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "cbsUrl_wc2mt"); size_t szCbsUrl_wc2mt = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "cbsUrl_wc2mt", szCbsUrl_wc2mt, 10000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::PaymentSpecificDataOne::parseAnonymousMsgBody3(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(applePay_encrPaymentToken);
}

/*static*/ void CashierServer::cli::PaymentSpecificDataOne::validateAnonymousMsgBody3(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "applePay_encrPaymentToken"); size_t szApplePay_encrPaymentToken = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "applePay_encrPaymentToken", szApplePay_encrPaymentToken, 10000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::PaymentSpecificDataOne::parseAnonymousMsgBody4(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(childTransId);
}

/*static*/ void CashierServer::cli::PaymentSpecificDataOne::validateAnonymousMsgBody4(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 childTransId; _parser0.parseUINT32(childTransId);
	AtfValidator::validateInt(_descr, "childTransId", childTransId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::PaymentSpecificDataOne::parseAnonymousMsgBody5(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(clientAcceptHeader);
	_parser0.parseStringP(clientJavaEnabled);
	_parser0.parseStringP(clientScreenColorDepth);
	_parser0.parseStringP(clientScreenHeight);
	_parser0.parseStringP(clientScreenWidth);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(clientUserAgent);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(clientTzOffsetInMin);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(clientBrowserLocale);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(clientChallengeWinSize);
}

/*static*/ void CashierServer::cli::PaymentSpecificDataOne::validateAnonymousMsgBody5(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "clientAcceptHeader"); size_t szClientAcceptHeader = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "clientAcceptHeader", szClientAcceptHeader, 10000, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "clientJavaEnabled"); size_t szClientJavaEnabled = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "clientJavaEnabled", szClientJavaEnabled, 10000, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "clientScreenColorDepth"); size_t szClientScreenColorDepth = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "clientScreenColorDepth", szClientScreenColorDepth, 10000, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "clientScreenHeight"); size_t szClientScreenHeight = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "clientScreenHeight", szClientScreenHeight, 10000, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "clientScreenWidth"); size_t szClientScreenWidth = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "clientScreenWidth", szClientScreenWidth, 10000, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "clientUserAgent"); size_t szClientUserAgent = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "clientUserAgent", szClientUserAgent, 10000, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "clientTzOffsetInMin"); size_t szClientTzOffsetInMin = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "clientTzOffsetInMin", szClientTzOffsetInMin, 10000, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "clientBrowserLocale"); size_t szClientBrowserLocale = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "clientBrowserLocale", szClientBrowserLocale, 10000, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "clientChallengeWinSize"); size_t szClientChallengeWinSize = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "clientChallengeWinSize", szClientChallengeWinSize, 10000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PaymentSpecificDataVec
//=================================================================

CashierServer::cli::PaymentSpecificDataVec::PaymentSpecificDataVec()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::PaymentSpecificDataVec::PaymentSpecificDataVec(PaymentSpecificDataVec&& _o)
	: vec(std::move(_o.vec))
{
}

CashierServer::cli::PaymentSpecificDataVec& CashierServer::cli::PaymentSpecificDataVec::operator=(PaymentSpecificDataVec&& _o)
{
	if(this != &_o)
	{
		vec = std::move(_o.vec);
	}
	return *this;
}

#endif

void CashierServer::cli::PaymentSpecificDataVec::clear()
{
	vec.clear();
}

bool CashierServer::cli::PaymentSpecificDataVec::equals(const PaymentSpecificDataVec& _o) const
{
	return vec.equals(_o.vec);
}

const char *CashierServer::cli::PaymentSpecificDataVec::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("vec=");
	vec.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::PaymentSpecificDataVec::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(PaymentSpecificDataVec())) // not empty
	{
		vec.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::PaymentSpecificDataVec::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	vec.parseMsg(_parser0);
}

/*static*/ void CashierServer::cli::PaymentSpecificDataVec::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szVec = ThinAtf::LAtfVector< PaymentSpecificDataOne, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("vec"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "vec", szVec, 1000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_CASHIN_CC
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC::Protocol_MSG_CASHIER_CASHIN_CC()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC::Protocol_MSG_CASHIER_CASHIN_CC(Protocol_MSG_CASHIER_CASHIN_CC&& _o)
	: userId(std::move(_o.userId))
	, amount(std::move(_o.amount))
	, paySystemByte(std::move(_o.paySystemByte))
	, cardNum(std::move(_o.cardNum))
	, cardCvv(std::move(_o.cardCvv))
	, expYear(std::move(_o.expYear))
	, expMonth(std::move(_o.expMonth))
	, bonusId(std::move(_o.bonusId))
	, doNotCancelCashouts(std::move(_o.doNotCancelCashouts))
	, currency(std::move(_o.currency))
	, issueNum(std::move(_o.issueNum))
	, startDate(std::move(_o.startDate))
	, converted(std::move(_o.converted))
	, secNum(std::move(_o.secNum))
	, bDate(std::move(_o.bDate))
	, dLicense(std::move(_o.dLicense))
	, userPhoneAch(std::move(_o.userPhoneAch))
	, saveCardInfoRequested(std::move(_o.saveCardInfoRequested))
	, bonusCode(std::move(_o.bonusCode))
	, balanceCurrency(std::move(_o.balanceCurrency))
	, clientBalance(std::move(_o.clientBalance))
	, fastDepositTransaction(std::move(_o.fastDepositTransaction))
	, saveInfoForFastDeposit(std::move(_o.saveInfoForFastDeposit))
	, ignoreRepeatedDeclines(std::move(_o.ignoreRepeatedDeclines))
	, cardInfoId(std::move(_o.cardInfoId))
	, awardId(std::move(_o.awardId))
	, clientDepositFlags(std::move(_o.clientDepositFlags))
	, isLoadAmountProvided(std::move(_o.isLoadAmountProvided))
	, loadAmount(std::move(_o.loadAmount))
	, geoIpInfo(std::move(_o.geoIpInfo))
	, depositPassword(std::move(_o.depositPassword))
	, encryptedCardNumAndCvv(std::move(_o.encryptedCardNumAndCvv))
	, paymentSpecificDataVec(std::move(_o.paymentSpecificDataVec))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC& CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC::operator=(Protocol_MSG_CASHIER_CASHIN_CC&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		amount = std::move(_o.amount);
		paySystemByte = std::move(_o.paySystemByte);
		cardNum = std::move(_o.cardNum);
		cardCvv = std::move(_o.cardCvv);
		expYear = std::move(_o.expYear);
		expMonth = std::move(_o.expMonth);
		bonusId = std::move(_o.bonusId);
		doNotCancelCashouts = std::move(_o.doNotCancelCashouts);
		currency = std::move(_o.currency);
		issueNum = std::move(_o.issueNum);
		startDate = std::move(_o.startDate);
		converted = std::move(_o.converted);
		secNum = std::move(_o.secNum);
		bDate = std::move(_o.bDate);
		dLicense = std::move(_o.dLicense);
		userPhoneAch = std::move(_o.userPhoneAch);
		saveCardInfoRequested = std::move(_o.saveCardInfoRequested);
		bonusCode = std::move(_o.bonusCode);
		balanceCurrency = std::move(_o.balanceCurrency);
		clientBalance = std::move(_o.clientBalance);
		fastDepositTransaction = std::move(_o.fastDepositTransaction);
		saveInfoForFastDeposit = std::move(_o.saveInfoForFastDeposit);
		ignoreRepeatedDeclines = std::move(_o.ignoreRepeatedDeclines);
		cardInfoId = std::move(_o.cardInfoId);
		awardId = std::move(_o.awardId);
		clientDepositFlags = std::move(_o.clientDepositFlags);
		isLoadAmountProvided = std::move(_o.isLoadAmountProvided);
		loadAmount = std::move(_o.loadAmount);
		geoIpInfo = std::move(_o.geoIpInfo);
		depositPassword = std::move(_o.depositPassword);
		encryptedCardNumAndCvv = std::move(_o.encryptedCardNumAndCvv);
		paymentSpecificDataVec = std::move(_o.paymentSpecificDataVec);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC::clear()
{
	userId.clear();
	amount = 0;
	paySystemByte = 0;
	cardNum.clear();
	cardCvv.clear();
	expYear = 0;
	expMonth = 0;
	bonusId = 0;
	doNotCancelCashouts = 0;
	currency.clear();
	issueNum.clear();
	startDate.clear();
	converted = 0;
	secNum.clear();
	bDate.setNull();
	dLicense.clear();
	userPhoneAch.clear();
	saveCardInfoRequested = false;
	bonusCode.clear();
	balanceCurrency.clear();
	clientBalance = 0;
	fastDepositTransaction = false;
	saveInfoForFastDeposit = false;
	ignoreRepeatedDeclines = false;
	cardInfoId = 0;
	awardId = 0;
	clientDepositFlags = 0;
	isLoadAmountProvided = false;
	loadAmount = 0;
	geoIpInfo.clear();
	depositPassword.clear();
	encryptedCardNumAndCvv.clear();
	paymentSpecificDataVec.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC::equals(const Protocol_MSG_CASHIER_CASHIN_CC& _o) const
{
	return userId.equals(_o.userId) &&
		amount == _o.amount &&
		paySystemByte == _o.paySystemByte &&
		cardNum.equals(_o.cardNum) &&
		cardCvv.equals(_o.cardCvv) &&
		expYear == _o.expYear &&
		expMonth == _o.expMonth &&
		bonusId == _o.bonusId &&
		doNotCancelCashouts == _o.doNotCancelCashouts &&
		currency.equals(_o.currency) &&
		issueNum.equals(_o.issueNum) &&
		startDate.equals(_o.startDate) &&
		converted == _o.converted &&
		secNum.equals(_o.secNum) &&
		bDate.equals(_o.bDate) &&
		dLicense.equals(_o.dLicense) &&
		userPhoneAch.equals(_o.userPhoneAch) &&
		saveCardInfoRequested == _o.saveCardInfoRequested &&
		bonusCode.equals(_o.bonusCode) &&
		balanceCurrency.equals(_o.balanceCurrency) &&
		clientBalance == _o.clientBalance &&
		fastDepositTransaction == _o.fastDepositTransaction &&
		saveInfoForFastDeposit == _o.saveInfoForFastDeposit &&
		ignoreRepeatedDeclines == _o.ignoreRepeatedDeclines &&
		cardInfoId == _o.cardInfoId &&
		awardId == _o.awardId &&
		clientDepositFlags == _o.clientDepositFlags &&
		isLoadAmountProvided == _o.isLoadAmountProvided &&
		loadAmount == _o.loadAmount &&
		geoIpInfo.equals(_o.geoIpInfo) &&
		depositPassword.equals(_o.depositPassword) &&
		encryptedCardNumAndCvv.size() == _o.encryptedCardNumAndCvv.size() && memcmp(encryptedCardNumAndCvv.ptr(), _o.encryptedCardNumAndCvv.ptr(), encryptedCardNumAndCvv.size()) == 0 &&
		paymentSpecificDataVec.equals(_o.paymentSpecificDataVec);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CASHIN_CC).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendInt(amount);
	_buf.append(',');
	_buf.append("paySystemByte=");
	_buf.appendUint(paySystemByte);
	_buf.append(',');
	_buf.append("cardNum=");
	_buf.append(cardNum);
	_buf.append(',');
	_buf.append("cardCvv=");
	_buf.append(cardCvv);
	_buf.append(',');
	_buf.append("expYear=");
	_buf.appendUint(expYear);
	_buf.append(',');
	_buf.append("expMonth=");
	_buf.appendUint(expMonth);
	_buf.append(',');
	_buf.append("bonusId=");
	_buf.appendUint(bonusId);
	_buf.append(',');
	_buf.append("doNotCancelCashouts=");
	_buf.appendUint(doNotCancelCashouts);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("issueNum=");
	_buf.append(issueNum);
	_buf.append(',');
	_buf.append("startDate=");
	_buf.append(startDate);
	_buf.append(',');
	_buf.append("converted=");
	_buf.appendInt(converted);
	_buf.append(',');
	_buf.append("secNum=");
	_buf.append(secNum);
	_buf.append(',');
	_buf.append("bDate=");
	ThinAtf::AtfTempl<CommSrvDate>::ToTraceString(_buf, bDate);
	_buf.append(',');
	_buf.append("dLicense=");
	_buf.append(dLicense);
	_buf.append(',');
	_buf.append("userPhoneAch=");
	_buf.append(userPhoneAch);
	_buf.append(',');
	_buf.append("saveCardInfoRequested=");
	_buf.appendUint(saveCardInfoRequested);
	_buf.append(',');
	_buf.append("bonusCode=");
	_buf.append(bonusCode);
	_buf.append(',');
	_buf.append("balanceCurrency=");
	_buf.append(balanceCurrency);
	_buf.append(',');
	_buf.append("clientBalance=");
	_buf.appendInt(clientBalance);
	_buf.append(',');
	_buf.append("fastDepositTransaction=");
	_buf.appendUint(fastDepositTransaction);
	_buf.append(',');
	_buf.append("saveInfoForFastDeposit=");
	_buf.appendUint(saveInfoForFastDeposit);
	_buf.append(',');
	_buf.append("ignoreRepeatedDeclines=");
	_buf.appendUint(ignoreRepeatedDeclines);
	_buf.append(',');
	_buf.append("cardInfoId=");
	_buf.appendUint(cardInfoId);
	_buf.append(',');
	_buf.append("awardId=");
	_buf.appendUint(awardId);
	_buf.append(',');
	_buf.append("clientDepositFlags=");
	_buf.appendUint(clientDepositFlags);
	if (paySystemByte == cardTypePayLucky || paySystemByte == cardTypeSightline || paySystemByte == cardTypeSightlineNR)
	{
		_buf.append(',');
		_buf.append("isLoadAmountProvided=");
		_buf.appendUint(isLoadAmountProvided);
		_buf.append(',');
		_buf.append("loadAmount=");
		_buf.appendInt(loadAmount);
		_buf.append(',');
		_buf.append("geoIpInfo=");
		_buf.append(geoIpInfo);
	}
	else if (paySystemByte == cardTypeGamersCard)
	{
		_buf.append(',');
		_buf.append("depositPassword=");
		_buf.append(depositPassword);
	}
	else
	{
		_buf.append(',');
	}
	_buf.append(',');
	_buf.append("encryptedCardNumAndCvv=");
	ThinAtf::AtfTempl<PBlock>::ToTraceString(_buf, encryptedCardNumAndCvv);
	_buf.append(',');
	_buf.append("paymentSpecificDataVec=");
	paymentSpecificDataVec.toTraceString(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeINT32(amount);
	_msg.composeBYTE(paySystemByte);
	_msg.composeString(cardNum);
	_msg.composeString(cardCvv);
	_msg.composeUINT16(expYear);
	_msg.composeBYTE(expMonth);
	_msg.composeUINT32(bonusId);
	_msg.composeBYTE(doNotCancelCashouts);
	_msg.composeString(currency);
	_msg.composeString(issueNum);
	_msg.composeString(startDate);
	_msg.composeINT32(converted);
	_msg.composeString(secNum);
	_msg.composeSrvDate(bDate);
	_msg.composeString(dLicense);
	_msg.composeString(userPhoneAch);
	_msg.composeBOOL(saveCardInfoRequested);
	_msg.composeString(bonusCode);
	_msg.composeString(balanceCurrency);
	_msg.composeINT32(clientBalance);
	_msg.composeBOOL(fastDepositTransaction);
	_msg.composeBOOL(saveInfoForFastDeposit);
	_msg.composeBOOL(ignoreRepeatedDeclines);
	_msg.composeUINT32(cardInfoId);
	_msg.composeUINT32(awardId);
	_msg.composeUINT32(clientDepositFlags);
	if (paySystemByte == cardTypePayLucky || paySystemByte == cardTypeSightline || paySystemByte == cardTypeSightlineNR)
	{
		CommMsgBody _msg0;
		_msg0.composeBOOL(isLoadAmountProvided);
		_msg0.composeINT32(loadAmount);
		_msg0.composeString(geoIpInfo);
		_msg.composeMsgBody(_msg0);
	}
	else if (paySystemByte == cardTypeGamersCard)
	{
		CommMsgBody _msg1;
		_msg1.composeString(depositPassword);
		_msg.composeMsgBody(_msg1);
	}
	else
	{
		CommMsgBody _msg2;
		_msg.composeMsgBody(_msg2);
	}
	_msg._composeVarBlock(encryptedCardNumAndCvv.ptr(), encryptedCardNumAndCvv.size());
	paymentSpecificDataVec.composeMsg(_msg);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseINT32(amount);
	_parser.parseBYTE(paySystemByte);
	_parser.parseStringP(cardNum);
	_parser.parseStringP(cardCvv);
	_parser.parseUINT16(expYear);
	_parser.parseBYTE(expMonth);
	_parser.parseUINT32(bonusId);
	_parser.parseBYTE(doNotCancelCashouts);
	_parser.parseStringP(currency);
	_parser.parseStringP(issueNum);
	_parser.parseStringP(startDate);
	_parser.parseINT32(converted);
	_parser.parseStringP(secNum);
	_parser.parseSrvDate(bDate);
	_parser.parseStringP(dLicense);
	_parser.parseStringP(userPhoneAch);
	_parser.parseBOOL(saveCardInfoRequested);
	_parser.parseStringP(bonusCode);
	_parser.parseStringP(balanceCurrency);
	_parser.parseINT32(clientBalance);
	_parser.parseBOOL(fastDepositTransaction);
	_parser.parseBOOL(saveInfoForFastDeposit);
	_parser.parseBOOL(ignoreRepeatedDeclines);
	_parser.parseUINT32(cardInfoId);
	_parser.parseUINT32(awardId);
	_parser.parseUINT32(clientDepositFlags);
	if (paySystemByte == cardTypePayLucky || paySystemByte == cardTypeSightline || paySystemByte == cardTypeSightlineNR)
	{
		if(_parser.parseEnded()) return;
		parseAnonymousMsgBody0(_parser);
	}
	else if (paySystemByte == cardTypeGamersCard)
	{
		if(_parser.parseEnded()) return;
		parseAnonymousMsgBody1(_parser);
	}
	else
	{
		if(_parser.parseEnded()) return;
		parseAnonymousMsgBody2(_parser);
	}
	if(_parser.parseEnded()) return;
	_parser.parsePBlock(encryptedCardNumAndCvv);
	if(_parser.parseEnded()) return;
	paymentSpecificDataVec.parseMsg(_parser);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CASHIN_CC";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE paySystemByte = 0;
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	INT32 amount; _parser.parseINT32(amount);
	AtfValidator::validateIntRange(_descr, "amount", amount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseBYTE(paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "cardNum"); size_t szCardNum = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "cardNum", szCardNum, CARDNUM_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "cardCvv"); size_t szCardCvv = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "cardCvv", szCardCvv, CARD_CVV_LEN, _checker, __FILE__, __LINE__);
	UINT16 expYear; _parser.parseUINT16(expYear);
	AtfValidator::validateIntRange(_descr, "expYear", expYear, 0, 3000, _checker, __FILE__, __LINE__);
	BYTE expMonth; _parser.parseBYTE(expMonth);
	AtfValidator::validateIntRange(_descr, "expMonth", expMonth, 0, 12, _checker, __FILE__, __LINE__);
	UINT32 bonusId; _parser.parseUINT32(bonusId);
	AtfValidator::validateInt(_descr, "bonusId", bonusId, _checker, __FILE__, __LINE__);
	BYTE doNotCancelCashouts; _parser.parseBYTE(doNotCancelCashouts);
	AtfValidator::validateInt(_descr, "doNotCancelCashouts", doNotCancelCashouts, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "issueNum"); size_t szIssueNum = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "issueNum", szIssueNum, ISSUE_NUM_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "startDate"); size_t szStartDate = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "startDate", szStartDate, START_DATE_LEN, _checker, __FILE__, __LINE__);
	INT32 converted; _parser.parseINT32(converted);
	AtfValidator::validateIntRange(_descr, "converted", converted, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "secNum"); size_t szSecNum = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "secNum", szSecNum, 1000, _checker, __FILE__, __LINE__);
	CommSrvDate bDate; _parser.parseSrvDate(bDate);
	AtfValidator::validateSrvDateTime(_descr, "bDate", bDate, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "dLicense"); size_t szDLicense = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "dLicense", szDLicense, 1000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userPhoneAch"); size_t szUserPhoneAch = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userPhoneAch", szUserPhoneAch, 1000, _checker, __FILE__, __LINE__);
	bool saveCardInfoRequested; _parser.parseBOOL(saveCardInfoRequested);
	AtfValidator::validateInt(_descr, "saveCardInfoRequested", saveCardInfoRequested, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "bonusCode"); size_t szBonusCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bonusCode", szBonusCode, BONUS_CODE_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "balanceCurrency"); size_t szBalanceCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "balanceCurrency", szBalanceCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	INT32 clientBalance; _parser.parseINT32(clientBalance);
	AtfValidator::validateIntMax(_descr, "clientBalance", clientBalance, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	bool fastDepositTransaction; _parser.parseBOOL(fastDepositTransaction);
	AtfValidator::validateInt(_descr, "fastDepositTransaction", fastDepositTransaction, _checker, __FILE__, __LINE__);
	bool saveInfoForFastDeposit; _parser.parseBOOL(saveInfoForFastDeposit);
	AtfValidator::validateInt(_descr, "saveInfoForFastDeposit", saveInfoForFastDeposit, _checker, __FILE__, __LINE__);
	bool ignoreRepeatedDeclines; _parser.parseBOOL(ignoreRepeatedDeclines);
	AtfValidator::validateInt(_descr, "ignoreRepeatedDeclines", ignoreRepeatedDeclines, _checker, __FILE__, __LINE__);
	UINT32 cardInfoId; _parser.parseUINT32(cardInfoId);
	AtfValidator::validateInt(_descr, "cardInfoId", cardInfoId, _checker, __FILE__, __LINE__);
	UINT32 awardId; _parser.parseUINT32(awardId);
	AtfValidator::validateInt(_descr, "awardId", awardId, _checker, __FILE__, __LINE__);
	UINT32 clientDepositFlags; _parser.parseUINT32(clientDepositFlags);
	AtfValidator::validateIntMax(_descr, "clientDepositFlags", clientDepositFlags, ((((UINT32)eClientDepositFlags_Last)<<1)-1), _checker, __FILE__, __LINE__);
	if (paySystemByte == cardTypePayLucky || paySystemByte == cardTypeSightline || paySystemByte == cardTypeSightlineNR)
	{
		if(_parser.parseEnded()) return;
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (paySystemByte == cardTypeGamersCard)
	{
		if(_parser.parseEnded()) return;
		validateAnonymousMsgBody1(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else
	{
		if(_parser.parseEnded()) return;
		validateAnonymousMsgBody2(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	if(_parser.parseEnded()) return;
	const BYTE* encryptedCardNumAndCvv; size_t szEncryptedCardNumAndCvv; _parser._parseVarBlock(encryptedCardNumAndCvv, szEncryptedCardNumAndCvv);  /*encryptedCardNumAndCvv*/
	AtfValidator::validateIntMax(_descr, "encryptedCardNumAndCvv", szEncryptedCardNumAndCvv, 4000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PString _descbuf;
	PaymentSpecificDataVec::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("paymentSpecificDataVec"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(isLoadAmountProvided);
	_parser0.parseINT32(loadAmount);
	_parser0.parseStringP(geoIpInfo);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	bool isLoadAmountProvided; _parser0.parseBOOL(isLoadAmountProvided);
	AtfValidator::validateInt(_descr, "isLoadAmountProvided", isLoadAmountProvided, _checker, __FILE__, __LINE__);
	INT32 loadAmount; _parser0.parseINT32(loadAmount);
	AtfValidator::validateIntRange(_descr, "loadAmount", loadAmount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "geoIpInfo"); size_t szGeoIpInfo = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "geoIpInfo", szGeoIpInfo, 10000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC::parseAnonymousMsgBody1(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(depositPassword);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC::validateAnonymousMsgBody1(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "depositPassword"); size_t szDepositPassword = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "depositPassword", szDepositPassword, 10000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC::parseAnonymousMsgBody2(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC::validateAnonymousMsgBody2(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

//=================================================================
//                Protocol_MSG_CASHIER_CASHIN_CC_CONFIRM
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_CONFIRM::Protocol_MSG_CASHIER_CASHIN_CC_CONFIRM()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_CONFIRM::Protocol_MSG_CASHIER_CASHIN_CC_CONFIRM(Protocol_MSG_CASHIER_CASHIN_CC_CONFIRM&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, transId(std::move(_o.transId))
	, empty(std::move(_o.empty))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_CONFIRM& CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_CONFIRM::operator=(Protocol_MSG_CASHIER_CASHIN_CC_CONFIRM&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		transId = std::move(_o.transId);
		empty = std::move(_o.empty);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_CONFIRM::clear()
{
	errCode = 0;
	errDescr.clear();
	transId = 0;
	empty.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_CONFIRM::equals(const Protocol_MSG_CASHIER_CASHIN_CC_CONFIRM& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		transId == _o.transId &&
		empty.equals(_o.empty);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_CONFIRM::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CASHIN_CC_CONFIRM).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("transId=");
		_buf.appendUint(transId);
		_buf.append(',');
		_buf.append("empty=");
		_buf.append(empty);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_CONFIRM::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(transId);
		_msg.composeString(empty);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_CONFIRM::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(transId);
		_parser.parseStringP(empty);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_CONFIRM::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CASHIN_CC_CONFIRM";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 transId; _parser.parseUINT32(transId);
		AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "empty"); size_t szEmpty = strlen(_dummy);
		AtfValidator::validateInt(_descr, "empty", szEmpty, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashinResultInfo
//=================================================================

CashierServer::cli::CashinResultInfo::CashinResultInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::CashinResultInfo::CashinResultInfo(CashinResultInfo&& _o)
	: type(std::move(_o.type))
	, action(std::move(_o.action))
	, amount(std::move(_o.amount))
	, reference(std::move(_o.reference))
	, systemFee(std::move(_o.systemFee))
{
}

CashierServer::cli::CashinResultInfo& CashierServer::cli::CashinResultInfo::operator=(CashinResultInfo&& _o)
{
	if(this != &_o)
	{
		type = std::move(_o.type);
		action = std::move(_o.action);
		amount = std::move(_o.amount);
		reference = std::move(_o.reference);
		systemFee = std::move(_o.systemFee);
	}
	return *this;
}

#endif

void CashierServer::cli::CashinResultInfo::clear()
{
	type = 0;
	action = 0;
	amount = 0;
	reference.clear();
	systemFee = 0;
}

bool CashierServer::cli::CashinResultInfo::equals(const CashinResultInfo& _o) const
{
	return type == _o.type &&
		action == _o.action &&
		amount == _o.amount &&
		reference.equals(_o.reference) &&
		systemFee == _o.systemFee;
}

const char *CashierServer::cli::CashinResultInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("type=");
	_buf.appendUint(type);
	_buf.append(',');
	_buf.append("action=");
	_buf.appendUint(action);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendInt(amount);
	_buf.append(',');
	_buf.append("reference=");
	_buf.append(reference);
	_buf.append(',');
	_buf.append("systemFee=");
	_buf.appendInt(systemFee);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashinResultInfo::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(type);
	_msg.composeBYTE(action);
	_msg.composeINT32(amount);
	_msg.composeString(reference);
	_msg.composeINT32(systemFee);
}

void CashierServer::cli::CashinResultInfo::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(type);
	_parser.parseBYTE(action);
	_parser.parseINT32(amount);
	_parser.parseStringP(reference);
	_parser.parseINT32(systemFee);
}

/*static*/ void CashierServer::cli::CashinResultInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	BYTE type; _parser.parseBYTE(type);
	AtfValidator::validateInt(_descr, "type", type, _checker, __FILE__, __LINE__);
	BYTE action; _parser.parseBYTE(action);
	AtfValidator::validateInt(_descr, "action", action, _checker, __FILE__, __LINE__);
	INT32 amount; _parser.parseINT32(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "reference"); size_t szReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "reference", szReference, _checker, __FILE__, __LINE__);
	INT32 systemFee; _parser.parseINT32(systemFee);
	AtfValidator::validateInt(_descr, "systemFee", systemFee, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_CASHIER_CASHIN_CC_COMPLETE
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_COMPLETE::Protocol_MSG_CASHIER_CASHIN_CC_COMPLETE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_COMPLETE::Protocol_MSG_CASHIER_CASHIN_CC_COMPLETE(Protocol_MSG_CASHIER_CASHIN_CC_COMPLETE&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, cardTypeByte(std::move(_o.cardTypeByte))
	, transId(std::move(_o.transId))
	, dadEligible(std::move(_o.dadEligible))
	, errDescrForClient(std::move(_o.errDescrForClient))
	, balanceCurrency(std::move(_o.balanceCurrency))
	, transStatusForClient(std::move(_o.transStatusForClient))
	, totalAmount(std::move(_o.totalAmount))
	, resultInfos(std::move(_o.resultInfos))
	, rejectExplanationCode(std::move(_o.rejectExplanationCode))
	, urlForUser(std::move(_o.urlForUser))
	, errorTemplateText(std::move(_o.errorTemplateText))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_COMPLETE& CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_COMPLETE::operator=(Protocol_MSG_CASHIER_CASHIN_CC_COMPLETE&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		cardTypeByte = std::move(_o.cardTypeByte);
		transId = std::move(_o.transId);
		dadEligible = std::move(_o.dadEligible);
		errDescrForClient = std::move(_o.errDescrForClient);
		balanceCurrency = std::move(_o.balanceCurrency);
		transStatusForClient = std::move(_o.transStatusForClient);
		totalAmount = std::move(_o.totalAmount);
		resultInfos = std::move(_o.resultInfos);
		rejectExplanationCode = std::move(_o.rejectExplanationCode);
		urlForUser = std::move(_o.urlForUser);
		errorTemplateText = std::move(_o.errorTemplateText);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_COMPLETE::clear()
{
	errCode = 0;
	errDescr.clear();
	cardTypeByte = 0;
	transId = 0;
	dadEligible = false;
	errDescrForClient.clear();
	balanceCurrency.clear();
	transStatusForClient = 0;
	totalAmount = 0;
	resultInfos.clear();
	rejectExplanationCode = 0;
	urlForUser.clear();
	errorTemplateText.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_COMPLETE::equals(const Protocol_MSG_CASHIER_CASHIN_CC_COMPLETE& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		cardTypeByte == _o.cardTypeByte &&
		transId == _o.transId &&
		dadEligible == _o.dadEligible &&
		errDescrForClient.equals(_o.errDescrForClient) &&
		balanceCurrency.equals(_o.balanceCurrency) &&
		transStatusForClient == _o.transStatusForClient &&
		totalAmount == _o.totalAmount &&
		resultInfos.equals(_o.resultInfos) &&
		rejectExplanationCode == _o.rejectExplanationCode &&
		urlForUser.equals(_o.urlForUser) &&
		errorTemplateText.equals(_o.errorTemplateText);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_COMPLETE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CASHIN_CC_COMPLETE).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
		_buf.append(',');
		_buf.append("cardTypeByte=");
		_buf.appendUint(cardTypeByte);
		_buf.append(',');
		_buf.append("transId=");
		_buf.appendUint(transId);
		_buf.append(',');
		_buf.append("dadEligible=");
		_buf.appendUint(dadEligible);
		_buf.append(',');
		_buf.append("errDescrForClient=");
		_buf.append(errDescrForClient);
		_buf.append(',');
		_buf.append("balanceCurrency=");
		_buf.append(balanceCurrency);
	}
	else
	{
		_buf.append(',');
		_buf.append("transId=");
		_buf.appendUint(transId);
		_buf.append(',');
		_buf.append("transStatusForClient=");
		_buf.appendUint(transStatusForClient);
		_buf.append(',');
		_buf.append("totalAmount=");
		_buf.appendInt(totalAmount);
		_buf.append(',');
		_buf.append("resultInfos=");
		resultInfos.toTraceString(_buf);
		_buf.append(',');
		_buf.append("rejectExplanationCode=");
		_buf.appendUint(rejectExplanationCode);
		_buf.append(',');
		_buf.append("urlForUser=");
		_buf.append(urlForUser);
		_buf.append(',');
		_buf.append("cardTypeByte=");
		_buf.appendUint(cardTypeByte);
		_buf.append(',');
		_buf.append("dadEligible=");
		_buf.appendUint(dadEligible);
		_buf.append(',');
		_buf.append("errorTemplateText=");
		_buf.append(errorTemplateText);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_COMPLETE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
		_msg.composeBYTE(cardTypeByte);
		_msg.composeUINT32(transId);
		_msg.composeBOOL(dadEligible);
		_msg.composeString(errDescrForClient);
		_msg.composeString(balanceCurrency);
	}
	else
	{
		_msg.composeUINT32(transId);
		_msg.composeBYTE(transStatusForClient);
		_msg.composeINT32(totalAmount);
		resultInfos.composeMsg(_msg);
		_msg.composeUINT32(rejectExplanationCode);
		_msg.composeString(urlForUser);
		_msg.composeBYTE(cardTypeByte);
		_msg.composeBOOL(dadEligible);
		_msg.composeString(errorTemplateText);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_COMPLETE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
		if(_parser.parseEnded()) return;
		_parser.parseBYTE(cardTypeByte);
		_parser.parseUINT32(transId);
		_parser.parseBOOL(dadEligible);
		_parser.parseStringP(errDescrForClient);
		_parser.parseStringP(balanceCurrency);
	}
	else
	{
		_parser.parseUINT32(transId);
		_parser.parseBYTE(transStatusForClient);
		_parser.parseINT32(totalAmount);
		resultInfos.parseMsg(_parser);
		_parser.parseUINT32(rejectExplanationCode);
		_parser.parseStringP(urlForUser);
		_parser.parseBYTE(cardTypeByte);
		_parser.parseBOOL(dadEligible);
		_parser.parseStringP(errorTemplateText);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_COMPLETE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CASHIN_CC_COMPLETE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		BYTE cardTypeByte; _parser.parseBYTE(cardTypeByte);
		AtfValidator::validateInt(_descr, "cardTypeByte", cardTypeByte, _checker, __FILE__, __LINE__);
		UINT32 transId; _parser.parseUINT32(transId);
		AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
		bool dadEligible; _parser.parseBOOL(dadEligible);
		AtfValidator::validateInt(_descr, "dadEligible", dadEligible, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "errDescrForClient"); size_t szErrDescrForClient = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescrForClient", szErrDescrForClient, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "balanceCurrency"); size_t szBalanceCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "balanceCurrency", szBalanceCurrency, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 transId; _parser.parseUINT32(transId);
		AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
		BYTE transStatusForClient; _parser.parseBYTE(transStatusForClient);
		AtfValidator::validateInt(_descr, "transStatusForClient", transStatusForClient, _checker, __FILE__, __LINE__);
		INT32 totalAmount; _parser.parseINT32(totalAmount);
		AtfValidator::validateInt(_descr, "totalAmount", totalAmount, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szResultInfos = ThinAtf::LAtfVector< CashinResultInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("resultInfos"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "resultInfos", szResultInfos, _checker, __FILE__, __LINE__);
		UINT32 rejectExplanationCode; _parser.parseUINT32(rejectExplanationCode);
		AtfValidator::validateInt(_descr, "rejectExplanationCode", rejectExplanationCode, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "urlForUser"); size_t szUrlForUser = strlen(_dummy);
		AtfValidator::validateInt(_descr, "urlForUser", szUrlForUser, _checker, __FILE__, __LINE__);
		BYTE cardTypeByte; _parser.parseBYTE(cardTypeByte);
		AtfValidator::validateInt(_descr, "cardTypeByte", cardTypeByte, _checker, __FILE__, __LINE__);
		bool dadEligible; _parser.parseBOOL(dadEligible);
		AtfValidator::validateInt(_descr, "dadEligible", dadEligible, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "errorTemplateText"); size_t szErrorTemplateText = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errorTemplateText", szErrorTemplateText, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CASHOUT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT::Protocol_MSG_CASHIER_CASHOUT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT::Protocol_MSG_CASHIER_CASHOUT(Protocol_MSG_CASHIER_CASHOUT&& _o)
	: userId(std::move(_o.userId))
	, amount(std::move(_o.amount))
	, paySystem(std::move(_o.paySystem))
	, bonusAware(std::move(_o.bonusAware))
	, userPhone(std::move(_o.userPhone))
	, currency(std::move(_o.currency))
	, convRate(std::move(_o.convRate))
	, balanceCurrency(std::move(_o.balanceCurrency))
	, reference(std::move(_o.reference))
	, clientBalance_ignored(std::move(_o.clientBalance_ignored))
	, convRate64(std::move(_o.convRate64))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT& CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT::operator=(Protocol_MSG_CASHIER_CASHOUT&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		amount = std::move(_o.amount);
		paySystem = std::move(_o.paySystem);
		bonusAware = std::move(_o.bonusAware);
		userPhone = std::move(_o.userPhone);
		currency = std::move(_o.currency);
		convRate = std::move(_o.convRate);
		balanceCurrency = std::move(_o.balanceCurrency);
		reference = std::move(_o.reference);
		clientBalance_ignored = std::move(_o.clientBalance_ignored);
		convRate64 = std::move(_o.convRate64);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT::clear()
{
	userId.clear();
	amount = 0;
	paySystem = 0;
	bonusAware = 0;
	userPhone.clear();
	currency.clear();
	convRate = 0;
	balanceCurrency.clear();
	reference.clear();
	clientBalance_ignored = 0;
	convRate64 = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT::equals(const Protocol_MSG_CASHIER_CASHOUT& _o) const
{
	return userId.equals(_o.userId) &&
		amount == _o.amount &&
		paySystem == _o.paySystem &&
		bonusAware == _o.bonusAware &&
		userPhone.equals(_o.userPhone) &&
		currency.equals(_o.currency) &&
		convRate == _o.convRate &&
		balanceCurrency.equals(_o.balanceCurrency) &&
		reference.equals(_o.reference) &&
		clientBalance_ignored == _o.clientBalance_ignored &&
		convRate64 == _o.convRate64;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CASHOUT).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendInt(amount);
	_buf.append(',');
	_buf.append("paySystem=");
	_buf.appendUint(paySystem);
	_buf.append(',');
	_buf.append("bonusAware=");
	_buf.appendUint(bonusAware);
	_buf.append(',');
	_buf.append("userPhone=");
	_buf.append(userPhone);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("convRate=");
	_buf.appendInt(convRate);
	_buf.append(',');
	_buf.append("balanceCurrency=");
	_buf.append(balanceCurrency);
	_buf.append(',');
	_buf.append("reference=");
	_buf.append(reference);
	_buf.append(',');
	_buf.append("clientBalance_ignored=");
	_buf.appendInt(clientBalance_ignored);
	_buf.append(',');
	_buf.append("convRate64=");
	_buf.appendInt64(convRate64);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeINT32(amount);
	_msg.composeBYTE(paySystem);
	_msg.composeBYTE(bonusAware);
	_msg.composeString(userPhone);
	_msg.composeString(currency);
	_msg.composeINT32(convRate);
	_msg.composeString(balanceCurrency);
	_msg.composeString(reference);
	_msg.composeINT32(clientBalance_ignored);
	_msg.composeINT64(convRate64);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseINT32(amount);
	_parser.parseBYTE(paySystem);
	_parser.parseBYTE(bonusAware);
	_parser.parseStringP(userPhone);
	_parser.parseStringP(currency);
	_parser.parseINT32(convRate);
	_parser.parseStringP(balanceCurrency);
	_parser.parseStringP(reference);
	_parser.parseINT32(clientBalance_ignored);
	if(_parser.parseEnded()) return;
	_parser.parseINT64(convRate64);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CASHOUT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	INT32 amount; _parser.parseINT32(amount);
	AtfValidator::validateIntRange(_descr, "amount", amount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	BYTE paySystem; _parser.parseBYTE(paySystem);
	AtfValidator::validateIntRange(_descr, "paySystem", paySystem, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	BYTE bonusAware; _parser.parseBYTE(bonusAware);
	AtfValidator::validateIntMax(_descr, "bonusAware", bonusAware, 1, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userPhone"); size_t szUserPhone = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userPhone", szUserPhone, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	INT32 convRate; _parser.parseINT32(convRate);
	AtfValidator::validateIntRange(_descr, "convRate", convRate, 0, std::numeric_limits<INT32>::max(), _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "balanceCurrency"); size_t szBalanceCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "balanceCurrency", szBalanceCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "reference"); size_t szReference = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "reference", szReference, 1000, _checker, __FILE__, __LINE__);
	INT32 clientBalance_ignored; _parser.parseINT32(clientBalance_ignored);
	AtfValidator::validateInt(_descr, "clientBalance_ignored", clientBalance_ignored, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	INT64 convRate64; _parser.parseINT64(convRate64);
	AtfValidator::validateIntRange(_descr, "convRate64", convRate64, 0, 1000000000000LL, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    ResultInfos
//=================================================================

CashierServer::cli::ResultInfos::ResultInfos()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::ResultInfos::ResultInfos(ResultInfos&& _o)
	: type(std::move(_o.type))
	, action(std::move(_o.action))
	, amount(std::move(_o.amount))
	, reference(std::move(_o.reference))
	, systemFee(std::move(_o.systemFee))
{
}

CashierServer::cli::ResultInfos& CashierServer::cli::ResultInfos::operator=(ResultInfos&& _o)
{
	if(this != &_o)
	{
		type = std::move(_o.type);
		action = std::move(_o.action);
		amount = std::move(_o.amount);
		reference = std::move(_o.reference);
		systemFee = std::move(_o.systemFee);
	}
	return *this;
}

#endif

void CashierServer::cli::ResultInfos::clear()
{
	type = 0;
	action = 0;
	amount = 0;
	reference.clear();
	systemFee = 0;
}

bool CashierServer::cli::ResultInfos::equals(const ResultInfos& _o) const
{
	return type == _o.type &&
		action == _o.action &&
		amount == _o.amount &&
		reference.equals(_o.reference) &&
		systemFee == _o.systemFee;
}

const char *CashierServer::cli::ResultInfos::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("type=");
	_buf.appendUint(type);
	_buf.append(',');
	_buf.append("action=");
	_buf.appendUint(action);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendInt(amount);
	_buf.append(',');
	_buf.append("reference=");
	_buf.append(reference);
	_buf.append(',');
	_buf.append("systemFee=");
	_buf.appendInt(systemFee);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::ResultInfos::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(type);
	_msg.composeBYTE(action);
	_msg.composeINT32(amount);
	_msg.composeString(reference);
	_msg.composeINT32(systemFee);
}

void CashierServer::cli::ResultInfos::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(type);
	_parser.parseBYTE(action);
	_parser.parseINT32(amount);
	_parser.parseStringP(reference);
	_parser.parseINT32(systemFee);
}

/*static*/ void CashierServer::cli::ResultInfos::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	BYTE type; _parser.parseBYTE(type);
	AtfValidator::validateInt(_descr, "type", type, _checker, __FILE__, __LINE__);
	BYTE action; _parser.parseBYTE(action);
	AtfValidator::validateInt(_descr, "action", action, _checker, __FILE__, __LINE__);
	INT32 amount; _parser.parseINT32(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "reference"); size_t szReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "reference", szReference, _checker, __FILE__, __LINE__);
	INT32 systemFee; _parser.parseINT32(systemFee);
	AtfValidator::validateInt(_descr, "systemFee", systemFee, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_CASHIER_CASHOUT_COMPLETE
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT_COMPLETE::Protocol_MSG_CASHIER_CASHOUT_COMPLETE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT_COMPLETE::Protocol_MSG_CASHIER_CASHOUT_COMPLETE(Protocol_MSG_CASHIER_CASHOUT_COMPLETE&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, transId(std::move(_o.transId))
	, statusByte(std::move(_o.statusByte))
	, returnedAmount(std::move(_o.returnedAmount))
	, resultInfos(std::move(_o.resultInfos))
	, parentPaySystem(std::move(_o.parentPaySystem))
	, empty(std::move(_o.empty))
	, balanceCurrency(std::move(_o.balanceCurrency))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT_COMPLETE& CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT_COMPLETE::operator=(Protocol_MSG_CASHIER_CASHOUT_COMPLETE&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		transId = std::move(_o.transId);
		statusByte = std::move(_o.statusByte);
		returnedAmount = std::move(_o.returnedAmount);
		resultInfos = std::move(_o.resultInfos);
		parentPaySystem = std::move(_o.parentPaySystem);
		empty = std::move(_o.empty);
		balanceCurrency = std::move(_o.balanceCurrency);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT_COMPLETE::clear()
{
	errCode = 0;
	errDescr.clear();
	transId = 0;
	statusByte = 0;
	returnedAmount = 0;
	resultInfos.clear();
	parentPaySystem = 0;
	empty.clear();
	balanceCurrency.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT_COMPLETE::equals(const Protocol_MSG_CASHIER_CASHOUT_COMPLETE& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		transId == _o.transId &&
		statusByte == _o.statusByte &&
		returnedAmount == _o.returnedAmount &&
		resultInfos.equals(_o.resultInfos) &&
		parentPaySystem == _o.parentPaySystem &&
		empty.equals(_o.empty) &&
		balanceCurrency.equals(_o.balanceCurrency);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT_COMPLETE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CASHOUT_COMPLETE).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("transId=");
		_buf.appendUint(transId);
		_buf.append(',');
		_buf.append("statusByte=");
		_buf.appendUint(statusByte);
		_buf.append(',');
		_buf.append("returnedAmount=");
		_buf.appendInt(returnedAmount);
		_buf.append(',');
		_buf.append("resultInfos=");
		resultInfos.toTraceString(_buf);
		_buf.append(',');
		_buf.append("parentPaySystem=");
		_buf.appendUint(parentPaySystem);
		_buf.append(',');
		_buf.append("empty=");
		_buf.append(empty);
		_buf.append(',');
		_buf.append("balanceCurrency=");
		_buf.append(balanceCurrency);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT_COMPLETE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(transId);
		_msg.composeBYTE(statusByte);
		_msg.composeINT32(returnedAmount);
		resultInfos.composeMsg(_msg);
		_msg.composeBYTE(parentPaySystem);
		_msg.composeString(empty);
		_msg.composeString(balanceCurrency);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT_COMPLETE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(transId);
		_parser.parseBYTE(statusByte);
		_parser.parseINT32(returnedAmount);
		resultInfos.parseMsg(_parser);
		_parser.parseBYTE(parentPaySystem);
		_parser.parseStringP(empty);
		_parser.parseStringP(balanceCurrency);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CASHOUT_COMPLETE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CASHOUT_COMPLETE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 transId; _parser.parseUINT32(transId);
		AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
		BYTE statusByte; _parser.parseBYTE(statusByte);
		AtfValidator::validateInt(_descr, "statusByte", statusByte, _checker, __FILE__, __LINE__);
		INT32 returnedAmount; _parser.parseINT32(returnedAmount);
		AtfValidator::validateInt(_descr, "returnedAmount", returnedAmount, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szResultInfos = ThinAtf::LAtfVector< ResultInfos, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("resultInfos"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "resultInfos", szResultInfos, _checker, __FILE__, __LINE__);
		BYTE parentPaySystem; _parser.parseBYTE(parentPaySystem);
		AtfValidator::validateInt(_descr, "parentPaySystem", parentPaySystem, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "empty"); size_t szEmpty = strlen(_dummy);
		AtfValidator::validateInt(_descr, "empty", szEmpty, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "balanceCurrency"); size_t szBalanceCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "balanceCurrency", szBalanceCurrency, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_HISTORY2
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2::Protocol_MSG_CASHIER_HISTORY2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2::Protocol_MSG_CASHIER_HISTORY2(Protocol_MSG_CASHIER_HISTORY2&& _o)
	: userId(std::move(_o.userId))
	, nLastDays(std::move(_o.nLastDays))
	, requestFlags(std::move(_o.requestFlags))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2& CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2::operator=(Protocol_MSG_CASHIER_HISTORY2&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		nLastDays = std::move(_o.nLastDays);
		requestFlags = std::move(_o.requestFlags);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2::clear()
{
	userId.clear();
	nLastDays = 0;
	requestFlags = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2::equals(const Protocol_MSG_CASHIER_HISTORY2& _o) const
{
	return userId.equals(_o.userId) &&
		nLastDays == _o.nLastDays &&
		requestFlags == _o.requestFlags;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_HISTORY2).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("nLastDays=");
	_buf.appendUint(nLastDays);
	_buf.append(',');
	_buf.append("requestFlags=");
	_buf.appendUint(requestFlags);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeUINT32(nLastDays);
	_msg.composeUINT32(requestFlags);
}

void CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseUINT32(nLastDays);
	_parser.parseUINT32(requestFlags);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_HISTORY2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT32 nLastDays; _parser.parseUINT32(nLastDays);
	AtfValidator::validateIntMax(_descr, "nLastDays", nLastDays, 400, _checker, __FILE__, __LINE__);
	UINT32 requestFlags; _parser.parseUINT32(requestFlags);
	AtfValidator::validateIntMax(_descr, "requestFlags", requestFlags, 1, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashTransactionWithReferenceBody
//=================================================================

CashierServer::cli::CashTransactionWithReferenceBody::CashTransactionWithReferenceBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::CashTransactionWithReferenceBody::CashTransactionWithReferenceBody(CashTransactionWithReferenceBody&& _o)
	: typeDescr(std::move(_o.typeDescr))
	, transAcctAmount(std::move(_o.transAcctAmount))
	, zero(std::move(_o.zero))
	, cardMaskedOrReference(std::move(_o.cardMaskedOrReference))
	, transId(std::move(_o.transId))
	, normalizedBalanceCurrency(std::move(_o.normalizedBalanceCurrency))
	, descriptor(std::move(_o.descriptor))
	, transConverted(std::move(_o.transConverted))
	, transCurrency(std::move(_o.transCurrency))
	, cardTypeByte(std::move(_o.cardTypeByte))
	, referenceHint(std::move(_o.referenceHint))
	, historyFlags(std::move(_o.historyFlags))
{
}

CashierServer::cli::CashTransactionWithReferenceBody& CashierServer::cli::CashTransactionWithReferenceBody::operator=(CashTransactionWithReferenceBody&& _o)
{
	if(this != &_o)
	{
		typeDescr = std::move(_o.typeDescr);
		transAcctAmount = std::move(_o.transAcctAmount);
		zero = std::move(_o.zero);
		cardMaskedOrReference = std::move(_o.cardMaskedOrReference);
		transId = std::move(_o.transId);
		normalizedBalanceCurrency = std::move(_o.normalizedBalanceCurrency);
		descriptor = std::move(_o.descriptor);
		transConverted = std::move(_o.transConverted);
		transCurrency = std::move(_o.transCurrency);
		cardTypeByte = std::move(_o.cardTypeByte);
		referenceHint = std::move(_o.referenceHint);
		historyFlags = std::move(_o.historyFlags);
	}
	return *this;
}

#endif

void CashierServer::cli::CashTransactionWithReferenceBody::clear()
{
	typeDescr.clear();
	transAcctAmount = 0;
	zero = 0;
	cardMaskedOrReference.clear();
	transId = 0;
	normalizedBalanceCurrency.clear();
	descriptor.clear();
	transConverted = 0;
	transCurrency.clear();
	cardTypeByte = 0;
	referenceHint.clear();
	historyFlags = 0;
}

bool CashierServer::cli::CashTransactionWithReferenceBody::equals(const CashTransactionWithReferenceBody& _o) const
{
	return typeDescr.equals(_o.typeDescr) &&
		transAcctAmount == _o.transAcctAmount &&
		zero == _o.zero &&
		cardMaskedOrReference.equals(_o.cardMaskedOrReference) &&
		transId == _o.transId &&
		normalizedBalanceCurrency.equals(_o.normalizedBalanceCurrency) &&
		descriptor.equals(_o.descriptor) &&
		transConverted == _o.transConverted &&
		transCurrency.equals(_o.transCurrency) &&
		cardTypeByte == _o.cardTypeByte &&
		referenceHint.equals(_o.referenceHint) &&
		historyFlags == _o.historyFlags;
}

const char *CashierServer::cli::CashTransactionWithReferenceBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("typeDescr=");
	_buf.append(typeDescr);
	_buf.append(',');
	_buf.append("transAcctAmount=");
	_buf.appendInt(transAcctAmount);
	_buf.append(',');
	_buf.append("zero=");
	_buf.appendUint(zero);
	_buf.append(',');
	_buf.append("cardMaskedOrReference=");
	_buf.append(cardMaskedOrReference);
	_buf.append(',');
	_buf.append("transId=");
	_buf.appendUint(transId);
	_buf.append(',');
	_buf.append("normalizedBalanceCurrency=");
	_buf.append(normalizedBalanceCurrency);
	_buf.append(',');
	_buf.append("descriptor=");
	_buf.append(descriptor);
	_buf.append(',');
	_buf.append("transConverted=");
	_buf.appendInt(transConverted);
	_buf.append(',');
	_buf.append("transCurrency=");
	_buf.append(transCurrency);
	_buf.append(',');
	_buf.append("cardTypeByte=");
	_buf.appendUint(cardTypeByte);
	_buf.append(',');
	_buf.append("referenceHint=");
	_buf.append(referenceHint);
	_buf.append(',');
	_buf.append("historyFlags=");
	_buf.appendUint(historyFlags);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashTransactionWithReferenceBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CashTransactionWithReferenceBody())) // not empty
	{
		_body.composeString(typeDescr);
		_body.composeINT32(transAcctAmount);
		_body.composeUINT32(zero);
		_body.composeString(cardMaskedOrReference);
		_body.composeUINT32(transId);
		_body.composeString(normalizedBalanceCurrency);
		_body.composeString(descriptor);
		_body.composeINT32(transConverted);
		_body.composeString(transCurrency);
		_body.composeBYTE(cardTypeByte);
		_body.composeString(referenceHint);
		_body.composeUINT32(historyFlags);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashTransactionWithReferenceBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(typeDescr);
	_parser0.parseINT32(transAcctAmount);
	_parser0.parseUINT32(zero);
	_parser0.parseStringP(cardMaskedOrReference);
	_parser0.parseUINT32(transId);
	_parser0.parseStringP(normalizedBalanceCurrency);
	_parser0.parseStringP(descriptor);
	_parser0.parseINT32(transConverted);
	_parser0.parseStringP(transCurrency);
	_parser0.parseBYTE(cardTypeByte);
	_parser0.parseStringP(referenceHint);
	_parser0.parseUINT32(historyFlags);
}

/*static*/ void CashierServer::cli::CashTransactionWithReferenceBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "typeDescr"); size_t szTypeDescr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "typeDescr", szTypeDescr, _checker, __FILE__, __LINE__);
	INT32 transAcctAmount; _parser0.parseINT32(transAcctAmount);
	AtfValidator::validateInt(_descr, "transAcctAmount", transAcctAmount, _checker, __FILE__, __LINE__);
	UINT32 zero; _parser0.parseUINT32(zero);
	AtfValidator::validateInt(_descr, "zero", zero, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "cardMaskedOrReference"); size_t szCardMaskedOrReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "cardMaskedOrReference", szCardMaskedOrReference, _checker, __FILE__, __LINE__);
	UINT32 transId; _parser0.parseUINT32(transId);
	AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "normalizedBalanceCurrency"); size_t szNormalizedBalanceCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "normalizedBalanceCurrency", szNormalizedBalanceCurrency, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "descriptor"); size_t szDescriptor = strlen(_dummy);
	AtfValidator::validateInt(_descr, "descriptor", szDescriptor, _checker, __FILE__, __LINE__);
	INT32 transConverted; _parser0.parseINT32(transConverted);
	AtfValidator::validateInt(_descr, "transConverted", transConverted, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "transCurrency"); size_t szTransCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "transCurrency", szTransCurrency, _checker, __FILE__, __LINE__);
	BYTE cardTypeByte; _parser0.parseBYTE(cardTypeByte);
	AtfValidator::validateInt(_descr, "cardTypeByte", cardTypeByte, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "referenceHint"); size_t szReferenceHint = strlen(_dummy);
	AtfValidator::validateInt(_descr, "referenceHint", szReferenceHint, _checker, __FILE__, __LINE__);
	UINT32 historyFlags; _parser0.parseUINT32(historyFlags);
	AtfValidator::validateInt(_descr, "historyFlags", historyFlags, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_HISTORY2_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2_REPLY::Protocol_MSG_CASHIER_HISTORY2_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2_REPLY::Protocol_MSG_CASHIER_HISTORY2_REPLY(Protocol_MSG_CASHIER_HISTORY2_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, transactions(std::move(_o.transactions))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2_REPLY::operator=(Protocol_MSG_CASHIER_HISTORY2_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		transactions = std::move(_o.transactions);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	transactions.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2_REPLY::equals(const Protocol_MSG_CASHIER_HISTORY2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		transactions.equals(_o.transactions);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_HISTORY2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("transactions=");
		transactions.toTraceString(_buf);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		transactions.composeMsg(_msg);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		transactions.parseMsg(_parser);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_HISTORY2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_HISTORY2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szTransactions = ThinAtf::LAtfVector< CashTransactionWithReferenceBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("transactions"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "transactions", szTransactions, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_USER_BONUSHIST_NEW
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW(Protocol_MSG_CASHIER_USER_BONUSHIST_NEW&& _o)
	: userId(std::move(_o.userId))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW& CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW::operator=(Protocol_MSG_CASHIER_USER_BONUSHIST_NEW&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW::clear()
{
	userId.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW::equals(const Protocol_MSG_CASHIER_USER_BONUSHIST_NEW& _o) const
{
	return userId.equals(_o.userId);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_USER_BONUSHIST_NEW).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
}

void CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_USER_BONUSHIST_NEW";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    UserBonusBody
//=================================================================

CashierServer::cli::UserBonusBody::UserBonusBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::UserBonusBody::UserBonusBody(UserBonusBody&& _o)
	: bonusName(std::move(_o.bonusName))
	, when(std::move(_o.when))
	, createdTransId(std::move(_o.createdTransId))
	, bonusAmount(std::move(_o.bonusAmount))
	, fppToCollect(std::move(_o.fppToCollect))
	, fppCollected(std::move(_o.fppCollected))
	, credited(std::move(_o.credited))
	, creditTransId(std::move(_o.creditTransId))
	, expDate(std::move(_o.expDate))
	, currency(std::move(_o.currency))
	, bonusInTickets(std::move(_o.bonusInTickets))
	, creditedTickets(std::move(_o.creditedTickets))
	, bonusClearedFlags(std::move(_o.bonusClearedFlags))
{
}

CashierServer::cli::UserBonusBody& CashierServer::cli::UserBonusBody::operator=(UserBonusBody&& _o)
{
	if(this != &_o)
	{
		bonusName = std::move(_o.bonusName);
		when = std::move(_o.when);
		createdTransId = std::move(_o.createdTransId);
		bonusAmount = std::move(_o.bonusAmount);
		fppToCollect = std::move(_o.fppToCollect);
		fppCollected = std::move(_o.fppCollected);
		credited = std::move(_o.credited);
		creditTransId = std::move(_o.creditTransId);
		expDate = std::move(_o.expDate);
		currency = std::move(_o.currency);
		bonusInTickets = std::move(_o.bonusInTickets);
		creditedTickets = std::move(_o.creditedTickets);
		bonusClearedFlags = std::move(_o.bonusClearedFlags);
	}
	return *this;
}

#endif

void CashierServer::cli::UserBonusBody::clear()
{
	bonusName.clear();
	when.setNull();
	createdTransId = 0;
	bonusAmount = 0;
	fppToCollect = 0;
	fppCollected = 0;
	credited = 0;
	creditTransId = 0;
	expDate.setNull();
	currency.clear();
	bonusInTickets = 0;
	creditedTickets = 0;
	bonusClearedFlags = 0;
}

bool CashierServer::cli::UserBonusBody::equals(const UserBonusBody& _o) const
{
	return bonusName.equals(_o.bonusName) &&
		when.equals(_o.when) &&
		createdTransId == _o.createdTransId &&
		bonusAmount == _o.bonusAmount &&
		fppToCollect == _o.fppToCollect &&
		fppCollected == _o.fppCollected &&
		credited == _o.credited &&
		creditTransId == _o.creditTransId &&
		expDate.equals(_o.expDate) &&
		currency.equals(_o.currency) &&
		bonusInTickets == _o.bonusInTickets &&
		creditedTickets == _o.creditedTickets &&
		bonusClearedFlags == _o.bonusClearedFlags;
}

const char *CashierServer::cli::UserBonusBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("bonusName=");
	_buf.append(bonusName);
	_buf.append(',');
	_buf.append("when=");
	ThinAtf::AtfTempl<CommSrvTime>::ToTraceString(_buf, when);
	_buf.append(',');
	_buf.append("createdTransId=");
	_buf.appendUint(createdTransId);
	_buf.append(',');
	_buf.append("bonusAmount=");
	_buf.appendInt(bonusAmount);
	_buf.append(',');
	_buf.append("fppToCollect=");
	_buf.appendInt(fppToCollect);
	_buf.append(',');
	_buf.append("fppCollected=");
	_buf.appendInt(fppCollected);
	_buf.append(',');
	_buf.append("credited=");
	_buf.appendInt(credited);
	_buf.append(',');
	_buf.append("creditTransId=");
	_buf.appendUint(creditTransId);
	_buf.append(',');
	_buf.append("expDate=");
	ThinAtf::AtfTempl<CommSrvTime>::ToTraceString(_buf, expDate);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("bonusInTickets=");
	_buf.appendInt(bonusInTickets);
	_buf.append(',');
	_buf.append("creditedTickets=");
	_buf.appendInt(creditedTickets);
	_buf.append(',');
	_buf.append("bonusClearedFlags=");
	_buf.appendUint(bonusClearedFlags);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::UserBonusBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(UserBonusBody())) // not empty
	{
		_body.composeString(bonusName);
		_body.composeSrvTime(when);
		_body.composeUINT32(createdTransId);
		_body.composeINT32(bonusAmount);
		_body.composeINT32(fppToCollect);
		_body.composeINT32(fppCollected);
		_body.composeINT32(credited);
		_body.composeUINT32(creditTransId);
		_body.composeSrvTime(expDate);
		_body.composeString(currency);
		_body.composeINT32(bonusInTickets);
		_body.composeINT32(creditedTickets);
		_body.composeUINT32(bonusClearedFlags);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::UserBonusBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(bonusName);
	_parser0.parseSrvTime(when);
	_parser0.parseUINT32(createdTransId);
	_parser0.parseINT32(bonusAmount);
	_parser0.parseINT32(fppToCollect);
	_parser0.parseINT32(fppCollected);
	_parser0.parseINT32(credited);
	_parser0.parseUINT32(creditTransId);
	_parser0.parseSrvTime(expDate);
	_parser0.parseStringP(currency);
	_parser0.parseINT32(bonusInTickets);
	_parser0.parseINT32(creditedTickets);
	_parser0.parseUINT32(bonusClearedFlags);
}

/*static*/ void CashierServer::cli::UserBonusBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "bonusName"); size_t szBonusName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bonusName", szBonusName, 1000, _checker, __FILE__, __LINE__);
	CommSrvTime when; _parser0.parseSrvTime(when);
	AtfValidator::validateSrvDateTime(_descr, "when", when, _checker, __FILE__, __LINE__);
	UINT32 createdTransId; _parser0.parseUINT32(createdTransId);
	AtfValidator::validateInt(_descr, "createdTransId", createdTransId, _checker, __FILE__, __LINE__);
	INT32 bonusAmount; _parser0.parseINT32(bonusAmount);
	AtfValidator::validateInt(_descr, "bonusAmount", bonusAmount, _checker, __FILE__, __LINE__);
	INT32 fppToCollect; _parser0.parseINT32(fppToCollect);
	AtfValidator::validateInt(_descr, "fppToCollect", fppToCollect, _checker, __FILE__, __LINE__);
	INT32 fppCollected; _parser0.parseINT32(fppCollected);
	AtfValidator::validateInt(_descr, "fppCollected", fppCollected, _checker, __FILE__, __LINE__);
	INT32 credited; _parser0.parseINT32(credited);
	AtfValidator::validateInt(_descr, "credited", credited, _checker, __FILE__, __LINE__);
	UINT32 creditTransId; _parser0.parseUINT32(creditTransId);
	AtfValidator::validateInt(_descr, "creditTransId", creditTransId, _checker, __FILE__, __LINE__);
	CommSrvTime expDate; _parser0.parseSrvTime(expDate);
	AtfValidator::validateSrvDateTime(_descr, "expDate", expDate, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT32 bonusInTickets; _parser0.parseINT32(bonusInTickets);
	AtfValidator::validateInt(_descr, "bonusInTickets", bonusInTickets, _checker, __FILE__, __LINE__);
	INT32 creditedTickets; _parser0.parseINT32(creditedTickets);
	AtfValidator::validateInt(_descr, "creditedTickets", creditedTickets, _checker, __FILE__, __LINE__);
	UINT32 bonusClearedFlags; _parser0.parseUINT32(bonusClearedFlags);
	AtfValidator::validateInt(_descr, "bonusClearedFlags", bonusClearedFlags, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_USER_BONUSHIST_NEW_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW_REPLY::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW_REPLY::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW_REPLY(Protocol_MSG_CASHIER_USER_BONUSHIST_NEW_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, bonuses(std::move(_o.bonuses))
	, bonusDescr(std::move(_o.bonusDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW_REPLY::operator=(Protocol_MSG_CASHIER_USER_BONUSHIST_NEW_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		bonuses = std::move(_o.bonuses);
		bonusDescr = std::move(_o.bonusDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	bonuses.clear();
	bonusDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW_REPLY::equals(const Protocol_MSG_CASHIER_USER_BONUSHIST_NEW_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		bonuses.equals(_o.bonuses) &&
		bonusDescr.equals(_o.bonusDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_USER_BONUSHIST_NEW_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("bonuses=");
		bonuses.toTraceString(_buf);
		_buf.append(',');
		_buf.append("bonusDescr=");
		_buf.append(bonusDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		bonuses.composeMsg(_msg);
		_msg.composeString(bonusDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		bonuses.parseMsg(_parser);
		_parser.parseStringP(bonusDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_USER_BONUSHIST_NEW_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szBonuses = ThinAtf::LAtfVector< UserBonusBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("bonuses"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "bonuses", szBonuses, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "bonusDescr"); size_t szBonusDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "bonusDescr", szBonusDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_PRE_CASHIN2
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2::Protocol_MSG_CASHIER_PRE_CASHIN2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2::Protocol_MSG_CASHIER_PRE_CASHIN2(Protocol_MSG_CASHIER_PRE_CASHIN2&& _o)
	: userId(std::move(_o.userId))
	, accountAmount(std::move(_o.accountAmount))
	, bytePaySystem(std::move(_o.bytePaySystem))
	, processorCurrency(std::move(_o.processorCurrency))
	, bonusCode(std::move(_o.bonusCode))
	, accountCurrency(std::move(_o.accountCurrency))
	, validationDigits(std::move(_o.validationDigits))
	, validationAttempts(std::move(_o.validationAttempts))
	, processorAmount(std::move(_o.processorAmount))
	, nonZeroPaysystemFeeApplies(std::move(_o.nonZeroPaysystemFeeApplies))
	, cardNum(std::move(_o.cardNum))
	, encryptedCardNum(std::move(_o.encryptedCardNum))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2& CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2::operator=(Protocol_MSG_CASHIER_PRE_CASHIN2&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		accountAmount = std::move(_o.accountAmount);
		bytePaySystem = std::move(_o.bytePaySystem);
		processorCurrency = std::move(_o.processorCurrency);
		bonusCode = std::move(_o.bonusCode);
		accountCurrency = std::move(_o.accountCurrency);
		validationDigits = std::move(_o.validationDigits);
		validationAttempts = std::move(_o.validationAttempts);
		processorAmount = std::move(_o.processorAmount);
		nonZeroPaysystemFeeApplies = std::move(_o.nonZeroPaysystemFeeApplies);
		cardNum = std::move(_o.cardNum);
		encryptedCardNum = std::move(_o.encryptedCardNum);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2::clear()
{
	userId.clear();
	accountAmount = 0;
	bytePaySystem = 0;
	processorCurrency.clear();
	bonusCode.clear();
	accountCurrency.clear();
	validationDigits = 0;
	validationAttempts = 0;
	processorAmount = 0;
	nonZeroPaysystemFeeApplies = false;
	cardNum.clear();
	encryptedCardNum.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2::equals(const Protocol_MSG_CASHIER_PRE_CASHIN2& _o) const
{
	return userId.equals(_o.userId) &&
		accountAmount == _o.accountAmount &&
		bytePaySystem == _o.bytePaySystem &&
		processorCurrency.equals(_o.processorCurrency) &&
		bonusCode.equals(_o.bonusCode) &&
		accountCurrency.equals(_o.accountCurrency) &&
		validationDigits == _o.validationDigits &&
		validationAttempts == _o.validationAttempts &&
		processorAmount == _o.processorAmount &&
		nonZeroPaysystemFeeApplies == _o.nonZeroPaysystemFeeApplies &&
		cardNum.equals(_o.cardNum) &&
		encryptedCardNum.size() == _o.encryptedCardNum.size() && memcmp(encryptedCardNum.ptr(), _o.encryptedCardNum.ptr(), encryptedCardNum.size()) == 0;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PRE_CASHIN2).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("accountAmount=");
	_buf.appendInt(accountAmount);
	_buf.append(',');
	_buf.append("bytePaySystem=");
	_buf.appendUint(bytePaySystem);
	_buf.append(',');
	_buf.append("processorCurrency=");
	_buf.append(processorCurrency);
	_buf.append(',');
	_buf.append("bonusCode=");
	_buf.append(bonusCode);
	_buf.append(',');
	_buf.append("accountCurrency=");
	_buf.append(accountCurrency);
	_buf.append(',');
	_buf.append("validationDigits=");
	_buf.appendUint(validationDigits);
	_buf.append(',');
	_buf.append("validationAttempts=");
	_buf.appendUint(validationAttempts);
	_buf.append(',');
	_buf.append("processorAmount=");
	_buf.appendInt(processorAmount);
	_buf.append(',');
	_buf.append("nonZeroPaysystemFeeApplies=");
	_buf.appendUint(nonZeroPaysystemFeeApplies);
	_buf.append(',');
	_buf.append("cardNum=");
	_buf.append(cardNum);
	_buf.append(',');
	_buf.append("encryptedCardNum=");
	ThinAtf::AtfTempl<PBlock>::ToTraceString(_buf, encryptedCardNum);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeINT32(accountAmount);
	_msg.composeBYTE(bytePaySystem);
	_msg.composeString(processorCurrency);
	_msg.composeString(bonusCode);
	_msg.composeString(accountCurrency);
	CommMsgBody _msg0;
	_msg0.composeUINT32(validationDigits);
	_msg0.composeUINT32(validationAttempts);
	_msg.composeMsgBody(_msg0);
	_msg.composeINT32(processorAmount);
	_msg.composeBOOL(nonZeroPaysystemFeeApplies);
	_msg.composeString(cardNum);
	_msg._composeVarBlock(encryptedCardNum.ptr(), encryptedCardNum.size());
}

void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseINT32(accountAmount);
	_parser.parseBYTE(bytePaySystem);
	_parser.parseStringP(processorCurrency);
	_parser.parseStringP(bonusCode);
	_parser.parseStringP(accountCurrency);
	parseAnonymousMsgBody0(_parser);
	_parser.parseINT32(processorAmount);
	_parser.parseBOOL(nonZeroPaysystemFeeApplies);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(cardNum);
	if(_parser.parseEnded()) return;
	_parser.parsePBlock(encryptedCardNum);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PRE_CASHIN2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	INT32 accountAmount; _parser.parseINT32(accountAmount);
	AtfValidator::validateIntRange(_descr, "accountAmount", accountAmount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	BYTE bytePaySystem; _parser.parseBYTE(bytePaySystem);
	AtfValidator::validateIntRange(_descr, "bytePaySystem", bytePaySystem, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "processorCurrency"); size_t szProcessorCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "processorCurrency", szProcessorCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "bonusCode"); size_t szBonusCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bonusCode", szBonusCode, 40, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "accountCurrency"); size_t szAccountCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "accountCurrency", szAccountCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 processorAmount; _parser.parseINT32(processorAmount);
	AtfValidator::validateIntRange(_descr, "processorAmount", processorAmount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	bool nonZeroPaysystemFeeApplies; _parser.parseBOOL(nonZeroPaysystemFeeApplies);
	AtfValidator::validateInt(_descr, "nonZeroPaysystemFeeApplies", nonZeroPaysystemFeeApplies, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "cardNum"); size_t szCardNum = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "cardNum", szCardNum, CARDNUM_LEN, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	const BYTE* encryptedCardNum; size_t szEncryptedCardNum; _parser._parseVarBlock(encryptedCardNum, szEncryptedCardNum);  /*encryptedCardNum*/
	AtfValidator::validateIntMax(_descr, "encryptedCardNum", szEncryptedCardNum, 4000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(validationDigits);
	_parser0.parseUINT32(validationAttempts);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 validationDigits; _parser0.parseUINT32(validationDigits);
	AtfValidator::validateInt(_descr, "validationDigits", validationDigits, _checker, __FILE__, __LINE__);
	UINT32 validationAttempts; _parser0.parseUINT32(validationAttempts);
	AtfValidator::validateInt(_descr, "validationAttempts", validationAttempts, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CashierTicketBody
//=================================================================

CashierServer::cli::CashierTicketBody::CashierTicketBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::CashierTicketBody::CashierTicketBody(CashierTicketBody&& _o)
	: admission(std::move(_o.admission))
	, ticketsCount(std::move(_o.ticketsCount))
{
}

CashierServer::cli::CashierTicketBody& CashierServer::cli::CashierTicketBody::operator=(CashierTicketBody&& _o)
{
	if(this != &_o)
	{
		admission = std::move(_o.admission);
		ticketsCount = std::move(_o.ticketsCount);
	}
	return *this;
}

#endif

void CashierServer::cli::CashierTicketBody::clear()
{
	admission.clear();
	ticketsCount = 0;
}

bool CashierServer::cli::CashierTicketBody::equals(const CashierTicketBody& _o) const
{
	return admission.equals(_o.admission) &&
		ticketsCount == _o.ticketsCount;
}

const char *CashierServer::cli::CashierTicketBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("admission=");
	_buf.append(admission);
	_buf.append(',');
	_buf.append("ticketsCount=");
	_buf.appendInt(ticketsCount);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashierTicketBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CashierTicketBody())) // not empty
	{
		_body.composeString(admission);
		_body.composeINT32(ticketsCount);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierTicketBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(admission);
	_parser0.parseINT32(ticketsCount);
}

/*static*/ void CashierServer::cli::CashierTicketBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "admission"); size_t szAdmission = strlen(_dummy);
	AtfValidator::validateInt(_descr, "admission", szAdmission, _checker, __FILE__, __LINE__);
	INT32 ticketsCount; _parser0.parseINT32(ticketsCount);
	AtfValidator::validateInt(_descr, "ticketsCount", ticketsCount, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CashierGatewayDisclaimerBodyOne
//=================================================================

CashierServer::cli::CashierGatewayDisclaimerBodyOne::CashierGatewayDisclaimerBodyOne()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::CashierGatewayDisclaimerBodyOne::CashierGatewayDisclaimerBodyOne(CashierGatewayDisclaimerBodyOne&& _o)
	: text(std::move(_o.text))
{
}

CashierServer::cli::CashierGatewayDisclaimerBodyOne& CashierServer::cli::CashierGatewayDisclaimerBodyOne::operator=(CashierGatewayDisclaimerBodyOne&& _o)
{
	if(this != &_o)
	{
		text = std::move(_o.text);
	}
	return *this;
}

#endif

void CashierServer::cli::CashierGatewayDisclaimerBodyOne::clear()
{
	text.clear();
}

bool CashierServer::cli::CashierGatewayDisclaimerBodyOne::equals(const CashierGatewayDisclaimerBodyOne& _o) const
{
	return text.equals(_o.text);
}

const char *CashierServer::cli::CashierGatewayDisclaimerBodyOne::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("text=");
	_buf.append(text);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashierGatewayDisclaimerBodyOne::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CashierGatewayDisclaimerBodyOne())) // not empty
	{
		_body.composeString(text);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierGatewayDisclaimerBodyOne::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(text);
}

/*static*/ void CashierServer::cli::CashierGatewayDisclaimerBodyOne::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "text"); size_t szText = strlen(_dummy);
	AtfValidator::validateInt(_descr, "text", szText, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CashierGatewayDisclaimerBody
//=================================================================

CashierServer::cli::CashierGatewayDisclaimerBody::CashierGatewayDisclaimerBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::CashierGatewayDisclaimerBody::CashierGatewayDisclaimerBody(CashierGatewayDisclaimerBody&& _o)
	: header(std::move(_o.header))
	, text(std::move(_o.text))
	, buttons(std::move(_o.buttons))
{
}

CashierServer::cli::CashierGatewayDisclaimerBody& CashierServer::cli::CashierGatewayDisclaimerBody::operator=(CashierGatewayDisclaimerBody&& _o)
{
	if(this != &_o)
	{
		header = std::move(_o.header);
		text = std::move(_o.text);
		buttons = std::move(_o.buttons);
	}
	return *this;
}

#endif

void CashierServer::cli::CashierGatewayDisclaimerBody::clear()
{
	header.clear();
	text.clear();
	buttons.clear();
}

bool CashierServer::cli::CashierGatewayDisclaimerBody::equals(const CashierGatewayDisclaimerBody& _o) const
{
	return header.equals(_o.header) &&
		text.equals(_o.text) &&
		buttons.equals(_o.buttons);
}

const char *CashierServer::cli::CashierGatewayDisclaimerBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	_buf.append(header);
	_buf.append(',');
	_buf.append("text=");
	_buf.append(text);
	_buf.append(',');
	_buf.append("buttons=");
	buttons.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashierGatewayDisclaimerBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CashierGatewayDisclaimerBody())) // not empty
	{
		_body.composeString(header);
		_body.composeString(text);
		buttons.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierGatewayDisclaimerBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(header);
	_parser0.parseStringP(text);
	buttons.parseMsg(_parser0);
}

/*static*/ void CashierServer::cli::CashierGatewayDisclaimerBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "header"); size_t szHeader = strlen(_dummy);
	AtfValidator::validateInt(_descr, "header", szHeader, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "text"); size_t szText = strlen(_dummy);
	AtfValidator::validateInt(_descr, "text", szText, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szButtons = ThinAtf::LAtfVector< CashierGatewayDisclaimerBodyOne, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("buttons"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "buttons", szButtons, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY::Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY::Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY(Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, bestBonusAmount(std::move(_o.bestBonusAmount))
	, bestBonusFppToEarn(std::move(_o.bestBonusFppToEarn))
	, availAmount(std::move(_o.availAmount))
	, bestBonusId(std::move(_o.bestBonusId))
	, bestBonusPercent(std::move(_o.bestBonusPercent))
	, bestBonusMaxAvailableAmount(std::move(_o.bestBonusMaxAvailableAmount))
	, bestBonusName(std::move(_o.bestBonusName))
	, bestBonusStart(std::move(_o.bestBonusStart))
	, bestBonusEnd(std::move(_o.bestBonusEnd))
	, bestBonusUrl(std::move(_o.bestBonusUrl))
	, zero(std::move(_o.zero))
	, bestBonusReleasePortion(std::move(_o.bestBonusReleasePortion))
	, bestBonusFppReleasePortion(std::move(_o.bestBonusFppReleasePortion))
	, bestBonusBonusFlags(std::move(_o.bestBonusBonusFlags))
	, bestBonusMaxNumDepositsLeft(std::move(_o.bestBonusMaxNumDepositsLeft))
	, bestBonusLastAllowedDepositTime(std::move(_o.bestBonusLastAllowedDepositTime))
	, bestBonusCurrency(std::move(_o.bestBonusCurrency))
	, bestBonusDaysToDeposit(std::move(_o.bestBonusDaysToDeposit))
	, bestBonusMaxDepositNumber(std::move(_o.bestBonusMaxDepositNumber))
	, acctAmount(std::move(_o.acctAmount))
	, beDepositExceedsLossLimit(std::move(_o.beDepositExceedsLossLimit))
	, ticketOnlyBonusBodies(std::move(_o.ticketOnlyBonusBodies))
	, rollMsgBody(std::move(_o.rollMsgBody))
	, disclaimerMsgBody(std::move(_o.disclaimerMsgBody))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY::operator=(Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		bestBonusAmount = std::move(_o.bestBonusAmount);
		bestBonusFppToEarn = std::move(_o.bestBonusFppToEarn);
		availAmount = std::move(_o.availAmount);
		bestBonusId = std::move(_o.bestBonusId);
		bestBonusPercent = std::move(_o.bestBonusPercent);
		bestBonusMaxAvailableAmount = std::move(_o.bestBonusMaxAvailableAmount);
		bestBonusName = std::move(_o.bestBonusName);
		bestBonusStart = std::move(_o.bestBonusStart);
		bestBonusEnd = std::move(_o.bestBonusEnd);
		bestBonusUrl = std::move(_o.bestBonusUrl);
		zero = std::move(_o.zero);
		bestBonusReleasePortion = std::move(_o.bestBonusReleasePortion);
		bestBonusFppReleasePortion = std::move(_o.bestBonusFppReleasePortion);
		bestBonusBonusFlags = std::move(_o.bestBonusBonusFlags);
		bestBonusMaxNumDepositsLeft = std::move(_o.bestBonusMaxNumDepositsLeft);
		bestBonusLastAllowedDepositTime = std::move(_o.bestBonusLastAllowedDepositTime);
		bestBonusCurrency = std::move(_o.bestBonusCurrency);
		bestBonusDaysToDeposit = std::move(_o.bestBonusDaysToDeposit);
		bestBonusMaxDepositNumber = std::move(_o.bestBonusMaxDepositNumber);
		acctAmount = std::move(_o.acctAmount);
		beDepositExceedsLossLimit = std::move(_o.beDepositExceedsLossLimit);
		ticketOnlyBonusBodies = std::move(_o.ticketOnlyBonusBodies);
		rollMsgBody = std::move(_o.rollMsgBody);
		disclaimerMsgBody = std::move(_o.disclaimerMsgBody);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	bestBonusAmount = 0;
	bestBonusFppToEarn = 0;
	availAmount = 0;
	bestBonusId = 0;
	bestBonusPercent = 0;
	bestBonusMaxAvailableAmount = 0;
	bestBonusName.clear();
	bestBonusStart.setNull();
	bestBonusEnd.setNull();
	bestBonusUrl.clear();
	zero = 0;
	bestBonusReleasePortion = 0;
	bestBonusFppReleasePortion = 0;
	bestBonusBonusFlags = 0;
	bestBonusMaxNumDepositsLeft = 0;
	bestBonusLastAllowedDepositTime.setNull();
	bestBonusCurrency.clear();
	bestBonusDaysToDeposit = 0;
	bestBonusMaxDepositNumber = 0;
	acctAmount = 0;
	beDepositExceedsLossLimit = false;
	ticketOnlyBonusBodies.clear();
	rollMsgBody.clear();
	disclaimerMsgBody.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY::equals(const Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		bestBonusAmount == _o.bestBonusAmount &&
		bestBonusFppToEarn == _o.bestBonusFppToEarn &&
		availAmount == _o.availAmount &&
		bestBonusId == _o.bestBonusId &&
		bestBonusPercent == _o.bestBonusPercent &&
		bestBonusMaxAvailableAmount == _o.bestBonusMaxAvailableAmount &&
		bestBonusName.equals(_o.bestBonusName) &&
		bestBonusStart.equals(_o.bestBonusStart) &&
		bestBonusEnd.equals(_o.bestBonusEnd) &&
		bestBonusUrl.equals(_o.bestBonusUrl) &&
		zero == _o.zero &&
		bestBonusReleasePortion == _o.bestBonusReleasePortion &&
		bestBonusFppReleasePortion == _o.bestBonusFppReleasePortion &&
		bestBonusBonusFlags == _o.bestBonusBonusFlags &&
		bestBonusMaxNumDepositsLeft == _o.bestBonusMaxNumDepositsLeft &&
		bestBonusLastAllowedDepositTime.equals(_o.bestBonusLastAllowedDepositTime) &&
		bestBonusCurrency.equals(_o.bestBonusCurrency) &&
		bestBonusDaysToDeposit == _o.bestBonusDaysToDeposit &&
		bestBonusMaxDepositNumber == _o.bestBonusMaxDepositNumber &&
		acctAmount == _o.acctAmount &&
		beDepositExceedsLossLimit == _o.beDepositExceedsLossLimit &&
		ticketOnlyBonusBodies.equals(_o.ticketOnlyBonusBodies) &&
		rollMsgBody.equals(_o.rollMsgBody) &&
		disclaimerMsgBody.equals(_o.disclaimerMsgBody);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PRE_CASHIN2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("bestBonusAmount=");
		_buf.appendInt(bestBonusAmount);
		_buf.append(',');
		_buf.append("bestBonusFppToEarn=");
		_buf.appendInt(bestBonusFppToEarn);
		_buf.append(',');
		_buf.append("availAmount=");
		_buf.appendInt(availAmount);
		_buf.append(',');
		_buf.append("bestBonusId=");
		_buf.appendUint(bestBonusId);
		_buf.append(',');
		_buf.append("bestBonusPercent=");
		_buf.appendInt(bestBonusPercent);
		_buf.append(',');
		_buf.append("bestBonusMaxAvailableAmount=");
		_buf.appendInt(bestBonusMaxAvailableAmount);
		_buf.append(',');
		_buf.append("bestBonusName=");
		_buf.append(bestBonusName);
		_buf.append(',');
		_buf.append("bestBonusStart=");
		ThinAtf::AtfTempl<CommSrvTime>::ToTraceString(_buf, bestBonusStart);
		_buf.append(',');
		_buf.append("bestBonusEnd=");
		ThinAtf::AtfTempl<CommSrvTime>::ToTraceString(_buf, bestBonusEnd);
		_buf.append(',');
		_buf.append("bestBonusUrl=");
		_buf.append(bestBonusUrl);
		_buf.append(',');
		_buf.append("zero=");
		_buf.appendUint(zero);
		_buf.append(',');
		_buf.append("bestBonusReleasePortion=");
		_buf.appendInt(bestBonusReleasePortion);
		_buf.append(',');
		_buf.append("bestBonusFppReleasePortion=");
		_buf.appendInt(bestBonusFppReleasePortion);
		_buf.append(',');
		_buf.append("bestBonusBonusFlags=");
		_buf.appendUint(bestBonusBonusFlags);
		_buf.append(',');
		_buf.append("bestBonusMaxNumDepositsLeft=");
		_buf.appendUint(bestBonusMaxNumDepositsLeft);
		_buf.append(',');
		_buf.append("bestBonusLastAllowedDepositTime=");
		ThinAtf::AtfTempl<CommSrvTime>::ToTraceString(_buf, bestBonusLastAllowedDepositTime);
		_buf.append(',');
		_buf.append("bestBonusCurrency=");
		_buf.append(bestBonusCurrency);
		_buf.append(',');
		_buf.append("bestBonusDaysToDeposit=");
		_buf.appendInt(bestBonusDaysToDeposit);
		_buf.append(',');
		_buf.append("bestBonusMaxDepositNumber=");
		_buf.appendInt(bestBonusMaxDepositNumber);
		_buf.append(',');
		_buf.append("acctAmount=");
		_buf.appendInt(acctAmount);
		_buf.append(',');
		_buf.append("beDepositExceedsLossLimit=");
		_buf.appendUint(beDepositExceedsLossLimit);
		_buf.append(',');
		_buf.append("ticketOnlyBonusBodies=");
		ticketOnlyBonusBodies.toTraceString(_buf);
		_buf.append(',');
		_buf.append("rollMsgBody=");
		rollMsgBody.toTraceString(_buf);
		_buf.append(',');
		_buf.append("disclaimerMsgBody=");
		disclaimerMsgBody.toTraceString(_buf);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(bestBonusAmount);
		_msg.composeINT32(bestBonusFppToEarn);
		_msg.composeINT32(availAmount);
		_msg.composeUINT32(bestBonusId);
		_msg.composeINT32(bestBonusPercent);
		_msg.composeINT32(bestBonusMaxAvailableAmount);
		_msg.composeString(bestBonusName);
		_msg.composeSrvTime(bestBonusStart);
		_msg.composeSrvTime(bestBonusEnd);
		_msg.composeString(bestBonusUrl);
		_msg.composeUINT32(zero);
		_msg.composeINT32(bestBonusReleasePortion);
		_msg.composeINT32(bestBonusFppReleasePortion);
		_msg.composeUINT32(bestBonusBonusFlags);
		_msg.composeUINT32(bestBonusMaxNumDepositsLeft);
		_msg.composeSrvTime(bestBonusLastAllowedDepositTime);
		_msg.composeString(bestBonusCurrency);
		_msg.composeINT32(bestBonusDaysToDeposit);
		_msg.composeINT32(bestBonusMaxDepositNumber);
		_msg.composeINT32(acctAmount);
		_msg.composeBOOL(beDepositExceedsLossLimit);
		CommMsgBody _msg0;
		ticketOnlyBonusBodies.composeMsg(_msg0);
		_msg.composeMsgBody(_msg0);
		rollMsgBody.composeMsg(_msg);
		disclaimerMsgBody.composeMsg(_msg);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(bestBonusAmount);
		_parser.parseINT32(bestBonusFppToEarn);
		_parser.parseINT32(availAmount);
		_parser.parseUINT32(bestBonusId);
		_parser.parseINT32(bestBonusPercent);
		_parser.parseINT32(bestBonusMaxAvailableAmount);
		_parser.parseStringP(bestBonusName);
		_parser.parseSrvTime(bestBonusStart);
		_parser.parseSrvTime(bestBonusEnd);
		_parser.parseStringP(bestBonusUrl);
		_parser.parseUINT32(zero);
		_parser.parseINT32(bestBonusReleasePortion);
		_parser.parseINT32(bestBonusFppReleasePortion);
		_parser.parseUINT32(bestBonusBonusFlags);
		_parser.parseUINT32(bestBonusMaxNumDepositsLeft);
		_parser.parseSrvTime(bestBonusLastAllowedDepositTime);
		_parser.parseStringP(bestBonusCurrency);
		_parser.parseINT32(bestBonusDaysToDeposit);
		_parser.parseINT32(bestBonusMaxDepositNumber);
		_parser.parseINT32(acctAmount);
		_parser.parseBOOL(beDepositExceedsLossLimit);
		parseAnonymousMsgBody0(_parser);
		rollMsgBody.parseMsg(_parser);
		disclaimerMsgBody.parseMsg(_parser);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PRE_CASHIN2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 bestBonusAmount; _parser.parseINT32(bestBonusAmount);
		AtfValidator::validateInt(_descr, "bestBonusAmount", bestBonusAmount, _checker, __FILE__, __LINE__);
		INT32 bestBonusFppToEarn; _parser.parseINT32(bestBonusFppToEarn);
		AtfValidator::validateInt(_descr, "bestBonusFppToEarn", bestBonusFppToEarn, _checker, __FILE__, __LINE__);
		INT32 availAmount; _parser.parseINT32(availAmount);
		AtfValidator::validateInt(_descr, "availAmount", availAmount, _checker, __FILE__, __LINE__);
		UINT32 bestBonusId; _parser.parseUINT32(bestBonusId);
		AtfValidator::validateInt(_descr, "bestBonusId", bestBonusId, _checker, __FILE__, __LINE__);
		INT32 bestBonusPercent; _parser.parseINT32(bestBonusPercent);
		AtfValidator::validateInt(_descr, "bestBonusPercent", bestBonusPercent, _checker, __FILE__, __LINE__);
		INT32 bestBonusMaxAvailableAmount; _parser.parseINT32(bestBonusMaxAvailableAmount);
		AtfValidator::validateInt(_descr, "bestBonusMaxAvailableAmount", bestBonusMaxAvailableAmount, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "bestBonusName"); size_t szBestBonusName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "bestBonusName", szBestBonusName, _checker, __FILE__, __LINE__);
		CommSrvTime bestBonusStart; _parser.parseSrvTime(bestBonusStart);
		AtfValidator::validateSrvDateTime(_descr, "bestBonusStart", bestBonusStart, _checker, __FILE__, __LINE__);
		CommSrvTime bestBonusEnd; _parser.parseSrvTime(bestBonusEnd);
		AtfValidator::validateSrvDateTime(_descr, "bestBonusEnd", bestBonusEnd, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "bestBonusUrl"); size_t szBestBonusUrl = strlen(_dummy);
		AtfValidator::validateInt(_descr, "bestBonusUrl", szBestBonusUrl, _checker, __FILE__, __LINE__);
		UINT32 zero; _parser.parseUINT32(zero);
		AtfValidator::validateInt(_descr, "zero", zero, _checker, __FILE__, __LINE__);
		INT32 bestBonusReleasePortion; _parser.parseINT32(bestBonusReleasePortion);
		AtfValidator::validateInt(_descr, "bestBonusReleasePortion", bestBonusReleasePortion, _checker, __FILE__, __LINE__);
		INT32 bestBonusFppReleasePortion; _parser.parseINT32(bestBonusFppReleasePortion);
		AtfValidator::validateInt(_descr, "bestBonusFppReleasePortion", bestBonusFppReleasePortion, _checker, __FILE__, __LINE__);
		UINT32 bestBonusBonusFlags; _parser.parseUINT32(bestBonusBonusFlags);
		AtfValidator::validateInt(_descr, "bestBonusBonusFlags", bestBonusBonusFlags, _checker, __FILE__, __LINE__);
		UINT32 bestBonusMaxNumDepositsLeft; _parser.parseUINT32(bestBonusMaxNumDepositsLeft);
		AtfValidator::validateInt(_descr, "bestBonusMaxNumDepositsLeft", bestBonusMaxNumDepositsLeft, _checker, __FILE__, __LINE__);
		CommSrvTime bestBonusLastAllowedDepositTime; _parser.parseSrvTime(bestBonusLastAllowedDepositTime);
		AtfValidator::validateSrvDateTime(_descr, "bestBonusLastAllowedDepositTime", bestBonusLastAllowedDepositTime, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "bestBonusCurrency"); size_t szBestBonusCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "bestBonusCurrency", szBestBonusCurrency, _checker, __FILE__, __LINE__);
		INT32 bestBonusDaysToDeposit; _parser.parseINT32(bestBonusDaysToDeposit);
		AtfValidator::validateInt(_descr, "bestBonusDaysToDeposit", bestBonusDaysToDeposit, _checker, __FILE__, __LINE__);
		INT32 bestBonusMaxDepositNumber; _parser.parseINT32(bestBonusMaxDepositNumber);
		AtfValidator::validateInt(_descr, "bestBonusMaxDepositNumber", bestBonusMaxDepositNumber, _checker, __FILE__, __LINE__);
		INT32 acctAmount; _parser.parseINT32(acctAmount);
		AtfValidator::validateInt(_descr, "acctAmount", acctAmount, _checker, __FILE__, __LINE__);
		bool beDepositExceedsLossLimit; _parser.parseBOOL(beDepositExceedsLossLimit);
		AtfValidator::validateInt(_descr, "beDepositExceedsLossLimit", beDepositExceedsLossLimit, _checker, __FILE__, __LINE__);
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
		PString _descbuf;
		common_structs::CashierRollBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("rollMsgBody"), _fieldsWithUnparsedContent);
		CashierGatewayDisclaimerBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("disclaimerMsgBody"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	ticketOnlyBonusBodies.parseMsg(_parser0);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szTicketOnlyBonusBodies = ThinAtf::LAtfVector< CashierTicketBody, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("ticketOnlyBonusBodies"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "ticketOnlyBonusBodies", szTicketOnlyBonusBodies, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_CASHIN_NT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT::Protocol_MSG_CASHIER_CASHIN_NT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT::Protocol_MSG_CASHIER_CASHIN_NT(Protocol_MSG_CASHIER_CASHIN_NT&& _o)
	: userId(std::move(_o.userId))
	, netAccount(std::move(_o.netAccount))
	, secureId(std::move(_o.secureId))
	, transAmount(std::move(_o.transAmount))
	, bonusId(std::move(_o.bonusId))
	, doNotCancel_ignored(std::move(_o.doNotCancel_ignored))
	, bank_acct_num(std::move(_o.bank_acct_num))
	, saveCardInfoRequested(std::move(_o.saveCardInfoRequested))
	, bonusCode(std::move(_o.bonusCode))
	, currency(std::move(_o.currency))
	, converted(std::move(_o.converted))
	, balanceCurrency(std::move(_o.balanceCurrency))
	, clientBalance_ignored(std::move(_o.clientBalance_ignored))
	, fastDepositTransaction(std::move(_o.fastDepositTransaction))
	, saveInfoForFastDeposit(std::move(_o.saveInfoForFastDeposit))
	, ignoreRepeatedDeclines(std::move(_o.ignoreRepeatedDeclines))
	, cardInfoId(std::move(_o.cardInfoId))
	, awardId(std::move(_o.awardId))
	, clientDepositFlags(std::move(_o.clientDepositFlags))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT& CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT::operator=(Protocol_MSG_CASHIER_CASHIN_NT&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		netAccount = std::move(_o.netAccount);
		secureId = std::move(_o.secureId);
		transAmount = std::move(_o.transAmount);
		bonusId = std::move(_o.bonusId);
		doNotCancel_ignored = std::move(_o.doNotCancel_ignored);
		bank_acct_num = std::move(_o.bank_acct_num);
		saveCardInfoRequested = std::move(_o.saveCardInfoRequested);
		bonusCode = std::move(_o.bonusCode);
		currency = std::move(_o.currency);
		converted = std::move(_o.converted);
		balanceCurrency = std::move(_o.balanceCurrency);
		clientBalance_ignored = std::move(_o.clientBalance_ignored);
		fastDepositTransaction = std::move(_o.fastDepositTransaction);
		saveInfoForFastDeposit = std::move(_o.saveInfoForFastDeposit);
		ignoreRepeatedDeclines = std::move(_o.ignoreRepeatedDeclines);
		cardInfoId = std::move(_o.cardInfoId);
		awardId = std::move(_o.awardId);
		clientDepositFlags = std::move(_o.clientDepositFlags);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT::clear()
{
	userId.clear();
	netAccount.clear();
	secureId.clear();
	transAmount = 0;
	bonusId = 0;
	doNotCancel_ignored = 0;
	bank_acct_num.clear();
	saveCardInfoRequested = false;
	bonusCode.clear();
	currency.clear();
	converted = 0;
	balanceCurrency.clear();
	clientBalance_ignored = 0;
	fastDepositTransaction = false;
	saveInfoForFastDeposit = false;
	ignoreRepeatedDeclines = false;
	cardInfoId = 0;
	awardId = 0;
	clientDepositFlags = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT::equals(const Protocol_MSG_CASHIER_CASHIN_NT& _o) const
{
	return userId.equals(_o.userId) &&
		netAccount.equals(_o.netAccount) &&
		secureId.equals(_o.secureId) &&
		transAmount == _o.transAmount &&
		bonusId == _o.bonusId &&
		doNotCancel_ignored == _o.doNotCancel_ignored &&
		bank_acct_num.equals(_o.bank_acct_num) &&
		saveCardInfoRequested == _o.saveCardInfoRequested &&
		bonusCode.equals(_o.bonusCode) &&
		currency.equals(_o.currency) &&
		converted == _o.converted &&
		balanceCurrency.equals(_o.balanceCurrency) &&
		clientBalance_ignored == _o.clientBalance_ignored &&
		fastDepositTransaction == _o.fastDepositTransaction &&
		saveInfoForFastDeposit == _o.saveInfoForFastDeposit &&
		ignoreRepeatedDeclines == _o.ignoreRepeatedDeclines &&
		cardInfoId == _o.cardInfoId &&
		awardId == _o.awardId &&
		clientDepositFlags == _o.clientDepositFlags;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CASHIN_NT).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("netAccount=");
	_buf.append(netAccount);
	_buf.append(',');
	_buf.append("secureId=");
	_buf.append(secureId);
	_buf.append(',');
	_buf.append("transAmount=");
	_buf.appendInt(transAmount);
	_buf.append(',');
	_buf.append("bonusId=");
	_buf.appendUint(bonusId);
	_buf.append(',');
	_buf.append("doNotCancel_ignored=");
	_buf.appendUint(doNotCancel_ignored);
	_buf.append(',');
	_buf.append("bank_acct_num=");
	_buf.append(bank_acct_num);
	_buf.append(',');
	_buf.append("saveCardInfoRequested=");
	_buf.appendUint(saveCardInfoRequested);
	_buf.append(',');
	_buf.append("bonusCode=");
	_buf.append(bonusCode);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("converted=");
	_buf.appendInt(converted);
	_buf.append(',');
	_buf.append("balanceCurrency=");
	_buf.append(balanceCurrency);
	_buf.append(',');
	_buf.append("clientBalance_ignored=");
	_buf.appendInt(clientBalance_ignored);
	_buf.append(',');
	_buf.append("fastDepositTransaction=");
	_buf.appendUint(fastDepositTransaction);
	_buf.append(',');
	_buf.append("saveInfoForFastDeposit=");
	_buf.appendUint(saveInfoForFastDeposit);
	_buf.append(',');
	_buf.append("ignoreRepeatedDeclines=");
	_buf.appendUint(ignoreRepeatedDeclines);
	_buf.append(',');
	_buf.append("cardInfoId=");
	_buf.appendUint(cardInfoId);
	_buf.append(',');
	_buf.append("awardId=");
	_buf.appendUint(awardId);
	_buf.append(',');
	_buf.append("clientDepositFlags=");
	_buf.appendUint(clientDepositFlags);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeString(netAccount);
	_msg.composeString(secureId);
	_msg.composeINT32(transAmount);
	_msg.composeUINT32(bonusId);
	_msg.composeBYTE(doNotCancel_ignored);
	_msg.composeString(bank_acct_num);
	_msg.composeBOOL(saveCardInfoRequested);
	_msg.composeString(bonusCode);
	_msg.composeString(currency);
	_msg.composeINT32(converted);
	_msg.composeString(balanceCurrency);
	_msg.composeINT32(clientBalance_ignored);
	_msg.composeBOOL(fastDepositTransaction);
	_msg.composeBOOL(saveInfoForFastDeposit);
	_msg.composeBOOL(ignoreRepeatedDeclines);
	_msg.composeUINT32(cardInfoId);
	_msg.composeUINT32(awardId);
	_msg.composeUINT32(clientDepositFlags);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseStringP(netAccount);
	_parser.parseStringP(secureId);
	_parser.parseINT32(transAmount);
	_parser.parseUINT32(bonusId);
	_parser.parseBYTE(doNotCancel_ignored);
	_parser.parseStringP(bank_acct_num);
	_parser.parseBOOL(saveCardInfoRequested);
	_parser.parseStringP(bonusCode);
	_parser.parseStringP(currency);
	_parser.parseINT32(converted);
	_parser.parseStringP(balanceCurrency);
	_parser.parseINT32(clientBalance_ignored);
	_parser.parseBOOL(fastDepositTransaction);
	_parser.parseBOOL(saveInfoForFastDeposit);
	_parser.parseBOOL(ignoreRepeatedDeclines);
	_parser.parseUINT32(cardInfoId);
	_parser.parseUINT32(awardId);
	_parser.parseUINT32(clientDepositFlags);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CASHIN_NT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "netAccount"); size_t szNetAccount = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "netAccount", szNetAccount, 1000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "secureId"); size_t szSecureId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "secureId", szSecureId, 1000, _checker, __FILE__, __LINE__);
	INT32 transAmount; _parser.parseINT32(transAmount);
	AtfValidator::validateIntRange(_descr, "transAmount", transAmount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	UINT32 bonusId; _parser.parseUINT32(bonusId);
	AtfValidator::validateInt(_descr, "bonusId", bonusId, _checker, __FILE__, __LINE__);
	BYTE doNotCancel_ignored; _parser.parseBYTE(doNotCancel_ignored);
	AtfValidator::validateInt(_descr, "doNotCancel_ignored", doNotCancel_ignored, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "bank_acct_num"); size_t szBank_acct_num = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bank_acct_num", szBank_acct_num, 1000, _checker, __FILE__, __LINE__);
	bool saveCardInfoRequested; _parser.parseBOOL(saveCardInfoRequested);
	AtfValidator::validateInt(_descr, "saveCardInfoRequested", saveCardInfoRequested, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "bonusCode"); size_t szBonusCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bonusCode", szBonusCode, BONUS_CODE_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	INT32 converted; _parser.parseINT32(converted);
	AtfValidator::validateIntRange(_descr, "converted", converted, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "balanceCurrency"); size_t szBalanceCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "balanceCurrency", szBalanceCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	INT32 clientBalance_ignored; _parser.parseINT32(clientBalance_ignored);
	AtfValidator::validateInt(_descr, "clientBalance_ignored", clientBalance_ignored, _checker, __FILE__, __LINE__);
	bool fastDepositTransaction; _parser.parseBOOL(fastDepositTransaction);
	AtfValidator::validateInt(_descr, "fastDepositTransaction", fastDepositTransaction, _checker, __FILE__, __LINE__);
	bool saveInfoForFastDeposit; _parser.parseBOOL(saveInfoForFastDeposit);
	AtfValidator::validateInt(_descr, "saveInfoForFastDeposit", saveInfoForFastDeposit, _checker, __FILE__, __LINE__);
	bool ignoreRepeatedDeclines; _parser.parseBOOL(ignoreRepeatedDeclines);
	AtfValidator::validateInt(_descr, "ignoreRepeatedDeclines", ignoreRepeatedDeclines, _checker, __FILE__, __LINE__);
	UINT32 cardInfoId; _parser.parseUINT32(cardInfoId);
	AtfValidator::validateInt(_descr, "cardInfoId", cardInfoId, _checker, __FILE__, __LINE__);
	UINT32 awardId; _parser.parseUINT32(awardId);
	AtfValidator::validateInt(_descr, "awardId", awardId, _checker, __FILE__, __LINE__);
	UINT32 clientDepositFlags; _parser.parseUINT32(clientDepositFlags);
	AtfValidator::validateIntMax(_descr, "clientDepositFlags", clientDepositFlags, ((((UINT32)eClientDepositFlags_Last)<<1)-1), _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CASHIN_NT_CONFIRM
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_CONFIRM::Protocol_MSG_CASHIER_CASHIN_NT_CONFIRM()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_CONFIRM::Protocol_MSG_CASHIER_CASHIN_NT_CONFIRM(Protocol_MSG_CASHIER_CASHIN_NT_CONFIRM&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, transId(std::move(_o.transId))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_CONFIRM& CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_CONFIRM::operator=(Protocol_MSG_CASHIER_CASHIN_NT_CONFIRM&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		transId = std::move(_o.transId);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_CONFIRM::clear()
{
	errCode = 0;
	errDescr.clear();
	transId = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_CONFIRM::equals(const Protocol_MSG_CASHIER_CASHIN_NT_CONFIRM& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		transId == _o.transId;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_CONFIRM::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CASHIN_NT_CONFIRM).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("transId=");
		_buf.appendUint(transId);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_CONFIRM::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(transId);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_CONFIRM::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(transId);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_CONFIRM::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CASHIN_NT_CONFIRM";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 transId; _parser.parseUINT32(transId);
		AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    Cashier3DSecureRedirectionParams
//=================================================================

CashierServer::cli::Cashier3DSecureRedirectionParams::Cashier3DSecureRedirectionParams()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Cashier3DSecureRedirectionParams::Cashier3DSecureRedirectionParams(Cashier3DSecureRedirectionParams&& _o)
	: first(std::move(_o.first))
	, second(std::move(_o.second))
{
}

CashierServer::cli::Cashier3DSecureRedirectionParams& CashierServer::cli::Cashier3DSecureRedirectionParams::operator=(Cashier3DSecureRedirectionParams&& _o)
{
	if(this != &_o)
	{
		first = std::move(_o.first);
		second = std::move(_o.second);
	}
	return *this;
}

#endif

void CashierServer::cli::Cashier3DSecureRedirectionParams::clear()
{
	first.clear();
	second.clear();
}

bool CashierServer::cli::Cashier3DSecureRedirectionParams::equals(const Cashier3DSecureRedirectionParams& _o) const
{
	return first.equals(_o.first) &&
		second.equals(_o.second);
}

const char *CashierServer::cli::Cashier3DSecureRedirectionParams::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("first=");
	_buf.append(first);
	_buf.append(',');
	_buf.append("second=");
	_buf.append(second);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::Cashier3DSecureRedirectionParams::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(first);
	_msg.composeString(second);
}

void CashierServer::cli::Cashier3DSecureRedirectionParams::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(first);
	_parser.parseStringP(second);
}

/*static*/ void CashierServer::cli::Cashier3DSecureRedirectionParams::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "first"); size_t szFirst = strlen(_dummy);
	AtfValidator::validateInt(_descr, "first", szFirst, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "second"); size_t szSecond = strlen(_dummy);
	AtfValidator::validateInt(_descr, "second", szSecond, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    CashierCashinCompleteSpecificInfoBody
//=================================================================

CashierServer::cli::CashierCashinCompleteSpecificInfoBody::CashierCashinCompleteSpecificInfoBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::CashierCashinCompleteSpecificInfoBody::CashierCashinCompleteSpecificInfoBody(CashierCashinCompleteSpecificInfoBody&& _o)
	: type(std::move(_o.type))
	, text(std::move(_o.text))
{
}

CashierServer::cli::CashierCashinCompleteSpecificInfoBody& CashierServer::cli::CashierCashinCompleteSpecificInfoBody::operator=(CashierCashinCompleteSpecificInfoBody&& _o)
{
	if(this != &_o)
	{
		type = std::move(_o.type);
		text = std::move(_o.text);
	}
	return *this;
}

#endif

void CashierServer::cli::CashierCashinCompleteSpecificInfoBody::clear()
{
	type = 0;
	text.clear();
}

bool CashierServer::cli::CashierCashinCompleteSpecificInfoBody::equals(const CashierCashinCompleteSpecificInfoBody& _o) const
{
	return type == _o.type &&
		text.equals(_o.text);
}

const char *CashierServer::cli::CashierCashinCompleteSpecificInfoBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("type=");
	_buf.appendUint(type);
	if (type == eCashinCompleteSpecificInfo_UnverifiedPayment )
	{
		_buf.append(',');
	}
	else if (type == eCashinCompleteSpecificInfo_AdditionalText)
	{
		_buf.append(',');
		_buf.append("text=");
		_buf.append(text);
	}
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashierCashinCompleteSpecificInfoBody::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(type);
	if (type == eCashinCompleteSpecificInfo_UnverifiedPayment )
	{
		CommMsgBody _msg0;
		_msg.composeMsgBody(_msg0);
	}
	else if (type == eCashinCompleteSpecificInfo_AdditionalText)
	{
		CommMsgBody _msg1;
		_msg1.composeString(text);
		_msg.composeMsgBody(_msg1);
	}
}

void CashierServer::cli::CashierCashinCompleteSpecificInfoBody::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(type);
	if (type == eCashinCompleteSpecificInfo_UnverifiedPayment )
	{
		parseAnonymousMsgBody0(_parser);
	}
	else if (type == eCashinCompleteSpecificInfo_AdditionalText)
	{
		parseAnonymousMsgBody1(_parser);
	}
}

/*static*/ void CashierServer::cli::CashierCashinCompleteSpecificInfoBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 type = 0;
	_parser.parseUINT32(type);
	AtfValidator::validateInt(_descr, "type", type, _checker, __FILE__, __LINE__);
	if (type == eCashinCompleteSpecificInfo_UnverifiedPayment )
	{
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (type == eCashinCompleteSpecificInfo_AdditionalText)
	{
		validateAnonymousMsgBody1(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
}

void CashierServer::cli::CashierCashinCompleteSpecificInfoBody::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
}

/*static*/ void CashierServer::cli::CashierCashinCompleteSpecificInfoBody::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

void CashierServer::cli::CashierCashinCompleteSpecificInfoBody::parseAnonymousMsgBody1(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(text);
}

/*static*/ void CashierServer::cli::CashierCashinCompleteSpecificInfoBody::validateAnonymousMsgBody1(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "text"); size_t szText = strlen(_dummy);
	AtfValidator::validateInt(_descr, "text", szText, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_CASHIN_NT_COMPLETE
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_COMPLETE::Protocol_MSG_CASHIER_CASHIN_NT_COMPLETE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_COMPLETE::Protocol_MSG_CASHIER_CASHIN_NT_COMPLETE(Protocol_MSG_CASHIER_CASHIN_NT_COMPLETE&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, transId(std::move(_o.transId))
	, transStatusByte(std::move(_o.transStatusByte))
	, totalAmount(std::move(_o.totalAmount))
	, resultInfos(std::move(_o.resultInfos))
	, rejectExplanationCode(std::move(_o.rejectExplanationCode))
	, errorInfo(std::move(_o.errorInfo))
	, ntUrl(std::move(_o.ntUrl))
	, ntUrlMsg(std::move(_o.ntUrlMsg))
	, ntPhone(std::move(_o.ntPhone))
	, dadEligible(std::move(_o.dadEligible))
	, rejectMsg(std::move(_o.rejectMsg))
	, transBalanceCurrency(std::move(_o.transBalanceCurrency))
	, transConverted(std::move(_o.transConverted))
	, transCurrency(std::move(_o.transCurrency))
	, threeDSecureRedirectionParams(std::move(_o.threeDSecureRedirectionParams))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_COMPLETE& CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_COMPLETE::operator=(Protocol_MSG_CASHIER_CASHIN_NT_COMPLETE&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		transId = std::move(_o.transId);
		transStatusByte = std::move(_o.transStatusByte);
		totalAmount = std::move(_o.totalAmount);
		resultInfos = std::move(_o.resultInfos);
		rejectExplanationCode = std::move(_o.rejectExplanationCode);
		errorInfo = std::move(_o.errorInfo);
		ntUrl = std::move(_o.ntUrl);
		ntUrlMsg = std::move(_o.ntUrlMsg);
		ntPhone = std::move(_o.ntPhone);
		dadEligible = std::move(_o.dadEligible);
		rejectMsg = std::move(_o.rejectMsg);
		transBalanceCurrency = std::move(_o.transBalanceCurrency);
		transConverted = std::move(_o.transConverted);
		transCurrency = std::move(_o.transCurrency);
		threeDSecureRedirectionParams = std::move(_o.threeDSecureRedirectionParams);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_COMPLETE::clear()
{
	errCode = 0;
	errDescr.clear();
	transId = 0;
	transStatusByte = 0;
	totalAmount = 0;
	resultInfos.clear();
	rejectExplanationCode = 0;
	errorInfo.clear();
	ntUrl.clear();
	ntUrlMsg.clear();
	ntPhone.clear();
	dadEligible = false;
	rejectMsg.clear();
	transBalanceCurrency.clear();
	transConverted = 0;
	transCurrency.clear();
	threeDSecureRedirectionParams.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_COMPLETE::equals(const Protocol_MSG_CASHIER_CASHIN_NT_COMPLETE& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		transId == _o.transId &&
		transStatusByte == _o.transStatusByte &&
		totalAmount == _o.totalAmount &&
		resultInfos.equals(_o.resultInfos) &&
		rejectExplanationCode == _o.rejectExplanationCode &&
		errorInfo.equals(_o.errorInfo) &&
		ntUrl.equals(_o.ntUrl) &&
		ntUrlMsg.equals(_o.ntUrlMsg) &&
		ntPhone.equals(_o.ntPhone) &&
		dadEligible == _o.dadEligible &&
		rejectMsg.equals(_o.rejectMsg) &&
		transBalanceCurrency.equals(_o.transBalanceCurrency) &&
		transConverted == _o.transConverted &&
		transCurrency.equals(_o.transCurrency) &&
		threeDSecureRedirectionParams.equals(_o.threeDSecureRedirectionParams);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_COMPLETE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CASHIN_NT_COMPLETE).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("transId=");
		_buf.appendUint(transId);
		_buf.append(',');
		_buf.append("transStatusByte=");
		_buf.appendUint(transStatusByte);
		_buf.append(',');
		_buf.append("totalAmount=");
		_buf.appendInt(totalAmount);
		_buf.append(',');
		_buf.append("resultInfos=");
		resultInfos.toTraceString(_buf);
		_buf.append(',');
		_buf.append("rejectExplanationCode=");
		_buf.appendUint(rejectExplanationCode);
		_buf.append(',');
		_buf.append("errorInfo=");
		_buf.append(errorInfo);
		_buf.append(',');
		_buf.append("ntUrl=");
		_buf.append(ntUrl);
		_buf.append(',');
		_buf.append("ntUrlMsg=");
		_buf.append(ntUrlMsg);
		_buf.append(',');
		_buf.append("ntPhone=");
		_buf.append(ntPhone);
		_buf.append(',');
		_buf.append("dadEligible=");
		_buf.appendUint(dadEligible);
		_buf.append(',');
		_buf.append("rejectMsg=");
		_buf.append(rejectMsg);
		_buf.append(',');
		_buf.append("transBalanceCurrency=");
		_buf.append(transBalanceCurrency);
		_buf.append(',');
		_buf.append("transConverted=");
		_buf.appendInt(transConverted);
		_buf.append(',');
		_buf.append("transCurrency=");
		_buf.append(transCurrency);
		_buf.append(',');
		_buf.append("threeDSecureRedirectionParams=");
		threeDSecureRedirectionParams.toTraceString(_buf);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_COMPLETE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(transId);
		_msg.composeBYTE(transStatusByte);
		_msg.composeINT32(totalAmount);
		resultInfos.composeMsg(_msg);
		_msg.composeUINT32(rejectExplanationCode);
		_msg.composeString(errorInfo);
		_msg.composeString(ntUrl);
		_msg.composeString(ntUrlMsg);
		_msg.composeString(ntPhone);
		_msg.composeBOOL(dadEligible);
		_msg.composeString(rejectMsg);
		_msg.composeString(transBalanceCurrency);
		_msg.composeINT32(transConverted);
		_msg.composeString(transCurrency);
		threeDSecureRedirectionParams.composeMsg(_msg);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_COMPLETE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(transId);
		_parser.parseBYTE(transStatusByte);
		_parser.parseINT32(totalAmount);
		resultInfos.parseMsg(_parser);
		_parser.parseUINT32(rejectExplanationCode);
		_parser.parseStringP(errorInfo);
		_parser.parseStringP(ntUrl);
		_parser.parseStringP(ntUrlMsg);
		_parser.parseStringP(ntPhone);
		_parser.parseBOOL(dadEligible);
		_parser.parseStringP(rejectMsg);
		_parser.parseStringP(transBalanceCurrency);
		_parser.parseINT32(transConverted);
		_parser.parseStringP(transCurrency);
		threeDSecureRedirectionParams.parseMsg(_parser);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_NT_COMPLETE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CASHIN_NT_COMPLETE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 transId; _parser.parseUINT32(transId);
		AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
		BYTE transStatusByte; _parser.parseBYTE(transStatusByte);
		AtfValidator::validateInt(_descr, "transStatusByte", transStatusByte, _checker, __FILE__, __LINE__);
		INT32 totalAmount; _parser.parseINT32(totalAmount);
		AtfValidator::validateInt(_descr, "totalAmount", totalAmount, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szResultInfos = ThinAtf::LAtfVector< ResultInfos, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("resultInfos"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "resultInfos", szResultInfos, _checker, __FILE__, __LINE__);
		UINT32 rejectExplanationCode; _parser.parseUINT32(rejectExplanationCode);
		AtfValidator::validateInt(_descr, "rejectExplanationCode", rejectExplanationCode, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "errorInfo"); size_t szErrorInfo = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errorInfo", szErrorInfo, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "ntUrl"); size_t szNtUrl = strlen(_dummy);
		AtfValidator::validateInt(_descr, "ntUrl", szNtUrl, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "ntUrlMsg"); size_t szNtUrlMsg = strlen(_dummy);
		AtfValidator::validateInt(_descr, "ntUrlMsg", szNtUrlMsg, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "ntPhone"); size_t szNtPhone = strlen(_dummy);
		AtfValidator::validateInt(_descr, "ntPhone", szNtPhone, _checker, __FILE__, __LINE__);
		bool dadEligible; _parser.parseBOOL(dadEligible);
		AtfValidator::validateInt(_descr, "dadEligible", dadEligible, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "rejectMsg"); size_t szRejectMsg = strlen(_dummy);
		AtfValidator::validateInt(_descr, "rejectMsg", szRejectMsg, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "transBalanceCurrency"); size_t szTransBalanceCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "transBalanceCurrency", szTransBalanceCurrency, _checker, __FILE__, __LINE__);
		INT32 transConverted; _parser.parseINT32(transConverted);
		AtfValidator::validateInt(_descr, "transConverted", transConverted, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "transCurrency"); size_t szTransCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "transCurrency", szTransCurrency, _checker, __FILE__, __LINE__);
		int szThreeDSecureRedirectionParams = ThinAtf::LAtfVector< Cashier3DSecureRedirectionParams, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("threeDSecureRedirectionParams"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "threeDSecureRedirectionParams", szThreeDSecureRedirectionParams, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CASHIN_CC_REDIRECTED
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_REDIRECTED::Protocol_MSG_CASHIER_CASHIN_CC_REDIRECTED()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_REDIRECTED::Protocol_MSG_CASHIER_CASHIN_CC_REDIRECTED(Protocol_MSG_CASHIER_CASHIN_CC_REDIRECTED&& _o)
	: transId(std::move(_o.transId))
	, amount(std::move(_o.amount))
	, isError(std::move(_o.isError))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_REDIRECTED& CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_REDIRECTED::operator=(Protocol_MSG_CASHIER_CASHIN_CC_REDIRECTED&& _o)
{
	if(this != &_o)
	{
		transId = std::move(_o.transId);
		amount = std::move(_o.amount);
		isError = std::move(_o.isError);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_REDIRECTED::clear()
{
	transId = 0;
	amount = 0;
	isError = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_REDIRECTED::equals(const Protocol_MSG_CASHIER_CASHIN_CC_REDIRECTED& _o) const
{
	return transId == _o.transId &&
		amount == _o.amount &&
		isError == _o.isError &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_REDIRECTED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CASHIN_CC_REDIRECTED).append(")");
	_buf.append(',');
	_buf.append("transId=");
	_buf.appendUint(transId);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendInt(amount);
	_buf.append(',');
	_buf.append("isError=");
	_buf.appendInt(isError);
	_buf.append(',');
	_buf.append("errDescr=");
	_buf.append(errDescr);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_REDIRECTED::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(transId);
	_msg.composeINT32(amount);
	_msg.composeINT32(isError);
	_msg.composeString(errDescr);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_REDIRECTED::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(transId);
	_parser.parseINT32(amount);
	_parser.parseINT32(isError);
	_parser.parseStringP(errDescr);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_CC_REDIRECTED::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CASHIN_CC_REDIRECTED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 transId; _parser.parseUINT32(transId);
	AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	INT32 amount; _parser.parseINT32(amount);
	AtfValidator::validateIntRange(_descr, "amount", amount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	INT32 isError; _parser.parseINT32(isError);
	AtfValidator::validateIntRange(_descr, "isError", isError, 0, 1, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "errDescr", szErrDescr, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_PRE_CASHOUT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT::Protocol_MSG_CASHIER_PRE_CASHOUT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT::Protocol_MSG_CASHIER_PRE_CASHOUT(Protocol_MSG_CASHIER_PRE_CASHOUT&& _o)
	: userId(std::move(_o.userId))
	, cashoutAmount(std::move(_o.cashoutAmount))
	, balanceCurrency(std::move(_o.balanceCurrency))
	, isForFTPkr(std::move(_o.isForFTPkr))
	, userRollbackOption(std::move(_o.userRollbackOption))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT& CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT::operator=(Protocol_MSG_CASHIER_PRE_CASHOUT&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		cashoutAmount = std::move(_o.cashoutAmount);
		balanceCurrency = std::move(_o.balanceCurrency);
		isForFTPkr = std::move(_o.isForFTPkr);
		userRollbackOption = std::move(_o.userRollbackOption);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT::clear()
{
	userId.clear();
	cashoutAmount = 0;
	balanceCurrency.clear();
	isForFTPkr = false;
	userRollbackOption = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT::equals(const Protocol_MSG_CASHIER_PRE_CASHOUT& _o) const
{
	return userId.equals(_o.userId) &&
		cashoutAmount == _o.cashoutAmount &&
		balanceCurrency.equals(_o.balanceCurrency) &&
		isForFTPkr == _o.isForFTPkr &&
		userRollbackOption == _o.userRollbackOption;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PRE_CASHOUT).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("cashoutAmount=");
	_buf.appendInt(cashoutAmount);
	_buf.append(',');
	_buf.append("balanceCurrency=");
	_buf.append(balanceCurrency);
	_buf.append(',');
	_buf.append("isForFTPkr=");
	_buf.appendUint(isForFTPkr);
	_buf.append(',');
	_buf.append("userRollbackOption=");
	_buf.appendUint(userRollbackOption);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeINT32(cashoutAmount);
	_msg.composeString(balanceCurrency);
	_msg.composeBOOL(isForFTPkr);
	_msg.composeBYTE(userRollbackOption);
}

void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseINT32(cashoutAmount);
	_parser.parseStringP(balanceCurrency);
	_parser.parseBOOL(isForFTPkr);
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(userRollbackOption);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PRE_CASHOUT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	INT32 cashoutAmount; _parser.parseINT32(cashoutAmount);
	AtfValidator::validateIntRange(_descr, "cashoutAmount", cashoutAmount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "balanceCurrency"); size_t szBalanceCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "balanceCurrency", szBalanceCurrency, 7, _checker, __FILE__, __LINE__);
	bool isForFTPkr; _parser.parseBOOL(isForFTPkr);
	AtfValidator::validateInt(_descr, "isForFTPkr", isForFTPkr, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	BYTE userRollbackOption; _parser.parseBYTE(userRollbackOption);
	AtfValidator::validateInt(_descr, "userRollbackOption", userRollbackOption, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CardRollback
//=================================================================

CashierServer::cli::CardRollback::CardRollback()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::CardRollback::CardRollback(CardRollback&& _o)
	: cardType(std::move(_o.cardType))
	, cardMasked(std::move(_o.cardMasked))
	, amount(std::move(_o.amount))
{
}

CashierServer::cli::CardRollback& CashierServer::cli::CardRollback::operator=(CardRollback&& _o)
{
	if(this != &_o)
	{
		cardType = std::move(_o.cardType);
		cardMasked = std::move(_o.cardMasked);
		amount = std::move(_o.amount);
	}
	return *this;
}

#endif

void CashierServer::cli::CardRollback::clear()
{
	cardType.clear();
	cardMasked.clear();
	amount = 0;
}

bool CashierServer::cli::CardRollback::equals(const CardRollback& _o) const
{
	return cardType.equals(_o.cardType) &&
		cardMasked.equals(_o.cardMasked) &&
		amount == _o.amount;
}

const char *CashierServer::cli::CardRollback::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("cardType=");
	_buf.append(cardType);
	_buf.append(',');
	_buf.append("cardMasked=");
	_buf.append(cardMasked);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendInt(amount);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CardRollback::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(cardType);
	_msg.composeString(cardMasked);
	_msg.composeINT32(amount);
}

void CashierServer::cli::CardRollback::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(cardType);
	_parser.parseStringP(cardMasked);
	_parser.parseINT32(amount);
}

/*static*/ void CashierServer::cli::CardRollback::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "cardType"); size_t szCardType = strlen(_dummy);
	AtfValidator::validateInt(_descr, "cardType", szCardType, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "cardMasked"); size_t szCardMasked = strlen(_dummy);
	AtfValidator::validateInt(_descr, "cardMasked", szCardMasked, _checker, __FILE__, __LINE__);
	INT32 amount; _parser.parseINT32(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    CardRollbackExtBody
//=================================================================

CashierServer::cli::CardRollbackExtBody::CardRollbackExtBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::CardRollbackExtBody::CardRollbackExtBody(CardRollbackExtBody&& _o)
	: cardType(std::move(_o.cardType))
	, cardMasked(std::move(_o.cardMasked))
	, amount(std::move(_o.amount))
	, cardTypeByte(std::move(_o.cardTypeByte))
	, convRate64(std::move(_o.convRate64))
	, cardCurrency(std::move(_o.cardCurrency))
	, processorAmount(std::move(_o.processorAmount))
	, cardId(std::move(_o.cardId))
	, flagsForClient(std::move(_o.flagsForClient))
{
}

CashierServer::cli::CardRollbackExtBody& CashierServer::cli::CardRollbackExtBody::operator=(CardRollbackExtBody&& _o)
{
	if(this != &_o)
	{
		cardType = std::move(_o.cardType);
		cardMasked = std::move(_o.cardMasked);
		amount = std::move(_o.amount);
		cardTypeByte = std::move(_o.cardTypeByte);
		convRate64 = std::move(_o.convRate64);
		cardCurrency = std::move(_o.cardCurrency);
		processorAmount = std::move(_o.processorAmount);
		cardId = std::move(_o.cardId);
		flagsForClient = std::move(_o.flagsForClient);
	}
	return *this;
}

#endif

void CashierServer::cli::CardRollbackExtBody::clear()
{
	cardType.clear();
	cardMasked.clear();
	amount = 0;
	cardTypeByte = 0;
	convRate64 = 0;
	cardCurrency.clear();
	processorAmount = 0;
	cardId = 0;
	flagsForClient = 0;
}

bool CashierServer::cli::CardRollbackExtBody::equals(const CardRollbackExtBody& _o) const
{
	return cardType.equals(_o.cardType) &&
		cardMasked.equals(_o.cardMasked) &&
		amount == _o.amount &&
		cardTypeByte == _o.cardTypeByte &&
		convRate64 == _o.convRate64 &&
		cardCurrency.equals(_o.cardCurrency) &&
		processorAmount == _o.processorAmount &&
		cardId == _o.cardId &&
		flagsForClient == _o.flagsForClient;
}

const char *CashierServer::cli::CardRollbackExtBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("cardType=");
	_buf.append(cardType);
	_buf.append(',');
	_buf.append("cardMasked=");
	_buf.append(cardMasked);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendInt(amount);
	_buf.append(',');
	_buf.append("cardTypeByte=");
	_buf.appendUint(cardTypeByte);
	_buf.append(',');
	_buf.append("convRate64=");
	_buf.appendInt64(convRate64);
	_buf.append(',');
	_buf.append("cardCurrency=");
	_buf.append(cardCurrency);
	_buf.append(',');
	_buf.append("processorAmount=");
	_buf.appendInt(processorAmount);
	_buf.append(',');
	_buf.append("cardId=");
	_buf.appendUint(cardId);
	_buf.append(',');
	_buf.append("flagsForClient=");
	_buf.appendUint(flagsForClient);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CardRollbackExtBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CardRollbackExtBody())) // not empty
	{
		_body.composeString(cardType);
		_body.composeString(cardMasked);
		_body.composeINT32(amount);
		_body.composeBYTE(cardTypeByte);
		_body.composeINT64(convRate64);
		_body.composeString(cardCurrency);
		_body.composeINT32(processorAmount);
		_body.composeUINT32(cardId);
		_body.composeUINT32(flagsForClient);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CardRollbackExtBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(cardType);
	_parser0.parseStringP(cardMasked);
	_parser0.parseINT32(amount);
	_parser0.parseBYTE(cardTypeByte);
	_parser0.parseINT64(convRate64);
	_parser0.parseStringP(cardCurrency);
	_parser0.parseINT32(processorAmount);
	_parser0.parseUINT32(cardId);
	_parser0.parseUINT32(flagsForClient);
}

/*static*/ void CashierServer::cli::CardRollbackExtBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "cardType"); size_t szCardType = strlen(_dummy);
	AtfValidator::validateInt(_descr, "cardType", szCardType, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "cardMasked"); size_t szCardMasked = strlen(_dummy);
	AtfValidator::validateInt(_descr, "cardMasked", szCardMasked, _checker, __FILE__, __LINE__);
	INT32 amount; _parser0.parseINT32(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	BYTE cardTypeByte; _parser0.parseBYTE(cardTypeByte);
	AtfValidator::validateInt(_descr, "cardTypeByte", cardTypeByte, _checker, __FILE__, __LINE__);
	INT64 convRate64; _parser0.parseINT64(convRate64);
	AtfValidator::validateInt(_descr, "convRate64", convRate64, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "cardCurrency"); size_t szCardCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "cardCurrency", szCardCurrency, _checker, __FILE__, __LINE__);
	INT32 processorAmount; _parser0.parseINT32(processorAmount);
	AtfValidator::validateInt(_descr, "processorAmount", processorAmount, _checker, __FILE__, __LINE__);
	UINT32 cardId; _parser0.parseUINT32(cardId);
	AtfValidator::validateInt(_descr, "cardId", cardId, _checker, __FILE__, __LINE__);
	UINT32 flagsForClient; _parser0.parseUINT32(flagsForClient);
	AtfValidator::validateInt(_descr, "flagsForClient", flagsForClient, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CashoutOptionBody
//=================================================================

CashierServer::cli::CashoutOptionBody::CashoutOptionBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::CashoutOptionBody::CashoutOptionBody(CashoutOptionBody&& _o)
	: cardTypeByte(std::move(_o.cardTypeByte))
	, when(std::move(_o.when))
	, maskedReference(std::move(_o.maskedReference))
	, currCode(std::move(_o.currCode))
	, convRate(std::move(_o.convRate))
	, isAllowed(std::move(_o.isAllowed))
	, limitAmount(std::move(_o.limitAmount))
	, explanation(std::move(_o.explanation))
	, psForCashoutI18n(std::move(_o.psForCashoutI18n))
	, coConvRate(std::move(_o.coConvRate))
	, additionalText(std::move(_o.additionalText))
	, isTagged(std::move(_o.isTagged))
	, cardId(std::move(_o.cardId))
	, coFlagsForClient(std::move(_o.coFlagsForClient))
{
}

CashierServer::cli::CashoutOptionBody& CashierServer::cli::CashoutOptionBody::operator=(CashoutOptionBody&& _o)
{
	if(this != &_o)
	{
		cardTypeByte = std::move(_o.cardTypeByte);
		when = std::move(_o.when);
		maskedReference = std::move(_o.maskedReference);
		currCode = std::move(_o.currCode);
		convRate = std::move(_o.convRate);
		isAllowed = std::move(_o.isAllowed);
		limitAmount = std::move(_o.limitAmount);
		explanation = std::move(_o.explanation);
		psForCashoutI18n = std::move(_o.psForCashoutI18n);
		coConvRate = std::move(_o.coConvRate);
		additionalText = std::move(_o.additionalText);
		isTagged = std::move(_o.isTagged);
		cardId = std::move(_o.cardId);
		coFlagsForClient = std::move(_o.coFlagsForClient);
	}
	return *this;
}

#endif

void CashierServer::cli::CashoutOptionBody::clear()
{
	cardTypeByte = 0;
	when.setNull();
	maskedReference.clear();
	currCode.clear();
	convRate = 0;
	isAllowed = false;
	limitAmount = 0;
	explanation.clear();
	psForCashoutI18n.clear();
	coConvRate = 0;
	additionalText.clear();
	isTagged = false;
	cardId = 0;
	coFlagsForClient = 0;
}

bool CashierServer::cli::CashoutOptionBody::equals(const CashoutOptionBody& _o) const
{
	return cardTypeByte == _o.cardTypeByte &&
		when.equals(_o.when) &&
		maskedReference.equals(_o.maskedReference) &&
		currCode.equals(_o.currCode) &&
		convRate == _o.convRate &&
		isAllowed == _o.isAllowed &&
		limitAmount == _o.limitAmount &&
		explanation.equals(_o.explanation) &&
		psForCashoutI18n.equals(_o.psForCashoutI18n) &&
		coConvRate == _o.coConvRate &&
		additionalText.equals(_o.additionalText) &&
		isTagged == _o.isTagged &&
		cardId == _o.cardId &&
		coFlagsForClient == _o.coFlagsForClient;
}

const char *CashierServer::cli::CashoutOptionBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("cardTypeByte=");
	_buf.appendUint(cardTypeByte);
	_buf.append(',');
	_buf.append("when=");
	ThinAtf::AtfTempl<CommSrvTime>::ToTraceString(_buf, when);
	_buf.append(',');
	_buf.append("maskedReference=");
	_buf.append(maskedReference);
	_buf.append(',');
	_buf.append("currCode=");
	_buf.append(currCode);
	_buf.append(',');
	_buf.append("convRate=");
	_buf.appendUint(convRate);
	_buf.append(',');
	_buf.append("isAllowed=");
	_buf.appendUint(isAllowed);
	_buf.append(',');
	_buf.append("limitAmount=");
	_buf.appendInt(limitAmount);
	_buf.append(',');
	_buf.append("explanation=");
	_buf.append(explanation);
	_buf.append(',');
	_buf.append("psForCashoutI18n=");
	_buf.append(psForCashoutI18n);
	_buf.append(',');
	_buf.append("coConvRate=");
	_buf.appendInt64(coConvRate);
	_buf.append(',');
	_buf.append("additionalText=");
	_buf.append(additionalText);
	_buf.append(',');
	_buf.append("isTagged=");
	_buf.appendUint(isTagged);
	_buf.append(',');
	_buf.append("cardId=");
	_buf.appendUint(cardId);
	_buf.append(',');
	_buf.append("coFlagsForClient=");
	_buf.appendUint(coFlagsForClient);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashoutOptionBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CashoutOptionBody())) // not empty
	{
		_body.composeBYTE(cardTypeByte);
		_body.composeSrvTime(when);
		_body.composeString(maskedReference);
		_body.composeString(currCode);
		_body.composeUINT32(convRate);
		_body.composeBOOL(isAllowed);
		_body.composeINT32(limitAmount);
		_body.composeString(explanation);
		_body.composeString(psForCashoutI18n);
		_body.composeINT64(coConvRate);
		_body.composeString(additionalText);
		_body.composeBOOL(isTagged);
		_body.composeUINT32(cardId);
		_body.composeUINT32(coFlagsForClient);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashoutOptionBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(cardTypeByte);
	_parser0.parseSrvTime(when);
	_parser0.parseStringP(maskedReference);
	_parser0.parseStringP(currCode);
	_parser0.parseUINT32(convRate);
	_parser0.parseBOOL(isAllowed);
	_parser0.parseINT32(limitAmount);
	_parser0.parseStringP(explanation);
	_parser0.parseStringP(psForCashoutI18n);
	_parser0.parseINT64(coConvRate);
	_parser0.parseStringP(additionalText);
	_parser0.parseBOOL(isTagged);
	_parser0.parseUINT32(cardId);
	_parser0.parseUINT32(coFlagsForClient);
}

/*static*/ void CashierServer::cli::CashoutOptionBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	BYTE cardTypeByte; _parser0.parseBYTE(cardTypeByte);
	AtfValidator::validateInt(_descr, "cardTypeByte", cardTypeByte, _checker, __FILE__, __LINE__);
	CommSrvTime when; _parser0.parseSrvTime(when);
	AtfValidator::validateSrvDateTime(_descr, "when", when, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "maskedReference"); size_t szMaskedReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "maskedReference", szMaskedReference, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currCode"); size_t szCurrCode = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currCode", szCurrCode, _checker, __FILE__, __LINE__);
	UINT32 convRate; _parser0.parseUINT32(convRate);
	AtfValidator::validateInt(_descr, "convRate", convRate, _checker, __FILE__, __LINE__);
	bool isAllowed; _parser0.parseBOOL(isAllowed);
	AtfValidator::validateInt(_descr, "isAllowed", isAllowed, _checker, __FILE__, __LINE__);
	INT32 limitAmount; _parser0.parseINT32(limitAmount);
	AtfValidator::validateInt(_descr, "limitAmount", limitAmount, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "explanation"); size_t szExplanation = strlen(_dummy);
	AtfValidator::validateInt(_descr, "explanation", szExplanation, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "psForCashoutI18n"); size_t szPsForCashoutI18n = strlen(_dummy);
	AtfValidator::validateInt(_descr, "psForCashoutI18n", szPsForCashoutI18n, _checker, __FILE__, __LINE__);
	INT64 coConvRate; _parser0.parseINT64(coConvRate);
	AtfValidator::validateInt(_descr, "coConvRate", coConvRate, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "additionalText"); size_t szAdditionalText = strlen(_dummy);
	AtfValidator::validateInt(_descr, "additionalText", szAdditionalText, _checker, __FILE__, __LINE__);
	bool isTagged; _parser0.parseBOOL(isTagged);
	AtfValidator::validateInt(_descr, "isTagged", isTagged, _checker, __FILE__, __LINE__);
	UINT32 cardId; _parser0.parseUINT32(cardId);
	AtfValidator::validateInt(_descr, "cardId", cardId, _checker, __FILE__, __LINE__);
	UINT32 coFlagsForClient; _parser0.parseUINT32(coFlagsForClient);
	AtfValidator::validateInt(_descr, "coFlagsForClient", coFlagsForClient, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_PRE_CASHOUT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT_REPLY::Protocol_MSG_CASHIER_PRE_CASHOUT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT_REPLY::Protocol_MSG_CASHIER_PRE_CASHOUT_REPLY(Protocol_MSG_CASHIER_PRE_CASHOUT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, needsBonusWarning(std::move(_o.needsBonusWarning))
	, bonusName(std::move(_o.bonusName))
	, bonusUrl(std::move(_o.bonusUrl))
	, bonusPercent(std::move(_o.bonusPercent))
	, bonusMaxAmount(std::move(_o.bonusMaxAmount))
	, estimatedRollback(std::move(_o.estimatedRollback))
	, zero(std::move(_o.zero))
	, userPhone(std::move(_o.userPhone))
	, zero2(std::move(_o.zero2))
	, rollbacks(std::move(_o.rollbacks))
	, cashoutOptions(std::move(_o.cashoutOptions))
	, rollbacksExt(std::move(_o.rollbacksExt))
	, preCashoutReplyFlags(std::move(_o.preCashoutReplyFlags))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT_REPLY::operator=(Protocol_MSG_CASHIER_PRE_CASHOUT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		needsBonusWarning = std::move(_o.needsBonusWarning);
		bonusName = std::move(_o.bonusName);
		bonusUrl = std::move(_o.bonusUrl);
		bonusPercent = std::move(_o.bonusPercent);
		bonusMaxAmount = std::move(_o.bonusMaxAmount);
		estimatedRollback = std::move(_o.estimatedRollback);
		zero = std::move(_o.zero);
		userPhone = std::move(_o.userPhone);
		zero2 = std::move(_o.zero2);
		rollbacks = std::move(_o.rollbacks);
		cashoutOptions = std::move(_o.cashoutOptions);
		rollbacksExt = std::move(_o.rollbacksExt);
		preCashoutReplyFlags = std::move(_o.preCashoutReplyFlags);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	needsBonusWarning = 0;
	bonusName.clear();
	bonusUrl.clear();
	bonusPercent = 0;
	bonusMaxAmount = 0;
	estimatedRollback = 0;
	zero = 0;
	userPhone.clear();
	zero2 = 0;
	rollbacks.clear();
	cashoutOptions.clear();
	rollbacksExt.clear();
	preCashoutReplyFlags = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT_REPLY::equals(const Protocol_MSG_CASHIER_PRE_CASHOUT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		needsBonusWarning == _o.needsBonusWarning &&
		bonusName.equals(_o.bonusName) &&
		bonusUrl.equals(_o.bonusUrl) &&
		bonusPercent == _o.bonusPercent &&
		bonusMaxAmount == _o.bonusMaxAmount &&
		estimatedRollback == _o.estimatedRollback &&
		zero == _o.zero &&
		userPhone.equals(_o.userPhone) &&
		zero2 == _o.zero2 &&
		rollbacks.equals(_o.rollbacks) &&
		cashoutOptions.equals(_o.cashoutOptions) &&
		rollbacksExt.equals(_o.rollbacksExt) &&
		preCashoutReplyFlags == _o.preCashoutReplyFlags;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PRE_CASHOUT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("needsBonusWarning=");
		_buf.appendUint(needsBonusWarning);
		_buf.append(',');
		_buf.append("bonusName=");
		_buf.append(bonusName);
		_buf.append(',');
		_buf.append("bonusUrl=");
		_buf.append(bonusUrl);
		_buf.append(',');
		_buf.append("bonusPercent=");
		_buf.appendInt(bonusPercent);
		_buf.append(',');
		_buf.append("bonusMaxAmount=");
		_buf.appendInt(bonusMaxAmount);
		_buf.append(',');
		_buf.append("estimatedRollback=");
		_buf.appendInt(estimatedRollback);
		_buf.append(',');
		_buf.append("zero=");
		_buf.appendInt(zero);
		_buf.append(',');
		_buf.append("userPhone=");
		_buf.append(userPhone);
		_buf.append(',');
		_buf.append("zero2=");
		_buf.appendInt(zero2);
		_buf.append(',');
		_buf.append("rollbacks=");
		rollbacks.toTraceString(_buf);
		_buf.append(',');
		_buf.append("cashoutOptions=");
		cashoutOptions.toTraceString(_buf);
		_buf.append(',');
		_buf.append("rollbacksExt=");
		rollbacksExt.toTraceString(_buf);
		_buf.append(',');
		_buf.append("preCashoutReplyFlags=");
		_buf.appendUint(preCashoutReplyFlags);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeBYTE(needsBonusWarning);
		_msg.composeString(bonusName);
		_msg.composeString(bonusUrl);
		_msg.composeINT32(bonusPercent);
		_msg.composeINT32(bonusMaxAmount);
		_msg.composeINT32(estimatedRollback);
		_msg.composeINT16(zero);
		_msg.composeString(userPhone);
		_msg.composeINT16(zero2);
		rollbacks.composeMsg(_msg);
		cashoutOptions.composeMsg(_msg);
		rollbacksExt.composeMsg(_msg);
		_msg.composeUINT32(preCashoutReplyFlags);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseBYTE(needsBonusWarning);
		_parser.parseStringP(bonusName);
		_parser.parseStringP(bonusUrl);
		_parser.parseINT32(bonusPercent);
		_parser.parseINT32(bonusMaxAmount);
		_parser.parseINT32(estimatedRollback);
		_parser.parseINT16(zero);
		_parser.parseStringP(userPhone);
		_parser.parseINT16(zero2);
		rollbacks.parseMsg(_parser);
		cashoutOptions.parseMsg(_parser);
		rollbacksExt.parseMsg(_parser);
		_parser.parseUINT32(preCashoutReplyFlags);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PRE_CASHOUT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PRE_CASHOUT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		BYTE needsBonusWarning; _parser.parseBYTE(needsBonusWarning);
		AtfValidator::validateInt(_descr, "needsBonusWarning", needsBonusWarning, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "bonusName"); size_t szBonusName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "bonusName", szBonusName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "bonusUrl"); size_t szBonusUrl = strlen(_dummy);
		AtfValidator::validateInt(_descr, "bonusUrl", szBonusUrl, _checker, __FILE__, __LINE__);
		INT32 bonusPercent; _parser.parseINT32(bonusPercent);
		AtfValidator::validateInt(_descr, "bonusPercent", bonusPercent, _checker, __FILE__, __LINE__);
		INT32 bonusMaxAmount; _parser.parseINT32(bonusMaxAmount);
		AtfValidator::validateInt(_descr, "bonusMaxAmount", bonusMaxAmount, _checker, __FILE__, __LINE__);
		INT32 estimatedRollback; _parser.parseINT32(estimatedRollback);
		AtfValidator::validateInt(_descr, "estimatedRollback", estimatedRollback, _checker, __FILE__, __LINE__);
		INT16 zero; _parser.parseINT16(zero);
		AtfValidator::validateInt(_descr, "zero", zero, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "userPhone"); size_t szUserPhone = strlen(_dummy);
		AtfValidator::validateInt(_descr, "userPhone", szUserPhone, _checker, __FILE__, __LINE__);
		INT16 zero2; _parser.parseINT16(zero2);
		AtfValidator::validateInt(_descr, "zero2", zero2, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szRollbacks = ThinAtf::LAtfVector< CardRollback, 2 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("rollbacks"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "rollbacks", szRollbacks, _checker, __FILE__, __LINE__);
		int szCashoutOptions = ThinAtf::LAtfVector< CashoutOptionBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cashoutOptions"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "cashoutOptions", szCashoutOptions, _checker, __FILE__, __LINE__);
		int szRollbacksExt = ThinAtf::LAtfVector< CardRollbackExtBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("rollbacksExt"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "rollbacksExt", szRollbacksExt, _checker, __FILE__, __LINE__);
		UINT32 preCashoutReplyFlags; _parser.parseUINT32(preCashoutReplyFlags);
		AtfValidator::validateInt(_descr, "preCashoutReplyFlags", preCashoutReplyFlags, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_VIP_INFO
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO::Protocol_MSG_CASHIER_VIP_INFO()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO::Protocol_MSG_CASHIER_VIP_INFO(Protocol_MSG_CASHIER_VIP_INFO&& _o)
	: userId(std::move(_o.userId))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO& CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO::operator=(Protocol_MSG_CASHIER_VIP_INFO&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO::clear()
{
	userId.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO::equals(const Protocol_MSG_CASHIER_VIP_INFO& _o) const
{
	return userId.equals(_o.userId);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_VIP_INFO).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
}

void CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_VIP_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    VipLevelBody
//=================================================================

CashierServer::cli::VipLevelBody::VipLevelBody()
{
	clear();
}

void CashierServer::cli::VipLevelBody::clear()
{
	statusId = 0;
	type = 0;
	minFpp = 0;
	fppBonusRate = 0;
	vipToKeepYearlyStatus = 0;
	lastMonthForYearly = 0;
	missableMonthsYearly = 0;
}

bool CashierServer::cli::VipLevelBody::equals(const VipLevelBody& _o) const
{
	return statusId == _o.statusId &&
		type == _o.type &&
		minFpp == _o.minFpp &&
		fppBonusRate == _o.fppBonusRate &&
		vipToKeepYearlyStatus == _o.vipToKeepYearlyStatus &&
		lastMonthForYearly == _o.lastMonthForYearly &&
		missableMonthsYearly == _o.missableMonthsYearly;
}

const char *CashierServer::cli::VipLevelBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("statusId=");
	_buf.appendInt(statusId);
	_buf.append(',');
	_buf.append("type=");
	_buf.appendInt(type);
	_buf.append(',');
	_buf.append("minFpp=");
	_buf.appendInt(minFpp);
	_buf.append(',');
	_buf.append("fppBonusRate=");
	_buf.appendInt(fppBonusRate);
	_buf.append(',');
	_buf.append("vipToKeepYearlyStatus=");
	_buf.appendInt(vipToKeepYearlyStatus);
	_buf.append(',');
	_buf.append("lastMonthForYearly=");
	_buf.appendInt(lastMonthForYearly);
	_buf.append(',');
	_buf.append("missableMonthsYearly=");
	_buf.appendInt(missableMonthsYearly);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::VipLevelBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(VipLevelBody())) // not empty
	{
		_body.composeINT32(statusId);
		_body.composeINT32(type);
		_body.composeINT32(minFpp);
		_body.composeINT32(fppBonusRate);
		_body.composeINT32(vipToKeepYearlyStatus);
		_body.composeINT32(lastMonthForYearly);
		_body.composeINT32(missableMonthsYearly);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::VipLevelBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(statusId);
	_parser0.parseINT32(type);
	_parser0.parseINT32(minFpp);
	_parser0.parseINT32(fppBonusRate);
	_parser0.parseINT32(vipToKeepYearlyStatus);
	_parser0.parseINT32(lastMonthForYearly);
	_parser0.parseINT32(missableMonthsYearly);
}

/*static*/ void CashierServer::cli::VipLevelBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 statusId; _parser0.parseINT32(statusId);
	AtfValidator::validateInt(_descr, "statusId", statusId, _checker, __FILE__, __LINE__);
	INT32 type; _parser0.parseINT32(type);
	AtfValidator::validateInt(_descr, "type", type, _checker, __FILE__, __LINE__);
	INT32 minFpp; _parser0.parseINT32(minFpp);
	AtfValidator::validateInt(_descr, "minFpp", minFpp, _checker, __FILE__, __LINE__);
	INT32 fppBonusRate; _parser0.parseINT32(fppBonusRate);
	AtfValidator::validateInt(_descr, "fppBonusRate", fppBonusRate, _checker, __FILE__, __LINE__);
	INT32 vipToKeepYearlyStatus; _parser0.parseINT32(vipToKeepYearlyStatus);
	AtfValidator::validateInt(_descr, "vipToKeepYearlyStatus", vipToKeepYearlyStatus, _checker, __FILE__, __LINE__);
	INT32 lastMonthForYearly; _parser0.parseINT32(lastMonthForYearly);
	AtfValidator::validateInt(_descr, "lastMonthForYearly", lastMonthForYearly, _checker, __FILE__, __LINE__);
	INT32 missableMonthsYearly; _parser0.parseINT32(missableMonthsYearly);
	AtfValidator::validateInt(_descr, "missableMonthsYearly", missableMonthsYearly, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    StellarBonusLevel
//=================================================================

CashierServer::cli::StellarBonusLevel::StellarBonusLevel()
{
	clear();
}

void CashierServer::cli::StellarBonusLevel::clear()
{
	groupId = 0;
	vppThreshold = 0;
	amount = 0;
}

bool CashierServer::cli::StellarBonusLevel::equals(const StellarBonusLevel& _o) const
{
	return groupId == _o.groupId &&
		vppThreshold == _o.vppThreshold &&
		amount == _o.amount;
}

const char *CashierServer::cli::StellarBonusLevel::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("groupId=");
	_buf.appendUint(groupId);
	_buf.append(',');
	_buf.append("vppThreshold=");
	_buf.appendInt(vppThreshold);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendInt(amount);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::StellarBonusLevel::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(groupId);
	_msg.composeINT32(vppThreshold);
	_msg.composeINT32(amount);
}

void CashierServer::cli::StellarBonusLevel::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(groupId);
	_parser.parseINT32(vppThreshold);
	_parser.parseINT32(amount);
}

/*static*/ void CashierServer::cli::StellarBonusLevel::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 groupId; _parser.parseUINT32(groupId);
	AtfValidator::validateInt(_descr, "groupId", groupId, _checker, __FILE__, __LINE__);
	INT32 vppThreshold; _parser.parseINT32(vppThreshold);
	AtfValidator::validateInt(_descr, "vppThreshold", vppThreshold, _checker, __FILE__, __LINE__);
	INT32 amount; _parser.parseINT32(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_CASHIER_VIP_INFO_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO_REPLY::Protocol_MSG_CASHIER_VIP_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO_REPLY::Protocol_MSG_CASHIER_VIP_INFO_REPLY(Protocol_MSG_CASHIER_VIP_INFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, zero(std::move(_o.zero))
	, lastMonthForYearlyOld(std::move(_o.lastMonthForYearlyOld))
	, stellarBonuses(std::move(_o.stellarBonuses))
	, previousYearVPP(std::move(_o.previousYearVPP))
	, zero2(std::move(_o.zero2))
	, dailyCnt(std::move(_o.dailyCnt))
	, vipLevelBodies(std::move(_o.vipLevelBodies))
	, ltVppInCents(std::move(_o.ltVppInCents))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO_REPLY::operator=(Protocol_MSG_CASHIER_VIP_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		zero = std::move(_o.zero);
		lastMonthForYearlyOld = std::move(_o.lastMonthForYearlyOld);
		stellarBonuses = std::move(_o.stellarBonuses);
		previousYearVPP = std::move(_o.previousYearVPP);
		zero2 = std::move(_o.zero2);
		dailyCnt = std::move(_o.dailyCnt);
		vipLevelBodies = std::move(_o.vipLevelBodies);
		ltVppInCents = std::move(_o.ltVppInCents);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	zero = 0;
	lastMonthForYearlyOld = 0;
	stellarBonuses.clear();
	previousYearVPP = 0;
	zero2 = 0;
	dailyCnt = 0;
	vipLevelBodies.clear();
	ltVppInCents = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO_REPLY::equals(const Protocol_MSG_CASHIER_VIP_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		zero == _o.zero &&
		lastMonthForYearlyOld == _o.lastMonthForYearlyOld &&
		stellarBonuses.equals(_o.stellarBonuses) &&
		previousYearVPP == _o.previousYearVPP &&
		zero2 == _o.zero2 &&
		dailyCnt == _o.dailyCnt &&
		vipLevelBodies.equals(_o.vipLevelBodies) &&
		ltVppInCents == _o.ltVppInCents;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_VIP_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("zero=");
		_buf.appendUint(zero);
		_buf.append(',');
		_buf.append("lastMonthForYearlyOld=");
		_buf.appendInt(lastMonthForYearlyOld);
		_buf.append(',');
		_buf.append("stellarBonuses=");
		stellarBonuses.toTraceString(_buf);
		_buf.append(',');
		_buf.append("previousYearVPP=");
		_buf.appendInt(previousYearVPP);
		_buf.append(',');
		_buf.append("zero2=");
		_buf.appendUint(zero2);
		_buf.append(',');
		_buf.append("dailyCnt=");
		_buf.appendInt(dailyCnt);
		_buf.append(',');
		_buf.append("vipLevelBodies=");
		vipLevelBodies.toTraceString(_buf);
		_buf.append(',');
		_buf.append("ltVppInCents=");
		_buf.appendInt64(ltVppInCents);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(zero);
		_msg.composeINT32(lastMonthForYearlyOld);
		stellarBonuses.composeMsg(_msg);
		_msg.composeINT32(previousYearVPP);
		_msg.composeUINT32(zero2);
		_msg.composeINT32(dailyCnt);
		vipLevelBodies.composeMsg(_msg);
		_msg.composeINT64(ltVppInCents);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(zero);
		_parser.parseINT32(lastMonthForYearlyOld);
		stellarBonuses.parseMsg(_parser);
		_parser.parseINT32(previousYearVPP);
		_parser.parseUINT32(zero2);
		_parser.parseINT32(dailyCnt);
		vipLevelBodies.parseMsg(_parser);
		_parser.parseINT64(ltVppInCents);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_VIP_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_VIP_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 zero; _parser.parseUINT32(zero);
		AtfValidator::validateInt(_descr, "zero", zero, _checker, __FILE__, __LINE__);
		INT32 lastMonthForYearlyOld; _parser.parseINT32(lastMonthForYearlyOld);
		AtfValidator::validateInt(_descr, "lastMonthForYearlyOld", lastMonthForYearlyOld, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szStellarBonuses = ThinAtf::LAtfVector< StellarBonusLevel, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("stellarBonuses"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "stellarBonuses", szStellarBonuses, _checker, __FILE__, __LINE__);
		INT32 previousYearVPP; _parser.parseINT32(previousYearVPP);
		AtfValidator::validateInt(_descr, "previousYearVPP", previousYearVPP, _checker, __FILE__, __LINE__);
		UINT32 zero2; _parser.parseUINT32(zero2);
		AtfValidator::validateInt(_descr, "zero2", zero2, _checker, __FILE__, __LINE__);
		INT32 dailyCnt; _parser.parseINT32(dailyCnt);
		AtfValidator::validateInt(_descr, "dailyCnt", dailyCnt, _checker, __FILE__, __LINE__);
		int szVipLevelBodies = ThinAtf::LAtfVector< VipLevelBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("vipLevelBodies"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "vipLevelBodies", szVipLevelBodies, _checker, __FILE__, __LINE__);
		INT64 ltVppInCents; _parser.parseINT64(ltVppInCents);
		AtfValidator::validateInt(_descr, "ltVppInCents", ltVppInCents, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SAVED_CARD
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD::Protocol_MSG_CASHIER_SAVED_CARD()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD::Protocol_MSG_CASHIER_SAVED_CARD(Protocol_MSG_CASHIER_SAVED_CARD&& _o)
	: userId(std::move(_o.userId))
	, paySystem(std::move(_o.paySystem))
	, cardInfoId(std::move(_o.cardInfoId))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD& CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD::operator=(Protocol_MSG_CASHIER_SAVED_CARD&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		paySystem = std::move(_o.paySystem);
		cardInfoId = std::move(_o.cardInfoId);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD::clear()
{
	userId.clear();
	paySystem.clear();
	cardInfoId = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD::equals(const Protocol_MSG_CASHIER_SAVED_CARD& _o) const
{
	return userId.equals(_o.userId) &&
		paySystem.equals(_o.paySystem) &&
		cardInfoId == _o.cardInfoId;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SAVED_CARD).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("paySystem=");
	_buf.append(paySystem);
	_buf.append(',');
	_buf.append("cardInfoId=");
	_buf.appendUint(cardInfoId);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeString(paySystem);
	_msg.composeUINT32(cardInfoId);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseStringP(paySystem);
	_parser.parseUINT32(cardInfoId);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SAVED_CARD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "paySystem"); size_t szPaySystem = strlen(_dummy);
	AtfValidator::validateIntRange(_descr, "paySystem", szPaySystem, 1, 1000, _checker, __FILE__, __LINE__);
	UINT32 cardInfoId; _parser.parseUINT32(cardInfoId);
	AtfValidator::validateInt(_descr, "cardInfoId", cardInfoId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SAVED_CARD_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD_REPLY::Protocol_MSG_CASHIER_SAVED_CARD_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD_REPLY::Protocol_MSG_CASHIER_SAVED_CARD_REPLY(Protocol_MSG_CASHIER_SAVED_CARD_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, infoId(std::move(_o.infoId))
	, userId(std::move(_o.userId))
	, paySystem(std::move(_o.paySystem))
	, plainCardNumForOldClient(std::move(_o.plainCardNumForOldClient))
	, ssNumPlain(std::move(_o.ssNumPlain))
	, dLicensePlain(std::move(_o.dLicensePlain))
	, expYear(std::move(_o.expYear))
	, expMonth(std::move(_o.expMonth))
	, encryptedCardNum(std::move(_o.encryptedCardNum))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD_REPLY::operator=(Protocol_MSG_CASHIER_SAVED_CARD_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		infoId = std::move(_o.infoId);
		userId = std::move(_o.userId);
		paySystem = std::move(_o.paySystem);
		plainCardNumForOldClient = std::move(_o.plainCardNumForOldClient);
		ssNumPlain = std::move(_o.ssNumPlain);
		dLicensePlain = std::move(_o.dLicensePlain);
		expYear = std::move(_o.expYear);
		expMonth = std::move(_o.expMonth);
		encryptedCardNum = std::move(_o.encryptedCardNum);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	infoId = 0;
	userId.clear();
	paySystem.clear();
	plainCardNumForOldClient.clear();
	ssNumPlain.clear();
	dLicensePlain.clear();
	expYear = 0;
	expMonth = 0;
	encryptedCardNum.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD_REPLY::equals(const Protocol_MSG_CASHIER_SAVED_CARD_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		infoId == _o.infoId &&
		userId.equals(_o.userId) &&
		paySystem.equals(_o.paySystem) &&
		plainCardNumForOldClient.equals(_o.plainCardNumForOldClient) &&
		ssNumPlain.equals(_o.ssNumPlain) &&
		dLicensePlain.equals(_o.dLicensePlain) &&
		expYear == _o.expYear &&
		expMonth == _o.expMonth &&
		encryptedCardNum.size() == _o.encryptedCardNum.size() && memcmp(encryptedCardNum.ptr(), _o.encryptedCardNum.ptr(), encryptedCardNum.size()) == 0;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SAVED_CARD_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("infoId=");
		_buf.appendUint(infoId);
		_buf.append(',');
		_buf.append("userId=");
		_buf.append(userId);
		_buf.append(',');
		_buf.append("paySystem=");
		_buf.append(paySystem);
		_buf.append(',');
		_buf.append("plainCardNumForOldClient=");
		_buf.append(plainCardNumForOldClient);
		_buf.append(',');
		_buf.append("ssNumPlain=");
		_buf.append(ssNumPlain);
		_buf.append(',');
		_buf.append("dLicensePlain=");
		_buf.append(dLicensePlain);
		_buf.append(',');
		_buf.append("expYear=");
		_buf.appendUint(expYear);
		_buf.append(',');
		_buf.append("expMonth=");
		_buf.appendUint(expMonth);
		_buf.append(',');
		_buf.append("encryptedCardNum=");
		ThinAtf::AtfTempl<PBlock>::ToTraceString(_buf, encryptedCardNum);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(infoId);
		_msg.composeString(userId);
		_msg.composeString(paySystem);
		_msg.composeString(plainCardNumForOldClient);
		_msg.composeString(ssNumPlain);
		_msg.composeString(dLicensePlain);
		_msg.composeUINT16(expYear);
		_msg.composeBYTE(expMonth);
		_msg._composeVarBlock(encryptedCardNum.ptr(), encryptedCardNum.size());
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(infoId);
		_parser.parseStringP(userId);
		_parser.parseStringP(paySystem);
		_parser.parseStringP(plainCardNumForOldClient);
		_parser.parseStringP(ssNumPlain);
		_parser.parseStringP(dLicensePlain);
		_parser.parseUINT16(expYear);
		_parser.parseBYTE(expMonth);
		_parser.parsePBlock(encryptedCardNum);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SAVED_CARD_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SAVED_CARD_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 infoId; _parser.parseUINT32(infoId);
		AtfValidator::validateInt(_descr, "infoId", infoId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "paySystem"); size_t szPaySystem = strlen(_dummy);
		AtfValidator::validateInt(_descr, "paySystem", szPaySystem, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "plainCardNumForOldClient"); size_t szPlainCardNumForOldClient = strlen(_dummy);
		AtfValidator::validateInt(_descr, "plainCardNumForOldClient", szPlainCardNumForOldClient, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "ssNumPlain"); size_t szSsNumPlain = strlen(_dummy);
		AtfValidator::validateInt(_descr, "ssNumPlain", szSsNumPlain, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "dLicensePlain"); size_t szDLicensePlain = strlen(_dummy);
		AtfValidator::validateInt(_descr, "dLicensePlain", szDLicensePlain, _checker, __FILE__, __LINE__);
		UINT16 expYear; _parser.parseUINT16(expYear);
		AtfValidator::validateInt(_descr, "expYear", expYear, _checker, __FILE__, __LINE__);
		BYTE expMonth; _parser.parseBYTE(expMonth);
		AtfValidator::validateInt(_descr, "expMonth", expMonth, _checker, __FILE__, __LINE__);
		const BYTE* encryptedCardNum; size_t szEncryptedCardNum; _parser._parseVarBlock(encryptedCardNum, szEncryptedCardNum);  /*encryptedCardNum*/
		AtfValidator::validateInt(_descr, "encryptedCardNum", szEncryptedCardNum, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    DadRequest
//=================================================================

CashierServer::cli::DadRequest::DadRequest()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::DadRequest::DadRequest(DadRequest&& _o)
	: requestType(std::move(_o.requestType))
	, userId(std::move(_o.userId))
	, phoneToContact(std::move(_o.phoneToContact))
	, timeToContact(std::move(_o.timeToContact))
	, transactionId(std::move(_o.transactionId))
{
}

CashierServer::cli::DadRequest& CashierServer::cli::DadRequest::operator=(DadRequest&& _o)
{
	if(this != &_o)
	{
		requestType = std::move(_o.requestType);
		userId = std::move(_o.userId);
		phoneToContact = std::move(_o.phoneToContact);
		timeToContact = std::move(_o.timeToContact);
		transactionId = std::move(_o.transactionId);
	}
	return *this;
}

#endif

void CashierServer::cli::DadRequest::clear()
{
	requestType = 0;
	userId.clear();
	phoneToContact.clear();
	timeToContact.clear();
	transactionId = 0;
}

bool CashierServer::cli::DadRequest::equals(const DadRequest& _o) const
{
	return requestType == _o.requestType &&
		userId.equals(_o.userId) &&
		phoneToContact.equals(_o.phoneToContact) &&
		timeToContact.equals(_o.timeToContact) &&
		transactionId == _o.transactionId;
}

const char *CashierServer::cli::DadRequest::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("requestType=");
	_buf.appendUint(requestType);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("phoneToContact=");
	_buf.append(phoneToContact);
	_buf.append(',');
	_buf.append("timeToContact=");
	_buf.append(timeToContact);
	_buf.append(',');
	_buf.append("transactionId=");
	_buf.appendUint(transactionId);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::DadRequest::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(requestType);
	_msg.composeString(userId);
	_msg.composeString(phoneToContact);
	_msg.composeString(timeToContact);
	_msg.composeUINT32(transactionId);
}

void CashierServer::cli::DadRequest::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(requestType);
	_parser.parseStringP(userId);
	_parser.parseStringP(phoneToContact);
	_parser.parseStringP(timeToContact);
	_parser.parseUINT32(transactionId);
}

/*static*/ void CashierServer::cli::DadRequest::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 requestType; _parser.parseUINT32(requestType);
	{ const UINT32 requestType_enum[] = { eLiveSupportRequestChat, eLiveSupportRequestPhone, eLiveSupportRequestNone, eLiveSupportRequestEmail, eLiveSupportRequestIndirect }; AtfValidator::validateEnum(_descr, "requestType", requestType, requestType_enum, _checker, __FILE__, __LINE__); }
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "phoneToContact"); size_t szPhoneToContact = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "phoneToContact", szPhoneToContact, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "timeToContact"); size_t szTimeToContact = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "timeToContact", szTimeToContact, 1000, _checker, __FILE__, __LINE__);
	UINT32 transactionId; _parser.parseUINT32(transactionId);
	AtfValidator::validateInt(_descr, "transactionId", transactionId, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_CASHIER_DAD_REQUEST
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST::Protocol_MSG_CASHIER_DAD_REQUEST()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST::Protocol_MSG_CASHIER_DAD_REQUEST(Protocol_MSG_CASHIER_DAD_REQUEST&& _o)
	: dadRequest(std::move(_o.dadRequest))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST& CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST::operator=(Protocol_MSG_CASHIER_DAD_REQUEST&& _o)
{
	if(this != &_o)
	{
		dadRequest = std::move(_o.dadRequest);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST::clear()
{
	dadRequest.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST::equals(const Protocol_MSG_CASHIER_DAD_REQUEST& _o) const
{
	return dadRequest.equals(_o.dadRequest);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_DAD_REQUEST).append(")");
	_buf.append(',');
	_buf.append("dadRequest=");
	dadRequest.toTraceString(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST::composeMsg(CommMsgBody& _msg) const
{
	dadRequest.composeMsg(_msg);
}

void CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST::parseMsg(CommMsgParser& _parser)
{
	dadRequest.parseMsg(_parser);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_DAD_REQUEST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	DadRequest::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("dadRequest"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_DAD_REQUEST_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST_REPLY::Protocol_MSG_CASHIER_DAD_REQUEST_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST_REPLY::Protocol_MSG_CASHIER_DAD_REQUEST_REPLY(Protocol_MSG_CASHIER_DAD_REQUEST_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, requestType(std::move(_o.requestType))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST_REPLY::operator=(Protocol_MSG_CASHIER_DAD_REQUEST_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		requestType = std::move(_o.requestType);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	requestType = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST_REPLY::equals(const Protocol_MSG_CASHIER_DAD_REQUEST_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		requestType == _o.requestType;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_DAD_REQUEST_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("requestType=");
		_buf.appendUint(requestType);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(requestType);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(requestType);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_DAD_REQUEST_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_DAD_REQUEST_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 requestType; _parser.parseUINT32(requestType);
		AtfValidator::validateInt(_descr, "requestType", requestType, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT(Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT&& _o)
	: dadRequest(std::move(_o.dadRequest))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT& CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT::operator=(Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT&& _o)
{
	if(this != &_o)
	{
		dadRequest = std::move(_o.dadRequest);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT::clear()
{
	dadRequest.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT::equals(const Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT& _o) const
{
	return dadRequest.equals(_o.dadRequest);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_FRMIGRATION_LIVESUPPORT).append(")");
	_buf.append(',');
	_buf.append("dadRequest=");
	dadRequest.toTraceString(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT::composeMsg(CommMsgBody& _msg) const
{
	dadRequest.composeMsg(_msg);
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT::parseMsg(CommMsgParser& _parser)
{
	dadRequest.parseMsg(_parser);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_FRMIGRATION_LIVESUPPORT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	DadRequest::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("dadRequest"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY(Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, requestType(std::move(_o.requestType))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY::operator=(Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		requestType = std::move(_o.requestType);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	requestType = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY::equals(const Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		requestType == _o.requestType;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("requestType=");
		_buf.appendUint(requestType);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(requestType);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(requestType);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 requestType; _parser.parseUINT32(requestType);
		AtfValidator::validateInt(_descr, "requestType", requestType, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_WIRE_REQUEST
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST::Protocol_MSG_CASHIER_WIRE_REQUEST()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST::Protocol_MSG_CASHIER_WIRE_REQUEST(Protocol_MSG_CASHIER_WIRE_REQUEST&& _o)
	: userId(std::move(_o.userId))
	, procAmount(std::move(_o.procAmount))
	, currency_not(std::move(_o.currency_not))
	, bonusCode(std::move(_o.bonusCode))
	, personalInfo(std::move(_o.personalInfo))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST& CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST::operator=(Protocol_MSG_CASHIER_WIRE_REQUEST&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		procAmount = std::move(_o.procAmount);
		currency_not = std::move(_o.currency_not);
		bonusCode = std::move(_o.bonusCode);
		personalInfo = std::move(_o.personalInfo);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST::clear()
{
	userId.clear();
	procAmount = 0;
	currency_not.clear();
	bonusCode.clear();
	personalInfo.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST::equals(const Protocol_MSG_CASHIER_WIRE_REQUEST& _o) const
{
	return userId.equals(_o.userId) &&
		procAmount == _o.procAmount &&
		currency_not.equals(_o.currency_not) &&
		bonusCode.equals(_o.bonusCode) &&
		personalInfo.equals(_o.personalInfo);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_WIRE_REQUEST).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("procAmount=");
	_buf.appendInt(procAmount);
	_buf.append(',');
	_buf.append("currency_not=");
	_buf.append(currency_not);
	_buf.append(',');
	_buf.append("bonusCode=");
	_buf.append(bonusCode);
	_buf.append(',');
	_buf.append("personalInfo=");
	_buf.append(personalInfo);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeINT32(procAmount);
	_msg.composeString(currency_not);
	_msg.composeString(bonusCode);
	_msg.composeString(personalInfo);
}

void CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseINT32(procAmount);
	_parser.parseStringP(currency_not);
	_parser.parseStringP(bonusCode);
	_parser.parseStringP(personalInfo);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_WIRE_REQUEST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	INT32 procAmount; _parser.parseINT32(procAmount);
	AtfValidator::validateIntRange(_descr, "procAmount", procAmount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency_not"); size_t szCurrency_not = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency_not", szCurrency_not, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "bonusCode"); size_t szBonusCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bonusCode", szBonusCode, BONUS_CODE_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "personalInfo"); size_t szPersonalInfo = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "personalInfo", szPersonalInfo, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_WIRE_REQUEST_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST_REPLY::Protocol_MSG_CASHIER_WIRE_REQUEST_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST_REPLY::Protocol_MSG_CASHIER_WIRE_REQUEST_REPLY(Protocol_MSG_CASHIER_WIRE_REQUEST_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, paymentReference(std::move(_o.paymentReference))
	, accountHolder(std::move(_o.accountHolder))
	, bankName(std::move(_o.bankName))
	, city(std::move(_o.city))
	, swift(std::move(_o.swift))
	, specialId(std::move(_o.specialId))
	, bankAcct(std::move(_o.bankAcct))
	, country(std::move(_o.country))
	, additionalRef(std::move(_o.additionalRef))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST_REPLY::operator=(Protocol_MSG_CASHIER_WIRE_REQUEST_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		paymentReference = std::move(_o.paymentReference);
		accountHolder = std::move(_o.accountHolder);
		bankName = std::move(_o.bankName);
		city = std::move(_o.city);
		swift = std::move(_o.swift);
		specialId = std::move(_o.specialId);
		bankAcct = std::move(_o.bankAcct);
		country = std::move(_o.country);
		additionalRef = std::move(_o.additionalRef);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	paymentReference.clear();
	accountHolder.clear();
	bankName.clear();
	city.clear();
	swift.clear();
	specialId.clear();
	bankAcct.clear();
	country.clear();
	additionalRef.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST_REPLY::equals(const Protocol_MSG_CASHIER_WIRE_REQUEST_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		paymentReference.equals(_o.paymentReference) &&
		accountHolder.equals(_o.accountHolder) &&
		bankName.equals(_o.bankName) &&
		city.equals(_o.city) &&
		swift.equals(_o.swift) &&
		specialId.equals(_o.specialId) &&
		bankAcct.equals(_o.bankAcct) &&
		country.equals(_o.country) &&
		additionalRef.equals(_o.additionalRef);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_WIRE_REQUEST_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("paymentReference=");
		_buf.append(paymentReference);
		_buf.append(',');
		_buf.append("accountHolder=");
		_buf.append(accountHolder);
		_buf.append(',');
		_buf.append("bankName=");
		_buf.append(bankName);
		_buf.append(',');
		_buf.append("city=");
		_buf.append(city);
		_buf.append(',');
		_buf.append("swift=");
		_buf.append(swift);
		_buf.append(',');
		_buf.append("specialId=");
		_buf.append(specialId);
		_buf.append(',');
		_buf.append("bankAcct=");
		_buf.append(bankAcct);
		_buf.append(',');
		_buf.append("country=");
		_buf.append(country);
		_buf.append(',');
		_buf.append("additionalRef=");
		_buf.append(additionalRef);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(paymentReference);
		_msg.composeString(accountHolder);
		_msg.composeString(bankName);
		_msg.composeString(city);
		_msg.composeString(swift);
		_msg.composeString(specialId);
		_msg.composeString(bankAcct);
		_msg.composeString(country);
		_msg.composeString(additionalRef);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(paymentReference);
		_parser.parseStringP(accountHolder);
		_parser.parseStringP(bankName);
		_parser.parseStringP(city);
		_parser.parseStringP(swift);
		_parser.parseStringP(specialId);
		_parser.parseStringP(bankAcct);
		_parser.parseStringP(country);
		_parser.parseStringP(additionalRef);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_WIRE_REQUEST_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_WIRE_REQUEST_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "paymentReference"); size_t szPaymentReference = strlen(_dummy);
		AtfValidator::validateInt(_descr, "paymentReference", szPaymentReference, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "accountHolder"); size_t szAccountHolder = strlen(_dummy);
		AtfValidator::validateInt(_descr, "accountHolder", szAccountHolder, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "bankName"); size_t szBankName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "bankName", szBankName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
		AtfValidator::validateInt(_descr, "city", szCity, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "swift"); size_t szSwift = strlen(_dummy);
		AtfValidator::validateInt(_descr, "swift", szSwift, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "specialId"); size_t szSpecialId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "specialId", szSpecialId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "bankAcct"); size_t szBankAcct = strlen(_dummy);
		AtfValidator::validateInt(_descr, "bankAcct", szBankAcct, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
		AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "additionalRef"); size_t szAdditionalRef = strlen(_dummy);
		AtfValidator::validateInt(_descr, "additionalRef", szAdditionalRef, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_BPAY_REQUEST
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST::Protocol_MSG_CASHIER_BPAY_REQUEST()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST::Protocol_MSG_CASHIER_BPAY_REQUEST(Protocol_MSG_CASHIER_BPAY_REQUEST&& _o)
	: userId(std::move(_o.userId))
	, procAmount(std::move(_o.procAmount))
	, currency_not(std::move(_o.currency_not))
	, bonusCode(std::move(_o.bonusCode))
	, personalInfo(std::move(_o.personalInfo))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST& CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST::operator=(Protocol_MSG_CASHIER_BPAY_REQUEST&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		procAmount = std::move(_o.procAmount);
		currency_not = std::move(_o.currency_not);
		bonusCode = std::move(_o.bonusCode);
		personalInfo = std::move(_o.personalInfo);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST::clear()
{
	userId.clear();
	procAmount = 0;
	currency_not.clear();
	bonusCode.clear();
	personalInfo.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST::equals(const Protocol_MSG_CASHIER_BPAY_REQUEST& _o) const
{
	return userId.equals(_o.userId) &&
		procAmount == _o.procAmount &&
		currency_not.equals(_o.currency_not) &&
		bonusCode.equals(_o.bonusCode) &&
		personalInfo.equals(_o.personalInfo);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_BPAY_REQUEST).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("procAmount=");
	_buf.appendInt(procAmount);
	_buf.append(',');
	_buf.append("currency_not=");
	_buf.append(currency_not);
	_buf.append(',');
	_buf.append("bonusCode=");
	_buf.append(bonusCode);
	_buf.append(',');
	_buf.append("personalInfo=");
	_buf.append(personalInfo);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeINT32(procAmount);
	_msg.composeString(currency_not);
	_msg.composeString(bonusCode);
	_msg.composeString(personalInfo);
}

void CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseINT32(procAmount);
	_parser.parseStringP(currency_not);
	_parser.parseStringP(bonusCode);
	_parser.parseStringP(personalInfo);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_BPAY_REQUEST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	INT32 procAmount; _parser.parseINT32(procAmount);
	AtfValidator::validateIntRange(_descr, "procAmount", procAmount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency_not"); size_t szCurrency_not = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency_not", szCurrency_not, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "bonusCode"); size_t szBonusCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bonusCode", szBonusCode, BONUS_CODE_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "personalInfo"); size_t szPersonalInfo = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "personalInfo", szPersonalInfo, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_BPAY_REQUEST_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST_REPLY::Protocol_MSG_CASHIER_BPAY_REQUEST_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST_REPLY::Protocol_MSG_CASHIER_BPAY_REQUEST_REPLY(Protocol_MSG_CASHIER_BPAY_REQUEST_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, paymentReference(std::move(_o.paymentReference))
	, billerId(std::move(_o.billerId))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST_REPLY::operator=(Protocol_MSG_CASHIER_BPAY_REQUEST_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		paymentReference = std::move(_o.paymentReference);
		billerId = std::move(_o.billerId);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	paymentReference.clear();
	billerId.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST_REPLY::equals(const Protocol_MSG_CASHIER_BPAY_REQUEST_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		paymentReference.equals(_o.paymentReference) &&
		billerId.equals(_o.billerId);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_BPAY_REQUEST_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("paymentReference=");
		_buf.append(paymentReference);
		_buf.append(',');
		_buf.append("billerId=");
		_buf.append(billerId);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(paymentReference);
		_msg.composeString(billerId);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(paymentReference);
		_parser.parseStringP(billerId);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_BPAY_REQUEST_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_BPAY_REQUEST_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "paymentReference"); size_t szPaymentReference = strlen(_dummy);
		AtfValidator::validateInt(_descr, "paymentReference", szPaymentReference, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "billerId"); size_t szBillerId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "billerId", szBillerId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT(Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT&& _o)
	: userId(std::move(_o.userId))
	, amount(std::move(_o.amount))
	, currency(std::move(_o.currency))
	, bonusCode(std::move(_o.bonusCode))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT& CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT::operator=(Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		amount = std::move(_o.amount);
		currency = std::move(_o.currency);
		bonusCode = std::move(_o.bonusCode);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT::clear()
{
	userId.clear();
	amount = 0;
	currency.clear();
	bonusCode.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT::equals(const Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT& _o) const
{
	return userId.equals(_o.userId) &&
		amount == _o.amount &&
		currency.equals(_o.currency) &&
		bonusCode.equals(_o.bonusCode);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_INIT_WIRECARD_DEPOSIT).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendInt(amount);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("bonusCode=");
	_buf.append(bonusCode);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeINT32(amount);
	_msg.composeString(currency);
	_msg.composeString(bonusCode);
}

void CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseINT32(amount);
	_parser.parseStringP(currency);
	_parser.parseStringP(bonusCode);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_INIT_WIRECARD_DEPOSIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	INT32 amount; _parser.parseINT32(amount);
	AtfValidator::validateIntRange(_descr, "amount", amount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "bonusCode"); size_t szBonusCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bonusCode", szBonusCode, BONUS_CODE_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY(Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, popUpText(std::move(_o.popUpText))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY::operator=(Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		popUpText = std::move(_o.popUpText);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	popUpText.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY::equals(const Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		popUpText.equals(_o.popUpText);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("popUpText=");
		_buf.append(popUpText);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(popUpText);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(popUpText);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "popUpText"); size_t szPopUpText = strlen(_dummy);
		AtfValidator::validateInt(_descr, "popUpText", szPopUpText, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_AGE_CHECK_UK
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK::Protocol_MSG_CASHIER_AGE_CHECK_UK()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK::Protocol_MSG_CASHIER_AGE_CHECK_UK(Protocol_MSG_CASHIER_AGE_CHECK_UK&& _o)
	: title(std::move(_o.title))
	, fullName(std::move(_o.fullName))
	, gender(std::move(_o.gender))
	, dateOfBirth(std::move(_o.dateOfBirth))
	, address(std::move(_o.address))
	, city(std::move(_o.city))
	, zip(std::move(_o.zip))
	, state(std::move(_o.state))
	, country(std::move(_o.country))
	, passportNumber1(std::move(_o.passportNumber1))
	, passportNumber2(std::move(_o.passportNumber2))
	, passportNumber3(std::move(_o.passportNumber3))
	, passportNumber4(std::move(_o.passportNumber4))
	, passportNumber5(std::move(_o.passportNumber5))
	, passportNumber6(std::move(_o.passportNumber6))
	, passportExprireDate(std::move(_o.passportExprireDate))
	, driverNumber1(std::move(_o.driverNumber1))
	, driverNumber2(std::move(_o.driverNumber2))
	, driverNumber3(std::move(_o.driverNumber3))
	, driverNumber4(std::move(_o.driverNumber4))
	, driverpostcode(std::move(_o.driverpostcode))
	, attemptNumber(std::move(_o.attemptNumber))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK& CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK::operator=(Protocol_MSG_CASHIER_AGE_CHECK_UK&& _o)
{
	if(this != &_o)
	{
		title = std::move(_o.title);
		fullName = std::move(_o.fullName);
		gender = std::move(_o.gender);
		dateOfBirth = std::move(_o.dateOfBirth);
		address = std::move(_o.address);
		city = std::move(_o.city);
		zip = std::move(_o.zip);
		state = std::move(_o.state);
		country = std::move(_o.country);
		passportNumber1 = std::move(_o.passportNumber1);
		passportNumber2 = std::move(_o.passportNumber2);
		passportNumber3 = std::move(_o.passportNumber3);
		passportNumber4 = std::move(_o.passportNumber4);
		passportNumber5 = std::move(_o.passportNumber5);
		passportNumber6 = std::move(_o.passportNumber6);
		passportExprireDate = std::move(_o.passportExprireDate);
		driverNumber1 = std::move(_o.driverNumber1);
		driverNumber2 = std::move(_o.driverNumber2);
		driverNumber3 = std::move(_o.driverNumber3);
		driverNumber4 = std::move(_o.driverNumber4);
		driverpostcode = std::move(_o.driverpostcode);
		attemptNumber = std::move(_o.attemptNumber);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK::clear()
{
	title.clear();
	fullName.clear();
	gender.clear();
	dateOfBirth.setNull();
	address.clear();
	city.clear();
	zip.clear();
	state.clear();
	country.clear();
	passportNumber1.clear();
	passportNumber2.clear();
	passportNumber3.clear();
	passportNumber4.clear();
	passportNumber5.clear();
	passportNumber6.clear();
	passportExprireDate.setNull();
	driverNumber1.clear();
	driverNumber2.clear();
	driverNumber3.clear();
	driverNumber4.clear();
	driverpostcode.clear();
	attemptNumber = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK::equals(const Protocol_MSG_CASHIER_AGE_CHECK_UK& _o) const
{
	return title.equals(_o.title) &&
		fullName.equals(_o.fullName) &&
		gender.equals(_o.gender) &&
		dateOfBirth.equals(_o.dateOfBirth) &&
		address.equals(_o.address) &&
		city.equals(_o.city) &&
		zip.equals(_o.zip) &&
		state.equals(_o.state) &&
		country.equals(_o.country) &&
		passportNumber1.equals(_o.passportNumber1) &&
		passportNumber2.equals(_o.passportNumber2) &&
		passportNumber3.equals(_o.passportNumber3) &&
		passportNumber4.equals(_o.passportNumber4) &&
		passportNumber5.equals(_o.passportNumber5) &&
		passportNumber6.equals(_o.passportNumber6) &&
		passportExprireDate.equals(_o.passportExprireDate) &&
		driverNumber1.equals(_o.driverNumber1) &&
		driverNumber2.equals(_o.driverNumber2) &&
		driverNumber3.equals(_o.driverNumber3) &&
		driverNumber4.equals(_o.driverNumber4) &&
		driverpostcode.equals(_o.driverpostcode) &&
		attemptNumber == _o.attemptNumber;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_AGE_CHECK_UK).append(")");
	_buf.append(',');
	_buf.append("title=");
	_buf.append(title);
	_buf.append(',');
	_buf.append("fullName=");
	_buf.append(fullName);
	_buf.append(',');
	_buf.append("gender=");
	_buf.append(gender);
	_buf.append(',');
	_buf.append("dateOfBirth=");
	ThinAtf::AtfTempl<CommSrvDate>::ToTraceString(_buf, dateOfBirth);
	_buf.append(',');
	_buf.append("address=");
	_buf.append(address);
	_buf.append(',');
	_buf.append("city=");
	_buf.append(city);
	_buf.append(',');
	_buf.append("zip=");
	_buf.append(zip);
	_buf.append(',');
	_buf.append("state=");
	_buf.append(state);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("passportNumber1=");
	_buf.append(passportNumber1);
	_buf.append(',');
	_buf.append("passportNumber2=");
	_buf.append(passportNumber2);
	_buf.append(',');
	_buf.append("passportNumber3=");
	_buf.append(passportNumber3);
	_buf.append(',');
	_buf.append("passportNumber4=");
	_buf.append(passportNumber4);
	_buf.append(',');
	_buf.append("passportNumber5=");
	_buf.append(passportNumber5);
	_buf.append(',');
	_buf.append("passportNumber6=");
	_buf.append(passportNumber6);
	_buf.append(',');
	_buf.append("passportExprireDate=");
	ThinAtf::AtfTempl<CommSrvDate>::ToTraceString(_buf, passportExprireDate);
	_buf.append(',');
	_buf.append("driverNumber1=");
	_buf.append(driverNumber1);
	_buf.append(',');
	_buf.append("driverNumber2=");
	_buf.append(driverNumber2);
	_buf.append(',');
	_buf.append("driverNumber3=");
	_buf.append(driverNumber3);
	_buf.append(',');
	_buf.append("driverNumber4=");
	_buf.append(driverNumber4);
	_buf.append(',');
	_buf.append("driverpostcode=");
	_buf.append(driverpostcode);
	_buf.append(',');
	_buf.append("attemptNumber=");
	_buf.appendUint(attemptNumber);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(title);
	_msg.composeString(fullName);
	_msg.composeString(gender);
	_msg.composeSrvDate(dateOfBirth);
	_msg.composeString(address);
	_msg.composeString(city);
	_msg.composeString(zip);
	_msg.composeString(state);
	_msg.composeString(country);
	_msg.composeString(passportNumber1);
	_msg.composeString(passportNumber2);
	_msg.composeString(passportNumber3);
	_msg.composeString(passportNumber4);
	_msg.composeString(passportNumber5);
	_msg.composeString(passportNumber6);
	_msg.composeSrvDate(passportExprireDate);
	_msg.composeString(driverNumber1);
	_msg.composeString(driverNumber2);
	_msg.composeString(driverNumber3);
	_msg.composeString(driverNumber4);
	_msg.composeString(driverpostcode);
	_msg.composeUINT32(attemptNumber);
}

void CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(title);
	_parser.parseStringP(fullName);
	_parser.parseStringP(gender);
	_parser.parseSrvDate(dateOfBirth);
	_parser.parseStringP(address);
	_parser.parseStringP(city);
	_parser.parseStringP(zip);
	_parser.parseStringP(state);
	_parser.parseStringP(country);
	_parser.parseStringP(passportNumber1);
	_parser.parseStringP(passportNumber2);
	_parser.parseStringP(passportNumber3);
	_parser.parseStringP(passportNumber4);
	_parser.parseStringP(passportNumber5);
	_parser.parseStringP(passportNumber6);
	_parser.parseSrvDate(passportExprireDate);
	_parser.parseStringP(driverNumber1);
	_parser.parseStringP(driverNumber2);
	_parser.parseStringP(driverNumber3);
	_parser.parseStringP(driverNumber4);
	_parser.parseStringP(driverpostcode);
	_parser.parseUINT32(attemptNumber);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_AGE_CHECK_UK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "title"); size_t szTitle = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "title", szTitle, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "fullName"); size_t szFullName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "fullName", szFullName, USER_FULLNAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "gender"); size_t szGender = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "gender", szGender, 6, _checker, __FILE__, __LINE__);
	CommSrvDate dateOfBirth; _parser.parseSrvDate(dateOfBirth);
	AtfValidator::validateSrvDateTime(_descr, "dateOfBirth", dateOfBirth, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "address"); size_t szAddress = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "address", szAddress, USER_ADDR_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "city", szCity, USER_CITY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "zip"); size_t szZip = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "zip", szZip, USER_ZIP_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "state"); size_t szState = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "state", szState, USER_STATE_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, USER_COUNTRY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "passportNumber1"); size_t szPassportNumber1 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "passportNumber1", szPassportNumber1, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "passportNumber2"); size_t szPassportNumber2 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "passportNumber2", szPassportNumber2, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "passportNumber3"); size_t szPassportNumber3 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "passportNumber3", szPassportNumber3, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "passportNumber4"); size_t szPassportNumber4 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "passportNumber4", szPassportNumber4, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "passportNumber5"); size_t szPassportNumber5 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "passportNumber5", szPassportNumber5, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "passportNumber6"); size_t szPassportNumber6 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "passportNumber6", szPassportNumber6, 100, _checker, __FILE__, __LINE__);
	CommSrvDate passportExprireDate; _parser.parseSrvDate(passportExprireDate);
	AtfValidator::validateSrvDateTime(_descr, "passportExprireDate", passportExprireDate, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "driverNumber1"); size_t szDriverNumber1 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "driverNumber1", szDriverNumber1, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "driverNumber2"); size_t szDriverNumber2 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "driverNumber2", szDriverNumber2, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "driverNumber3"); size_t szDriverNumber3 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "driverNumber3", szDriverNumber3, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "driverNumber4"); size_t szDriverNumber4 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "driverNumber4", szDriverNumber4, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "driverpostcode"); size_t szDriverpostcode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "driverpostcode", szDriverpostcode, 100, _checker, __FILE__, __LINE__);
	UINT32 attemptNumber; _parser.parseUINT32(attemptNumber);
	AtfValidator::validateIntMax(_descr, "attemptNumber", attemptNumber, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_AGE_CHECK_UK_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK_REPLY::Protocol_MSG_CASHIER_AGE_CHECK_UK_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK_REPLY::Protocol_MSG_CASHIER_AGE_CHECK_UK_REPLY(Protocol_MSG_CASHIER_AGE_CHECK_UK_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK_REPLY::operator=(Protocol_MSG_CASHIER_AGE_CHECK_UK_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK_REPLY::equals(const Protocol_MSG_CASHIER_AGE_CHECK_UK_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_AGE_CHECK_UK_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_AGE_CHECK_UK_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_AGE_CHECK_UK_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    AgeVerificationCommonBody
//=================================================================

CashierServer::cli::AgeVerificationCommonBody::AgeVerificationCommonBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::AgeVerificationCommonBody::AgeVerificationCommonBody(AgeVerificationCommonBody&& _o)
	: title(std::move(_o.title))
	, fullName(std::move(_o.fullName))
	, gender(std::move(_o.gender))
	, dateOfBirth(std::move(_o.dateOfBirth))
	, address(std::move(_o.address))
	, city(std::move(_o.city))
	, zip(std::move(_o.zip))
	, state(std::move(_o.state))
	, country(std::move(_o.country))
	, phone(std::move(_o.phone))
	, firstName(std::move(_o.firstName))
	, lastName(std::move(_o.lastName))
{
}

CashierServer::cli::AgeVerificationCommonBody& CashierServer::cli::AgeVerificationCommonBody::operator=(AgeVerificationCommonBody&& _o)
{
	if(this != &_o)
	{
		title = std::move(_o.title);
		fullName = std::move(_o.fullName);
		gender = std::move(_o.gender);
		dateOfBirth = std::move(_o.dateOfBirth);
		address = std::move(_o.address);
		city = std::move(_o.city);
		zip = std::move(_o.zip);
		state = std::move(_o.state);
		country = std::move(_o.country);
		phone = std::move(_o.phone);
		firstName = std::move(_o.firstName);
		lastName = std::move(_o.lastName);
	}
	return *this;
}

#endif

void CashierServer::cli::AgeVerificationCommonBody::clear()
{
	title = 0;
	fullName.clear();
	gender.clear();
	dateOfBirth.setNull();
	address.clear();
	city.clear();
	zip.clear();
	state.clear();
	country.clear();
	phone.clear();
	firstName.clear();
	lastName.clear();
}

bool CashierServer::cli::AgeVerificationCommonBody::equals(const AgeVerificationCommonBody& _o) const
{
	return title == _o.title &&
		fullName.equals(_o.fullName) &&
		gender.equals(_o.gender) &&
		dateOfBirth.equals(_o.dateOfBirth) &&
		address.equals(_o.address) &&
		city.equals(_o.city) &&
		zip.equals(_o.zip) &&
		state.equals(_o.state) &&
		country.equals(_o.country) &&
		phone.equals(_o.phone) &&
		firstName.equals(_o.firstName) &&
		lastName.equals(_o.lastName);
}

const char *CashierServer::cli::AgeVerificationCommonBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("title=");
	_buf.appendInt(title);
	_buf.append(',');
	_buf.append("fullName=");
	_buf.append(fullName);
	_buf.append(',');
	_buf.append("gender=");
	_buf.append(gender);
	_buf.append(',');
	_buf.append("dateOfBirth=");
	ThinAtf::AtfTempl<CommSrvDate>::ToTraceString(_buf, dateOfBirth);
	_buf.append(',');
	_buf.append("address=");
	_buf.append(address);
	_buf.append(',');
	_buf.append("city=");
	_buf.append(city);
	_buf.append(',');
	_buf.append("zip=");
	_buf.append(zip);
	_buf.append(',');
	_buf.append("state=");
	_buf.append(state);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("phone=");
	_buf.append(phone);
	_buf.append(',');
	_buf.append("firstName=");
	_buf.append(firstName);
	_buf.append(',');
	_buf.append("lastName=");
	_buf.append(lastName);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::AgeVerificationCommonBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(AgeVerificationCommonBody())) // not empty
	{
		_body.composeINT32(title);
		_body.composeString(fullName);
		_body.composeString(gender);
		_body.composeSrvDate(dateOfBirth);
		_body.composeString(address);
		_body.composeString(city);
		_body.composeString(zip);
		_body.composeString(state);
		_body.composeString(country);
		_body.composeString(phone);
		_body.composeString(firstName);
		_body.composeString(lastName);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::AgeVerificationCommonBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(title);
	_parser0.parseStringP(fullName);
	_parser0.parseStringP(gender);
	_parser0.parseSrvDate(dateOfBirth);
	_parser0.parseStringP(address);
	_parser0.parseStringP(city);
	_parser0.parseStringP(zip);
	_parser0.parseStringP(state);
	_parser0.parseStringP(country);
	_parser0.parseStringP(phone);
	_parser0.parseStringP(firstName);
	_parser0.parseStringP(lastName);
}

/*static*/ void CashierServer::cli::AgeVerificationCommonBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	INT32 title; _parser0.parseINT32(title);
	{ const INT32 title_enum[] = { eUserTitleNone, eUserTitleMr, eUserTitleMrs, eUserTitleMiss, eUserTitleMs, eUserTitleDr }; AtfValidator::validateEnum(_descr, "title", title, title_enum, _checker, __FILE__, __LINE__); }
	_parser0.parseStringN(_dummy, 0, "fullName"); size_t szFullName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "fullName", szFullName, USER_FULLNAME_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "gender"); size_t szGender = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "gender", szGender, GENDER_LEN, _checker, __FILE__, __LINE__);
	CommSrvDate dateOfBirth; _parser0.parseSrvDate(dateOfBirth);
	AtfValidator::validateSrvDateTime(_descr, "dateOfBirth", dateOfBirth, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "address"); size_t szAddress = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "address", szAddress, USER_ADDR_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "city", szCity, USER_CITY_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "zip"); size_t szZip = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "zip", szZip, USER_ZIP_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "state"); size_t szState = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "state", szState, USER_STATE_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, USER_COUNTRY_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "phone"); size_t szPhone = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "phone", szPhone, 100, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "firstName"); size_t szFirstName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "firstName", szFirstName, USER_FIRST_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "lastName"); size_t szLastName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "lastName", szLastName, USER_LAST_NAME_LEN, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    AgeVerificationPassportBody
//=================================================================

CashierServer::cli::AgeVerificationPassportBody::AgeVerificationPassportBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::AgeVerificationPassportBody::AgeVerificationPassportBody(AgeVerificationPassportBody&& _o)
	: passportNumber1(std::move(_o.passportNumber1))
	, passportNumber2(std::move(_o.passportNumber2))
	, passportNumber3(std::move(_o.passportNumber3))
	, passportNumber4(std::move(_o.passportNumber4))
	, passportNumber5(std::move(_o.passportNumber5))
	, passportNumber6(std::move(_o.passportNumber6))
	, passportExprireDate(std::move(_o.passportExprireDate))
{
}

CashierServer::cli::AgeVerificationPassportBody& CashierServer::cli::AgeVerificationPassportBody::operator=(AgeVerificationPassportBody&& _o)
{
	if(this != &_o)
	{
		passportNumber1 = std::move(_o.passportNumber1);
		passportNumber2 = std::move(_o.passportNumber2);
		passportNumber3 = std::move(_o.passportNumber3);
		passportNumber4 = std::move(_o.passportNumber4);
		passportNumber5 = std::move(_o.passportNumber5);
		passportNumber6 = std::move(_o.passportNumber6);
		passportExprireDate = std::move(_o.passportExprireDate);
	}
	return *this;
}

#endif

void CashierServer::cli::AgeVerificationPassportBody::clear()
{
	passportNumber1.clear();
	passportNumber2.clear();
	passportNumber3.clear();
	passportNumber4.clear();
	passportNumber5.clear();
	passportNumber6.clear();
	passportExprireDate.setNull();
}

bool CashierServer::cli::AgeVerificationPassportBody::equals(const AgeVerificationPassportBody& _o) const
{
	return passportNumber1.equals(_o.passportNumber1) &&
		passportNumber2.equals(_o.passportNumber2) &&
		passportNumber3.equals(_o.passportNumber3) &&
		passportNumber4.equals(_o.passportNumber4) &&
		passportNumber5.equals(_o.passportNumber5) &&
		passportNumber6.equals(_o.passportNumber6) &&
		passportExprireDate.equals(_o.passportExprireDate);
}

const char *CashierServer::cli::AgeVerificationPassportBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("passportNumber1=");
	_buf.append(passportNumber1);
	_buf.append(',');
	_buf.append("passportNumber2=");
	_buf.append(passportNumber2);
	_buf.append(',');
	_buf.append("passportNumber3=");
	_buf.append(passportNumber3);
	_buf.append(',');
	_buf.append("passportNumber4=");
	_buf.append(passportNumber4);
	_buf.append(',');
	_buf.append("passportNumber5=");
	_buf.append(passportNumber5);
	_buf.append(',');
	_buf.append("passportNumber6=");
	_buf.append(passportNumber6);
	_buf.append(',');
	_buf.append("passportExprireDate=");
	ThinAtf::AtfTempl<CommSrvDate>::ToTraceString(_buf, passportExprireDate);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::AgeVerificationPassportBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(AgeVerificationPassportBody())) // not empty
	{
		_body.composeString(passportNumber1);
		_body.composeString(passportNumber2);
		_body.composeString(passportNumber3);
		_body.composeString(passportNumber4);
		_body.composeString(passportNumber5);
		_body.composeString(passportNumber6);
		_body.composeSrvDate(passportExprireDate);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::AgeVerificationPassportBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(passportNumber1);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(passportNumber2);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(passportNumber3);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(passportNumber4);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(passportNumber5);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(passportNumber6);
	if(_parser0.parseEnded()) return;
	_parser0.parseSrvDate(passportExprireDate);
}

/*static*/ void CashierServer::cli::AgeVerificationPassportBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "passportNumber1"); size_t szPassportNumber1 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "passportNumber1", szPassportNumber1, 100, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "passportNumber2"); size_t szPassportNumber2 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "passportNumber2", szPassportNumber2, 100, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "passportNumber3"); size_t szPassportNumber3 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "passportNumber3", szPassportNumber3, 100, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "passportNumber4"); size_t szPassportNumber4 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "passportNumber4", szPassportNumber4, 100, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "passportNumber5"); size_t szPassportNumber5 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "passportNumber5", szPassportNumber5, 100, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "passportNumber6"); size_t szPassportNumber6 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "passportNumber6", szPassportNumber6, 100, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	CommSrvDate passportExprireDate; _parser0.parseSrvDate(passportExprireDate);
	AtfValidator::validateSrvDateTime(_descr, "passportExprireDate", passportExprireDate, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    AgeVerificationDrivLicBody
//=================================================================

CashierServer::cli::AgeVerificationDrivLicBody::AgeVerificationDrivLicBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::AgeVerificationDrivLicBody::AgeVerificationDrivLicBody(AgeVerificationDrivLicBody&& _o)
	: driverLicenseCountry(std::move(_o.driverLicenseCountry))
	, driverNumber1(std::move(_o.driverNumber1))
	, driverNumber2(std::move(_o.driverNumber2))
	, driverNumber3(std::move(_o.driverNumber3))
	, driverNumber4(std::move(_o.driverNumber4))
{
}

CashierServer::cli::AgeVerificationDrivLicBody& CashierServer::cli::AgeVerificationDrivLicBody::operator=(AgeVerificationDrivLicBody&& _o)
{
	if(this != &_o)
	{
		driverLicenseCountry = std::move(_o.driverLicenseCountry);
		driverNumber1 = std::move(_o.driverNumber1);
		driverNumber2 = std::move(_o.driverNumber2);
		driverNumber3 = std::move(_o.driverNumber3);
		driverNumber4 = std::move(_o.driverNumber4);
	}
	return *this;
}

#endif

void CashierServer::cli::AgeVerificationDrivLicBody::clear()
{
	driverLicenseCountry.clear();
	driverNumber1.clear();
	driverNumber2.clear();
	driverNumber3.clear();
	driverNumber4.clear();
}

bool CashierServer::cli::AgeVerificationDrivLicBody::equals(const AgeVerificationDrivLicBody& _o) const
{
	return driverLicenseCountry.equals(_o.driverLicenseCountry) &&
		driverNumber1.equals(_o.driverNumber1) &&
		driverNumber2.equals(_o.driverNumber2) &&
		driverNumber3.equals(_o.driverNumber3) &&
		driverNumber4.equals(_o.driverNumber4);
}

const char *CashierServer::cli::AgeVerificationDrivLicBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("driverLicenseCountry=");
	_buf.append(driverLicenseCountry);
	_buf.append(',');
	_buf.append("driverNumber1=");
	_buf.append(driverNumber1);
	_buf.append(',');
	_buf.append("driverNumber2=");
	_buf.append(driverNumber2);
	_buf.append(',');
	_buf.append("driverNumber3=");
	_buf.append(driverNumber3);
	_buf.append(',');
	_buf.append("driverNumber4=");
	_buf.append(driverNumber4);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::AgeVerificationDrivLicBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(AgeVerificationDrivLicBody())) // not empty
	{
		_body.composeString(driverLicenseCountry);
		_body.composeString(driverNumber1);
		_body.composeString(driverNumber2);
		_body.composeString(driverNumber3);
		_body.composeString(driverNumber4);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::AgeVerificationDrivLicBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(driverLicenseCountry);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(driverNumber1);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(driverNumber2);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(driverNumber3);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(driverNumber4);
}

/*static*/ void CashierServer::cli::AgeVerificationDrivLicBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "driverLicenseCountry"); size_t szDriverLicenseCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "driverLicenseCountry", szDriverLicenseCountry, 100, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "driverNumber1"); size_t szDriverNumber1 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "driverNumber1", szDriverNumber1, 100, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "driverNumber2"); size_t szDriverNumber2 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "driverNumber2", szDriverNumber2, 100, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "driverNumber3"); size_t szDriverNumber3 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "driverNumber3", szDriverNumber3, 100, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "driverNumber4"); size_t szDriverNumber4 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "driverNumber4", szDriverNumber4, 100, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_AGEVERIVICATION2
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2::Protocol_MSG_CASHIER_AGEVERIVICATION2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2::Protocol_MSG_CASHIER_AGEVERIVICATION2(Protocol_MSG_CASHIER_AGEVERIVICATION2&& _o)
	: common(std::move(_o.common))
	, passport(std::move(_o.passport))
	, drivLic(std::move(_o.drivLic))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2& CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2::operator=(Protocol_MSG_CASHIER_AGEVERIVICATION2&& _o)
{
	if(this != &_o)
	{
		common = std::move(_o.common);
		passport = std::move(_o.passport);
		drivLic = std::move(_o.drivLic);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2::clear()
{
	common.clear();
	passport.clear();
	drivLic.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2::equals(const Protocol_MSG_CASHIER_AGEVERIVICATION2& _o) const
{
	return common.equals(_o.common) &&
		passport.equals(_o.passport) &&
		drivLic.equals(_o.drivLic);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_AGEVERIVICATION2).append(")");
	_buf.append(',');
	_buf.append("common=");
	common.toTraceString(_buf);
	_buf.append(',');
	_buf.append("passport=");
	passport.toTraceString(_buf);
	_buf.append(',');
	_buf.append("drivLic=");
	drivLic.toTraceString(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2::composeMsg(CommMsgBody& _msg) const
{
	common.composeMsg(_msg);
	passport.composeMsg(_msg);
	drivLic.composeMsg(_msg);
}

void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2::parseMsg(CommMsgParser& _parser)
{
	common.parseMsg(_parser);
	passport.parseMsg(_parser);
	drivLic.parseMsg(_parser);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_AGEVERIVICATION2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	AgeVerificationCommonBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("common"), _fieldsWithUnparsedContent);
	AgeVerificationPassportBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("passport"), _fieldsWithUnparsedContent);
	AgeVerificationDrivLicBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("drivLic"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    AgeVerificationDrivLicCountryBody
//=================================================================

CashierServer::cli::AgeVerificationDrivLicCountryBody::AgeVerificationDrivLicCountryBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::AgeVerificationDrivLicCountryBody::AgeVerificationDrivLicCountryBody(AgeVerificationDrivLicCountryBody&& _o)
	: country(std::move(_o.country))
{
}

CashierServer::cli::AgeVerificationDrivLicCountryBody& CashierServer::cli::AgeVerificationDrivLicCountryBody::operator=(AgeVerificationDrivLicCountryBody&& _o)
{
	if(this != &_o)
	{
		country = std::move(_o.country);
	}
	return *this;
}

#endif

void CashierServer::cli::AgeVerificationDrivLicCountryBody::clear()
{
	country.clear();
}

bool CashierServer::cli::AgeVerificationDrivLicCountryBody::equals(const AgeVerificationDrivLicCountryBody& _o) const
{
	return country.equals(_o.country);
}

const char *CashierServer::cli::AgeVerificationDrivLicCountryBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("country=");
	_buf.append(country);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::AgeVerificationDrivLicCountryBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(AgeVerificationDrivLicCountryBody())) // not empty
	{
		_body.composeString(country);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::AgeVerificationDrivLicCountryBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(country);
}

/*static*/ void CashierServer::cli::AgeVerificationDrivLicCountryBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_AGEVERIVICATION2_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_REPLY::Protocol_MSG_CASHIER_AGEVERIVICATION2_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_REPLY::Protocol_MSG_CASHIER_AGEVERIVICATION2_REPLY(Protocol_MSG_CASHIER_AGEVERIVICATION2_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, ageCheckDrivLicCountries(std::move(_o.ageCheckDrivLicCountries))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_REPLY::operator=(Protocol_MSG_CASHIER_AGEVERIVICATION2_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		ageCheckDrivLicCountries = std::move(_o.ageCheckDrivLicCountries);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	ageCheckDrivLicCountries.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_REPLY::equals(const Protocol_MSG_CASHIER_AGEVERIVICATION2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		ageCheckDrivLicCountries.equals(_o.ageCheckDrivLicCountries);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_AGEVERIVICATION2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("ageCheckDrivLicCountries=");
		ageCheckDrivLicCountries.toTraceString(_buf);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		ageCheckDrivLicCountries.composeMsg(_msg);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		if(_parser.parseEnded()) return;
		ageCheckDrivLicCountries.parseMsg(_parser);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_AGEVERIVICATION2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		if(_parser.parseEnded()) return;
		PString _descbuf;
		int szAgeCheckDrivLicCountries = ThinAtf::LAtfVector< AgeVerificationDrivLicCountryBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("ageCheckDrivLicCountries"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "ageCheckDrivLicCountries", szAgeCheckDrivLicCountries, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL::equals(const Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL& _o) const
{
	return true;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_AGEVERIVICATION2_CANCEL).append(")");
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL::composeMsg(CommMsgBody& _msg) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_AGEVERIVICATION2_CANCEL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY(Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY::operator=(Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY::equals(const Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CHECK_PAYSYSTEM
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM(Protocol_MSG_CASHIER_CHECK_PAYSYSTEM&& _o)
	: paySystemByte(std::move(_o.paySystemByte))
	, requestCurrency(std::move(_o.requestCurrency))
	, cardInfoId(std::move(_o.cardInfoId))
	, notUsedNum1(std::move(_o.notUsedNum1))
	, notUsedNum2(std::move(_o.notUsedNum2))
	, notUsedNum3(std::move(_o.notUsedNum3))
	, notUsedNum4(std::move(_o.notUsedNum4))
	, notUsedNum5(std::move(_o.notUsedNum5))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM& CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM::operator=(Protocol_MSG_CASHIER_CHECK_PAYSYSTEM&& _o)
{
	if(this != &_o)
	{
		paySystemByte = std::move(_o.paySystemByte);
		requestCurrency = std::move(_o.requestCurrency);
		cardInfoId = std::move(_o.cardInfoId);
		notUsedNum1 = std::move(_o.notUsedNum1);
		notUsedNum2 = std::move(_o.notUsedNum2);
		notUsedNum3 = std::move(_o.notUsedNum3);
		notUsedNum4 = std::move(_o.notUsedNum4);
		notUsedNum5 = std::move(_o.notUsedNum5);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM::clear()
{
	paySystemByte = 0;
	requestCurrency.clear();
	cardInfoId = 0;
	notUsedNum1 = 0;
	notUsedNum2 = 0;
	notUsedNum3 = 0;
	notUsedNum4 = 0;
	notUsedNum5 = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM::equals(const Protocol_MSG_CASHIER_CHECK_PAYSYSTEM& _o) const
{
	return paySystemByte == _o.paySystemByte &&
		requestCurrency.equals(_o.requestCurrency) &&
		cardInfoId == _o.cardInfoId &&
		notUsedNum1 == _o.notUsedNum1 &&
		notUsedNum2 == _o.notUsedNum2 &&
		notUsedNum3 == _o.notUsedNum3 &&
		notUsedNum4 == _o.notUsedNum4 &&
		notUsedNum5 == _o.notUsedNum5;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CHECK_PAYSYSTEM).append(")");
	_buf.append(',');
	_buf.append("paySystemByte=");
	_buf.appendUint(paySystemByte);
	_buf.append(',');
	_buf.append("requestCurrency=");
	_buf.append(requestCurrency);
	_buf.append(',');
	_buf.append("cardInfoId=");
	_buf.appendUint(cardInfoId);
	_buf.append(',');
	_buf.append("notUsedNum1=");
	_buf.appendUint(notUsedNum1);
	_buf.append(',');
	_buf.append("notUsedNum2=");
	_buf.appendUint(notUsedNum2);
	_buf.append(',');
	_buf.append("notUsedNum3=");
	_buf.appendUint(notUsedNum3);
	_buf.append(',');
	_buf.append("notUsedNum4=");
	_buf.appendUint(notUsedNum4);
	_buf.append(',');
	_buf.append("notUsedNum5=");
	_buf.appendUint(notUsedNum5);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(paySystemByte);
	_msg.composeString(requestCurrency);
	_msg.composeUINT32(cardInfoId);
	_msg.composeBYTE(notUsedNum1);
	_msg.composeBYTE(notUsedNum2);
	_msg.composeBYTE(notUsedNum3);
	_msg.composeBYTE(notUsedNum4);
	_msg.composeBYTE(notUsedNum5);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(paySystemByte);
	_parser.parseStringP(requestCurrency);
	_parser.parseUINT32(cardInfoId);
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(notUsedNum1);
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(notUsedNum2);
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(notUsedNum3);
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(notUsedNum4);
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(notUsedNum5);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CHECK_PAYSYSTEM";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE paySystemByte; _parser.parseBYTE(paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "requestCurrency"); size_t szRequestCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "requestCurrency", szRequestCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	UINT32 cardInfoId; _parser.parseUINT32(cardInfoId);
	AtfValidator::validateInt(_descr, "cardInfoId", cardInfoId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	BYTE notUsedNum1; _parser.parseBYTE(notUsedNum1);
	AtfValidator::validateInt(_descr, "notUsedNum1", notUsedNum1, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	BYTE notUsedNum2; _parser.parseBYTE(notUsedNum2);
	AtfValidator::validateInt(_descr, "notUsedNum2", notUsedNum2, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	BYTE notUsedNum3; _parser.parseBYTE(notUsedNum3);
	AtfValidator::validateInt(_descr, "notUsedNum3", notUsedNum3, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	BYTE notUsedNum4; _parser.parseBYTE(notUsedNum4);
	AtfValidator::validateInt(_descr, "notUsedNum4", notUsedNum4, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	BYTE notUsedNum5; _parser.parseBYTE(notUsedNum5);
	AtfValidator::validateInt(_descr, "notUsedNum5", notUsedNum5, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierAvailableCurrency
//=================================================================

CashierServer::cli::CashierAvailableCurrency::CashierAvailableCurrency()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::CashierAvailableCurrency::CashierAvailableCurrency(CashierAvailableCurrency&& _o)
	: currency(std::move(_o.currency))
	, depositRate64(std::move(_o.depositRate64))
	, depositRate64Inverted(std::move(_o.depositRate64Inverted))
{
}

CashierServer::cli::CashierAvailableCurrency& CashierServer::cli::CashierAvailableCurrency::operator=(CashierAvailableCurrency&& _o)
{
	if(this != &_o)
	{
		currency = std::move(_o.currency);
		depositRate64 = std::move(_o.depositRate64);
		depositRate64Inverted = std::move(_o.depositRate64Inverted);
	}
	return *this;
}

#endif

void CashierServer::cli::CashierAvailableCurrency::clear()
{
	currency.clear();
	depositRate64 = 0;
	depositRate64Inverted = 0;
}

bool CashierServer::cli::CashierAvailableCurrency::equals(const CashierAvailableCurrency& _o) const
{
	return currency.equals(_o.currency) &&
		depositRate64 == _o.depositRate64 &&
		depositRate64Inverted == _o.depositRate64Inverted;
}

const char *CashierServer::cli::CashierAvailableCurrency::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("depositRate64=");
	_buf.appendUint64(depositRate64);
	_buf.append(',');
	_buf.append("depositRate64Inverted=");
	_buf.appendUint64(depositRate64Inverted);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashierAvailableCurrency::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CashierAvailableCurrency())) // not empty
	{
		_body.composeString(currency);
		_body.composeUINT64(depositRate64);
		_body.composeUINT64(depositRate64Inverted);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierAvailableCurrency::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(currency);
	_parser0.parseUINT64(depositRate64);
	_parser0.parseUINT64(depositRate64Inverted);
}

/*static*/ void CashierServer::cli::CashierAvailableCurrency::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT64 depositRate64; _parser0.parseUINT64(depositRate64);
	AtfValidator::validateUint(_descr, "depositRate64", depositRate64, _checker, __FILE__, __LINE__);
	UINT64 depositRate64Inverted; _parser0.parseUINT64(depositRate64Inverted);
	AtfValidator::validateUint(_descr, "depositRate64Inverted", depositRate64Inverted, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CashierFeeBody
//=================================================================

CashierServer::cli::CashierFeeBody::CashierFeeBody()
{
	clear();
}

void CashierServer::cli::CashierFeeBody::clear()
{
	graceDepositsPeriodDays = 0;
	graceDeposits = 0;
	leftGraceDeposits = 0;
	calcRate_x_100K = 0;
	calcMinFee = 0;
	calcMaxFee = 0;
	altPaysystemByte = 0;
}

bool CashierServer::cli::CashierFeeBody::equals(const CashierFeeBody& _o) const
{
	return graceDepositsPeriodDays == _o.graceDepositsPeriodDays &&
		graceDeposits == _o.graceDeposits &&
		leftGraceDeposits == _o.leftGraceDeposits &&
		calcRate_x_100K == _o.calcRate_x_100K &&
		calcMinFee == _o.calcMinFee &&
		calcMaxFee == _o.calcMaxFee &&
		altPaysystemByte == _o.altPaysystemByte;
}

const char *CashierServer::cli::CashierFeeBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("graceDepositsPeriodDays=");
	_buf.appendInt(graceDepositsPeriodDays);
	_buf.append(',');
	_buf.append("graceDeposits=");
	_buf.appendInt(graceDeposits);
	_buf.append(',');
	_buf.append("leftGraceDeposits=");
	_buf.appendInt(leftGraceDeposits);
	_buf.append(',');
	_buf.append("calcRate_x_100K=");
	_buf.appendInt(calcRate_x_100K);
	_buf.append(',');
	_buf.append("calcMinFee=");
	_buf.appendInt(calcMinFee);
	_buf.append(',');
	_buf.append("calcMaxFee=");
	_buf.appendInt(calcMaxFee);
	_buf.append(',');
	_buf.append("altPaysystemByte=");
	_buf.appendUint(altPaysystemByte);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashierFeeBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CashierFeeBody())) // not empty
	{
		_body.composeINT32(graceDepositsPeriodDays);
		_body.composeINT32(graceDeposits);
		_body.composeINT32(leftGraceDeposits);
		_body.composeINT32(calcRate_x_100K);
		_body.composeINT32(calcMinFee);
		_body.composeINT32(calcMaxFee);
		_body.composeBYTE(altPaysystemByte);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierFeeBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(graceDepositsPeriodDays);
	_parser0.parseINT32(graceDeposits);
	_parser0.parseINT32(leftGraceDeposits);
	_parser0.parseINT32(calcRate_x_100K);
	_parser0.parseINT32(calcMinFee);
	_parser0.parseINT32(calcMaxFee);
	_parser0.parseBYTE(altPaysystemByte);
}

/*static*/ void CashierServer::cli::CashierFeeBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 graceDepositsPeriodDays; _parser0.parseINT32(graceDepositsPeriodDays);
	AtfValidator::validateInt(_descr, "graceDepositsPeriodDays", graceDepositsPeriodDays, _checker, __FILE__, __LINE__);
	INT32 graceDeposits; _parser0.parseINT32(graceDeposits);
	AtfValidator::validateInt(_descr, "graceDeposits", graceDeposits, _checker, __FILE__, __LINE__);
	INT32 leftGraceDeposits; _parser0.parseINT32(leftGraceDeposits);
	AtfValidator::validateInt(_descr, "leftGraceDeposits", leftGraceDeposits, _checker, __FILE__, __LINE__);
	INT32 calcRate_x_100K; _parser0.parseINT32(calcRate_x_100K);
	AtfValidator::validateInt(_descr, "calcRate_x_100K", calcRate_x_100K, _checker, __FILE__, __LINE__);
	INT32 calcMinFee; _parser0.parseINT32(calcMinFee);
	AtfValidator::validateInt(_descr, "calcMinFee", calcMinFee, _checker, __FILE__, __LINE__);
	INT32 calcMaxFee; _parser0.parseINT32(calcMaxFee);
	AtfValidator::validateInt(_descr, "calcMaxFee", calcMaxFee, _checker, __FILE__, __LINE__);
	BYTE altPaysystemByte; _parser0.parseBYTE(altPaysystemByte);
	AtfValidator::validateInt(_descr, "altPaysystemByte", altPaysystemByte, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CashierPredefinedButtonsBody
//=================================================================

CashierServer::cli::CashierPredefinedButtonsBody::CashierPredefinedButtonsBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::CashierPredefinedButtonsBody::CashierPredefinedButtonsBody(CashierPredefinedButtonsBody&& _o)
	: roundedValidSuggestedAmounts(std::move(_o.roundedValidSuggestedAmounts))
	, selectedInd(std::move(_o.selectedInd))
{
}

CashierServer::cli::CashierPredefinedButtonsBody& CashierServer::cli::CashierPredefinedButtonsBody::operator=(CashierPredefinedButtonsBody&& _o)
{
	if(this != &_o)
	{
		roundedValidSuggestedAmounts = std::move(_o.roundedValidSuggestedAmounts);
		selectedInd = std::move(_o.selectedInd);
	}
	return *this;
}

#endif

void CashierServer::cli::CashierPredefinedButtonsBody::clear()
{
	roundedValidSuggestedAmounts.clear();
	selectedInd = 0;
}

bool CashierServer::cli::CashierPredefinedButtonsBody::equals(const CashierPredefinedButtonsBody& _o) const
{
	return roundedValidSuggestedAmounts.equals(_o.roundedValidSuggestedAmounts) &&
		selectedInd == _o.selectedInd;
}

const char *CashierServer::cli::CashierPredefinedButtonsBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("roundedValidSuggestedAmounts=");
	roundedValidSuggestedAmounts.toTraceString(_buf);
	_buf.append(',');
	_buf.append("selectedInd=");
	_buf.appendInt(selectedInd);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashierPredefinedButtonsBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CashierPredefinedButtonsBody())) // not empty
	{
		roundedValidSuggestedAmounts.composeMsg(_body);
		_body.composeINT32(selectedInd);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierPredefinedButtonsBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	roundedValidSuggestedAmounts.parseMsg(_parser0);
	_parser0.parseINT32(selectedInd);
}

/*static*/ void CashierServer::cli::CashierPredefinedButtonsBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szRoundedValidSuggestedAmounts = ThinAtf::LAtfVector< INT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("roundedValidSuggestedAmounts"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "roundedValidSuggestedAmounts", szRoundedValidSuggestedAmounts, _checker, __FILE__, __LINE__);
	INT32 selectedInd; _parser0.parseINT32(selectedInd);
	AtfValidator::validateInt(_descr, "selectedInd", selectedInd, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CashierOpenValueBody
//=================================================================

CashierServer::cli::CashierOpenValueBody::CashierOpenValueBody()
{
	clear();
}

void CashierServer::cli::CashierOpenValueBody::clear()
{
	openValue = false;
}

bool CashierServer::cli::CashierOpenValueBody::equals(const CashierOpenValueBody& _o) const
{
	return openValue == _o.openValue;
}

const char *CashierServer::cli::CashierOpenValueBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("openValue=");
	_buf.appendUint(openValue);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashierOpenValueBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CashierOpenValueBody())) // not empty
	{
		_body.composeBOOL(openValue);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierOpenValueBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(openValue);
}

/*static*/ void CashierServer::cli::CashierOpenValueBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	bool openValue; _parser0.parseBOOL(openValue);
	AtfValidator::validateInt(_descr, "openValue", openValue, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CashierDepositCurrencyBody
//=================================================================

CashierServer::cli::CashierDepositCurrencyBody::CashierDepositCurrencyBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::CashierDepositCurrencyBody::CashierDepositCurrencyBody(CashierDepositCurrencyBody&& _o)
	: processorCurr(std::move(_o.processorCurr))
	, predefinedButtons(std::move(_o.predefinedButtons))
	, openValue(std::move(_o.openValue))
{
}

CashierServer::cli::CashierDepositCurrencyBody& CashierServer::cli::CashierDepositCurrencyBody::operator=(CashierDepositCurrencyBody&& _o)
{
	if(this != &_o)
	{
		processorCurr = std::move(_o.processorCurr);
		predefinedButtons = std::move(_o.predefinedButtons);
		openValue = std::move(_o.openValue);
	}
	return *this;
}

#endif

void CashierServer::cli::CashierDepositCurrencyBody::clear()
{
	processorCurr.clear();
	predefinedButtons.clear();
	openValue.clear();
}

bool CashierServer::cli::CashierDepositCurrencyBody::equals(const CashierDepositCurrencyBody& _o) const
{
	return processorCurr.equals(_o.processorCurr) &&
		predefinedButtons.equals(_o.predefinedButtons) &&
		openValue.equals(_o.openValue);
}

const char *CashierServer::cli::CashierDepositCurrencyBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("processorCurr=");
	_buf.append(processorCurr);
	_buf.append(',');
	_buf.append("predefinedButtons=");
	predefinedButtons.toTraceString(_buf);
	_buf.append(',');
	_buf.append("openValue=");
	openValue.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashierDepositCurrencyBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CashierDepositCurrencyBody())) // not empty
	{
		_body.composeString(processorCurr);
		predefinedButtons.composeMsg(_body);
		openValue.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierDepositCurrencyBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(processorCurr);
	predefinedButtons.parseMsg(_parser0);
	openValue.parseMsg(_parser0);
}

/*static*/ void CashierServer::cli::CashierDepositCurrencyBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "processorCurr"); size_t szProcessorCurr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "processorCurr", szProcessorCurr, _checker, __FILE__, __LINE__);
	PString _descbuf;
	CashierPredefinedButtonsBody::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("predefinedButtons"), _fieldsWithUnparsedContent);
	CashierOpenValueBody::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("openValue"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CashierPrepopulatedCodeBody
//=================================================================

CashierServer::cli::CashierPrepopulatedCodeBody::CashierPrepopulatedCodeBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::CashierPrepopulatedCodeBody::CashierPrepopulatedCodeBody(CashierPrepopulatedCodeBody&& _o)
	: bonusCode(std::move(_o.bonusCode))
{
}

CashierServer::cli::CashierPrepopulatedCodeBody& CashierServer::cli::CashierPrepopulatedCodeBody::operator=(CashierPrepopulatedCodeBody&& _o)
{
	if(this != &_o)
	{
		bonusCode = std::move(_o.bonusCode);
	}
	return *this;
}

#endif

void CashierServer::cli::CashierPrepopulatedCodeBody::clear()
{
	bonusCode.clear();
}

bool CashierServer::cli::CashierPrepopulatedCodeBody::equals(const CashierPrepopulatedCodeBody& _o) const
{
	return bonusCode.equals(_o.bonusCode);
}

const char *CashierServer::cli::CashierPrepopulatedCodeBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("bonusCode=");
	_buf.append(bonusCode);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashierPrepopulatedCodeBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CashierPrepopulatedCodeBody())) // not empty
	{
		_body.composeString(bonusCode);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierPrepopulatedCodeBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(bonusCode);
}

/*static*/ void CashierServer::cli::CashierPrepopulatedCodeBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "bonusCode"); size_t szBonusCode = strlen(_dummy);
	AtfValidator::validateInt(_descr, "bonusCode", szBonusCode, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CashierSubType
//=================================================================

CashierServer::cli::CashierSubType::CashierSubType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::CashierSubType::CashierSubType(CashierSubType&& _o)
	: productId(std::move(_o.productId))
	, subTypeName(std::move(_o.subTypeName))
	, logoImageId(std::move(_o.logoImageId))
	, currencies(std::move(_o.currencies))
{
}

CashierServer::cli::CashierSubType& CashierServer::cli::CashierSubType::operator=(CashierSubType&& _o)
{
	if(this != &_o)
	{
		productId = std::move(_o.productId);
		subTypeName = std::move(_o.subTypeName);
		logoImageId = std::move(_o.logoImageId);
		currencies = std::move(_o.currencies);
	}
	return *this;
}

#endif

void CashierServer::cli::CashierSubType::clear()
{
	productId.clear();
	subTypeName.clear();
	logoImageId = 0;
	currencies.clear();
}

bool CashierServer::cli::CashierSubType::equals(const CashierSubType& _o) const
{
	return productId.equals(_o.productId) &&
		subTypeName.equals(_o.subTypeName) &&
		logoImageId == _o.logoImageId &&
		currencies.equals(_o.currencies);
}

const char *CashierServer::cli::CashierSubType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("productId=");
	_buf.append(productId);
	_buf.append(',');
	_buf.append("subTypeName=");
	_buf.append(subTypeName);
	_buf.append(',');
	_buf.append("logoImageId=");
	_buf.appendUint(logoImageId);
	_buf.append(',');
	_buf.append("currencies=");
	currencies.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashierSubType::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(productId);
	_msg.composeString(subTypeName);
	_msg.composeUINT32(logoImageId);
	currencies.composeMsg(_msg);
}

void CashierServer::cli::CashierSubType::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(productId);
	_parser.parseStringP(subTypeName);
	_parser.parseUINT32(logoImageId);
	currencies.parseMsg(_parser);
}

/*static*/ void CashierServer::cli::CashierSubType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "productId"); size_t szProductId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "productId", szProductId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "subTypeName"); size_t szSubTypeName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "subTypeName", szSubTypeName, _checker, __FILE__, __LINE__);
	UINT32 logoImageId; _parser.parseUINT32(logoImageId);
	AtfValidator::validateInt(_descr, "logoImageId", logoImageId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szCurrencies = ThinAtf::LAtfVector< PString, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("currencies"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "currencies", szCurrencies, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    CashierUrlPair
//=================================================================

CashierServer::cli::CashierUrlPair::CashierUrlPair()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::CashierUrlPair::CashierUrlPair(CashierUrlPair&& _o)
	: openAccountStr(std::move(_o.openAccountStr))
	, signUpLink(std::move(_o.signUpLink))
	, linkFlags(std::move(_o.linkFlags))
{
}

CashierServer::cli::CashierUrlPair& CashierServer::cli::CashierUrlPair::operator=(CashierUrlPair&& _o)
{
	if(this != &_o)
	{
		openAccountStr = std::move(_o.openAccountStr);
		signUpLink = std::move(_o.signUpLink);
		linkFlags = std::move(_o.linkFlags);
	}
	return *this;
}

#endif

void CashierServer::cli::CashierUrlPair::clear()
{
	openAccountStr.clear();
	signUpLink.clear();
	linkFlags = 0;
}

bool CashierServer::cli::CashierUrlPair::equals(const CashierUrlPair& _o) const
{
	return openAccountStr.equals(_o.openAccountStr) &&
		signUpLink.equals(_o.signUpLink) &&
		linkFlags == _o.linkFlags;
}

const char *CashierServer::cli::CashierUrlPair::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("openAccountStr=");
	_buf.append(openAccountStr);
	_buf.append(',');
	_buf.append("signUpLink=");
	_buf.append(signUpLink);
	_buf.append(',');
	_buf.append("linkFlags=");
	_buf.appendUint(linkFlags);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashierUrlPair::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(openAccountStr);
	_msg.composeString(signUpLink);
	_msg.composeUINT32(linkFlags);
}

void CashierServer::cli::CashierUrlPair::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(openAccountStr);
	_parser.parseStringP(signUpLink);
	_parser.parseUINT32(linkFlags);
}

/*static*/ void CashierServer::cli::CashierUrlPair::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "openAccountStr"); size_t szOpenAccountStr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "openAccountStr", szOpenAccountStr, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "signUpLink"); size_t szSignUpLink = strlen(_dummy);
	AtfValidator::validateInt(_descr, "signUpLink", szSignUpLink, _checker, __FILE__, __LINE__);
	UINT32 linkFlags; _parser.parseUINT32(linkFlags);
	AtfValidator::validateInt(_descr, "linkFlags", linkFlags, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    CashierAgeVerifyOne
//=================================================================

CashierServer::cli::CashierAgeVerifyOne::CashierAgeVerifyOne()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::CashierAgeVerifyOne::CashierAgeVerifyOne(CashierAgeVerifyOne&& _o)
	: id_type(std::move(_o.id_type))
	, id_descr(std::move(_o.id_descr))
{
}

CashierServer::cli::CashierAgeVerifyOne& CashierServer::cli::CashierAgeVerifyOne::operator=(CashierAgeVerifyOne&& _o)
{
	if(this != &_o)
	{
		id_type = std::move(_o.id_type);
		id_descr = std::move(_o.id_descr);
	}
	return *this;
}

#endif

void CashierServer::cli::CashierAgeVerifyOne::clear()
{
	id_type = 0;
	id_descr.clear();
}

bool CashierServer::cli::CashierAgeVerifyOne::equals(const CashierAgeVerifyOne& _o) const
{
	return id_type == _o.id_type &&
		id_descr.equals(_o.id_descr);
}

const char *CashierServer::cli::CashierAgeVerifyOne::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("id_type=");
	_buf.appendUint(id_type);
	_buf.append(',');
	_buf.append("id_descr=");
	_buf.append(id_descr);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashierAgeVerifyOne::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(id_type);
	_msg.composeString(id_descr);
}

void CashierServer::cli::CashierAgeVerifyOne::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(id_type);
	_parser.parseStringP(id_descr);
}

/*static*/ void CashierServer::cli::CashierAgeVerifyOne::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 id_type; _parser.parseUINT32(id_type);
	AtfValidator::validateInt(_descr, "id_type", id_type, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "id_descr"); size_t szId_descr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "id_descr", szId_descr, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    CashierPaysystemReply
//=================================================================

CashierServer::cli::CashierPaysystemReply::CashierPaysystemReply()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::CashierPaysystemReply::CashierPaysystemReply(CashierPaysystemReply&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, paySystemByte(std::move(_o.paySystemByte))
	, isAvailable(std::move(_o.isAvailable))
	, paysystemMessage(std::move(_o.paysystemMessage))
	, subTypes(std::move(_o.subTypes))
	, urlPairs(std::move(_o.urlPairs))
	, ageVerifyNeeded(std::move(_o.ageVerifyNeeded))
	, ageVerifications(std::move(_o.ageVerifications))
	, ageVerifyProcessorId(std::move(_o.ageVerifyProcessorId))
	, daysToClear(std::move(_o.daysToClear))
	, availableCurrencies(std::move(_o.availableCurrencies))
	, bonusWithCodeExists(std::move(_o.bonusWithCodeExists))
	, validationFailuresThreshold(std::move(_o.validationFailuresThreshold))
	, selfImposedLimit(std::move(_o.selfImposedLimit))
	, allowedAmount(std::move(_o.allowedAmount))
	, fastDepositIsOk(std::move(_o.fastDepositIsOk))
	, isItPs4AuthUser(std::move(_o.isItPs4AuthUser))
	, maxCashinDaily(std::move(_o.maxCashinDaily))
	, maxCashinWeekly(std::move(_o.maxCashinWeekly))
	, maxCashinMonthly(std::move(_o.maxCashinMonthly))
	, paysystemFeeApplies(std::move(_o.paysystemFeeApplies))
	, cardNumLength(std::move(_o.cardNumLength))
	, depositAvailableCurrencies(std::move(_o.depositAvailableCurrencies))
	, prepopulatedCodes(std::move(_o.prepopulatedCodes))
{
}

CashierServer::cli::CashierPaysystemReply& CashierServer::cli::CashierPaysystemReply::operator=(CashierPaysystemReply&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		paySystemByte = std::move(_o.paySystemByte);
		isAvailable = std::move(_o.isAvailable);
		paysystemMessage = std::move(_o.paysystemMessage);
		subTypes = std::move(_o.subTypes);
		urlPairs = std::move(_o.urlPairs);
		ageVerifyNeeded = std::move(_o.ageVerifyNeeded);
		ageVerifications = std::move(_o.ageVerifications);
		ageVerifyProcessorId = std::move(_o.ageVerifyProcessorId);
		daysToClear = std::move(_o.daysToClear);
		availableCurrencies = std::move(_o.availableCurrencies);
		bonusWithCodeExists = std::move(_o.bonusWithCodeExists);
		validationFailuresThreshold = std::move(_o.validationFailuresThreshold);
		selfImposedLimit = std::move(_o.selfImposedLimit);
		allowedAmount = std::move(_o.allowedAmount);
		fastDepositIsOk = std::move(_o.fastDepositIsOk);
		isItPs4AuthUser = std::move(_o.isItPs4AuthUser);
		maxCashinDaily = std::move(_o.maxCashinDaily);
		maxCashinWeekly = std::move(_o.maxCashinWeekly);
		maxCashinMonthly = std::move(_o.maxCashinMonthly);
		paysystemFeeApplies = std::move(_o.paysystemFeeApplies);
		cardNumLength = std::move(_o.cardNumLength);
		depositAvailableCurrencies = std::move(_o.depositAvailableCurrencies);
		prepopulatedCodes = std::move(_o.prepopulatedCodes);
	}
	return *this;
}

#endif

void CashierServer::cli::CashierPaysystemReply::clear()
{
	errCode = 0;
	errDescr.clear();
	paySystemByte = 0;
	isAvailable = false;
	paysystemMessage.clear();
	subTypes.clear();
	urlPairs.clear();
	ageVerifyNeeded = false;
	ageVerifications.clear();
	ageVerifyProcessorId = 0;
	daysToClear = 0;
	availableCurrencies.clear();
	bonusWithCodeExists = false;
	validationFailuresThreshold = 0;
	selfImposedLimit = 0;
	allowedAmount = 0;
	fastDepositIsOk = false;
	isItPs4AuthUser = false;
	maxCashinDaily = 0;
	maxCashinWeekly = 0;
	maxCashinMonthly = 0;
	paysystemFeeApplies = false;
	cardNumLength = 0;
	depositAvailableCurrencies.clear();
	prepopulatedCodes.clear();
}

bool CashierServer::cli::CashierPaysystemReply::equals(const CashierPaysystemReply& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		paySystemByte == _o.paySystemByte &&
		isAvailable == _o.isAvailable &&
		paysystemMessage.equals(_o.paysystemMessage) &&
		subTypes.equals(_o.subTypes) &&
		urlPairs.equals(_o.urlPairs) &&
		ageVerifyNeeded == _o.ageVerifyNeeded &&
		ageVerifications.equals(_o.ageVerifications) &&
		ageVerifyProcessorId == _o.ageVerifyProcessorId &&
		daysToClear == _o.daysToClear &&
		availableCurrencies.equals(_o.availableCurrencies) &&
		bonusWithCodeExists == _o.bonusWithCodeExists &&
		validationFailuresThreshold == _o.validationFailuresThreshold &&
		selfImposedLimit == _o.selfImposedLimit &&
		allowedAmount == _o.allowedAmount &&
		fastDepositIsOk == _o.fastDepositIsOk &&
		isItPs4AuthUser == _o.isItPs4AuthUser &&
		maxCashinDaily == _o.maxCashinDaily &&
		maxCashinWeekly == _o.maxCashinWeekly &&
		maxCashinMonthly == _o.maxCashinMonthly &&
		paysystemFeeApplies == _o.paysystemFeeApplies &&
		cardNumLength == _o.cardNumLength &&
		depositAvailableCurrencies.equals(_o.depositAvailableCurrencies) &&
		prepopulatedCodes.equals(_o.prepopulatedCodes);
}

const char *CashierServer::cli::CashierPaysystemReply::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("paySystemByte=");
		_buf.appendUint(paySystemByte);
		_buf.append(',');
		_buf.append("isAvailable=");
		_buf.appendUint(isAvailable);
		_buf.append(',');
		_buf.append("paysystemMessage=");
		_buf.append(paysystemMessage);
		_buf.append(',');
		_buf.append("subTypes=");
		subTypes.toTraceString(_buf);
		_buf.append(',');
		_buf.append("urlPairs=");
		urlPairs.toTraceString(_buf);
		_buf.append(',');
		_buf.append("ageVerifyNeeded=");
		_buf.appendUint(ageVerifyNeeded);
		_buf.append(',');
		_buf.append("ageVerifications=");
		ageVerifications.toTraceString(_buf);
		_buf.append(',');
		_buf.append("ageVerifyProcessorId=");
		_buf.appendUint(ageVerifyProcessorId);
		_buf.append(',');
		_buf.append("daysToClear=");
		_buf.appendInt(daysToClear);
		_buf.append(',');
		_buf.append("availableCurrencies=");
		availableCurrencies.toTraceString(_buf);
		_buf.append(',');
		_buf.append("bonusWithCodeExists=");
		_buf.appendUint(bonusWithCodeExists);
		_buf.append(',');
		_buf.append("validationFailuresThreshold=");
		_buf.appendUint(validationFailuresThreshold);
		_buf.append(',');
		_buf.append("selfImposedLimit=");
		_buf.appendInt(selfImposedLimit);
		_buf.append(',');
		_buf.append("allowedAmount=");
		_buf.appendInt(allowedAmount);
		_buf.append(',');
		_buf.append("fastDepositIsOk=");
		_buf.appendUint(fastDepositIsOk);
		_buf.append(',');
		_buf.append("isItPs4AuthUser=");
		_buf.appendUint(isItPs4AuthUser);
		_buf.append(',');
		_buf.append("maxCashinDaily=");
		_buf.appendInt(maxCashinDaily);
		_buf.append(',');
		_buf.append("maxCashinWeekly=");
		_buf.appendInt(maxCashinWeekly);
		_buf.append(',');
		_buf.append("maxCashinMonthly=");
		_buf.appendInt(maxCashinMonthly);
		_buf.append(',');
		_buf.append("paysystemFeeApplies=");
		_buf.appendUint(paysystemFeeApplies);
		_buf.append(',');
		_buf.append("cardNumLength=");
		_buf.appendInt(cardNumLength);
		_buf.append(',');
		_buf.append("depositAvailableCurrencies=");
		depositAvailableCurrencies.toTraceString(_buf);
		_buf.append(',');
		_buf.append(',');
		_buf.append("prepopulatedCodes=");
		prepopulatedCodes.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashierPaysystemReply::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeBYTE(paySystemByte);
		_msg.composeBOOL(isAvailable);
		_msg.composeString(paysystemMessage);
		subTypes.composeMsg(_msg);
		urlPairs.composeMsg(_msg);
		_msg.composeBOOL(ageVerifyNeeded);
		ageVerifications.composeMsg(_msg);
		_msg.composeUINT32(ageVerifyProcessorId);
		_msg.composeINT32(daysToClear);
		availableCurrencies.composeMsg(_msg);
		_msg.composeBOOL(bonusWithCodeExists);
		_msg.composeUINT32(validationFailuresThreshold);
		_msg.composeINT32(selfImposedLimit);
		_msg.composeINT32(allowedAmount);
		_msg.composeBOOL(fastDepositIsOk);
		_msg.composeBOOL(isItPs4AuthUser);
		CommMsgBody _msg0;
		_msg0.composeINT32(maxCashinDaily);
		_msg0.composeINT32(maxCashinWeekly);
		_msg0.composeINT32(maxCashinMonthly);
		_msg.composeMsgBody(_msg0);
		_msg.composeBOOL(paysystemFeeApplies);
		_msg.composeINT32(cardNumLength);
		CommMsgBody _msg1;
		depositAvailableCurrencies.composeMsg(_msg1);
		_msg.composeMsgBody(_msg1);
		CommMsgBody _msg2;
		_msg.composeMsgBody(_msg2);
		prepopulatedCodes.composeMsg(_msg);
	}
}

void CashierServer::cli::CashierPaysystemReply::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseBYTE(paySystemByte);
		_parser.parseBOOL(isAvailable);
		_parser.parseStringP(paysystemMessage);
		subTypes.parseMsg(_parser);
		urlPairs.parseMsg(_parser);
		_parser.parseBOOL(ageVerifyNeeded);
		ageVerifications.parseMsg(_parser);
		_parser.parseUINT32(ageVerifyProcessorId);
		_parser.parseINT32(daysToClear);
		availableCurrencies.parseMsg(_parser);
		_parser.parseBOOL(bonusWithCodeExists);
		_parser.parseUINT32(validationFailuresThreshold);
		_parser.parseINT32(selfImposedLimit);
		_parser.parseINT32(allowedAmount);
		_parser.parseBOOL(fastDepositIsOk);
		_parser.parseBOOL(isItPs4AuthUser);
		parseAnonymousMsgBody0(_parser);
		_parser.parseBOOL(paysystemFeeApplies);
		_parser.parseINT32(cardNumLength);
		parseAnonymousMsgBody1(_parser);
		parseAnonymousMsgBody2(_parser);
		prepopulatedCodes.parseMsg(_parser);
	}
}

/*static*/ void CashierServer::cli::CashierPaysystemReply::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		BYTE paySystemByte; _parser.parseBYTE(paySystemByte);
		AtfValidator::validateInt(_descr, "paySystemByte", paySystemByte, _checker, __FILE__, __LINE__);
		bool isAvailable; _parser.parseBOOL(isAvailable);
		AtfValidator::validateInt(_descr, "isAvailable", isAvailable, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "paysystemMessage"); size_t szPaysystemMessage = strlen(_dummy);
		AtfValidator::validateInt(_descr, "paysystemMessage", szPaysystemMessage, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szSubTypes = ThinAtf::LAtfVector< CashierSubType, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("subTypes"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "subTypes", szSubTypes, _checker, __FILE__, __LINE__);
		int szUrlPairs = ThinAtf::LAtfVector< CashierUrlPair, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("urlPairs"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "urlPairs", szUrlPairs, _checker, __FILE__, __LINE__);
		bool ageVerifyNeeded; _parser.parseBOOL(ageVerifyNeeded);
		AtfValidator::validateInt(_descr, "ageVerifyNeeded", ageVerifyNeeded, _checker, __FILE__, __LINE__);
		int szAgeVerifications = ThinAtf::LAtfVector< CashierAgeVerifyOne, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("ageVerifications"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "ageVerifications", szAgeVerifications, _checker, __FILE__, __LINE__);
		UINT32 ageVerifyProcessorId; _parser.parseUINT32(ageVerifyProcessorId);
		AtfValidator::validateInt(_descr, "ageVerifyProcessorId", ageVerifyProcessorId, _checker, __FILE__, __LINE__);
		INT32 daysToClear; _parser.parseINT32(daysToClear);
		AtfValidator::validateInt(_descr, "daysToClear", daysToClear, _checker, __FILE__, __LINE__);
		int szAvailableCurrencies = ThinAtf::LAtfVector< CashierAvailableCurrency, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("availableCurrencies"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "availableCurrencies", szAvailableCurrencies, _checker, __FILE__, __LINE__);
		bool bonusWithCodeExists; _parser.parseBOOL(bonusWithCodeExists);
		AtfValidator::validateInt(_descr, "bonusWithCodeExists", bonusWithCodeExists, _checker, __FILE__, __LINE__);
		UINT32 validationFailuresThreshold; _parser.parseUINT32(validationFailuresThreshold);
		AtfValidator::validateInt(_descr, "validationFailuresThreshold", validationFailuresThreshold, _checker, __FILE__, __LINE__);
		INT32 selfImposedLimit; _parser.parseINT32(selfImposedLimit);
		AtfValidator::validateInt(_descr, "selfImposedLimit", selfImposedLimit, _checker, __FILE__, __LINE__);
		INT32 allowedAmount; _parser.parseINT32(allowedAmount);
		AtfValidator::validateInt(_descr, "allowedAmount", allowedAmount, _checker, __FILE__, __LINE__);
		bool fastDepositIsOk; _parser.parseBOOL(fastDepositIsOk);
		AtfValidator::validateInt(_descr, "fastDepositIsOk", fastDepositIsOk, _checker, __FILE__, __LINE__);
		bool isItPs4AuthUser; _parser.parseBOOL(isItPs4AuthUser);
		AtfValidator::validateInt(_descr, "isItPs4AuthUser", isItPs4AuthUser, _checker, __FILE__, __LINE__);
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
		bool paysystemFeeApplies; _parser.parseBOOL(paysystemFeeApplies);
		AtfValidator::validateInt(_descr, "paysystemFeeApplies", paysystemFeeApplies, _checker, __FILE__, __LINE__);
		INT32 cardNumLength; _parser.parseINT32(cardNumLength);
		AtfValidator::validateInt(_descr, "cardNumLength", cardNumLength, _checker, __FILE__, __LINE__);
		validateAnonymousMsgBody1(_parser, _checker, _descr, _fieldsWithUnparsedContent);
		validateAnonymousMsgBody2(_parser, _checker, _descr, _fieldsWithUnparsedContent);
		int szPrepopulatedCodes = ThinAtf::LAtfVector< CashierPrepopulatedCodeBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("prepopulatedCodes"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "prepopulatedCodes", szPrepopulatedCodes, _checker, __FILE__, __LINE__);
	}
}

void CashierServer::cli::CashierPaysystemReply::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(maxCashinDaily);
	_parser0.parseINT32(maxCashinWeekly);
	_parser0.parseINT32(maxCashinMonthly);
}

/*static*/ void CashierServer::cli::CashierPaysystemReply::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 maxCashinDaily; _parser0.parseINT32(maxCashinDaily);
	AtfValidator::validateInt(_descr, "maxCashinDaily", maxCashinDaily, _checker, __FILE__, __LINE__);
	INT32 maxCashinWeekly; _parser0.parseINT32(maxCashinWeekly);
	AtfValidator::validateInt(_descr, "maxCashinWeekly", maxCashinWeekly, _checker, __FILE__, __LINE__);
	INT32 maxCashinMonthly; _parser0.parseINT32(maxCashinMonthly);
	AtfValidator::validateInt(_descr, "maxCashinMonthly", maxCashinMonthly, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::CashierPaysystemReply::parseAnonymousMsgBody1(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	depositAvailableCurrencies.parseMsg(_parser0);
}

/*static*/ void CashierServer::cli::CashierPaysystemReply::validateAnonymousMsgBody1(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szDepositAvailableCurrencies = ThinAtf::LAtfVector< CashierDepositCurrencyBody, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("depositAvailableCurrencies"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "depositAvailableCurrencies", szDepositAvailableCurrencies, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::CashierPaysystemReply::parseAnonymousMsgBody2(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
}

/*static*/ void CashierServer::cli::CashierPaysystemReply::validateAnonymousMsgBody2(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

//=================================================================
//                Protocol_MSG_CASHIER_CHECK_PAYSYSTEM_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM_REPLY::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM_REPLY::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM_REPLY(Protocol_MSG_CASHIER_CHECK_PAYSYSTEM_REPLY&& _o)
	: reply(std::move(_o.reply))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM_REPLY::operator=(Protocol_MSG_CASHIER_CHECK_PAYSYSTEM_REPLY&& _o)
{
	if(this != &_o)
	{
		reply = std::move(_o.reply);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM_REPLY::clear()
{
	reply.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM_REPLY::equals(const Protocol_MSG_CASHIER_CHECK_PAYSYSTEM_REPLY& _o) const
{
	return reply.equals(_o.reply);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CHECK_PAYSYSTEM_REPLY).append(")");
	_buf.append(',');
	_buf.append("reply=");
	reply.toTraceString(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM_REPLY::composeMsg(CommMsgBody& _msg) const
{
	reply.composeMsg(_msg);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM_REPLY::parseMsg(CommMsgParser& _parser)
{
	reply.parseMsg(_parser);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CHECK_PAYSYSTEM_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	CashierPaysystemReply::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("reply"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    FastDepositDataBody
//=================================================================

CashierServer::cli::FastDepositDataBody::FastDepositDataBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::FastDepositDataBody::FastDepositDataBody(FastDepositDataBody&& _o)
	: currency(std::move(_o.currency))
	, amount(std::move(_o.amount))
{
}

CashierServer::cli::FastDepositDataBody& CashierServer::cli::FastDepositDataBody::operator=(FastDepositDataBody&& _o)
{
	if(this != &_o)
	{
		currency = std::move(_o.currency);
		amount = std::move(_o.amount);
	}
	return *this;
}

#endif

void CashierServer::cli::FastDepositDataBody::clear()
{
	currency.clear();
	amount = 0;
}

bool CashierServer::cli::FastDepositDataBody::equals(const FastDepositDataBody& _o) const
{
	return currency.equals(_o.currency) &&
		amount == _o.amount;
}

const char *CashierServer::cli::FastDepositDataBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendInt(amount);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::FastDepositDataBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(FastDepositDataBody())) // not empty
	{
		_body.composeString(currency);
		_body.composeINT32(amount);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::FastDepositDataBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(currency);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT32(amount);
}

/*static*/ void CashierServer::cli::FastDepositDataBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, 8, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT32 amount; _parser0.parseINT32(amount);
	AtfValidator::validateIntRange(_descr, "amount", amount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2(Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2&& _o)
	: paySystemByte(std::move(_o.paySystemByte))
	, requestCurrency(std::move(_o.requestCurrency))
	, cardInfoId(std::move(_o.cardInfoId))
	, fastDepositData(std::move(_o.fastDepositData))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2& CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2::operator=(Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2&& _o)
{
	if(this != &_o)
	{
		paySystemByte = std::move(_o.paySystemByte);
		requestCurrency = std::move(_o.requestCurrency);
		cardInfoId = std::move(_o.cardInfoId);
		fastDepositData = std::move(_o.fastDepositData);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2::clear()
{
	paySystemByte = 0;
	requestCurrency.clear();
	cardInfoId = 0;
	fastDepositData.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2::equals(const Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2& _o) const
{
	return paySystemByte == _o.paySystemByte &&
		requestCurrency.equals(_o.requestCurrency) &&
		cardInfoId == _o.cardInfoId &&
		fastDepositData.equals(_o.fastDepositData);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CHECK_PAYSYSTEM2).append(")");
	_buf.append(',');
	_buf.append("paySystemByte=");
	_buf.appendUint(paySystemByte);
	_buf.append(',');
	_buf.append("requestCurrency=");
	_buf.append(requestCurrency);
	_buf.append(',');
	_buf.append("cardInfoId=");
	_buf.appendUint(cardInfoId);
	_buf.append(',');
	_buf.append("fastDepositData=");
	fastDepositData.toTraceString(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(paySystemByte);
	_msg.composeString(requestCurrency);
	_msg.composeUINT32(cardInfoId);
	fastDepositData.composeMsg(_msg);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(paySystemByte);
	_parser.parseStringP(requestCurrency);
	_parser.parseUINT32(cardInfoId);
	if(_parser.parseEnded()) return;
	fastDepositData.parseMsg(_parser);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CHECK_PAYSYSTEM2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE paySystemByte; _parser.parseBYTE(paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "requestCurrency"); size_t szRequestCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "requestCurrency", szRequestCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	UINT32 cardInfoId; _parser.parseUINT32(cardInfoId);
	AtfValidator::validateInt(_descr, "cardInfoId", cardInfoId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PString _descbuf;
	FastDepositDataBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("fastDepositData"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY(Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY&& _o)
	: reply(std::move(_o.reply))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY::operator=(Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY&& _o)
{
	if(this != &_o)
	{
		reply = std::move(_o.reply);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY::clear()
{
	reply.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY::equals(const Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY& _o) const
{
	return reply.equals(_o.reply);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY).append(")");
	_buf.append(',');
	_buf.append("reply=");
	reply.toTraceString(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY::composeMsg(CommMsgBody& _msg) const
{
	reply.composeMsg(_msg);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY::parseMsg(CommMsgParser& _parser)
{
	reply.parseMsg(_parser);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	CashierPaysystemReply::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("reply"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CASHIN_HOSTED
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED::Protocol_MSG_CASHIER_CASHIN_HOSTED()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED::Protocol_MSG_CASHIER_CASHIN_HOSTED(Protocol_MSG_CASHIER_CASHIN_HOSTED&& _o)
	: userId(std::move(_o.userId))
	, amount(std::move(_o.amount))
	, currency(std::move(_o.currency))
	, converted(std::move(_o.converted))
	, paySystemByte(std::move(_o.paySystemByte))
	, productId(std::move(_o.productId))
	, bonusId(std::move(_o.bonusId))
	, bonusCode(std::move(_o.bonusCode))
	, doNotCancelCashouts(std::move(_o.doNotCancelCashouts))
	, balanceCurrency(std::move(_o.balanceCurrency))
	, clientBalance(std::move(_o.clientBalance))
	, cardNum(std::move(_o.cardNum))
	, saveCardInfoRequested(std::move(_o.saveCardInfoRequested))
	, fastDepositTransaction(std::move(_o.fastDepositTransaction))
	, saveInfoForFastDeposit(std::move(_o.saveInfoForFastDeposit))
	, cardInfoId(std::move(_o.cardInfoId))
	, awardId(std::move(_o.awardId))
	, clientDepositFlags(std::move(_o.clientDepositFlags))
	, encryptedCardNum(std::move(_o.encryptedCardNum))
	, paymentSpecificDataVec(std::move(_o.paymentSpecificDataVec))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED& CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED::operator=(Protocol_MSG_CASHIER_CASHIN_HOSTED&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		amount = std::move(_o.amount);
		currency = std::move(_o.currency);
		converted = std::move(_o.converted);
		paySystemByte = std::move(_o.paySystemByte);
		productId = std::move(_o.productId);
		bonusId = std::move(_o.bonusId);
		bonusCode = std::move(_o.bonusCode);
		doNotCancelCashouts = std::move(_o.doNotCancelCashouts);
		balanceCurrency = std::move(_o.balanceCurrency);
		clientBalance = std::move(_o.clientBalance);
		cardNum = std::move(_o.cardNum);
		saveCardInfoRequested = std::move(_o.saveCardInfoRequested);
		fastDepositTransaction = std::move(_o.fastDepositTransaction);
		saveInfoForFastDeposit = std::move(_o.saveInfoForFastDeposit);
		cardInfoId = std::move(_o.cardInfoId);
		awardId = std::move(_o.awardId);
		clientDepositFlags = std::move(_o.clientDepositFlags);
		encryptedCardNum = std::move(_o.encryptedCardNum);
		paymentSpecificDataVec = std::move(_o.paymentSpecificDataVec);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED::clear()
{
	userId.clear();
	amount = 0;
	currency.clear();
	converted = 0;
	paySystemByte = 0;
	productId.clear();
	bonusId = 0;
	bonusCode.clear();
	doNotCancelCashouts = 0;
	balanceCurrency.clear();
	clientBalance = 0;
	cardNum.clear();
	saveCardInfoRequested = false;
	fastDepositTransaction = false;
	saveInfoForFastDeposit = false;
	cardInfoId = 0;
	awardId = 0;
	clientDepositFlags = 0;
	encryptedCardNum.clear();
	paymentSpecificDataVec.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED::equals(const Protocol_MSG_CASHIER_CASHIN_HOSTED& _o) const
{
	return userId.equals(_o.userId) &&
		amount == _o.amount &&
		currency.equals(_o.currency) &&
		converted == _o.converted &&
		paySystemByte == _o.paySystemByte &&
		productId.equals(_o.productId) &&
		bonusId == _o.bonusId &&
		bonusCode.equals(_o.bonusCode) &&
		doNotCancelCashouts == _o.doNotCancelCashouts &&
		balanceCurrency.equals(_o.balanceCurrency) &&
		clientBalance == _o.clientBalance &&
		cardNum.equals(_o.cardNum) &&
		saveCardInfoRequested == _o.saveCardInfoRequested &&
		fastDepositTransaction == _o.fastDepositTransaction &&
		saveInfoForFastDeposit == _o.saveInfoForFastDeposit &&
		cardInfoId == _o.cardInfoId &&
		awardId == _o.awardId &&
		clientDepositFlags == _o.clientDepositFlags &&
		encryptedCardNum.size() == _o.encryptedCardNum.size() && memcmp(encryptedCardNum.ptr(), _o.encryptedCardNum.ptr(), encryptedCardNum.size()) == 0 &&
		paymentSpecificDataVec.equals(_o.paymentSpecificDataVec);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CASHIN_HOSTED).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendInt(amount);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("converted=");
	_buf.appendInt(converted);
	_buf.append(',');
	_buf.append("paySystemByte=");
	_buf.appendUint(paySystemByte);
	_buf.append(',');
	_buf.append("productId=");
	_buf.append(productId);
	_buf.append(',');
	_buf.append("bonusId=");
	_buf.appendUint(bonusId);
	_buf.append(',');
	_buf.append("bonusCode=");
	_buf.append(bonusCode);
	_buf.append(',');
	_buf.append("doNotCancelCashouts=");
	_buf.appendUint(doNotCancelCashouts);
	_buf.append(',');
	_buf.append("balanceCurrency=");
	_buf.append(balanceCurrency);
	_buf.append(',');
	_buf.append("clientBalance=");
	_buf.appendInt(clientBalance);
	_buf.append(',');
	_buf.append("cardNum=");
	_buf.append(cardNum);
	_buf.append(',');
	_buf.append("saveCardInfoRequested=");
	_buf.appendUint(saveCardInfoRequested);
	_buf.append(',');
	_buf.append("fastDepositTransaction=");
	_buf.appendUint(fastDepositTransaction);
	_buf.append(',');
	_buf.append("saveInfoForFastDeposit=");
	_buf.appendUint(saveInfoForFastDeposit);
	_buf.append(',');
	_buf.append("cardInfoId=");
	_buf.appendUint(cardInfoId);
	_buf.append(',');
	_buf.append("awardId=");
	_buf.appendUint(awardId);
	_buf.append(',');
	_buf.append("clientDepositFlags=");
	_buf.appendUint(clientDepositFlags);
	_buf.append(',');
	_buf.append("encryptedCardNum=");
	ThinAtf::AtfTempl<PBlock>::ToTraceString(_buf, encryptedCardNum);
	_buf.append(',');
	_buf.append("paymentSpecificDataVec=");
	paymentSpecificDataVec.toTraceString(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeINT32(amount);
	_msg.composeString(currency);
	_msg.composeINT32(converted);
	_msg.composeBYTE(paySystemByte);
	_msg.composeString(productId);
	_msg.composeUINT32(bonusId);
	_msg.composeString(bonusCode);
	_msg.composeBYTE(doNotCancelCashouts);
	_msg.composeString(balanceCurrency);
	_msg.composeINT32(clientBalance);
	_msg.composeString(cardNum);
	_msg.composeBOOL(saveCardInfoRequested);
	_msg.composeBOOL(fastDepositTransaction);
	_msg.composeBOOL(saveInfoForFastDeposit);
	_msg.composeUINT32(cardInfoId);
	_msg.composeUINT32(awardId);
	_msg.composeUINT32(clientDepositFlags);
	_msg._composeVarBlock(encryptedCardNum.ptr(), encryptedCardNum.size());
	paymentSpecificDataVec.composeMsg(_msg);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseINT32(amount);
	_parser.parseStringP(currency);
	_parser.parseINT32(converted);
	_parser.parseBYTE(paySystemByte);
	_parser.parseStringP(productId);
	_parser.parseUINT32(bonusId);
	_parser.parseStringP(bonusCode);
	_parser.parseBYTE(doNotCancelCashouts);
	_parser.parseStringP(balanceCurrency);
	_parser.parseINT32(clientBalance);
	_parser.parseStringP(cardNum);
	_parser.parseBOOL(saveCardInfoRequested);
	_parser.parseBOOL(fastDepositTransaction);
	_parser.parseBOOL(saveInfoForFastDeposit);
	_parser.parseUINT32(cardInfoId);
	_parser.parseUINT32(awardId);
	_parser.parseUINT32(clientDepositFlags);
	if(_parser.parseEnded()) return;
	_parser.parsePBlock(encryptedCardNum);
	if(_parser.parseEnded()) return;
	paymentSpecificDataVec.parseMsg(_parser);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CASHIN_HOSTED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	INT32 amount; _parser.parseINT32(amount);
	AtfValidator::validateIntRange(_descr, "amount", amount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	INT32 converted; _parser.parseINT32(converted);
	AtfValidator::validateIntRange(_descr, "converted", converted, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	BYTE paySystemByte; _parser.parseBYTE(paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "productId"); size_t szProductId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "productId", szProductId, PRODUCT_ID_LEN, _checker, __FILE__, __LINE__);
	UINT32 bonusId; _parser.parseUINT32(bonusId);
	AtfValidator::validateInt(_descr, "bonusId", bonusId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "bonusCode"); size_t szBonusCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bonusCode", szBonusCode, BONUS_CODE_LEN, _checker, __FILE__, __LINE__);
	BYTE doNotCancelCashouts; _parser.parseBYTE(doNotCancelCashouts);
	AtfValidator::validateInt(_descr, "doNotCancelCashouts", doNotCancelCashouts, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "balanceCurrency"); size_t szBalanceCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "balanceCurrency", szBalanceCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	INT32 clientBalance; _parser.parseINT32(clientBalance);
	AtfValidator::validateIntRange(_descr, "clientBalance", clientBalance, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "cardNum"); size_t szCardNum = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "cardNum", szCardNum, CARDNUM_LEN, _checker, __FILE__, __LINE__);
	bool saveCardInfoRequested; _parser.parseBOOL(saveCardInfoRequested);
	AtfValidator::validateInt(_descr, "saveCardInfoRequested", saveCardInfoRequested, _checker, __FILE__, __LINE__);
	bool fastDepositTransaction; _parser.parseBOOL(fastDepositTransaction);
	AtfValidator::validateInt(_descr, "fastDepositTransaction", fastDepositTransaction, _checker, __FILE__, __LINE__);
	bool saveInfoForFastDeposit; _parser.parseBOOL(saveInfoForFastDeposit);
	AtfValidator::validateInt(_descr, "saveInfoForFastDeposit", saveInfoForFastDeposit, _checker, __FILE__, __LINE__);
	UINT32 cardInfoId; _parser.parseUINT32(cardInfoId);
	AtfValidator::validateInt(_descr, "cardInfoId", cardInfoId, _checker, __FILE__, __LINE__);
	UINT32 awardId; _parser.parseUINT32(awardId);
	AtfValidator::validateInt(_descr, "awardId", awardId, _checker, __FILE__, __LINE__);
	UINT32 clientDepositFlags; _parser.parseUINT32(clientDepositFlags);
	AtfValidator::validateIntMax(_descr, "clientDepositFlags", clientDepositFlags, ((((UINT32)eClientDepositFlags_Last)<<1)-1), _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	const BYTE* encryptedCardNum; size_t szEncryptedCardNum; _parser._parseVarBlock(encryptedCardNum, szEncryptedCardNum);  /*encryptedCardNum*/
	AtfValidator::validateIntMax(_descr, "encryptedCardNum", szEncryptedCardNum, 4000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PString _descbuf;
	PaymentSpecificDataVec::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("paymentSpecificDataVec"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CASHIN_HOSTED_REDIRECT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED_REDIRECT::Protocol_MSG_CASHIER_CASHIN_HOSTED_REDIRECT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED_REDIRECT::Protocol_MSG_CASHIER_CASHIN_HOSTED_REDIRECT(Protocol_MSG_CASHIER_CASHIN_HOSTED_REDIRECT&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, formMethod(std::move(_o.formMethod))
	, formAction(std::move(_o.formAction))
	, transId(std::move(_o.transId))
	, xTransStr(std::move(_o.xTransStr))
	, cardTypeByte(std::move(_o.cardTypeByte))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED_REDIRECT& CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED_REDIRECT::operator=(Protocol_MSG_CASHIER_CASHIN_HOSTED_REDIRECT&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		formMethod = std::move(_o.formMethod);
		formAction = std::move(_o.formAction);
		transId = std::move(_o.transId);
		xTransStr = std::move(_o.xTransStr);
		cardTypeByte = std::move(_o.cardTypeByte);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED_REDIRECT::clear()
{
	errCode = 0;
	errDescr.clear();
	formMethod.clear();
	formAction.clear();
	transId = 0;
	xTransStr.clear();
	cardTypeByte = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED_REDIRECT::equals(const Protocol_MSG_CASHIER_CASHIN_HOSTED_REDIRECT& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		formMethod.equals(_o.formMethod) &&
		formAction.equals(_o.formAction) &&
		transId == _o.transId &&
		xTransStr.equals(_o.xTransStr) &&
		cardTypeByte == _o.cardTypeByte;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED_REDIRECT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CASHIN_HOSTED_REDIRECT).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("formMethod=");
		_buf.append(formMethod);
		_buf.append(',');
		_buf.append("formAction=");
		_buf.append(formAction);
		_buf.append(',');
		_buf.append("transId=");
		_buf.appendUint(transId);
		_buf.append(',');
		_buf.append("xTransStr=");
		_buf.append(xTransStr);
		_buf.append(',');
		_buf.append("cardTypeByte=");
		_buf.appendUint(cardTypeByte);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED_REDIRECT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(formMethod);
		_msg.composeString(formAction);
		_msg.composeUINT32(transId);
		_msg.composeString(xTransStr);
		_msg.composeBYTE(cardTypeByte);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED_REDIRECT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(formMethod);
		_parser.parseStringP(formAction);
		_parser.parseUINT32(transId);
		_parser.parseStringP(xTransStr);
		_parser.parseBYTE(cardTypeByte);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CASHIN_HOSTED_REDIRECT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CASHIN_HOSTED_REDIRECT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "formMethod"); size_t szFormMethod = strlen(_dummy);
		AtfValidator::validateInt(_descr, "formMethod", szFormMethod, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "formAction"); size_t szFormAction = strlen(_dummy);
		AtfValidator::validateInt(_descr, "formAction", szFormAction, _checker, __FILE__, __LINE__);
		UINT32 transId; _parser.parseUINT32(transId);
		AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "xTransStr"); size_t szXTransStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "xTransStr", szXTransStr, _checker, __FILE__, __LINE__);
		BYTE cardTypeByte; _parser.parseBYTE(cardTypeByte);
		AtfValidator::validateInt(_descr, "cardTypeByte", cardTypeByte, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_HOSTED_DONE
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_HOSTED_DONE::Protocol_MSG_CASHIER_HOSTED_DONE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_HOSTED_DONE::Protocol_MSG_CASHIER_HOSTED_DONE(Protocol_MSG_CASHIER_HOSTED_DONE&& _o)
	: userId(std::move(_o.userId))
	, transId(std::move(_o.transId))
	, xTransStr(std::move(_o.xTransStr))
	, isDone(std::move(_o.isDone))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_HOSTED_DONE& CashierServer::cli::Protocol_MSG_CASHIER_HOSTED_DONE::operator=(Protocol_MSG_CASHIER_HOSTED_DONE&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		transId = std::move(_o.transId);
		xTransStr = std::move(_o.xTransStr);
		isDone = std::move(_o.isDone);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_HOSTED_DONE::clear()
{
	userId.clear();
	transId = 0;
	xTransStr.clear();
	isDone = false;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_HOSTED_DONE::equals(const Protocol_MSG_CASHIER_HOSTED_DONE& _o) const
{
	return userId.equals(_o.userId) &&
		transId == _o.transId &&
		xTransStr.equals(_o.xTransStr) &&
		isDone == _o.isDone;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_HOSTED_DONE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_HOSTED_DONE).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("transId=");
	_buf.appendUint(transId);
	_buf.append(',');
	_buf.append("xTransStr=");
	_buf.append(xTransStr);
	_buf.append(',');
	_buf.append("isDone=");
	_buf.appendUint(isDone);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_HOSTED_DONE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeUINT32(transId);
	_msg.composeString(xTransStr);
	_msg.composeBOOL(isDone);
}

void CashierServer::cli::Protocol_MSG_CASHIER_HOSTED_DONE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseUINT32(transId);
	_parser.parseStringP(xTransStr);
	_parser.parseBOOL(isDone);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_HOSTED_DONE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_HOSTED_DONE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT32 transId; _parser.parseUINT32(transId);
	AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "xTransStr"); size_t szXTransStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "xTransStr", szXTransStr, 1000, _checker, __FILE__, __LINE__);
	bool isDone; _parser.parseBOOL(isDone);
	AtfValidator::validateInt(_descr, "isDone", isDone, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS::clear()
{
	paysystemRejectedByte = 0;
	rejectedTransId = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS::equals(const Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS& _o) const
{
	return paysystemRejectedByte == _o.paysystemRejectedByte &&
		rejectedTransId == _o.rejectedTransId;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SUGGEST_PAYSYSTEMS).append(")");
	_buf.append(',');
	_buf.append("paysystemRejectedByte=");
	_buf.appendUint(paysystemRejectedByte);
	_buf.append(',');
	_buf.append("rejectedTransId=");
	_buf.appendUint(rejectedTransId);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(paysystemRejectedByte);
	_msg.composeUINT32(rejectedTransId);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(paysystemRejectedByte);
	_parser.parseUINT32(rejectedTransId);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SUGGEST_PAYSYSTEMS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE paysystemRejectedByte; _parser.parseBYTE(paysystemRejectedByte);
	AtfValidator::validateIntRange(_descr, "paysystemRejectedByte", paysystemRejectedByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	UINT32 rejectedTransId; _parser.parseUINT32(rejectedTransId);
	AtfValidator::validateInt(_descr, "rejectedTransId", rejectedTransId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierSuggestedPaysystem
//=================================================================

CashierServer::cli::CashierSuggestedPaysystem::CashierSuggestedPaysystem()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::CashierSuggestedPaysystem::CashierSuggestedPaysystem(CashierSuggestedPaysystem&& _o)
	: cardTypeByte(std::move(_o.cardTypeByte))
	, usedDescription(std::move(_o.usedDescription))
{
}

CashierServer::cli::CashierSuggestedPaysystem& CashierServer::cli::CashierSuggestedPaysystem::operator=(CashierSuggestedPaysystem&& _o)
{
	if(this != &_o)
	{
		cardTypeByte = std::move(_o.cardTypeByte);
		usedDescription = std::move(_o.usedDescription);
	}
	return *this;
}

#endif

void CashierServer::cli::CashierSuggestedPaysystem::clear()
{
	cardTypeByte = 0;
	usedDescription.clear();
}

bool CashierServer::cli::CashierSuggestedPaysystem::equals(const CashierSuggestedPaysystem& _o) const
{
	return cardTypeByte == _o.cardTypeByte &&
		usedDescription.equals(_o.usedDescription);
}

const char *CashierServer::cli::CashierSuggestedPaysystem::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("cardTypeByte=");
	_buf.appendUint(cardTypeByte);
	_buf.append(',');
	_buf.append("usedDescription=");
	_buf.append(usedDescription);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashierSuggestedPaysystem::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CashierSuggestedPaysystem())) // not empty
	{
		_body.composeBYTE(cardTypeByte);
		_body.composeString(usedDescription);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierSuggestedPaysystem::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(cardTypeByte);
	_parser0.parseStringP(usedDescription);
}

/*static*/ void CashierServer::cli::CashierSuggestedPaysystem::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	BYTE cardTypeByte; _parser0.parseBYTE(cardTypeByte);
	AtfValidator::validateInt(_descr, "cardTypeByte", cardTypeByte, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "usedDescription"); size_t szUsedDescription = strlen(_dummy);
	AtfValidator::validateInt(_descr, "usedDescription", szUsedDescription, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY(Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, suggestions(std::move(_o.suggestions))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY::operator=(Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		suggestions = std::move(_o.suggestions);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	suggestions.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY::equals(const Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		suggestions.equals(_o.suggestions);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("suggestions=");
		suggestions.toTraceString(_buf);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		suggestions.composeMsg(_msg);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		suggestions.parseMsg(_parser);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szSuggestions = ThinAtf::LAtfVector< CashierSuggestedPaysystem, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("suggestions"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "suggestions", szSuggestions, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS::equals(const Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS& _o) const
{
	return true;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS).append(")");
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS::composeMsg(CommMsgBody& _msg) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierRecentDepositBody
//=================================================================

CashierServer::cli::CashierRecentDepositBody::CashierRecentDepositBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::CashierRecentDepositBody::CashierRecentDepositBody(CashierRecentDepositBody&& _o)
	: paysystemByte(std::move(_o.paysystemByte))
	, transId(std::move(_o.transId))
	, maskedCardNum(std::move(_o.maskedCardNum))
	, started(std::move(_o.started))
	, completed(std::move(_o.completed))
	, fxAmount(std::move(_o.fxAmount))
	, fxCurrency(std::move(_o.fxCurrency))
	, converted(std::move(_o.converted))
	, currency(std::move(_o.currency))
{
}

CashierServer::cli::CashierRecentDepositBody& CashierServer::cli::CashierRecentDepositBody::operator=(CashierRecentDepositBody&& _o)
{
	if(this != &_o)
	{
		paysystemByte = std::move(_o.paysystemByte);
		transId = std::move(_o.transId);
		maskedCardNum = std::move(_o.maskedCardNum);
		started = std::move(_o.started);
		completed = std::move(_o.completed);
		fxAmount = std::move(_o.fxAmount);
		fxCurrency = std::move(_o.fxCurrency);
		converted = std::move(_o.converted);
		currency = std::move(_o.currency);
	}
	return *this;
}

#endif

void CashierServer::cli::CashierRecentDepositBody::clear()
{
	paysystemByte = 0;
	transId = 0;
	maskedCardNum.clear();
	started.setNull();
	completed.setNull();
	fxAmount = 0;
	fxCurrency.clear();
	converted = 0;
	currency.clear();
}

bool CashierServer::cli::CashierRecentDepositBody::equals(const CashierRecentDepositBody& _o) const
{
	return paysystemByte == _o.paysystemByte &&
		transId == _o.transId &&
		maskedCardNum.equals(_o.maskedCardNum) &&
		started.equals(_o.started) &&
		completed.equals(_o.completed) &&
		fxAmount == _o.fxAmount &&
		fxCurrency.equals(_o.fxCurrency) &&
		converted == _o.converted &&
		currency.equals(_o.currency);
}

const char *CashierServer::cli::CashierRecentDepositBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("paysystemByte=");
	_buf.appendUint(paysystemByte);
	_buf.append(',');
	_buf.append("transId=");
	_buf.appendUint(transId);
	_buf.append(',');
	_buf.append("maskedCardNum=");
	_buf.append(maskedCardNum);
	_buf.append(',');
	_buf.append("started=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, started);
	_buf.append(',');
	_buf.append("completed=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, completed);
	_buf.append(',');
	_buf.append("fxAmount=");
	_buf.appendInt(fxAmount);
	_buf.append(',');
	_buf.append("fxCurrency=");
	_buf.append(fxCurrency);
	_buf.append(',');
	_buf.append("converted=");
	_buf.appendInt(converted);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashierRecentDepositBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CashierRecentDepositBody())) // not empty
	{
		_body.composeBYTE(paysystemByte);
		_body.composeUINT32(transId);
		_body.composeString(maskedCardNum);
		_body.composeSrvTime(started);
		_body.composeSrvTime(completed);
		_body.composeINT32(fxAmount);
		_body.composeString(fxCurrency);
		_body.composeINT32(converted);
		_body.composeString(currency);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierRecentDepositBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(paysystemByte);
	_parser0.parseUINT32(transId);
	_parser0.parseStringP(maskedCardNum);
	_parser0.parseSrvTime(started);
	_parser0.parseSrvTime(completed);
	_parser0.parseINT32(fxAmount);
	_parser0.parseStringP(fxCurrency);
	_parser0.parseINT32(converted);
	_parser0.parseStringP(currency);
}

/*static*/ void CashierServer::cli::CashierRecentDepositBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	BYTE paysystemByte; _parser0.parseBYTE(paysystemByte);
	AtfValidator::validateInt(_descr, "paysystemByte", paysystemByte, _checker, __FILE__, __LINE__);
	UINT32 transId; _parser0.parseUINT32(transId);
	AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "maskedCardNum"); size_t szMaskedCardNum = strlen(_dummy);
	AtfValidator::validateInt(_descr, "maskedCardNum", szMaskedCardNum, _checker, __FILE__, __LINE__);
	SrvTime started; _parser0.parseSrvTime(started);
	AtfValidator::validateSrvDateTime(_descr, "started", started, _checker, __FILE__, __LINE__);
	SrvTime completed; _parser0.parseSrvTime(completed);
	AtfValidator::validateSrvDateTime(_descr, "completed", completed, _checker, __FILE__, __LINE__);
	INT32 fxAmount; _parser0.parseINT32(fxAmount);
	AtfValidator::validateInt(_descr, "fxAmount", fxAmount, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "fxCurrency"); size_t szFxCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "fxCurrency", szFxCurrency, _checker, __FILE__, __LINE__);
	INT32 converted; _parser0.parseINT32(converted);
	AtfValidator::validateInt(_descr, "converted", converted, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY(Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, deposits(std::move(_o.deposits))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY::operator=(Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		deposits = std::move(_o.deposits);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	deposits.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY::equals(const Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		deposits.equals(_o.deposits);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("deposits=");
		deposits.toTraceString(_buf);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		deposits.composeMsg(_msg);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		deposits.parseMsg(_parser);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szDeposits = ThinAtf::LAtfVector< CashierRecentDepositBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("deposits"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "deposits", szDeposits, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS::equals(const Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS& _o) const
{
	return true;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_RESCUE_PAYSYSTEMS).append(")");
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS::composeMsg(CommMsgBody& _msg) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_RESCUE_PAYSYSTEMS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierRescuePaysystem
//=================================================================

CashierServer::cli::CashierRescuePaysystem::CashierRescuePaysystem()
{
	clear();
}

void CashierServer::cli::CashierRescuePaysystem::clear()
{
	paysystemByte = 0;
	flags = 0;
}

bool CashierServer::cli::CashierRescuePaysystem::equals(const CashierRescuePaysystem& _o) const
{
	return paysystemByte == _o.paysystemByte &&
		flags == _o.flags;
}

const char *CashierServer::cli::CashierRescuePaysystem::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("paysystemByte=");
	_buf.appendUint(paysystemByte);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashierRescuePaysystem::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CashierRescuePaysystem())) // not empty
	{
		_body.composeBYTE(paysystemByte);
		_body.composeUINT32(flags);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierRescuePaysystem::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(paysystemByte);
	_parser0.parseUINT32(flags);
}

/*static*/ void CashierServer::cli::CashierRescuePaysystem::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	BYTE paysystemByte; _parser0.parseBYTE(paysystemByte);
	AtfValidator::validateInt(_descr, "paysystemByte", paysystemByte, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser0.parseUINT32(flags);
	AtfValidator::validateIntMax(_descr, "flags", flags, ((((UINT32)eRescuePaysystemFlags_Last)<<1)-1), _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY(Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, paysystems(std::move(_o.paysystems))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY::operator=(Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		paysystems = std::move(_o.paysystems);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	paysystems.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY::equals(const Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		paysystems.equals(_o.paysystems);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("paysystems=");
		paysystems.toTraceString(_buf);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		paysystems.composeMsg(_msg);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		paysystems.parseMsg(_parser);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szPaysystems = ThinAtf::LAtfVector< CashierRescuePaysystem, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("paysystems"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "paysystems", szPaysystems, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_VERIFY_AGE
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE::Protocol_MSG_CASHIER_VERIFY_AGE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE::Protocol_MSG_CASHIER_VERIFY_AGE(Protocol_MSG_CASHIER_VERIFY_AGE&& _o)
	: clientReqId(std::move(_o.clientReqId))
	, userId(std::move(_o.userId))
	, fullName(std::move(_o.fullName))
	, gender(std::move(_o.gender))
	, dateOfBirth(std::move(_o.dateOfBirth))
	, phone(std::move(_o.phone))
	, address(std::move(_o.address))
	, city(std::move(_o.city))
	, zip(std::move(_o.zip))
	, county(std::move(_o.county))
	, state(std::move(_o.state))
	, country(std::move(_o.country))
	, SSN4(std::move(_o.SSN4))
	, idType(std::move(_o.idType))
	, id(std::move(_o.id))
	, contextAttemptNumber(std::move(_o.contextAttemptNumber))
	, requestPurpose(std::move(_o.requestPurpose))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE& CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE::operator=(Protocol_MSG_CASHIER_VERIFY_AGE&& _o)
{
	if(this != &_o)
	{
		clientReqId = std::move(_o.clientReqId);
		userId = std::move(_o.userId);
		fullName = std::move(_o.fullName);
		gender = std::move(_o.gender);
		dateOfBirth = std::move(_o.dateOfBirth);
		phone = std::move(_o.phone);
		address = std::move(_o.address);
		city = std::move(_o.city);
		zip = std::move(_o.zip);
		county = std::move(_o.county);
		state = std::move(_o.state);
		country = std::move(_o.country);
		SSN4 = std::move(_o.SSN4);
		idType = std::move(_o.idType);
		id = std::move(_o.id);
		contextAttemptNumber = std::move(_o.contextAttemptNumber);
		requestPurpose = std::move(_o.requestPurpose);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE::clear()
{
	clientReqId = 0;
	userId.clear();
	fullName.clear();
	gender.clear();
	dateOfBirth.setNull();
	phone.clear();
	address.clear();
	city.clear();
	zip.clear();
	county.clear();
	state.clear();
	country.clear();
	SSN4.clear();
	idType = 0;
	id.clear();
	contextAttemptNumber = 0;
	requestPurpose = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE::equals(const Protocol_MSG_CASHIER_VERIFY_AGE& _o) const
{
	return clientReqId == _o.clientReqId &&
		userId.equals(_o.userId) &&
		fullName.equals(_o.fullName) &&
		gender.equals(_o.gender) &&
		dateOfBirth.equals(_o.dateOfBirth) &&
		phone.equals(_o.phone) &&
		address.equals(_o.address) &&
		city.equals(_o.city) &&
		zip.equals(_o.zip) &&
		county.equals(_o.county) &&
		state.equals(_o.state) &&
		country.equals(_o.country) &&
		SSN4.equals(_o.SSN4) &&
		idType == _o.idType &&
		id.equals(_o.id) &&
		contextAttemptNumber == _o.contextAttemptNumber &&
		requestPurpose == _o.requestPurpose;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_VERIFY_AGE).append(")");
	_buf.append(',');
	_buf.append("clientReqId=");
	_buf.appendUint(clientReqId);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("fullName=");
	_buf.append(fullName);
	_buf.append(',');
	_buf.append("gender=");
	_buf.append(gender);
	_buf.append(',');
	_buf.append("dateOfBirth=");
	ThinAtf::AtfTempl<CommSrvDate>::ToTraceString(_buf, dateOfBirth);
	_buf.append(',');
	_buf.append("phone=");
	_buf.append(phone);
	_buf.append(',');
	_buf.append("address=");
	_buf.append(address);
	_buf.append(',');
	_buf.append("city=");
	_buf.append(city);
	_buf.append(',');
	_buf.append("zip=");
	_buf.append(zip);
	_buf.append(',');
	_buf.append("county=");
	_buf.append(county);
	_buf.append(',');
	_buf.append("state=");
	_buf.append(state);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("SSN4=");
	_buf.append(SSN4);
	_buf.append(',');
	_buf.append("idType=");
	_buf.appendUint(idType);
	_buf.append(',');
	_buf.append("id=");
	_buf.append(id);
	_buf.append(',');
	_buf.append("contextAttemptNumber=");
	_buf.appendUint(contextAttemptNumber);
	_buf.append(',');
	_buf.append("requestPurpose=");
	_buf.appendUint(requestPurpose);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(clientReqId);
	_msg.composeString(userId);
	_msg.composeString(fullName);
	_msg.composeString(gender);
	_msg.composeSrvDate(dateOfBirth);
	_msg.composeString(phone);
	_msg.composeString(address);
	_msg.composeString(city);
	_msg.composeString(zip);
	_msg.composeString(county);
	_msg.composeString(state);
	_msg.composeString(country);
	_msg.composeString(SSN4);
	_msg.composeUINT32(idType);
	_msg.composeString(id);
	_msg.composeUINT32(contextAttemptNumber);
	_msg.composeUINT32(requestPurpose);
}

void CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clientReqId);
	_parser.parseStringP(userId);
	_parser.parseStringP(fullName);
	_parser.parseStringP(gender);
	_parser.parseSrvDate(dateOfBirth);
	_parser.parseStringP(phone);
	_parser.parseStringP(address);
	_parser.parseStringP(city);
	_parser.parseStringP(zip);
	_parser.parseStringP(county);
	_parser.parseStringP(state);
	_parser.parseStringP(country);
	_parser.parseStringP(SSN4);
	_parser.parseUINT32(idType);
	_parser.parseStringP(id);
	_parser.parseUINT32(contextAttemptNumber);
	_parser.parseUINT32(requestPurpose);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_VERIFY_AGE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 clientReqId; _parser.parseUINT32(clientReqId);
	AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "fullName"); size_t szFullName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "fullName", szFullName, USER_FULLNAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "gender"); size_t szGender = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "gender", szGender, GENDER_LEN, _checker, __FILE__, __LINE__);
	CommSrvDate dateOfBirth; _parser.parseSrvDate(dateOfBirth);
	AtfValidator::validateSrvDateTime(_descr, "dateOfBirth", dateOfBirth, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "phone"); size_t szPhone = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "phone", szPhone, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "address"); size_t szAddress = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "address", szAddress, USER_ADDR_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "city", szCity, USER_CITY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "zip"); size_t szZip = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "zip", szZip, USER_ZIP_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "county"); size_t szCounty = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "county", szCounty, COUNTY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "state"); size_t szState = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "state", szState, USER_STATE_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, USER_COUNTRY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "SSN4"); size_t szSSN4 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "SSN4", szSSN4, SSN_4_LEN, _checker, __FILE__, __LINE__);
	UINT32 idType; _parser.parseUINT32(idType);
	AtfValidator::validateIntRange(_descr, "idType", idType, eAgeVerificationPersonalIdTypeNone, eAgeVerificationPersonalIdTypeTravelDocument, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "id"); size_t szId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "id", szId, 100, _checker, __FILE__, __LINE__);
	UINT32 contextAttemptNumber; _parser.parseUINT32(contextAttemptNumber);
	AtfValidator::validateIntMax(_descr, "contextAttemptNumber", contextAttemptNumber, 1000, _checker, __FILE__, __LINE__);
	UINT32 requestPurpose; _parser.parseUINT32(requestPurpose);
	{ const UINT32 requestPurpose_enum[] = { eAristotleRequestForAgeVerification, eAristotleRequestForAuthentication, eAristotleRequestForScreening }; AtfValidator::validateEnum(_descr, "requestPurpose", requestPurpose, requestPurpose_enum, _checker, __FILE__, __LINE__); }
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_VERIFY_AGE_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE_REPLY::Protocol_MSG_CASHIER_VERIFY_AGE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE_REPLY::Protocol_MSG_CASHIER_VERIFY_AGE_REPLY(Protocol_MSG_CASHIER_VERIFY_AGE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, resultId(std::move(_o.resultId))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE_REPLY::operator=(Protocol_MSG_CASHIER_VERIFY_AGE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		resultId = std::move(_o.resultId);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	resultId = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE_REPLY::equals(const Protocol_MSG_CASHIER_VERIFY_AGE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		resultId == _o.resultId;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_VERIFY_AGE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errDescr=");
	_buf.append(errDescr);
	_buf.append(',');
	_buf.append("resultId=");
	_buf.appendUint(resultId);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errDescr);
	_msg.composeUINT32(resultId);
}

void CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(errDescr);
	_parser.parseUINT32(resultId);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_VERIFY_AGE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_VERIFY_AGE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	UINT32 resultId; _parser.parseUINT32(resultId);
	AtfValidator::validateInt(_descr, "resultId", resultId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL(Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL&& _o)
	: currency(std::move(_o.currency))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL& CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL::operator=(Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL&& _o)
{
	if(this != &_o)
	{
		currency = std::move(_o.currency);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL::clear()
{
	currency.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL::equals(const Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL& _o) const
{
	return currency.equals(_o.currency);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PAYSYSTEMS_AVAIL).append(")");
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(currency);
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(currency);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PAYSYSTEMS_AVAIL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    PaysystemLimitBody
//=================================================================

CashierServer::cli::PaysystemLimitBody::PaysystemLimitBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::PaysystemLimitBody::PaysystemLimitBody(PaysystemLimitBody&& _o)
	: limit(std::move(_o.limit))
{
}

CashierServer::cli::PaysystemLimitBody& CashierServer::cli::PaysystemLimitBody::operator=(PaysystemLimitBody&& _o)
{
	if(this != &_o)
	{
		limit = std::move(_o.limit);
	}
	return *this;
}

#endif

void CashierServer::cli::PaysystemLimitBody::clear()
{
	limit.clear();
}

bool CashierServer::cli::PaysystemLimitBody::equals(const PaysystemLimitBody& _o) const
{
	return limit.equals(_o.limit);
}

const char *CashierServer::cli::PaysystemLimitBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("limit=");
	limit.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::PaysystemLimitBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(PaysystemLimitBody())) // not empty
	{
		limit.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::PaysystemLimitBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	limit.parseMsg(_parser0);
}

/*static*/ void CashierServer::cli::PaysystemLimitBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	common_structs::PaysystemLimit::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("limit"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY(Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, limits(std::move(_o.limits))
	, dadPreDepositAvailable(std::move(_o.dadPreDepositAvailable))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY::operator=(Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		limits = std::move(_o.limits);
		dadPreDepositAvailable = std::move(_o.dadPreDepositAvailable);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	limits.clear();
	dadPreDepositAvailable = false;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY::equals(const Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		limits.equals(_o.limits) &&
		dadPreDepositAvailable == _o.dadPreDepositAvailable;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("limits=");
		limits.toTraceString(_buf);
		_buf.append(',');
		_buf.append("dadPreDepositAvailable=");
		_buf.appendUint(dadPreDepositAvailable);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		limits.composeMsg(_msg);
		_msg.composeBOOL(dadPreDepositAvailable);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		limits.parseMsg(_parser);
		_parser.parseBOOL(dadPreDepositAvailable);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szLimits = ThinAtf::LAtfVector< PaysystemLimitBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("limits"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "limits", szLimits, _checker, __FILE__, __LINE__);
		bool dadPreDepositAvailable; _parser.parseBOOL(dadPreDepositAvailable);
		AtfValidator::validateInt(_descr, "dadPreDepositAvailable", dadPreDepositAvailable, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM::equals(const Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM& _o) const
{
	return true;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PAYSYSTEMS_AVAIL_PM).append(")");
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM::composeMsg(CommMsgBody& _msg) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PAYSYSTEMS_AVAIL_PM";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierPaySystemLimitExBody
//=================================================================

CashierServer::cli::CashierPaySystemLimitExBody::CashierPaySystemLimitExBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::CashierPaySystemLimitExBody::CashierPaySystemLimitExBody(CashierPaySystemLimitExBody&& _o)
	: paySystemByte(std::move(_o.paySystemByte))
	, cashinLimit(std::move(_o.cashinLimit))
	, fastDepositIsOk(std::move(_o.fastDepositIsOk))
	, psAvailFlagToClient(std::move(_o.psAvailFlagToClient))
{
}

CashierServer::cli::CashierPaySystemLimitExBody& CashierServer::cli::CashierPaySystemLimitExBody::operator=(CashierPaySystemLimitExBody&& _o)
{
	if(this != &_o)
	{
		paySystemByte = std::move(_o.paySystemByte);
		cashinLimit = std::move(_o.cashinLimit);
		fastDepositIsOk = std::move(_o.fastDepositIsOk);
		psAvailFlagToClient = std::move(_o.psAvailFlagToClient);
	}
	return *this;
}

#endif

void CashierServer::cli::CashierPaySystemLimitExBody::clear()
{
	paySystemByte = 0;
	cashinLimit.clear();
	fastDepositIsOk = false;
	psAvailFlagToClient = 0;
}

bool CashierServer::cli::CashierPaySystemLimitExBody::equals(const CashierPaySystemLimitExBody& _o) const
{
	return paySystemByte == _o.paySystemByte &&
		cashinLimit.equals(_o.cashinLimit) &&
		fastDepositIsOk == _o.fastDepositIsOk &&
		psAvailFlagToClient == _o.psAvailFlagToClient;
}

const char *CashierServer::cli::CashierPaySystemLimitExBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("paySystemByte=");
	_buf.appendUint(paySystemByte);
	_buf.append(',');
	_buf.append("cashinLimit=");
	cashinLimit.toTraceString(_buf);
	_buf.append(',');
	_buf.append("fastDepositIsOk=");
	_buf.appendUint(fastDepositIsOk);
	_buf.append(',');
	_buf.append("psAvailFlagToClient=");
	_buf.appendUint(psAvailFlagToClient);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashierPaySystemLimitExBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CashierPaySystemLimitExBody())) // not empty
	{
		_body.composeBYTE(paySystemByte);
		cashinLimit.composeMsg(_body);
		_body.composeBOOL(fastDepositIsOk);
		_body.composeUINT32(psAvailFlagToClient);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierPaySystemLimitExBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(paySystemByte);
	cashinLimit.parseMsg(_parser0);
	_parser0.parseBOOL(fastDepositIsOk);
	_parser0.parseUINT32(psAvailFlagToClient);
}

/*static*/ void CashierServer::cli::CashierPaySystemLimitExBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	BYTE paySystemByte; _parser0.parseBYTE(paySystemByte);
	AtfValidator::validateInt(_descr, "paySystemByte", paySystemByte, _checker, __FILE__, __LINE__);
	PString _descbuf;
	PaysystemLimitBody::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("cashinLimit"), _fieldsWithUnparsedContent);
	bool fastDepositIsOk; _parser0.parseBOOL(fastDepositIsOk);
	AtfValidator::validateInt(_descr, "fastDepositIsOk", fastDepositIsOk, _checker, __FILE__, __LINE__);
	UINT32 psAvailFlagToClient; _parser0.parseUINT32(psAvailFlagToClient);
	AtfValidator::validateInt(_descr, "psAvailFlagToClient", psAvailFlagToClient, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY(Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, limits(std::move(_o.limits))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY::operator=(Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		limits = std::move(_o.limits);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	limits.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY::equals(const Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		limits.equals(_o.limits);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("limits=");
		limits.toTraceString(_buf);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		limits.composeMsg(_msg);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		limits.parseMsg(_parser);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szLimits = ThinAtf::LAtfVector< CashierPaySystemLimitExBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("limits"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "limits", szLimits, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO(Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO&& _o)
	: currency(std::move(_o.currency))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO& CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO::operator=(Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO&& _o)
{
	if(this != &_o)
	{
		currency = std::move(_o.currency);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO::clear()
{
	currency.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO::equals(const Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO& _o) const
{
	return currency.equals(_o.currency);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO).append(")");
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(currency);
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(currency);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY(Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY&& _o)
	: pssNum(std::move(_o.pssNum))
	, header(std::move(_o.header))
	, body(std::move(_o.body))
	, footer(std::move(_o.footer))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY::operator=(Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY&& _o)
{
	if(this != &_o)
	{
		pssNum = std::move(_o.pssNum);
		header = std::move(_o.header);
		body = std::move(_o.body);
		footer = std::move(_o.footer);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY::clear()
{
	pssNum = 0;
	header.clear();
	body.clear();
	footer.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY::equals(const Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY& _o) const
{
	return pssNum == _o.pssNum &&
		header.equals(_o.header) &&
		body.equals(_o.body) &&
		footer.equals(_o.footer);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY).append(")");
	_buf.append(',');
	_buf.append("pssNum=");
	_buf.appendUint(pssNum);
	_buf.append(',');
	_buf.append("header=");
	_buf.append(header);
	_buf.append(',');
	_buf.append("body=");
	_buf.append(body);
	_buf.append(',');
	_buf.append("footer=");
	_buf.append(footer);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(pssNum);
	_msg.composeString(header);
	_msg.composeString(body);
	_msg.composeString(footer);
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(pssNum);
	_parser.parseStringP(header);
	_parser.parseStringP(body);
	_parser.parseStringP(footer);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE pssNum; _parser.parseBYTE(pssNum);
	AtfValidator::validateInt(_descr, "pssNum", pssNum, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "header"); size_t szHeader = strlen(_dummy);
	AtfValidator::validateInt(_descr, "header", szHeader, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "body"); size_t szBody = strlen(_dummy);
	AtfValidator::validateInt(_descr, "body", szBody, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "footer"); size_t szFooter = strlen(_dummy);
	AtfValidator::validateInt(_descr, "footer", szFooter, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    WireHolderBody
//=================================================================

CashierServer::cli::WireHolderBody::WireHolderBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::WireHolderBody::WireHolderBody(WireHolderBody&& _o)
	: fullName(std::move(_o.fullName))
	, phone(std::move(_o.phone))
	, address(std::move(_o.address))
	, city(std::move(_o.city))
	, state(std::move(_o.state))
	, zip(std::move(_o.zip))
	, countryCode(std::move(_o.countryCode))
{
}

CashierServer::cli::WireHolderBody& CashierServer::cli::WireHolderBody::operator=(WireHolderBody&& _o)
{
	if(this != &_o)
	{
		fullName = std::move(_o.fullName);
		phone = std::move(_o.phone);
		address = std::move(_o.address);
		city = std::move(_o.city);
		state = std::move(_o.state);
		zip = std::move(_o.zip);
		countryCode = std::move(_o.countryCode);
	}
	return *this;
}

#endif

void CashierServer::cli::WireHolderBody::clear()
{
	fullName.clear();
	phone.clear();
	address.clear();
	city.clear();
	state.clear();
	zip.clear();
	countryCode.clear();
}

bool CashierServer::cli::WireHolderBody::equals(const WireHolderBody& _o) const
{
	return fullName.equals(_o.fullName) &&
		phone.equals(_o.phone) &&
		address.equals(_o.address) &&
		city.equals(_o.city) &&
		state.equals(_o.state) &&
		zip.equals(_o.zip) &&
		countryCode.equals(_o.countryCode);
}

const char *CashierServer::cli::WireHolderBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("fullName=");
	_buf.append(fullName);
	_buf.append(',');
	_buf.append("phone=");
	_buf.append(phone);
	_buf.append(',');
	_buf.append("address=");
	_buf.append(address);
	_buf.append(',');
	_buf.append("city=");
	_buf.append(city);
	_buf.append(',');
	_buf.append("state=");
	_buf.append(state);
	_buf.append(',');
	_buf.append("zip=");
	_buf.append(zip);
	_buf.append(',');
	_buf.append("countryCode=");
	_buf.append(countryCode);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::WireHolderBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(WireHolderBody())) // not empty
	{
		_body.composeString(fullName);
		_body.composeString(phone);
		_body.composeString(address);
		_body.composeString(city);
		_body.composeString(state);
		_body.composeString(zip);
		_body.composeString(countryCode);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::WireHolderBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(fullName);
	_parser0.parseStringP(phone);
	_parser0.parseStringP(address);
	_parser0.parseStringP(city);
	_parser0.parseStringP(state);
	_parser0.parseStringP(zip);
	_parser0.parseStringP(countryCode);
}

/*static*/ void CashierServer::cli::WireHolderBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "fullName"); size_t szFullName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "fullName", szFullName, WIREACCOUNTS_HOLDERNAME_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "phone"); size_t szPhone = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "phone", szPhone, WIREACCOUNTS_PHONE_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "address"); size_t szAddress = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "address", szAddress, WIREACCOUNTS_ADDR_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "city", szCity, WIREACCOUNTS_CITY_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "state"); size_t szState = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "state", szState, WIREACCOUNTS_STATE_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "zip"); size_t szZip = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "zip", szZip, WIREACCOUNTS_ZIPCODE_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "countryCode"); size_t szCountryCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "countryCode", szCountryCode, WIREACCOUNTS_COUNTRY_LEN, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    WireBankInfoBody
//=================================================================

CashierServer::cli::WireBankInfoBody::WireBankInfoBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::WireBankInfoBody::WireBankInfoBody(WireBankInfoBody&& _o)
	: userAccount(std::move(_o.userAccount))
	, currencyCode(std::move(_o.currencyCode))
	, iban(std::move(_o.iban))
	, swiftCode(std::move(_o.swiftCode))
	, bankName(std::move(_o.bankName))
	, bankAddr(std::move(_o.bankAddr))
	, comments(std::move(_o.comments))
{
}

CashierServer::cli::WireBankInfoBody& CashierServer::cli::WireBankInfoBody::operator=(WireBankInfoBody&& _o)
{
	if(this != &_o)
	{
		userAccount = std::move(_o.userAccount);
		currencyCode = std::move(_o.currencyCode);
		iban = std::move(_o.iban);
		swiftCode = std::move(_o.swiftCode);
		bankName = std::move(_o.bankName);
		bankAddr = std::move(_o.bankAddr);
		comments = std::move(_o.comments);
	}
	return *this;
}

#endif

void CashierServer::cli::WireBankInfoBody::clear()
{
	userAccount.clear();
	currencyCode.clear();
	iban.clear();
	swiftCode.clear();
	bankName.clear();
	bankAddr.clear();
	comments.clear();
}

bool CashierServer::cli::WireBankInfoBody::equals(const WireBankInfoBody& _o) const
{
	return userAccount.equals(_o.userAccount) &&
		currencyCode.equals(_o.currencyCode) &&
		iban.equals(_o.iban) &&
		swiftCode.equals(_o.swiftCode) &&
		bankName.equals(_o.bankName) &&
		bankAddr.equals(_o.bankAddr) &&
		comments.equals(_o.comments);
}

const char *CashierServer::cli::WireBankInfoBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userAccount=");
	_buf.append(userAccount);
	_buf.append(',');
	_buf.append("currencyCode=");
	_buf.append(currencyCode);
	_buf.append(',');
	_buf.append("iban=");
	_buf.append(iban);
	_buf.append(',');
	_buf.append("swiftCode=");
	_buf.append(swiftCode);
	_buf.append(',');
	_buf.append("bankName=");
	_buf.append(bankName);
	_buf.append(',');
	_buf.append("bankAddr=");
	_buf.append(bankAddr);
	_buf.append(',');
	_buf.append("comments=");
	_buf.append(comments);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::WireBankInfoBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(WireBankInfoBody())) // not empty
	{
		_body.composeString(userAccount);
		_body.composeString(currencyCode);
		_body.composeString(iban);
		_body.composeString(swiftCode);
		_body.composeString(bankName);
		_body.composeString(bankAddr);
		_body.composeString(comments);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::WireBankInfoBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(userAccount);
	_parser0.parseStringP(currencyCode);
	_parser0.parseStringP(iban);
	_parser0.parseStringP(swiftCode);
	_parser0.parseStringP(bankName);
	_parser0.parseStringP(bankAddr);
	_parser0.parseStringP(comments);
}

/*static*/ void CashierServer::cli::WireBankInfoBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "userAccount"); size_t szUserAccount = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userAccount", szUserAccount, 100, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currencyCode"); size_t szCurrencyCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currencyCode", szCurrencyCode, WIREACCOUNTS_CURRENCY_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "iban"); size_t szIban = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "iban", szIban, WIREACCOUNTS_IBAN_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "swiftCode"); size_t szSwiftCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "swiftCode", szSwiftCode, WIREACCOUNTS_SWIFTCODE_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "bankName"); size_t szBankName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bankName", szBankName, WIREACCOUNTS_BANKNAME_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "bankAddr"); size_t szBankAddr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bankAddr", szBankAddr, WIREACCOUNTS_BANKADDR_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "comments"); size_t szComments = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "comments", szComments, 10000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO(Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO&& _o)
	: holder(std::move(_o.holder))
	, bankinfo(std::move(_o.bankinfo))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO& CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO::operator=(Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO&& _o)
{
	if(this != &_o)
	{
		holder = std::move(_o.holder);
		bankinfo = std::move(_o.bankinfo);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO::clear()
{
	holder.clear();
	bankinfo.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO::equals(const Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO& _o) const
{
	return holder.equals(_o.holder) &&
		bankinfo.equals(_o.bankinfo);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO).append(")");
	_buf.append(',');
	_buf.append("holder=");
	holder.toTraceString(_buf);
	_buf.append(',');
	_buf.append("bankinfo=");
	bankinfo.toTraceString(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO::composeMsg(CommMsgBody& _msg) const
{
	holder.composeMsg(_msg);
	bankinfo.composeMsg(_msg);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO::parseMsg(CommMsgParser& _parser)
{
	holder.parseMsg(_parser);
	bankinfo.parseMsg(_parser);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	WireHolderBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("holder"), _fieldsWithUnparsedContent);
	WireBankInfoBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("bankinfo"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY(Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errReplyInfo(std::move(_o.errReplyInfo))
	, eDbtWireBankValNoError(std::move(_o.eDbtWireBankValNoError))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY::operator=(Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errReplyInfo = std::move(_o.errReplyInfo);
		eDbtWireBankValNoError = std::move(_o.eDbtWireBankValNoError);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY::clear()
{
	errCode = 0;
	errReplyInfo.clear();
	eDbtWireBankValNoError = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY::equals(const Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errReplyInfo.equals(_o.errReplyInfo) &&
		eDbtWireBankValNoError == _o.eDbtWireBankValNoError;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errReplyInfo=");
	_buf.append(errReplyInfo);
	_buf.append(',');
	_buf.append("eDbtWireBankValNoError=");
	_buf.appendInt(eDbtWireBankValNoError);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errReplyInfo);
	_msg.composeINT16(eDbtWireBankValNoError);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(errReplyInfo);
	_parser.parseINT16(eDbtWireBankValNoError);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errReplyInfo"); size_t szErrReplyInfo = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errReplyInfo", szErrReplyInfo, _checker, __FILE__, __LINE__);
	INT16 eDbtWireBankValNoError; _parser.parseINT16(eDbtWireBankValNoError);
	AtfValidator::validateInt(_descr, "eDbtWireBankValNoError", eDbtWireBankValNoError, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_USER_LIMIT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT::Protocol_MSG_CASHIER_GET_USER_LIMIT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT::Protocol_MSG_CASHIER_GET_USER_LIMIT(Protocol_MSG_CASHIER_GET_USER_LIMIT&& _o)
	: userId(std::move(_o.userId))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT& CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT::operator=(Protocol_MSG_CASHIER_GET_USER_LIMIT&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT::clear()
{
	userId.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT::equals(const Protocol_MSG_CASHIER_GET_USER_LIMIT& _o) const
{
	return userId.equals(_o.userId);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_USER_LIMIT).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseStringP(userId);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_USER_LIMIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_USER_LIMIT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_REPLY::Protocol_MSG_CASHIER_GET_USER_LIMIT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_REPLY::Protocol_MSG_CASHIER_GET_USER_LIMIT_REPLY(Protocol_MSG_CASHIER_GET_USER_LIMIT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, weeklyLimit(std::move(_o.weeklyLimit))
	, enforcedUntil(std::move(_o.enforcedUntil))
	, maxUserLimit(std::move(_o.maxUserLimit))
	, minUserLimitInCur(std::move(_o.minUserLimitInCur))
	, selfLimitCurrency(std::move(_o.selfLimitCurrency))
	, rateToUsd_x100M(std::move(_o.rateToUsd_x100M))
	, regulatoryWeeklyLimit(std::move(_o.regulatoryWeeklyLimit))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_REPLY::operator=(Protocol_MSG_CASHIER_GET_USER_LIMIT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		weeklyLimit = std::move(_o.weeklyLimit);
		enforcedUntil = std::move(_o.enforcedUntil);
		maxUserLimit = std::move(_o.maxUserLimit);
		minUserLimitInCur = std::move(_o.minUserLimitInCur);
		selfLimitCurrency = std::move(_o.selfLimitCurrency);
		rateToUsd_x100M = std::move(_o.rateToUsd_x100M);
		regulatoryWeeklyLimit = std::move(_o.regulatoryWeeklyLimit);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	weeklyLimit = 0;
	enforcedUntil.setNull();
	maxUserLimit = 0;
	minUserLimitInCur = 0;
	selfLimitCurrency.clear();
	rateToUsd_x100M = 0;
	regulatoryWeeklyLimit = -1;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_REPLY::equals(const Protocol_MSG_CASHIER_GET_USER_LIMIT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		weeklyLimit == _o.weeklyLimit &&
		enforcedUntil.equals(_o.enforcedUntil) &&
		maxUserLimit == _o.maxUserLimit &&
		minUserLimitInCur == _o.minUserLimitInCur &&
		selfLimitCurrency.equals(_o.selfLimitCurrency) &&
		rateToUsd_x100M == _o.rateToUsd_x100M &&
		regulatoryWeeklyLimit == _o.regulatoryWeeklyLimit;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_USER_LIMIT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("weeklyLimit=");
		_buf.appendInt(weeklyLimit);
		_buf.append(',');
		_buf.append("enforcedUntil=");
		ThinAtf::AtfTempl<CommSrvTime>::ToTraceString(_buf, enforcedUntil);
		_buf.append(',');
		_buf.append("maxUserLimit=");
		_buf.appendInt(maxUserLimit);
		_buf.append(',');
		_buf.append("minUserLimitInCur=");
		_buf.appendInt(minUserLimitInCur);
		_buf.append(',');
		_buf.append("selfLimitCurrency=");
		_buf.append(selfLimitCurrency);
		_buf.append(',');
		_buf.append("rateToUsd_x100M=");
		_buf.appendInt64(rateToUsd_x100M);
		_buf.append(',');
		_buf.append("regulatoryWeeklyLimit=");
		_buf.appendInt(regulatoryWeeklyLimit);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(weeklyLimit);
		_msg.composeSrvTime(enforcedUntil);
		_msg.composeINT32(maxUserLimit);
		_msg.composeINT32(minUserLimitInCur);
		_msg.composeString(selfLimitCurrency);
		_msg.composeINT64(rateToUsd_x100M);
		_msg.composeINT32(regulatoryWeeklyLimit);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(weeklyLimit);
		_parser.parseSrvTime(enforcedUntil);
		_parser.parseINT32(maxUserLimit);
		_parser.parseINT32(minUserLimitInCur);
		_parser.parseStringP(selfLimitCurrency);
		_parser.parseINT64(rateToUsd_x100M);
		if(_parser.parseEnded()) return;
		_parser.parseINT32(regulatoryWeeklyLimit);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_USER_LIMIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 weeklyLimit; _parser.parseINT32(weeklyLimit);
		AtfValidator::validateInt(_descr, "weeklyLimit", weeklyLimit, _checker, __FILE__, __LINE__);
		CommSrvTime enforcedUntil; _parser.parseSrvTime(enforcedUntil);
		AtfValidator::validateSrvDateTime(_descr, "enforcedUntil", enforcedUntil, _checker, __FILE__, __LINE__);
		INT32 maxUserLimit; _parser.parseINT32(maxUserLimit);
		AtfValidator::validateInt(_descr, "maxUserLimit", maxUserLimit, _checker, __FILE__, __LINE__);
		INT32 minUserLimitInCur; _parser.parseINT32(minUserLimitInCur);
		AtfValidator::validateInt(_descr, "minUserLimitInCur", minUserLimitInCur, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "selfLimitCurrency"); size_t szSelfLimitCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "selfLimitCurrency", szSelfLimitCurrency, _checker, __FILE__, __LINE__);
		INT64 rateToUsd_x100M; _parser.parseINT64(rateToUsd_x100M);
		AtfValidator::validateInt(_descr, "rateToUsd_x100M", rateToUsd_x100M, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		INT32 regulatoryWeeklyLimit; _parser.parseINT32(regulatoryWeeklyLimit);
		AtfValidator::validateInt(_descr, "regulatoryWeeklyLimit", regulatoryWeeklyLimit, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_USER_LIMIT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT::Protocol_MSG_CASHIER_SET_USER_LIMIT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT::Protocol_MSG_CASHIER_SET_USER_LIMIT(Protocol_MSG_CASHIER_SET_USER_LIMIT&& _o)
	: userId(std::move(_o.userId))
	, weeklyLimit(std::move(_o.weeklyLimit))
	, flags_ignored(std::move(_o.flags_ignored))
	, flags2_ignored(std::move(_o.flags2_ignored))
	, groupDepositLimit(std::move(_o.groupDepositLimit))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT& CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT::operator=(Protocol_MSG_CASHIER_SET_USER_LIMIT&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		weeklyLimit = std::move(_o.weeklyLimit);
		flags_ignored = std::move(_o.flags_ignored);
		flags2_ignored = std::move(_o.flags2_ignored);
		groupDepositLimit = std::move(_o.groupDepositLimit);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT::clear()
{
	userId.clear();
	weeklyLimit = 0;
	flags_ignored = 0;
	flags2_ignored = 0;
	groupDepositLimit = false;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT::equals(const Protocol_MSG_CASHIER_SET_USER_LIMIT& _o) const
{
	return userId.equals(_o.userId) &&
		weeklyLimit == _o.weeklyLimit &&
		flags_ignored == _o.flags_ignored &&
		flags2_ignored == _o.flags2_ignored &&
		groupDepositLimit == _o.groupDepositLimit;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_USER_LIMIT).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("weeklyLimit=");
	_buf.appendInt(weeklyLimit);
	_buf.append(',');
	_buf.append("flags_ignored=");
	_buf.appendUint(flags_ignored);
	_buf.append(',');
	_buf.append("flags2_ignored=");
	_buf.appendUint64(flags2_ignored);
	_buf.append(',');
	_buf.append("groupDepositLimit=");
	_buf.appendUint(groupDepositLimit);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeINT32(weeklyLimit);
	_msg.composeUINT32(flags_ignored);
	_msg.composeUINT64(flags2_ignored);
	_msg.composeBOOL(groupDepositLimit);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseINT32(weeklyLimit);
	_parser.parseUINT32(flags_ignored);
	_parser.parseUINT64(flags2_ignored);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(groupDepositLimit);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_USER_LIMIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	INT32 weeklyLimit; _parser.parseINT32(weeklyLimit);
	AtfValidator::validateIntRange(_descr, "weeklyLimit", weeklyLimit, -1, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	UINT32 flags_ignored; _parser.parseUINT32(flags_ignored);
	AtfValidator::validateInt(_descr, "flags_ignored", flags_ignored, _checker, __FILE__, __LINE__);
	UINT64 flags2_ignored; _parser.parseUINT64(flags2_ignored);
	AtfValidator::validateUint(_descr, "flags2_ignored", flags2_ignored, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool groupDepositLimit; _parser.parseBOOL(groupDepositLimit);
	AtfValidator::validateInt(_descr, "groupDepositLimit", groupDepositLimit, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_USER_LIMIT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_REPLY::Protocol_MSG_CASHIER_SET_USER_LIMIT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_REPLY::Protocol_MSG_CASHIER_SET_USER_LIMIT_REPLY(Protocol_MSG_CASHIER_SET_USER_LIMIT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, status(std::move(_o.status))
	, weeklyLimit(std::move(_o.weeklyLimit))
	, enforcedUntil(std::move(_o.enforcedUntil))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_REPLY::operator=(Protocol_MSG_CASHIER_SET_USER_LIMIT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		status = std::move(_o.status);
		weeklyLimit = std::move(_o.weeklyLimit);
		enforcedUntil = std::move(_o.enforcedUntil);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	status = 0;
	weeklyLimit = 0;
	enforcedUntil.setNull();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_REPLY::equals(const Protocol_MSG_CASHIER_SET_USER_LIMIT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		status == _o.status &&
		weeklyLimit == _o.weeklyLimit &&
		enforcedUntil.equals(_o.enforcedUntil);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_USER_LIMIT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("status=");
		_buf.appendUint(status);
		_buf.append(',');
		_buf.append("weeklyLimit=");
		_buf.appendInt(weeklyLimit);
		_buf.append(',');
		_buf.append("enforcedUntil=");
		ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, enforcedUntil);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeBYTE(status);
		_msg.composeINT32(weeklyLimit);
		_msg.composeSrvTime(enforcedUntil);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseBYTE(status);
		_parser.parseINT32(weeklyLimit);
		_parser.parseSrvTime(enforcedUntil);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_USER_LIMIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		BYTE status; _parser.parseBYTE(status);
		AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
		INT32 weeklyLimit; _parser.parseINT32(weeklyLimit);
		AtfValidator::validateInt(_descr, "weeklyLimit", weeklyLimit, _checker, __FILE__, __LINE__);
		SrvTime enforcedUntil; _parser.parseSrvTime(enforcedUntil);
		AtfValidator::validateSrvDateTime(_descr, "enforcedUntil", enforcedUntil, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_USER_LIMIT_EX
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX(Protocol_MSG_CASHIER_GET_USER_LIMIT_EX&& _o)
	: userId(std::move(_o.userId))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX& CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX::operator=(Protocol_MSG_CASHIER_GET_USER_LIMIT_EX&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX::clear()
{
	userId.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX::equals(const Protocol_MSG_CASHIER_GET_USER_LIMIT_EX& _o) const
{
	return userId.equals(_o.userId);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_USER_LIMIT_EX).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_USER_LIMIT_EX";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    UserLimitReplyBody
//=================================================================

CashierServer::cli::UserLimitReplyBody::UserLimitReplyBody()
{
	clear();
}

void CashierServer::cli::UserLimitReplyBody::clear()
{
	type = 0;
	value = 0;
	enforcedUntil.setNull();
	maxL = 0;
	minL = 0;
	maxValuePropInt = 0;
	regulatoryLimit = -1;
}

bool CashierServer::cli::UserLimitReplyBody::equals(const UserLimitReplyBody& _o) const
{
	return type == _o.type &&
		value == _o.value &&
		enforcedUntil.equals(_o.enforcedUntil) &&
		maxL == _o.maxL &&
		minL == _o.minL &&
		maxValuePropInt == _o.maxValuePropInt &&
		regulatoryLimit == _o.regulatoryLimit;
}

const char *CashierServer::cli::UserLimitReplyBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("type=");
	_buf.appendUint(type);
	_buf.append(',');
	_buf.append("value=");
	_buf.appendInt(value);
	_buf.append(',');
	_buf.append("enforcedUntil=");
	ThinAtf::AtfTempl<CommSrvTime>::ToTraceString(_buf, enforcedUntil);
	_buf.append(',');
	_buf.append("maxL=");
	_buf.appendInt(maxL);
	_buf.append(',');
	_buf.append("minL=");
	_buf.appendInt(minL);
	_buf.append(',');
	_buf.append("maxValuePropInt=");
	_buf.appendInt(maxValuePropInt);
	_buf.append(',');
	_buf.append("regulatoryLimit=");
	_buf.appendInt(regulatoryLimit);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::UserLimitReplyBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(UserLimitReplyBody())) // not empty
	{
		_body.composeUINT32(type);
		_body.composeINT32(value);
		_body.composeSrvTime(enforcedUntil);
		_body.composeINT32(maxL);
		_body.composeINT32(minL);
		_body.composeINT32(maxValuePropInt);
		_body.composeINT32(regulatoryLimit);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::UserLimitReplyBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(type);
	_parser0.parseINT32(value);
	_parser0.parseSrvTime(enforcedUntil);
	_parser0.parseINT32(maxL);
	_parser0.parseINT32(minL);
	_parser0.parseINT32(maxValuePropInt);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT32(regulatoryLimit);
}

/*static*/ void CashierServer::cli::UserLimitReplyBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 type; _parser0.parseUINT32(type);
	AtfValidator::validateInt(_descr, "type", type, _checker, __FILE__, __LINE__);
	INT32 value; _parser0.parseINT32(value);
	AtfValidator::validateInt(_descr, "value", value, _checker, __FILE__, __LINE__);
	CommSrvTime enforcedUntil; _parser0.parseSrvTime(enforcedUntil);
	AtfValidator::validateSrvDateTime(_descr, "enforcedUntil", enforcedUntil, _checker, __FILE__, __LINE__);
	INT32 maxL; _parser0.parseINT32(maxL);
	AtfValidator::validateInt(_descr, "maxL", maxL, _checker, __FILE__, __LINE__);
	INT32 minL; _parser0.parseINT32(minL);
	AtfValidator::validateInt(_descr, "minL", minL, _checker, __FILE__, __LINE__);
	INT32 maxValuePropInt; _parser0.parseINT32(maxValuePropInt);
	AtfValidator::validateInt(_descr, "maxValuePropInt", maxValuePropInt, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT32 regulatoryLimit; _parser0.parseINT32(regulatoryLimit);
	AtfValidator::validateInt(_descr, "regulatoryLimit", regulatoryLimit, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY(Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, quizPropInt(std::move(_o.quizPropInt))
	, quizPropWhen(std::move(_o.quizPropWhen))
	, size(std::move(_o.size))
	, limitDaily(std::move(_o.limitDaily))
	, limitWeekly(std::move(_o.limitWeekly))
	, limitMonthly(std::move(_o.limitMonthly))
	, selfLimitCurrency(std::move(_o.selfLimitCurrency))
	, rateToUsd_x100M(std::move(_o.rateToUsd_x100M))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY::operator=(Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		quizPropInt = std::move(_o.quizPropInt);
		quizPropWhen = std::move(_o.quizPropWhen);
		size = std::move(_o.size);
		limitDaily = std::move(_o.limitDaily);
		limitWeekly = std::move(_o.limitWeekly);
		limitMonthly = std::move(_o.limitMonthly);
		selfLimitCurrency = std::move(_o.selfLimitCurrency);
		rateToUsd_x100M = std::move(_o.rateToUsd_x100M);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	quizPropInt = 0;
	quizPropWhen.setNull();
	size = 0;
	limitDaily.clear();
	limitWeekly.clear();
	limitMonthly.clear();
	selfLimitCurrency.clear();
	rateToUsd_x100M = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY::equals(const Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		quizPropInt == _o.quizPropInt &&
		quizPropWhen.equals(_o.quizPropWhen) &&
		size == _o.size &&
		limitDaily.equals(_o.limitDaily) &&
		limitWeekly.equals(_o.limitWeekly) &&
		limitMonthly.equals(_o.limitMonthly) &&
		selfLimitCurrency.equals(_o.selfLimitCurrency) &&
		rateToUsd_x100M == _o.rateToUsd_x100M;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_USER_LIMIT_EX_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("quizPropInt=");
		_buf.appendUint(quizPropInt);
		_buf.append(',');
		_buf.append("quizPropWhen=");
		ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, quizPropWhen);
		_buf.append(',');
		_buf.append("size=");
		_buf.appendUint(size);
		_buf.append(',');
		_buf.append("limitDaily=");
		limitDaily.toTraceString(_buf);
		_buf.append(',');
		_buf.append("limitWeekly=");
		limitWeekly.toTraceString(_buf);
		_buf.append(',');
		_buf.append("limitMonthly=");
		limitMonthly.toTraceString(_buf);
		_buf.append(',');
		_buf.append("selfLimitCurrency=");
		_buf.append(selfLimitCurrency);
		_buf.append(',');
		_buf.append("rateToUsd_x100M=");
		_buf.appendInt64(rateToUsd_x100M);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		CommMsgBody _msg0;
		_msg0.composeUINT32(quizPropInt);
		_msg0.composeSrvTime(quizPropWhen);
		_msg.composeMsgBody(_msg0);
		_msg.composeUINT32(size);
		limitDaily.composeMsg(_msg);
		limitWeekly.composeMsg(_msg);
		limitMonthly.composeMsg(_msg);
		_msg.composeString(selfLimitCurrency);
		_msg.composeINT64(rateToUsd_x100M);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		parseAnonymousMsgBody0(_parser);
		_parser.parseUINT32(size);
		limitDaily.parseMsg(_parser);
		limitWeekly.parseMsg(_parser);
		limitMonthly.parseMsg(_parser);
		_parser.parseStringP(selfLimitCurrency);
		_parser.parseINT64(rateToUsd_x100M);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_USER_LIMIT_EX_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
		UINT32 size; _parser.parseUINT32(size);
		AtfValidator::validateIntRange(_descr, "size", size, 3, 3, _checker, __FILE__, __LINE__);
		PString _descbuf;
		UserLimitReplyBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("limitDaily"), _fieldsWithUnparsedContent);
		UserLimitReplyBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("limitWeekly"), _fieldsWithUnparsedContent);
		UserLimitReplyBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("limitMonthly"), _fieldsWithUnparsedContent);
		_parser.parseStringN(_dummy, 0, "selfLimitCurrency"); size_t szSelfLimitCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "selfLimitCurrency", szSelfLimitCurrency, _checker, __FILE__, __LINE__);
		INT64 rateToUsd_x100M; _parser.parseINT64(rateToUsd_x100M);
		AtfValidator::validateInt(_descr, "rateToUsd_x100M", rateToUsd_x100M, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(quizPropInt);
	_parser0.parseSrvTime(quizPropWhen);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 quizPropInt; _parser0.parseUINT32(quizPropInt);
	AtfValidator::validateInt(_descr, "quizPropInt", quizPropInt, _checker, __FILE__, __LINE__);
	SrvTime quizPropWhen; _parser0.parseSrvTime(quizPropWhen);
	AtfValidator::validateSrvDateTime(_descr, "quizPropWhen", quizPropWhen, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CashierUserLimit
//=================================================================

CashierServer::cli::CashierUserLimit::CashierUserLimit()
{
	clear();
}

void CashierServer::cli::CashierUserLimit::clear()
{
	type = 0;
	value = 0;
}

bool CashierServer::cli::CashierUserLimit::equals(const CashierUserLimit& _o) const
{
	return type == _o.type &&
		value == _o.value;
}

const char *CashierServer::cli::CashierUserLimit::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("type=");
	_buf.appendUint(type);
	_buf.append(',');
	_buf.append("value=");
	_buf.appendInt(value);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashierUserLimit::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(type);
	_msg.composeINT32(value);
}

void CashierServer::cli::CashierUserLimit::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(type);
	_parser.parseINT32(value);
}

/*static*/ void CashierServer::cli::CashierUserLimit::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 type; _parser.parseUINT32(type);
	{ const UINT32 type_enum[] = {eDailyDepositLimit, eWeeklyDepositLimit, eMonthlyDepositLimit}; AtfValidator::validateEnum(_descr, "type", type, type_enum, _checker, __FILE__, __LINE__); }
	INT32 value; _parser.parseINT32(value);
	AtfValidator::validateIntRange(_descr, "value", value, -1, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_USER_LIMIT_EX
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::clear()
{
	quiz = 0;
	ignoreFlags1 = 0;
	ignoreFlags2 = 0;
	answers = 0;
	sz = 0;
	daily.clear();
	weekly.clear();
	monthly.clear();
	groupDepositLimit = false;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::equals(const Protocol_MSG_CASHIER_SET_USER_LIMIT_EX& _o) const
{
	return quiz == _o.quiz &&
		ignoreFlags1 == _o.ignoreFlags1 &&
		ignoreFlags2 == _o.ignoreFlags2 &&
		answers == _o.answers &&
		sz == _o.sz &&
		daily.equals(_o.daily) &&
		weekly.equals(_o.weekly) &&
		monthly.equals(_o.monthly) &&
		groupDepositLimit == _o.groupDepositLimit;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_USER_LIMIT_EX).append(")");
	_buf.append(',');
	_buf.append("quiz=");
	_buf.appendUint(quiz);
	_buf.append(',');
	_buf.append("ignoreFlags1=");
	_buf.appendUint(ignoreFlags1);
	_buf.append(',');
	_buf.append("ignoreFlags2=");
	_buf.appendUint64(ignoreFlags2);
	_buf.append(',');
	_buf.append("answers=");
	_buf.appendUint(answers);
	_buf.append(',');
	_buf.append("sz=");
	_buf.appendUint(sz);
	_buf.append(',');
	_buf.append("daily=");
	daily.toTraceString(_buf);
	_buf.append(',');
	_buf.append("weekly=");
	weekly.toTraceString(_buf);
	_buf.append(',');
	_buf.append("monthly=");
	monthly.toTraceString(_buf);
	_buf.append(',');
	_buf.append("groupDepositLimit=");
	_buf.appendUint(groupDepositLimit);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	_msg0.composeUINT32(quiz);
	_msg0.composeUINT32(ignoreFlags1);
	_msg0.composeUINT64(ignoreFlags2);
	_msg0.composeUINT32(answers);
	_msg.composeMsgBody(_msg0);
	_msg.composeUINT32(sz);
	CommMsgBody _msg1;
	daily.composeMsg(_msg1);
	_msg.composeMsgBody(_msg1);
	CommMsgBody _msg2;
	weekly.composeMsg(_msg2);
	_msg.composeMsgBody(_msg2);
	CommMsgBody _msg3;
	monthly.composeMsg(_msg3);
	_msg.composeMsgBody(_msg3);
	_msg.composeBOOL(groupDepositLimit);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::parseMsg(CommMsgParser& _parser)
{
	parseAnonymousMsgBody0(_parser);
	_parser.parseUINT32(sz);
	parseAnonymousMsgBody1(_parser);
	parseAnonymousMsgBody2(_parser);
	parseAnonymousMsgBody3(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(groupDepositLimit);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_USER_LIMIT_EX";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 sz; _parser.parseUINT32(sz);
	AtfValidator::validateIntRange(_descr, "sz", sz, 3, 3, _checker, __FILE__, __LINE__);
	validateAnonymousMsgBody1(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	validateAnonymousMsgBody2(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	validateAnonymousMsgBody3(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	bool groupDepositLimit; _parser.parseBOOL(groupDepositLimit);
	AtfValidator::validateInt(_descr, "groupDepositLimit", groupDepositLimit, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(quiz);
	_parser0.parseUINT32(ignoreFlags1);
	_parser0.parseUINT64(ignoreFlags2);
	_parser0.parseUINT32(answers);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 quiz; _parser0.parseUINT32(quiz);
	AtfValidator::validateInt(_descr, "quiz", quiz, _checker, __FILE__, __LINE__);
	UINT32 ignoreFlags1; _parser0.parseUINT32(ignoreFlags1);
	AtfValidator::validateInt(_descr, "ignoreFlags1", ignoreFlags1, _checker, __FILE__, __LINE__);
	UINT64 ignoreFlags2; _parser0.parseUINT64(ignoreFlags2);
	AtfValidator::validateUint(_descr, "ignoreFlags2", ignoreFlags2, _checker, __FILE__, __LINE__);
	UINT32 answers; _parser0.parseUINT32(answers);
	AtfValidator::validateInt(_descr, "answers", answers, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::parseAnonymousMsgBody1(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	daily.parseMsg(_parser0);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::validateAnonymousMsgBody1(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	CashierUserLimit::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("daily"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::parseAnonymousMsgBody2(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	weekly.parseMsg(_parser0);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::validateAnonymousMsgBody2(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	CashierUserLimit::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("weekly"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::parseAnonymousMsgBody3(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	monthly.parseMsg(_parser0);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::validateAnonymousMsgBody3(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	CashierUserLimit::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("monthly"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SelfDepositLimitReplyInfo
//=================================================================

CashierServer::cli::SelfDepositLimitReplyInfo::SelfDepositLimitReplyInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::SelfDepositLimitReplyInfo::SelfDepositLimitReplyInfo(SelfDepositLimitReplyInfo&& _o)
	: type(std::move(_o.type))
	, code(std::move(_o.code))
	, info(std::move(_o.info))
	, curValue(std::move(_o.curValue))
	, enforcedUntil(std::move(_o.enforcedUntil))
	, newValue(std::move(_o.newValue))
{
}

CashierServer::cli::SelfDepositLimitReplyInfo& CashierServer::cli::SelfDepositLimitReplyInfo::operator=(SelfDepositLimitReplyInfo&& _o)
{
	if(this != &_o)
	{
		type = std::move(_o.type);
		code = std::move(_o.code);
		info = std::move(_o.info);
		curValue = std::move(_o.curValue);
		enforcedUntil = std::move(_o.enforcedUntil);
		newValue = std::move(_o.newValue);
	}
	return *this;
}

#endif

void CashierServer::cli::SelfDepositLimitReplyInfo::clear()
{
	type = 0;
	code = 0;
	info.clear();
	curValue = 0;
	enforcedUntil.setNull();
	newValue = 0;
}

bool CashierServer::cli::SelfDepositLimitReplyInfo::equals(const SelfDepositLimitReplyInfo& _o) const
{
	return type == _o.type &&
		code == _o.code &&
		info.equals(_o.info) &&
		curValue == _o.curValue &&
		enforcedUntil.equals(_o.enforcedUntil) &&
		newValue == _o.newValue;
}

const char *CashierServer::cli::SelfDepositLimitReplyInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("type=");
	_buf.appendUint(type);
	_buf.append(',');
	_buf.append("code=");
	_buf.appendInt(code);
	_buf.append(',');
	_buf.append("info=");
	_buf.append(info);
	_buf.append(',');
	_buf.append("curValue=");
	_buf.appendInt(curValue);
	_buf.append(',');
	_buf.append("enforcedUntil=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, enforcedUntil);
	_buf.append(',');
	_buf.append("newValue=");
	_buf.appendInt(newValue);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::SelfDepositLimitReplyInfo::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(type);
	_msg.composeINT16(code);
	_msg.composeString(info);
	_msg.composeINT32(curValue);
	_msg.composeSrvTime(enforcedUntil);
	_msg.composeINT32(newValue);
}

void CashierServer::cli::SelfDepositLimitReplyInfo::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(type);
	_parser.parseINT16(code);
	_parser.parseStringP(info);
	_parser.parseINT32(curValue);
	_parser.parseSrvTime(enforcedUntil);
	_parser.parseINT32(newValue);
}

/*static*/ void CashierServer::cli::SelfDepositLimitReplyInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 type; _parser.parseUINT32(type);
	AtfValidator::validateInt(_descr, "type", type, _checker, __FILE__, __LINE__);
	INT16 code; _parser.parseINT16(code);
	AtfValidator::validateInt(_descr, "code", code, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "info"); size_t szInfo = strlen(_dummy);
	AtfValidator::validateInt(_descr, "info", szInfo, _checker, __FILE__, __LINE__);
	INT32 curValue; _parser.parseINT32(curValue);
	AtfValidator::validateInt(_descr, "curValue", curValue, _checker, __FILE__, __LINE__);
	SrvTime enforcedUntil; _parser.parseSrvTime(enforcedUntil);
	AtfValidator::validateSrvDateTime(_descr, "enforcedUntil", enforcedUntil, _checker, __FILE__, __LINE__);
	INT32 newValue; _parser.parseINT32(newValue);
	AtfValidator::validateInt(_descr, "newValue", newValue, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY(Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, sz(std::move(_o.sz))
	, daily(std::move(_o.daily))
	, weekly(std::move(_o.weekly))
	, monthly(std::move(_o.monthly))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY::operator=(Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		sz = std::move(_o.sz);
		daily = std::move(_o.daily);
		weekly = std::move(_o.weekly);
		monthly = std::move(_o.monthly);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	sz = 0;
	daily.clear();
	weekly.clear();
	monthly.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY::equals(const Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		sz == _o.sz &&
		daily.equals(_o.daily) &&
		weekly.equals(_o.weekly) &&
		monthly.equals(_o.monthly);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_USER_LIMIT_EX_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("sz=");
		_buf.appendUint(sz);
		_buf.append(',');
		_buf.append("daily=");
		daily.toTraceString(_buf);
		_buf.append(',');
		_buf.append("weekly=");
		weekly.toTraceString(_buf);
		_buf.append(',');
		_buf.append("monthly=");
		monthly.toTraceString(_buf);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(sz);
		CommMsgBody _msg0;
		daily.composeMsg(_msg0);
		_msg.composeMsgBody(_msg0);
		CommMsgBody _msg1;
		weekly.composeMsg(_msg1);
		_msg.composeMsgBody(_msg1);
		CommMsgBody _msg2;
		monthly.composeMsg(_msg2);
		_msg.composeMsgBody(_msg2);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(sz);
		parseAnonymousMsgBody0(_parser);
		parseAnonymousMsgBody1(_parser);
		parseAnonymousMsgBody2(_parser);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_USER_LIMIT_EX_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 sz; _parser.parseUINT32(sz);
		AtfValidator::validateInt(_descr, "sz", sz, _checker, __FILE__, __LINE__);
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
		validateAnonymousMsgBody1(_parser, _checker, _descr, _fieldsWithUnparsedContent);
		validateAnonymousMsgBody2(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	daily.parseMsg(_parser0);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	SelfDepositLimitReplyInfo::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("daily"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY::parseAnonymousMsgBody1(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	weekly.parseMsg(_parser0);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY::validateAnonymousMsgBody1(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	SelfDepositLimitReplyInfo::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("weekly"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY::parseAnonymousMsgBody2(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	monthly.parseMsg(_parser0);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY::validateAnonymousMsgBody2(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	SelfDepositLimitReplyInfo::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("monthly"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2::equals(const Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2& _o) const
{
	return true;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_UNCLEARED_DEPOSITS2).append(")");
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2::composeMsg(CommMsgBody& _msg) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_UNCLEARED_DEPOSITS2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierUnclearedDepositBody
//=================================================================

CashierServer::cli::CashierUnclearedDepositBody::CashierUnclearedDepositBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::CashierUnclearedDepositBody::CashierUnclearedDepositBody(CashierUnclearedDepositBody&& _o)
	: transId(std::move(_o.transId))
	, psNameTranslated(std::move(_o.psNameTranslated))
	, amountUsd(std::move(_o.amountUsd))
	, whenClear(std::move(_o.whenClear))
	, fppLeftToClear(std::move(_o.fppLeftToClear))
	, balanceCurrency(std::move(_o.balanceCurrency))
	, balanceAmount(std::move(_o.balanceAmount))
	, processorCurrency(std::move(_o.processorCurrency))
	, processorAmount(std::move(_o.processorAmount))
{
}

CashierServer::cli::CashierUnclearedDepositBody& CashierServer::cli::CashierUnclearedDepositBody::operator=(CashierUnclearedDepositBody&& _o)
{
	if(this != &_o)
	{
		transId = std::move(_o.transId);
		psNameTranslated = std::move(_o.psNameTranslated);
		amountUsd = std::move(_o.amountUsd);
		whenClear = std::move(_o.whenClear);
		fppLeftToClear = std::move(_o.fppLeftToClear);
		balanceCurrency = std::move(_o.balanceCurrency);
		balanceAmount = std::move(_o.balanceAmount);
		processorCurrency = std::move(_o.processorCurrency);
		processorAmount = std::move(_o.processorAmount);
	}
	return *this;
}

#endif

void CashierServer::cli::CashierUnclearedDepositBody::clear()
{
	transId = 0;
	psNameTranslated.clear();
	amountUsd = 0;
	whenClear.setNull();
	fppLeftToClear = 0;
	balanceCurrency.clear();
	balanceAmount = 0;
	processorCurrency.clear();
	processorAmount = 0;
}

bool CashierServer::cli::CashierUnclearedDepositBody::equals(const CashierUnclearedDepositBody& _o) const
{
	return transId == _o.transId &&
		psNameTranslated.equals(_o.psNameTranslated) &&
		amountUsd == _o.amountUsd &&
		whenClear.equals(_o.whenClear) &&
		fppLeftToClear == _o.fppLeftToClear &&
		balanceCurrency.equals(_o.balanceCurrency) &&
		balanceAmount == _o.balanceAmount &&
		processorCurrency.equals(_o.processorCurrency) &&
		processorAmount == _o.processorAmount;
}

const char *CashierServer::cli::CashierUnclearedDepositBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("transId=");
	_buf.appendUint(transId);
	_buf.append(',');
	_buf.append("psNameTranslated=");
	_buf.append(psNameTranslated);
	_buf.append(',');
	_buf.append("amountUsd=");
	_buf.appendInt(amountUsd);
	_buf.append(',');
	_buf.append("whenClear=");
	ThinAtf::AtfTempl<CommSrvTime>::ToTraceString(_buf, whenClear);
	_buf.append(',');
	_buf.append("fppLeftToClear=");
	_buf.appendInt(fppLeftToClear);
	_buf.append(',');
	_buf.append("balanceCurrency=");
	_buf.append(balanceCurrency);
	_buf.append(',');
	_buf.append("balanceAmount=");
	_buf.appendInt(balanceAmount);
	_buf.append(',');
	_buf.append("processorCurrency=");
	_buf.append(processorCurrency);
	_buf.append(',');
	_buf.append("processorAmount=");
	_buf.appendInt(processorAmount);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashierUnclearedDepositBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CashierUnclearedDepositBody())) // not empty
	{
		_body.composeUINT32(transId);
		_body.composeString(psNameTranslated);
		_body.composeINT32(amountUsd);
		_body.composeSrvTime(whenClear);
		_body.composeINT32(fppLeftToClear);
		_body.composeString(balanceCurrency);
		_body.composeINT32(balanceAmount);
		_body.composeString(processorCurrency);
		_body.composeINT32(processorAmount);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierUnclearedDepositBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(transId);
	_parser0.parseStringP(psNameTranslated);
	_parser0.parseINT32(amountUsd);
	_parser0.parseSrvTime(whenClear);
	_parser0.parseINT32(fppLeftToClear);
	_parser0.parseStringP(balanceCurrency);
	_parser0.parseINT32(balanceAmount);
	_parser0.parseStringP(processorCurrency);
	_parser0.parseINT32(processorAmount);
}

/*static*/ void CashierServer::cli::CashierUnclearedDepositBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 transId; _parser0.parseUINT32(transId);
	AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "psNameTranslated"); size_t szPsNameTranslated = strlen(_dummy);
	AtfValidator::validateInt(_descr, "psNameTranslated", szPsNameTranslated, _checker, __FILE__, __LINE__);
	INT32 amountUsd; _parser0.parseINT32(amountUsd);
	AtfValidator::validateInt(_descr, "amountUsd", amountUsd, _checker, __FILE__, __LINE__);
	CommSrvTime whenClear; _parser0.parseSrvTime(whenClear);
	AtfValidator::validateSrvDateTime(_descr, "whenClear", whenClear, _checker, __FILE__, __LINE__);
	INT32 fppLeftToClear; _parser0.parseINT32(fppLeftToClear);
	AtfValidator::validateInt(_descr, "fppLeftToClear", fppLeftToClear, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "balanceCurrency"); size_t szBalanceCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "balanceCurrency", szBalanceCurrency, _checker, __FILE__, __LINE__);
	INT32 balanceAmount; _parser0.parseINT32(balanceAmount);
	AtfValidator::validateInt(_descr, "balanceAmount", balanceAmount, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "processorCurrency"); size_t szProcessorCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "processorCurrency", szProcessorCurrency, _checker, __FILE__, __LINE__);
	INT32 processorAmount; _parser0.parseINT32(processorAmount);
	AtfValidator::validateInt(_descr, "processorAmount", processorAmount, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY(Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, unclearedDeposits(std::move(_o.unclearedDeposits))
	, maxNum(std::move(_o.maxNum))
	, maxSum(std::move(_o.maxSum))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY::operator=(Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		unclearedDeposits = std::move(_o.unclearedDeposits);
		maxNum = std::move(_o.maxNum);
		maxSum = std::move(_o.maxSum);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	unclearedDeposits.clear();
	maxNum = 0;
	maxSum = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY::equals(const Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		unclearedDeposits.equals(_o.unclearedDeposits) &&
		maxNum == _o.maxNum &&
		maxSum == _o.maxSum;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("unclearedDeposits=");
		unclearedDeposits.toTraceString(_buf);
		_buf.append(',');
		_buf.append("maxNum=");
		_buf.appendUint(maxNum);
		_buf.append(',');
		_buf.append("maxSum=");
		_buf.appendUint(maxSum);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		unclearedDeposits.composeMsg(_msg);
		_msg.composeUINT32(maxNum);
		_msg.composeUINT32(maxSum);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		unclearedDeposits.parseMsg(_parser);
		_parser.parseUINT32(maxNum);
		_parser.parseUINT32(maxSum);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szUnclearedDeposits = ThinAtf::LAtfVector< CashierUnclearedDepositBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("unclearedDeposits"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "unclearedDeposits", szUnclearedDeposits, _checker, __FILE__, __LINE__);
		UINT32 maxNum; _parser.parseUINT32(maxNum);
		AtfValidator::validateInt(_descr, "maxNum", maxNum, _checker, __FILE__, __LINE__);
		UINT32 maxSum; _parser.parseUINT32(maxSum);
		AtfValidator::validateInt(_descr, "maxSum", maxSum, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_DBT_FIELDS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS::Protocol_MSG_CASHIER_GET_DBT_FIELDS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS::Protocol_MSG_CASHIER_GET_DBT_FIELDS(Protocol_MSG_CASHIER_GET_DBT_FIELDS&& _o)
	: userId(std::move(_o.userId))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS& CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS::operator=(Protocol_MSG_CASHIER_GET_DBT_FIELDS&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS::clear()
{
	userId.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS::equals(const Protocol_MSG_CASHIER_GET_DBT_FIELDS& _o) const
{
	return userId.equals(_o.userId);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_DBT_FIELDS).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_DBT_FIELDS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    OneDbtFieldBody
//=================================================================

CashierServer::cli::OneDbtFieldBody::OneDbtFieldBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::OneDbtFieldBody::OneDbtFieldBody(OneDbtFieldBody&& _o)
	: fieldName(std::move(_o.fieldName))
	, localizedDescription(std::move(_o.localizedDescription))
	, fieldValue(std::move(_o.fieldValue))
	, maxLen(std::move(_o.maxLen))
	, flag(std::move(_o.flag))
	, extra(std::move(_o.extra))
	, minLen(std::move(_o.minLen))
{
}

CashierServer::cli::OneDbtFieldBody& CashierServer::cli::OneDbtFieldBody::operator=(OneDbtFieldBody&& _o)
{
	if(this != &_o)
	{
		fieldName = std::move(_o.fieldName);
		localizedDescription = std::move(_o.localizedDescription);
		fieldValue = std::move(_o.fieldValue);
		maxLen = std::move(_o.maxLen);
		flag = std::move(_o.flag);
		extra = std::move(_o.extra);
		minLen = std::move(_o.minLen);
	}
	return *this;
}

#endif

void CashierServer::cli::OneDbtFieldBody::clear()
{
	fieldName.clear();
	localizedDescription.clear();
	fieldValue.clear();
	maxLen = 0;
	flag = 0;
	extra.clear();
	minLen = 0;
}

bool CashierServer::cli::OneDbtFieldBody::equals(const OneDbtFieldBody& _o) const
{
	return fieldName.equals(_o.fieldName) &&
		localizedDescription.equals(_o.localizedDescription) &&
		fieldValue.equals(_o.fieldValue) &&
		maxLen == _o.maxLen &&
		flag == _o.flag &&
		extra.equals(_o.extra) &&
		minLen == _o.minLen;
}

const char *CashierServer::cli::OneDbtFieldBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("fieldName=");
	_buf.append(fieldName);
	_buf.append(',');
	_buf.append("localizedDescription=");
	_buf.append(localizedDescription);
	_buf.append(',');
	_buf.append("fieldValue=");
	_buf.append(fieldValue);
	_buf.append(',');
	_buf.append("maxLen=");
	_buf.appendUint(maxLen);
	_buf.append(',');
	_buf.append("flag=");
	_buf.appendUint(flag);
	_buf.append(',');
	_buf.append("extra=");
	_buf.append(extra);
	_buf.append(',');
	_buf.append("minLen=");
	_buf.appendUint(minLen);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::OneDbtFieldBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(OneDbtFieldBody())) // not empty
	{
		_body.composeString(fieldName);
		_body.composeString(localizedDescription);
		_body.composeString(fieldValue);
		_body.composeUINT32(maxLen);
		_body.composeUINT32(flag);
		_body.composeString(extra);
		_body.composeUINT32(minLen);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::OneDbtFieldBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(fieldName);
	_parser0.parseStringP(localizedDescription);
	_parser0.parseStringP(fieldValue);
	_parser0.parseUINT32(maxLen);
	_parser0.parseUINT32(flag);
	_parser0.parseStringP(extra);
	_parser0.parseUINT32(minLen);
}

/*static*/ void CashierServer::cli::OneDbtFieldBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "fieldName"); size_t szFieldName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "fieldName", szFieldName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "localizedDescription"); size_t szLocalizedDescription = strlen(_dummy);
	AtfValidator::validateInt(_descr, "localizedDescription", szLocalizedDescription, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "fieldValue"); size_t szFieldValue = strlen(_dummy);
	AtfValidator::validateInt(_descr, "fieldValue", szFieldValue, _checker, __FILE__, __LINE__);
	UINT32 maxLen; _parser0.parseUINT32(maxLen);
	AtfValidator::validateInt(_descr, "maxLen", maxLen, _checker, __FILE__, __LINE__);
	UINT32 flag; _parser0.parseUINT32(flag);
	AtfValidator::validateInt(_descr, "flag", flag, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "extra"); size_t szExtra = strlen(_dummy);
	AtfValidator::validateInt(_descr, "extra", szExtra, _checker, __FILE__, __LINE__);
	UINT32 minLen; _parser0.parseUINT32(minLen);
	AtfValidator::validateInt(_descr, "minLen", minLen, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_DBT_FIELDS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS_REPLY::Protocol_MSG_CASHIER_GET_DBT_FIELDS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS_REPLY::Protocol_MSG_CASHIER_GET_DBT_FIELDS_REPLY(Protocol_MSG_CASHIER_GET_DBT_FIELDS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, dbtFields(std::move(_o.dbtFields))
	, currencies(std::move(_o.currencies))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS_REPLY::operator=(Protocol_MSG_CASHIER_GET_DBT_FIELDS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		dbtFields = std::move(_o.dbtFields);
		currencies = std::move(_o.currencies);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	dbtFields.clear();
	currencies.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS_REPLY::equals(const Protocol_MSG_CASHIER_GET_DBT_FIELDS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		dbtFields.equals(_o.dbtFields) &&
		currencies.equals(_o.currencies);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_DBT_FIELDS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("dbtFields=");
		dbtFields.toTraceString(_buf);
		_buf.append(',');
		_buf.append("currencies=");
		currencies.toTraceString(_buf);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		dbtFields.composeMsg(_msg);
		currencies.composeMsg(_msg);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		dbtFields.parseMsg(_parser);
		currencies.parseMsg(_parser);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_DBT_FIELDS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szDbtFields = ThinAtf::LAtfVector< OneDbtFieldBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("dbtFields"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "dbtFields", szDbtFields, _checker, __FILE__, __LINE__);
		int szCurrencies = ThinAtf::LAtfVector< PString, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("currencies"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "currencies", szCurrencies, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    DbtValidateFieldBody
//=================================================================

CashierServer::cli::DbtValidateFieldBody::DbtValidateFieldBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::DbtValidateFieldBody::DbtValidateFieldBody(DbtValidateFieldBody&& _o)
	: fieldName(std::move(_o.fieldName))
	, fieldValue(std::move(_o.fieldValue))
{
}

CashierServer::cli::DbtValidateFieldBody& CashierServer::cli::DbtValidateFieldBody::operator=(DbtValidateFieldBody&& _o)
{
	if(this != &_o)
	{
		fieldName = std::move(_o.fieldName);
		fieldValue = std::move(_o.fieldValue);
	}
	return *this;
}

#endif

void CashierServer::cli::DbtValidateFieldBody::clear()
{
	fieldName.clear();
	fieldValue.clear();
}

bool CashierServer::cli::DbtValidateFieldBody::equals(const DbtValidateFieldBody& _o) const
{
	return fieldName.equals(_o.fieldName) &&
		fieldValue.equals(_o.fieldValue);
}

const char *CashierServer::cli::DbtValidateFieldBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("fieldName=");
	_buf.append(fieldName);
	_buf.append(',');
	_buf.append("fieldValue=");
	_buf.append(fieldValue);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::DbtValidateFieldBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(DbtValidateFieldBody())) // not empty
	{
		_body.composeString(fieldName);
		_body.composeString(fieldValue);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::DbtValidateFieldBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(fieldName);
	_parser0.parseStringP(fieldValue);
}

/*static*/ void CashierServer::cli::DbtValidateFieldBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "fieldName"); size_t szFieldName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "fieldName", szFieldName, 100, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "fieldValue"); size_t szFieldValue = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "fieldValue", szFieldValue, 300, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_DBT_VALIDATE
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE::Protocol_MSG_CASHIER_DBT_VALIDATE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE::Protocol_MSG_CASHIER_DBT_VALIDATE(Protocol_MSG_CASHIER_DBT_VALIDATE&& _o)
	: userId(std::move(_o.userId))
	, currency(std::move(_o.currency))
	, fields(std::move(_o.fields))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE& CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE::operator=(Protocol_MSG_CASHIER_DBT_VALIDATE&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		currency = std::move(_o.currency);
		fields = std::move(_o.fields);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE::clear()
{
	userId.clear();
	currency.clear();
	fields.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE::equals(const Protocol_MSG_CASHIER_DBT_VALIDATE& _o) const
{
	return userId.equals(_o.userId) &&
		currency.equals(_o.currency) &&
		fields.equals(_o.fields);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_DBT_VALIDATE).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("fields=");
	fields.toTraceString(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeString(currency);
	fields.composeMsg(_msg);
}

void CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseStringP(currency);
	fields.parseMsg(_parser);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_DBT_VALIDATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szFields = ThinAtf::LAtfVector< DbtValidateFieldBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("fields"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "fields", szFields, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_DBT_VALIDATE_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE_REPLY::Protocol_MSG_CASHIER_DBT_VALIDATE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE_REPLY::Protocol_MSG_CASHIER_DBT_VALIDATE_REPLY(Protocol_MSG_CASHIER_DBT_VALIDATE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errReplyInfo(std::move(_o.errReplyInfo))
	, eDbtWireBankValNoError(std::move(_o.eDbtWireBankValNoError))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE_REPLY::operator=(Protocol_MSG_CASHIER_DBT_VALIDATE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errReplyInfo = std::move(_o.errReplyInfo);
		eDbtWireBankValNoError = std::move(_o.eDbtWireBankValNoError);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE_REPLY::clear()
{
	errCode = 0;
	errReplyInfo.clear();
	eDbtWireBankValNoError = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE_REPLY::equals(const Protocol_MSG_CASHIER_DBT_VALIDATE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errReplyInfo.equals(_o.errReplyInfo) &&
		eDbtWireBankValNoError == _o.eDbtWireBankValNoError;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_DBT_VALIDATE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errReplyInfo=");
	_buf.append(errReplyInfo);
	_buf.append(',');
	_buf.append("eDbtWireBankValNoError=");
	_buf.appendInt(eDbtWireBankValNoError);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errReplyInfo);
	_msg.composeINT16(eDbtWireBankValNoError);
}

void CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(errReplyInfo);
	_parser.parseINT16(eDbtWireBankValNoError);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_DBT_VALIDATE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_DBT_VALIDATE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errReplyInfo"); size_t szErrReplyInfo = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errReplyInfo", szErrReplyInfo, _checker, __FILE__, __LINE__);
	INT16 eDbtWireBankValNoError; _parser.parseINT16(eDbtWireBankValNoError);
	AtfValidator::validateInt(_descr, "eDbtWireBankValNoError", eDbtWireBankValNoError, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_AVLS_REQUEST
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST::Protocol_MSG_CASHIER_AVLS_REQUEST()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST::Protocol_MSG_CASHIER_AVLS_REQUEST(Protocol_MSG_CASHIER_AVLS_REQUEST&& _o)
	: requestType(std::move(_o.requestType))
	, userId(std::move(_o.userId))
	, phoneToContact(std::move(_o.phoneToContact))
	, timeToContact(std::move(_o.timeToContact))
	, avSystem(std::move(_o.avSystem))
	, resultId(std::move(_o.resultId))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST& CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST::operator=(Protocol_MSG_CASHIER_AVLS_REQUEST&& _o)
{
	if(this != &_o)
	{
		requestType = std::move(_o.requestType);
		userId = std::move(_o.userId);
		phoneToContact = std::move(_o.phoneToContact);
		timeToContact = std::move(_o.timeToContact);
		avSystem = std::move(_o.avSystem);
		resultId = std::move(_o.resultId);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST::clear()
{
	requestType = 0;
	userId.clear();
	phoneToContact.clear();
	timeToContact.clear();
	avSystem = 0;
	resultId = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST::equals(const Protocol_MSG_CASHIER_AVLS_REQUEST& _o) const
{
	return requestType == _o.requestType &&
		userId.equals(_o.userId) &&
		phoneToContact.equals(_o.phoneToContact) &&
		timeToContact.equals(_o.timeToContact) &&
		avSystem == _o.avSystem &&
		resultId == _o.resultId;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_AVLS_REQUEST).append(")");
	_buf.append(',');
	_buf.append("requestType=");
	_buf.appendUint(requestType);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("phoneToContact=");
	_buf.append(phoneToContact);
	_buf.append(',');
	_buf.append("timeToContact=");
	_buf.append(timeToContact);
	_buf.append(',');
	_buf.append("avSystem=");
	_buf.appendUint(avSystem);
	_buf.append(',');
	_buf.append("resultId=");
	_buf.appendUint(resultId);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(requestType);
	_msg.composeString(userId);
	_msg.composeString(phoneToContact);
	_msg.composeString(timeToContact);
	_msg.composeUINT32(avSystem);
	_msg.composeUINT32(resultId);
}

void CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(requestType);
	_parser.parseStringP(userId);
	_parser.parseStringP(phoneToContact);
	_parser.parseStringP(timeToContact);
	_parser.parseUINT32(avSystem);
	_parser.parseUINT32(resultId);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_AVLS_REQUEST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 requestType; _parser.parseUINT32(requestType);
	{ const UINT32 requestType_enum[] = { eLiveSupportRequestChat, eLiveSupportRequestPhone, eLiveSupportRequestNone, eLiveSupportRequestEmail, eLiveSupportRequestIndirect }; AtfValidator::validateEnum(_descr, "requestType", requestType, requestType_enum, _checker, __FILE__, __LINE__); }
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "phoneToContact"); size_t szPhoneToContact = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "phoneToContact", szPhoneToContact, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "timeToContact"); size_t szTimeToContact = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "timeToContact", szTimeToContact, 1000, _checker, __FILE__, __LINE__);
	UINT32 avSystem; _parser.parseUINT32(avSystem);
	{ const UINT32 avSystem_enum[] = { eAgeVerificationSystemAristotle, eAgeVerificationSystemURU }; AtfValidator::validateEnum(_descr, "avSystem", avSystem, avSystem_enum, _checker, __FILE__, __LINE__); }
	UINT32 resultId; _parser.parseUINT32(resultId);
	AtfValidator::validateInt(_descr, "resultId", resultId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_AVLS_REQUEST_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST_REPLY::Protocol_MSG_CASHIER_AVLS_REQUEST_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST_REPLY::Protocol_MSG_CASHIER_AVLS_REQUEST_REPLY(Protocol_MSG_CASHIER_AVLS_REQUEST_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, requestType(std::move(_o.requestType))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST_REPLY::operator=(Protocol_MSG_CASHIER_AVLS_REQUEST_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		requestType = std::move(_o.requestType);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	requestType = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST_REPLY::equals(const Protocol_MSG_CASHIER_AVLS_REQUEST_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		requestType == _o.requestType;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_AVLS_REQUEST_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("requestType=");
		_buf.appendUint(requestType);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(requestType);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(requestType);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_AVLS_REQUEST_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_AVLS_REQUEST_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 requestType; _parser.parseUINT32(requestType);
		AtfValidator::validateInt(_descr, "requestType", requestType, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS::clear()
{
	includeHoldStatus_obsolete = false;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS::equals(const Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS& _o) const
{
	return includeHoldStatus_obsolete == _o.includeHoldStatus_obsolete;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_PENDING_CASHOUTS).append(")");
	_buf.append(',');
	_buf.append("includeHoldStatus_obsolete=");
	_buf.appendUint(includeHoldStatus_obsolete);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBOOL(includeHoldStatus_obsolete);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(includeHoldStatus_obsolete);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_PENDING_CASHOUTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	bool includeHoldStatus_obsolete; _parser.parseBOOL(includeHoldStatus_obsolete);
	AtfValidator::validateInt(_descr, "includeHoldStatus_obsolete", includeHoldStatus_obsolete, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    OneTransBody
//=================================================================

CashierServer::cli::OneTransBody::OneTransBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::OneTransBody::OneTransBody(OneTransBody&& _o)
	: transId(std::move(_o.transId))
	, psForCashout(std::move(_o.psForCashout))
	, returnedAmount(std::move(_o.returnedAmount))
	, currency(std::move(_o.currency))
	, converted(std::move(_o.converted))
	, started(std::move(_o.started))
	, status(std::move(_o.status))
	, balanceCurrency(std::move(_o.balanceCurrency))
	, canBeCancelled(std::move(_o.canBeCancelled))
	, cardTypeByte(std::move(_o.cardTypeByte))
	, maskedReference(std::move(_o.maskedReference))
{
}

CashierServer::cli::OneTransBody& CashierServer::cli::OneTransBody::operator=(OneTransBody&& _o)
{
	if(this != &_o)
	{
		transId = std::move(_o.transId);
		psForCashout = std::move(_o.psForCashout);
		returnedAmount = std::move(_o.returnedAmount);
		currency = std::move(_o.currency);
		converted = std::move(_o.converted);
		started = std::move(_o.started);
		status = std::move(_o.status);
		balanceCurrency = std::move(_o.balanceCurrency);
		canBeCancelled = std::move(_o.canBeCancelled);
		cardTypeByte = std::move(_o.cardTypeByte);
		maskedReference = std::move(_o.maskedReference);
	}
	return *this;
}

#endif

void CashierServer::cli::OneTransBody::clear()
{
	transId = 0;
	psForCashout.clear();
	returnedAmount = 0;
	currency.clear();
	converted = 0;
	started.setNull();
	status.clear();
	balanceCurrency.clear();
	canBeCancelled = false;
	cardTypeByte = 0;
	maskedReference.clear();
}

bool CashierServer::cli::OneTransBody::equals(const OneTransBody& _o) const
{
	return transId == _o.transId &&
		psForCashout.equals(_o.psForCashout) &&
		returnedAmount == _o.returnedAmount &&
		currency.equals(_o.currency) &&
		converted == _o.converted &&
		started.equals(_o.started) &&
		status.equals(_o.status) &&
		balanceCurrency.equals(_o.balanceCurrency) &&
		canBeCancelled == _o.canBeCancelled &&
		cardTypeByte == _o.cardTypeByte &&
		maskedReference.equals(_o.maskedReference);
}

const char *CashierServer::cli::OneTransBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("transId=");
	_buf.appendUint(transId);
	_buf.append(',');
	_buf.append("psForCashout=");
	_buf.append(psForCashout);
	_buf.append(',');
	_buf.append("returnedAmount=");
	_buf.appendInt(returnedAmount);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("converted=");
	_buf.appendInt(converted);
	_buf.append(',');
	_buf.append("started=");
	ThinAtf::AtfTempl<CommSrvTime>::ToTraceString(_buf, started);
	_buf.append(',');
	_buf.append("status=");
	_buf.append(status);
	_buf.append(',');
	_buf.append("balanceCurrency=");
	_buf.append(balanceCurrency);
	_buf.append(',');
	_buf.append("canBeCancelled=");
	_buf.appendUint(canBeCancelled);
	_buf.append(',');
	_buf.append("cardTypeByte=");
	_buf.appendUint(cardTypeByte);
	_buf.append(',');
	_buf.append("maskedReference=");
	_buf.append(maskedReference);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::OneTransBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(OneTransBody())) // not empty
	{
		_body.composeUINT32(transId);
		_body.composeString(psForCashout);
		_body.composeINT32(returnedAmount);
		_body.composeString(currency);
		_body.composeINT32(converted);
		_body.composeSrvTime(started);
		_body.composeString(status);
		_body.composeString(balanceCurrency);
		_body.composeBOOL(canBeCancelled);
		_body.composeBYTE(cardTypeByte);
		_body.composeString(maskedReference);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::OneTransBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(transId);
	_parser0.parseStringP(psForCashout);
	_parser0.parseINT32(returnedAmount);
	_parser0.parseStringP(currency);
	_parser0.parseINT32(converted);
	_parser0.parseSrvTime(started);
	_parser0.parseStringP(status);
	_parser0.parseStringP(balanceCurrency);
	_parser0.parseBOOL(canBeCancelled);
	_parser0.parseBYTE(cardTypeByte);
	_parser0.parseStringP(maskedReference);
}

/*static*/ void CashierServer::cli::OneTransBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 transId; _parser0.parseUINT32(transId);
	AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "psForCashout"); size_t szPsForCashout = strlen(_dummy);
	AtfValidator::validateInt(_descr, "psForCashout", szPsForCashout, _checker, __FILE__, __LINE__);
	INT32 returnedAmount; _parser0.parseINT32(returnedAmount);
	AtfValidator::validateInt(_descr, "returnedAmount", returnedAmount, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT32 converted; _parser0.parseINT32(converted);
	AtfValidator::validateInt(_descr, "converted", converted, _checker, __FILE__, __LINE__);
	CommSrvTime started; _parser0.parseSrvTime(started);
	AtfValidator::validateSrvDateTime(_descr, "started", started, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "status"); size_t szStatus = strlen(_dummy);
	AtfValidator::validateInt(_descr, "status", szStatus, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "balanceCurrency"); size_t szBalanceCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "balanceCurrency", szBalanceCurrency, _checker, __FILE__, __LINE__);
	bool canBeCancelled; _parser0.parseBOOL(canBeCancelled);
	AtfValidator::validateInt(_descr, "canBeCancelled", canBeCancelled, _checker, __FILE__, __LINE__);
	BYTE cardTypeByte; _parser0.parseBYTE(cardTypeByte);
	AtfValidator::validateInt(_descr, "cardTypeByte", cardTypeByte, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "maskedReference"); size_t szMaskedReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "maskedReference", szMaskedReference, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY(Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY&& _o)
	: cashoutTransactions(std::move(_o.cashoutTransactions))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY::operator=(Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY&& _o)
{
	if(this != &_o)
	{
		cashoutTransactions = std::move(_o.cashoutTransactions);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY::clear()
{
	cashoutTransactions.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY::equals(const Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY& _o) const
{
	return cashoutTransactions.equals(_o.cashoutTransactions);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY).append(")");
	_buf.append(',');
	_buf.append("cashoutTransactions=");
	cashoutTransactions.toTraceString(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	cashoutTransactions.composeMsg(_msg);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY::parseMsg(CommMsgParser& _parser)
{
	cashoutTransactions.parseMsg(_parser);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szCashoutTransactions = ThinAtf::LAtfVector< OneTransBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cashoutTransactions"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "cashoutTransactions", szCashoutTransactions, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS(Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS&& _o)
	: idsToCancel(std::move(_o.idsToCancel))
	, bonusCode(std::move(_o.bonusCode))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS& CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS::operator=(Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS&& _o)
{
	if(this != &_o)
	{
		idsToCancel = std::move(_o.idsToCancel);
		bonusCode = std::move(_o.bonusCode);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS::clear()
{
	idsToCancel.clear();
	bonusCode.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS::equals(const Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS& _o) const
{
	return idsToCancel.equals(_o.idsToCancel) &&
		bonusCode.equals(_o.bonusCode);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CANCEL_PENDING_CASHOUTS).append(")");
	_buf.append(',');
	_buf.append("idsToCancel=");
	idsToCancel.toTraceString(_buf);
	_buf.append(',');
	_buf.append("bonusCode=");
	_buf.append(bonusCode);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS::composeMsg(CommMsgBody& _msg) const
{
	idsToCancel.composeMsg(_msg);
	_msg.composeString(bonusCode);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS::parseMsg(CommMsgParser& _parser)
{
	idsToCancel.parseMsg(_parser);
	_parser.parseStringP(bonusCode);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CANCEL_PENDING_CASHOUTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	PString _descbuf;
	int szIdsToCancel = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("idsToCancel"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "idsToCancel", szIdsToCancel, 10000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "bonusCode"); size_t szBonusCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bonusCode", szBonusCode, BONUS_CODE_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    PendingCashoutStatus
//=================================================================

CashierServer::cli::PendingCashoutStatus::PendingCashoutStatus()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::PendingCashoutStatus::PendingCashoutStatus(PendingCashoutStatus&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::PendingCashoutStatus& CashierServer::cli::PendingCashoutStatus::operator=(PendingCashoutStatus&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::PendingCashoutStatus::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::PendingCashoutStatus::equals(const PendingCashoutStatus& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::PendingCashoutStatus::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errDescr=");
	_buf.append(errDescr);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::PendingCashoutStatus::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errDescr);
}

void CashierServer::cli::PendingCashoutStatus::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(errDescr);
}

/*static*/ void CashierServer::cli::PendingCashoutStatus::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY(Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, cashoutStatuses(std::move(_o.cashoutStatuses))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY::operator=(Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		cashoutStatuses = std::move(_o.cashoutStatuses);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	cashoutStatuses.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY::equals(const Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		cashoutStatuses.equals(_o.cashoutStatuses);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("cashoutStatuses=");
		cashoutStatuses.toTraceString(_buf);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		cashoutStatuses.composeMsg(_msg);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		cashoutStatuses.parseMsg(_parser);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szCashoutStatuses = ThinAtf::LAtfVector< PendingCashoutStatus, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cashoutStatuses"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "cashoutStatuses", szCashoutStatuses, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS(Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS&& _o)
	: procCurrency(std::move(_o.procCurrency))
	, forAllCurrencies(std::move(_o.forAllCurrencies))
	, paysystemByte(std::move(_o.paysystemByte))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS& CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS::operator=(Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS&& _o)
{
	if(this != &_o)
	{
		procCurrency = std::move(_o.procCurrency);
		forAllCurrencies = std::move(_o.forAllCurrencies);
		paysystemByte = std::move(_o.paysystemByte);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS::clear()
{
	procCurrency.clear();
	forAllCurrencies = false;
	paysystemByte = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS::equals(const Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS& _o) const
{
	return procCurrency.equals(_o.procCurrency) &&
		forAllCurrencies == _o.forAllCurrencies &&
		paysystemByte == _o.paysystemByte;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_ENVOY_LBT_GET_BANKS).append(")");
	_buf.append(',');
	_buf.append("procCurrency=");
	_buf.append(procCurrency);
	_buf.append(',');
	_buf.append("forAllCurrencies=");
	_buf.appendUint(forAllCurrencies);
	_buf.append(',');
	_buf.append("paysystemByte=");
	_buf.appendUint(paysystemByte);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(procCurrency);
	_msg.composeBOOL(forAllCurrencies);
	_msg.composeBYTE(paysystemByte);
}

void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(procCurrency);
	_parser.parseBOOL(forAllCurrencies);
	_parser.parseBYTE(paysystemByte);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ENVOY_LBT_GET_BANKS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "procCurrency"); size_t szProcCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "procCurrency", szProcCurrency, 100, _checker, __FILE__, __LINE__);
	bool forAllCurrencies; _parser.parseBOOL(forAllCurrencies);
	AtfValidator::validateInt(_descr, "forAllCurrencies", forAllCurrencies, _checker, __FILE__, __LINE__);
	BYTE paysystemByte; _parser.parseBYTE(paysystemByte);
	AtfValidator::validateIntRange(_descr, "paysystemByte", paysystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    EnvoyBankInfoBody
//=================================================================

CashierServer::cli::EnvoyBankInfoBody::EnvoyBankInfoBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::EnvoyBankInfoBody::EnvoyBankInfoBody(EnvoyBankInfoBody&& _o)
	: bankrefId(std::move(_o.bankrefId))
	, currency(std::move(_o.currency))
	, name(std::move(_o.name))
	, city(std::move(_o.city))
	, address(std::move(_o.address))
	, swift(std::move(_o.swift))
	, url(std::move(_o.url))
	, accountNum(std::move(_o.accountNum))
	, iban(std::move(_o.iban))
	, benficiary(std::move(_o.benficiary))
	, extraInfo(std::move(_o.extraInfo))
	, preferred(std::move(_o.preferred))
	, paysystem(std::move(_o.paysystem))
	, bankId(std::move(_o.bankId))
	, comment(std::move(_o.comment))
	, flags(std::move(_o.flags))
	, country(std::move(_o.country))
{
}

CashierServer::cli::EnvoyBankInfoBody& CashierServer::cli::EnvoyBankInfoBody::operator=(EnvoyBankInfoBody&& _o)
{
	if(this != &_o)
	{
		bankrefId = std::move(_o.bankrefId);
		currency = std::move(_o.currency);
		name = std::move(_o.name);
		city = std::move(_o.city);
		address = std::move(_o.address);
		swift = std::move(_o.swift);
		url = std::move(_o.url);
		accountNum = std::move(_o.accountNum);
		iban = std::move(_o.iban);
		benficiary = std::move(_o.benficiary);
		extraInfo = std::move(_o.extraInfo);
		preferred = std::move(_o.preferred);
		paysystem = std::move(_o.paysystem);
		bankId = std::move(_o.bankId);
		comment = std::move(_o.comment);
		flags = std::move(_o.flags);
		country = std::move(_o.country);
	}
	return *this;
}

#endif

void CashierServer::cli::EnvoyBankInfoBody::clear()
{
	bankrefId = 0;
	currency.clear();
	name.clear();
	city.clear();
	address.clear();
	swift.clear();
	url.clear();
	accountNum.clear();
	iban.clear();
	benficiary.clear();
	extraInfo.clear();
	preferred = false;
	paysystem.clear();
	bankId.clear();
	comment.clear();
	flags = 0;
	country.clear();
}

bool CashierServer::cli::EnvoyBankInfoBody::equals(const EnvoyBankInfoBody& _o) const
{
	return bankrefId == _o.bankrefId &&
		currency.equals(_o.currency) &&
		name.equals(_o.name) &&
		city.equals(_o.city) &&
		address.equals(_o.address) &&
		swift.equals(_o.swift) &&
		url.equals(_o.url) &&
		accountNum.equals(_o.accountNum) &&
		iban.equals(_o.iban) &&
		benficiary.equals(_o.benficiary) &&
		extraInfo.equals(_o.extraInfo) &&
		preferred == _o.preferred &&
		paysystem.equals(_o.paysystem) &&
		bankId.equals(_o.bankId) &&
		comment.equals(_o.comment) &&
		flags == _o.flags &&
		country.equals(_o.country);
}

const char *CashierServer::cli::EnvoyBankInfoBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("bankrefId=");
	_buf.appendUint(bankrefId);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("city=");
	_buf.append(city);
	_buf.append(',');
	_buf.append("address=");
	_buf.append(address);
	_buf.append(',');
	_buf.append("swift=");
	_buf.append(swift);
	_buf.append(',');
	_buf.append("url=");
	_buf.append(url);
	_buf.append(',');
	_buf.append("accountNum=");
	_buf.append(accountNum);
	_buf.append(',');
	_buf.append("iban=");
	_buf.append(iban);
	_buf.append(',');
	_buf.append("benficiary=");
	_buf.append(benficiary);
	_buf.append(',');
	_buf.append("extraInfo=");
	_buf.append(extraInfo);
	_buf.append(',');
	_buf.append("preferred=");
	_buf.appendUint(preferred);
	_buf.append(',');
	_buf.append("paysystem=");
	_buf.append(paysystem);
	_buf.append(',');
	_buf.append("bankId=");
	_buf.append(bankId);
	_buf.append(',');
	_buf.append("comment=");
	_buf.append(comment);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::EnvoyBankInfoBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(EnvoyBankInfoBody())) // not empty
	{
		_body.composeUINT32(bankrefId);
		_body.composeString(currency);
		_body.composeString(name);
		_body.composeString(city);
		_body.composeString(address);
		_body.composeString(swift);
		_body.composeString(url);
		_body.composeString(accountNum);
		_body.composeString(iban);
		_body.composeString(benficiary);
		_body.composeString(extraInfo);
		_body.composeBOOL(preferred);
		_body.composeString(paysystem);
		_body.composeString(bankId);
		_body.composeString(comment);
		_body.composeUINT32(flags);
		_body.composeString(country);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::EnvoyBankInfoBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(bankrefId);
	_parser0.parseStringP(currency);
	_parser0.parseStringP(name);
	_parser0.parseStringP(city);
	_parser0.parseStringP(address);
	_parser0.parseStringP(swift);
	_parser0.parseStringP(url);
	_parser0.parseStringP(accountNum);
	_parser0.parseStringP(iban);
	_parser0.parseStringP(benficiary);
	_parser0.parseStringP(extraInfo);
	_parser0.parseBOOL(preferred);
	_parser0.parseStringP(paysystem);
	_parser0.parseStringP(bankId);
	_parser0.parseStringP(comment);
	_parser0.parseUINT32(flags);
	_parser0.parseStringP(country);
}

/*static*/ void CashierServer::cli::EnvoyBankInfoBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 bankrefId; _parser0.parseUINT32(bankrefId);
	AtfValidator::validateInt(_descr, "bankrefId", bankrefId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
	AtfValidator::validateInt(_descr, "city", szCity, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "address"); size_t szAddress = strlen(_dummy);
	AtfValidator::validateInt(_descr, "address", szAddress, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "swift"); size_t szSwift = strlen(_dummy);
	AtfValidator::validateInt(_descr, "swift", szSwift, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "url"); size_t szUrl = strlen(_dummy);
	AtfValidator::validateInt(_descr, "url", szUrl, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "accountNum"); size_t szAccountNum = strlen(_dummy);
	AtfValidator::validateInt(_descr, "accountNum", szAccountNum, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "iban"); size_t szIban = strlen(_dummy);
	AtfValidator::validateInt(_descr, "iban", szIban, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "benficiary"); size_t szBenficiary = strlen(_dummy);
	AtfValidator::validateInt(_descr, "benficiary", szBenficiary, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "extraInfo"); size_t szExtraInfo = strlen(_dummy);
	AtfValidator::validateInt(_descr, "extraInfo", szExtraInfo, _checker, __FILE__, __LINE__);
	bool preferred; _parser0.parseBOOL(preferred);
	AtfValidator::validateInt(_descr, "preferred", preferred, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "paysystem"); size_t szPaysystem = strlen(_dummy);
	AtfValidator::validateInt(_descr, "paysystem", szPaysystem, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "bankId"); size_t szBankId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "bankId", szBankId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "comment"); size_t szComment = strlen(_dummy);
	AtfValidator::validateInt(_descr, "comment", szComment, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser0.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY(Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, banksForClient(std::move(_o.banksForClient))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY::operator=(Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		banksForClient = std::move(_o.banksForClient);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	banksForClient.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY::equals(const Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		banksForClient.equals(_o.banksForClient);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("banksForClient=");
		banksForClient.toTraceString(_buf);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		banksForClient.composeMsg(_msg);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		banksForClient.parseMsg(_parser);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szBanksForClient = ThinAtf::LAtfVector< EnvoyBankInfoBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("banksForClient"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "banksForClient", szBanksForClient, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED(Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED&& _o)
	: bonusCode(std::move(_o.bonusCode))
	, bankrefId(std::move(_o.bankrefId))
	, currency(std::move(_o.currency))
	, name(std::move(_o.name))
	, city(std::move(_o.city))
	, address(std::move(_o.address))
	, swift(std::move(_o.swift))
	, url(std::move(_o.url))
	, accountNum(std::move(_o.accountNum))
	, iban(std::move(_o.iban))
	, benficiary(std::move(_o.benficiary))
	, extraInfo(std::move(_o.extraInfo))
	, preferred(std::move(_o.preferred))
	, intendedProcAmount(std::move(_o.intendedProcAmount))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED& CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED::operator=(Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED&& _o)
{
	if(this != &_o)
	{
		bonusCode = std::move(_o.bonusCode);
		bankrefId = std::move(_o.bankrefId);
		currency = std::move(_o.currency);
		name = std::move(_o.name);
		city = std::move(_o.city);
		address = std::move(_o.address);
		swift = std::move(_o.swift);
		url = std::move(_o.url);
		accountNum = std::move(_o.accountNum);
		iban = std::move(_o.iban);
		benficiary = std::move(_o.benficiary);
		extraInfo = std::move(_o.extraInfo);
		preferred = std::move(_o.preferred);
		intendedProcAmount = std::move(_o.intendedProcAmount);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED::clear()
{
	bonusCode.clear();
	bankrefId = 0;
	currency.clear();
	name.clear();
	city.clear();
	address.clear();
	swift.clear();
	url.clear();
	accountNum.clear();
	iban.clear();
	benficiary.clear();
	extraInfo.clear();
	preferred = false;
	intendedProcAmount = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED::equals(const Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED& _o) const
{
	return bonusCode.equals(_o.bonusCode) &&
		bankrefId == _o.bankrefId &&
		currency.equals(_o.currency) &&
		name.equals(_o.name) &&
		city.equals(_o.city) &&
		address.equals(_o.address) &&
		swift.equals(_o.swift) &&
		url.equals(_o.url) &&
		accountNum.equals(_o.accountNum) &&
		iban.equals(_o.iban) &&
		benficiary.equals(_o.benficiary) &&
		extraInfo.equals(_o.extraInfo) &&
		preferred == _o.preferred &&
		intendedProcAmount == _o.intendedProcAmount;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_ENVOY_LBT_BANK_SELECTED).append(")");
	_buf.append(',');
	_buf.append("bonusCode=");
	_buf.append(bonusCode);
	_buf.append(',');
	_buf.append("bankrefId=");
	_buf.appendUint(bankrefId);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("city=");
	_buf.append(city);
	_buf.append(',');
	_buf.append("address=");
	_buf.append(address);
	_buf.append(',');
	_buf.append("swift=");
	_buf.append(swift);
	_buf.append(',');
	_buf.append("url=");
	_buf.append(url);
	_buf.append(',');
	_buf.append("accountNum=");
	_buf.append(accountNum);
	_buf.append(',');
	_buf.append("iban=");
	_buf.append(iban);
	_buf.append(',');
	_buf.append("benficiary=");
	_buf.append(benficiary);
	_buf.append(',');
	_buf.append("extraInfo=");
	_buf.append(extraInfo);
	_buf.append(',');
	_buf.append("preferred=");
	_buf.appendUint(preferred);
	_buf.append(',');
	_buf.append("intendedProcAmount=");
	_buf.appendInt(intendedProcAmount);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(bonusCode);
	_msg.composeUINT32(bankrefId);
	_msg.composeString(currency);
	_msg.composeString(name);
	_msg.composeString(city);
	_msg.composeString(address);
	_msg.composeString(swift);
	_msg.composeString(url);
	_msg.composeString(accountNum);
	_msg.composeString(iban);
	_msg.composeString(benficiary);
	_msg.composeString(extraInfo);
	_msg.composeBOOL(preferred);
	_msg.composeINT32(intendedProcAmount);
}

void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(bonusCode);
	_parser.parseUINT32(bankrefId);
	_parser.parseStringP(currency);
	_parser.parseStringP(name);
	_parser.parseStringP(city);
	_parser.parseStringP(address);
	_parser.parseStringP(swift);
	_parser.parseStringP(url);
	_parser.parseStringP(accountNum);
	_parser.parseStringP(iban);
	_parser.parseStringP(benficiary);
	_parser.parseStringP(extraInfo);
	_parser.parseBOOL(preferred);
	_parser.parseINT32(intendedProcAmount);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ENVOY_LBT_BANK_SELECTED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "bonusCode"); size_t szBonusCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bonusCode", szBonusCode, BONUS_CODE_LEN, _checker, __FILE__, __LINE__);
	UINT32 bankrefId; _parser.parseUINT32(bankrefId);
	AtfValidator::validateInt(_descr, "bankrefId", bankrefId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "name", szName, WIREACCOUNTS_HOLDERNAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "city", szCity, WIREACCOUNTS_CITY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "address"); size_t szAddress = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "address", szAddress, WIREACCOUNTS_ADDR_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "swift"); size_t szSwift = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "swift", szSwift, WIREACCOUNTS_SWIFTCODE_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "url"); size_t szUrl = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "url", szUrl, 1000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "accountNum"); size_t szAccountNum = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "accountNum", szAccountNum, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "iban"); size_t szIban = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "iban", szIban, WIREACCOUNTS_IBAN_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "benficiary"); size_t szBenficiary = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "benficiary", szBenficiary, WIREACCOUNTS_HOLDERNAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "extraInfo"); size_t szExtraInfo = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "extraInfo", szExtraInfo, 4000, _checker, __FILE__, __LINE__);
	bool preferred; _parser.parseBOOL(preferred);
	AtfValidator::validateInt(_descr, "preferred", preferred, _checker, __FILE__, __LINE__);
	INT32 intendedProcAmount; _parser.parseINT32(intendedProcAmount);
	AtfValidator::validateIntRange(_descr, "intendedProcAmount", intendedProcAmount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY(Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, retStr(std::move(_o.retStr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY::operator=(Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		retStr = std::move(_o.retStr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	retStr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY::equals(const Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		retStr.equals(_o.retStr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("retStr=");
		_buf.append(retStr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(retStr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(retStr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "retStr"); size_t szRetStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "retStr", szRetStr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED(Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED&& _o)
	: bonusCode(std::move(_o.bonusCode))
	, bankRefId(std::move(_o.bankRefId))
	, intendedProcAmount(std::move(_o.intendedProcAmount))
	, processorCurrency(std::move(_o.processorCurrency))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED& CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED::operator=(Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED&& _o)
{
	if(this != &_o)
	{
		bonusCode = std::move(_o.bonusCode);
		bankRefId = std::move(_o.bankRefId);
		intendedProcAmount = std::move(_o.intendedProcAmount);
		processorCurrency = std::move(_o.processorCurrency);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED::clear()
{
	bonusCode.clear();
	bankRefId = 0;
	intendedProcAmount = 0;
	processorCurrency.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED::equals(const Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED& _o) const
{
	return bonusCode.equals(_o.bonusCode) &&
		bankRefId == _o.bankRefId &&
		intendedProcAmount == _o.intendedProcAmount &&
		processorCurrency.equals(_o.processorCurrency);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PSTARSPAY_BANK_SELECTED).append(")");
	_buf.append(',');
	_buf.append("bonusCode=");
	_buf.append(bonusCode);
	_buf.append(',');
	_buf.append("bankRefId=");
	_buf.appendUint(bankRefId);
	_buf.append(',');
	_buf.append("intendedProcAmount=");
	_buf.appendInt(intendedProcAmount);
	_buf.append(',');
	_buf.append("processorCurrency=");
	_buf.append(processorCurrency);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(bonusCode);
	_msg.composeUINT32(bankRefId);
	_msg.composeINT32(intendedProcAmount);
	_msg.composeString(processorCurrency);
}

void CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(bonusCode);
	_parser.parseUINT32(bankRefId);
	_parser.parseINT32(intendedProcAmount);
	_parser.parseStringP(processorCurrency);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PSTARSPAY_BANK_SELECTED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "bonusCode"); size_t szBonusCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bonusCode", szBonusCode, BONUS_CODE_LEN, _checker, __FILE__, __LINE__);
	UINT32 bankRefId; _parser.parseUINT32(bankRefId);
	AtfValidator::validateInt(_descr, "bankRefId", bankRefId, _checker, __FILE__, __LINE__);
	INT32 intendedProcAmount; _parser.parseINT32(intendedProcAmount);
	AtfValidator::validateIntRange(_descr, "intendedProcAmount", intendedProcAmount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "processorCurrency"); size_t szProcessorCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "processorCurrency", szProcessorCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY(Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, name(std::move(_o.name))
	, benficiary(std::move(_o.benficiary))
	, sccountNum(std::move(_o.sccountNum))
	, useReference(std::move(_o.useReference))
	, processorExtras(std::move(_o.processorExtras))
	, currency(std::move(_o.currency))
	, intendedProcAmount(std::move(_o.intendedProcAmount))
	, amount(std::move(_o.amount))
	, comment(std::move(_o.comment))
	, empty(std::move(_o.empty))
	, extraInfo(std::move(_o.extraInfo))
	, url(std::move(_o.url))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY::operator=(Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		name = std::move(_o.name);
		benficiary = std::move(_o.benficiary);
		sccountNum = std::move(_o.sccountNum);
		useReference = std::move(_o.useReference);
		processorExtras = std::move(_o.processorExtras);
		currency = std::move(_o.currency);
		intendedProcAmount = std::move(_o.intendedProcAmount);
		amount = std::move(_o.amount);
		comment = std::move(_o.comment);
		empty = std::move(_o.empty);
		extraInfo = std::move(_o.extraInfo);
		url = std::move(_o.url);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	name.clear();
	benficiary.clear();
	sccountNum.clear();
	useReference = false;
	processorExtras.clear();
	currency.clear();
	intendedProcAmount = 0;
	amount = 0;
	comment.clear();
	empty.clear();
	extraInfo.clear();
	url.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY::equals(const Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		name.equals(_o.name) &&
		benficiary.equals(_o.benficiary) &&
		sccountNum.equals(_o.sccountNum) &&
		useReference == _o.useReference &&
		processorExtras.equals(_o.processorExtras) &&
		currency.equals(_o.currency) &&
		intendedProcAmount == _o.intendedProcAmount &&
		amount == _o.amount &&
		comment.equals(_o.comment) &&
		empty.equals(_o.empty) &&
		extraInfo.equals(_o.extraInfo) &&
		url.equals(_o.url);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("name=");
		_buf.append(name);
		_buf.append(',');
		_buf.append("benficiary=");
		_buf.append(benficiary);
		_buf.append(',');
		_buf.append("sccountNum=");
		_buf.append(sccountNum);
		_buf.append(',');
		_buf.append("useReference=");
		_buf.appendUint(useReference);
		_buf.append(',');
		_buf.append("processorExtras=");
		_buf.append(processorExtras);
		_buf.append(',');
		_buf.append("currency=");
		_buf.append(currency);
		_buf.append(',');
		_buf.append("intendedProcAmount=");
		_buf.appendInt(intendedProcAmount);
		_buf.append(',');
		_buf.append("amount=");
		_buf.appendInt(amount);
		_buf.append(',');
		_buf.append("comment=");
		_buf.append(comment);
		_buf.append(',');
		_buf.append("empty=");
		_buf.append(empty);
		_buf.append(',');
		_buf.append("extraInfo=");
		_buf.append(extraInfo);
		_buf.append(',');
		_buf.append("url=");
		_buf.append(url);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(name);
		_msg.composeString(benficiary);
		_msg.composeString(sccountNum);
		_msg.composeBOOL(useReference);
		_msg.composeString(processorExtras);
		_msg.composeString(currency);
		_msg.composeINT32(intendedProcAmount);
		_msg.composeINT32(amount);
		_msg.composeString(comment);
		_msg.composeString(empty);
		_msg.composeString(extraInfo);
		_msg.composeString(url);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(name);
		_parser.parseStringP(benficiary);
		_parser.parseStringP(sccountNum);
		_parser.parseBOOL(useReference);
		_parser.parseStringP(processorExtras);
		_parser.parseStringP(currency);
		_parser.parseINT32(intendedProcAmount);
		_parser.parseINT32(amount);
		_parser.parseStringP(comment);
		_parser.parseStringP(empty);
		_parser.parseStringP(extraInfo);
		_parser.parseStringP(url);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "benficiary"); size_t szBenficiary = strlen(_dummy);
		AtfValidator::validateInt(_descr, "benficiary", szBenficiary, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "sccountNum"); size_t szSccountNum = strlen(_dummy);
		AtfValidator::validateInt(_descr, "sccountNum", szSccountNum, _checker, __FILE__, __LINE__);
		bool useReference; _parser.parseBOOL(useReference);
		AtfValidator::validateInt(_descr, "useReference", useReference, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "processorExtras"); size_t szProcessorExtras = strlen(_dummy);
		AtfValidator::validateInt(_descr, "processorExtras", szProcessorExtras, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
		INT32 intendedProcAmount; _parser.parseINT32(intendedProcAmount);
		AtfValidator::validateInt(_descr, "intendedProcAmount", intendedProcAmount, _checker, __FILE__, __LINE__);
		INT32 amount; _parser.parseINT32(amount);
		AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "comment"); size_t szComment = strlen(_dummy);
		AtfValidator::validateInt(_descr, "comment", szComment, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "empty"); size_t szEmpty = strlen(_dummy);
		AtfValidator::validateInt(_descr, "empty", szEmpty, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "extraInfo"); size_t szExtraInfo = strlen(_dummy);
		AtfValidator::validateInt(_descr, "extraInfo", szExtraInfo, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "url"); size_t szUrl = strlen(_dummy);
		AtfValidator::validateInt(_descr, "url", szUrl, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CONVRATES_SUBSET
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET::Protocol_MSG_CASHIER_CONVRATES_SUBSET()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET::Protocol_MSG_CASHIER_CONVRATES_SUBSET(Protocol_MSG_CASHIER_CONVRATES_SUBSET&& _o)
	: intActionType(std::move(_o.intActionType))
	, incomingCur(std::move(_o.incomingCur))
	, curIsSrcNotDst(std::move(_o.curIsSrcNotDst))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET& CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET::operator=(Protocol_MSG_CASHIER_CONVRATES_SUBSET&& _o)
{
	if(this != &_o)
	{
		intActionType = std::move(_o.intActionType);
		incomingCur = std::move(_o.incomingCur);
		curIsSrcNotDst = std::move(_o.curIsSrcNotDst);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET::clear()
{
	intActionType = 0;
	incomingCur.clear();
	curIsSrcNotDst = false;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET::equals(const Protocol_MSG_CASHIER_CONVRATES_SUBSET& _o) const
{
	return intActionType == _o.intActionType &&
		incomingCur.equals(_o.incomingCur) &&
		curIsSrcNotDst == _o.curIsSrcNotDst;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CONVRATES_SUBSET).append(")");
	_buf.append(',');
	_buf.append("intActionType=");
	_buf.appendUint(intActionType);
	_buf.append(',');
	_buf.append("incomingCur=");
	_buf.append(incomingCur);
	_buf.append(',');
	_buf.append("curIsSrcNotDst=");
	_buf.appendUint(curIsSrcNotDst);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(intActionType);
	_msg.composeString(incomingCur);
	_msg.composeBOOL(curIsSrcNotDst);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(intActionType);
	_parser.parseStringP(incomingCur);
	_parser.parseBOOL(curIsSrcNotDst);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CONVRATES_SUBSET";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 intActionType; _parser.parseUINT32(intActionType);
	AtfValidator::validateIntRange(_descr, "intActionType", intActionType, eConvActionDefault, eConvActionPoolBettingLast, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "incomingCur"); size_t szIncomingCur = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "incomingCur", szIncomingCur, 100, _checker, __FILE__, __LINE__);
	bool curIsSrcNotDst; _parser.parseBOOL(curIsSrcNotDst);
	AtfValidator::validateInt(_descr, "curIsSrcNotDst", curIsSrcNotDst, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierConvRateBody
//=================================================================

CashierServer::cli::CashierConvRateBody::CashierConvRateBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::CashierConvRateBody::CashierConvRateBody(CashierConvRateBody&& _o)
	: outgoingCur(std::move(_o.outgoingCur))
	, rateFin(std::move(_o.rateFin))
	, inverseRateFin(std::move(_o.inverseRateFin))
{
}

CashierServer::cli::CashierConvRateBody& CashierServer::cli::CashierConvRateBody::operator=(CashierConvRateBody&& _o)
{
	if(this != &_o)
	{
		outgoingCur = std::move(_o.outgoingCur);
		rateFin = std::move(_o.rateFin);
		inverseRateFin = std::move(_o.inverseRateFin);
	}
	return *this;
}

#endif

void CashierServer::cli::CashierConvRateBody::clear()
{
	outgoingCur.clear();
	rateFin = 0;
	inverseRateFin = 0;
}

bool CashierServer::cli::CashierConvRateBody::equals(const CashierConvRateBody& _o) const
{
	return outgoingCur.equals(_o.outgoingCur) &&
		rateFin == _o.rateFin &&
		inverseRateFin == _o.inverseRateFin;
}

const char *CashierServer::cli::CashierConvRateBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("outgoingCur=");
	_buf.append(outgoingCur);
	_buf.append(',');
	_buf.append("rateFin=");
	_buf.appendUint64(rateFin);
	_buf.append(',');
	_buf.append("inverseRateFin=");
	_buf.appendUint64(inverseRateFin);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashierConvRateBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CashierConvRateBody())) // not empty
	{
		_body.composeString(outgoingCur);
		_body.composeUINT64(rateFin);
		_body.composeUINT64(inverseRateFin);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierConvRateBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(outgoingCur);
	_parser0.parseUINT64(rateFin);
	_parser0.parseUINT64(inverseRateFin);
}

/*static*/ void CashierServer::cli::CashierConvRateBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "outgoingCur"); size_t szOutgoingCur = strlen(_dummy);
	AtfValidator::validateInt(_descr, "outgoingCur", szOutgoingCur, _checker, __FILE__, __LINE__);
	UINT64 rateFin; _parser0.parseUINT64(rateFin);
	AtfValidator::validateUint(_descr, "rateFin", rateFin, _checker, __FILE__, __LINE__);
	UINT64 inverseRateFin; _parser0.parseUINT64(inverseRateFin);
	AtfValidator::validateUint(_descr, "inverseRateFin", inverseRateFin, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_CONVRATES_SUBSET_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET_REPLY::Protocol_MSG_CASHIER_CONVRATES_SUBSET_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET_REPLY::Protocol_MSG_CASHIER_CONVRATES_SUBSET_REPLY(Protocol_MSG_CASHIER_CONVRATES_SUBSET_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, convRates(std::move(_o.convRates))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET_REPLY::operator=(Protocol_MSG_CASHIER_CONVRATES_SUBSET_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		convRates = std::move(_o.convRates);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	convRates.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET_REPLY::equals(const Protocol_MSG_CASHIER_CONVRATES_SUBSET_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		convRates.equals(_o.convRates);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CONVRATES_SUBSET_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("convRates=");
		convRates.toTraceString(_buf);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		convRates.composeMsg(_msg);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		convRates.parseMsg(_parser);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CONVRATES_SUBSET_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szConvRates = ThinAtf::LAtfVector< CashierConvRateBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("convRates"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "convRates", szConvRates, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT(Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT&& _o)
	: newDefaultCurrency(std::move(_o.newDefaultCurrency))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT& CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT::operator=(Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT&& _o)
{
	if(this != &_o)
	{
		newDefaultCurrency = std::move(_o.newDefaultCurrency);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT::clear()
{
	newDefaultCurrency.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT::equals(const Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT& _o) const
{
	return newDefaultCurrency.equals(_o.newDefaultCurrency);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_DEFAULT_ACCOUNT).append(")");
	_buf.append(',');
	_buf.append("newDefaultCurrency=");
	_buf.append(newDefaultCurrency);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(newDefaultCurrency);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(newDefaultCurrency);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_DEFAULT_ACCOUNT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "newDefaultCurrency"); size_t szNewDefaultCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "newDefaultCurrency", szNewDefaultCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY(Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY::operator=(Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY::equals(const Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT(Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT&& _o)
	: newCurrencyToAdd(std::move(_o.newCurrencyToAdd))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT& CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT::operator=(Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT&& _o)
{
	if(this != &_o)
	{
		newCurrencyToAdd = std::move(_o.newCurrencyToAdd);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT::clear()
{
	newCurrencyToAdd.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT::equals(const Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT& _o) const
{
	return newCurrencyToAdd.equals(_o.newCurrencyToAdd);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_NEW_CURRENCY_ACCOUNT).append(")");
	_buf.append(',');
	_buf.append("newCurrencyToAdd=");
	_buf.append(newCurrencyToAdd);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(newCurrencyToAdd);
}

void CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(newCurrencyToAdd);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_NEW_CURRENCY_ACCOUNT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "newCurrencyToAdd"); size_t szNewCurrencyToAdd = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "newCurrencyToAdd", szNewCurrencyToAdd, 100, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY(Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY::operator=(Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY::equals(const Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT(Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT&& _o)
	: currencyToDelete(std::move(_o.currencyToDelete))
	, disregradBonuses(std::move(_o.disregradBonuses))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT& CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT::operator=(Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT&& _o)
{
	if(this != &_o)
	{
		currencyToDelete = std::move(_o.currencyToDelete);
		disregradBonuses = std::move(_o.disregradBonuses);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT::clear()
{
	currencyToDelete.clear();
	disregradBonuses = false;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT::equals(const Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT& _o) const
{
	return currencyToDelete.equals(_o.currencyToDelete) &&
		disregradBonuses == _o.disregradBonuses;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_DELETE_CURRENCY_ACCOUNT).append(")");
	_buf.append(',');
	_buf.append("currencyToDelete=");
	_buf.append(currencyToDelete);
	_buf.append(',');
	_buf.append("disregradBonuses=");
	_buf.appendUint(disregradBonuses);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(currencyToDelete);
	_msg.composeBOOL(disregradBonuses);
}

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(currencyToDelete);
	_parser.parseBOOL(disregradBonuses);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_DELETE_CURRENCY_ACCOUNT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "currencyToDelete"); size_t szCurrencyToDelete = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currencyToDelete", szCurrencyToDelete, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	bool disregradBonuses; _parser.parseBOOL(disregradBonuses);
	AtfValidator::validateInt(_descr, "disregradBonuses", disregradBonuses, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY(Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY::operator=(Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY::equals(const Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    AccountTransferInfo
//=================================================================

CashierServer::cli::AccountTransferInfo::AccountTransferInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::AccountTransferInfo::AccountTransferInfo(AccountTransferInfo&& _o)
	: amountSrc(std::move(_o.amountSrc))
	, currencySrc(std::move(_o.currencySrc))
	, amountDst(std::move(_o.amountDst))
	, currencyDst(std::move(_o.currencyDst))
	, chipsType(std::move(_o.chipsType))
{
}

CashierServer::cli::AccountTransferInfo& CashierServer::cli::AccountTransferInfo::operator=(AccountTransferInfo&& _o)
{
	if(this != &_o)
	{
		amountSrc = std::move(_o.amountSrc);
		currencySrc = std::move(_o.currencySrc);
		amountDst = std::move(_o.amountDst);
		currencyDst = std::move(_o.currencyDst);
		chipsType = std::move(_o.chipsType);
	}
	return *this;
}

#endif

void CashierServer::cli::AccountTransferInfo::clear()
{
	amountSrc = 0;
	currencySrc.clear();
	amountDst = 0;
	currencyDst.clear();
	chipsType = 0;
}

bool CashierServer::cli::AccountTransferInfo::equals(const AccountTransferInfo& _o) const
{
	return amountSrc == _o.amountSrc &&
		currencySrc.equals(_o.currencySrc) &&
		amountDst == _o.amountDst &&
		currencyDst.equals(_o.currencyDst) &&
		chipsType == _o.chipsType;
}

const char *CashierServer::cli::AccountTransferInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("amountSrc=");
	_buf.appendInt(amountSrc);
	_buf.append(',');
	_buf.append("currencySrc=");
	_buf.append(currencySrc);
	_buf.append(',');
	_buf.append("amountDst=");
	_buf.appendInt(amountDst);
	_buf.append(',');
	_buf.append("currencyDst=");
	_buf.append(currencyDst);
	_buf.append(',');
	_buf.append("chipsType=");
	_buf.appendInt(chipsType);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::AccountTransferInfo::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(amountSrc);
	_msg.composeString(currencySrc);
	_msg.composeINT32(amountDst);
	_msg.composeString(currencyDst);
	_msg.composeINT32(chipsType);
}

void CashierServer::cli::AccountTransferInfo::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(amountSrc);
	_parser.parseStringP(currencySrc);
	_parser.parseINT32(amountDst);
	_parser.parseStringP(currencyDst);
	_parser.parseINT32(chipsType);
}

/*static*/ void CashierServer::cli::AccountTransferInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	INT32 amountSrc; _parser.parseINT32(amountSrc);
	AtfValidator::validateIntRange(_descr, "amountSrc", amountSrc, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currencySrc"); size_t szCurrencySrc = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currencySrc", szCurrencySrc, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	INT32 amountDst; _parser.parseINT32(amountDst);
	AtfValidator::validateIntRange(_descr, "amountDst", amountDst, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currencyDst"); size_t szCurrencyDst = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currencyDst", szCurrencyDst, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	INT32 chipsType; _parser.parseINT32(chipsType);
	{ const INT32 chipsType_enum[] = { REAL_CHIPS, PLAY_CHIPS, TOURN_CHIPS, BLITZ_REAL_CHIPS, BLITZ_PLAY_CHIPS, POKER_DUEL_CHIPS }; AtfValidator::validateEnum(_descr, "chipsType", chipsType, chipsType_enum, _checker, __FILE__, __LINE__); }
}

//=================================================================
//                Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER(Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER&& _o)
	: transfers(std::move(_o.transfers))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER& CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER::operator=(Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER&& _o)
{
	if(this != &_o)
	{
		transfers = std::move(_o.transfers);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER::clear()
{
	transfers.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER::equals(const Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER& _o) const
{
	return transfers.equals(_o.transfers);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER).append(")");
	_buf.append(',');
	_buf.append("transfers=");
	transfers.toTraceString(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER::composeMsg(CommMsgBody& _msg) const
{
	transfers.composeMsg(_msg);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER::parseMsg(CommMsgParser& _parser)
{
	transfers.parseMsg(_parser);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTransfers = ThinAtf::LAtfVector< AccountTransferInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("transfers"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "transfers", szTransfers, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY(Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY::operator=(Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY::equals(const Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_USER_PRIVS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS::Protocol_MSG_CASHIER_GET_USER_PRIVS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS::Protocol_MSG_CASHIER_GET_USER_PRIVS(Protocol_MSG_CASHIER_GET_USER_PRIVS&& _o)
	: unusedStr(std::move(_o.unusedStr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS& CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS::operator=(Protocol_MSG_CASHIER_GET_USER_PRIVS&& _o)
{
	if(this != &_o)
	{
		unusedStr = std::move(_o.unusedStr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS::clear()
{
	unusedStr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS::equals(const Protocol_MSG_CASHIER_GET_USER_PRIVS& _o) const
{
	return unusedStr.equals(_o.unusedStr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_USER_PRIVS).append(")");
	_buf.append(',');
	_buf.append("unusedStr=");
	_buf.append(unusedStr);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(unusedStr);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseStringP(unusedStr);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_USER_PRIVS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "unusedStr"); size_t szUnusedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "unusedStr", szUnusedStr, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierUserPrivs
//=================================================================

CashierServer::cli::CashierUserPrivs::CashierUserPrivs()
{
	clear();
}

void CashierServer::cli::CashierUserPrivs::clear()
{
	privs = 0;
	privs2 = 0;
	modelessCashierAllowedForUser = false;
	forceCashout = false;
	dummy = false;
	privs3 = 0;
}

bool CashierServer::cli::CashierUserPrivs::equals(const CashierUserPrivs& _o) const
{
	return privs == _o.privs &&
		privs2 == _o.privs2 &&
		modelessCashierAllowedForUser == _o.modelessCashierAllowedForUser &&
		forceCashout == _o.forceCashout &&
		dummy == _o.dummy &&
		privs3 == _o.privs3;
}

const char *CashierServer::cli::CashierUserPrivs::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("privs=");
	_buf.appendUint(privs);
	_buf.append(',');
	_buf.append("privs2=");
	_buf.appendUint64(privs2);
	_buf.append(',');
	_buf.append("modelessCashierAllowedForUser=");
	_buf.appendUint(modelessCashierAllowedForUser);
	_buf.append(',');
	_buf.append("forceCashout=");
	_buf.appendUint(forceCashout);
	_buf.append(',');
	_buf.append("dummy=");
	_buf.appendUint(dummy);
	_buf.append(',');
	_buf.append("privs3=");
	_buf.appendUint64(privs3);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashierUserPrivs::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(privs);
	_msg.composeUINT64(privs2);
	_msg.composeBOOL(modelessCashierAllowedForUser);
	_msg.composeBOOL(forceCashout);
	_msg.composeBOOL(dummy);
	_msg.composeUINT64(privs3);
}

void CashierServer::cli::CashierUserPrivs::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(privs);
	_parser.parseUINT64(privs2);
	_parser.parseBOOL(modelessCashierAllowedForUser);
	_parser.parseBOOL(forceCashout);
	_parser.parseBOOL(dummy);
	_parser.parseUINT64(privs3);
}

/*static*/ void CashierServer::cli::CashierUserPrivs::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 privs; _parser.parseUINT32(privs);
	AtfValidator::validateInt(_descr, "privs", privs, _checker, __FILE__, __LINE__);
	UINT64 privs2; _parser.parseUINT64(privs2);
	AtfValidator::validateUint(_descr, "privs2", privs2, _checker, __FILE__, __LINE__);
	bool modelessCashierAllowedForUser; _parser.parseBOOL(modelessCashierAllowedForUser);
	AtfValidator::validateInt(_descr, "modelessCashierAllowedForUser", modelessCashierAllowedForUser, _checker, __FILE__, __LINE__);
	bool forceCashout; _parser.parseBOOL(forceCashout);
	AtfValidator::validateInt(_descr, "forceCashout", forceCashout, _checker, __FILE__, __LINE__);
	bool dummy; _parser.parseBOOL(dummy);
	AtfValidator::validateInt(_descr, "dummy", dummy, _checker, __FILE__, __LINE__);
	UINT64 privs3; _parser.parseUINT64(privs3);
	AtfValidator::validateUint(_descr, "privs3", privs3, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_USER_PRIVS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_REPLY::Protocol_MSG_CASHIER_GET_USER_PRIVS_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_REPLY::clear()
{
	privs.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_REPLY::equals(const Protocol_MSG_CASHIER_GET_USER_PRIVS_REPLY& _o) const
{
	return privs.equals(_o.privs);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_USER_PRIVS_REPLY).append(")");
	_buf.append(',');
	_buf.append("privs=");
	privs.toTraceString(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	privs.composeMsg(_msg);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_REPLY::parseMsg(CommMsgParser& _parser)
{
	privs.parseMsg(_parser);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_USER_PRIVS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	CashierUserPrivs::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privs"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_USER_PRIVS_2
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2::Protocol_MSG_CASHIER_GET_USER_PRIVS_2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2::Protocol_MSG_CASHIER_GET_USER_PRIVS_2(Protocol_MSG_CASHIER_GET_USER_PRIVS_2&& _o)
	: unusedStr(std::move(_o.unusedStr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2& CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2::operator=(Protocol_MSG_CASHIER_GET_USER_PRIVS_2&& _o)
{
	if(this != &_o)
	{
		unusedStr = std::move(_o.unusedStr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2::clear()
{
	unusedStr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2::equals(const Protocol_MSG_CASHIER_GET_USER_PRIVS_2& _o) const
{
	return unusedStr.equals(_o.unusedStr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_USER_PRIVS_2).append(")");
	_buf.append(',');
	_buf.append("unusedStr=");
	_buf.append(unusedStr);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(unusedStr);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseStringP(unusedStr);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_USER_PRIVS_2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "unusedStr"); size_t szUnusedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "unusedStr", szUnusedStr, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_USER_PRIVS_2_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2_REPLY::Protocol_MSG_CASHIER_GET_USER_PRIVS_2_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2_REPLY::Protocol_MSG_CASHIER_GET_USER_PRIVS_2_REPLY(Protocol_MSG_CASHIER_GET_USER_PRIVS_2_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, privs(std::move(_o.privs))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2_REPLY::operator=(Protocol_MSG_CASHIER_GET_USER_PRIVS_2_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		privs = std::move(_o.privs);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	privs.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2_REPLY::equals(const Protocol_MSG_CASHIER_GET_USER_PRIVS_2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		privs.equals(_o.privs);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_USER_PRIVS_2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("privs=");
		privs.toTraceString(_buf);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		privs.composeMsg(_msg);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		privs.parseMsg(_parser);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_USER_PRIVS_2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		CashierUserPrivs::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privs"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_REAL_PRE_TRANSFER
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER(Protocol_MSG_CASHIER_REAL_PRE_TRANSFER&& _o)
	: userFrom(std::move(_o.userFrom))
	, userTo(std::move(_o.userTo))
	, amountFrom(std::move(_o.amountFrom))
	, currencyFrom(std::move(_o.currencyFrom))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER& CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER::operator=(Protocol_MSG_CASHIER_REAL_PRE_TRANSFER&& _o)
{
	if(this != &_o)
	{
		userFrom = std::move(_o.userFrom);
		userTo = std::move(_o.userTo);
		amountFrom = std::move(_o.amountFrom);
		currencyFrom = std::move(_o.currencyFrom);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER::clear()
{
	userFrom.clear();
	userTo.clear();
	amountFrom = 0;
	currencyFrom.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER::equals(const Protocol_MSG_CASHIER_REAL_PRE_TRANSFER& _o) const
{
	return userFrom.equals(_o.userFrom) &&
		userTo.equals(_o.userTo) &&
		amountFrom == _o.amountFrom &&
		currencyFrom.equals(_o.currencyFrom);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_REAL_PRE_TRANSFER).append(")");
	_buf.append(',');
	_buf.append("userFrom=");
	_buf.append(userFrom);
	_buf.append(',');
	_buf.append("userTo=");
	_buf.append(userTo);
	_buf.append(',');
	_buf.append("amountFrom=");
	_buf.appendInt(amountFrom);
	_buf.append(',');
	_buf.append("currencyFrom=");
	_buf.append(currencyFrom);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userFrom);
	_msg.composeString(userTo);
	_msg.composeINT32(amountFrom);
	_msg.composeString(currencyFrom);
}

void CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userFrom);
	_parser.parseStringP(userTo);
	_parser.parseINT32(amountFrom);
	_parser.parseStringP(currencyFrom);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_REAL_PRE_TRANSFER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userFrom"); size_t szUserFrom = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userFrom", szUserFrom, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userTo"); size_t szUserTo = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userTo", szUserTo, 1000, _checker, __FILE__, __LINE__);
	INT32 amountFrom; _parser.parseINT32(amountFrom);
	AtfValidator::validateIntRange(_descr, "amountFrom", amountFrom, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currencyFrom"); size_t szCurrencyFrom = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currencyFrom", szCurrencyFrom, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_REAL_PRE_TRANSFER_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER_REPLY::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER_REPLY::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER_REPLY(Protocol_MSG_CASHIER_REAL_PRE_TRANSFER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, userId(std::move(_o.userId))
	, city(std::move(_o.city))
	, country(std::move(_o.country))
	, showCity(std::move(_o.showCity))
	, imageId(std::move(_o.imageId))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER_REPLY::operator=(Protocol_MSG_CASHIER_REAL_PRE_TRANSFER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		userId = std::move(_o.userId);
		city = std::move(_o.city);
		country = std::move(_o.country);
		showCity = std::move(_o.showCity);
		imageId = std::move(_o.imageId);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	userId.clear();
	city.clear();
	country.clear();
	showCity = 0;
	imageId = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER_REPLY::equals(const Protocol_MSG_CASHIER_REAL_PRE_TRANSFER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		userId.equals(_o.userId) &&
		city.equals(_o.city) &&
		country.equals(_o.country) &&
		showCity == _o.showCity &&
		imageId == _o.imageId;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_REAL_PRE_TRANSFER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("userId=");
		_buf.append(userId);
		_buf.append(',');
		_buf.append("city=");
		_buf.append(city);
		_buf.append(',');
		_buf.append("country=");
		_buf.append(country);
		_buf.append(',');
		_buf.append("showCity=");
		_buf.appendUint(showCity);
		_buf.append(',');
		_buf.append("imageId=");
		_buf.appendUint(imageId);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(userId);
		_msg.composeString(city);
		_msg.composeString(country);
		_msg.composeBYTE(showCity);
		_msg.composeUINT32(imageId);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(userId);
		_parser.parseStringP(city);
		_parser.parseStringP(country);
		_parser.parseBYTE(showCity);
		_parser.parseUINT32(imageId);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_REAL_PRE_TRANSFER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
		AtfValidator::validateInt(_descr, "city", szCity, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
		AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
		BYTE showCity; _parser.parseBYTE(showCity);
		AtfValidator::validateIntRange(_descr, "showCity", showCity, 0, 1, _checker, __FILE__, __LINE__);
		UINT32 imageId; _parser.parseUINT32(imageId);
		AtfValidator::validateInt(_descr, "imageId", imageId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_REAL_TRANSFER
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER::Protocol_MSG_CASHIER_REAL_TRANSFER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER::Protocol_MSG_CASHIER_REAL_TRANSFER(Protocol_MSG_CASHIER_REAL_TRANSFER&& _o)
	: userFrom(std::move(_o.userFrom))
	, userTo(std::move(_o.userTo))
	, amountFrom(std::move(_o.amountFrom))
	, userComment(std::move(_o.userComment))
	, currencyFrom(std::move(_o.currencyFrom))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER& CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER::operator=(Protocol_MSG_CASHIER_REAL_TRANSFER&& _o)
{
	if(this != &_o)
	{
		userFrom = std::move(_o.userFrom);
		userTo = std::move(_o.userTo);
		amountFrom = std::move(_o.amountFrom);
		userComment = std::move(_o.userComment);
		currencyFrom = std::move(_o.currencyFrom);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER::clear()
{
	userFrom.clear();
	userTo.clear();
	amountFrom = 0;
	userComment.clear();
	currencyFrom.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER::equals(const Protocol_MSG_CASHIER_REAL_TRANSFER& _o) const
{
	return userFrom.equals(_o.userFrom) &&
		userTo.equals(_o.userTo) &&
		amountFrom == _o.amountFrom &&
		userComment.equals(_o.userComment) &&
		currencyFrom.equals(_o.currencyFrom);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_REAL_TRANSFER).append(")");
	_buf.append(',');
	_buf.append("userFrom=");
	_buf.append(userFrom);
	_buf.append(',');
	_buf.append("userTo=");
	_buf.append(userTo);
	_buf.append(',');
	_buf.append("amountFrom=");
	_buf.appendInt(amountFrom);
	_buf.append(',');
	_buf.append("userComment=");
	_buf.append(userComment);
	_buf.append(',');
	_buf.append("currencyFrom=");
	_buf.append(currencyFrom);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userFrom);
	_msg.composeString(userTo);
	_msg.composeINT32(amountFrom);
	_msg.composeString(userComment);
	_msg.composeString(currencyFrom);
}

void CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userFrom);
	_parser.parseStringP(userTo);
	_parser.parseINT32(amountFrom);
	_parser.parseStringP(userComment);
	_parser.parseStringP(currencyFrom);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_REAL_TRANSFER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userFrom"); size_t szUserFrom = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userFrom", szUserFrom, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userTo"); size_t szUserTo = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userTo", szUserTo, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	INT32 amountFrom; _parser.parseINT32(amountFrom);
	AtfValidator::validateIntRange(_descr, "amountFrom", amountFrom, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userComment"); size_t szUserComment = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userComment", szUserComment, 4000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currencyFrom"); size_t szCurrencyFrom = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currencyFrom", szCurrencyFrom, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_REAL_TRANSFER_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER_REPLY::Protocol_MSG_CASHIER_REAL_TRANSFER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER_REPLY::Protocol_MSG_CASHIER_REAL_TRANSFER_REPLY(Protocol_MSG_CASHIER_REAL_TRANSFER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER_REPLY::operator=(Protocol_MSG_CASHIER_REAL_TRANSFER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER_REPLY::equals(const Protocol_MSG_CASHIER_REAL_TRANSFER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_REAL_TRANSFER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_REAL_TRANSFER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_REAL_TRANSFER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierRedeemAccountData
//=================================================================

CashierServer::cli::CashierRedeemAccountData::CashierRedeemAccountData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::CashierRedeemAccountData::CashierRedeemAccountData(CashierRedeemAccountData&& _o)
	: name(std::move(_o.name))
	, acct(std::move(_o.acct))
{
}

CashierServer::cli::CashierRedeemAccountData& CashierServer::cli::CashierRedeemAccountData::operator=(CashierRedeemAccountData&& _o)
{
	if(this != &_o)
	{
		name = std::move(_o.name);
		acct = std::move(_o.acct);
	}
	return *this;
}

#endif

void CashierServer::cli::CashierRedeemAccountData::clear()
{
	name.clear();
	acct.clear();
}

bool CashierServer::cli::CashierRedeemAccountData::equals(const CashierRedeemAccountData& _o) const
{
	return name.equals(_o.name) &&
		acct.equals(_o.acct);
}

const char *CashierServer::cli::CashierRedeemAccountData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("acct=");
	_buf.append(acct);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashierRedeemAccountData::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(name);
	_msg.composeString(acct);
}

void CashierServer::cli::CashierRedeemAccountData::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(name);
	_parser.parseStringP(acct);
}

/*static*/ void CashierServer::cli::CashierRedeemAccountData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "name", szName, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "acct"); size_t szAcct = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "acct", szAcct, 100, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT(Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT&& _o)
	: paysystemByte(std::move(_o.paysystemByte))
	, accounts(std::move(_o.accounts))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT& CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT::operator=(Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT&& _o)
{
	if(this != &_o)
	{
		paysystemByte = std::move(_o.paysystemByte);
		accounts = std::move(_o.accounts);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT::clear()
{
	paysystemByte = 0;
	accounts.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT::equals(const Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT& _o) const
{
	return paysystemByte == _o.paysystemByte &&
		accounts.equals(_o.accounts);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CREATE_REDEEM_ACCOUNT).append(")");
	_buf.append(',');
	_buf.append("paysystemByte=");
	_buf.appendUint(paysystemByte);
	_buf.append(',');
	_buf.append("accounts=");
	accounts.toTraceString(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(paysystemByte);
	accounts.composeMsg(_msg);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(paysystemByte);
	accounts.parseMsg(_parser);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CREATE_REDEEM_ACCOUNT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE paysystemByte; _parser.parseBYTE(paysystemByte);
	AtfValidator::validateIntRange(_descr, "paysystemByte", paysystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szAccounts = ThinAtf::LAtfVector< CashierRedeemAccountData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("accounts"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "accounts", szAccounts, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY(Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY::operator=(Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY::equals(const Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION(Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION&& _o)
	: userId(std::move(_o.userId))
	, paysystemByte(std::move(_o.paysystemByte))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION& CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION::operator=(Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		paysystemByte = std::move(_o.paysystemByte);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION::clear()
{
	userId.clear();
	paysystemByte = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION::equals(const Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION& _o) const
{
	return userId.equals(_o.userId) &&
		paysystemByte == _o.paysystemByte;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_USER_ACCT_PROC_REGISTRATION).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("paysystemByte=");
	_buf.appendUint(paysystemByte);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeBYTE(paysystemByte);
}

void CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseBYTE(paysystemByte);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_USER_ACCT_PROC_REGISTRATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	BYTE paysystemByte; _parser.parseBYTE(paysystemByte);
	AtfValidator::validateIntRange(_descr, "paysystemByte", paysystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY(Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY::operator=(Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY::equals(const Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CHECK_PLI
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI::Protocol_MSG_CASHIER_CHECK_PLI()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI::Protocol_MSG_CASHIER_CHECK_PLI(Protocol_MSG_CASHIER_CHECK_PLI&& _o)
	: paySystemByte(std::move(_o.paySystemByte))
	, accountCurrency(std::move(_o.accountCurrency))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI& CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI::operator=(Protocol_MSG_CASHIER_CHECK_PLI&& _o)
{
	if(this != &_o)
	{
		paySystemByte = std::move(_o.paySystemByte);
		accountCurrency = std::move(_o.accountCurrency);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI::clear()
{
	paySystemByte = 0;
	accountCurrency.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI::equals(const Protocol_MSG_CASHIER_CHECK_PLI& _o) const
{
	return paySystemByte == _o.paySystemByte &&
		accountCurrency.equals(_o.accountCurrency);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CHECK_PLI).append(")");
	_buf.append(',');
	_buf.append("paySystemByte=");
	_buf.appendUint(paySystemByte);
	_buf.append(',');
	_buf.append("accountCurrency=");
	_buf.append(accountCurrency);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(paySystemByte);
	_msg.composeString(accountCurrency);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(paySystemByte);
	_parser.parseStringP(accountCurrency);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CHECK_PLI";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE paySystemByte; _parser.parseBYTE(paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "accountCurrency"); size_t szAccountCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "accountCurrency", szAccountCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CHECK_PLI_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI_REPLY::Protocol_MSG_CASHIER_CHECK_PLI_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI_REPLY::Protocol_MSG_CASHIER_CHECK_PLI_REPLY(Protocol_MSG_CASHIER_CHECK_PLI_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, cardTypeByte(std::move(_o.cardTypeByte))
	, minDepositInCur(std::move(_o.minDepositInCur))
	, maxCashinDaily(std::move(_o.maxCashinDaily))
	, maxCashinWeekly(std::move(_o.maxCashinWeekly))
	, maxCashinMonthly(std::move(_o.maxCashinMonthly))
	, levelId(std::move(_o.levelId))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI_REPLY::operator=(Protocol_MSG_CASHIER_CHECK_PLI_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		cardTypeByte = std::move(_o.cardTypeByte);
		minDepositInCur = std::move(_o.minDepositInCur);
		maxCashinDaily = std::move(_o.maxCashinDaily);
		maxCashinWeekly = std::move(_o.maxCashinWeekly);
		maxCashinMonthly = std::move(_o.maxCashinMonthly);
		levelId = std::move(_o.levelId);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	cardTypeByte = 0;
	minDepositInCur = 0;
	maxCashinDaily = 0;
	maxCashinWeekly = 0;
	maxCashinMonthly = 0;
	levelId = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI_REPLY::equals(const Protocol_MSG_CASHIER_CHECK_PLI_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		cardTypeByte == _o.cardTypeByte &&
		minDepositInCur == _o.minDepositInCur &&
		maxCashinDaily == _o.maxCashinDaily &&
		maxCashinWeekly == _o.maxCashinWeekly &&
		maxCashinMonthly == _o.maxCashinMonthly &&
		levelId == _o.levelId;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CHECK_PLI_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("cardTypeByte=");
		_buf.appendUint(cardTypeByte);
		_buf.append(',');
		_buf.append("minDepositInCur=");
		_buf.appendInt(minDepositInCur);
		_buf.append(',');
		_buf.append("maxCashinDaily=");
		_buf.appendInt(maxCashinDaily);
		_buf.append(',');
		_buf.append("maxCashinWeekly=");
		_buf.appendInt(maxCashinWeekly);
		_buf.append(',');
		_buf.append("maxCashinMonthly=");
		_buf.appendInt(maxCashinMonthly);
		_buf.append(',');
		_buf.append("levelId=");
		_buf.appendUint(levelId);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeBYTE(cardTypeByte);
		_msg.composeINT32(minDepositInCur);
		_msg.composeINT32(maxCashinDaily);
		_msg.composeINT32(maxCashinWeekly);
		_msg.composeINT32(maxCashinMonthly);
		_msg.composeUINT32(levelId);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseBYTE(cardTypeByte);
		_parser.parseINT32(minDepositInCur);
		_parser.parseINT32(maxCashinDaily);
		_parser.parseINT32(maxCashinWeekly);
		_parser.parseINT32(maxCashinMonthly);
		_parser.parseUINT32(levelId);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CHECK_PLI_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CHECK_PLI_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		BYTE cardTypeByte; _parser.parseBYTE(cardTypeByte);
		AtfValidator::validateInt(_descr, "cardTypeByte", cardTypeByte, _checker, __FILE__, __LINE__);
		INT32 minDepositInCur; _parser.parseINT32(minDepositInCur);
		AtfValidator::validateInt(_descr, "minDepositInCur", minDepositInCur, _checker, __FILE__, __LINE__);
		INT32 maxCashinDaily; _parser.parseINT32(maxCashinDaily);
		AtfValidator::validateInt(_descr, "maxCashinDaily", maxCashinDaily, _checker, __FILE__, __LINE__);
		INT32 maxCashinWeekly; _parser.parseINT32(maxCashinWeekly);
		AtfValidator::validateInt(_descr, "maxCashinWeekly", maxCashinWeekly, _checker, __FILE__, __LINE__);
		INT32 maxCashinMonthly; _parser.parseINT32(maxCashinMonthly);
		AtfValidator::validateInt(_descr, "maxCashinMonthly", maxCashinMonthly, _checker, __FILE__, __LINE__);
		UINT32 levelId; _parser.parseUINT32(levelId);
		AtfValidator::validateInt(_descr, "levelId", levelId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_INCREASE_PLI
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI::Protocol_MSG_CASHIER_INCREASE_PLI()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI::clear()
{
	paySystemByte = 0;
	nextLevelId = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI::equals(const Protocol_MSG_CASHIER_INCREASE_PLI& _o) const
{
	return paySystemByte == _o.paySystemByte &&
		nextLevelId == _o.nextLevelId;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_INCREASE_PLI).append(")");
	_buf.append(',');
	_buf.append("paySystemByte=");
	_buf.appendUint(paySystemByte);
	_buf.append(',');
	_buf.append("nextLevelId=");
	_buf.appendUint(nextLevelId);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(paySystemByte);
	_msg.composeUINT32(nextLevelId);
}

void CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(paySystemByte);
	_parser.parseUINT32(nextLevelId);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_INCREASE_PLI";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE paySystemByte; _parser.parseBYTE(paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	UINT32 nextLevelId; _parser.parseUINT32(nextLevelId);
	AtfValidator::validateInt(_descr, "nextLevelId", nextLevelId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_INCREASE_PLI_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI_REPLY::Protocol_MSG_CASHIER_INCREASE_PLI_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI_REPLY::Protocol_MSG_CASHIER_INCREASE_PLI_REPLY(Protocol_MSG_CASHIER_INCREASE_PLI_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI_REPLY::operator=(Protocol_MSG_CASHIER_INCREASE_PLI_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI_REPLY::equals(const Protocol_MSG_CASHIER_INCREASE_PLI_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_INCREASE_PLI_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_INCREASE_PLI_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_INCREASE_PLI_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SEND_USER_DOCS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS::Protocol_MSG_CASHIER_SEND_USER_DOCS()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS::clear()
{
	paySystemByte = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS::equals(const Protocol_MSG_CASHIER_SEND_USER_DOCS& _o) const
{
	return paySystemByte == _o.paySystemByte;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SEND_USER_DOCS).append(")");
	_buf.append(',');
	_buf.append("paySystemByte=");
	_buf.appendUint(paySystemByte);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(paySystemByte);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(paySystemByte);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SEND_USER_DOCS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE paySystemByte; _parser.parseBYTE(paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SEND_USER_DOCS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS_REPLY::Protocol_MSG_CASHIER_SEND_USER_DOCS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS_REPLY::Protocol_MSG_CASHIER_SEND_USER_DOCS_REPLY(Protocol_MSG_CASHIER_SEND_USER_DOCS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, data(std::move(_o.data))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS_REPLY::operator=(Protocol_MSG_CASHIER_SEND_USER_DOCS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		data = std::move(_o.data);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	data.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS_REPLY::equals(const Protocol_MSG_CASHIER_SEND_USER_DOCS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		data.size() == _o.data.size() && memcmp(data.ptr(), _o.data.ptr(), data.size()) == 0;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SEND_USER_DOCS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("data=");
		ThinAtf::AtfTempl<PBlock>::ToTraceString(_buf, data);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg._composeVarBlock(data.ptr(), data.size());
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parsePBlock(data);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SEND_USER_DOCS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SEND_USER_DOCS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		const BYTE* data; size_t szData; _parser._parseVarBlock(data, szData);  /*data*/
		AtfValidator::validateInt(_descr, "data", szData, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS(Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS&& _o)
	: paySystemBytes(std::move(_o.paySystemBytes))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS& CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS::operator=(Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS&& _o)
{
	if(this != &_o)
	{
		paySystemBytes = std::move(_o.paySystemBytes);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS::clear()
{
	paySystemBytes.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS::equals(const Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS& _o) const
{
	return paySystemBytes.equals(_o.paySystemBytes);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PAYSYSTEMS_LIMITS).append(")");
	_buf.append(',');
	_buf.append("paySystemBytes=");
	paySystemBytes.toTraceString(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS::composeMsg(CommMsgBody& _msg) const
{
	paySystemBytes.composeMsg(_msg);
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS::parseMsg(CommMsgParser& _parser)
{
	paySystemBytes.parseMsg(_parser);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PAYSYSTEMS_LIMITS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szPaySystemBytes = ThinAtf::LAtfVector< BYTE, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("paySystemBytes"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "paySystemBytes", szPaySystemBytes, 2000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    PaysystemLimit2Body
//=================================================================

CashierServer::cli::PaysystemLimit2Body::PaysystemLimit2Body()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::PaysystemLimit2Body::PaysystemLimit2Body(PaysystemLimit2Body&& _o)
	: currency(std::move(_o.currency))
	, limit(std::move(_o.limit))
{
}

CashierServer::cli::PaysystemLimit2Body& CashierServer::cli::PaysystemLimit2Body::operator=(PaysystemLimit2Body&& _o)
{
	if(this != &_o)
	{
		currency = std::move(_o.currency);
		limit = std::move(_o.limit);
	}
	return *this;
}

#endif

void CashierServer::cli::PaysystemLimit2Body::clear()
{
	currency.clear();
	limit.clear();
}

bool CashierServer::cli::PaysystemLimit2Body::equals(const PaysystemLimit2Body& _o) const
{
	return currency.equals(_o.currency) &&
		limit.equals(_o.limit);
}

const char *CashierServer::cli::PaysystemLimit2Body::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("limit=");
	limit.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::PaysystemLimit2Body::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(PaysystemLimit2Body())) // not empty
	{
		_body.composeString(currency);
		limit.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::PaysystemLimit2Body::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(currency);
	limit.parseMsg(_parser0);
}

/*static*/ void CashierServer::cli::PaysystemLimit2Body::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	PString _descbuf;
	common_structs::PaysystemLimit::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("limit"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY(Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, limits(std::move(_o.limits))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY::operator=(Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		limits = std::move(_o.limits);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	limits.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY::equals(const Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		limits.equals(_o.limits);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("limits=");
		limits.toTraceString(_buf);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		limits.composeMsg(_msg);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		limits.parseMsg(_parser);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szLimits = ThinAtf::LAtfVector< PaysystemLimit2Body, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("limits"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "limits", szLimits, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS::equals(const Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS& _o) const
{
	return true;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CONVERT_ALL_ASSETS).append(")");
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS::composeMsg(CommMsgBody& _msg) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CONVERT_ALL_ASSETS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    UserAllAssetsOneBody
//=================================================================

CashierServer::cli::UserAllAssetsOneBody::UserAllAssetsOneBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::UserAllAssetsOneBody::UserAllAssetsOneBody(UserAllAssetsOneBody&& _o)
	: assetType(std::move(_o.assetType))
	, typedAmount(std::move(_o.typedAmount))
	, currency(std::move(_o.currency))
	, chipsDst(std::move(_o.chipsDst))
	, convRate(std::move(_o.convRate))
{
}

CashierServer::cli::UserAllAssetsOneBody& CashierServer::cli::UserAllAssetsOneBody::operator=(UserAllAssetsOneBody&& _o)
{
	if(this != &_o)
	{
		assetType = std::move(_o.assetType);
		typedAmount = std::move(_o.typedAmount);
		currency = std::move(_o.currency);
		chipsDst = std::move(_o.chipsDst);
		convRate = std::move(_o.convRate);
	}
	return *this;
}

#endif

void CashierServer::cli::UserAllAssetsOneBody::clear()
{
	assetType = 0;
	typedAmount = 0;
	currency.clear();
	chipsDst = 0;
	convRate = 0;
}

bool CashierServer::cli::UserAllAssetsOneBody::equals(const UserAllAssetsOneBody& _o) const
{
	return assetType == _o.assetType &&
		typedAmount == _o.typedAmount &&
		currency.equals(_o.currency) &&
		chipsDst == _o.chipsDst &&
		convRate == _o.convRate;
}

const char *CashierServer::cli::UserAllAssetsOneBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("assetType=");
	_buf.appendInt(assetType);
	_buf.append(',');
	_buf.append("typedAmount=");
	_buf.appendInt(typedAmount);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("chipsDst=");
	_buf.appendInt(chipsDst);
	_buf.append(',');
	_buf.append("convRate=");
	_buf.appendUint64(convRate);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::UserAllAssetsOneBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(UserAllAssetsOneBody())) // not empty
	{
		_body.composeINT32(assetType);
		_body.composeINT32(typedAmount);
		_body.composeString(currency);
		_body.composeINT32(chipsDst);
		_body.composeUINT64(convRate);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::UserAllAssetsOneBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(assetType);
	_parser0.parseINT32(typedAmount);
	_parser0.parseStringP(currency);
	_parser0.parseINT32(chipsDst);
	_parser0.parseUINT64(convRate);
}

/*static*/ void CashierServer::cli::UserAllAssetsOneBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	INT32 assetType; _parser0.parseINT32(assetType);
	AtfValidator::validateInt(_descr, "assetType", assetType, _checker, __FILE__, __LINE__);
	INT32 typedAmount; _parser0.parseINT32(typedAmount);
	AtfValidator::validateInt(_descr, "typedAmount", typedAmount, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT32 chipsDst; _parser0.parseINT32(chipsDst);
	AtfValidator::validateInt(_descr, "chipsDst", chipsDst, _checker, __FILE__, __LINE__);
	UINT64 convRate; _parser0.parseUINT64(convRate);
	AtfValidator::validateUint(_descr, "convRate", convRate, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    UserAllAssets
//=================================================================

CashierServer::cli::UserAllAssets::UserAllAssets()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::UserAllAssets::UserAllAssets(UserAllAssets&& _o)
	: availDst(std::move(_o.availDst))
	, currencyDst(std::move(_o.currencyDst))
	, assets(std::move(_o.assets))
{
}

CashierServer::cli::UserAllAssets& CashierServer::cli::UserAllAssets::operator=(UserAllAssets&& _o)
{
	if(this != &_o)
	{
		availDst = std::move(_o.availDst);
		currencyDst = std::move(_o.currencyDst);
		assets = std::move(_o.assets);
	}
	return *this;
}

#endif

void CashierServer::cli::UserAllAssets::clear()
{
	availDst = 0;
	currencyDst.clear();
	assets.clear();
}

bool CashierServer::cli::UserAllAssets::equals(const UserAllAssets& _o) const
{
	return availDst == _o.availDst &&
		currencyDst.equals(_o.currencyDst) &&
		assets.equals(_o.assets);
}

const char *CashierServer::cli::UserAllAssets::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("availDst=");
	_buf.appendInt(availDst);
	_buf.append(',');
	_buf.append("currencyDst=");
	_buf.append(currencyDst);
	_buf.append(',');
	_buf.append("assets=");
	assets.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::UserAllAssets::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(availDst);
	_msg.composeString(currencyDst);
	assets.composeMsg(_msg);
}

void CashierServer::cli::UserAllAssets::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(availDst);
	_parser.parseStringP(currencyDst);
	assets.parseMsg(_parser);
}

/*static*/ void CashierServer::cli::UserAllAssets::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	INT32 availDst; _parser.parseINT32(availDst);
	AtfValidator::validateInt(_descr, "availDst", availDst, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currencyDst"); size_t szCurrencyDst = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currencyDst", szCurrencyDst, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szAssets = ThinAtf::LAtfVector< UserAllAssetsOneBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("assets"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "assets", szAssets, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY(Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, allAssets(std::move(_o.allAssets))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY::operator=(Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		allAssets = std::move(_o.allAssets);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	allAssets.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY::equals(const Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		allAssets.equals(_o.allAssets);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("allAssets=");
		allAssets.toTraceString(_buf);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		allAssets.composeMsg(_msg);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		allAssets.parseMsg(_parser);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		UserAllAssets::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("allAssets"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT(Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT&& _o)
	: unusedStr(std::move(_o.unusedStr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT& CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT::operator=(Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT&& _o)
{
	if(this != &_o)
	{
		unusedStr = std::move(_o.unusedStr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT::clear()
{
	unusedStr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT::equals(const Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT& _o) const
{
	return unusedStr.equals(_o.unusedStr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_RMF_BANKACCOUNT).append(")");
	_buf.append(',');
	_buf.append("unusedStr=");
	_buf.append(unusedStr);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(unusedStr);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseStringP(unusedStr);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_RMF_BANKACCOUNT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "unusedStr"); size_t szUnusedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "unusedStr", szUnusedStr, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY(Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, bankName(std::move(_o.bankName))
	, accountNumberDecrypted(std::move(_o.accountNumberDecrypted))
	, isValid(std::move(_o.isValid))
	, bankCountry(std::move(_o.bankCountry))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY::operator=(Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		bankName = std::move(_o.bankName);
		accountNumberDecrypted = std::move(_o.accountNumberDecrypted);
		isValid = std::move(_o.isValid);
		bankCountry = std::move(_o.bankCountry);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	bankName.clear();
	accountNumberDecrypted.clear();
	isValid = false;
	bankCountry.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY::equals(const Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		bankName.equals(_o.bankName) &&
		accountNumberDecrypted.equals(_o.accountNumberDecrypted) &&
		isValid == _o.isValid &&
		bankCountry.equals(_o.bankCountry);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("bankName=");
		_buf.append(bankName);
		_buf.append(',');
		_buf.append("accountNumberDecrypted=");
		_buf.append(accountNumberDecrypted);
		_buf.append(',');
		_buf.append("isValid=");
		_buf.appendUint(isValid);
		_buf.append(',');
		_buf.append("bankCountry=");
		_buf.append(bankCountry);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(bankName);
		_msg.composeString(accountNumberDecrypted);
		_msg.composeBOOL(isValid);
		_msg.composeString(bankCountry);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(bankName);
		_parser.parseStringP(accountNumberDecrypted);
		_parser.parseBOOL(isValid);
		_parser.parseStringP(bankCountry);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "bankName"); size_t szBankName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "bankName", szBankName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "accountNumberDecrypted"); size_t szAccountNumberDecrypted = strlen(_dummy);
		AtfValidator::validateInt(_descr, "accountNumberDecrypted", szAccountNumberDecrypted, _checker, __FILE__, __LINE__);
		bool isValid; _parser.parseBOOL(isValid);
		AtfValidator::validateInt(_descr, "isValid", isValid, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "bankCountry"); size_t szBankCountry = strlen(_dummy);
		AtfValidator::validateInt(_descr, "bankCountry", szBankCountry, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT(Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT&& _o)
	: bankName(std::move(_o.bankName))
	, accountNumberDecrypted(std::move(_o.accountNumberDecrypted))
	, bankCountry(std::move(_o.bankCountry))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT& CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::operator=(Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT&& _o)
{
	if(this != &_o)
	{
		bankName = std::move(_o.bankName);
		accountNumberDecrypted = std::move(_o.accountNumberDecrypted);
		bankCountry = std::move(_o.bankCountry);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::clear()
{
	bankName.clear();
	accountNumberDecrypted.clear();
	bankCountry.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::equals(const Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT& _o) const
{
	return bankName.equals(_o.bankName) &&
		accountNumberDecrypted.equals(_o.accountNumberDecrypted) &&
		bankCountry.equals(_o.bankCountry);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_RMF_BANKACCOUNT).append(")");
	_buf.append(',');
	_buf.append("bankName=");
	_buf.append(bankName);
	_buf.append(',');
	_buf.append("accountNumberDecrypted=");
	_buf.append(accountNumberDecrypted);
	_buf.append(',');
	_buf.append("bankCountry=");
	_buf.append(bankCountry);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(bankName);
	_msg.composeString(accountNumberDecrypted);
	_msg.composeString(bankCountry);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(bankName);
	_parser.parseStringP(accountNumberDecrypted);
	_parser.parseStringP(bankCountry);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_RMF_BANKACCOUNT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "bankName"); size_t szBankName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bankName", szBankName, 1000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "accountNumberDecrypted"); size_t szAccountNumberDecrypted = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "accountNumberDecrypted", szAccountNumberDecrypted, 1000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "bankCountry"); size_t szBankCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bankCountry", szBankCountry, 100, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY(Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, reference(std::move(_o.reference))
	, isValid(std::move(_o.isValid))
	, realMoneyOk(std::move(_o.realMoneyOk))
	, accountNumberDecrypted(std::move(_o.accountNumberDecrypted))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::operator=(Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		reference = std::move(_o.reference);
		isValid = std::move(_o.isValid);
		realMoneyOk = std::move(_o.realMoneyOk);
		accountNumberDecrypted = std::move(_o.accountNumberDecrypted);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	reference.clear();
	isValid = false;
	realMoneyOk = 0;
	accountNumberDecrypted.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::equals(const Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		reference.equals(_o.reference) &&
		isValid == _o.isValid &&
		realMoneyOk == _o.realMoneyOk &&
		accountNumberDecrypted.equals(_o.accountNumberDecrypted);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("reference=");
		_buf.append(reference);
		_buf.append(',');
		_buf.append("isValid=");
		_buf.appendUint(isValid);
		_buf.append(',');
		_buf.append("realMoneyOk=");
		_buf.appendUint(realMoneyOk);
		_buf.append(',');
		_buf.append("accountNumberDecrypted=");
		_buf.append(accountNumberDecrypted);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(reference);
		_msg.composeBOOL(isValid);
		CommMsgBody _msg0;
		_msg0.composeBYTE(realMoneyOk);
		_msg0.composeString(accountNumberDecrypted);
		_msg.composeMsgBody(_msg0);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(reference);
		_parser.parseBOOL(isValid);
		parseAnonymousMsgBody0(_parser);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "reference"); size_t szReference = strlen(_dummy);
		AtfValidator::validateInt(_descr, "reference", szReference, _checker, __FILE__, __LINE__);
		bool isValid; _parser.parseBOOL(isValid);
		AtfValidator::validateInt(_descr, "isValid", isValid, _checker, __FILE__, __LINE__);
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(realMoneyOk);
	_parser0.parseStringP(accountNumberDecrypted);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	BYTE realMoneyOk; _parser0.parseBYTE(realMoneyOk);
	AtfValidator::validateIntRange(_descr, "realMoneyOk", realMoneyOk, 0, 1, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "accountNumberDecrypted"); size_t szAccountNumberDecrypted = strlen(_dummy);
	AtfValidator::validateInt(_descr, "accountNumberDecrypted", szAccountNumberDecrypted, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_SPENDING_LIMIT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT::equals(const Protocol_MSG_CASHIER_GET_SPENDING_LIMIT& _o) const
{
	return true;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_SPENDING_LIMIT).append(")");
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT::composeMsg(CommMsgBody& _msg) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_SPENDING_LIMIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_SPENDING_LIMIT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT_REPLY::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT_REPLY::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT_REPLY(Protocol_MSG_CASHIER_GET_SPENDING_LIMIT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, spendingLimitOUT(std::move(_o.spendingLimitOUT))
	, availForSpending(std::move(_o.availForSpending))
	, totalBalance(std::move(_o.totalBalance))
	, limitsArray(std::move(_o.limitsArray))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT_REPLY::operator=(Protocol_MSG_CASHIER_GET_SPENDING_LIMIT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		spendingLimitOUT = std::move(_o.spendingLimitOUT);
		availForSpending = std::move(_o.availForSpending);
		totalBalance = std::move(_o.totalBalance);
		limitsArray = std::move(_o.limitsArray);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	spendingLimitOUT = 0;
	availForSpending = 0;
	totalBalance = 0;
	limitsArray.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT_REPLY::equals(const Protocol_MSG_CASHIER_GET_SPENDING_LIMIT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		spendingLimitOUT == _o.spendingLimitOUT &&
		availForSpending == _o.availForSpending &&
		totalBalance == _o.totalBalance &&
		limitsArray.equals(_o.limitsArray);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_SPENDING_LIMIT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("spendingLimitOUT=");
		_buf.appendInt(spendingLimitOUT);
		_buf.append(',');
		_buf.append("availForSpending=");
		_buf.appendInt(availForSpending);
		_buf.append(',');
		_buf.append("totalBalance=");
		_buf.appendInt(totalBalance);
		_buf.append(',');
		_buf.append("limitsArray=");
		limitsArray.toTraceString(_buf);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(spendingLimitOUT);
		_msg.composeINT32(availForSpending);
		_msg.composeINT32(totalBalance);
		limitsArray.composeMsg(_msg);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(spendingLimitOUT);
		_parser.parseINT32(availForSpending);
		_parser.parseINT32(totalBalance);
		limitsArray.parseMsg(_parser);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_SPENDING_LIMIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 spendingLimitOUT; _parser.parseINT32(spendingLimitOUT);
		AtfValidator::validateInt(_descr, "spendingLimitOUT", spendingLimitOUT, _checker, __FILE__, __LINE__);
		INT32 availForSpending; _parser.parseINT32(availForSpending);
		AtfValidator::validateInt(_descr, "availForSpending", availForSpending, _checker, __FILE__, __LINE__);
		INT32 totalBalance; _parser.parseINT32(totalBalance);
		AtfValidator::validateInt(_descr, "totalBalance", totalBalance, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szLimitsArray = ThinAtf::LAtfVector< INT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("limitsArray"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "limitsArray", szLimitsArray, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_SPENDING_LIMIT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT::clear()
{
	spendingLimit = 0;
	flags_ignored = 0;
	flags2_ignored = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT::equals(const Protocol_MSG_CASHIER_SET_SPENDING_LIMIT& _o) const
{
	return spendingLimit == _o.spendingLimit &&
		flags_ignored == _o.flags_ignored &&
		flags2_ignored == _o.flags2_ignored;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_SPENDING_LIMIT).append(")");
	_buf.append(',');
	_buf.append("spendingLimit=");
	_buf.appendInt(spendingLimit);
	_buf.append(',');
	_buf.append("flags_ignored=");
	_buf.appendUint(flags_ignored);
	_buf.append(',');
	_buf.append("flags2_ignored=");
	_buf.appendUint64(flags2_ignored);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(spendingLimit);
	_msg.composeUINT32(flags_ignored);
	_msg.composeUINT64(flags2_ignored);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(spendingLimit);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(flags_ignored);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(flags2_ignored);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_SPENDING_LIMIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 spendingLimit; _parser.parseINT32(spendingLimit);
	AtfValidator::validateIntRange(_descr, "spendingLimit", spendingLimit, 1, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 flags_ignored; _parser.parseUINT32(flags_ignored);
	AtfValidator::validateInt(_descr, "flags_ignored", flags_ignored, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 flags2_ignored; _parser.parseUINT64(flags2_ignored);
	AtfValidator::validateUint(_descr, "flags2_ignored", flags2_ignored, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_SPENDING_LIMIT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT_REPLY::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT_REPLY::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT_REPLY(Protocol_MSG_CASHIER_SET_SPENDING_LIMIT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT_REPLY::operator=(Protocol_MSG_CASHIER_SET_SPENDING_LIMIT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT_REPLY::equals(const Protocol_MSG_CASHIER_SET_SPENDING_LIMIT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_SPENDING_LIMIT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_SPENDING_LIMIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_FRMIGRATION_CANCEL
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL::clear()
{
	cancelCode = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL::equals(const Protocol_MSG_CASHIER_FRMIGRATION_CANCEL& _o) const
{
	return cancelCode == _o.cancelCode;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_FRMIGRATION_CANCEL).append(")");
	_buf.append(',');
	_buf.append("cancelCode=");
	_buf.appendUint(cancelCode);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(cancelCode);
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(cancelCode);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_FRMIGRATION_CANCEL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 cancelCode; _parser.parseUINT32(cancelCode);
	AtfValidator::validateIntRange(_descr, "cancelCode", cancelCode, eFrMigrationCancelCode1, eFrMigrationCancelCodeLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_FRMIGRATION_CANCEL_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL_REPLY::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL_REPLY::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL_REPLY(Protocol_MSG_CASHIER_FRMIGRATION_CANCEL_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL_REPLY::operator=(Protocol_MSG_CASHIER_FRMIGRATION_CANCEL_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL_REPLY::equals(const Protocol_MSG_CASHIER_FRMIGRATION_CANCEL_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_FRMIGRATION_CANCEL_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_FRMIGRATION_CANCEL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO(Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO&& _o)
	: migrTypeInt(std::move(_o.migrTypeInt))
	, linkedUserId(std::move(_o.linkedUserId))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO& CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO::operator=(Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO&& _o)
{
	if(this != &_o)
	{
		migrTypeInt = std::move(_o.migrTypeInt);
		linkedUserId = std::move(_o.linkedUserId);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO::clear()
{
	migrTypeInt = 0;
	linkedUserId.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO::equals(const Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO& _o) const
{
	return migrTypeInt == _o.migrTypeInt &&
		linkedUserId.equals(_o.linkedUserId);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_FRMIGRATION_GET_INFO).append(")");
	_buf.append(',');
	_buf.append("migrTypeInt=");
	_buf.appendUint(migrTypeInt);
	_buf.append(',');
	_buf.append("linkedUserId=");
	_buf.append(linkedUserId);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(migrTypeInt);
	_msg.composeString(linkedUserId);
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(migrTypeInt);
	_parser.parseStringP(linkedUserId);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_FRMIGRATION_GET_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 migrTypeInt; _parser.parseUINT32(migrTypeInt);
	AtfValidator::validateIntRange(_descr, "migrTypeInt", migrTypeInt, eMigrationTypeTransfer, eMigrationTypeLast, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "linkedUserId"); size_t szLinkedUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "linkedUserId", szLinkedUserId, 200, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY(Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, cashAssets(std::move(_o.cashAssets))
	, tChipsAssets(std::move(_o.tChipsAssets))
	, fppBalance(std::move(_o.fppBalance))
	, vipRewardBonusFpp(std::move(_o.vipRewardBonusFpp))
	, monthlyVpp(std::move(_o.monthlyVpp))
	, yearlyVpp(std::move(_o.yearlyVpp))
	, totalCashAmount(std::move(_o.totalCashAmount))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY::operator=(Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		cashAssets = std::move(_o.cashAssets);
		tChipsAssets = std::move(_o.tChipsAssets);
		fppBalance = std::move(_o.fppBalance);
		vipRewardBonusFpp = std::move(_o.vipRewardBonusFpp);
		monthlyVpp = std::move(_o.monthlyVpp);
		yearlyVpp = std::move(_o.yearlyVpp);
		totalCashAmount = std::move(_o.totalCashAmount);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	cashAssets.clear();
	tChipsAssets.clear();
	fppBalance = 0;
	vipRewardBonusFpp = 0;
	monthlyVpp = 0;
	yearlyVpp = 0;
	totalCashAmount = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY::equals(const Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		cashAssets.equals(_o.cashAssets) &&
		tChipsAssets.equals(_o.tChipsAssets) &&
		fppBalance == _o.fppBalance &&
		vipRewardBonusFpp == _o.vipRewardBonusFpp &&
		monthlyVpp == _o.monthlyVpp &&
		yearlyVpp == _o.yearlyVpp &&
		totalCashAmount == _o.totalCashAmount;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("cashAssets=");
		cashAssets.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tChipsAssets=");
		tChipsAssets.toTraceString(_buf);
		_buf.append(',');
		_buf.append("fppBalance=");
		_buf.appendUint(fppBalance);
		_buf.append(',');
		_buf.append("vipRewardBonusFpp=");
		_buf.appendUint(vipRewardBonusFpp);
		_buf.append(',');
		_buf.append("monthlyVpp=");
		_buf.appendUint(monthlyVpp);
		_buf.append(',');
		_buf.append("yearlyVpp=");
		_buf.appendUint(yearlyVpp);
		_buf.append(',');
		_buf.append("totalCashAmount=");
		_buf.appendUint(totalCashAmount);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		cashAssets.composeMsg(_msg);
		tChipsAssets.composeMsg(_msg);
		_msg.composeUINT32(fppBalance);
		_msg.composeUINT32(vipRewardBonusFpp);
		_msg.composeUINT32(monthlyVpp);
		_msg.composeUINT32(yearlyVpp);
		_msg.composeUINT32(totalCashAmount);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		cashAssets.parseMsg(_parser);
		tChipsAssets.parseMsg(_parser);
		_parser.parseUINT32(fppBalance);
		_parser.parseUINT32(vipRewardBonusFpp);
		_parser.parseUINT32(monthlyVpp);
		_parser.parseUINT32(yearlyVpp);
		_parser.parseUINT32(totalCashAmount);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		UserAllAssets::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cashAssets"), _fieldsWithUnparsedContent);
		UserAllAssets::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tChipsAssets"), _fieldsWithUnparsedContent);
		UINT32 fppBalance; _parser.parseUINT32(fppBalance);
		AtfValidator::validateInt(_descr, "fppBalance", fppBalance, _checker, __FILE__, __LINE__);
		UINT32 vipRewardBonusFpp; _parser.parseUINT32(vipRewardBonusFpp);
		AtfValidator::validateInt(_descr, "vipRewardBonusFpp", vipRewardBonusFpp, _checker, __FILE__, __LINE__);
		UINT32 monthlyVpp; _parser.parseUINT32(monthlyVpp);
		AtfValidator::validateInt(_descr, "monthlyVpp", monthlyVpp, _checker, __FILE__, __LINE__);
		UINT32 yearlyVpp; _parser.parseUINT32(yearlyVpp);
		AtfValidator::validateInt(_descr, "yearlyVpp", yearlyVpp, _checker, __FILE__, __LINE__);
		UINT32 totalCashAmount; _parser.parseUINT32(totalCashAmount);
		AtfValidator::validateInt(_descr, "totalCashAmount", totalCashAmount, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_FRMIGRATION
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION::Protocol_MSG_CASHIER_FRMIGRATION()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION::equals(const Protocol_MSG_CASHIER_FRMIGRATION& _o) const
{
	return true;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_FRMIGRATION).append(")");
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION::composeMsg(CommMsgBody& _msg) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_FRMIGRATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_FRMIGRATION_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_REPLY::Protocol_MSG_CASHIER_FRMIGRATION_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_REPLY::Protocol_MSG_CASHIER_FRMIGRATION_REPLY(Protocol_MSG_CASHIER_FRMIGRATION_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, overcreditTransId(std::move(_o.overcreditTransId))
	, migrationId(std::move(_o.migrationId))
	, overcreditAmount(std::move(_o.overcreditAmount))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_REPLY::operator=(Protocol_MSG_CASHIER_FRMIGRATION_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		overcreditTransId = std::move(_o.overcreditTransId);
		migrationId = std::move(_o.migrationId);
		overcreditAmount = std::move(_o.overcreditAmount);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	overcreditTransId = 0;
	migrationId = 0;
	overcreditAmount = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_REPLY::equals(const Protocol_MSG_CASHIER_FRMIGRATION_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		overcreditTransId == _o.overcreditTransId &&
		migrationId == _o.migrationId &&
		overcreditAmount == _o.overcreditAmount;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_FRMIGRATION_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("overcreditTransId=");
		_buf.appendUint(overcreditTransId);
		_buf.append(',');
		_buf.append("migrationId=");
		_buf.appendUint(migrationId);
		_buf.append(',');
		_buf.append("overcreditAmount=");
		_buf.appendInt(overcreditAmount);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(overcreditTransId);
		_msg.composeUINT32(migrationId);
		_msg.composeINT32(overcreditAmount);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(overcreditTransId);
		_parser.parseUINT32(migrationId);
		_parser.parseINT32(overcreditAmount);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_FRMIGRATION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 overcreditTransId; _parser.parseUINT32(overcreditTransId);
		AtfValidator::validateInt(_descr, "overcreditTransId", overcreditTransId, _checker, __FILE__, __LINE__);
		UINT32 migrationId; _parser.parseUINT32(migrationId);
		AtfValidator::validateInt(_descr, "migrationId", migrationId, _checker, __FILE__, __LINE__);
		INT32 overcreditAmount; _parser.parseINT32(overcreditAmount);
		AtfValidator::validateInt(_descr, "overcreditAmount", overcreditAmount, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT::clear()
{
	doDeposit = false;
	overcreditTransId = 0;
	migrationId = 0;
	amount = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT::equals(const Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT& _o) const
{
	return doDeposit == _o.doDeposit &&
		overcreditTransId == _o.overcreditTransId &&
		migrationId == _o.migrationId &&
		amount == _o.amount;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_FRMIGRATION_DEPOSIT).append(")");
	_buf.append(',');
	_buf.append("doDeposit=");
	_buf.appendUint(doDeposit);
	_buf.append(',');
	_buf.append("overcreditTransId=");
	_buf.appendUint(overcreditTransId);
	_buf.append(',');
	_buf.append("migrationId=");
	_buf.appendUint(migrationId);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendInt(amount);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBOOL(doDeposit);
	_msg.composeUINT32(overcreditTransId);
	_msg.composeUINT32(migrationId);
	_msg.composeINT32(amount);
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(doDeposit);
	_parser.parseUINT32(overcreditTransId);
	_parser.parseUINT32(migrationId);
	_parser.parseINT32(amount);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_FRMIGRATION_DEPOSIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	bool doDeposit; _parser.parseBOOL(doDeposit);
	AtfValidator::validateInt(_descr, "doDeposit", doDeposit, _checker, __FILE__, __LINE__);
	UINT32 overcreditTransId; _parser.parseUINT32(overcreditTransId);
	AtfValidator::validateInt(_descr, "overcreditTransId", overcreditTransId, _checker, __FILE__, __LINE__);
	UINT32 migrationId; _parser.parseUINT32(migrationId);
	AtfValidator::validateInt(_descr, "migrationId", migrationId, _checker, __FILE__, __LINE__);
	INT32 amount; _parser.parseINT32(amount);
	AtfValidator::validateIntRange(_descr, "amount", amount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY(Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY::operator=(Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY::equals(const Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL::clear()
{
	cancelCode = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL::equals(const Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL& _o) const
{
	return cancelCode == _o.cancelCode;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_ESMIGRATION2_CANCEL).append(")");
	_buf.append(',');
	_buf.append("cancelCode=");
	_buf.appendUint(cancelCode);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(cancelCode);
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(cancelCode);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ESMIGRATION2_CANCEL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 cancelCode; _parser.parseUINT32(cancelCode);
	AtfValidator::validateIntRange(_descr, "cancelCode", cancelCode, eEsMigrationCancelCode1, eEsMigrationCancelCodeLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY(Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY::operator=(Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY::equals(const Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO::equals(const Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO& _o) const
{
	return true;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_ESMIGRATION2_GET_INFO).append(")");
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO::composeMsg(CommMsgBody& _msg) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ESMIGRATION2_GET_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY(Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, cashAssets(std::move(_o.cashAssets))
	, tChipsAssets(std::move(_o.tChipsAssets))
	, fppBalance(std::move(_o.fppBalance))
	, vipRewardBonusFpp(std::move(_o.vipRewardBonusFpp))
	, monthlyVpp(std::move(_o.monthlyVpp))
	, yearlyVpp(std::move(_o.yearlyVpp))
	, totalCashAmount(std::move(_o.totalCashAmount))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY::operator=(Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		cashAssets = std::move(_o.cashAssets);
		tChipsAssets = std::move(_o.tChipsAssets);
		fppBalance = std::move(_o.fppBalance);
		vipRewardBonusFpp = std::move(_o.vipRewardBonusFpp);
		monthlyVpp = std::move(_o.monthlyVpp);
		yearlyVpp = std::move(_o.yearlyVpp);
		totalCashAmount = std::move(_o.totalCashAmount);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	cashAssets.clear();
	tChipsAssets.clear();
	fppBalance = 0;
	vipRewardBonusFpp = 0;
	monthlyVpp = 0;
	yearlyVpp = 0;
	totalCashAmount = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY::equals(const Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		cashAssets.equals(_o.cashAssets) &&
		tChipsAssets.equals(_o.tChipsAssets) &&
		fppBalance == _o.fppBalance &&
		vipRewardBonusFpp == _o.vipRewardBonusFpp &&
		monthlyVpp == _o.monthlyVpp &&
		yearlyVpp == _o.yearlyVpp &&
		totalCashAmount == _o.totalCashAmount;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("cashAssets=");
		cashAssets.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tChipsAssets=");
		tChipsAssets.toTraceString(_buf);
		_buf.append(',');
		_buf.append("fppBalance=");
		_buf.appendUint(fppBalance);
		_buf.append(',');
		_buf.append("vipRewardBonusFpp=");
		_buf.appendUint(vipRewardBonusFpp);
		_buf.append(',');
		_buf.append("monthlyVpp=");
		_buf.appendUint(monthlyVpp);
		_buf.append(',');
		_buf.append("yearlyVpp=");
		_buf.appendUint(yearlyVpp);
		_buf.append(',');
		_buf.append("totalCashAmount=");
		_buf.appendUint(totalCashAmount);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		cashAssets.composeMsg(_msg);
		tChipsAssets.composeMsg(_msg);
		_msg.composeUINT32(fppBalance);
		_msg.composeUINT32(vipRewardBonusFpp);
		_msg.composeUINT32(monthlyVpp);
		_msg.composeUINT32(yearlyVpp);
		_msg.composeUINT32(totalCashAmount);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		cashAssets.parseMsg(_parser);
		tChipsAssets.parseMsg(_parser);
		_parser.parseUINT32(fppBalance);
		_parser.parseUINT32(vipRewardBonusFpp);
		_parser.parseUINT32(monthlyVpp);
		_parser.parseUINT32(yearlyVpp);
		_parser.parseUINT32(totalCashAmount);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		UserAllAssets::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cashAssets"), _fieldsWithUnparsedContent);
		UserAllAssets::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tChipsAssets"), _fieldsWithUnparsedContent);
		UINT32 fppBalance; _parser.parseUINT32(fppBalance);
		AtfValidator::validateInt(_descr, "fppBalance", fppBalance, _checker, __FILE__, __LINE__);
		UINT32 vipRewardBonusFpp; _parser.parseUINT32(vipRewardBonusFpp);
		AtfValidator::validateInt(_descr, "vipRewardBonusFpp", vipRewardBonusFpp, _checker, __FILE__, __LINE__);
		UINT32 monthlyVpp; _parser.parseUINT32(monthlyVpp);
		AtfValidator::validateInt(_descr, "monthlyVpp", monthlyVpp, _checker, __FILE__, __LINE__);
		UINT32 yearlyVpp; _parser.parseUINT32(yearlyVpp);
		AtfValidator::validateInt(_descr, "yearlyVpp", yearlyVpp, _checker, __FILE__, __LINE__);
		UINT32 totalCashAmount; _parser.parseUINT32(totalCashAmount);
		AtfValidator::validateInt(_descr, "totalCashAmount", totalCashAmount, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_ESMIGRATION2
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2::Protocol_MSG_CASHIER_ESMIGRATION2()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2::equals(const Protocol_MSG_CASHIER_ESMIGRATION2& _o) const
{
	return true;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_ESMIGRATION2).append(")");
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2::composeMsg(CommMsgBody& _msg) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ESMIGRATION2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_ESMIGRATION2_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_REPLY::Protocol_MSG_CASHIER_ESMIGRATION2_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_REPLY::Protocol_MSG_CASHIER_ESMIGRATION2_REPLY(Protocol_MSG_CASHIER_ESMIGRATION2_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, overcreditTransId(std::move(_o.overcreditTransId))
	, migrationId(std::move(_o.migrationId))
	, overcreditAmount(std::move(_o.overcreditAmount))
	, voucher(std::move(_o.voucher))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_REPLY::operator=(Protocol_MSG_CASHIER_ESMIGRATION2_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		overcreditTransId = std::move(_o.overcreditTransId);
		migrationId = std::move(_o.migrationId);
		overcreditAmount = std::move(_o.overcreditAmount);
		voucher = std::move(_o.voucher);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	overcreditTransId = 0;
	migrationId = 0;
	overcreditAmount = 0;
	voucher.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_REPLY::equals(const Protocol_MSG_CASHIER_ESMIGRATION2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		overcreditTransId == _o.overcreditTransId &&
		migrationId == _o.migrationId &&
		overcreditAmount == _o.overcreditAmount &&
		voucher.equals(_o.voucher);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_ESMIGRATION2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("overcreditTransId=");
		_buf.appendUint(overcreditTransId);
		_buf.append(',');
		_buf.append("migrationId=");
		_buf.appendUint(migrationId);
		_buf.append(',');
		_buf.append("overcreditAmount=");
		_buf.appendUint(overcreditAmount);
		_buf.append(',');
		_buf.append("voucher=");
		_buf.append(voucher);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(overcreditTransId);
		_msg.composeUINT32(migrationId);
		_msg.composeUINT32(overcreditAmount);
		_msg.composeString(voucher);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(overcreditTransId);
		_parser.parseUINT32(migrationId);
		_parser.parseUINT32(overcreditAmount);
		_parser.parseStringP(voucher);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ESMIGRATION2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 overcreditTransId; _parser.parseUINT32(overcreditTransId);
		AtfValidator::validateInt(_descr, "overcreditTransId", overcreditTransId, _checker, __FILE__, __LINE__);
		UINT32 migrationId; _parser.parseUINT32(migrationId);
		AtfValidator::validateInt(_descr, "migrationId", migrationId, _checker, __FILE__, __LINE__);
		UINT32 overcreditAmount; _parser.parseUINT32(overcreditAmount);
		AtfValidator::validateInt(_descr, "overcreditAmount", overcreditAmount, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "voucher"); size_t szVoucher = strlen(_dummy);
		AtfValidator::validateInt(_descr, "voucher", szVoucher, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT::clear()
{
	doDeposit = false;
	overcreditTransId = 0;
	migrationId = 0;
	amountEur = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT::equals(const Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT& _o) const
{
	return doDeposit == _o.doDeposit &&
		overcreditTransId == _o.overcreditTransId &&
		migrationId == _o.migrationId &&
		amountEur == _o.amountEur;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_ESMIGRATION2_DEPOSIT).append(")");
	_buf.append(',');
	_buf.append("doDeposit=");
	_buf.appendUint(doDeposit);
	_buf.append(',');
	_buf.append("overcreditTransId=");
	_buf.appendUint(overcreditTransId);
	_buf.append(',');
	_buf.append("migrationId=");
	_buf.appendUint(migrationId);
	_buf.append(',');
	_buf.append("amountEur=");
	_buf.appendInt(amountEur);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBOOL(doDeposit);
	_msg.composeUINT32(overcreditTransId);
	_msg.composeUINT32(migrationId);
	_msg.composeINT32(amountEur);
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(doDeposit);
	_parser.parseUINT32(overcreditTransId);
	_parser.parseUINT32(migrationId);
	_parser.parseINT32(amountEur);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ESMIGRATION2_DEPOSIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	bool doDeposit; _parser.parseBOOL(doDeposit);
	AtfValidator::validateInt(_descr, "doDeposit", doDeposit, _checker, __FILE__, __LINE__);
	UINT32 overcreditTransId; _parser.parseUINT32(overcreditTransId);
	AtfValidator::validateInt(_descr, "overcreditTransId", overcreditTransId, _checker, __FILE__, __LINE__);
	UINT32 migrationId; _parser.parseUINT32(migrationId);
	AtfValidator::validateInt(_descr, "migrationId", migrationId, _checker, __FILE__, __LINE__);
	INT32 amountEur; _parser.parseINT32(amountEur);
	AtfValidator::validateIntRange(_descr, "amountEur", amountEur, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY(Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, descrForUser(std::move(_o.descrForUser))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY::operator=(Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		descrForUser = std::move(_o.descrForUser);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	descrForUser.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY::equals(const Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		descrForUser.equals(_o.descrForUser);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("descrForUser=");
		_buf.append(descrForUser);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(descrForUser);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(descrForUser);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "descrForUser"); size_t szDescrForUser = strlen(_dummy);
		AtfValidator::validateInt(_descr, "descrForUser", szDescrForUser, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_VALIDATION_CANCEL
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL::Protocol_MSG_CASHIER_VALIDATION_CANCEL()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL::clear()
{
	paySystemByte = 0;
	digits = 0;
	attempts = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL::equals(const Protocol_MSG_CASHIER_VALIDATION_CANCEL& _o) const
{
	return paySystemByte == _o.paySystemByte &&
		digits == _o.digits &&
		attempts == _o.attempts;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_VALIDATION_CANCEL).append(")");
	_buf.append(',');
	_buf.append("paySystemByte=");
	_buf.appendUint(paySystemByte);
	_buf.append(',');
	_buf.append("digits=");
	_buf.appendUint(digits);
	_buf.append(',');
	_buf.append("attempts=");
	_buf.appendUint(attempts);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(paySystemByte);
	_msg.composeUINT32(digits);
	_msg.composeUINT32(attempts);
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(paySystemByte);
	_parser.parseUINT32(digits);
	_parser.parseUINT32(attempts);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_VALIDATION_CANCEL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE paySystemByte; _parser.parseBYTE(paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	UINT32 digits; _parser.parseUINT32(digits);
	AtfValidator::validateInt(_descr, "digits", digits, _checker, __FILE__, __LINE__);
	UINT32 attempts; _parser.parseUINT32(attempts);
	AtfValidator::validateIntMax(_descr, "attempts", attempts, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_VALIDATION_CANCEL_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL_REPLY::Protocol_MSG_CASHIER_VALIDATION_CANCEL_REPLY()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL_REPLY::clear()
{
	errCode = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL_REPLY::equals(const Protocol_MSG_CASHIER_VALIDATION_CANCEL_REPLY& _o) const
{
	return errCode == _o.errCode;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_VALIDATION_CANCEL_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_VALIDATION_CANCEL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_TCHIPS_PRESALE
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE::Protocol_MSG_CASHIER_TCHIPS_PRESALE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE::Protocol_MSG_CASHIER_TCHIPS_PRESALE(Protocol_MSG_CASHIER_TCHIPS_PRESALE&& _o)
	: anotherUserId(std::move(_o.anotherUserId))
	, isBuyer(std::move(_o.isBuyer))
	, tChips(std::move(_o.tChips))
	, cash(std::move(_o.cash))
	, currency(std::move(_o.currency))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE& CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE::operator=(Protocol_MSG_CASHIER_TCHIPS_PRESALE&& _o)
{
	if(this != &_o)
	{
		anotherUserId = std::move(_o.anotherUserId);
		isBuyer = std::move(_o.isBuyer);
		tChips = std::move(_o.tChips);
		cash = std::move(_o.cash);
		currency = std::move(_o.currency);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE::clear()
{
	anotherUserId.clear();
	isBuyer = false;
	tChips = 0;
	cash = 0;
	currency.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE::equals(const Protocol_MSG_CASHIER_TCHIPS_PRESALE& _o) const
{
	return anotherUserId.equals(_o.anotherUserId) &&
		isBuyer == _o.isBuyer &&
		tChips == _o.tChips &&
		cash == _o.cash &&
		currency.equals(_o.currency);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_TCHIPS_PRESALE).append(")");
	_buf.append(',');
	_buf.append("anotherUserId=");
	_buf.append(anotherUserId);
	_buf.append(',');
	_buf.append("isBuyer=");
	_buf.appendUint(isBuyer);
	_buf.append(',');
	_buf.append("tChips=");
	_buf.appendInt(tChips);
	_buf.append(',');
	_buf.append("cash=");
	_buf.appendInt(cash);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(anotherUserId);
	_msg.composeBOOL(isBuyer);
	_msg.composeINT32(tChips);
	_msg.composeINT32(cash);
	_msg.composeString(currency);
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(anotherUserId);
	_parser.parseBOOL(isBuyer);
	_parser.parseINT32(tChips);
	_parser.parseINT32(cash);
	_parser.parseStringP(currency);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TCHIPS_PRESALE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "anotherUserId"); size_t szAnotherUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "anotherUserId", szAnotherUserId, 200, _checker, __FILE__, __LINE__);
	bool isBuyer; _parser.parseBOOL(isBuyer);
	AtfValidator::validateInt(_descr, "isBuyer", isBuyer, _checker, __FILE__, __LINE__);
	INT32 tChips; _parser.parseINT32(tChips);
	AtfValidator::validateIntRange(_descr, "tChips", tChips, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	INT32 cash; _parser.parseINT32(cash);
	AtfValidator::validateIntRange(_descr, "cash", cash, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_TCHIPS_PRESALE_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE_REPLY::Protocol_MSG_CASHIER_TCHIPS_PRESALE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE_REPLY::Protocol_MSG_CASHIER_TCHIPS_PRESALE_REPLY(Protocol_MSG_CASHIER_TCHIPS_PRESALE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, seller(std::move(_o.seller))
	, buyer(std::move(_o.buyer))
	, isBuyer(std::move(_o.isBuyer))
	, tChips(std::move(_o.tChips))
	, cash(std::move(_o.cash))
	, userId(std::move(_o.userId))
	, city(std::move(_o.city))
	, country(std::move(_o.country))
	, showCity(std::move(_o.showCity))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE_REPLY::operator=(Protocol_MSG_CASHIER_TCHIPS_PRESALE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		seller = std::move(_o.seller);
		buyer = std::move(_o.buyer);
		isBuyer = std::move(_o.isBuyer);
		tChips = std::move(_o.tChips);
		cash = std::move(_o.cash);
		userId = std::move(_o.userId);
		city = std::move(_o.city);
		country = std::move(_o.country);
		showCity = std::move(_o.showCity);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	seller.clear();
	buyer.clear();
	isBuyer = false;
	tChips = 0;
	cash = 0;
	userId.clear();
	city.clear();
	country.clear();
	showCity = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE_REPLY::equals(const Protocol_MSG_CASHIER_TCHIPS_PRESALE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		seller.equals(_o.seller) &&
		buyer.equals(_o.buyer) &&
		isBuyer == _o.isBuyer &&
		tChips == _o.tChips &&
		cash == _o.cash &&
		userId.equals(_o.userId) &&
		city.equals(_o.city) &&
		country.equals(_o.country) &&
		showCity == _o.showCity;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_TCHIPS_PRESALE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("seller=");
		_buf.append(seller);
		_buf.append(',');
		_buf.append("buyer=");
		_buf.append(buyer);
		_buf.append(',');
		_buf.append("isBuyer=");
		_buf.appendUint(isBuyer);
		_buf.append(',');
		_buf.append("tChips=");
		_buf.appendInt(tChips);
		_buf.append(',');
		_buf.append("cash=");
		_buf.appendInt(cash);
		_buf.append(',');
		_buf.append("userId=");
		_buf.append(userId);
		_buf.append(',');
		_buf.append("city=");
		_buf.append(city);
		_buf.append(',');
		_buf.append("country=");
		_buf.append(country);
		_buf.append(',');
		_buf.append("showCity=");
		_buf.appendUint(showCity);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(seller);
		_msg.composeString(buyer);
		_msg.composeBOOL(isBuyer);
		_msg.composeINT32(tChips);
		_msg.composeINT32(cash);
		_msg.composeString(userId);
		_msg.composeString(city);
		_msg.composeString(country);
		_msg.composeBYTE(showCity);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(seller);
		_parser.parseStringP(buyer);
		_parser.parseBOOL(isBuyer);
		_parser.parseINT32(tChips);
		_parser.parseINT32(cash);
		_parser.parseStringP(userId);
		_parser.parseStringP(city);
		_parser.parseStringP(country);
		_parser.parseBYTE(showCity);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TCHIPS_PRESALE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "seller"); size_t szSeller = strlen(_dummy);
		AtfValidator::validateInt(_descr, "seller", szSeller, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "buyer"); size_t szBuyer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "buyer", szBuyer, _checker, __FILE__, __LINE__);
		bool isBuyer; _parser.parseBOOL(isBuyer);
		AtfValidator::validateInt(_descr, "isBuyer", isBuyer, _checker, __FILE__, __LINE__);
		INT32 tChips; _parser.parseINT32(tChips);
		AtfValidator::validateInt(_descr, "tChips", tChips, _checker, __FILE__, __LINE__);
		INT32 cash; _parser.parseINT32(cash);
		AtfValidator::validateInt(_descr, "cash", cash, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
		AtfValidator::validateInt(_descr, "city", szCity, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
		AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
		BYTE showCity; _parser.parseBYTE(showCity);
		AtfValidator::validateIntRange(_descr, "showCity", showCity, 0, 1, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_TCHIPS_SALE
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE::Protocol_MSG_CASHIER_TCHIPS_SALE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE::Protocol_MSG_CASHIER_TCHIPS_SALE(Protocol_MSG_CASHIER_TCHIPS_SALE&& _o)
	: anotherUserId(std::move(_o.anotherUserId))
	, isBuyer(std::move(_o.isBuyer))
	, tChips(std::move(_o.tChips))
	, cash(std::move(_o.cash))
	, currency(std::move(_o.currency))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE& CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE::operator=(Protocol_MSG_CASHIER_TCHIPS_SALE&& _o)
{
	if(this != &_o)
	{
		anotherUserId = std::move(_o.anotherUserId);
		isBuyer = std::move(_o.isBuyer);
		tChips = std::move(_o.tChips);
		cash = std::move(_o.cash);
		currency = std::move(_o.currency);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE::clear()
{
	anotherUserId.clear();
	isBuyer = false;
	tChips = 0;
	cash = 0;
	currency.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE::equals(const Protocol_MSG_CASHIER_TCHIPS_SALE& _o) const
{
	return anotherUserId.equals(_o.anotherUserId) &&
		isBuyer == _o.isBuyer &&
		tChips == _o.tChips &&
		cash == _o.cash &&
		currency.equals(_o.currency);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_TCHIPS_SALE).append(")");
	_buf.append(',');
	_buf.append("anotherUserId=");
	_buf.append(anotherUserId);
	_buf.append(',');
	_buf.append("isBuyer=");
	_buf.appendUint(isBuyer);
	_buf.append(',');
	_buf.append("tChips=");
	_buf.appendInt(tChips);
	_buf.append(',');
	_buf.append("cash=");
	_buf.appendInt(cash);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(anotherUserId);
	_msg.composeBOOL(isBuyer);
	_msg.composeINT32(tChips);
	_msg.composeINT32(cash);
	_msg.composeString(currency);
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(anotherUserId);
	_parser.parseBOOL(isBuyer);
	_parser.parseINT32(tChips);
	_parser.parseINT32(cash);
	_parser.parseStringP(currency);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TCHIPS_SALE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "anotherUserId"); size_t szAnotherUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "anotherUserId", szAnotherUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	bool isBuyer; _parser.parseBOOL(isBuyer);
	AtfValidator::validateInt(_descr, "isBuyer", isBuyer, _checker, __FILE__, __LINE__);
	INT32 tChips; _parser.parseINT32(tChips);
	AtfValidator::validateIntRange(_descr, "tChips", tChips, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	INT32 cash; _parser.parseINT32(cash);
	AtfValidator::validateIntRange(_descr, "cash", cash, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_TCHIPS_SALE_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_REPLY::Protocol_MSG_CASHIER_TCHIPS_SALE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_REPLY::Protocol_MSG_CASHIER_TCHIPS_SALE_REPLY(Protocol_MSG_CASHIER_TCHIPS_SALE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, expirationIntervalSec(std::move(_o.expirationIntervalSec))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_REPLY::operator=(Protocol_MSG_CASHIER_TCHIPS_SALE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		expirationIntervalSec = std::move(_o.expirationIntervalSec);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	expirationIntervalSec = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_REPLY::equals(const Protocol_MSG_CASHIER_TCHIPS_SALE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		expirationIntervalSec == _o.expirationIntervalSec;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_TCHIPS_SALE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("expirationIntervalSec=");
		_buf.appendInt(expirationIntervalSec);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(expirationIntervalSec);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(expirationIntervalSec);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TCHIPS_SALE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 expirationIntervalSec; _parser.parseINT32(expirationIntervalSec);
		AtfValidator::validateInt(_descr, "expirationIntervalSec", expirationIntervalSec, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_TCHIPS_PRECANCEL
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL::equals(const Protocol_MSG_CASHIER_TCHIPS_PRECANCEL& _o) const
{
	return true;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_TCHIPS_PRECANCEL).append(")");
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL::composeMsg(CommMsgBody& _msg) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TCHIPS_PRECANCEL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierTChipsPrecancelOneBody
//=================================================================

CashierServer::cli::CashierTChipsPrecancelOneBody::CashierTChipsPrecancelOneBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::CashierTChipsPrecancelOneBody::CashierTChipsPrecancelOneBody(CashierTChipsPrecancelOneBody&& _o)
	: saleId(std::move(_o.saleId))
	, anotherUserId(std::move(_o.anotherUserId))
	, tChips(std::move(_o.tChips))
	, cash(std::move(_o.cash))
	, isStartedByBuyer(std::move(_o.isStartedByBuyer))
	, validUntil(std::move(_o.validUntil))
	, currency(std::move(_o.currency))
{
}

CashierServer::cli::CashierTChipsPrecancelOneBody& CashierServer::cli::CashierTChipsPrecancelOneBody::operator=(CashierTChipsPrecancelOneBody&& _o)
{
	if(this != &_o)
	{
		saleId = std::move(_o.saleId);
		anotherUserId = std::move(_o.anotherUserId);
		tChips = std::move(_o.tChips);
		cash = std::move(_o.cash);
		isStartedByBuyer = std::move(_o.isStartedByBuyer);
		validUntil = std::move(_o.validUntil);
		currency = std::move(_o.currency);
	}
	return *this;
}

#endif

void CashierServer::cli::CashierTChipsPrecancelOneBody::clear()
{
	saleId = 0;
	anotherUserId.clear();
	tChips = 0;
	cash = 0;
	isStartedByBuyer = false;
	validUntil.setNull();
	currency.clear();
}

bool CashierServer::cli::CashierTChipsPrecancelOneBody::equals(const CashierTChipsPrecancelOneBody& _o) const
{
	return saleId == _o.saleId &&
		anotherUserId.equals(_o.anotherUserId) &&
		tChips == _o.tChips &&
		cash == _o.cash &&
		isStartedByBuyer == _o.isStartedByBuyer &&
		validUntil.equals(_o.validUntil) &&
		currency.equals(_o.currency);
}

const char *CashierServer::cli::CashierTChipsPrecancelOneBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("saleId=");
	_buf.appendUint(saleId);
	_buf.append(',');
	_buf.append("anotherUserId=");
	_buf.append(anotherUserId);
	_buf.append(',');
	_buf.append("tChips=");
	_buf.appendInt(tChips);
	_buf.append(',');
	_buf.append("cash=");
	_buf.appendInt(cash);
	_buf.append(',');
	_buf.append("isStartedByBuyer=");
	_buf.appendUint(isStartedByBuyer);
	_buf.append(',');
	_buf.append("validUntil=");
	ThinAtf::AtfTempl<CommSrvTime>::ToTraceString(_buf, validUntil);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashierTChipsPrecancelOneBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CashierTChipsPrecancelOneBody())) // not empty
	{
		_body.composeUINT32(saleId);
		_body.composeString(anotherUserId);
		_body.composeINT32(tChips);
		_body.composeINT32(cash);
		_body.composeBOOL(isStartedByBuyer);
		_body.composeSrvTime(validUntil);
		_body.composeString(currency);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierTChipsPrecancelOneBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(saleId);
	_parser0.parseStringP(anotherUserId);
	_parser0.parseINT32(tChips);
	_parser0.parseINT32(cash);
	_parser0.parseBOOL(isStartedByBuyer);
	_parser0.parseSrvTime(validUntil);
	_parser0.parseStringP(currency);
}

/*static*/ void CashierServer::cli::CashierTChipsPrecancelOneBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 saleId; _parser0.parseUINT32(saleId);
	AtfValidator::validateInt(_descr, "saleId", saleId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "anotherUserId"); size_t szAnotherUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "anotherUserId", szAnotherUserId, _checker, __FILE__, __LINE__);
	INT32 tChips; _parser0.parseINT32(tChips);
	AtfValidator::validateInt(_descr, "tChips", tChips, _checker, __FILE__, __LINE__);
	INT32 cash; _parser0.parseINT32(cash);
	AtfValidator::validateInt(_descr, "cash", cash, _checker, __FILE__, __LINE__);
	bool isStartedByBuyer; _parser0.parseBOOL(isStartedByBuyer);
	AtfValidator::validateInt(_descr, "isStartedByBuyer", isStartedByBuyer, _checker, __FILE__, __LINE__);
	CommSrvTime validUntil; _parser0.parseSrvTime(validUntil);
	AtfValidator::validateSrvDateTime(_descr, "validUntil", validUntil, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_TCHIPS_PRECANCEL_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL_REPLY::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL_REPLY::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL_REPLY(Protocol_MSG_CASHIER_TCHIPS_PRECANCEL_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, precancelEntries(std::move(_o.precancelEntries))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL_REPLY::operator=(Protocol_MSG_CASHIER_TCHIPS_PRECANCEL_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		precancelEntries = std::move(_o.precancelEntries);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	precancelEntries.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL_REPLY::equals(const Protocol_MSG_CASHIER_TCHIPS_PRECANCEL_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		precancelEntries.equals(_o.precancelEntries);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_TCHIPS_PRECANCEL_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("precancelEntries=");
		precancelEntries.toTraceString(_buf);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		precancelEntries.composeMsg(_msg);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		precancelEntries.parseMsg(_parser);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TCHIPS_PRECANCEL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szPrecancelEntries = ThinAtf::LAtfVector< CashierTChipsPrecancelOneBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("precancelEntries"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "precancelEntries", szPrecancelEntries, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_TCHIPS_CANCELID
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID::Protocol_MSG_CASHIER_TCHIPS_CANCELID()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID::Protocol_MSG_CASHIER_TCHIPS_CANCELID(Protocol_MSG_CASHIER_TCHIPS_CANCELID&& _o)
	: saleIds(std::move(_o.saleIds))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID& CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID::operator=(Protocol_MSG_CASHIER_TCHIPS_CANCELID&& _o)
{
	if(this != &_o)
	{
		saleIds = std::move(_o.saleIds);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID::clear()
{
	saleIds.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID::equals(const Protocol_MSG_CASHIER_TCHIPS_CANCELID& _o) const
{
	return saleIds.equals(_o.saleIds);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_TCHIPS_CANCELID).append(")");
	_buf.append(',');
	_buf.append("saleIds=");
	saleIds.toTraceString(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID::composeMsg(CommMsgBody& _msg) const
{
	saleIds.composeMsg(_msg);
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID::parseMsg(CommMsgParser& _parser)
{
	saleIds.parseMsg(_parser);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TCHIPS_CANCELID";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szSaleIds = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("saleIds"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "saleIds", szSaleIds, 10000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashieTChipsSaleBody
//=================================================================

CashierServer::cli::CashieTChipsSaleBody::CashieTChipsSaleBody()
{
	clear();
}

void CashierServer::cli::CashieTChipsSaleBody::clear()
{
	saleId = 0;
	errCode2 = 0;
}

bool CashierServer::cli::CashieTChipsSaleBody::equals(const CashieTChipsSaleBody& _o) const
{
	return saleId == _o.saleId &&
		errCode2 == _o.errCode2;
}

const char *CashierServer::cli::CashieTChipsSaleBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("saleId=");
	_buf.appendUint(saleId);
	_buf.append(',');
	_buf.append("errCode2=");
	_buf.appendInt(errCode2);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashieTChipsSaleBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CashieTChipsSaleBody())) // not empty
	{
		_body.composeUINT32(saleId);
		_body.composeINT16(errCode2);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashieTChipsSaleBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(saleId);
	_parser0.parseINT16(errCode2);
}

/*static*/ void CashierServer::cli::CashieTChipsSaleBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 saleId; _parser0.parseUINT32(saleId);
	AtfValidator::validateInt(_descr, "saleId", saleId, _checker, __FILE__, __LINE__);
	INT16 errCode2; _parser0.parseINT16(errCode2);
	AtfValidator::validateInt(_descr, "errCode2", errCode2, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_TCHIPS_CANCELID_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID_REPLY::Protocol_MSG_CASHIER_TCHIPS_CANCELID_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID_REPLY::Protocol_MSG_CASHIER_TCHIPS_CANCELID_REPLY(Protocol_MSG_CASHIER_TCHIPS_CANCELID_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, sales(std::move(_o.sales))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID_REPLY::operator=(Protocol_MSG_CASHIER_TCHIPS_CANCELID_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		sales = std::move(_o.sales);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	sales.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID_REPLY::equals(const Protocol_MSG_CASHIER_TCHIPS_CANCELID_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		sales.equals(_o.sales);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_TCHIPS_CANCELID_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("sales=");
		sales.toTraceString(_buf);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		sales.composeMsg(_msg);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		sales.parseMsg(_parser);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TCHIPS_CANCELID_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szSales = ThinAtf::LAtfVector< CashieTChipsSaleBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sales"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "sales", szSales, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS(Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS&& _o)
	: tChips(std::move(_o.tChips))
	, cash(std::move(_o.cash))
	, currency(std::move(_o.currency))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS& CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS::operator=(Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS&& _o)
{
	if(this != &_o)
	{
		tChips = std::move(_o.tChips);
		cash = std::move(_o.cash);
		currency = std::move(_o.currency);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS::clear()
{
	tChips = 0;
	cash = 0;
	currency.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS::equals(const Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS& _o) const
{
	return tChips == _o.tChips &&
		cash == _o.cash &&
		currency.equals(_o.currency);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_TCHIPS_SALE_TO_PSTARS).append(")");
	_buf.append(',');
	_buf.append("tChips=");
	_buf.appendInt(tChips);
	_buf.append(',');
	_buf.append("cash=");
	_buf.appendInt(cash);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(tChips);
	_msg.composeINT32(cash);
	_msg.composeString(currency);
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(tChips);
	_parser.parseINT32(cash);
	_parser.parseStringP(currency);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TCHIPS_SALE_TO_PSTARS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT32 tChips; _parser.parseINT32(tChips);
	AtfValidator::validateIntRange(_descr, "tChips", tChips, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	INT32 cash; _parser.parseINT32(cash);
	AtfValidator::validateIntRange(_descr, "cash", cash, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY(Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY::operator=(Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY::equals(const Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_TSALE_GET_INFO
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO::Protocol_MSG_CASHIER_TSALE_GET_INFO()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO::equals(const Protocol_MSG_CASHIER_TSALE_GET_INFO& _o) const
{
	return true;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_TSALE_GET_INFO).append(")");
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO::composeMsg(CommMsgBody& _msg) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TSALE_GET_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_TSALE_GET_INFO_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO_REPLY::Protocol_MSG_CASHIER_TSALE_GET_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO_REPLY::Protocol_MSG_CASHIER_TSALE_GET_INFO_REPLY(Protocol_MSG_CASHIER_TSALE_GET_INFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, tChipsToCashMinimumRate_x1M(std::move(_o.tChipsToCashMinimumRate_x1M))
	, tSaleToPStarsEnabled(std::move(_o.tSaleToPStarsEnabled))
	, tChipsToCashPStarsRate_x1M(std::move(_o.tChipsToCashPStarsRate_x1M))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO_REPLY::operator=(Protocol_MSG_CASHIER_TSALE_GET_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		tChipsToCashMinimumRate_x1M = std::move(_o.tChipsToCashMinimumRate_x1M);
		tSaleToPStarsEnabled = std::move(_o.tSaleToPStarsEnabled);
		tChipsToCashPStarsRate_x1M = std::move(_o.tChipsToCashPStarsRate_x1M);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	tChipsToCashMinimumRate_x1M = 0;
	tSaleToPStarsEnabled = false;
	tChipsToCashPStarsRate_x1M = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO_REPLY::equals(const Protocol_MSG_CASHIER_TSALE_GET_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		tChipsToCashMinimumRate_x1M == _o.tChipsToCashMinimumRate_x1M &&
		tSaleToPStarsEnabled == _o.tSaleToPStarsEnabled &&
		tChipsToCashPStarsRate_x1M == _o.tChipsToCashPStarsRate_x1M;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_TSALE_GET_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("tChipsToCashMinimumRate_x1M=");
		_buf.appendInt(tChipsToCashMinimumRate_x1M);
		_buf.append(',');
		_buf.append("tSaleToPStarsEnabled=");
		_buf.appendUint(tSaleToPStarsEnabled);
		_buf.append(',');
		_buf.append("tChipsToCashPStarsRate_x1M=");
		_buf.appendInt(tChipsToCashPStarsRate_x1M);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(tChipsToCashMinimumRate_x1M);
		_msg.composeBOOL(tSaleToPStarsEnabled);
		_msg.composeINT32(tChipsToCashPStarsRate_x1M);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(tChipsToCashMinimumRate_x1M);
		_parser.parseBOOL(tSaleToPStarsEnabled);
		_parser.parseINT32(tChipsToCashPStarsRate_x1M);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TSALE_GET_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TSALE_GET_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 tChipsToCashMinimumRate_x1M; _parser.parseINT32(tChipsToCashMinimumRate_x1M);
		AtfValidator::validateInt(_descr, "tChipsToCashMinimumRate_x1M", tChipsToCashMinimumRate_x1M, _checker, __FILE__, __LINE__);
		bool tSaleToPStarsEnabled; _parser.parseBOOL(tSaleToPStarsEnabled);
		AtfValidator::validateInt(_descr, "tSaleToPStarsEnabled", tSaleToPStarsEnabled, _checker, __FILE__, __LINE__);
		INT32 tChipsToCashPStarsRate_x1M; _parser.parseINT32(tChipsToCashPStarsRate_x1M);
		AtfValidator::validateInt(_descr, "tChipsToCashPStarsRate_x1M", tChipsToCashPStarsRate_x1M, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO::clear()
{
	paySystemByte = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO::equals(const Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO& _o) const
{
	return paySystemByte == _o.paySystemByte;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO).append(")");
	_buf.append(',');
	_buf.append("paySystemByte=");
	_buf.appendUint(paySystemByte);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(paySystemByte);
}

void CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(paySystemByte);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE paySystemByte; _parser.parseBYTE(paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierAmountCurrencyBody
//=================================================================

CashierServer::cli::CashierAmountCurrencyBody::CashierAmountCurrencyBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::CashierAmountCurrencyBody::CashierAmountCurrencyBody(CashierAmountCurrencyBody&& _o)
	: amount(std::move(_o.amount))
	, currency(std::move(_o.currency))
{
}

CashierServer::cli::CashierAmountCurrencyBody& CashierServer::cli::CashierAmountCurrencyBody::operator=(CashierAmountCurrencyBody&& _o)
{
	if(this != &_o)
	{
		amount = std::move(_o.amount);
		currency = std::move(_o.currency);
	}
	return *this;
}

#endif

void CashierServer::cli::CashierAmountCurrencyBody::clear()
{
	amount = 0;
	currency.clear();
}

bool CashierServer::cli::CashierAmountCurrencyBody::equals(const CashierAmountCurrencyBody& _o) const
{
	return amount == _o.amount &&
		currency.equals(_o.currency);
}

const char *CashierServer::cli::CashierAmountCurrencyBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("amount=");
	_buf.appendInt(amount);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashierAmountCurrencyBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CashierAmountCurrencyBody())) // not empty
	{
		_body.composeINT32(amount);
		_body.composeString(currency);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierAmountCurrencyBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(amount);
	_parser0.parseStringP(currency);
}

/*static*/ void CashierServer::cli::CashierAmountCurrencyBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	INT32 amount; _parser0.parseINT32(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY(Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, infos(std::move(_o.infos))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY::operator=(Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		infos = std::move(_o.infos);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	infos.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY::equals(const Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		infos.equals(_o.infos);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("infos=");
		infos.toTraceString(_buf);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		infos.composeMsg(_msg);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		infos.parseMsg(_parser);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szInfos = ThinAtf::LAtfVector< CashierAmountCurrencyBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("infos"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "infos", szInfos, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO(Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO&& _o)
	: fdCallFrom(std::move(_o.fdCallFrom))
	, targetAmount(std::move(_o.targetAmount))
	, targetAcctCurrency(std::move(_o.targetAcctCurrency))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO& CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO::operator=(Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO&& _o)
{
	if(this != &_o)
	{
		fdCallFrom = std::move(_o.fdCallFrom);
		targetAmount = std::move(_o.targetAmount);
		targetAcctCurrency = std::move(_o.targetAcctCurrency);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO::clear()
{
	fdCallFrom = 0;
	targetAmount = 0;
	targetAcctCurrency.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO::equals(const Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO& _o) const
{
	return fdCallFrom == _o.fdCallFrom &&
		targetAmount == _o.targetAmount &&
		targetAcctCurrency.equals(_o.targetAcctCurrency);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_FAST_DEPOSIT_INFO).append(")");
	_buf.append(',');
	_buf.append("fdCallFrom=");
	_buf.appendInt(fdCallFrom);
	_buf.append(',');
	_buf.append("targetAmount=");
	_buf.appendInt(targetAmount);
	_buf.append(',');
	_buf.append("targetAcctCurrency=");
	_buf.append(targetAcctCurrency);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(fdCallFrom);
	_msg.composeINT32(targetAmount);
	_msg.composeString(targetAcctCurrency);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(fdCallFrom);
	_parser.parseINT32(targetAmount);
	_parser.parseStringP(targetAcctCurrency);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_FAST_DEPOSIT_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT32 fdCallFrom; _parser.parseINT32(fdCallFrom);
	AtfValidator::validateIntRange(_descr, "fdCallFrom", fdCallFrom, eFastDepositCallFromUnknown, eFastDepositCallFromLast, _checker, __FILE__, __LINE__);
	INT32 targetAmount; _parser.parseINT32(targetAmount);
	AtfValidator::validateIntRange(_descr, "targetAmount", targetAmount, -1, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "targetAcctCurrency"); size_t szTargetAcctCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "targetAcctCurrency", szTargetAcctCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY(Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, cardTypeByte(std::move(_o.cardTypeByte))
	, paysystemName(std::move(_o.paysystemName))
	, status(std::move(_o.status))
	, procAmount(std::move(_o.procAmount))
	, procCurrency(std::move(_o.procCurrency))
	, extraAcctAmountNeeded(std::move(_o.extraAcctAmountNeeded))
	, cardInfoId(std::move(_o.cardInfoId))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY::operator=(Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		cardTypeByte = std::move(_o.cardTypeByte);
		paysystemName = std::move(_o.paysystemName);
		status = std::move(_o.status);
		procAmount = std::move(_o.procAmount);
		procCurrency = std::move(_o.procCurrency);
		extraAcctAmountNeeded = std::move(_o.extraAcctAmountNeeded);
		cardInfoId = std::move(_o.cardInfoId);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	cardTypeByte = 0;
	paysystemName.clear();
	status = 0;
	procAmount = 0;
	procCurrency.clear();
	extraAcctAmountNeeded = 0;
	cardInfoId = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY::equals(const Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		cardTypeByte == _o.cardTypeByte &&
		paysystemName.equals(_o.paysystemName) &&
		status == _o.status &&
		procAmount == _o.procAmount &&
		procCurrency.equals(_o.procCurrency) &&
		extraAcctAmountNeeded == _o.extraAcctAmountNeeded &&
		cardInfoId == _o.cardInfoId;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("cardTypeByte=");
		_buf.appendUint(cardTypeByte);
		_buf.append(',');
		_buf.append("paysystemName=");
		_buf.append(paysystemName);
		_buf.append(',');
		_buf.append("status=");
		_buf.appendInt(status);
		_buf.append(',');
		_buf.append("procAmount=");
		_buf.appendInt(procAmount);
		_buf.append(',');
		_buf.append("procCurrency=");
		_buf.append(procCurrency);
		_buf.append(',');
		_buf.append("extraAcctAmountNeeded=");
		_buf.appendInt(extraAcctAmountNeeded);
		_buf.append(',');
		_buf.append("cardInfoId=");
		_buf.appendUint(cardInfoId);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeBYTE(cardTypeByte);
		_msg.composeString(paysystemName);
		_msg.composeINT32(status);
		_msg.composeINT32(procAmount);
		_msg.composeString(procCurrency);
		_msg.composeINT32(extraAcctAmountNeeded);
		_msg.composeUINT32(cardInfoId);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseBYTE(cardTypeByte);
		_parser.parseStringP(paysystemName);
		_parser.parseINT32(status);
		_parser.parseINT32(procAmount);
		_parser.parseStringP(procCurrency);
		_parser.parseINT32(extraAcctAmountNeeded);
		_parser.parseUINT32(cardInfoId);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		BYTE cardTypeByte; _parser.parseBYTE(cardTypeByte);
		AtfValidator::validateInt(_descr, "cardTypeByte", cardTypeByte, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "paysystemName"); size_t szPaysystemName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "paysystemName", szPaysystemName, _checker, __FILE__, __LINE__);
		INT32 status; _parser.parseINT32(status);
		AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
		INT32 procAmount; _parser.parseINT32(procAmount);
		AtfValidator::validateInt(_descr, "procAmount", procAmount, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "procCurrency"); size_t szProcCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "procCurrency", szProcCurrency, _checker, __FILE__, __LINE__);
		INT32 extraAcctAmountNeeded; _parser.parseINT32(extraAcctAmountNeeded);
		AtfValidator::validateInt(_descr, "extraAcctAmountNeeded", extraAcctAmountNeeded, _checker, __FILE__, __LINE__);
		UINT32 cardInfoId; _parser.parseUINT32(cardInfoId);
		AtfValidator::validateInt(_descr, "cardInfoId", cardInfoId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO(Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO&& _o)
	: paySystemByte(std::move(_o.paySystemByte))
	, fdStatus(std::move(_o.fdStatus))
	, procAmount(std::move(_o.procAmount))
	, procCurrency(std::move(_o.procCurrency))
	, cardInfoId(std::move(_o.cardInfoId))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO& CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO::operator=(Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO&& _o)
{
	if(this != &_o)
	{
		paySystemByte = std::move(_o.paySystemByte);
		fdStatus = std::move(_o.fdStatus);
		procAmount = std::move(_o.procAmount);
		procCurrency = std::move(_o.procCurrency);
		cardInfoId = std::move(_o.cardInfoId);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO::clear()
{
	paySystemByte = 0;
	fdStatus = 0;
	procAmount = 0;
	procCurrency.clear();
	cardInfoId = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO::equals(const Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO& _o) const
{
	return paySystemByte == _o.paySystemByte &&
		fdStatus == _o.fdStatus &&
		procAmount == _o.procAmount &&
		procCurrency.equals(_o.procCurrency) &&
		cardInfoId == _o.cardInfoId;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO).append(")");
	_buf.append(',');
	_buf.append("paySystemByte=");
	_buf.appendUint(paySystemByte);
	_buf.append(',');
	_buf.append("fdStatus=");
	_buf.appendInt(fdStatus);
	_buf.append(',');
	_buf.append("procAmount=");
	_buf.appendInt(procAmount);
	_buf.append(',');
	_buf.append("procCurrency=");
	_buf.append(procCurrency);
	_buf.append(',');
	_buf.append("cardInfoId=");
	_buf.appendUint(cardInfoId);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(paySystemByte);
	_msg.composeINT32(fdStatus);
	_msg.composeINT32(procAmount);
	_msg.composeString(procCurrency);
	_msg.composeUINT32(cardInfoId);
}

void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(paySystemByte);
	_parser.parseINT32(fdStatus);
	_parser.parseINT32(procAmount);
	_parser.parseStringP(procCurrency);
	_parser.parseUINT32(cardInfoId);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE paySystemByte; _parser.parseBYTE(paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	INT32 fdStatus; _parser.parseINT32(fdStatus);
	{ const INT32 fdStatus_enum[] = { eFastDepositStatusNotExists, eFastDepositStatusDisabled, eFastDepositStatusActive }; AtfValidator::validateEnum(_descr, "fdStatus", fdStatus, fdStatus_enum, _checker, __FILE__, __LINE__); }
	INT32 procAmount; _parser.parseINT32(procAmount);
	AtfValidator::validateIntRange(_descr, "procAmount", procAmount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "procCurrency"); size_t szProcCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "procCurrency", szProcCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	UINT32 cardInfoId; _parser.parseUINT32(cardInfoId);
	AtfValidator::validateInt(_descr, "cardInfoId", cardInfoId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY(Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY::operator=(Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY::equals(const Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO::clear()
{
	paySystemByte = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO::equals(const Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO& _o) const
{
	return paySystemByte == _o.paySystemByte;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO).append(")");
	_buf.append(',');
	_buf.append("paySystemByte=");
	_buf.appendUint(paySystemByte);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(paySystemByte);
}

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(paySystemByte);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE paySystemByte; _parser.parseBYTE(paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY(Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY::operator=(Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY::equals(const Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS::equals(const Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS& _o) const
{
	return true;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_RM_NOK_HELD_FUNDS).append(")");
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS::composeMsg(CommMsgBody& _msg) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_RM_NOK_HELD_FUNDS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierHeldTransBody
//=================================================================

CashierServer::cli::CashierHeldTransBody::CashierHeldTransBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::CashierHeldTransBody::CashierHeldTransBody(CashierHeldTransBody&& _o)
	: transId(std::move(_o.transId))
	, amountAcct(std::move(_o.amountAcct))
	, currencyAcct(std::move(_o.currencyAcct))
	, started(std::move(_o.started))
	, cardTypeByte(std::move(_o.cardTypeByte))
	, paysystemName(std::move(_o.paysystemName))
{
}

CashierServer::cli::CashierHeldTransBody& CashierServer::cli::CashierHeldTransBody::operator=(CashierHeldTransBody&& _o)
{
	if(this != &_o)
	{
		transId = std::move(_o.transId);
		amountAcct = std::move(_o.amountAcct);
		currencyAcct = std::move(_o.currencyAcct);
		started = std::move(_o.started);
		cardTypeByte = std::move(_o.cardTypeByte);
		paysystemName = std::move(_o.paysystemName);
	}
	return *this;
}

#endif

void CashierServer::cli::CashierHeldTransBody::clear()
{
	transId = 0;
	amountAcct = 0;
	currencyAcct.clear();
	started.setNull();
	cardTypeByte = 0;
	paysystemName.clear();
}

bool CashierServer::cli::CashierHeldTransBody::equals(const CashierHeldTransBody& _o) const
{
	return transId == _o.transId &&
		amountAcct == _o.amountAcct &&
		currencyAcct.equals(_o.currencyAcct) &&
		started.equals(_o.started) &&
		cardTypeByte == _o.cardTypeByte &&
		paysystemName.equals(_o.paysystemName);
}

const char *CashierServer::cli::CashierHeldTransBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("transId=");
	_buf.appendUint(transId);
	_buf.append(',');
	_buf.append("amountAcct=");
	_buf.appendInt(amountAcct);
	_buf.append(',');
	_buf.append("currencyAcct=");
	_buf.append(currencyAcct);
	_buf.append(',');
	_buf.append("started=");
	ThinAtf::AtfTempl<CommSrvTime>::ToTraceString(_buf, started);
	_buf.append(',');
	_buf.append("cardTypeByte=");
	_buf.appendUint(cardTypeByte);
	_buf.append(',');
	_buf.append("paysystemName=");
	_buf.append(paysystemName);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashierHeldTransBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CashierHeldTransBody())) // not empty
	{
		_body.composeUINT32(transId);
		_body.composeINT32(amountAcct);
		_body.composeString(currencyAcct);
		_body.composeSrvTime(started);
		_body.composeBYTE(cardTypeByte);
		_body.composeString(paysystemName);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierHeldTransBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(transId);
	_parser0.parseINT32(amountAcct);
	_parser0.parseStringP(currencyAcct);
	_parser0.parseSrvTime(started);
	_parser0.parseBYTE(cardTypeByte);
	_parser0.parseStringP(paysystemName);
}

/*static*/ void CashierServer::cli::CashierHeldTransBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 transId; _parser0.parseUINT32(transId);
	AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	INT32 amountAcct; _parser0.parseINT32(amountAcct);
	AtfValidator::validateInt(_descr, "amountAcct", amountAcct, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currencyAcct"); size_t szCurrencyAcct = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currencyAcct", szCurrencyAcct, _checker, __FILE__, __LINE__);
	CommSrvTime started; _parser0.parseSrvTime(started);
	AtfValidator::validateSrvDateTime(_descr, "started", started, _checker, __FILE__, __LINE__);
	BYTE cardTypeByte; _parser0.parseBYTE(cardTypeByte);
	AtfValidator::validateInt(_descr, "cardTypeByte", cardTypeByte, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "paysystemName"); size_t szPaysystemName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "paysystemName", szPaysystemName, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY(Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, transactions(std::move(_o.transactions))
	, totalOnHold(std::move(_o.totalOnHold))
	, denominatedCurrency(std::move(_o.denominatedCurrency))
	, allowToRejectFunds(std::move(_o.allowToRejectFunds))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY::operator=(Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		transactions = std::move(_o.transactions);
		totalOnHold = std::move(_o.totalOnHold);
		denominatedCurrency = std::move(_o.denominatedCurrency);
		allowToRejectFunds = std::move(_o.allowToRejectFunds);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	transactions.clear();
	totalOnHold = 0;
	denominatedCurrency.clear();
	allowToRejectFunds = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY::equals(const Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		transactions.equals(_o.transactions) &&
		totalOnHold == _o.totalOnHold &&
		denominatedCurrency.equals(_o.denominatedCurrency) &&
		allowToRejectFunds == _o.allowToRejectFunds;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("transactions=");
		transactions.toTraceString(_buf);
		_buf.append(',');
		_buf.append("totalOnHold=");
		_buf.appendInt(totalOnHold);
		_buf.append(',');
		_buf.append("denominatedCurrency=");
		_buf.append(denominatedCurrency);
		_buf.append(',');
		_buf.append("allowToRejectFunds=");
		_buf.appendUint(allowToRejectFunds);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		transactions.composeMsg(_msg);
		_msg.composeINT32(totalOnHold);
		_msg.composeString(denominatedCurrency);
		_msg.composeUINT32(allowToRejectFunds);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		transactions.parseMsg(_parser);
		_parser.parseINT32(totalOnHold);
		_parser.parseStringP(denominatedCurrency);
		_parser.parseUINT32(allowToRejectFunds);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szTransactions = ThinAtf::LAtfVector< CashierHeldTransBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("transactions"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "transactions", szTransactions, _checker, __FILE__, __LINE__);
		INT32 totalOnHold; _parser.parseINT32(totalOnHold);
		AtfValidator::validateInt(_descr, "totalOnHold", totalOnHold, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "denominatedCurrency"); size_t szDenominatedCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "denominatedCurrency", szDenominatedCurrency, _checker, __FILE__, __LINE__);
		UINT32 allowToRejectFunds; _parser.parseUINT32(allowToRejectFunds);
		AtfValidator::validateInt(_descr, "allowToRejectFunds", allowToRejectFunds, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS::equals(const Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS& _o) const
{
	return true;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS).append(")");
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS::composeMsg(CommMsgBody& _msg) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY(Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY::operator=(Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY::equals(const Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_SAVED_CARDS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS::Protocol_MSG_CASHIER_GET_SAVED_CARDS()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS::equals(const Protocol_MSG_CASHIER_GET_SAVED_CARDS& _o) const
{
	return true;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_SAVED_CARDS).append(")");
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS::composeMsg(CommMsgBody& _msg) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_SAVED_CARDS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierOneCardBody
//=================================================================

CashierServer::cli::CashierOneCardBody::CashierOneCardBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::CashierOneCardBody::CashierOneCardBody(CashierOneCardBody&& _o)
	: infoId(std::move(_o.infoId))
	, ccId(std::move(_o.ccId))
	, paysystemByte(std::move(_o.paysystemByte))
	, flagsForClient(std::move(_o.flagsForClient))
	, oldCardNumPlain(std::move(_o.oldCardNumPlain))
	, maskedCardNum(std::move(_o.maskedCardNum))
	, expYear(std::move(_o.expYear))
	, expMonth(std::move(_o.expMonth))
	, lastUse(std::move(_o.lastUse))
	, currencyProc(std::move(_o.currencyProc))
	, savedProcAmount(std::move(_o.savedProcAmount))
{
}

CashierServer::cli::CashierOneCardBody& CashierServer::cli::CashierOneCardBody::operator=(CashierOneCardBody&& _o)
{
	if(this != &_o)
	{
		infoId = std::move(_o.infoId);
		ccId = std::move(_o.ccId);
		paysystemByte = std::move(_o.paysystemByte);
		flagsForClient = std::move(_o.flagsForClient);
		oldCardNumPlain = std::move(_o.oldCardNumPlain);
		maskedCardNum = std::move(_o.maskedCardNum);
		expYear = std::move(_o.expYear);
		expMonth = std::move(_o.expMonth);
		lastUse = std::move(_o.lastUse);
		currencyProc = std::move(_o.currencyProc);
		savedProcAmount = std::move(_o.savedProcAmount);
	}
	return *this;
}

#endif

void CashierServer::cli::CashierOneCardBody::clear()
{
	infoId = 0;
	ccId = 0;
	paysystemByte = 0;
	flagsForClient = 0;
	oldCardNumPlain.clear();
	maskedCardNum.clear();
	expYear = 0;
	expMonth = 0;
	lastUse.setNull();
	currencyProc.clear();
	savedProcAmount = 0;
}

bool CashierServer::cli::CashierOneCardBody::equals(const CashierOneCardBody& _o) const
{
	return infoId == _o.infoId &&
		ccId == _o.ccId &&
		paysystemByte == _o.paysystemByte &&
		flagsForClient == _o.flagsForClient &&
		oldCardNumPlain.equals(_o.oldCardNumPlain) &&
		maskedCardNum.equals(_o.maskedCardNum) &&
		expYear == _o.expYear &&
		expMonth == _o.expMonth &&
		lastUse.equals(_o.lastUse) &&
		currencyProc.equals(_o.currencyProc) &&
		savedProcAmount == _o.savedProcAmount;
}

const char *CashierServer::cli::CashierOneCardBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("infoId=");
	_buf.appendUint(infoId);
	_buf.append(',');
	_buf.append("ccId=");
	_buf.appendUint(ccId);
	_buf.append(',');
	_buf.append("paysystemByte=");
	_buf.appendUint(paysystemByte);
	_buf.append(',');
	_buf.append("flagsForClient=");
	_buf.appendUint(flagsForClient);
	_buf.append(',');
	_buf.append("oldCardNumPlain=");
	_buf.append(oldCardNumPlain);
	_buf.append(',');
	_buf.append("maskedCardNum=");
	_buf.append(maskedCardNum);
	_buf.append(',');
	_buf.append("expYear=");
	_buf.appendUint(expYear);
	_buf.append(',');
	_buf.append("expMonth=");
	_buf.appendUint(expMonth);
	_buf.append(',');
	_buf.append("lastUse=");
	ThinAtf::AtfTempl<CommSrvTime>::ToTraceString(_buf, lastUse);
	_buf.append(',');
	_buf.append("currencyProc=");
	_buf.append(currencyProc);
	_buf.append(',');
	_buf.append("savedProcAmount=");
	_buf.appendInt(savedProcAmount);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashierOneCardBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CashierOneCardBody())) // not empty
	{
		_body.composeUINT32(infoId);
		_body.composeUINT32(ccId);
		_body.composeBYTE(paysystemByte);
		_body.composeUINT32(flagsForClient);
		_body.composeString(oldCardNumPlain);
		_body.composeString(maskedCardNum);
		_body.composeUINT16(expYear);
		_body.composeBYTE(expMonth);
		_body.composeSrvTime(lastUse);
		_body.composeString(currencyProc);
		_body.composeINT32(savedProcAmount);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierOneCardBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(infoId);
	_parser0.parseUINT32(ccId);
	_parser0.parseBYTE(paysystemByte);
	_parser0.parseUINT32(flagsForClient);
	_parser0.parseStringP(oldCardNumPlain);
	_parser0.parseStringP(maskedCardNum);
	_parser0.parseUINT16(expYear);
	_parser0.parseBYTE(expMonth);
	_parser0.parseSrvTime(lastUse);
	_parser0.parseStringP(currencyProc);
	_parser0.parseINT32(savedProcAmount);
}

/*static*/ void CashierServer::cli::CashierOneCardBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 infoId; _parser0.parseUINT32(infoId);
	AtfValidator::validateInt(_descr, "infoId", infoId, _checker, __FILE__, __LINE__);
	UINT32 ccId; _parser0.parseUINT32(ccId);
	AtfValidator::validateInt(_descr, "ccId", ccId, _checker, __FILE__, __LINE__);
	BYTE paysystemByte; _parser0.parseBYTE(paysystemByte);
	AtfValidator::validateInt(_descr, "paysystemByte", paysystemByte, _checker, __FILE__, __LINE__);
	UINT32 flagsForClient; _parser0.parseUINT32(flagsForClient);
	AtfValidator::validateInt(_descr, "flagsForClient", flagsForClient, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "oldCardNumPlain"); size_t szOldCardNumPlain = strlen(_dummy);
	AtfValidator::validateInt(_descr, "oldCardNumPlain", szOldCardNumPlain, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "maskedCardNum"); size_t szMaskedCardNum = strlen(_dummy);
	AtfValidator::validateInt(_descr, "maskedCardNum", szMaskedCardNum, _checker, __FILE__, __LINE__);
	UINT16 expYear; _parser0.parseUINT16(expYear);
	AtfValidator::validateInt(_descr, "expYear", expYear, _checker, __FILE__, __LINE__);
	BYTE expMonth; _parser0.parseBYTE(expMonth);
	AtfValidator::validateInt(_descr, "expMonth", expMonth, _checker, __FILE__, __LINE__);
	CommSrvTime lastUse; _parser0.parseSrvTime(lastUse);
	AtfValidator::validateSrvDateTime(_descr, "lastUse", lastUse, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currencyProc"); size_t szCurrencyProc = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currencyProc", szCurrencyProc, _checker, __FILE__, __LINE__);
	INT32 savedProcAmount; _parser0.parseINT32(savedProcAmount);
	AtfValidator::validateInt(_descr, "savedProcAmount", savedProcAmount, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_SAVED_CARDS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS_REPLY::Protocol_MSG_CASHIER_GET_SAVED_CARDS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS_REPLY::Protocol_MSG_CASHIER_GET_SAVED_CARDS_REPLY(Protocol_MSG_CASHIER_GET_SAVED_CARDS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, cards(std::move(_o.cards))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS_REPLY::operator=(Protocol_MSG_CASHIER_GET_SAVED_CARDS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		cards = std::move(_o.cards);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	cards.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS_REPLY::equals(const Protocol_MSG_CASHIER_GET_SAVED_CARDS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		cards.equals(_o.cards);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_SAVED_CARDS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("cards=");
		cards.toTraceString(_buf);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		cards.composeMsg(_msg);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		cards.parseMsg(_parser);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_SAVED_CARDS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szCards = ThinAtf::LAtfVector< CashierOneCardBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cards"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "cards", szCards, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_DELETE_SAVED_CARD
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD::Protocol_MSG_CASHIER_DELETE_SAVED_CARD()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD::clear()
{
	paySystemByte = 0;
	cardInfoId = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD::equals(const Protocol_MSG_CASHIER_DELETE_SAVED_CARD& _o) const
{
	return paySystemByte == _o.paySystemByte &&
		cardInfoId == _o.cardInfoId;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_DELETE_SAVED_CARD).append(")");
	_buf.append(',');
	_buf.append("paySystemByte=");
	_buf.appendUint(paySystemByte);
	_buf.append(',');
	_buf.append("cardInfoId=");
	_buf.appendUint(cardInfoId);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(paySystemByte);
	_msg.composeUINT32(cardInfoId);
}

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(paySystemByte);
	_parser.parseUINT32(cardInfoId);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_DELETE_SAVED_CARD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE paySystemByte; _parser.parseBYTE(paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	UINT32 cardInfoId; _parser.parseUINT32(cardInfoId);
	AtfValidator::validateInt(_descr, "cardInfoId", cardInfoId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_DELETE_SAVED_CARD_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD_REPLY::Protocol_MSG_CASHIER_DELETE_SAVED_CARD_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD_REPLY::Protocol_MSG_CASHIER_DELETE_SAVED_CARD_REPLY(Protocol_MSG_CASHIER_DELETE_SAVED_CARD_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD_REPLY::operator=(Protocol_MSG_CASHIER_DELETE_SAVED_CARD_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD_REPLY::equals(const Protocol_MSG_CASHIER_DELETE_SAVED_CARD_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_DELETE_SAVED_CARD_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_DELETE_SAVED_CARD_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_PLAY_TRANSFER
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER::Protocol_MSG_CASHIER_PLAY_TRANSFER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER::Protocol_MSG_CASHIER_PLAY_TRANSFER(Protocol_MSG_CASHIER_PLAY_TRANSFER&& _o)
	: userTo(std::move(_o.userTo))
	, amount64(std::move(_o.amount64))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER& CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER::operator=(Protocol_MSG_CASHIER_PLAY_TRANSFER&& _o)
{
	if(this != &_o)
	{
		userTo = std::move(_o.userTo);
		amount64 = std::move(_o.amount64);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER::clear()
{
	userTo.clear();
	amount64 = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER::equals(const Protocol_MSG_CASHIER_PLAY_TRANSFER& _o) const
{
	return userTo.equals(_o.userTo) &&
		amount64 == _o.amount64;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PLAY_TRANSFER).append(")");
	_buf.append(',');
	_buf.append("userTo=");
	_buf.append(userTo);
	_buf.append(',');
	_buf.append("amount64=");
	_buf.appendInt64(amount64);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userTo);
	_msg.composeINT64(amount64);
}

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userTo);
	_parser.parseINT64(amount64);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PLAY_TRANSFER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userTo"); size_t szUserTo = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userTo", szUserTo, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	INT64 amount64; _parser.parseINT64(amount64);
	AtfValidator::validateIntRange(_descr, "amount64", amount64, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_PLAY_TRANSFER_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER_REPLY::Protocol_MSG_CASHIER_PLAY_TRANSFER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER_REPLY::Protocol_MSG_CASHIER_PLAY_TRANSFER_REPLY(Protocol_MSG_CASHIER_PLAY_TRANSFER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER_REPLY::operator=(Protocol_MSG_CASHIER_PLAY_TRANSFER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER_REPLY::equals(const Protocol_MSG_CASHIER_PLAY_TRANSFER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PLAY_TRANSFER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_TRANSFER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PLAY_TRANSFER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_DEPOSIT_CHECK
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK::Protocol_MSG_CASHIER_DEPOSIT_CHECK()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK::Protocol_MSG_CASHIER_DEPOSIT_CHECK(Protocol_MSG_CASHIER_DEPOSIT_CHECK&& _o)
	: paySystemByte(std::move(_o.paySystemByte))
	, procAmount(std::move(_o.procAmount))
	, procCurrency(std::move(_o.procCurrency))
	, acctAmount(std::move(_o.acctAmount))
	, acctCurrency(std::move(_o.acctCurrency))
	, requestFlags(std::move(_o.requestFlags))
	, cardNum(std::move(_o.cardNum))
	, cardNumEncrypted(std::move(_o.cardNumEncrypted))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK& CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK::operator=(Protocol_MSG_CASHIER_DEPOSIT_CHECK&& _o)
{
	if(this != &_o)
	{
		paySystemByte = std::move(_o.paySystemByte);
		procAmount = std::move(_o.procAmount);
		procCurrency = std::move(_o.procCurrency);
		acctAmount = std::move(_o.acctAmount);
		acctCurrency = std::move(_o.acctCurrency);
		requestFlags = std::move(_o.requestFlags);
		cardNum = std::move(_o.cardNum);
		cardNumEncrypted = std::move(_o.cardNumEncrypted);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK::clear()
{
	paySystemByte = 0;
	procAmount = 0;
	procCurrency.clear();
	acctAmount = 0;
	acctCurrency.clear();
	requestFlags = 0;
	cardNum.clear();
	cardNumEncrypted.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK::equals(const Protocol_MSG_CASHIER_DEPOSIT_CHECK& _o) const
{
	return paySystemByte == _o.paySystemByte &&
		procAmount == _o.procAmount &&
		procCurrency.equals(_o.procCurrency) &&
		acctAmount == _o.acctAmount &&
		acctCurrency.equals(_o.acctCurrency) &&
		requestFlags == _o.requestFlags &&
		cardNum.equals(_o.cardNum) &&
		cardNumEncrypted.size() == _o.cardNumEncrypted.size() && memcmp(cardNumEncrypted.ptr(), _o.cardNumEncrypted.ptr(), cardNumEncrypted.size()) == 0;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_DEPOSIT_CHECK).append(")");
	_buf.append(',');
	_buf.append("paySystemByte=");
	_buf.appendUint(paySystemByte);
	_buf.append(',');
	_buf.append("procAmount=");
	_buf.appendInt64(procAmount);
	_buf.append(',');
	_buf.append("procCurrency=");
	_buf.append(procCurrency);
	_buf.append(',');
	_buf.append("acctAmount=");
	_buf.appendInt64(acctAmount);
	_buf.append(',');
	_buf.append("acctCurrency=");
	_buf.append(acctCurrency);
	_buf.append(',');
	_buf.append("requestFlags=");
	_buf.appendUint(requestFlags);
	_buf.append(',');
	_buf.append("cardNum=");
	_buf.append(cardNum);
	_buf.append(',');
	_buf.append("cardNumEncrypted=");
	ThinAtf::AtfTempl<PBlock>::ToTraceString(_buf, cardNumEncrypted);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(paySystemByte);
	_msg.composeINT64(procAmount);
	_msg.composeString(procCurrency);
	_msg.composeINT64(acctAmount);
	_msg.composeString(acctCurrency);
	_msg.composeUINT32(requestFlags);
	_msg.composeString(cardNum);
	_msg._composeVarBlock(cardNumEncrypted.ptr(), cardNumEncrypted.size());
}

void CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(paySystemByte);
	_parser.parseINT64(procAmount);
	_parser.parseStringP(procCurrency);
	_parser.parseINT64(acctAmount);
	_parser.parseStringP(acctCurrency);
	_parser.parseUINT32(requestFlags);
	_parser.parseStringP(cardNum);
	if(_parser.parseEnded()) return;
	_parser.parsePBlock(cardNumEncrypted);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_DEPOSIT_CHECK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE paySystemByte; _parser.parseBYTE(paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	INT64 procAmount; _parser.parseINT64(procAmount);
	AtfValidator::validateIntRange(_descr, "procAmount", procAmount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "procCurrency"); size_t szProcCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "procCurrency", szProcCurrency, 100, _checker, __FILE__, __LINE__);
	INT64 acctAmount; _parser.parseINT64(acctAmount);
	AtfValidator::validateIntRange(_descr, "acctAmount", acctAmount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "acctCurrency"); size_t szAcctCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "acctCurrency", szAcctCurrency, 100, _checker, __FILE__, __LINE__);
	UINT32 requestFlags; _parser.parseUINT32(requestFlags);
	AtfValidator::validateIntMax(_descr, "requestFlags", requestFlags, ((((UINT32)eCashierDepositCheckFlag_Last)<<1)-1), _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "cardNum"); size_t szCardNum = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "cardNum", szCardNum, CARDNUM_LEN, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	const BYTE* cardNumEncrypted; size_t szCardNumEncrypted; _parser._parseVarBlock(cardNumEncrypted, szCardNumEncrypted);  /*cardNumEncrypted*/
	AtfValidator::validateIntMax(_descr, "cardNumEncrypted", szCardNumEncrypted, 4000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierUpsellAwardBody
//=================================================================

CashierServer::cli::CashierUpsellAwardBody::CashierUpsellAwardBody()
{
	clear();
}

void CashierServer::cli::CashierUpsellAwardBody::clear()
{
	proposedProcAmount = 0;
	proposedAcctAmount = 0;
	award = 0;
	awardInAcctCurrency = 0;
}

bool CashierServer::cli::CashierUpsellAwardBody::equals(const CashierUpsellAwardBody& _o) const
{
	return proposedProcAmount == _o.proposedProcAmount &&
		proposedAcctAmount == _o.proposedAcctAmount &&
		award == _o.award &&
		awardInAcctCurrency == _o.awardInAcctCurrency;
}

const char *CashierServer::cli::CashierUpsellAwardBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("proposedProcAmount=");
	_buf.appendInt64(proposedProcAmount);
	_buf.append(',');
	_buf.append("proposedAcctAmount=");
	_buf.appendInt64(proposedAcctAmount);
	_buf.append(',');
	_buf.append("award=");
	_buf.appendInt64(award);
	_buf.append(',');
	_buf.append("awardInAcctCurrency=");
	_buf.appendInt64(awardInAcctCurrency);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashierUpsellAwardBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CashierUpsellAwardBody())) // not empty
	{
		_body.composeINT64(proposedProcAmount);
		_body.composeINT64(proposedAcctAmount);
		_body.composeINT64(award);
		_body.composeINT64(awardInAcctCurrency);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierUpsellAwardBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT64(proposedProcAmount);
	_parser0.parseINT64(proposedAcctAmount);
	_parser0.parseINT64(award);
	_parser0.parseINT64(awardInAcctCurrency);
}

/*static*/ void CashierServer::cli::CashierUpsellAwardBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT64 proposedProcAmount; _parser0.parseINT64(proposedProcAmount);
	AtfValidator::validateInt(_descr, "proposedProcAmount", proposedProcAmount, _checker, __FILE__, __LINE__);
	INT64 proposedAcctAmount; _parser0.parseINT64(proposedAcctAmount);
	AtfValidator::validateInt(_descr, "proposedAcctAmount", proposedAcctAmount, _checker, __FILE__, __LINE__);
	INT64 award; _parser0.parseINT64(award);
	AtfValidator::validateInt(_descr, "award", award, _checker, __FILE__, __LINE__);
	INT64 awardInAcctCurrency; _parser0.parseINT64(awardInAcctCurrency);
	AtfValidator::validateInt(_descr, "awardInAcctCurrency", awardInAcctCurrency, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CashierUpsellBody
//=================================================================

CashierServer::cli::CashierUpsellBody::CashierUpsellBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::CashierUpsellBody::CashierUpsellBody(CashierUpsellBody&& _o)
	: awardId(std::move(_o.awardId))
	, awardType(std::move(_o.awardType))
	, upsellCaptionText(std::move(_o.upsellCaptionText))
	, baseCurrency(std::move(_o.baseCurrency))
	, awards(std::move(_o.awards))
	, timerValueSecs(std::move(_o.timerValueSecs))
{
}

CashierServer::cli::CashierUpsellBody& CashierServer::cli::CashierUpsellBody::operator=(CashierUpsellBody&& _o)
{
	if(this != &_o)
	{
		awardId = std::move(_o.awardId);
		awardType = std::move(_o.awardType);
		upsellCaptionText = std::move(_o.upsellCaptionText);
		baseCurrency = std::move(_o.baseCurrency);
		awards = std::move(_o.awards);
		timerValueSecs = std::move(_o.timerValueSecs);
	}
	return *this;
}

#endif

void CashierServer::cli::CashierUpsellBody::clear()
{
	awardId = 0;
	awardType = 0;
	upsellCaptionText.clear();
	baseCurrency.clear();
	awards.clear();
	timerValueSecs = 0;
}

bool CashierServer::cli::CashierUpsellBody::equals(const CashierUpsellBody& _o) const
{
	return awardId == _o.awardId &&
		awardType == _o.awardType &&
		upsellCaptionText.equals(_o.upsellCaptionText) &&
		baseCurrency.equals(_o.baseCurrency) &&
		awards.equals(_o.awards) &&
		timerValueSecs == _o.timerValueSecs;
}

const char *CashierServer::cli::CashierUpsellBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("awardId=");
	_buf.appendUint(awardId);
	_buf.append(',');
	_buf.append("awardType=");
	_buf.appendInt(awardType);
	_buf.append(',');
	_buf.append("upsellCaptionText=");
	_buf.append(upsellCaptionText);
	_buf.append(',');
	_buf.append("baseCurrency=");
	_buf.append(baseCurrency);
	_buf.append(',');
	_buf.append("awards=");
	awards.toTraceString(_buf);
	_buf.append(',');
	_buf.append("timerValueSecs=");
	_buf.appendInt(timerValueSecs);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashierUpsellBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CashierUpsellBody())) // not empty
	{
		_body.composeUINT32(awardId);
		_body.composeINT32(awardType);
		_body.composeString(upsellCaptionText);
		_body.composeString(baseCurrency);
		awards.composeMsg(_body);
		_body.composeINT32(timerValueSecs);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierUpsellBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(awardId);
	_parser0.parseINT32(awardType);
	_parser0.parseStringP(upsellCaptionText);
	_parser0.parseStringP(baseCurrency);
	awards.parseMsg(_parser0);
	_parser0.parseINT32(timerValueSecs);
}

/*static*/ void CashierServer::cli::CashierUpsellBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 awardId; _parser0.parseUINT32(awardId);
	AtfValidator::validateInt(_descr, "awardId", awardId, _checker, __FILE__, __LINE__);
	INT32 awardType; _parser0.parseINT32(awardType);
	AtfValidator::validateInt(_descr, "awardType", awardType, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "upsellCaptionText"); size_t szUpsellCaptionText = strlen(_dummy);
	AtfValidator::validateInt(_descr, "upsellCaptionText", szUpsellCaptionText, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "baseCurrency"); size_t szBaseCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "baseCurrency", szBaseCurrency, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szAwards = ThinAtf::LAtfVector< CashierUpsellAwardBody, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("awards"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "awards", szAwards, _checker, __FILE__, __LINE__);
	INT32 timerValueSecs; _parser0.parseINT32(timerValueSecs);
	AtfValidator::validateInt(_descr, "timerValueSecs", timerValueSecs, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY::Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY::Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY(Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, replyFlags(std::move(_o.replyFlags))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY::operator=(Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		replyFlags = std::move(_o.replyFlags);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	replyFlags = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY::equals(const Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		replyFlags == _o.replyFlags;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_DEPOSIT_CHECK_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append(',');
		_buf.append("replyFlags=");
		_buf.appendUint(replyFlags);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		CommMsgBody _msg0;
		_msg.composeMsgBody(_msg0);
		_msg.composeUINT32(replyFlags);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		parseAnonymousMsgBody0(_parser);
		_parser.parseUINT32(replyFlags);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_DEPOSIT_CHECK_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
		UINT32 replyFlags; _parser.parseUINT32(replyFlags);
		AtfValidator::validateInt(_descr, "replyFlags", replyFlags, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

//=================================================================
//                Protocol_MSG_CASHIER_3V_PREREGISTER
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER::Protocol_MSG_CASHIER_3V_PREREGISTER()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER::equals(const Protocol_MSG_CASHIER_3V_PREREGISTER& _o) const
{
	return true;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_3V_PREREGISTER).append(")");
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER::composeMsg(CommMsgBody& _msg) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_3V_PREREGISTER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_3V_PREREGISTER_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER_REPLY::Protocol_MSG_CASHIER_3V_PREREGISTER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER_REPLY::Protocol_MSG_CASHIER_3V_PREREGISTER_REPLY(Protocol_MSG_CASHIER_3V_PREREGISTER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, signupUrl(std::move(_o.signupUrl))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER_REPLY::operator=(Protocol_MSG_CASHIER_3V_PREREGISTER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		signupUrl = std::move(_o.signupUrl);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	signupUrl.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER_REPLY::equals(const Protocol_MSG_CASHIER_3V_PREREGISTER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		signupUrl.equals(_o.signupUrl);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_3V_PREREGISTER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("signupUrl=");
		_buf.append(signupUrl);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(signupUrl);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(signupUrl);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_3V_PREREGISTER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_3V_PREREGISTER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "signupUrl"); size_t szSignupUrl = strlen(_dummy);
		AtfValidator::validateInt(_descr, "signupUrl", szSignupUrl, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    BuyPmUserBody
//=================================================================

CashierServer::cli::BuyPmUserBody::BuyPmUserBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::BuyPmUserBody::BuyPmUserBody(BuyPmUserBody&& _o)
	: addr1(std::move(_o.addr1))
	, addr2(std::move(_o.addr2))
	, city(std::move(_o.city))
	, state(std::move(_o.state))
	, country(std::move(_o.country))
	, zipCode(std::move(_o.zipCode))
	, firstName(std::move(_o.firstName))
	, lastName(std::move(_o.lastName))
{
}

CashierServer::cli::BuyPmUserBody& CashierServer::cli::BuyPmUserBody::operator=(BuyPmUserBody&& _o)
{
	if(this != &_o)
	{
		addr1 = std::move(_o.addr1);
		addr2 = std::move(_o.addr2);
		city = std::move(_o.city);
		state = std::move(_o.state);
		country = std::move(_o.country);
		zipCode = std::move(_o.zipCode);
		firstName = std::move(_o.firstName);
		lastName = std::move(_o.lastName);
	}
	return *this;
}

#endif

void CashierServer::cli::BuyPmUserBody::clear()
{
	addr1.clear();
	addr2.clear();
	city.clear();
	state.clear();
	country.clear();
	zipCode.clear();
	firstName.clear();
	lastName.clear();
}

bool CashierServer::cli::BuyPmUserBody::equals(const BuyPmUserBody& _o) const
{
	return addr1.equals(_o.addr1) &&
		addr2.equals(_o.addr2) &&
		city.equals(_o.city) &&
		state.equals(_o.state) &&
		country.equals(_o.country) &&
		zipCode.equals(_o.zipCode) &&
		firstName.equals(_o.firstName) &&
		lastName.equals(_o.lastName);
}

const char *CashierServer::cli::BuyPmUserBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("addr1=");
	_buf.append(addr1);
	_buf.append(',');
	_buf.append("addr2=");
	_buf.append(addr2);
	_buf.append(',');
	_buf.append("city=");
	_buf.append(city);
	_buf.append(',');
	_buf.append("state=");
	_buf.append(state);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("zipCode=");
	_buf.append(zipCode);
	_buf.append(',');
	_buf.append("firstName=");
	_buf.append(firstName);
	_buf.append(',');
	_buf.append("lastName=");
	_buf.append(lastName);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::BuyPmUserBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(BuyPmUserBody())) // not empty
	{
		_body.composeString(addr1);
		_body.composeString(addr2);
		_body.composeString(city);
		_body.composeString(state);
		_body.composeString(country);
		_body.composeString(zipCode);
		_body.composeString(firstName);
		_body.composeString(lastName);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::BuyPmUserBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(addr1);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(addr2);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(city);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(state);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(country);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(zipCode);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(firstName);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(lastName);
}

/*static*/ void CashierServer::cli::BuyPmUserBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "addr1"); size_t szAddr1 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "addr1", szAddr1, USER_ADDR_LEN, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "addr2"); size_t szAddr2 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "addr2", szAddr2, USER_ADDR2_LEN, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "city", szCity, USER_CITY_LEN, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "state"); size_t szState = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "state", szState, USER_STATE_LEN, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, USER_COUNTRY_LEN, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "zipCode"); size_t szZipCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "zipCode", szZipCode, USER_ZIP_LEN, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "firstName"); size_t szFirstName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "firstName", szFirstName, USER_FIRST_NAME_LEN, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "lastName"); size_t szLastName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "lastName", szLastName, USER_LAST_NAME_LEN, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    BuyPmCardBody
//=================================================================

CashierServer::cli::BuyPmCardBody::BuyPmCardBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::BuyPmCardBody::BuyPmCardBody(BuyPmCardBody&& _o)
	: cardInfoId(std::move(_o.cardInfoId))
	, cardNum(std::move(_o.cardNum))
	, cardCvv(std::move(_o.cardCvv))
	, expYear(std::move(_o.expYear))
	, expMonth(std::move(_o.expMonth))
	, encryptedCardNumAndCvv(std::move(_o.encryptedCardNumAndCvv))
{
}

CashierServer::cli::BuyPmCardBody& CashierServer::cli::BuyPmCardBody::operator=(BuyPmCardBody&& _o)
{
	if(this != &_o)
	{
		cardInfoId = std::move(_o.cardInfoId);
		cardNum = std::move(_o.cardNum);
		cardCvv = std::move(_o.cardCvv);
		expYear = std::move(_o.expYear);
		expMonth = std::move(_o.expMonth);
		encryptedCardNumAndCvv = std::move(_o.encryptedCardNumAndCvv);
	}
	return *this;
}

#endif

void CashierServer::cli::BuyPmCardBody::clear()
{
	cardInfoId = 0;
	cardNum.clear();
	cardCvv.clear();
	expYear = 0;
	expMonth = 0;
	encryptedCardNumAndCvv.clear();
}

bool CashierServer::cli::BuyPmCardBody::equals(const BuyPmCardBody& _o) const
{
	return cardInfoId == _o.cardInfoId &&
		cardNum.equals(_o.cardNum) &&
		cardCvv.equals(_o.cardCvv) &&
		expYear == _o.expYear &&
		expMonth == _o.expMonth &&
		encryptedCardNumAndCvv.size() == _o.encryptedCardNumAndCvv.size() && memcmp(encryptedCardNumAndCvv.ptr(), _o.encryptedCardNumAndCvv.ptr(), encryptedCardNumAndCvv.size()) == 0;
}

const char *CashierServer::cli::BuyPmCardBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("cardInfoId=");
	_buf.appendUint(cardInfoId);
	_buf.append(',');
	_buf.append("cardNum=");
	_buf.append(cardNum);
	_buf.append(',');
	_buf.append("cardCvv=");
	_buf.append(cardCvv);
	_buf.append(',');
	_buf.append("expYear=");
	_buf.appendUint(expYear);
	_buf.append(',');
	_buf.append("expMonth=");
	_buf.appendUint(expMonth);
	_buf.append(',');
	_buf.append("encryptedCardNumAndCvv=");
	ThinAtf::AtfTempl<PBlock>::ToTraceString(_buf, encryptedCardNumAndCvv);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::BuyPmCardBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(BuyPmCardBody())) // not empty
	{
		_body.composeUINT32(cardInfoId);
		_body.composeString(cardNum);
		_body.composeString(cardCvv);
		_body.composeUINT16(expYear);
		_body.composeBYTE(expMonth);
		_body._composeVarBlock(encryptedCardNumAndCvv.ptr(), encryptedCardNumAndCvv.size());
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::BuyPmCardBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(cardInfoId);
	_parser0.parseStringP(cardNum);
	_parser0.parseStringP(cardCvv);
	_parser0.parseUINT16(expYear);
	_parser0.parseBYTE(expMonth);
	if(_parser0.parseEnded()) return;
	_parser0.parsePBlock(encryptedCardNumAndCvv);
}

/*static*/ void CashierServer::cli::BuyPmCardBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 cardInfoId; _parser0.parseUINT32(cardInfoId);
	AtfValidator::validateInt(_descr, "cardInfoId", cardInfoId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "cardNum"); size_t szCardNum = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "cardNum", szCardNum, CARDNUM_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "cardCvv"); size_t szCardCvv = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "cardCvv", szCardCvv, CARD_CVV_LEN, _checker, __FILE__, __LINE__);
	UINT16 expYear; _parser0.parseUINT16(expYear);
	AtfValidator::validateIntMax(_descr, "expYear", expYear, 3000, _checker, __FILE__, __LINE__);
	BYTE expMonth; _parser0.parseBYTE(expMonth);
	AtfValidator::validateIntMax(_descr, "expMonth", expMonth, 12, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	const BYTE* encryptedCardNumAndCvv; size_t szEncryptedCardNumAndCvv; _parser0._parseVarBlock(encryptedCardNumAndCvv, szEncryptedCardNumAndCvv);  /*encryptedCardNumAndCvv*/
	AtfValidator::validateIntMax(_descr, "encryptedCardNumAndCvv", szEncryptedCardNumAndCvv, 4000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_BUY_PM
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM::Protocol_MSG_CASHIER_BUY_PM()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM::Protocol_MSG_CASHIER_BUY_PM(Protocol_MSG_CASHIER_BUY_PM&& _o)
	: converted(std::move(_o.converted))
	, currency(std::move(_o.currency))
	, playMoneyPurchaseAmount(std::move(_o.playMoneyPurchaseAmount))
	, userBody(std::move(_o.userBody))
	, paySystemByte(std::move(_o.paySystemByte))
	, cardBody(std::move(_o.cardBody))
	, saveCardInfoRequested(std::move(_o.saveCardInfoRequested))
	, cliPsSpecificBodyIn(std::move(_o.cliPsSpecificBodyIn))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM& CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM::operator=(Protocol_MSG_CASHIER_BUY_PM&& _o)
{
	if(this != &_o)
	{
		converted = std::move(_o.converted);
		currency = std::move(_o.currency);
		playMoneyPurchaseAmount = std::move(_o.playMoneyPurchaseAmount);
		userBody = std::move(_o.userBody);
		paySystemByte = std::move(_o.paySystemByte);
		cardBody = std::move(_o.cardBody);
		saveCardInfoRequested = std::move(_o.saveCardInfoRequested);
		cliPsSpecificBodyIn = std::move(_o.cliPsSpecificBodyIn);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM::clear()
{
	converted = 0;
	currency.clear();
	playMoneyPurchaseAmount = 0;
	userBody.clear();
	paySystemByte = 0;
	cardBody.clear();
	saveCardInfoRequested = false;
	cliPsSpecificBodyIn.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM::equals(const Protocol_MSG_CASHIER_BUY_PM& _o) const
{
	return converted == _o.converted &&
		currency.equals(_o.currency) &&
		playMoneyPurchaseAmount == _o.playMoneyPurchaseAmount &&
		userBody.equals(_o.userBody) &&
		paySystemByte == _o.paySystemByte &&
		cardBody.equals(_o.cardBody) &&
		saveCardInfoRequested == _o.saveCardInfoRequested &&
		cliPsSpecificBodyIn.equals(_o.cliPsSpecificBodyIn);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_BUY_PM).append(")");
	_buf.append(',');
	_buf.append("converted=");
	_buf.appendInt(converted);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("playMoneyPurchaseAmount=");
	_buf.appendInt64(playMoneyPurchaseAmount);
	_buf.append(',');
	_buf.append("userBody=");
	userBody.toTraceString(_buf);
	_buf.append(',');
	_buf.append("paySystemByte=");
	_buf.appendUint(paySystemByte);
	_buf.append(',');
	_buf.append("cardBody=");
	cardBody.toTraceString(_buf);
	_buf.append(',');
	_buf.append("saveCardInfoRequested=");
	_buf.appendUint(saveCardInfoRequested);
	_buf.append(',');
	_buf.append("cliPsSpecificBodyIn=");
	cliPsSpecificBodyIn.toTraceString(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(converted);
	_msg.composeString(currency);
	_msg.composeINT64(playMoneyPurchaseAmount);
	userBody.composeMsg(_msg);
	_msg.composeBYTE(paySystemByte);
	cardBody.composeMsg(_msg);
	_msg.composeBOOL(saveCardInfoRequested);
	_msg.composeMsgBody(cliPsSpecificBodyIn);
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(converted);
	_parser.parseStringP(currency);
	_parser.parseINT64(playMoneyPurchaseAmount);
	userBody.parseMsg(_parser);
	_parser.parseBYTE(paySystemByte);
	cardBody.parseMsg(_parser);
	_parser.parseBOOL(saveCardInfoRequested);
	if(_parser.parseEnded()) return;
	_parser.parseMsgBody(cliPsSpecificBodyIn);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_BUY_PM";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT32 converted; _parser.parseINT32(converted);
	AtfValidator::validateIntRange(_descr, "converted", converted, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	INT64 playMoneyPurchaseAmount; _parser.parseINT64(playMoneyPurchaseAmount);
	AtfValidator::validateIntRange(_descr, "playMoneyPurchaseAmount", playMoneyPurchaseAmount, 0, ((INT64)PINT32_MAX*CASHTRANS_PM_MULTIPLIER), _checker, __FILE__, __LINE__);
	PString _descbuf;
	BuyPmUserBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("userBody"), _fieldsWithUnparsedContent);
	BYTE paySystemByte; _parser.parseBYTE(paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	BuyPmCardBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cardBody"), _fieldsWithUnparsedContent);
	bool saveCardInfoRequested; _parser.parseBOOL(saveCardInfoRequested);
	AtfValidator::validateInt(_descr, "saveCardInfoRequested", saveCardInfoRequested, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	size_t szCliPsSpecificBodyIn; _parser.skipMsgBody(szCliPsSpecificBodyIn);  /*cliPsSpecificBodyIn*/
	AtfValidator::validateIntMax(_descr, "cliPsSpecificBodyIn", szCliPsSpecificBodyIn, 10000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_BUY_PM_COMPLETE
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_COMPLETE::Protocol_MSG_CASHIER_BUY_PM_COMPLETE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_COMPLETE::Protocol_MSG_CASHIER_BUY_PM_COMPLETE(Protocol_MSG_CASHIER_BUY_PM_COMPLETE&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, pmpApprovedPopUp(std::move(_o.pmpApprovedPopUp))
	, transId(std::move(_o.transId))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_COMPLETE& CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_COMPLETE::operator=(Protocol_MSG_CASHIER_BUY_PM_COMPLETE&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		pmpApprovedPopUp = std::move(_o.pmpApprovedPopUp);
		transId = std::move(_o.transId);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_COMPLETE::clear()
{
	errCode = 0;
	errDescr.clear();
	pmpApprovedPopUp.clear();
	transId = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_COMPLETE::equals(const Protocol_MSG_CASHIER_BUY_PM_COMPLETE& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		pmpApprovedPopUp.equals(_o.pmpApprovedPopUp) &&
		transId == _o.transId;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_COMPLETE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_BUY_PM_COMPLETE).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("pmpApprovedPopUp=");
		_buf.append(pmpApprovedPopUp);
		_buf.append(',');
		_buf.append("transId=");
		_buf.appendUint(transId);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_COMPLETE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(pmpApprovedPopUp);
		_msg.composeUINT32(transId);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_COMPLETE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(pmpApprovedPopUp);
		_parser.parseUINT32(transId);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_COMPLETE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_BUY_PM_COMPLETE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "pmpApprovedPopUp"); size_t szPmpApprovedPopUp = strlen(_dummy);
		AtfValidator::validateInt(_descr, "pmpApprovedPopUp", szPmpApprovedPopUp, _checker, __FILE__, __LINE__);
		UINT32 transId; _parser.parseUINT32(transId);
		AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_BUY_PM_CONFIRM
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_CONFIRM::Protocol_MSG_CASHIER_BUY_PM_CONFIRM()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_CONFIRM::Protocol_MSG_CASHIER_BUY_PM_CONFIRM(Protocol_MSG_CASHIER_BUY_PM_CONFIRM&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, transId(std::move(_o.transId))
	, message(std::move(_o.message))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_CONFIRM& CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_CONFIRM::operator=(Protocol_MSG_CASHIER_BUY_PM_CONFIRM&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		transId = std::move(_o.transId);
		message = std::move(_o.message);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_CONFIRM::clear()
{
	errCode = 0;
	errDescr.clear();
	transId = 0;
	message.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_CONFIRM::equals(const Protocol_MSG_CASHIER_BUY_PM_CONFIRM& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		transId == _o.transId &&
		message.equals(_o.message);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_CONFIRM::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_BUY_PM_CONFIRM).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("transId=");
		_buf.appendUint(transId);
		_buf.append(',');
		_buf.append("message=");
		_buf.append(message);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_CONFIRM::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(transId);
		_msg.composeString(message);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_CONFIRM::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(transId);
		_parser.parseStringP(message);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_CONFIRM::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_BUY_PM_CONFIRM";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 transId; _parser.parseUINT32(transId);
		AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "message"); size_t szMessage = strlen(_dummy);
		AtfValidator::validateInt(_descr, "message", szMessage, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_MBOOKERS_REDIRECTED
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_MBOOKERS_REDIRECTED::Protocol_MSG_CASHIER_MBOOKERS_REDIRECTED()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_MBOOKERS_REDIRECTED::Protocol_MSG_CASHIER_MBOOKERS_REDIRECTED(Protocol_MSG_CASHIER_MBOOKERS_REDIRECTED&& _o)
	: transId(std::move(_o.transId))
	, status(std::move(_o.status))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_MBOOKERS_REDIRECTED& CashierServer::cli::Protocol_MSG_CASHIER_MBOOKERS_REDIRECTED::operator=(Protocol_MSG_CASHIER_MBOOKERS_REDIRECTED&& _o)
{
	if(this != &_o)
	{
		transId = std::move(_o.transId);
		status = std::move(_o.status);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_MBOOKERS_REDIRECTED::clear()
{
	transId = 0;
	status = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_MBOOKERS_REDIRECTED::equals(const Protocol_MSG_CASHIER_MBOOKERS_REDIRECTED& _o) const
{
	return transId == _o.transId &&
		status == _o.status &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_MBOOKERS_REDIRECTED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_MBOOKERS_REDIRECTED).append(")");
	_buf.append(',');
	_buf.append("transId=");
	_buf.appendUint(transId);
	_buf.append(',');
	_buf.append("status=");
	_buf.appendUint(status);
	_buf.append(',');
	_buf.append("errDescr=");
	_buf.append(errDescr);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_MBOOKERS_REDIRECTED::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(transId);
	_msg.composeUINT32(status);
	_msg.composeString(errDescr);
}

void CashierServer::cli::Protocol_MSG_CASHIER_MBOOKERS_REDIRECTED::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(transId);
	_parser.parseUINT32(status);
	_parser.parseStringP(errDescr);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_MBOOKERS_REDIRECTED::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_MBOOKERS_REDIRECTED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 transId; _parser.parseUINT32(transId);
	AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	UINT32 status; _parser.parseUINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "errDescr", szErrDescr, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL::clear()
{
	storeId = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL::equals(const Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL& _o) const
{
	return storeId == _o.storeId;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PM_PURCH_ITEMS_AVAIL).append(")");
	_buf.append(',');
	_buf.append("storeId=");
	_buf.appendUint(storeId);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(storeId);
}

void CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(storeId);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PM_PURCH_ITEMS_AVAIL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 storeId; _parser.parseUINT32(storeId);
	AtfValidator::validateIntRange(_descr, "storeId", storeId, ClientPlayChipsStore_web, ClientPlayChipsStore_Last, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierPurchaseBody
//=================================================================

CashierServer::cli::CashierPurchaseBody::CashierPurchaseBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::CashierPurchaseBody::CashierPurchaseBody(CashierPurchaseBody&& _o)
	: cashPrice(std::move(_o.cashPrice))
	, currency(std::move(_o.currency))
	, playMoneyAmt(std::move(_o.playMoneyAmt))
	, productId(std::move(_o.productId))
	, itemFlags(std::move(_o.itemFlags))
	, savingRate_x1M(std::move(_o.savingRate_x1M))
{
}

CashierServer::cli::CashierPurchaseBody& CashierServer::cli::CashierPurchaseBody::operator=(CashierPurchaseBody&& _o)
{
	if(this != &_o)
	{
		cashPrice = std::move(_o.cashPrice);
		currency = std::move(_o.currency);
		playMoneyAmt = std::move(_o.playMoneyAmt);
		productId = std::move(_o.productId);
		itemFlags = std::move(_o.itemFlags);
		savingRate_x1M = std::move(_o.savingRate_x1M);
	}
	return *this;
}

#endif

void CashierServer::cli::CashierPurchaseBody::clear()
{
	cashPrice = 0;
	currency.clear();
	playMoneyAmt = 0;
	productId.clear();
	itemFlags = 0;
	savingRate_x1M = 0;
}

bool CashierServer::cli::CashierPurchaseBody::equals(const CashierPurchaseBody& _o) const
{
	return cashPrice == _o.cashPrice &&
		currency.equals(_o.currency) &&
		playMoneyAmt == _o.playMoneyAmt &&
		productId.equals(_o.productId) &&
		itemFlags == _o.itemFlags &&
		savingRate_x1M == _o.savingRate_x1M;
}

const char *CashierServer::cli::CashierPurchaseBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("cashPrice=");
	_buf.appendInt(cashPrice);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("playMoneyAmt=");
	_buf.appendInt64(playMoneyAmt);
	_buf.append(',');
	_buf.append("productId=");
	_buf.append(productId);
	_buf.append(',');
	_buf.append("itemFlags=");
	_buf.appendUint(itemFlags);
	_buf.append(',');
	_buf.append("savingRate_x1M=");
	_buf.appendInt(savingRate_x1M);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashierPurchaseBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CashierPurchaseBody())) // not empty
	{
		_body.composeINT32(cashPrice);
		_body.composeString(currency);
		_body.composeINT64(playMoneyAmt);
		_body.composeString(productId);
		_body.composeUINT32(itemFlags);
		_body.composeINT32(savingRate_x1M);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierPurchaseBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(cashPrice);
	_parser0.parseStringP(currency);
	_parser0.parseINT64(playMoneyAmt);
	_parser0.parseStringP(productId);
	_parser0.parseUINT32(itemFlags);
	_parser0.parseINT32(savingRate_x1M);
}

/*static*/ void CashierServer::cli::CashierPurchaseBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	INT32 cashPrice; _parser0.parseINT32(cashPrice);
	AtfValidator::validateInt(_descr, "cashPrice", cashPrice, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT64 playMoneyAmt; _parser0.parseINT64(playMoneyAmt);
	AtfValidator::validateInt(_descr, "playMoneyAmt", playMoneyAmt, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "productId"); size_t szProductId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "productId", szProductId, _checker, __FILE__, __LINE__);
	UINT32 itemFlags; _parser0.parseUINT32(itemFlags);
	AtfValidator::validateInt(_descr, "itemFlags", itemFlags, _checker, __FILE__, __LINE__);
	INT32 savingRate_x1M; _parser0.parseINT32(savingRate_x1M);
	AtfValidator::validateInt(_descr, "savingRate_x1M", savingRate_x1M, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY(Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, purchases(std::move(_o.purchases))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY::operator=(Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		purchases = std::move(_o.purchases);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	purchases.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY::equals(const Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		purchases.equals(_o.purchases);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("purchases=");
		purchases.toTraceString(_buf);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		purchases.composeMsg(_msg);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		purchases.parseMsg(_parser);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szPurchases = ThinAtf::LAtfVector< CashierPurchaseBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("purchases"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "purchases", szPurchases, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_BUY_PM_GOOGLE
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE::Protocol_MSG_CASHIER_BUY_PM_GOOGLE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE::Protocol_MSG_CASHIER_BUY_PM_GOOGLE(Protocol_MSG_CASHIER_BUY_PM_GOOGLE&& _o)
	: order(std::move(_o.order))
	, signature(std::move(_o.signature))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE& CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE::operator=(Protocol_MSG_CASHIER_BUY_PM_GOOGLE&& _o)
{
	if(this != &_o)
	{
		order = std::move(_o.order);
		signature = std::move(_o.signature);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE::clear()
{
	order.clear();
	signature.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE::equals(const Protocol_MSG_CASHIER_BUY_PM_GOOGLE& _o) const
{
	return order.equals(_o.order) &&
		signature.equals(_o.signature);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_BUY_PM_GOOGLE).append(")");
	_buf.append(',');
	_buf.append("order=");
	_buf.append(order);
	_buf.append(',');
	_buf.append("signature=");
	_buf.append(signature);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(order);
	_msg.composeString(signature);
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(order);
	_parser.parseStringP(signature);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_BUY_PM_GOOGLE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "order"); size_t szOrder = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "order", szOrder, 1000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "signature"); size_t szSignature = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "signature", szSignature, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierCommmonBuyPmReply
//=================================================================

CashierServer::cli::CashierCommmonBuyPmReply::CashierCommmonBuyPmReply()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::CashierCommmonBuyPmReply::CashierCommmonBuyPmReply(CashierCommmonBuyPmReply&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, pmpApprovedPopUp(std::move(_o.pmpApprovedPopUp))
	, transId(std::move(_o.transId))
{
}

CashierServer::cli::CashierCommmonBuyPmReply& CashierServer::cli::CashierCommmonBuyPmReply::operator=(CashierCommmonBuyPmReply&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		pmpApprovedPopUp = std::move(_o.pmpApprovedPopUp);
		transId = std::move(_o.transId);
	}
	return *this;
}

#endif

void CashierServer::cli::CashierCommmonBuyPmReply::clear()
{
	errCode = 0;
	errDescr.clear();
	pmpApprovedPopUp.clear();
	transId = 0;
}

bool CashierServer::cli::CashierCommmonBuyPmReply::equals(const CashierCommmonBuyPmReply& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		pmpApprovedPopUp.equals(_o.pmpApprovedPopUp) &&
		transId == _o.transId;
}

const char *CashierServer::cli::CashierCommmonBuyPmReply::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("pmpApprovedPopUp=");
		_buf.append(pmpApprovedPopUp);
		_buf.append(',');
		_buf.append("transId=");
		_buf.appendUint(transId);
	}
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashierCommmonBuyPmReply::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(pmpApprovedPopUp);
		_msg.composeUINT32(transId);
	}
}

void CashierServer::cli::CashierCommmonBuyPmReply::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(pmpApprovedPopUp);
		_parser.parseUINT32(transId);
	}
}

/*static*/ void CashierServer::cli::CashierCommmonBuyPmReply::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "pmpApprovedPopUp"); size_t szPmpApprovedPopUp = strlen(_dummy);
		AtfValidator::validateInt(_descr, "pmpApprovedPopUp", szPmpApprovedPopUp, _checker, __FILE__, __LINE__);
		UINT32 transId; _parser.parseUINT32(transId);
		AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	}
}

//=================================================================
//                Protocol_MSG_CASHIER_BUY_PM_GOOGLE_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE_REPLY::Protocol_MSG_CASHIER_BUY_PM_GOOGLE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE_REPLY::Protocol_MSG_CASHIER_BUY_PM_GOOGLE_REPLY(Protocol_MSG_CASHIER_BUY_PM_GOOGLE_REPLY&& _o)
	: reply(std::move(_o.reply))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE_REPLY::operator=(Protocol_MSG_CASHIER_BUY_PM_GOOGLE_REPLY&& _o)
{
	if(this != &_o)
	{
		reply = std::move(_o.reply);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE_REPLY::clear()
{
	reply.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE_REPLY::equals(const Protocol_MSG_CASHIER_BUY_PM_GOOGLE_REPLY& _o) const
{
	return reply.equals(_o.reply);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_BUY_PM_GOOGLE_REPLY).append(")");
	_buf.append(',');
	_buf.append("reply=");
	reply.toTraceString(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	reply.composeMsg(_msg);
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE_REPLY::parseMsg(CommMsgParser& _parser)
{
	reply.parseMsg(_parser);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_BUY_PM_GOOGLE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	CashierCommmonBuyPmReply::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("reply"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_BUY_PM_APPLE
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE::Protocol_MSG_CASHIER_BUY_PM_APPLE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE::Protocol_MSG_CASHIER_BUY_PM_APPLE(Protocol_MSG_CASHIER_BUY_PM_APPLE&& _o)
	: order(std::move(_o.order))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE& CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE::operator=(Protocol_MSG_CASHIER_BUY_PM_APPLE&& _o)
{
	if(this != &_o)
	{
		order = std::move(_o.order);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE::clear()
{
	order.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE::equals(const Protocol_MSG_CASHIER_BUY_PM_APPLE& _o) const
{
	return order.equals(_o.order);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_BUY_PM_APPLE).append(")");
	_buf.append(',');
	_buf.append("order=");
	_buf.append(order);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(order);
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(order);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_BUY_PM_APPLE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "order"); size_t szOrder = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "order", szOrder, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_BUY_PM_APPLE_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE_REPLY::Protocol_MSG_CASHIER_BUY_PM_APPLE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE_REPLY::Protocol_MSG_CASHIER_BUY_PM_APPLE_REPLY(Protocol_MSG_CASHIER_BUY_PM_APPLE_REPLY&& _o)
	: reply(std::move(_o.reply))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE_REPLY::operator=(Protocol_MSG_CASHIER_BUY_PM_APPLE_REPLY&& _o)
{
	if(this != &_o)
	{
		reply = std::move(_o.reply);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE_REPLY::clear()
{
	reply.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE_REPLY::equals(const Protocol_MSG_CASHIER_BUY_PM_APPLE_REPLY& _o) const
{
	return reply.equals(_o.reply);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_BUY_PM_APPLE_REPLY).append(")");
	_buf.append(',');
	_buf.append("reply=");
	reply.toTraceString(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	reply.composeMsg(_msg);
}

void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE_REPLY::parseMsg(CommMsgParser& _parser)
{
	reply.parseMsg(_parser);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_BUY_PM_APPLE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_BUY_PM_APPLE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	CashierCommmonBuyPmReply::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("reply"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO::clear()
{
	isForCashout = false;
	cardTypeByte = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO::equals(const Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO& _o) const
{
	return isForCashout == _o.isForCashout &&
		cardTypeByte == _o.cardTypeByte;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_ASTROPAY_BANKINFO).append(")");
	_buf.append(',');
	_buf.append("isForCashout=");
	_buf.appendUint(isForCashout);
	_buf.append(',');
	_buf.append("cardTypeByte=");
	_buf.appendUint(cardTypeByte);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBOOL(isForCashout);
	_msg.composeBYTE(cardTypeByte);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(isForCashout);
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(cardTypeByte);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_ASTROPAY_BANKINFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	bool isForCashout; _parser.parseBOOL(isForCashout);
	AtfValidator::validateInt(_descr, "isForCashout", isForCashout, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	BYTE cardTypeByte; _parser.parseBYTE(cardTypeByte);
	AtfValidator::validateIntRange(_descr, "cardTypeByte", cardTypeByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    AstropayDirectUserBankRef
//=================================================================

CashierServer::cli::AstropayDirectUserBankRef::AstropayDirectUserBankRef()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::AstropayDirectUserBankRef::AstropayDirectUserBankRef(AstropayDirectUserBankRef&& _o)
	: bankId(std::move(_o.bankId))
	, bankCode(std::move(_o.bankCode))
	, bankName(std::move(_o.bankName))
	, bankCurrency(std::move(_o.bankCurrency))
	, branchName(std::move(_o.branchName))
	, nicAlias(std::move(_o.nicAlias))
	, country(std::move(_o.country))
	, nicValue(std::move(_o.nicValue))
	, bankAccount(std::move(_o.bankAccount))
	, accountType(std::move(_o.accountType))
{
}

CashierServer::cli::AstropayDirectUserBankRef& CashierServer::cli::AstropayDirectUserBankRef::operator=(AstropayDirectUserBankRef&& _o)
{
	if(this != &_o)
	{
		bankId = std::move(_o.bankId);
		bankCode = std::move(_o.bankCode);
		bankName = std::move(_o.bankName);
		bankCurrency = std::move(_o.bankCurrency);
		branchName = std::move(_o.branchName);
		nicAlias = std::move(_o.nicAlias);
		country = std::move(_o.country);
		nicValue = std::move(_o.nicValue);
		bankAccount = std::move(_o.bankAccount);
		accountType = std::move(_o.accountType);
	}
	return *this;
}

#endif

void CashierServer::cli::AstropayDirectUserBankRef::clear()
{
	bankId = 0;
	bankCode.clear();
	bankName.clear();
	bankCurrency.clear();
	branchName.clear();
	nicAlias.clear();
	country.clear();
	nicValue.clear();
	bankAccount.clear();
	accountType.clear();
}

bool CashierServer::cli::AstropayDirectUserBankRef::equals(const AstropayDirectUserBankRef& _o) const
{
	return bankId == _o.bankId &&
		bankCode.equals(_o.bankCode) &&
		bankName.equals(_o.bankName) &&
		bankCurrency.equals(_o.bankCurrency) &&
		branchName.equals(_o.branchName) &&
		nicAlias.equals(_o.nicAlias) &&
		country.equals(_o.country) &&
		nicValue.equals(_o.nicValue) &&
		bankAccount.equals(_o.bankAccount) &&
		accountType.equals(_o.accountType);
}

const char *CashierServer::cli::AstropayDirectUserBankRef::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("bankId=");
	_buf.appendUint(bankId);
	_buf.append(',');
	_buf.append("bankCode=");
	_buf.append(bankCode);
	_buf.append(',');
	_buf.append("bankName=");
	_buf.append(bankName);
	_buf.append(',');
	_buf.append("bankCurrency=");
	_buf.append(bankCurrency);
	_buf.append(',');
	_buf.append("branchName=");
	_buf.append(branchName);
	_buf.append(',');
	_buf.append("nicAlias=");
	_buf.append(nicAlias);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("nicValue=");
	_buf.append(nicValue);
	_buf.append(',');
	_buf.append("bankAccount=");
	_buf.append(bankAccount);
	_buf.append(',');
	_buf.append("accountType=");
	_buf.append(accountType);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::AstropayDirectUserBankRef::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(bankId);
	_msg.composeString(bankCode);
	_msg.composeString(bankName);
	_msg.composeString(bankCurrency);
	_msg.composeString(branchName);
	_msg.composeString(nicAlias);
	_msg.composeString(country);
	_msg.composeString(nicValue);
	_msg.composeString(bankAccount);
	_msg.composeString(accountType);
}

void CashierServer::cli::AstropayDirectUserBankRef::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(bankId);
	_parser.parseStringP(bankCode);
	_parser.parseStringP(bankName);
	_parser.parseStringP(bankCurrency);
	_parser.parseStringP(branchName);
	_parser.parseStringP(nicAlias);
	_parser.parseStringP(country);
	_parser.parseStringP(nicValue);
	_parser.parseStringP(bankAccount);
	_parser.parseStringP(accountType);
}

/*static*/ void CashierServer::cli::AstropayDirectUserBankRef::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 bankId; _parser.parseUINT32(bankId);
	AtfValidator::validateInt(_descr, "bankId", bankId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "bankCode"); size_t szBankCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bankCode", szBankCode, ASTROPAYDIRECT_BANKCODE_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "bankName"); size_t szBankName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bankName", szBankName, ASTROPAYDIRECT_BANKNAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "bankCurrency"); size_t szBankCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bankCurrency", szBankCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "branchName"); size_t szBranchName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "branchName", szBranchName, ASTROPAYDIRECT_BRANCHNAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "nicAlias"); size_t szNicAlias = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "nicAlias", szNicAlias, ASTROPAYDIRECT_NICALIAS_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, USER_COUNTRY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "nicValue"); size_t szNicValue = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "nicValue", szNicValue, ASTROPAYDIRECT_NICVALUE_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "bankAccount"); size_t szBankAccount = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bankAccount", szBankAccount, ASTROPAYDIRECT_ACCTNUM_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "accountType"); size_t szAccountType = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "accountType", szAccountType, ASTROPAYDIRECT_ACCTTYPE_LEN, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY(Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, index(std::move(_o.index))
	, bankInfos(std::move(_o.bankInfos))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY::operator=(Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		index = std::move(_o.index);
		bankInfos = std::move(_o.bankInfos);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	index = 0;
	bankInfos.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY::equals(const Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		index == _o.index &&
		bankInfos.equals(_o.bankInfos);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("index=");
		_buf.appendInt(index);
		_buf.append(',');
		_buf.append("bankInfos=");
		bankInfos.toTraceString(_buf);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT16(index);
		bankInfos.composeMsg(_msg);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT16(index);
		bankInfos.parseMsg(_parser);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT16 index; _parser.parseINT16(index);
		AtfValidator::validateInt(_descr, "index", index, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szBankInfos = ThinAtf::LAtfVector< AstropayDirectUserBankRef, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("bankInfos"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "bankInfos", szBankInfos, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_ASTROPAY_CASHIN
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN::Protocol_MSG_CASHIER_ASTROPAY_CASHIN()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN::Protocol_MSG_CASHIER_ASTROPAY_CASHIN(Protocol_MSG_CASHIER_ASTROPAY_CASHIN&& _o)
	: bankId(std::move(_o.bankId))
	, cpf(std::move(_o.cpf))
	, amount64(std::move(_o.amount64))
	, bonusCode(std::move(_o.bonusCode))
	, cardTypeByte(std::move(_o.cardTypeByte))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN& CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN::operator=(Protocol_MSG_CASHIER_ASTROPAY_CASHIN&& _o)
{
	if(this != &_o)
	{
		bankId = std::move(_o.bankId);
		cpf = std::move(_o.cpf);
		amount64 = std::move(_o.amount64);
		bonusCode = std::move(_o.bonusCode);
		cardTypeByte = std::move(_o.cardTypeByte);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN::clear()
{
	bankId = 0;
	cpf.clear();
	amount64 = 0;
	bonusCode.clear();
	cardTypeByte = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN::equals(const Protocol_MSG_CASHIER_ASTROPAY_CASHIN& _o) const
{
	return bankId == _o.bankId &&
		cpf.equals(_o.cpf) &&
		amount64 == _o.amount64 &&
		bonusCode.equals(_o.bonusCode) &&
		cardTypeByte == _o.cardTypeByte;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_ASTROPAY_CASHIN).append(")");
	_buf.append(',');
	_buf.append("bankId=");
	_buf.appendUint(bankId);
	_buf.append(',');
	_buf.append("cpf=");
	_buf.append(cpf);
	_buf.append(',');
	_buf.append("amount64=");
	_buf.appendInt64(amount64);
	_buf.append(',');
	_buf.append("bonusCode=");
	_buf.append(bonusCode);
	_buf.append(',');
	_buf.append("cardTypeByte=");
	_buf.appendUint(cardTypeByte);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(bankId);
	_msg.composeString(cpf);
	_msg.composeINT64(amount64);
	_msg.composeString(bonusCode);
	_msg.composeBYTE(cardTypeByte);
}

void CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(bankId);
	_parser.parseStringP(cpf);
	_parser.parseINT64(amount64);
	_parser.parseStringP(bonusCode);
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(cardTypeByte);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ASTROPAY_CASHIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 bankId; _parser.parseUINT32(bankId);
	AtfValidator::validateInt(_descr, "bankId", bankId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "cpf"); size_t szCpf = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "cpf", szCpf, 100, _checker, __FILE__, __LINE__);
	INT64 amount64; _parser.parseINT64(amount64);
	AtfValidator::validateIntRange(_descr, "amount64", amount64, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "bonusCode"); size_t szBonusCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bonusCode", szBonusCode, BONUS_CODE_LEN, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	BYTE cardTypeByte; _parser.parseBYTE(cardTypeByte);
	AtfValidator::validateIntRange(_descr, "cardTypeByte", cardTypeByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT::Protocol_MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT::Protocol_MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT(Protocol_MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, redirectUrl(std::move(_o.redirectUrl))
	, amount64(std::move(_o.amount64))
	, bankInfo(std::move(_o.bankInfo))
	, cardTypeByte(std::move(_o.cardTypeByte))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT& CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT::operator=(Protocol_MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		redirectUrl = std::move(_o.redirectUrl);
		amount64 = std::move(_o.amount64);
		bankInfo = std::move(_o.bankInfo);
		cardTypeByte = std::move(_o.cardTypeByte);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT::clear()
{
	errCode = 0;
	errDescr.clear();
	redirectUrl.clear();
	amount64 = 0;
	bankInfo.clear();
	cardTypeByte = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT::equals(const Protocol_MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		redirectUrl.equals(_o.redirectUrl) &&
		amount64 == _o.amount64 &&
		bankInfo.equals(_o.bankInfo) &&
		cardTypeByte == _o.cardTypeByte;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("redirectUrl=");
		_buf.append(redirectUrl);
		_buf.append(',');
		_buf.append("amount64=");
		_buf.appendInt64(amount64);
		_buf.append(',');
		_buf.append("bankInfo=");
		bankInfo.toTraceString(_buf);
		_buf.append(',');
		_buf.append("cardTypeByte=");
		_buf.appendUint(cardTypeByte);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(redirectUrl);
		_msg.composeINT64(amount64);
		bankInfo.composeMsg(_msg);
		_msg.composeBYTE(cardTypeByte);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(redirectUrl);
		_parser.parseINT64(amount64);
		bankInfo.parseMsg(_parser);
		_parser.parseBYTE(cardTypeByte);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "redirectUrl"); size_t szRedirectUrl = strlen(_dummy);
		AtfValidator::validateInt(_descr, "redirectUrl", szRedirectUrl, _checker, __FILE__, __LINE__);
		INT64 amount64; _parser.parseINT64(amount64);
		AtfValidator::validateInt(_descr, "amount64", amount64, _checker, __FILE__, __LINE__);
		PString _descbuf;
		AstropayDirectUserBankRef::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("bankInfo"), _fieldsWithUnparsedContent);
		BYTE cardTypeByte; _parser.parseBYTE(cardTypeByte);
		AtfValidator::validateInt(_descr, "cardTypeByte", cardTypeByte, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO(Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO&& _o)
	: bankInfo(std::move(_o.bankInfo))
	, cardTypeByte(std::move(_o.cardTypeByte))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO& CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO::operator=(Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO&& _o)
{
	if(this != &_o)
	{
		bankInfo = std::move(_o.bankInfo);
		cardTypeByte = std::move(_o.cardTypeByte);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO::clear()
{
	bankInfo.clear();
	cardTypeByte = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO::equals(const Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO& _o) const
{
	return bankInfo.equals(_o.bankInfo) &&
		cardTypeByte == _o.cardTypeByte;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SAVE_ASTROPAY_BANKINFO).append(")");
	_buf.append(',');
	_buf.append("bankInfo=");
	bankInfo.toTraceString(_buf);
	_buf.append(',');
	_buf.append("cardTypeByte=");
	_buf.appendUint(cardTypeByte);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO::composeMsg(CommMsgBody& _msg) const
{
	bankInfo.composeMsg(_msg);
	_msg.composeBYTE(cardTypeByte);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO::parseMsg(CommMsgParser& _parser)
{
	bankInfo.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(cardTypeByte);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SAVE_ASTROPAY_BANKINFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	AstropayDirectUserBankRef::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("bankInfo"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	BYTE cardTypeByte; _parser.parseBYTE(cardTypeByte);
	AtfValidator::validateIntRange(_descr, "cardTypeByte", cardTypeByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY(Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY::operator=(Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY::equals(const Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT(Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT&& _o)
	: currencyDst(std::move(_o.currencyDst))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT& CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT::operator=(Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT&& _o)
{
	if(this != &_o)
	{
		currencyDst = std::move(_o.currencyDst);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT::clear()
{
	currencyDst.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT::equals(const Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT& _o) const
{
	return currencyDst.equals(_o.currencyDst);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT).append(")");
	_buf.append(',');
	_buf.append("currencyDst=");
	_buf.append(currencyDst);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(currencyDst);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(currencyDst);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "currencyDst"); size_t szCurrencyDst = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currencyDst", szCurrencyDst, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY(Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY::operator=(Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY::equals(const Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL::equals(const Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL& _o) const
{
	return true;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL).append(")");
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL::composeMsg(CommMsgBody& _msg) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY(Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY::operator=(Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY::equals(const Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO::clear()
{
	paySystemByte = cardTypePayLucky;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO::equals(const Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO& _o) const
{
	return paySystemByte == _o.paySystemByte;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_PAYLUCKY_INFO).append(")");
	_buf.append(',');
	_buf.append("paySystemByte=");
	_buf.appendUint(paySystemByte);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(paySystemByte);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(paySystemByte);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_PAYLUCKY_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE paySystemByte; _parser.parseBYTE(paySystemByte);
	{ const BYTE paySystemByte_enum[] = { cardTypePayLucky, cardTypeSightline, cardTypeSightlineNR }; AtfValidator::validateEnum(_descr, "paySystemByte", paySystemByte, paySystemByte_enum, _checker, __FILE__, __LINE__); }
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY(Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, payLuckyBalance(std::move(_o.payLuckyBalance))
	, sightLineMaxBalance(std::move(_o.sightLineMaxBalance))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY::operator=(Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		payLuckyBalance = std::move(_o.payLuckyBalance);
		sightLineMaxBalance = std::move(_o.sightLineMaxBalance);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	payLuckyBalance = 0;
	sightLineMaxBalance = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY::equals(const Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		payLuckyBalance == _o.payLuckyBalance &&
		sightLineMaxBalance == _o.sightLineMaxBalance;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("payLuckyBalance=");
		_buf.appendInt(payLuckyBalance);
		_buf.append(',');
		_buf.append("sightLineMaxBalance=");
		_buf.appendInt(sightLineMaxBalance);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(payLuckyBalance);
		_msg.composeINT32(sightLineMaxBalance);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(payLuckyBalance);
		_parser.parseINT32(sightLineMaxBalance);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 payLuckyBalance; _parser.parseINT32(payLuckyBalance);
		AtfValidator::validateInt(_descr, "payLuckyBalance", payLuckyBalance, _checker, __FILE__, __LINE__);
		INT32 sightLineMaxBalance; _parser.parseINT32(sightLineMaxBalance);
		AtfValidator::validateInt(_descr, "sightLineMaxBalance", sightLineMaxBalance, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY(Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY&& _o)
	: pin(std::move(_o.pin))
	, balanceCurrency(std::move(_o.balanceCurrency))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY& CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY::operator=(Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY&& _o)
{
	if(this != &_o)
	{
		pin = std::move(_o.pin);
		balanceCurrency = std::move(_o.balanceCurrency);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY::clear()
{
	pin.clear();
	balanceCurrency.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY::equals(const Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY& _o) const
{
	return pin.equals(_o.pin) &&
		balanceCurrency.equals(_o.balanceCurrency);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_VANILLA_AMTCURRENCY).append(")");
	_buf.append(',');
	_buf.append("pin=");
	_buf.append(pin);
	_buf.append(',');
	_buf.append("balanceCurrency=");
	_buf.append(balanceCurrency);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(pin);
	_msg.composeString(balanceCurrency);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(pin);
	_parser.parseStringP(balanceCurrency);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_VANILLA_AMTCURRENCY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "pin"); size_t szPin = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "pin", szPin, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "balanceCurrency"); size_t szBalanceCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "balanceCurrency", szBalanceCurrency, 100, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY(Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, procAmount(std::move(_o.procAmount))
	, procCurrency(std::move(_o.procCurrency))
	, balanceAmount(std::move(_o.balanceAmount))
	, balanceCurrency(std::move(_o.balanceCurrency))
	, pin(std::move(_o.pin))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY::operator=(Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		procAmount = std::move(_o.procAmount);
		procCurrency = std::move(_o.procCurrency);
		balanceAmount = std::move(_o.balanceAmount);
		balanceCurrency = std::move(_o.balanceCurrency);
		pin = std::move(_o.pin);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	procAmount = 0;
	procCurrency.clear();
	balanceAmount = 0;
	balanceCurrency.clear();
	pin.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY::equals(const Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		procAmount == _o.procAmount &&
		procCurrency.equals(_o.procCurrency) &&
		balanceAmount == _o.balanceAmount &&
		balanceCurrency.equals(_o.balanceCurrency) &&
		pin.equals(_o.pin);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("procAmount=");
		_buf.appendUint(procAmount);
		_buf.append(',');
		_buf.append("procCurrency=");
		_buf.append(procCurrency);
		_buf.append(',');
		_buf.append("balanceAmount=");
		_buf.appendUint(balanceAmount);
		_buf.append(',');
		_buf.append("balanceCurrency=");
		_buf.append(balanceCurrency);
		_buf.append(',');
		_buf.append("pin=");
		_buf.append(pin);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(procAmount);
		_msg.composeString(procCurrency);
		_msg.composeUINT32(balanceAmount);
		_msg.composeString(balanceCurrency);
		_msg.composeString(pin);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(procAmount);
		_parser.parseStringP(procCurrency);
		_parser.parseUINT32(balanceAmount);
		_parser.parseStringP(balanceCurrency);
		_parser.parseStringP(pin);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 procAmount; _parser.parseUINT32(procAmount);
		AtfValidator::validateInt(_descr, "procAmount", procAmount, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "procCurrency"); size_t szProcCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "procCurrency", szProcCurrency, _checker, __FILE__, __LINE__);
		UINT32 balanceAmount; _parser.parseUINT32(balanceAmount);
		AtfValidator::validateInt(_descr, "balanceAmount", balanceAmount, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "balanceCurrency"); size_t szBalanceCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "balanceCurrency", szBalanceCurrency, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "pin"); size_t szPin = strlen(_dummy);
		AtfValidator::validateInt(_descr, "pin", szPin, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_PLAY_MONEY_REFILL
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL::equals(const Protocol_MSG_CASHIER_PLAY_MONEY_REFILL& _o) const
{
	return true;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PLAY_MONEY_REFILL).append(")");
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL::composeMsg(CommMsgBody& _msg) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PLAY_MONEY_REFILL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierPlayMoneyCommonBody
//=================================================================

CashierServer::cli::CashierPlayMoneyCommonBody::CashierPlayMoneyCommonBody()
{
	clear();
}

void CashierServer::cli::CashierPlayMoneyCommonBody::clear()
{
	playChipsRefillPeriodSec = 0;
	playChipsAllowedForPeriodCents = 0;
	targetRefillAmountCents = 0;
	playChipsBalance = 0;
	availableForRefill = 0;
}

bool CashierServer::cli::CashierPlayMoneyCommonBody::equals(const CashierPlayMoneyCommonBody& _o) const
{
	return playChipsRefillPeriodSec == _o.playChipsRefillPeriodSec &&
		playChipsAllowedForPeriodCents == _o.playChipsAllowedForPeriodCents &&
		targetRefillAmountCents == _o.targetRefillAmountCents &&
		playChipsBalance == _o.playChipsBalance &&
		availableForRefill == _o.availableForRefill;
}

const char *CashierServer::cli::CashierPlayMoneyCommonBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("playChipsRefillPeriodSec=");
	_buf.appendInt(playChipsRefillPeriodSec);
	_buf.append(',');
	_buf.append("playChipsAllowedForPeriodCents=");
	_buf.appendInt64(playChipsAllowedForPeriodCents);
	_buf.append(',');
	_buf.append("targetRefillAmountCents=");
	_buf.appendInt64(targetRefillAmountCents);
	_buf.append(',');
	_buf.append("playChipsBalance=");
	_buf.appendInt64(playChipsBalance);
	_buf.append(',');
	_buf.append("availableForRefill=");
	_buf.appendInt64(availableForRefill);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashierPlayMoneyCommonBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CashierPlayMoneyCommonBody())) // not empty
	{
		_body.composeINT32(playChipsRefillPeriodSec);
		_body.composeINT64(playChipsAllowedForPeriodCents);
		_body.composeINT64(targetRefillAmountCents);
		_body.composeINT64(playChipsBalance);
		_body.composeINT64(availableForRefill);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierPlayMoneyCommonBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(playChipsRefillPeriodSec);
	_parser0.parseINT64(playChipsAllowedForPeriodCents);
	_parser0.parseINT64(targetRefillAmountCents);
	_parser0.parseINT64(playChipsBalance);
	_parser0.parseINT64(availableForRefill);
}

/*static*/ void CashierServer::cli::CashierPlayMoneyCommonBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 playChipsRefillPeriodSec; _parser0.parseINT32(playChipsRefillPeriodSec);
	AtfValidator::validateInt(_descr, "playChipsRefillPeriodSec", playChipsRefillPeriodSec, _checker, __FILE__, __LINE__);
	INT64 playChipsAllowedForPeriodCents; _parser0.parseINT64(playChipsAllowedForPeriodCents);
	AtfValidator::validateInt(_descr, "playChipsAllowedForPeriodCents", playChipsAllowedForPeriodCents, _checker, __FILE__, __LINE__);
	INT64 targetRefillAmountCents; _parser0.parseINT64(targetRefillAmountCents);
	AtfValidator::validateInt(_descr, "targetRefillAmountCents", targetRefillAmountCents, _checker, __FILE__, __LINE__);
	INT64 playChipsBalance; _parser0.parseINT64(playChipsBalance);
	AtfValidator::validateInt(_descr, "playChipsBalance", playChipsBalance, _checker, __FILE__, __LINE__);
	INT64 availableForRefill; _parser0.parseINT64(availableForRefill);
	AtfValidator::validateInt(_descr, "availableForRefill", availableForRefill, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CashierPlayMoneyRefillResult
//=================================================================

CashierServer::cli::CashierPlayMoneyRefillResult::CashierPlayMoneyRefillResult()
{
	clear();
}

void CashierServer::cli::CashierPlayMoneyRefillResult::clear()
{
	refillResult = 0;
	refilledAmount = 0;
	nextRefillTime.setNull();
	deltaSec = 0;
}

bool CashierServer::cli::CashierPlayMoneyRefillResult::equals(const CashierPlayMoneyRefillResult& _o) const
{
	return refillResult == _o.refillResult &&
		refilledAmount == _o.refilledAmount &&
		nextRefillTime.equals(_o.nextRefillTime) &&
		deltaSec == _o.deltaSec;
}

const char *CashierServer::cli::CashierPlayMoneyRefillResult::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("refillResult=");
	_buf.appendInt(refillResult);
	if (refillResult == ePmRefillSucceeded)
	{
		_buf.append(',');
		_buf.append("refilledAmount=");
		_buf.appendInt64(refilledAmount);
		_buf.append(',');
		_buf.append("nextRefillTime=");
		ThinAtf::AtfTempl<CommSrvTime>::ToTraceString(_buf, nextRefillTime);
		_buf.append(',');
		_buf.append("deltaSec=");
		_buf.appendInt(deltaSec);
	}
	else if (refillResult == ePmRefillAllowenceExceeded)
	{
		_buf.append(',');
		_buf.append("nextRefillTime=");
		ThinAtf::AtfTempl<CommSrvTime>::ToTraceString(_buf, nextRefillTime);
		_buf.append(',');
		_buf.append("deltaSec=");
		_buf.appendInt(deltaSec);
	}
	else if (refillResult == ePmRefillGreaterThanTarget)
	{
		_buf.append(',');
	}
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashierPlayMoneyRefillResult::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(refillResult);
	if (refillResult == ePmRefillSucceeded)
	{
		CommMsgBody _msg0;
		_msg0.composeINT64(refilledAmount);
		_msg0.composeSrvTime(nextRefillTime);
		_msg0.composeINT32(deltaSec);
		_msg.composeMsgBody(_msg0);
	}
	else if (refillResult == ePmRefillAllowenceExceeded)
	{
		CommMsgBody _msg1;
		_msg1.composeSrvTime(nextRefillTime);
		_msg1.composeINT32(deltaSec);
		_msg.composeMsgBody(_msg1);
	}
	else if (refillResult == ePmRefillGreaterThanTarget)
	{
		CommMsgBody _msg2;
		_msg.composeMsgBody(_msg2);
	}
}

void CashierServer::cli::CashierPlayMoneyRefillResult::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(refillResult);
	if (refillResult == ePmRefillSucceeded)
	{
		parseAnonymousMsgBody0(_parser);
	}
	else if (refillResult == ePmRefillAllowenceExceeded)
	{
		parseAnonymousMsgBody1(_parser);
	}
	else if (refillResult == ePmRefillGreaterThanTarget)
	{
		parseAnonymousMsgBody2(_parser);
	}
}

/*static*/ void CashierServer::cli::CashierPlayMoneyRefillResult::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT32 refillResult = 0;
	_parser.parseINT32(refillResult);
	AtfValidator::validateInt(_descr, "refillResult", refillResult, _checker, __FILE__, __LINE__);
	if (refillResult == ePmRefillSucceeded)
	{
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (refillResult == ePmRefillAllowenceExceeded)
	{
		validateAnonymousMsgBody1(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (refillResult == ePmRefillGreaterThanTarget)
	{
		validateAnonymousMsgBody2(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
}

void CashierServer::cli::CashierPlayMoneyRefillResult::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseINT64(refilledAmount);
	_parser0.parseSrvTime(nextRefillTime);
	_parser0.parseINT32(deltaSec);
}

/*static*/ void CashierServer::cli::CashierPlayMoneyRefillResult::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT64 refilledAmount; _parser0.parseINT64(refilledAmount);
	AtfValidator::validateInt(_descr, "refilledAmount", refilledAmount, _checker, __FILE__, __LINE__);
	CommSrvTime nextRefillTime; _parser0.parseSrvTime(nextRefillTime);
	AtfValidator::validateSrvDateTime(_descr, "nextRefillTime", nextRefillTime, _checker, __FILE__, __LINE__);
	INT32 deltaSec; _parser0.parseINT32(deltaSec);
	AtfValidator::validateInt(_descr, "deltaSec", deltaSec, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::CashierPlayMoneyRefillResult::parseAnonymousMsgBody1(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseSrvTime(nextRefillTime);
	_parser0.parseINT32(deltaSec);
}

/*static*/ void CashierServer::cli::CashierPlayMoneyRefillResult::validateAnonymousMsgBody1(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	CommSrvTime nextRefillTime; _parser0.parseSrvTime(nextRefillTime);
	AtfValidator::validateSrvDateTime(_descr, "nextRefillTime", nextRefillTime, _checker, __FILE__, __LINE__);
	INT32 deltaSec; _parser0.parseINT32(deltaSec);
	AtfValidator::validateInt(_descr, "deltaSec", deltaSec, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void CashierServer::cli::CashierPlayMoneyRefillResult::parseAnonymousMsgBody2(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
}

/*static*/ void CashierServer::cli::CashierPlayMoneyRefillResult::validateAnonymousMsgBody2(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

//=================================================================
//                Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_REPLY::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_REPLY::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_REPLY(Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, common(std::move(_o.common))
	, refillResult(std::move(_o.refillResult))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_REPLY::operator=(Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		common = std::move(_o.common);
		refillResult = std::move(_o.refillResult);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	common.clear();
	refillResult.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_REPLY::equals(const Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		common.equals(_o.common) &&
		refillResult.equals(_o.refillResult);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PLAY_MONEY_REFILL_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("common=");
		common.toTraceString(_buf);
		_buf.append(',');
		_buf.append("refillResult=");
		refillResult.toTraceString(_buf);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		common.composeMsg(_msg);
		refillResult.composeMsg(_msg);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		common.parseMsg(_parser);
		refillResult.parseMsg(_parser);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PLAY_MONEY_REFILL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		CashierPlayMoneyCommonBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("common"), _fieldsWithUnparsedContent);
		CashierPlayMoneyRefillResult::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("refillResult"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO::equals(const Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO& _o) const
{
	return true;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO).append(")");
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO::composeMsg(CommMsgBody& _msg) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    AdEventConfBody
//=================================================================

CashierServer::cli::AdEventConfBody::AdEventConfBody()
{
	clear();
}

void CashierServer::cli::AdEventConfBody::clear()
{
	nextAdEventTime.setNull();
	adEventPmRewardAmountCents = 0;
}

bool CashierServer::cli::AdEventConfBody::equals(const AdEventConfBody& _o) const
{
	return nextAdEventTime.equals(_o.nextAdEventTime) &&
		adEventPmRewardAmountCents == _o.adEventPmRewardAmountCents;
}

const char *CashierServer::cli::AdEventConfBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("nextAdEventTime=");
	ThinAtf::AtfTempl<CommSrvTime>::ToTraceString(_buf, nextAdEventTime);
	_buf.append(',');
	_buf.append("adEventPmRewardAmountCents=");
	_buf.appendInt64(adEventPmRewardAmountCents);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::AdEventConfBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(AdEventConfBody())) // not empty
	{
		_body.composeSrvTime(nextAdEventTime);
		_body.composeINT64(adEventPmRewardAmountCents);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::AdEventConfBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseSrvTime(nextAdEventTime);
	_parser0.parseINT64(adEventPmRewardAmountCents);
}

/*static*/ void CashierServer::cli::AdEventConfBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	CommSrvTime nextAdEventTime; _parser0.parseSrvTime(nextAdEventTime);
	AtfValidator::validateSrvDateTime(_descr, "nextAdEventTime", nextAdEventTime, _checker, __FILE__, __LINE__);
	INT64 adEventPmRewardAmountCents; _parser0.parseINT64(adEventPmRewardAmountCents);
	AtfValidator::validateInt(_descr, "adEventPmRewardAmountCents", adEventPmRewardAmountCents, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY(Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, playChipsRefillPeriodSec(std::move(_o.playChipsRefillPeriodSec))
	, playChipsAllowedForPeriodCents(std::move(_o.playChipsAllowedForPeriodCents))
	, targetRefillAmountCents(std::move(_o.targetRefillAmountCents))
	, availableForRefill(std::move(_o.availableForRefill))
	, nextRefillTime(std::move(_o.nextRefillTime))
	, userAdEventConf(std::move(_o.userAdEventConf))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY::operator=(Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		playChipsRefillPeriodSec = std::move(_o.playChipsRefillPeriodSec);
		playChipsAllowedForPeriodCents = std::move(_o.playChipsAllowedForPeriodCents);
		targetRefillAmountCents = std::move(_o.targetRefillAmountCents);
		availableForRefill = std::move(_o.availableForRefill);
		nextRefillTime = std::move(_o.nextRefillTime);
		userAdEventConf = std::move(_o.userAdEventConf);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	playChipsRefillPeriodSec = 0;
	playChipsAllowedForPeriodCents = 0;
	targetRefillAmountCents = 0;
	availableForRefill = 0;
	nextRefillTime.setNull();
	userAdEventConf.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY::equals(const Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		playChipsRefillPeriodSec == _o.playChipsRefillPeriodSec &&
		playChipsAllowedForPeriodCents == _o.playChipsAllowedForPeriodCents &&
		targetRefillAmountCents == _o.targetRefillAmountCents &&
		availableForRefill == _o.availableForRefill &&
		nextRefillTime.equals(_o.nextRefillTime) &&
		userAdEventConf.equals(_o.userAdEventConf);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("playChipsRefillPeriodSec=");
		_buf.appendInt(playChipsRefillPeriodSec);
		_buf.append(',');
		_buf.append("playChipsAllowedForPeriodCents=");
		_buf.appendInt64(playChipsAllowedForPeriodCents);
		_buf.append(',');
		_buf.append("targetRefillAmountCents=");
		_buf.appendInt64(targetRefillAmountCents);
		_buf.append(',');
		_buf.append("availableForRefill=");
		_buf.appendInt64(availableForRefill);
		_buf.append(',');
		_buf.append("nextRefillTime=");
		ThinAtf::AtfTempl<CommSrvTime>::ToTraceString(_buf, nextRefillTime);
		_buf.append(',');
		_buf.append("userAdEventConf=");
		userAdEventConf.toTraceString(_buf);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(playChipsRefillPeriodSec);
		_msg.composeINT64(playChipsAllowedForPeriodCents);
		_msg.composeINT64(targetRefillAmountCents);
		_msg.composeINT64(availableForRefill);
		_msg.composeSrvTime(nextRefillTime);
		userAdEventConf.composeMsg(_msg);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(playChipsRefillPeriodSec);
		_parser.parseINT64(playChipsAllowedForPeriodCents);
		_parser.parseINT64(targetRefillAmountCents);
		_parser.parseINT64(availableForRefill);
		_parser.parseSrvTime(nextRefillTime);
		if(_parser.parseEnded()) return;
		userAdEventConf.parseMsg(_parser);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 playChipsRefillPeriodSec; _parser.parseINT32(playChipsRefillPeriodSec);
		AtfValidator::validateInt(_descr, "playChipsRefillPeriodSec", playChipsRefillPeriodSec, _checker, __FILE__, __LINE__);
		INT64 playChipsAllowedForPeriodCents; _parser.parseINT64(playChipsAllowedForPeriodCents);
		AtfValidator::validateInt(_descr, "playChipsAllowedForPeriodCents", playChipsAllowedForPeriodCents, _checker, __FILE__, __LINE__);
		INT64 targetRefillAmountCents; _parser.parseINT64(targetRefillAmountCents);
		AtfValidator::validateInt(_descr, "targetRefillAmountCents", targetRefillAmountCents, _checker, __FILE__, __LINE__);
		INT64 availableForRefill; _parser.parseINT64(availableForRefill);
		AtfValidator::validateInt(_descr, "availableForRefill", availableForRefill, _checker, __FILE__, __LINE__);
		CommSrvTime nextRefillTime; _parser.parseSrvTime(nextRefillTime);
		AtfValidator::validateSrvDateTime(_descr, "nextRefillTime", nextRefillTime, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		PString _descbuf;
		AdEventConfBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("userAdEventConf"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_PM_WATCH2EARN_START
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START::Protocol_MSG_CASHIER_PM_WATCH2EARN_START()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START::clear()
{
	triggerType = 0;
	triggerId = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START::equals(const Protocol_MSG_CASHIER_PM_WATCH2EARN_START& _o) const
{
	return triggerType == _o.triggerType &&
		triggerId == _o.triggerId;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PM_WATCH2EARN_START).append(")");
	_buf.append(',');
	_buf.append("triggerType=");
	_buf.appendInt(triggerType);
	_buf.append(',');
	_buf.append("triggerId=");
	_buf.appendUint64(triggerId);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(triggerType);
	_msg.composeUINT64(triggerId);
}

void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(triggerType);
	_parser.parseUINT64(triggerId);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PM_WATCH2EARN_START";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 triggerType; _parser.parseINT32(triggerType);
	AtfValidator::validateIntRange(_descr, "triggerType", triggerType, ePlayMoneyAdTriggerType_Undefined, ePlayMoneyAdTriggerType_Last, _checker, __FILE__, __LINE__);
	UINT64 triggerId; _parser.parseUINT64(triggerId);
	AtfValidator::validateUint(_descr, "triggerId", triggerId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_PM_WATCH2EARN_START_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START_REPLY::Protocol_MSG_CASHIER_PM_WATCH2EARN_START_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START_REPLY::Protocol_MSG_CASHIER_PM_WATCH2EARN_START_REPLY(Protocol_MSG_CASHIER_PM_WATCH2EARN_START_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, eventId(std::move(_o.eventId))
	, nextAdEventTime(std::move(_o.nextAdEventTime))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START_REPLY::operator=(Protocol_MSG_CASHIER_PM_WATCH2EARN_START_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		eventId = std::move(_o.eventId);
		nextAdEventTime = std::move(_o.nextAdEventTime);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	eventId = 0;
	nextAdEventTime.setNull();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START_REPLY::equals(const Protocol_MSG_CASHIER_PM_WATCH2EARN_START_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		eventId == _o.eventId &&
		nextAdEventTime.equals(_o.nextAdEventTime);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PM_WATCH2EARN_START_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("eventId=");
		_buf.appendUint(eventId);
		_buf.append(',');
		_buf.append("nextAdEventTime=");
		ThinAtf::AtfTempl<CommSrvTime>::ToTraceString(_buf, nextAdEventTime);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(eventId);
		_msg.composeSrvTime(nextAdEventTime);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(eventId);
		_parser.parseSrvTime(nextAdEventTime);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PM_WATCH2EARN_START_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 eventId; _parser.parseUINT32(eventId);
		AtfValidator::validateInt(_descr, "eventId", eventId, _checker, __FILE__, __LINE__);
		CommSrvTime nextAdEventTime; _parser.parseSrvTime(nextAdEventTime);
		AtfValidator::validateSrvDateTime(_descr, "nextAdEventTime", nextAdEventTime, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH(Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH&& _o)
	: eventId(std::move(_o.eventId))
	, status(std::move(_o.status))
	, xTransStr(std::move(_o.xTransStr))
	, infoStr(std::move(_o.infoStr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH& CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH::operator=(Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH&& _o)
{
	if(this != &_o)
	{
		eventId = std::move(_o.eventId);
		status = std::move(_o.status);
		xTransStr = std::move(_o.xTransStr);
		infoStr = std::move(_o.infoStr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH::clear()
{
	eventId = 0;
	status = 0;
	xTransStr.clear();
	infoStr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH::equals(const Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH& _o) const
{
	return eventId == _o.eventId &&
		status == _o.status &&
		xTransStr.equals(_o.xTransStr) &&
		infoStr.equals(_o.infoStr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PM_WATCH2EARN_FINISH).append(")");
	_buf.append(',');
	_buf.append("eventId=");
	_buf.appendUint(eventId);
	_buf.append(',');
	_buf.append("status=");
	_buf.appendInt(status);
	_buf.append(',');
	_buf.append("xTransStr=");
	_buf.append(xTransStr);
	_buf.append(',');
	_buf.append("infoStr=");
	_buf.append(infoStr);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(eventId);
	_msg.composeINT32(status);
	_msg.composeString(xTransStr);
	_msg.composeString(infoStr);
}

void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(eventId);
	_parser.parseINT32(status);
	_parser.parseStringP(xTransStr);
	_parser.parseStringP(infoStr);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PM_WATCH2EARN_FINISH";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 eventId; _parser.parseUINT32(eventId);
	AtfValidator::validateInt(_descr, "eventId", eventId, _checker, __FILE__, __LINE__);
	INT32 status; _parser.parseINT32(status);
	AtfValidator::validateIntRange(_descr, "status", status, ePlayMoneyAdWatchResult_Complete, ePlayMoneyAdWatchResult_Last, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "xTransStr"); size_t szXTransStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "xTransStr", szXTransStr, 1000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "infoStr"); size_t szInfoStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "infoStr", szInfoStr, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY(Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY::operator=(Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY::equals(const Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS(Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS&& _o)
	: propertyTypes(std::move(_o.propertyTypes))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS& CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS::operator=(Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS&& _o)
{
	if(this != &_o)
	{
		propertyTypes = std::move(_o.propertyTypes);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS::clear()
{
	propertyTypes.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS::equals(const Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS& _o) const
{
	return propertyTypes.equals(_o.propertyTypes);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS).append(")");
	_buf.append(',');
	_buf.append("propertyTypes=");
	propertyTypes.toTraceString(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS::composeMsg(CommMsgBody& _msg) const
{
	propertyTypes.composeMsg(_msg);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS::parseMsg(CommMsgParser& _parser)
{
	propertyTypes.parseMsg(_parser);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szPropertyTypes = ThinAtf::LAtfVector< INT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("propertyTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntRange(_descr, "propertyTypes", szPropertyTypes, 1, 2000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierAccountBalanceBody
//=================================================================

CashierServer::cli::CashierAccountBalanceBody::CashierAccountBalanceBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::CashierAccountBalanceBody::CashierAccountBalanceBody(CashierAccountBalanceBody&& _o)
	: currency(std::move(_o.currency))
	, chips(std::move(_o.chips))
	, tChips(std::move(_o.tChips))
{
}

CashierServer::cli::CashierAccountBalanceBody& CashierServer::cli::CashierAccountBalanceBody::operator=(CashierAccountBalanceBody&& _o)
{
	if(this != &_o)
	{
		currency = std::move(_o.currency);
		chips = std::move(_o.chips);
		tChips = std::move(_o.tChips);
	}
	return *this;
}

#endif

void CashierServer::cli::CashierAccountBalanceBody::clear()
{
	currency.clear();
	chips = 0;
	tChips = 0;
}

bool CashierServer::cli::CashierAccountBalanceBody::equals(const CashierAccountBalanceBody& _o) const
{
	return currency.equals(_o.currency) &&
		chips == _o.chips &&
		tChips == _o.tChips;
}

const char *CashierServer::cli::CashierAccountBalanceBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("chips=");
	_buf.appendInt64(chips);
	_buf.append(',');
	_buf.append("tChips=");
	_buf.appendInt64(tChips);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashierAccountBalanceBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CashierAccountBalanceBody())) // not empty
	{
		_body.composeString(currency);
		_body.composeINT64(chips);
		_body.composeINT64(tChips);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierAccountBalanceBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(currency);
	_parser0.parseINT64(chips);
	_parser0.parseINT64(tChips);
}

/*static*/ void CashierServer::cli::CashierAccountBalanceBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT64 chips; _parser0.parseINT64(chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	INT64 tChips; _parser0.parseINT64(tChips);
	AtfValidator::validateInt(_descr, "tChips", tChips, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY(Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, userProperties(std::move(_o.userProperties))
	, flags(std::move(_o.flags))
	, flags2(std::move(_o.flags2))
	, privileges(std::move(_o.privileges))
	, privileges2(std::move(_o.privileges2))
	, privileges3(std::move(_o.privileges3))
	, playChips(std::move(_o.playChips))
	, defaultCurrency(std::move(_o.defaultCurrency))
	, totalAmountCurr(std::move(_o.totalAmountCurr))
	, accountBalances(std::move(_o.accountBalances))
	, flags3(std::move(_o.flags3))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY::operator=(Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		userProperties = std::move(_o.userProperties);
		flags = std::move(_o.flags);
		flags2 = std::move(_o.flags2);
		privileges = std::move(_o.privileges);
		privileges2 = std::move(_o.privileges2);
		privileges3 = std::move(_o.privileges3);
		playChips = std::move(_o.playChips);
		defaultCurrency = std::move(_o.defaultCurrency);
		totalAmountCurr = std::move(_o.totalAmountCurr);
		accountBalances = std::move(_o.accountBalances);
		flags3 = std::move(_o.flags3);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	userProperties.clear();
	flags = 0;
	flags2 = 0;
	privileges = 0;
	privileges2 = 0;
	privileges3 = 0;
	playChips = 0;
	defaultCurrency.clear();
	totalAmountCurr = 0;
	accountBalances.clear();
	flags3 = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY::equals(const Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		userProperties.equals(_o.userProperties) &&
		flags == _o.flags &&
		flags2 == _o.flags2 &&
		privileges == _o.privileges &&
		privileges2 == _o.privileges2 &&
		privileges3 == _o.privileges3 &&
		playChips == _o.playChips &&
		defaultCurrency.equals(_o.defaultCurrency) &&
		totalAmountCurr == _o.totalAmountCurr &&
		accountBalances.equals(_o.accountBalances) &&
		flags3 == _o.flags3;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("userProperties=");
		userProperties.toTraceString(_buf);
		_buf.append(',');
		_buf.append("flags=");
		_buf.appendUint(flags);
		_buf.append(',');
		_buf.append("flags2=");
		_buf.appendUint64(flags2);
		_buf.append(',');
		_buf.append("privileges=");
		_buf.appendUint(privileges);
		_buf.append(',');
		_buf.append("privileges2=");
		_buf.appendUint64(privileges2);
		_buf.append(',');
		_buf.append("privileges3=");
		_buf.appendUint64(privileges3);
		_buf.append(',');
		_buf.append("playChips=");
		_buf.appendInt64(playChips);
		_buf.append(',');
		_buf.append("defaultCurrency=");
		_buf.append(defaultCurrency);
		_buf.append(',');
		_buf.append("totalAmountCurr=");
		_buf.appendInt64(totalAmountCurr);
		_buf.append(',');
		_buf.append("accountBalances=");
		accountBalances.toTraceString(_buf);
		_buf.append(',');
		_buf.append("flags3=");
		_buf.appendUint64(flags3);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		userProperties.composeMsg(_msg);
		_msg.composeUINT32(flags);
		_msg.composeUINT64(flags2);
		_msg.composeUINT32(privileges);
		_msg.composeUINT64(privileges2);
		_msg.composeUINT64(privileges3);
		_msg.composeINT64(playChips);
		_msg.composeString(defaultCurrency);
		_msg.composeINT64(totalAmountCurr);
		accountBalances.composeMsg(_msg);
		_msg.composeUINT64(flags3);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		userProperties.parseMsg(_parser);
		_parser.parseUINT32(flags);
		_parser.parseUINT64(flags2);
		_parser.parseUINT32(privileges);
		_parser.parseUINT64(privileges2);
		_parser.parseUINT64(privileges3);
		_parser.parseINT64(playChips);
		_parser.parseStringP(defaultCurrency);
		_parser.parseINT64(totalAmountCurr);
		accountBalances.parseMsg(_parser);
		_parser.parseUINT64(flags3);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szUserProperties = ThinAtf::LAtfVector< CommonThin::AtfShared::UserPropertyBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("userProperties"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "userProperties", szUserProperties, _checker, __FILE__, __LINE__);
		UINT32 flags; _parser.parseUINT32(flags);
		AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
		UINT64 flags2; _parser.parseUINT64(flags2);
		AtfValidator::validateUint(_descr, "flags2", flags2, _checker, __FILE__, __LINE__);
		UINT32 privileges; _parser.parseUINT32(privileges);
		AtfValidator::validateInt(_descr, "privileges", privileges, _checker, __FILE__, __LINE__);
		UINT64 privileges2; _parser.parseUINT64(privileges2);
		AtfValidator::validateUint(_descr, "privileges2", privileges2, _checker, __FILE__, __LINE__);
		UINT64 privileges3; _parser.parseUINT64(privileges3);
		AtfValidator::validateUint(_descr, "privileges3", privileges3, _checker, __FILE__, __LINE__);
		INT64 playChips; _parser.parseINT64(playChips);
		AtfValidator::validateInt(_descr, "playChips", playChips, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "defaultCurrency"); size_t szDefaultCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "defaultCurrency", szDefaultCurrency, _checker, __FILE__, __LINE__);
		INT64 totalAmountCurr; _parser.parseINT64(totalAmountCurr);
		AtfValidator::validateInt(_descr, "totalAmountCurr", totalAmountCurr, _checker, __FILE__, __LINE__);
		int szAccountBalances = ThinAtf::LAtfVector< CashierAccountBalanceBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("accountBalances"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "accountBalances", szAccountBalances, _checker, __FILE__, __LINE__);
		UINT64 flags3; _parser.parseUINT64(flags3);
		AtfValidator::validateUint(_descr, "flags3", flags3, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS::equals(const Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS& _o) const
{
	return true;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_CURRENT_USERROLLS).append(")");
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS::composeMsg(CommMsgBody& _msg) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_CURRENT_USERROLLS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierUserRollBody
//=================================================================

CashierServer::cli::CashierUserRollBody::CashierUserRollBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::CashierUserRollBody::CashierUserRollBody(CashierUserRollBody&& _o)
	: userRollId(std::move(_o.userRollId))
	, status(std::move(_o.status))
	, oneRollDescription(std::move(_o.oneRollDescription))
	, paidFpp(std::move(_o.paidFpp))
	, paidCash(std::move(_o.paidCash))
	, initialAmount(std::move(_o.initialAmount))
	, currentAmount(std::move(_o.currentAmount))
	, currency(std::move(_o.currency))
	, surrenderValue(std::move(_o.surrenderValue))
	, collectedPoints(std::move(_o.collectedPoints))
	, totalPoints(std::move(_o.totalPoints))
	, numOfBets(std::move(_o.numOfBets))
	, clearBets(std::move(_o.clearBets))
	, expiration(std::move(_o.expiration))
	, rollFlags(std::move(_o.rollFlags))
	, flags(std::move(_o.flags))
	, rollSupportedGamesJson(std::move(_o.rollSupportedGamesJson))
	, redemptionLimit(std::move(_o.redemptionLimit))
	, shortEligibleGameNames(std::move(_o.shortEligibleGameNames))
	, longEligibleGameNames(std::move(_o.longEligibleGameNames))
	, stakes(std::move(_o.stakes))
	, clearStakes(std::move(_o.clearStakes))
	, rollBrandsMask(std::move(_o.rollBrandsMask))
	, rollRewardAssetType(std::move(_o.rollRewardAssetType))
	, rollRewardAssetId(std::move(_o.rollRewardAssetId))
	, rollVerticalMask(std::move(_o.rollVerticalMask))
{
}

CashierServer::cli::CashierUserRollBody& CashierServer::cli::CashierUserRollBody::operator=(CashierUserRollBody&& _o)
{
	if(this != &_o)
	{
		userRollId = std::move(_o.userRollId);
		status = std::move(_o.status);
		oneRollDescription = std::move(_o.oneRollDescription);
		paidFpp = std::move(_o.paidFpp);
		paidCash = std::move(_o.paidCash);
		initialAmount = std::move(_o.initialAmount);
		currentAmount = std::move(_o.currentAmount);
		currency = std::move(_o.currency);
		surrenderValue = std::move(_o.surrenderValue);
		collectedPoints = std::move(_o.collectedPoints);
		totalPoints = std::move(_o.totalPoints);
		numOfBets = std::move(_o.numOfBets);
		clearBets = std::move(_o.clearBets);
		expiration = std::move(_o.expiration);
		rollFlags = std::move(_o.rollFlags);
		flags = std::move(_o.flags);
		rollSupportedGamesJson = std::move(_o.rollSupportedGamesJson);
		redemptionLimit = std::move(_o.redemptionLimit);
		shortEligibleGameNames = std::move(_o.shortEligibleGameNames);
		longEligibleGameNames = std::move(_o.longEligibleGameNames);
		stakes = std::move(_o.stakes);
		clearStakes = std::move(_o.clearStakes);
		rollBrandsMask = std::move(_o.rollBrandsMask);
		rollRewardAssetType = std::move(_o.rollRewardAssetType);
		rollRewardAssetId = std::move(_o.rollRewardAssetId);
		rollVerticalMask = std::move(_o.rollVerticalMask);
	}
	return *this;
}

#endif

void CashierServer::cli::CashierUserRollBody::clear()
{
	userRollId = 0;
	status = 0;
	oneRollDescription.clear();
	paidFpp = 0;
	paidCash = 0;
	initialAmount = 0;
	currentAmount = 0;
	currency.clear();
	surrenderValue = 0;
	collectedPoints = 0;
	totalPoints = 0;
	numOfBets = 0;
	clearBets = 0;
	expiration.setNull();
	rollFlags = 0;
	flags = 0;
	rollSupportedGamesJson.clear();
	redemptionLimit = 0;
	shortEligibleGameNames.clear();
	longEligibleGameNames.clear();
	stakes = 0;
	clearStakes = 0;
	rollBrandsMask = 0;
	rollRewardAssetType = 0;
	rollRewardAssetId = 0;
	rollVerticalMask = 0;
}

bool CashierServer::cli::CashierUserRollBody::equals(const CashierUserRollBody& _o) const
{
	return userRollId == _o.userRollId &&
		status == _o.status &&
		oneRollDescription.equals(_o.oneRollDescription) &&
		paidFpp == _o.paidFpp &&
		paidCash == _o.paidCash &&
		initialAmount == _o.initialAmount &&
		currentAmount == _o.currentAmount &&
		currency.equals(_o.currency) &&
		surrenderValue == _o.surrenderValue &&
		collectedPoints == _o.collectedPoints &&
		totalPoints == _o.totalPoints &&
		numOfBets == _o.numOfBets &&
		clearBets == _o.clearBets &&
		expiration.equals(_o.expiration) &&
		rollFlags == _o.rollFlags &&
		flags == _o.flags &&
		rollSupportedGamesJson.equals(_o.rollSupportedGamesJson) &&
		redemptionLimit == _o.redemptionLimit &&
		shortEligibleGameNames.equals(_o.shortEligibleGameNames) &&
		longEligibleGameNames.equals(_o.longEligibleGameNames) &&
		stakes == _o.stakes &&
		clearStakes == _o.clearStakes &&
		rollBrandsMask == _o.rollBrandsMask &&
		rollRewardAssetType == _o.rollRewardAssetType &&
		rollRewardAssetId == _o.rollRewardAssetId &&
		rollVerticalMask == _o.rollVerticalMask;
}

const char *CashierServer::cli::CashierUserRollBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userRollId=");
	_buf.appendUint(userRollId);
	_buf.append(',');
	_buf.append("status=");
	_buf.appendInt(status);
	_buf.append(',');
	_buf.append("oneRollDescription=");
	_buf.append(oneRollDescription);
	_buf.append(',');
	_buf.append("paidFpp=");
	_buf.appendInt(paidFpp);
	_buf.append(',');
	_buf.append("paidCash=");
	_buf.appendInt(paidCash);
	_buf.append(',');
	_buf.append("initialAmount=");
	_buf.appendInt(initialAmount);
	_buf.append(',');
	_buf.append("currentAmount=");
	_buf.appendInt(currentAmount);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("surrenderValue=");
	_buf.appendInt(surrenderValue);
	_buf.append(',');
	_buf.append("collectedPoints=");
	_buf.appendInt(collectedPoints);
	_buf.append(',');
	_buf.append("totalPoints=");
	_buf.appendInt(totalPoints);
	_buf.append(',');
	_buf.append("numOfBets=");
	_buf.appendInt(numOfBets);
	_buf.append(',');
	_buf.append("clearBets=");
	_buf.appendInt(clearBets);
	_buf.append(',');
	_buf.append("expiration=");
	ThinAtf::AtfTempl<CommSrvTime>::ToTraceString(_buf, expiration);
	_buf.append(',');
	_buf.append("rollFlags=");
	_buf.appendUint(rollFlags);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("rollSupportedGamesJson=");
	_buf.append(rollSupportedGamesJson);
	_buf.append(',');
	_buf.append("redemptionLimit=");
	_buf.appendInt(redemptionLimit);
	_buf.append(',');
	_buf.append("shortEligibleGameNames=");
	_buf.append(shortEligibleGameNames);
	_buf.append(',');
	_buf.append("longEligibleGameNames=");
	_buf.append(longEligibleGameNames);
	_buf.append(',');
	_buf.append("stakes=");
	_buf.appendInt(stakes);
	_buf.append(',');
	_buf.append("clearStakes=");
	_buf.appendInt(clearStakes);
	_buf.append(',');
	_buf.append("rollBrandsMask=");
	_buf.appendUint(rollBrandsMask);
	_buf.append(',');
	_buf.append("rollRewardAssetType=");
	_buf.appendInt(rollRewardAssetType);
	_buf.append(',');
	_buf.append("rollRewardAssetId=");
	_buf.appendUint(rollRewardAssetId);
	_buf.append(',');
	_buf.append("rollVerticalMask=");
	_buf.appendInt(rollVerticalMask);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashierUserRollBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CashierUserRollBody())) // not empty
	{
		_body.composeUINT32(userRollId);
		_body.composeINT32(status);
		_body.composeString(oneRollDescription);
		_body.composeINT32(paidFpp);
		_body.composeINT32(paidCash);
		_body.composeINT32(initialAmount);
		_body.composeINT32(currentAmount);
		_body.composeString(currency);
		_body.composeINT32(surrenderValue);
		_body.composeINT32(collectedPoints);
		_body.composeINT32(totalPoints);
		_body.composeINT32(numOfBets);
		_body.composeINT32(clearBets);
		_body.composeSrvTime(expiration);
		_body.composeUINT32(rollFlags);
		_body.composeUINT32(flags);
		_body.composeString(rollSupportedGamesJson);
		_body.composeINT32(redemptionLimit);
		_body.composeString(shortEligibleGameNames);
		_body.composeString(longEligibleGameNames);
		_body.composeINT32(stakes);
		_body.composeINT32(clearStakes);
		_body.composeUINT32(rollBrandsMask);
		_body.composeINT32(rollRewardAssetType);
		_body.composeUINT32(rollRewardAssetId);
		_body.composeINT32(rollVerticalMask);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierUserRollBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(userRollId);
	_parser0.parseINT32(status);
	_parser0.parseStringP(oneRollDescription);
	_parser0.parseINT32(paidFpp);
	_parser0.parseINT32(paidCash);
	_parser0.parseINT32(initialAmount);
	_parser0.parseINT32(currentAmount);
	_parser0.parseStringP(currency);
	_parser0.parseINT32(surrenderValue);
	_parser0.parseINT32(collectedPoints);
	_parser0.parseINT32(totalPoints);
	_parser0.parseINT32(numOfBets);
	_parser0.parseINT32(clearBets);
	_parser0.parseSrvTime(expiration);
	_parser0.parseUINT32(rollFlags);
	_parser0.parseUINT32(flags);
	_parser0.parseStringP(rollSupportedGamesJson);
	_parser0.parseINT32(redemptionLimit);
	_parser0.parseStringP(shortEligibleGameNames);
	_parser0.parseStringP(longEligibleGameNames);
	_parser0.parseINT32(stakes);
	_parser0.parseINT32(clearStakes);
	_parser0.parseUINT32(rollBrandsMask);
	_parser0.parseINT32(rollRewardAssetType);
	_parser0.parseUINT32(rollRewardAssetId);
	_parser0.parseINT32(rollVerticalMask);
}

/*static*/ void CashierServer::cli::CashierUserRollBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 userRollId; _parser0.parseUINT32(userRollId);
	AtfValidator::validateInt(_descr, "userRollId", userRollId, _checker, __FILE__, __LINE__);
	INT32 status; _parser0.parseINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "oneRollDescription"); size_t szOneRollDescription = strlen(_dummy);
	AtfValidator::validateInt(_descr, "oneRollDescription", szOneRollDescription, _checker, __FILE__, __LINE__);
	INT32 paidFpp; _parser0.parseINT32(paidFpp);
	AtfValidator::validateInt(_descr, "paidFpp", paidFpp, _checker, __FILE__, __LINE__);
	INT32 paidCash; _parser0.parseINT32(paidCash);
	AtfValidator::validateInt(_descr, "paidCash", paidCash, _checker, __FILE__, __LINE__);
	INT32 initialAmount; _parser0.parseINT32(initialAmount);
	AtfValidator::validateInt(_descr, "initialAmount", initialAmount, _checker, __FILE__, __LINE__);
	INT32 currentAmount; _parser0.parseINT32(currentAmount);
	AtfValidator::validateInt(_descr, "currentAmount", currentAmount, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT32 surrenderValue; _parser0.parseINT32(surrenderValue);
	AtfValidator::validateInt(_descr, "surrenderValue", surrenderValue, _checker, __FILE__, __LINE__);
	INT32 collectedPoints; _parser0.parseINT32(collectedPoints);
	AtfValidator::validateInt(_descr, "collectedPoints", collectedPoints, _checker, __FILE__, __LINE__);
	INT32 totalPoints; _parser0.parseINT32(totalPoints);
	AtfValidator::validateInt(_descr, "totalPoints", totalPoints, _checker, __FILE__, __LINE__);
	INT32 numOfBets; _parser0.parseINT32(numOfBets);
	AtfValidator::validateInt(_descr, "numOfBets", numOfBets, _checker, __FILE__, __LINE__);
	INT32 clearBets; _parser0.parseINT32(clearBets);
	AtfValidator::validateInt(_descr, "clearBets", clearBets, _checker, __FILE__, __LINE__);
	CommSrvTime expiration; _parser0.parseSrvTime(expiration);
	AtfValidator::validateSrvDateTime(_descr, "expiration", expiration, _checker, __FILE__, __LINE__);
	UINT32 rollFlags; _parser0.parseUINT32(rollFlags);
	AtfValidator::validateInt(_descr, "rollFlags", rollFlags, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser0.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "rollSupportedGamesJson"); size_t szRollSupportedGamesJson = strlen(_dummy);
	AtfValidator::validateInt(_descr, "rollSupportedGamesJson", szRollSupportedGamesJson, _checker, __FILE__, __LINE__);
	INT32 redemptionLimit; _parser0.parseINT32(redemptionLimit);
	AtfValidator::validateInt(_descr, "redemptionLimit", redemptionLimit, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "shortEligibleGameNames"); size_t szShortEligibleGameNames = strlen(_dummy);
	AtfValidator::validateInt(_descr, "shortEligibleGameNames", szShortEligibleGameNames, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "longEligibleGameNames"); size_t szLongEligibleGameNames = strlen(_dummy);
	AtfValidator::validateInt(_descr, "longEligibleGameNames", szLongEligibleGameNames, _checker, __FILE__, __LINE__);
	INT32 stakes; _parser0.parseINT32(stakes);
	AtfValidator::validateInt(_descr, "stakes", stakes, _checker, __FILE__, __LINE__);
	INT32 clearStakes; _parser0.parseINT32(clearStakes);
	AtfValidator::validateInt(_descr, "clearStakes", clearStakes, _checker, __FILE__, __LINE__);
	UINT32 rollBrandsMask; _parser0.parseUINT32(rollBrandsMask);
	AtfValidator::validateInt(_descr, "rollBrandsMask", rollBrandsMask, _checker, __FILE__, __LINE__);
	INT32 rollRewardAssetType; _parser0.parseINT32(rollRewardAssetType);
	AtfValidator::validateInt(_descr, "rollRewardAssetType", rollRewardAssetType, _checker, __FILE__, __LINE__);
	UINT32 rollRewardAssetId; _parser0.parseUINT32(rollRewardAssetId);
	AtfValidator::validateInt(_descr, "rollRewardAssetId", rollRewardAssetId, _checker, __FILE__, __LINE__);
	INT32 rollVerticalMask; _parser0.parseINT32(rollVerticalMask);
	AtfValidator::validateInt(_descr, "rollVerticalMask", rollVerticalMask, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY(Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, userRolls(std::move(_o.userRolls))
	, freeSpinUserRolls(std::move(_o.freeSpinUserRolls))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY::operator=(Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		userRolls = std::move(_o.userRolls);
		freeSpinUserRolls = std::move(_o.freeSpinUserRolls);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	userRolls.clear();
	freeSpinUserRolls.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY::equals(const Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		userRolls.equals(_o.userRolls) &&
		freeSpinUserRolls.equals(_o.freeSpinUserRolls);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("userRolls=");
		userRolls.toTraceString(_buf);
		_buf.append(',');
		_buf.append("freeSpinUserRolls=");
		freeSpinUserRolls.toTraceString(_buf);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		userRolls.composeMsg(_msg);
		freeSpinUserRolls.composeMsg(_msg);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		userRolls.parseMsg(_parser);
		freeSpinUserRolls.parseMsg(_parser);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szUserRolls = ThinAtf::LAtfVector< CashierUserRollBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("userRolls"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "userRolls", szUserRolls, _checker, __FILE__, __LINE__);
		int szFreeSpinUserRolls = ThinAtf::LAtfVector< CashierUserRollBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("freeSpinUserRolls"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "freeSpinUserRolls", szFreeSpinUserRolls, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_USERROLL_STATUS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::Protocol_MSG_CASHIER_SET_USERROLL_STATUS()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::clear()
{
	status.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::equals(const Protocol_MSG_CASHIER_SET_USERROLL_STATUS& _o) const
{
	return status.equals(_o.status);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_USERROLL_STATUS).append(")");
	_buf.append(',');
	_buf.append("status=");
	status.toTraceString(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::composeMsg(CommMsgBody& _msg) const
{
	status.composeMsg(_msg);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::parseMsg(CommMsgParser& _parser)
{
	status.parseMsg(_parser);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_USERROLL_STATUS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	common_structs::SetUserRollStatus::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("status"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY(Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY&& _o)
	: reply(std::move(_o.reply))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::operator=(Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY&& _o)
{
	if(this != &_o)
	{
		reply = std::move(_o.reply);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::clear()
{
	reply.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::equals(const Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY& _o) const
{
	return reply.equals(_o.reply);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_USERROLL_STATUS_REPLY).append(")");
	_buf.append(',');
	_buf.append("reply=");
	reply.toTraceString(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	reply.composeMsg(_msg);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::parseMsg(CommMsgParser& _parser)
{
	reply.parseMsg(_parser);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_USERROLL_STATUS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	common_structs::SetUserRollStatusReply::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("reply"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierUserRollsOrderOneBody
//=================================================================

CashierServer::cli::CashierUserRollsOrderOneBody::CashierUserRollsOrderOneBody()
{
	clear();
}

void CashierServer::cli::CashierUserRollsOrderOneBody::clear()
{
	userRollId = 0;
}

bool CashierServer::cli::CashierUserRollsOrderOneBody::equals(const CashierUserRollsOrderOneBody& _o) const
{
	return userRollId == _o.userRollId;
}

const char *CashierServer::cli::CashierUserRollsOrderOneBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userRollId=");
	_buf.appendUint(userRollId);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashierUserRollsOrderOneBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CashierUserRollsOrderOneBody())) // not empty
	{
		_body.composeUINT32(userRollId);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierUserRollsOrderOneBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(userRollId);
}

/*static*/ void CashierServer::cli::CashierUserRollsOrderOneBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 userRollId; _parser0.parseUINT32(userRollId);
	AtfValidator::validateInt(_descr, "userRollId", userRollId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER(Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER&& _o)
	: userRollsOrder(std::move(_o.userRollsOrder))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER& CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER::operator=(Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER&& _o)
{
	if(this != &_o)
	{
		userRollsOrder = std::move(_o.userRollsOrder);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER::clear()
{
	userRollsOrder.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER::equals(const Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER& _o) const
{
	return userRollsOrder.equals(_o.userRollsOrder);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_UPDATE_USERROLLS_ORDER).append(")");
	_buf.append(',');
	_buf.append("userRollsOrder=");
	userRollsOrder.toTraceString(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER::composeMsg(CommMsgBody& _msg) const
{
	userRollsOrder.composeMsg(_msg);
}

void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER::parseMsg(CommMsgParser& _parser)
{
	userRollsOrder.parseMsg(_parser);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_UPDATE_USERROLLS_ORDER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szUserRollsOrder = ThinAtf::LAtfVector< CashierUserRollsOrderOneBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("userRollsOrder"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntRange(_descr, "userRollsOrder", szUserRollsOrder, 1, 10000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY(Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY::operator=(Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY::equals(const Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES::clear()
{
	privsMaskToSet = 0;
	privsMaskToClear = 0;
	privs2MaskToSet = 0;
	privs2MaskToClear = 0;
	privs3MaskToSet = 0;
	privs3MaskToClear = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES::equals(const Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES& _o) const
{
	return privsMaskToSet == _o.privsMaskToSet &&
		privsMaskToClear == _o.privsMaskToClear &&
		privs2MaskToSet == _o.privs2MaskToSet &&
		privs2MaskToClear == _o.privs2MaskToClear &&
		privs3MaskToSet == _o.privs3MaskToSet &&
		privs3MaskToClear == _o.privs3MaskToClear;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_USER_ALL_PRIVILEGES).append(")");
	_buf.append(',');
	_buf.append("privsMaskToSet=");
	_buf.appendUint(privsMaskToSet);
	_buf.append(',');
	_buf.append("privsMaskToClear=");
	_buf.appendUint(privsMaskToClear);
	_buf.append(',');
	_buf.append("privs2MaskToSet=");
	_buf.appendUint64(privs2MaskToSet);
	_buf.append(',');
	_buf.append("privs2MaskToClear=");
	_buf.appendUint64(privs2MaskToClear);
	_buf.append(',');
	_buf.append("privs3MaskToSet=");
	_buf.appendUint64(privs3MaskToSet);
	_buf.append(',');
	_buf.append("privs3MaskToClear=");
	_buf.appendUint64(privs3MaskToClear);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(privsMaskToSet);
	_msg.composeUINT32(privsMaskToClear);
	_msg.composeUINT64(privs2MaskToSet);
	_msg.composeUINT64(privs2MaskToClear);
	_msg.composeUINT64(privs3MaskToSet);
	_msg.composeUINT64(privs3MaskToClear);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(privsMaskToSet);
	_parser.parseUINT32(privsMaskToClear);
	_parser.parseUINT64(privs2MaskToSet);
	_parser.parseUINT64(privs2MaskToClear);
	_parser.parseUINT64(privs3MaskToSet);
	_parser.parseUINT64(privs3MaskToClear);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_USER_ALL_PRIVILEGES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 privsMaskToSet; _parser.parseUINT32(privsMaskToSet);
	AtfValidator::validateInt(_descr, "privsMaskToSet", privsMaskToSet, _checker, __FILE__, __LINE__);
	UINT32 privsMaskToClear; _parser.parseUINT32(privsMaskToClear);
	AtfValidator::validateInt(_descr, "privsMaskToClear", privsMaskToClear, _checker, __FILE__, __LINE__);
	UINT64 privs2MaskToSet; _parser.parseUINT64(privs2MaskToSet);
	AtfValidator::validateUintMax(_descr, "privs2MaskToSet", privs2MaskToSet, ((ONE64<<(priv2LastUsedBit+ONE64))-ONE64), _checker, __FILE__, __LINE__);
	UINT64 privs2MaskToClear; _parser.parseUINT64(privs2MaskToClear);
	AtfValidator::validateUint(_descr, "privs2MaskToClear", privs2MaskToClear, _checker, __FILE__, __LINE__);
	UINT64 privs3MaskToSet; _parser.parseUINT64(privs3MaskToSet);
	AtfValidator::validateUintMax(_descr, "privs3MaskToSet", privs3MaskToSet, ((ONE64<<(priv3LastUsedBit+ONE64))-ONE64), _checker, __FILE__, __LINE__);
	UINT64 privs3MaskToClear; _parser.parseUINT64(privs3MaskToClear);
	AtfValidator::validateUint(_descr, "privs3MaskToClear", privs3MaskToClear, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY(Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY::operator=(Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY::equals(const Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_TEXT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT::Protocol_MSG_CASHIER_GET_TEXT()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT::clear()
{
	getTextFlags = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT::equals(const Protocol_MSG_CASHIER_GET_TEXT& _o) const
{
	return getTextFlags == _o.getTextFlags;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_TEXT).append(")");
	_buf.append(',');
	_buf.append("getTextFlags=");
	_buf.appendUint(getTextFlags);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(getTextFlags);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(getTextFlags);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_TEXT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 getTextFlags; _parser.parseUINT32(getTextFlags);
	AtfValidator::validateIntMax(_descr, "getTextFlags", getTextFlags, ((((UINT32)eCashierGetTextFlags_Last)<<1)-1), _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CashierGetTextRealMoneyPopupBody
//=================================================================

CashierServer::cli::CashierGetTextRealMoneyPopupBody::CashierGetTextRealMoneyPopupBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::CashierGetTextRealMoneyPopupBody::CashierGetTextRealMoneyPopupBody(CashierGetTextRealMoneyPopupBody&& _o)
	: localizedTitle(std::move(_o.localizedTitle))
	, localizedText(std::move(_o.localizedText))
	, localizedButton(std::move(_o.localizedButton))
{
}

CashierServer::cli::CashierGetTextRealMoneyPopupBody& CashierServer::cli::CashierGetTextRealMoneyPopupBody::operator=(CashierGetTextRealMoneyPopupBody&& _o)
{
	if(this != &_o)
	{
		localizedTitle = std::move(_o.localizedTitle);
		localizedText = std::move(_o.localizedText);
		localizedButton = std::move(_o.localizedButton);
	}
	return *this;
}

#endif

void CashierServer::cli::CashierGetTextRealMoneyPopupBody::clear()
{
	localizedTitle.clear();
	localizedText.clear();
	localizedButton.clear();
}

bool CashierServer::cli::CashierGetTextRealMoneyPopupBody::equals(const CashierGetTextRealMoneyPopupBody& _o) const
{
	return localizedTitle.equals(_o.localizedTitle) &&
		localizedText.equals(_o.localizedText) &&
		localizedButton.equals(_o.localizedButton);
}

const char *CashierServer::cli::CashierGetTextRealMoneyPopupBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("localizedTitle=");
	_buf.append(localizedTitle);
	_buf.append(',');
	_buf.append("localizedText=");
	_buf.append(localizedText);
	_buf.append(',');
	_buf.append("localizedButton=");
	_buf.append(localizedButton);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashierGetTextRealMoneyPopupBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CashierGetTextRealMoneyPopupBody())) // not empty
	{
		_body.composeString(localizedTitle);
		_body.composeString(localizedText);
		_body.composeString(localizedButton);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierGetTextRealMoneyPopupBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(localizedTitle);
	_parser0.parseStringP(localizedText);
	_parser0.parseStringP(localizedButton);
}

/*static*/ void CashierServer::cli::CashierGetTextRealMoneyPopupBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "localizedTitle"); size_t szLocalizedTitle = strlen(_dummy);
	AtfValidator::validateInt(_descr, "localizedTitle", szLocalizedTitle, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "localizedText"); size_t szLocalizedText = strlen(_dummy);
	AtfValidator::validateInt(_descr, "localizedText", szLocalizedText, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "localizedButton"); size_t szLocalizedButton = strlen(_dummy);
	AtfValidator::validateInt(_descr, "localizedButton", szLocalizedButton, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CashierGetTextResponseOneBody
//=================================================================

CashierServer::cli::CashierGetTextResponseOneBody::CashierGetTextResponseOneBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::CashierGetTextResponseOneBody::CashierGetTextResponseOneBody(CashierGetTextResponseOneBody&& _o)
	: getTextFlag(std::move(_o.getTextFlag))
	, processedOk(std::move(_o.processedOk))
	, textData(std::move(_o.textData))
{
}

CashierServer::cli::CashierGetTextResponseOneBody& CashierServer::cli::CashierGetTextResponseOneBody::operator=(CashierGetTextResponseOneBody&& _o)
{
	if(this != &_o)
	{
		getTextFlag = std::move(_o.getTextFlag);
		processedOk = std::move(_o.processedOk);
		textData = std::move(_o.textData);
	}
	return *this;
}

#endif

void CashierServer::cli::CashierGetTextResponseOneBody::clear()
{
	getTextFlag = 0;
	processedOk = false;
	textData.clear();
}

bool CashierServer::cli::CashierGetTextResponseOneBody::equals(const CashierGetTextResponseOneBody& _o) const
{
	return getTextFlag == _o.getTextFlag &&
		processedOk == _o.processedOk &&
		textData.equals(_o.textData);
}

const char *CashierServer::cli::CashierGetTextResponseOneBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("getTextFlag=");
	_buf.appendInt(getTextFlag);
	_buf.append(',');
	_buf.append("processedOk=");
	_buf.appendUint(processedOk);
	_buf.append(',');
	_buf.append("textData=");
	textData.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::CashierGetTextResponseOneBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CashierGetTextResponseOneBody())) // not empty
	{
		_body.composeINT32(getTextFlag);
		_body.composeBOOL(processedOk);
		textData.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::CashierGetTextResponseOneBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(getTextFlag);
	_parser0.parseBOOL(processedOk);
	textData.parseMsg(_parser0);
}

/*static*/ void CashierServer::cli::CashierGetTextResponseOneBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 getTextFlag; _parser0.parseINT32(getTextFlag);
	AtfValidator::validateInt(_descr, "getTextFlag", getTextFlag, _checker, __FILE__, __LINE__);
	bool processedOk; _parser0.parseBOOL(processedOk);
	AtfValidator::validateInt(_descr, "processedOk", processedOk, _checker, __FILE__, __LINE__);
	PString _descbuf;
	CashierGetTextRealMoneyPopupBody::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("textData"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_TEXT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT_REPLY::Protocol_MSG_CASHIER_GET_TEXT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT_REPLY::Protocol_MSG_CASHIER_GET_TEXT_REPLY(Protocol_MSG_CASHIER_GET_TEXT_REPLY&& _o)
	: items(std::move(_o.items))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT_REPLY::operator=(Protocol_MSG_CASHIER_GET_TEXT_REPLY&& _o)
{
	if(this != &_o)
	{
		items = std::move(_o.items);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT_REPLY::clear()
{
	items.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT_REPLY::equals(const Protocol_MSG_CASHIER_GET_TEXT_REPLY& _o) const
{
	return items.equals(_o.items);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_TEXT_REPLY).append(")");
	_buf.append(',');
	_buf.append("items=");
	items.toTraceString(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	items.composeMsg(_msg);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT_REPLY::parseMsg(CommMsgParser& _parser)
{
	items.parseMsg(_parser);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEXT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_TEXT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szItems = ThinAtf::LAtfVector< CashierGetTextResponseOneBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("items"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "items", szItems, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP(Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP&& _o)
	: geoIpInfo(std::move(_o.geoIpInfo))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP& CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP::operator=(Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP&& _o)
{
	if(this != &_o)
	{
		geoIpInfo = std::move(_o.geoIpInfo);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP::clear()
{
	geoIpInfo.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP::equals(const Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP& _o) const
{
	return geoIpInfo.equals(_o.geoIpInfo);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SIGHTLINE_SIGNUP).append(")");
	_buf.append(',');
	_buf.append("geoIpInfo=");
	_buf.append(geoIpInfo);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(geoIpInfo);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(geoIpInfo);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SIGHTLINE_SIGNUP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "geoIpInfo"); size_t szGeoIpInfo = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "geoIpInfo", szGeoIpInfo, 10000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY(Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY::operator=(Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY::equals(const Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP::equals(const Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP& _o) const
{
	return true;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_VALINNARELOAD_SIGNUP).append(")");
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP::composeMsg(CommMsgBody& _msg) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_VALINNARELOAD_SIGNUP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY(Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY::operator=(Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY::equals(const Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE::equals(const Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE& _o) const
{
	return true;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_VALINNARELOAD_GET_BARCODE).append(")");
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE::composeMsg(CommMsgBody& _msg) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_VALINNARELOAD_GET_BARCODE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY(Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY::operator=(Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY::equals(const Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::clear()
{
	status.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::equals(const Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS& _o) const
{
	return status.equals(_o.status);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_GAMETICKET_STATUS).append(")");
	_buf.append(',');
	_buf.append("status=");
	status.toTraceString(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::composeMsg(CommMsgBody& _msg) const
{
	status.composeMsg(_msg);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::parseMsg(CommMsgParser& _parser)
{
	status.parseMsg(_parser);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_GAMETICKET_STATUS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	common_structs::SetGameTicketStatus::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("status"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY(Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY&& _o)
	: reply(std::move(_o.reply))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::operator=(Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY&& _o)
{
	if(this != &_o)
	{
		reply = std::move(_o.reply);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::clear()
{
	reply.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::equals(const Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY& _o) const
{
	return reply.equals(_o.reply);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY).append(")");
	_buf.append(',');
	_buf.append("reply=");
	reply.toTraceString(_buf);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	reply.composeMsg(_msg);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::parseMsg(CommMsgParser& _parser)
{
	reply.parseMsg(_parser);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	common_structs::SetGameTicketStatusReply::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("reply"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION::clear()
{
	setNotRemove = false;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION::equals(const Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION& _o) const
{
	return setNotRemove == _o.setNotRemove;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION).append(")");
	_buf.append(',');
	_buf.append("setNotRemove=");
	_buf.appendUint(setNotRemove);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBOOL(setNotRemove);
}

void CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(setNotRemove);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	bool setNotRemove; _parser.parseBOOL(setNotRemove);
	AtfValidator::validateInt(_descr, "setNotRemove", setNotRemove, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY(Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY::operator=(Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY::equals(const Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT(Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT&& _o)
	: totalAmountNeeded(std::move(_o.totalAmountNeeded))
	, currency(std::move(_o.currency))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT& CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT::operator=(Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT&& _o)
{
	if(this != &_o)
	{
		totalAmountNeeded = std::move(_o.totalAmountNeeded);
		currency = std::move(_o.currency);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT::clear()
{
	totalAmountNeeded = 0;
	currency.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT::equals(const Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT& _o) const
{
	return totalAmountNeeded == _o.totalAmountNeeded &&
		currency.equals(_o.currency);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT).append(")");
	_buf.append(',');
	_buf.append("totalAmountNeeded=");
	_buf.appendInt(totalAmountNeeded);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(totalAmountNeeded);
	_msg.composeString(currency);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(totalAmountNeeded);
	_parser.parseStringP(currency);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT32 totalAmountNeeded; _parser.parseINT32(totalAmountNeeded);
	AtfValidator::validateIntRange(_descr, "totalAmountNeeded", totalAmountNeeded, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY(Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, amountAfter(std::move(_o.amountAfter))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY::operator=(Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		amountAfter = std::move(_o.amountAfter);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	amountAfter = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY::equals(const Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		amountAfter == _o.amountAfter;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("amountAfter=");
		_buf.appendInt(amountAfter);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(amountAfter);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(amountAfter);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 amountAfter; _parser.parseINT32(amountAfter);
		AtfValidator::validateInt(_descr, "amountAfter", amountAfter, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE(Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE&& _o)
	: targetCurrency(std::move(_o.targetCurrency))
	, convActionTypeInt(std::move(_o.convActionTypeInt))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE& CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE::operator=(Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE&& _o)
{
	if(this != &_o)
	{
		targetCurrency = std::move(_o.targetCurrency);
		convActionTypeInt = std::move(_o.convActionTypeInt);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE::clear()
{
	targetCurrency.clear();
	convActionTypeInt = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE::equals(const Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE& _o) const
{
	return targetCurrency.equals(_o.targetCurrency) &&
		convActionTypeInt == _o.convActionTypeInt;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_DENOMINATED_BALANCE).append(")");
	_buf.append(',');
	_buf.append("targetCurrency=");
	_buf.append(targetCurrency);
	_buf.append(',');
	_buf.append("convActionTypeInt=");
	_buf.appendInt(convActionTypeInt);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(targetCurrency);
	_msg.composeINT32(convActionTypeInt);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(targetCurrency);
	_parser.parseINT32(convActionTypeInt);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_DENOMINATED_BALANCE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "targetCurrency"); size_t szTargetCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "targetCurrency", szTargetCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	INT32 convActionTypeInt; _parser.parseINT32(convActionTypeInt);
	AtfValidator::validateIntRange(_descr, "convActionTypeInt", convActionTypeInt, eConvActionDefault, eConvActionPoolBettingLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    DenominatedBalanceOneAccBody
//=================================================================

CashierServer::cli::DenominatedBalanceOneAccBody::DenominatedBalanceOneAccBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::DenominatedBalanceOneAccBody::DenominatedBalanceOneAccBody(DenominatedBalanceOneAccBody&& _o)
	: acctCurrency(std::move(_o.acctCurrency))
	, convRate_x100M(std::move(_o.convRate_x100M))
	, chips(std::move(_o.chips))
	, chipsInTC(std::move(_o.chipsInTC))
	, tChips(std::move(_o.tChips))
	, tChipsInTC(std::move(_o.tChipsInTC))
{
}

CashierServer::cli::DenominatedBalanceOneAccBody& CashierServer::cli::DenominatedBalanceOneAccBody::operator=(DenominatedBalanceOneAccBody&& _o)
{
	if(this != &_o)
	{
		acctCurrency = std::move(_o.acctCurrency);
		convRate_x100M = std::move(_o.convRate_x100M);
		chips = std::move(_o.chips);
		chipsInTC = std::move(_o.chipsInTC);
		tChips = std::move(_o.tChips);
		tChipsInTC = std::move(_o.tChipsInTC);
	}
	return *this;
}

#endif

void CashierServer::cli::DenominatedBalanceOneAccBody::clear()
{
	acctCurrency.clear();
	convRate_x100M = 0;
	chips = 0;
	chipsInTC = 0;
	tChips = 0;
	tChipsInTC = 0;
}

bool CashierServer::cli::DenominatedBalanceOneAccBody::equals(const DenominatedBalanceOneAccBody& _o) const
{
	return acctCurrency.equals(_o.acctCurrency) &&
		convRate_x100M == _o.convRate_x100M &&
		chips == _o.chips &&
		chipsInTC == _o.chipsInTC &&
		tChips == _o.tChips &&
		tChipsInTC == _o.tChipsInTC;
}

const char *CashierServer::cli::DenominatedBalanceOneAccBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("acctCurrency=");
	_buf.append(acctCurrency);
	_buf.append(',');
	_buf.append("convRate_x100M=");
	_buf.appendInt64(convRate_x100M);
	_buf.append(',');
	_buf.append("chips=");
	_buf.appendInt64(chips);
	_buf.append(',');
	_buf.append("chipsInTC=");
	_buf.appendInt64(chipsInTC);
	_buf.append(',');
	_buf.append("tChips=");
	_buf.appendInt64(tChips);
	_buf.append(',');
	_buf.append("tChipsInTC=");
	_buf.appendInt64(tChipsInTC);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::DenominatedBalanceOneAccBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(DenominatedBalanceOneAccBody())) // not empty
	{
		_body.composeString(acctCurrency);
		_body.composeINT64(convRate_x100M);
		_body.composeINT64(chips);
		_body.composeINT64(chipsInTC);
		_body.composeINT64(tChips);
		_body.composeINT64(tChipsInTC);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::DenominatedBalanceOneAccBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(acctCurrency);
	_parser0.parseINT64(convRate_x100M);
	_parser0.parseINT64(chips);
	_parser0.parseINT64(chipsInTC);
	_parser0.parseINT64(tChips);
	_parser0.parseINT64(tChipsInTC);
}

/*static*/ void CashierServer::cli::DenominatedBalanceOneAccBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "acctCurrency"); size_t szAcctCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "acctCurrency", szAcctCurrency, _checker, __FILE__, __LINE__);
	INT64 convRate_x100M; _parser0.parseINT64(convRate_x100M);
	AtfValidator::validateInt(_descr, "convRate_x100M", convRate_x100M, _checker, __FILE__, __LINE__);
	INT64 chips; _parser0.parseINT64(chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	INT64 chipsInTC; _parser0.parseINT64(chipsInTC);
	AtfValidator::validateInt(_descr, "chipsInTC", chipsInTC, _checker, __FILE__, __LINE__);
	INT64 tChips; _parser0.parseINT64(tChips);
	AtfValidator::validateInt(_descr, "tChips", tChips, _checker, __FILE__, __LINE__);
	INT64 tChipsInTC; _parser0.parseINT64(tChipsInTC);
	AtfValidator::validateInt(_descr, "tChipsInTC", tChipsInTC, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY(Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, targetCurrency(std::move(_o.targetCurrency))
	, denominatedBalanceAccs(std::move(_o.denominatedBalanceAccs))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY::operator=(Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		targetCurrency = std::move(_o.targetCurrency);
		denominatedBalanceAccs = std::move(_o.denominatedBalanceAccs);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	targetCurrency.clear();
	denominatedBalanceAccs.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY::equals(const Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		targetCurrency.equals(_o.targetCurrency) &&
		denominatedBalanceAccs.equals(_o.denominatedBalanceAccs);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("targetCurrency=");
		_buf.append(targetCurrency);
		_buf.append(',');
		_buf.append("denominatedBalanceAccs=");
		denominatedBalanceAccs.toTraceString(_buf);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(targetCurrency);
		denominatedBalanceAccs.composeMsg(_msg);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(targetCurrency);
		denominatedBalanceAccs.parseMsg(_parser);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "targetCurrency"); size_t szTargetCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "targetCurrency", szTargetCurrency, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szDenominatedBalanceAccs = ThinAtf::LAtfVector< DenominatedBalanceOneAccBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("denominatedBalanceAccs"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "denominatedBalanceAccs", szDenominatedBalanceAccs, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_STARSWALLET_REGISTER
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER::Protocol_MSG_CASHIER_STARSWALLET_REGISTER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER::Protocol_MSG_CASHIER_STARSWALLET_REGISTER(Protocol_MSG_CASHIER_STARSWALLET_REGISTER&& _o)
	: mobilePhone(std::move(_o.mobilePhone))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER& CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER::operator=(Protocol_MSG_CASHIER_STARSWALLET_REGISTER&& _o)
{
	if(this != &_o)
	{
		mobilePhone = std::move(_o.mobilePhone);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER::clear()
{
	mobilePhone.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER::equals(const Protocol_MSG_CASHIER_STARSWALLET_REGISTER& _o) const
{
	return mobilePhone.equals(_o.mobilePhone);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_STARSWALLET_REGISTER).append(")");
	_buf.append(',');
	_buf.append("mobilePhone=");
	_buf.append(mobilePhone);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(mobilePhone);
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(mobilePhone);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_STARSWALLET_REGISTER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "mobilePhone"); size_t szMobilePhone = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "mobilePhone", szMobilePhone, USER_MOBILE_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_STARSWALLET_REGISTER_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER_REPLY::Protocol_MSG_CASHIER_STARSWALLET_REGISTER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER_REPLY::Protocol_MSG_CASHIER_STARSWALLET_REGISTER_REPLY(Protocol_MSG_CASHIER_STARSWALLET_REGISTER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER_REPLY::operator=(Protocol_MSG_CASHIER_STARSWALLET_REGISTER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER_REPLY::equals(const Protocol_MSG_CASHIER_STARSWALLET_REGISTER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_STARSWALLET_REGISTER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_STARSWALLET_REGISTER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE(Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE&& _o)
	: newMobileNumber(std::move(_o.newMobileNumber))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE& CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE::operator=(Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE&& _o)
{
	if(this != &_o)
	{
		newMobileNumber = std::move(_o.newMobileNumber);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE::clear()
{
	newMobileNumber.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE::equals(const Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE& _o) const
{
	return newMobileNumber.equals(_o.newMobileNumber);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_STARSWALLET_CHANGE_MOBILE).append(")");
	_buf.append(',');
	_buf.append("newMobileNumber=");
	_buf.append(newMobileNumber);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(newMobileNumber);
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(newMobileNumber);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_STARSWALLET_CHANGE_MOBILE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "newMobileNumber"); size_t szNewMobileNumber = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "newMobileNumber", szNewMobileNumber, USER_MOBILE_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY(Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY::operator=(Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY::equals(const Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP::equals(const Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP& _o) const
{
	return true;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_STARSWALLET_RESEND_OTP).append(")");
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP::composeMsg(CommMsgBody& _msg) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_STARSWALLET_RESEND_OTP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY(Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY::operator=(Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY::equals(const Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED::equals(const Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED& _o) const
{
	return true;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_STARSWALLET_OTP_RECEIVED).append(")");
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED::composeMsg(CommMsgBody& _msg) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_STARSWALLET_OTP_RECEIVED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY(Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY::operator=(Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY::equals(const Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO::clear()
{
	cashoutAmount = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO::equals(const Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO& _o) const
{
	return cashoutAmount == _o.cashoutAmount;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_IND_USER_TAX_INFO).append(")");
	_buf.append(',');
	_buf.append("cashoutAmount=");
	_buf.appendInt(cashoutAmount);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(cashoutAmount);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(cashoutAmount);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_IND_USER_TAX_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 cashoutAmount; _parser.parseINT32(cashoutAmount);
	AtfValidator::validateIntRange(_descr, "cashoutAmount", cashoutAmount, -1, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY(Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, taxAmount(std::move(_o.taxAmount))
	, totalBalance(std::move(_o.totalBalance))
	, unUsedBalance(std::move(_o.unUsedBalance))
	, taxableCashout(std::move(_o.taxableCashout))
	, indiaTaxFreeCashout(std::move(_o.indiaTaxFreeCashout))
	, indiaTaxRate_x1M(std::move(_o.indiaTaxRate_x1M))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY::operator=(Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		taxAmount = std::move(_o.taxAmount);
		totalBalance = std::move(_o.totalBalance);
		unUsedBalance = std::move(_o.unUsedBalance);
		taxableCashout = std::move(_o.taxableCashout);
		indiaTaxFreeCashout = std::move(_o.indiaTaxFreeCashout);
		indiaTaxRate_x1M = std::move(_o.indiaTaxRate_x1M);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	taxAmount = 0;
	totalBalance = 0;
	unUsedBalance = 0;
	taxableCashout = 0;
	indiaTaxFreeCashout = 0;
	indiaTaxRate_x1M = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY::equals(const Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		taxAmount == _o.taxAmount &&
		totalBalance == _o.totalBalance &&
		unUsedBalance == _o.unUsedBalance &&
		taxableCashout == _o.taxableCashout &&
		indiaTaxFreeCashout == _o.indiaTaxFreeCashout &&
		indiaTaxRate_x1M == _o.indiaTaxRate_x1M;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("taxAmount=");
		_buf.appendInt(taxAmount);
		_buf.append(',');
		_buf.append("totalBalance=");
		_buf.appendInt(totalBalance);
		_buf.append(',');
		_buf.append("unUsedBalance=");
		_buf.appendInt(unUsedBalance);
		_buf.append(',');
		_buf.append("taxableCashout=");
		_buf.appendInt(taxableCashout);
		_buf.append(',');
		_buf.append("indiaTaxFreeCashout=");
		_buf.appendInt(indiaTaxFreeCashout);
		_buf.append(',');
		_buf.append("indiaTaxRate_x1M=");
		_buf.appendInt(indiaTaxRate_x1M);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(taxAmount);
		_msg.composeINT32(totalBalance);
		_msg.composeINT32(unUsedBalance);
		_msg.composeINT32(taxableCashout);
		_msg.composeINT32(indiaTaxFreeCashout);
		_msg.composeINT32(indiaTaxRate_x1M);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(taxAmount);
		_parser.parseINT32(totalBalance);
		_parser.parseINT32(unUsedBalance);
		_parser.parseINT32(taxableCashout);
		_parser.parseINT32(indiaTaxFreeCashout);
		_parser.parseINT32(indiaTaxRate_x1M);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 taxAmount; _parser.parseINT32(taxAmount);
		AtfValidator::validateInt(_descr, "taxAmount", taxAmount, _checker, __FILE__, __LINE__);
		INT32 totalBalance; _parser.parseINT32(totalBalance);
		AtfValidator::validateInt(_descr, "totalBalance", totalBalance, _checker, __FILE__, __LINE__);
		INT32 unUsedBalance; _parser.parseINT32(unUsedBalance);
		AtfValidator::validateInt(_descr, "unUsedBalance", unUsedBalance, _checker, __FILE__, __LINE__);
		INT32 taxableCashout; _parser.parseINT32(taxableCashout);
		AtfValidator::validateInt(_descr, "taxableCashout", taxableCashout, _checker, __FILE__, __LINE__);
		INT32 indiaTaxFreeCashout; _parser.parseINT32(indiaTaxFreeCashout);
		AtfValidator::validateInt(_descr, "indiaTaxFreeCashout", indiaTaxFreeCashout, _checker, __FILE__, __LINE__);
		INT32 indiaTaxRate_x1M; _parser.parseINT32(indiaTaxRate_x1M);
		AtfValidator::validateInt(_descr, "indiaTaxRate_x1M", indiaTaxRate_x1M, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CC_BIN_CHECK
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK::Protocol_MSG_CASHIER_CC_BIN_CHECK()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK::Protocol_MSG_CASHIER_CC_BIN_CHECK(Protocol_MSG_CASHIER_CC_BIN_CHECK&& _o)
	: cardBin(std::move(_o.cardBin))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK& CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK::operator=(Protocol_MSG_CASHIER_CC_BIN_CHECK&& _o)
{
	if(this != &_o)
	{
		cardBin = std::move(_o.cardBin);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK::clear()
{
	cardBin.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK::equals(const Protocol_MSG_CASHIER_CC_BIN_CHECK& _o) const
{
	return cardBin.equals(_o.cardBin);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CC_BIN_CHECK).append(")");
	_buf.append(',');
	_buf.append("cardBin=");
	_buf.append(cardBin);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(cardBin);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(cardBin);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CC_BIN_CHECK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "cardBin"); size_t szCardBin = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "cardBin", szCardBin, 100, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CC_BIN_CHECK_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK_REPLY::Protocol_MSG_CASHIER_CC_BIN_CHECK_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK_REPLY::Protocol_MSG_CASHIER_CC_BIN_CHECK_REPLY(Protocol_MSG_CASHIER_CC_BIN_CHECK_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, bHostile(std::move(_o.bHostile))
	, paySystemByte(std::move(_o.paySystemByte))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK_REPLY::operator=(Protocol_MSG_CASHIER_CC_BIN_CHECK_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		bHostile = std::move(_o.bHostile);
		paySystemByte = std::move(_o.paySystemByte);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	bHostile = false;
	paySystemByte = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK_REPLY::equals(const Protocol_MSG_CASHIER_CC_BIN_CHECK_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		bHostile == _o.bHostile &&
		paySystemByte == _o.paySystemByte;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CC_BIN_CHECK_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("bHostile=");
		_buf.appendUint(bHostile);
		_buf.append(',');
		_buf.append("paySystemByte=");
		_buf.appendUint(paySystemByte);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeBOOL(bHostile);
		_msg.composeBYTE(paySystemByte);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseBOOL(bHostile);
		_parser.parseBYTE(paySystemByte);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CC_BIN_CHECK_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CC_BIN_CHECK_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool bHostile; _parser.parseBOOL(bHostile);
		AtfValidator::validateInt(_descr, "bHostile", bHostile, _checker, __FILE__, __LINE__);
		BYTE paySystemByte; _parser.parseBYTE(paySystemByte);
		AtfValidator::validateInt(_descr, "paySystemByte", paySystemByte, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_BONUS_CHECK
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK::Protocol_MSG_CASHIER_BONUS_CHECK()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK::Protocol_MSG_CASHIER_BONUS_CHECK(Protocol_MSG_CASHIER_BONUS_CHECK&& _o)
	: paySystemByte(std::move(_o.paySystemByte))
	, bonusCode(std::move(_o.bonusCode))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK& CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK::operator=(Protocol_MSG_CASHIER_BONUS_CHECK&& _o)
{
	if(this != &_o)
	{
		paySystemByte = std::move(_o.paySystemByte);
		bonusCode = std::move(_o.bonusCode);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK::clear()
{
	paySystemByte = 0;
	bonusCode.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK::equals(const Protocol_MSG_CASHIER_BONUS_CHECK& _o) const
{
	return paySystemByte == _o.paySystemByte &&
		bonusCode.equals(_o.bonusCode);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_BONUS_CHECK).append(")");
	_buf.append(',');
	_buf.append("paySystemByte=");
	_buf.appendUint(paySystemByte);
	_buf.append(',');
	_buf.append("bonusCode=");
	_buf.append(bonusCode);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(paySystemByte);
	_msg.composeString(bonusCode);
}

void CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(paySystemByte);
	_parser.parseStringP(bonusCode);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_BONUS_CHECK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE paySystemByte; _parser.parseBYTE(paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "bonusCode"); size_t szBonusCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bonusCode", szBonusCode, BONUS_CODE_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_BONUS_CHECK_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK_REPLY::Protocol_MSG_CASHIER_BONUS_CHECK_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK_REPLY::Protocol_MSG_CASHIER_BONUS_CHECK_REPLY(Protocol_MSG_CASHIER_BONUS_CHECK_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK_REPLY::operator=(Protocol_MSG_CASHIER_BONUS_CHECK_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK_REPLY::equals(const Protocol_MSG_CASHIER_BONUS_CHECK_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_BONUS_CHECK_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_BONUS_CHECK_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_BONUS_CHECK_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_NET_REPORT_BRIEF
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_NET_REPORT_BRIEF::Protocol_MSG_CASHIER_GET_NET_REPORT_BRIEF()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_NET_REPORT_BRIEF::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_NET_REPORT_BRIEF::equals(const Protocol_MSG_CASHIER_GET_NET_REPORT_BRIEF& _o) const
{
	return true;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_NET_REPORT_BRIEF::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_NET_REPORT_BRIEF).append(")");
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_NET_REPORT_BRIEF::composeMsg(CommMsgBody& _msg) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_NET_REPORT_BRIEF::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_NET_REPORT_BRIEF::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_NET_REPORT_BRIEF";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX::equals(const Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX& _o) const
{
	return true;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX).append(")");
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX::composeMsg(CommMsgBody& _msg) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY(Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, countryPrefix(std::move(_o.countryPrefix))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY::operator=(Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		countryPrefix = std::move(_o.countryPrefix);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	countryPrefix.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY::equals(const Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		countryPrefix.equals(_o.countryPrefix);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("countryPrefix=");
		_buf.append(countryPrefix);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(countryPrefix);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(countryPrefix);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "countryPrefix"); size_t szCountryPrefix = strlen(_dummy);
		AtfValidator::validateInt(_descr, "countryPrefix", szCountryPrefix, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE(Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE&& _o)
	: balanceCurrency(std::move(_o.balanceCurrency))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE& CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE::operator=(Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE&& _o)
{
	if(this != &_o)
	{
		balanceCurrency = std::move(_o.balanceCurrency);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE::clear()
{
	balanceCurrency.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE::equals(const Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE& _o) const
{
	return balanceCurrency.equals(_o.balanceCurrency);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_AG_OPERATOR_BALANCE).append(")");
	_buf.append(',');
	_buf.append("balanceCurrency=");
	_buf.append(balanceCurrency);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(balanceCurrency);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(balanceCurrency);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_AG_OPERATOR_BALANCE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "balanceCurrency"); size_t szBalanceCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "balanceCurrency", szBalanceCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY(Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, operatorCurrency(std::move(_o.operatorCurrency))
	, operatorAmount(std::move(_o.operatorAmount))
	, balanceCurrency(std::move(_o.balanceCurrency))
	, balanceAmount(std::move(_o.balanceAmount))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY::operator=(Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		operatorCurrency = std::move(_o.operatorCurrency);
		operatorAmount = std::move(_o.operatorAmount);
		balanceCurrency = std::move(_o.balanceCurrency);
		balanceAmount = std::move(_o.balanceAmount);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	operatorCurrency.clear();
	operatorAmount = 0;
	balanceCurrency.clear();
	balanceAmount = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY::equals(const Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		operatorCurrency.equals(_o.operatorCurrency) &&
		operatorAmount == _o.operatorAmount &&
		balanceCurrency.equals(_o.balanceCurrency) &&
		balanceAmount == _o.balanceAmount;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("operatorCurrency=");
		_buf.append(operatorCurrency);
		_buf.append(',');
		_buf.append("operatorAmount=");
		_buf.appendInt64(operatorAmount);
		_buf.append(',');
		_buf.append("balanceCurrency=");
		_buf.append(balanceCurrency);
		_buf.append(',');
		_buf.append("balanceAmount=");
		_buf.appendInt64(balanceAmount);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(operatorCurrency);
		_msg.composeINT64(operatorAmount);
		_msg.composeString(balanceCurrency);
		_msg.composeINT64(balanceAmount);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(operatorCurrency);
		_parser.parseINT64(operatorAmount);
		_parser.parseStringP(balanceCurrency);
		_parser.parseINT64(balanceAmount);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "operatorCurrency"); size_t szOperatorCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "operatorCurrency", szOperatorCurrency, _checker, __FILE__, __LINE__);
		INT64 operatorAmount; _parser.parseINT64(operatorAmount);
		AtfValidator::validateInt(_descr, "operatorAmount", operatorAmount, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "balanceCurrency"); size_t szBalanceCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "balanceCurrency", szBalanceCurrency, _checker, __FILE__, __LINE__);
		INT64 balanceAmount; _parser.parseINT64(balanceAmount);
		AtfValidator::validateInt(_descr, "balanceAmount", balanceAmount, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_TRANSINFO
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO::Protocol_MSG_CASHIER_GET_TRANSINFO()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO::clear()
{
	transId = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO::equals(const Protocol_MSG_CASHIER_GET_TRANSINFO& _o) const
{
	return transId == _o.transId;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_TRANSINFO).append(")");
	_buf.append(',');
	_buf.append("transId=");
	_buf.appendUint(transId);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(transId);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(transId);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_TRANSINFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 transId; _parser.parseUINT32(transId);
	AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_TRANSINFO_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO_REPLY::Protocol_MSG_CASHIER_GET_TRANSINFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO_REPLY::Protocol_MSG_CASHIER_GET_TRANSINFO_REPLY(Protocol_MSG_CASHIER_GET_TRANSINFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, transId(std::move(_o.transId))
	, status(std::move(_o.status))
	, paysystemByte(std::move(_o.paysystemByte))
	, gateway(std::move(_o.gateway))
	, procAmount(std::move(_o.procAmount))
	, procCurrency(std::move(_o.procCurrency))
	, balanceAmount(std::move(_o.balanceAmount))
	, balanceCurrency(std::move(_o.balanceCurrency))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO_REPLY::operator=(Protocol_MSG_CASHIER_GET_TRANSINFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		transId = std::move(_o.transId);
		status = std::move(_o.status);
		paysystemByte = std::move(_o.paysystemByte);
		gateway = std::move(_o.gateway);
		procAmount = std::move(_o.procAmount);
		procCurrency = std::move(_o.procCurrency);
		balanceAmount = std::move(_o.balanceAmount);
		balanceCurrency = std::move(_o.balanceCurrency);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	transId = 0;
	status.clear();
	paysystemByte = 0;
	gateway.clear();
	procAmount = 0;
	procCurrency.clear();
	balanceAmount = 0;
	balanceCurrency.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO_REPLY::equals(const Protocol_MSG_CASHIER_GET_TRANSINFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		transId == _o.transId &&
		status.equals(_o.status) &&
		paysystemByte == _o.paysystemByte &&
		gateway.equals(_o.gateway) &&
		procAmount == _o.procAmount &&
		procCurrency.equals(_o.procCurrency) &&
		balanceAmount == _o.balanceAmount &&
		balanceCurrency.equals(_o.balanceCurrency);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_TRANSINFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("transId=");
		_buf.appendUint(transId);
		_buf.append(',');
		_buf.append("status=");
		_buf.append(status);
		_buf.append(',');
		_buf.append("paysystemByte=");
		_buf.appendUint(paysystemByte);
		_buf.append(',');
		_buf.append("gateway=");
		_buf.append(gateway);
		_buf.append(',');
		_buf.append("procAmount=");
		_buf.appendInt(procAmount);
		_buf.append(',');
		_buf.append("procCurrency=");
		_buf.append(procCurrency);
		_buf.append(',');
		_buf.append("balanceAmount=");
		_buf.appendInt(balanceAmount);
		_buf.append(',');
		_buf.append("balanceCurrency=");
		_buf.append(balanceCurrency);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(transId);
		_msg.composeString(status);
		_msg.composeBYTE(paysystemByte);
		_msg.composeString(gateway);
		_msg.composeINT32(procAmount);
		_msg.composeString(procCurrency);
		_msg.composeINT32(balanceAmount);
		_msg.composeString(balanceCurrency);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(transId);
		_parser.parseStringP(status);
		_parser.parseBYTE(paysystemByte);
		_parser.parseStringP(gateway);
		_parser.parseINT32(procAmount);
		_parser.parseStringP(procCurrency);
		_parser.parseINT32(balanceAmount);
		_parser.parseStringP(balanceCurrency);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_TRANSINFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_TRANSINFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 transId; _parser.parseUINT32(transId);
		AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "status"); size_t szStatus = strlen(_dummy);
		AtfValidator::validateInt(_descr, "status", szStatus, _checker, __FILE__, __LINE__);
		BYTE paysystemByte; _parser.parseBYTE(paysystemByte);
		AtfValidator::validateInt(_descr, "paysystemByte", paysystemByte, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "gateway"); size_t szGateway = strlen(_dummy);
		AtfValidator::validateInt(_descr, "gateway", szGateway, _checker, __FILE__, __LINE__);
		INT32 procAmount; _parser.parseINT32(procAmount);
		AtfValidator::validateInt(_descr, "procAmount", procAmount, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "procCurrency"); size_t szProcCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "procCurrency", szProcCurrency, _checker, __FILE__, __LINE__);
		INT32 balanceAmount; _parser.parseINT32(balanceAmount);
		AtfValidator::validateInt(_descr, "balanceAmount", balanceAmount, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "balanceCurrency"); size_t szBalanceCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "balanceCurrency", szBalanceCurrency, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT::clear()
{
	paySystemByte = 0;
	consentValue = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT::equals(const Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT& _o) const
{
	return paySystemByte == _o.paySystemByte &&
		consentValue == _o.consentValue;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT).append(")");
	_buf.append(',');
	_buf.append("paySystemByte=");
	_buf.appendUint(paySystemByte);
	_buf.append(',');
	_buf.append("consentValue=");
	_buf.appendInt(consentValue);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(paySystemByte);
	_msg.composeINT32(consentValue);
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(paySystemByte);
	_parser.parseINT32(consentValue);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE paySystemByte; _parser.parseBYTE(paySystemByte);
	AtfValidator::validateIntRange(_descr, "paySystemByte", paySystemByte, cardTypeFirst, cardTypeLast, _checker, __FILE__, __LINE__);
	INT32 consentValue; _parser.parseINT32(consentValue);
	{ const INT32 consentValue_enum[] = {eUserPaysystemConsent_No, eUserPaysystemConsent_Yes}; AtfValidator::validateEnum(_descr, "consentValue", consentValue, consentValue_enum, _checker, __FILE__, __LINE__); }
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY(Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY::operator=(Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY::equals(const Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX(Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX&& _o)
	: cashoutAmount(std::move(_o.cashoutAmount))
	, balanceCurrency(std::move(_o.balanceCurrency))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX& CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX::operator=(Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX&& _o)
{
	if(this != &_o)
	{
		cashoutAmount = std::move(_o.cashoutAmount);
		balanceCurrency = std::move(_o.balanceCurrency);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX::clear()
{
	cashoutAmount = 0;
	balanceCurrency.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX::equals(const Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX& _o) const
{
	return cashoutAmount == _o.cashoutAmount &&
		balanceCurrency.equals(_o.balanceCurrency);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX).append(")");
	_buf.append(',');
	_buf.append("cashoutAmount=");
	_buf.appendInt64(cashoutAmount);
	_buf.append(',');
	_buf.append("balanceCurrency=");
	_buf.append(balanceCurrency);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(cashoutAmount);
	_msg.composeString(balanceCurrency);
}

void CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(cashoutAmount);
	_parser.parseStringP(balanceCurrency);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT64 cashoutAmount; _parser.parseINT64(cashoutAmount);
	AtfValidator::validateIntRange(_descr, "cashoutAmount", cashoutAmount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "balanceCurrency"); size_t szBalanceCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "balanceCurrency", szBalanceCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY(Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, taxAmountInBalanceCurrency(std::move(_o.taxAmountInBalanceCurrency))
	, cashoutRemainder(std::move(_o.cashoutRemainder))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY::operator=(Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		taxAmountInBalanceCurrency = std::move(_o.taxAmountInBalanceCurrency);
		cashoutRemainder = std::move(_o.cashoutRemainder);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	taxAmountInBalanceCurrency = 0;
	cashoutRemainder = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY::equals(const Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		taxAmountInBalanceCurrency == _o.taxAmountInBalanceCurrency &&
		cashoutRemainder == _o.cashoutRemainder;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("taxAmountInBalanceCurrency=");
		_buf.appendInt64(taxAmountInBalanceCurrency);
		_buf.append(',');
		_buf.append("cashoutRemainder=");
		_buf.appendInt64(cashoutRemainder);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT64(taxAmountInBalanceCurrency);
		_msg.composeINT64(cashoutRemainder);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT64(taxAmountInBalanceCurrency);
		_parser.parseINT64(cashoutRemainder);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT64 taxAmountInBalanceCurrency; _parser.parseINT64(taxAmountInBalanceCurrency);
		AtfValidator::validateInt(_descr, "taxAmountInBalanceCurrency", taxAmountInBalanceCurrency, _checker, __FILE__, __LINE__);
		INT64 cashoutRemainder; _parser.parseINT64(cashoutRemainder);
		AtfValidator::validateInt(_descr, "cashoutRemainder", cashoutRemainder, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE::equals(const Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE& _o) const
{
	return true;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_VANILLADIRECT_BARCODE).append(")");
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE::composeMsg(CommMsgBody& _msg) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_VANILLADIRECT_BARCODE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY(Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, barcode(std::move(_o.barcode))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY::operator=(Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		barcode = std::move(_o.barcode);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	barcode.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY::equals(const Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		barcode.equals(_o.barcode);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("barcode=");
		_buf.append(barcode);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(barcode);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(barcode);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "barcode"); size_t szBarcode = strlen(_dummy);
		AtfValidator::validateInt(_descr, "barcode", szBarcode, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN::equals(const Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN& _o) const
{
	return true;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_STARSWALLET_RESEND_MTAN).append(")");
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN::composeMsg(CommMsgBody& _msg) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_STARSWALLET_RESEND_MTAN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY(Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY::operator=(Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY::equals(const Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN(Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN&& _o)
	: mtan(std::move(_o.mtan))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN& CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN::operator=(Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN&& _o)
{
	if(this != &_o)
	{
		mtan = std::move(_o.mtan);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN::clear()
{
	mtan.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN::equals(const Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN& _o) const
{
	return mtan.equals(_o.mtan);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_STARSWALLET_CHECK_MTAN).append(")");
	_buf.append(',');
	_buf.append("mtan=");
	_buf.append(mtan);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(mtan);
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(mtan);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_STARSWALLET_CHECK_MTAN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "mtan"); size_t szMtan = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "mtan", szMtan, 50, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY(Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY::operator=(Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY::equals(const Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION(Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION&& _o)
	: initiative(std::move(_o.initiative))
	, validationURL(std::move(_o.validationURL))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION& CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION::operator=(Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION&& _o)
{
	if(this != &_o)
	{
		initiative = std::move(_o.initiative);
		validationURL = std::move(_o.validationURL);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION::clear()
{
	initiative.clear();
	validationURL.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION::equals(const Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION& _o) const
{
	return initiative.equals(_o.initiative) &&
		validationURL.equals(_o.validationURL);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION).append(")");
	_buf.append(',');
	_buf.append("initiative=");
	_buf.append(initiative);
	_buf.append(',');
	_buf.append("validationURL=");
	_buf.append(validationURL);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(initiative);
	_msg.composeString(validationURL);
}

void CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(initiative);
	_parser.parseStringP(validationURL);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "initiative"); size_t szInitiative = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "initiative", szInitiative, 10000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "validationURL"); size_t szValidationURL = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "validationURL", szValidationURL, 10000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY(Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, merchantSession(std::move(_o.merchantSession))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY::operator=(Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		merchantSession = std::move(_o.merchantSession);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	merchantSession.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY::equals(const Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		merchantSession.equals(_o.merchantSession);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("merchantSession=");
		_buf.append(merchantSession);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(merchantSession);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(merchantSession);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "merchantSession"); size_t szMerchantSession = strlen(_dummy);
		AtfValidator::validateInt(_descr, "merchantSession", szMerchantSession, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    TempAccountLimitStatus
//=================================================================

CashierServer::cli::TempAccountLimitStatus::TempAccountLimitStatus()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::TempAccountLimitStatus::TempAccountLimitStatus(TempAccountLimitStatus&& _o)
	: limitAmount(std::move(_o.limitAmount))
	, limitCurrency(std::move(_o.limitCurrency))
	, availAmount(std::move(_o.availAmount))
	, availBalanceCurrency(std::move(_o.availBalanceCurrency))
{
}

CashierServer::cli::TempAccountLimitStatus& CashierServer::cli::TempAccountLimitStatus::operator=(TempAccountLimitStatus&& _o)
{
	if(this != &_o)
	{
		limitAmount = std::move(_o.limitAmount);
		limitCurrency = std::move(_o.limitCurrency);
		availAmount = std::move(_o.availAmount);
		availBalanceCurrency = std::move(_o.availBalanceCurrency);
	}
	return *this;
}

#endif

void CashierServer::cli::TempAccountLimitStatus::clear()
{
	limitAmount = 0;
	limitCurrency.clear();
	availAmount = 0;
	availBalanceCurrency.clear();
}

bool CashierServer::cli::TempAccountLimitStatus::equals(const TempAccountLimitStatus& _o) const
{
	return limitAmount == _o.limitAmount &&
		limitCurrency.equals(_o.limitCurrency) &&
		availAmount == _o.availAmount &&
		availBalanceCurrency.equals(_o.availBalanceCurrency);
}

const char *CashierServer::cli::TempAccountLimitStatus::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("limitAmount=");
	_buf.appendInt(limitAmount);
	_buf.append(',');
	_buf.append("limitCurrency=");
	_buf.append(limitCurrency);
	_buf.append(',');
	_buf.append("availAmount=");
	_buf.appendInt(availAmount);
	_buf.append(',');
	_buf.append("availBalanceCurrency=");
	_buf.append(availBalanceCurrency);
	_buf.append('}');
	return _buf.c_str();
}

void CashierServer::cli::TempAccountLimitStatus::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(TempAccountLimitStatus())) // not empty
	{
		_body.composeINT32(limitAmount);
		_body.composeString(limitCurrency);
		_body.composeINT32(availAmount);
		_body.composeString(availBalanceCurrency);
	}

	_msg.composeMsgBody(_body);
}

void CashierServer::cli::TempAccountLimitStatus::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(limitAmount);
	_parser0.parseStringP(limitCurrency);
	_parser0.parseINT32(availAmount);
	_parser0.parseStringP(availBalanceCurrency);
}

/*static*/ void CashierServer::cli::TempAccountLimitStatus::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	INT32 limitAmount; _parser0.parseINT32(limitAmount);
	AtfValidator::validateInt(_descr, "limitAmount", limitAmount, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "limitCurrency"); size_t szLimitCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "limitCurrency", szLimitCurrency, _checker, __FILE__, __LINE__);
	INT32 availAmount; _parser0.parseINT32(availAmount);
	AtfValidator::validateInt(_descr, "availAmount", availAmount, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "availBalanceCurrency"); size_t szAvailBalanceCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "availBalanceCurrency", szAvailBalanceCurrency, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS::equals(const Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS& _o) const
{
	return true;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS).append(")");
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS::composeMsg(CommMsgBody& _msg) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY(Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, enabled(std::move(_o.enabled))
	, cashoutLimit(std::move(_o.cashoutLimit))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY::operator=(Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		enabled = std::move(_o.enabled);
		cashoutLimit = std::move(_o.cashoutLimit);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	enabled = false;
	cashoutLimit.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY::equals(const Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		enabled == _o.enabled &&
		cashoutLimit.equals(_o.cashoutLimit);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("enabled=");
		_buf.appendUint(enabled);
		_buf.append(',');
		_buf.append("cashoutLimit=");
		cashoutLimit.toTraceString(_buf);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeBOOL(enabled);
		cashoutLimit.composeMsg(_msg);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseBOOL(enabled);
		cashoutLimit.parseMsg(_parser);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool enabled; _parser.parseBOOL(enabled);
		AtfValidator::validateInt(_descr, "enabled", enabled, _checker, __FILE__, __LINE__);
		PString _descbuf;
		TempAccountLimitStatus::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cashoutLimit"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS::clear()
{
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS::equals(const Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS& _o) const
{
	return true;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS).append(")");
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS::composeMsg(CommMsgBody& _msg) const
{
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY(Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, enabled(std::move(_o.enabled))
	, limitStatus(std::move(_o.limitStatus))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY::operator=(Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		enabled = std::move(_o.enabled);
		limitStatus = std::move(_o.limitStatus);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	enabled = false;
	limitStatus.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY::equals(const Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		enabled == _o.enabled &&
		limitStatus.equals(_o.limitStatus);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("enabled=");
		_buf.appendUint(enabled);
		_buf.append(',');
		_buf.append("limitStatus=");
		limitStatus.toTraceString(_buf);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeBOOL(enabled);
		limitStatus.composeMsg(_msg);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseBOOL(enabled);
		limitStatus.parseMsg(_parser);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool enabled; _parser.parseBOOL(enabled);
		AtfValidator::validateInt(_descr, "enabled", enabled, _checker, __FILE__, __LINE__);
		PString _descbuf;
		TempAccountLimitStatus::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("limitStatus"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED()
{
	clear();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED::clear()
{
	transId = 0;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED::equals(const Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED& _o) const
{
	return transId == _o.transId;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED).append(")");
	_buf.append(',');
	_buf.append("transId=");
	_buf.appendUint(transId);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(transId);
}

void CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(transId);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 transId; _parser.parseUINT32(transId);
	AtfValidator::validateInt(_descr, "transId", transId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY(Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY::operator=(Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY::equals(const Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_PLAID_DATA
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA::Protocol_MSG_CASHIER_GET_PLAID_DATA()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA::Protocol_MSG_CASHIER_GET_PLAID_DATA(Protocol_MSG_CASHIER_GET_PLAID_DATA&& _o)
	: paysystemByte(std::move(_o.paysystemByte))
	, amount(std::move(_o.amount))
	, currency(std::move(_o.currency))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA& CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA::operator=(Protocol_MSG_CASHIER_GET_PLAID_DATA&& _o)
{
	if(this != &_o)
	{
		paysystemByte = std::move(_o.paysystemByte);
		amount = std::move(_o.amount);
		currency = std::move(_o.currency);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA::clear()
{
	paysystemByte = 0;
	amount = 0;
	currency.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA::equals(const Protocol_MSG_CASHIER_GET_PLAID_DATA& _o) const
{
	return paysystemByte == _o.paysystemByte &&
		amount == _o.amount &&
		currency.equals(_o.currency);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_PLAID_DATA).append(")");
	_buf.append(',');
	_buf.append("paysystemByte=");
	_buf.appendUint(paysystemByte);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendInt(amount);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(paysystemByte);
	_msg.composeINT32(amount);
	_msg.composeString(currency);
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(paysystemByte);
	_parser.parseINT32(amount);
	_parser.parseStringP(currency);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_PLAID_DATA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE paysystemByte; _parser.parseBYTE(paysystemByte);
	AtfValidator::validateInt(_descr, "paysystemByte", paysystemByte, _checker, __FILE__, __LINE__);
	INT32 amount; _parser.parseINT32(amount);
	AtfValidator::validateIntRange(_descr, "amount", amount, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_GET_PLAID_DATA_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA_REPLY::Protocol_MSG_CASHIER_GET_PLAID_DATA_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA_REPLY::Protocol_MSG_CASHIER_GET_PLAID_DATA_REPLY(Protocol_MSG_CASHIER_GET_PLAID_DATA_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, plaidEnvironment(std::move(_o.plaidEnvironment))
	, plaidPublicKey(std::move(_o.plaidPublicKey))
	, bankLookupPreference(std::move(_o.bankLookupPreference))
	, isPlaidAccountInSystem(std::move(_o.isPlaidAccountInSystem))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA_REPLY::operator=(Protocol_MSG_CASHIER_GET_PLAID_DATA_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		plaidEnvironment = std::move(_o.plaidEnvironment);
		plaidPublicKey = std::move(_o.plaidPublicKey);
		bankLookupPreference = std::move(_o.bankLookupPreference);
		isPlaidAccountInSystem = std::move(_o.isPlaidAccountInSystem);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	plaidEnvironment.clear();
	plaidPublicKey.clear();
	bankLookupPreference.clear();
	isPlaidAccountInSystem = false;
}

bool CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA_REPLY::equals(const Protocol_MSG_CASHIER_GET_PLAID_DATA_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		plaidEnvironment.equals(_o.plaidEnvironment) &&
		plaidPublicKey.equals(_o.plaidPublicKey) &&
		bankLookupPreference.equals(_o.bankLookupPreference) &&
		isPlaidAccountInSystem == _o.isPlaidAccountInSystem;
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_GET_PLAID_DATA_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("plaidEnvironment=");
		_buf.append(plaidEnvironment);
		_buf.append(',');
		_buf.append("plaidPublicKey=");
		_buf.append(plaidPublicKey);
		_buf.append(',');
		_buf.append("bankLookupPreference=");
		_buf.append(bankLookupPreference);
		_buf.append(',');
		_buf.append("isPlaidAccountInSystem=");
		_buf.appendUint(isPlaidAccountInSystem);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(plaidEnvironment);
		_msg.composeString(plaidPublicKey);
		_msg.composeString(bankLookupPreference);
		_msg.composeBOOL(isPlaidAccountInSystem);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(plaidEnvironment);
		_parser.parseStringP(plaidPublicKey);
		_parser.parseStringP(bankLookupPreference);
		_parser.parseBOOL(isPlaidAccountInSystem);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_GET_PLAID_DATA_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_GET_PLAID_DATA_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "plaidEnvironment"); size_t szPlaidEnvironment = strlen(_dummy);
		AtfValidator::validateInt(_descr, "plaidEnvironment", szPlaidEnvironment, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "plaidPublicKey"); size_t szPlaidPublicKey = strlen(_dummy);
		AtfValidator::validateInt(_descr, "plaidPublicKey", szPlaidPublicKey, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "bankLookupPreference"); size_t szBankLookupPreference = strlen(_dummy);
		AtfValidator::validateInt(_descr, "bankLookupPreference", szBankLookupPreference, _checker, __FILE__, __LINE__);
		bool isPlaidAccountInSystem; _parser.parseBOOL(isPlaidAccountInSystem);
		AtfValidator::validateInt(_descr, "isPlaidAccountInSystem", isPlaidAccountInSystem, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT(Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT&& _o)
	: plaidPublicToken(std::move(_o.plaidPublicToken))
	, plaidBankAccountId(std::move(_o.plaidBankAccountId))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT& CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT::operator=(Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT&& _o)
{
	if(this != &_o)
	{
		plaidPublicToken = std::move(_o.plaidPublicToken);
		plaidBankAccountId = std::move(_o.plaidBankAccountId);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT::clear()
{
	plaidPublicToken.clear();
	plaidBankAccountId.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT::equals(const Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT& _o) const
{
	return plaidPublicToken.equals(_o.plaidPublicToken) &&
		plaidBankAccountId.equals(_o.plaidBankAccountId);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_ADD_PLAID_ACCOUNT).append(")");
	_buf.append(',');
	_buf.append("plaidPublicToken=");
	_buf.append(plaidPublicToken);
	_buf.append(',');
	_buf.append("plaidBankAccountId=");
	_buf.append(plaidBankAccountId);
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(plaidPublicToken);
	_msg.composeString(plaidBankAccountId);
}

void CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(plaidPublicToken);
	_parser.parseStringP(plaidBankAccountId);
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ADD_PLAID_ACCOUNT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "plaidPublicToken"); size_t szPlaidPublicToken = strlen(_dummy);
	AtfValidator::validateIntMin(_descr, "plaidPublicToken", szPlaidPublicToken, 1, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "plaidBankAccountId"); size_t szPlaidBankAccountId = strlen(_dummy);
	AtfValidator::validateIntMin(_descr, "plaidBankAccountId", szPlaidBankAccountId, 1, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY
//=================================================================

CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY(Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY& CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY::operator=(Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY::equals(const Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_USER_LOGGED_IN
//=================================================================

CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN::Protocol_MSG_CASHIER_USER_LOGGED_IN()
{
	clear();
}

void CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN::clear()
{
}

bool CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN::equals(const Protocol_MSG_CASHIER_USER_LOGGED_IN& _o) const
{
	return true;
}

const char *CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_USER_LOGGED_IN).append(")");
	return _buf.c_str();
}

void CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN::composeMsg(CommMsgBody& _msg) const
{
}

void CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_USER_LOGGED_IN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_USER_LOGGED_IN_REPLY
//=================================================================

CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN_REPLY::Protocol_MSG_CASHIER_USER_LOGGED_IN_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN_REPLY::Protocol_MSG_CASHIER_USER_LOGGED_IN_REPLY(Protocol_MSG_CASHIER_USER_LOGGED_IN_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN_REPLY& CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN_REPLY::operator=(Protocol_MSG_CASHIER_USER_LOGGED_IN_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN_REPLY::equals(const Protocol_MSG_CASHIER_USER_LOGGED_IN_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_USER_LOGGED_IN_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void CashierServer::cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_USER_LOGGED_IN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_USERROLL_STATUS
//=================================================================

CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::Protocol_MSG_CASHIER_SET_USERROLL_STATUS()
{
	clear();
}

void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::clear()
{
	status.clear();
}

bool CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::equals(const Protocol_MSG_CASHIER_SET_USERROLL_STATUS& _o) const
{
	return status.equals(_o.status);
}

const char *CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_USERROLL_STATUS).append(")");
	_buf.append(',');
	_buf.append("status=");
	status.toTraceString(_buf);
	return _buf.c_str();
}

void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::composeMsg(CommMsgBody& _msg) const
{
	status.composeMsg(_msg);
}

void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::parseMsg(CommMsgParser& _parser)
{
	status.parseMsg(_parser);
}

/*static*/ void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_USERROLL_STATUS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	common_structs::SetUserRollStatus::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("status"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY
//=================================================================

CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY(Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY&& _o)
	: reply(std::move(_o.reply))
{
}

CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY& CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::operator=(Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY&& _o)
{
	if(this != &_o)
	{
		reply = std::move(_o.reply);
	}
	return *this;
}

#endif

void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::clear()
{
	reply.clear();
}

bool CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::equals(const Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY& _o) const
{
	return reply.equals(_o.reply);
}

const char *CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_USERROLL_STATUS_REPLY).append(")");
	_buf.append(',');
	_buf.append("reply=");
	reply.toTraceString(_buf);
	return _buf.c_str();
}

void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	reply.composeMsg(_msg);
}

void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::parseMsg(CommMsgParser& _parser)
{
	reply.parseMsg(_parser);
}

/*static*/ void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_USERROLL_STATUS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	common_structs::SetUserRollStatusReply::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("reply"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS
//=================================================================

CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS()
{
	clear();
}

void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::clear()
{
	status.clear();
}

bool CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::equals(const Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS& _o) const
{
	return status.equals(_o.status);
}

const char *CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_GAMETICKET_STATUS).append(")");
	_buf.append(',');
	_buf.append("status=");
	status.toTraceString(_buf);
	return _buf.c_str();
}

void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::composeMsg(CommMsgBody& _msg) const
{
	status.composeMsg(_msg);
}

void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::parseMsg(CommMsgParser& _parser)
{
	status.parseMsg(_parser);
}

/*static*/ void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_GAMETICKET_STATUS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	common_structs::SetGameTicketStatus::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("status"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY
//=================================================================

CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY(Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY&& _o)
	: reply(std::move(_o.reply))
{
}

CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY& CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::operator=(Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY&& _o)
{
	if(this != &_o)
	{
		reply = std::move(_o.reply);
	}
	return *this;
}

#endif

void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::clear()
{
	reply.clear();
}

bool CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::equals(const Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY& _o) const
{
	return reply.equals(_o.reply);
}

const char *CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY).append(")");
	_buf.append(',');
	_buf.append("reply=");
	reply.toTraceString(_buf);
	return _buf.c_str();
}

void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	reply.composeMsg(_msg);
}

void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::parseMsg(CommMsgParser& _parser)
{
	reply.parseMsg(_parser);
}

/*static*/ void CashierServer::cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	common_structs::SetGameTicketStatusReply::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("reply"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ bool CashierServer::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_CASHIER_3V_PREREGISTER: cli::Protocol_MSG_CASHIER_3V_PREREGISTER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_3V_PREREGISTER_REPLY: cli::Protocol_MSG_CASHIER_3V_PREREGISTER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ADD_PLAID_ACCOUNT: cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY: cli::Protocol_MSG_CASHIER_ADD_PLAID_ACCOUNT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_AGEVERIVICATION2: cli::Protocol_MSG_CASHIER_AGEVERIVICATION2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_AGEVERIVICATION2_CANCEL: cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY: cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_CANCEL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_AGEVERIVICATION2_REPLY: cli::Protocol_MSG_CASHIER_AGEVERIVICATION2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_AGE_CHECK_UK: cli::Protocol_MSG_CASHIER_AGE_CHECK_UK::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_AGE_CHECK_UK_REPLY: cli::Protocol_MSG_CASHIER_AGE_CHECK_UK_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION: cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY: cli::Protocol_MSG_CASHIER_APPLEPAY_MERCHANT_VALIDATION_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ASTROPAY_CASHIN: cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT: cli::Protocol_MSG_CASHIER_ASTROPAY_CASHIN_REDIRECT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_AVLS_REQUEST: cli::Protocol_MSG_CASHIER_AVLS_REQUEST::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_AVLS_REQUEST_REPLY: cli::Protocol_MSG_CASHIER_AVLS_REQUEST_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_BONUS_CHECK: cli::Protocol_MSG_CASHIER_BONUS_CHECK::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_BONUS_CHECK_REPLY: cli::Protocol_MSG_CASHIER_BONUS_CHECK_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_BPAY_REQUEST: cli::Protocol_MSG_CASHIER_BPAY_REQUEST::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_BPAY_REQUEST_REPLY: cli::Protocol_MSG_CASHIER_BPAY_REQUEST_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_BUY_PM: cli::Protocol_MSG_CASHIER_BUY_PM::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_BUY_PM_APPLE: cli::Protocol_MSG_CASHIER_BUY_PM_APPLE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_BUY_PM_APPLE_REPLY: cli::Protocol_MSG_CASHIER_BUY_PM_APPLE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_BUY_PM_COMPLETE: cli::Protocol_MSG_CASHIER_BUY_PM_COMPLETE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_BUY_PM_CONFIRM: cli::Protocol_MSG_CASHIER_BUY_PM_CONFIRM::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_BUY_PM_GOOGLE: cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_BUY_PM_GOOGLE_REPLY: cli::Protocol_MSG_CASHIER_BUY_PM_GOOGLE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX: cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY: cli::Protocol_MSG_CASHIER_CALC_ROMANIA_CASHOUT_TAX_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CANCEL_PENDING_CASHOUTS: cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY: cli::Protocol_MSG_CASHIER_CANCEL_PENDING_CASHOUTS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CASHIN_CC: cli::Protocol_MSG_CASHIER_CASHIN_CC::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CASHIN_CC_COMPLETE: cli::Protocol_MSG_CASHIER_CASHIN_CC_COMPLETE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CASHIN_CC_CONFIRM: cli::Protocol_MSG_CASHIER_CASHIN_CC_CONFIRM::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CASHIN_CC_REDIRECTED: cli::Protocol_MSG_CASHIER_CASHIN_CC_REDIRECTED::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CASHIN_HOSTED: cli::Protocol_MSG_CASHIER_CASHIN_HOSTED::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CASHIN_HOSTED_REDIRECT: cli::Protocol_MSG_CASHIER_CASHIN_HOSTED_REDIRECT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CASHIN_NT: cli::Protocol_MSG_CASHIER_CASHIN_NT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CASHIN_NT_COMPLETE: cli::Protocol_MSG_CASHIER_CASHIN_NT_COMPLETE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CASHIN_NT_CONFIRM: cli::Protocol_MSG_CASHIER_CASHIN_NT_CONFIRM::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CASHOUT: cli::Protocol_MSG_CASHIER_CASHOUT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CASHOUT_COMPLETE: cli::Protocol_MSG_CASHIER_CASHOUT_COMPLETE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CC_BIN_CHECK: cli::Protocol_MSG_CASHIER_CC_BIN_CHECK::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CC_BIN_CHECK_REPLY: cli::Protocol_MSG_CASHIER_CC_BIN_CHECK_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CHECK_PAYSYSTEM: cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CHECK_PAYSYSTEM2: cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY: cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CHECK_PAYSYSTEM_REPLY: cli::Protocol_MSG_CASHIER_CHECK_PAYSYSTEM_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CHECK_PLI: cli::Protocol_MSG_CASHIER_CHECK_PLI::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CHECK_PLI_REPLY: cli::Protocol_MSG_CASHIER_CHECK_PLI_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CHIPS_INFO2: cli::Protocol_MSG_CASHIER_CHIPS_INFO2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CHIPS_INFO2_REPLY: cli::Protocol_MSG_CASHIER_CHIPS_INFO2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS: cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY: cli::Protocol_MSG_CASHIER_CHIPS_INFO_WITH_OPTIONS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CONVERT_ALL_ASSETS: cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY: cli::Protocol_MSG_CASHIER_CONVERT_ALL_ASSETS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT: cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY: cli::Protocol_MSG_CASHIER_CONVERT_FOR_TARGET_AMOUNT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT: cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY: cli::Protocol_MSG_CASHIER_CONVERT_FUNDS_TO_ONE_ACCT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CONVRATES_SUBSET: cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CONVRATES_SUBSET_REPLY: cli::Protocol_MSG_CASHIER_CONVRATES_SUBSET_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CREATE_REDEEM_ACCOUNT: cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY: cli::Protocol_MSG_CASHIER_CREATE_REDEEM_ACCOUNT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER: cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY: cli::Protocol_MSG_CASHIER_CURRENCY_ACCOUNT_MULTI_TRANSFER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_DAD_REQUEST: cli::Protocol_MSG_CASHIER_DAD_REQUEST::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_DAD_REQUEST_REPLY: cli::Protocol_MSG_CASHIER_DAD_REQUEST_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_DBT_VALIDATE: cli::Protocol_MSG_CASHIER_DBT_VALIDATE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_DBT_VALIDATE_REPLY: cli::Protocol_MSG_CASHIER_DBT_VALIDATE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_DELETE_CURRENCY_ACCOUNT: cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY: cli::Protocol_MSG_CASHIER_DELETE_CURRENCY_ACCOUNT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO: cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY: cli::Protocol_MSG_CASHIER_DELETE_FAST_DEPOSIT_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_DELETE_SAVED_CARD: cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_DELETE_SAVED_CARD_REPLY: cli::Protocol_MSG_CASHIER_DELETE_SAVED_CARD_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_DEPOSIT_CHECK: cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_DEPOSIT_CHECK_REPLY: cli::Protocol_MSG_CASHIER_DEPOSIT_CHECK_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ENVOY_LBT_BANK_SELECTED: cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY: cli::Protocol_MSG_CASHIER_ENVOY_LBT_BANK_SELECTED_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ENVOY_LBT_GET_BANKS: cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY: cli::Protocol_MSG_CASHIER_ENVOY_LBT_GET_BANKS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ESMIGRATION2: cli::Protocol_MSG_CASHIER_ESMIGRATION2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ESMIGRATION2_CANCEL: cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY: cli::Protocol_MSG_CASHIER_ESMIGRATION2_CANCEL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ESMIGRATION2_DEPOSIT: cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY: cli::Protocol_MSG_CASHIER_ESMIGRATION2_DEPOSIT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ESMIGRATION2_GET_INFO: cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY: cli::Protocol_MSG_CASHIER_ESMIGRATION2_GET_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_ESMIGRATION2_REPLY: cli::Protocol_MSG_CASHIER_ESMIGRATION2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED: cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY: cli::Protocol_MSG_CASHIER_FDMS_NOTIFY_3DFORM_COMPLETED_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_FRMIGRATION: cli::Protocol_MSG_CASHIER_FRMIGRATION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_FRMIGRATION_CANCEL: cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_FRMIGRATION_CANCEL_REPLY: cli::Protocol_MSG_CASHIER_FRMIGRATION_CANCEL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_FRMIGRATION_DEPOSIT: cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY: cli::Protocol_MSG_CASHIER_FRMIGRATION_DEPOSIT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_FRMIGRATION_GET_INFO: cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY: cli::Protocol_MSG_CASHIER_FRMIGRATION_GET_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_FRMIGRATION_LIVESUPPORT: cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY: cli::Protocol_MSG_CASHIER_FRMIGRATION_LIVESUPPORT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_FRMIGRATION_REPLY: cli::Protocol_MSG_CASHIER_FRMIGRATION_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL: cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY: cli::Protocol_MSG_CASHIER_GENERATE_ELV_MANDATE_EMAIL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_AG_OPERATOR_BALANCE: cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY: cli::Protocol_MSG_CASHIER_GET_AG_OPERATOR_BALANCE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_ASTROPAY_BANKINFO: cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY: cli::Protocol_MSG_CASHIER_GET_ASTROPAY_BANKINFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_CURRENT_USERROLLS: cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY: cli::Protocol_MSG_CASHIER_GET_CURRENT_USERROLLS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_DBT_FIELDS: cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_DBT_FIELDS_REPLY: cli::Protocol_MSG_CASHIER_GET_DBT_FIELDS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_DENOMINATED_BALANCE: cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY: cli::Protocol_MSG_CASHIER_GET_DENOMINATED_BALANCE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_FAST_DEPOSIT_INFO: cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY: cli::Protocol_MSG_CASHIER_GET_FAST_DEPOSIT_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_IND_USER_TAX_INFO: cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY: cli::Protocol_MSG_CASHIER_GET_IND_USER_TAX_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_NET_REPORT_BRIEF: cli::Protocol_MSG_CASHIER_GET_NET_REPORT_BRIEF::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_PAYLUCKY_INFO: cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY: cli::Protocol_MSG_CASHIER_GET_PAYLUCKY_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_PENDING_CASHOUTS: cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY: cli::Protocol_MSG_CASHIER_GET_PENDING_CASHOUTS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_PLAID_DATA: cli::Protocol_MSG_CASHIER_GET_PLAID_DATA::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_PLAID_DATA_REPLY: cli::Protocol_MSG_CASHIER_GET_PLAID_DATA_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS: cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY: cli::Protocol_MSG_CASHIER_GET_RECENT_SUCCESSFUL_DEPOSITS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_RESCUE_PAYSYSTEMS: cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY: cli::Protocol_MSG_CASHIER_GET_RESCUE_PAYSYSTEMS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_RMF_BANKACCOUNT: cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY: cli::Protocol_MSG_CASHIER_GET_RMF_BANKACCOUNT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_RM_NOK_HELD_FUNDS: cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY: cli::Protocol_MSG_CASHIER_GET_RM_NOK_HELD_FUNDS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_SAVED_CARDS: cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_SAVED_CARDS_REPLY: cli::Protocol_MSG_CASHIER_GET_SAVED_CARDS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_SPENDING_LIMIT: cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_SPENDING_LIMIT_REPLY: cli::Protocol_MSG_CASHIER_GET_SPENDING_LIMIT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS: cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY: cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_CASHOUT_LIMIT_STATUS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS: cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY: cli::Protocol_MSG_CASHIER_GET_TEMP_ACCOUNT_DEPOSIT_STATUS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_TEXT: cli::Protocol_MSG_CASHIER_GET_TEXT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_TEXT_REPLY: cli::Protocol_MSG_CASHIER_GET_TEXT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_TRANSINFO: cli::Protocol_MSG_CASHIER_GET_TRANSINFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_TRANSINFO_REPLY: cli::Protocol_MSG_CASHIER_GET_TRANSINFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_UNCLEARED_DEPOSITS2: cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY: cli::Protocol_MSG_CASHIER_GET_UNCLEARED_DEPOSITS2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX: cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY: cli::Protocol_MSG_CASHIER_GET_USER_COUNTRY_PHONE_PREFIX_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_USER_LIMIT: cli::Protocol_MSG_CASHIER_GET_USER_LIMIT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_USER_LIMIT_EX: cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_USER_LIMIT_EX_REPLY: cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_EX_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_USER_LIMIT_REPLY: cli::Protocol_MSG_CASHIER_GET_USER_LIMIT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_USER_PRIVS: cli::Protocol_MSG_CASHIER_GET_USER_PRIVS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_USER_PRIVS_2: cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_USER_PRIVS_2_REPLY: cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_USER_PRIVS_REPLY: cli::Protocol_MSG_CASHIER_GET_USER_PRIVS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_VANILLADIRECT_BARCODE: cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY: cli::Protocol_MSG_CASHIER_GET_VANILLADIRECT_BARCODE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_VANILLA_AMTCURRENCY: cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY: cli::Protocol_MSG_CASHIER_GET_VANILLA_AMTCURRENCY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_HISTORY2: cli::Protocol_MSG_CASHIER_HISTORY2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_HISTORY2_REPLY: cli::Protocol_MSG_CASHIER_HISTORY2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_HOSTED_DONE: cli::Protocol_MSG_CASHIER_HOSTED_DONE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_INCREASE_PLI: cli::Protocol_MSG_CASHIER_INCREASE_PLI::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_INCREASE_PLI_REPLY: cli::Protocol_MSG_CASHIER_INCREASE_PLI_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_INIT_WIRECARD_DEPOSIT: cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY: cli::Protocol_MSG_CASHIER_INIT_WIRECARD_DEPOSIT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_MBOOKERS_REDIRECTED: cli::Protocol_MSG_CASHIER_MBOOKERS_REDIRECTED::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_NEW_CURRENCY_ACCOUNT: cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY: cli::Protocol_MSG_CASHIER_NEW_CURRENCY_ACCOUNT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PAYSYSTEMS_AVAIL: cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PAYSYSTEMS_AVAIL_PM: cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY: cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PM_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO: cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY: cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_PROMO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY: cli::Protocol_MSG_CASHIER_PAYSYSTEMS_AVAIL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PAYSYSTEMS_LIMITS: cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY: cli::Protocol_MSG_CASHIER_PAYSYSTEMS_LIMITS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PLAY_MONEY_REFILL: cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO: cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY: cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_GET_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PLAY_MONEY_REFILL_REPLY: cli::Protocol_MSG_CASHIER_PLAY_MONEY_REFILL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PLAY_TRANSFER: cli::Protocol_MSG_CASHIER_PLAY_TRANSFER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PLAY_TRANSFER_REPLY: cli::Protocol_MSG_CASHIER_PLAY_TRANSFER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PM_PURCH_ITEMS_AVAIL: cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY: cli::Protocol_MSG_CASHIER_PM_PURCH_ITEMS_AVAIL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PM_WATCH2EARN_FINISH: cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY: cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_FINISH_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PM_WATCH2EARN_START: cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PM_WATCH2EARN_START_REPLY: cli::Protocol_MSG_CASHIER_PM_WATCH2EARN_START_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PRE_CASHIN2: cli::Protocol_MSG_CASHIER_PRE_CASHIN2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PRE_CASHIN2_REPLY: cli::Protocol_MSG_CASHIER_PRE_CASHIN2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PRE_CASHOUT: cli::Protocol_MSG_CASHIER_PRE_CASHOUT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PRE_CASHOUT_REPLY: cli::Protocol_MSG_CASHIER_PRE_CASHOUT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PSTARSPAY_BANK_SELECTED: cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY: cli::Protocol_MSG_CASHIER_PSTARSPAY_BANK_SELECTED_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_REAL_PRE_TRANSFER: cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_REAL_PRE_TRANSFER_REPLY: cli::Protocol_MSG_CASHIER_REAL_PRE_TRANSFER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_REAL_TRANSFER: cli::Protocol_MSG_CASHIER_REAL_TRANSFER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_REAL_TRANSFER_REPLY: cli::Protocol_MSG_CASHIER_REAL_TRANSFER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS: cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY: cli::Protocol_MSG_CASHIER_REJECT_RM_NOK_HELD_FUNDS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SAVED_CARD: cli::Protocol_MSG_CASHIER_SAVED_CARD::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SAVED_CARD_REPLY: cli::Protocol_MSG_CASHIER_SAVED_CARD_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SAVE_ASTROPAY_BANKINFO: cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY: cli::Protocol_MSG_CASHIER_SAVE_ASTROPAY_BANKINFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT: cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY: cli::Protocol_MSG_CASHIER_SAVE_PAYSYSTEM_CONSENT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO: cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY: cli::Protocol_MSG_CASHIER_SAVE_WIRE_CASHOUT_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SEND_USER_DOCS: cli::Protocol_MSG_CASHIER_SEND_USER_DOCS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SEND_USER_DOCS_REPLY: cli::Protocol_MSG_CASHIER_SEND_USER_DOCS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_DEFAULT_ACCOUNT: cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY: cli::Protocol_MSG_CASHIER_SET_DEFAULT_ACCOUNT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_GAMETICKET_STATUS: cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY: cli::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_RMF_BANKACCOUNT: cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY: cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_SPENDING_LIMIT: cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_SPENDING_LIMIT_REPLY: cli::Protocol_MSG_CASHIER_SET_SPENDING_LIMIT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_USERROLL_STATUS: cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_USERROLL_STATUS_REPLY: cli::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_USER_ALL_PRIVILEGES: cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY: cli::Protocol_MSG_CASHIER_SET_USER_ALL_PRIVILEGES_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_USER_LIMIT: cli::Protocol_MSG_CASHIER_SET_USER_LIMIT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_USER_LIMIT_EX: cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_USER_LIMIT_EX_REPLY: cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_EX_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_USER_LIMIT_REPLY: cli::Protocol_MSG_CASHIER_SET_USER_LIMIT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SIGHTLINE_SIGNUP: cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY: cli::Protocol_MSG_CASHIER_SIGHTLINE_SIGNUP_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_STARSWALLET_CHANGE_MOBILE: cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY: cli::Protocol_MSG_CASHIER_STARSWALLET_CHANGE_MOBILE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_STARSWALLET_CHECK_MTAN: cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY: cli::Protocol_MSG_CASHIER_STARSWALLET_CHECK_MTAN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_STARSWALLET_OTP_RECEIVED: cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY: cli::Protocol_MSG_CASHIER_STARSWALLET_OTP_RECEIVED_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_STARSWALLET_REGISTER: cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_STARSWALLET_REGISTER_REPLY: cli::Protocol_MSG_CASHIER_STARSWALLET_REGISTER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_STARSWALLET_RESEND_MTAN: cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY: cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_MTAN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_STARSWALLET_RESEND_OTP: cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY: cli::Protocol_MSG_CASHIER_STARSWALLET_RESEND_OTP_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SUGGEST_PAYSYSTEMS: cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY: cli::Protocol_MSG_CASHIER_SUGGEST_PAYSYSTEMS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TCHIPS_CANCELID: cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TCHIPS_CANCELID_REPLY: cli::Protocol_MSG_CASHIER_TCHIPS_CANCELID_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TCHIPS_PRECANCEL: cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TCHIPS_PRECANCEL_REPLY: cli::Protocol_MSG_CASHIER_TCHIPS_PRECANCEL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TCHIPS_PRESALE: cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TCHIPS_PRESALE_REPLY: cli::Protocol_MSG_CASHIER_TCHIPS_PRESALE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TCHIPS_SALE: cli::Protocol_MSG_CASHIER_TCHIPS_SALE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TCHIPS_SALE_REPLY: cli::Protocol_MSG_CASHIER_TCHIPS_SALE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TCHIPS_SALE_TO_PSTARS: cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY: cli::Protocol_MSG_CASHIER_TCHIPS_SALE_TO_PSTARS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TSALE_GET_INFO: cli::Protocol_MSG_CASHIER_TSALE_GET_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TSALE_GET_INFO_REPLY: cli::Protocol_MSG_CASHIER_TSALE_GET_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION: cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY: cli::Protocol_MSG_CASHIER_TURN_ON_OFF_GAMEIN_AUTOCONVERSION_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO: cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY: cli::Protocol_MSG_CASHIER_UPDATE_FAST_DEPOSIT_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_UPDATE_USERROLLS_ORDER: cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY: cli::Protocol_MSG_CASHIER_UPDATE_USERROLLS_ORDER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_USER_ACCT_PROC_REGISTRATION: cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY: cli::Protocol_MSG_CASHIER_USER_ACCT_PROC_REGISTRATION_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_USER_BONUSHIST_NEW: cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_USER_BONUSHIST_NEW_REPLY: cli::Protocol_MSG_CASHIER_USER_BONUSHIST_NEW_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_VALIDATION_CANCEL: cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_VALIDATION_CANCEL_REPLY: cli::Protocol_MSG_CASHIER_VALIDATION_CANCEL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_VALINNARELOAD_GET_BARCODE: cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY: cli::Protocol_MSG_CASHIER_VALINNARELOAD_GET_BARCODE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_VALINNARELOAD_SIGNUP: cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY: cli::Protocol_MSG_CASHIER_VALINNARELOAD_SIGNUP_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_VERIFY_AGE: cli::Protocol_MSG_CASHIER_VERIFY_AGE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_VERIFY_AGE_REPLY: cli::Protocol_MSG_CASHIER_VERIFY_AGE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_VIP_INFO: cli::Protocol_MSG_CASHIER_VIP_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_VIP_INFO_REPLY: cli::Protocol_MSG_CASHIER_VIP_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO: cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY: cli::Protocol_MSG_CASHIER_VOUCHER_AMOUNTCURRENCY_GET_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_WIRE_REQUEST: cli::Protocol_MSG_CASHIER_WIRE_REQUEST::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_WIRE_REQUEST_REPLY: cli::Protocol_MSG_CASHIER_WIRE_REQUEST_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "cli_lite"))
	{
		switch(_msgId)
		{
			case MSG_CASHIER_SET_GAMETICKET_STATUS: cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY: cli_lite::Protocol_MSG_CASHIER_SET_GAMETICKET_STATUS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_USERROLL_STATUS: cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_USERROLL_STATUS_REPLY: cli_lite::Protocol_MSG_CASHIER_SET_USERROLL_STATUS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_USER_LOGGED_IN: cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_USER_LOGGED_IN_REPLY: cli_lite::Protocol_MSG_CASHIER_USER_LOGGED_IN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

