/**
 * mlobbyNG_atf_thin.cpp
 *
 * This file was auto-generated from mlobbyNG_atf.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor -thin mlobbyNG_atf.txt
 */
 
#include "mlobbyNG_atf_thin.h"

//=================================================================
//                    TournSelectionFilter
//=================================================================

MLobbyNG::cli::TournSelectionFilter::TournSelectionFilter()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::TournSelectionFilter::TournSelectionFilter(TournSelectionFilter&& _o)
	: locale(std::move(_o.locale))
	, gameMask(std::move(_o.gameMask))
	, buyInMask(std::move(_o.buyInMask))
	, minBuyIn(std::move(_o.minBuyIn))
	, maxBuyIn(std::move(_o.maxBuyIn))
	, speedMask(std::move(_o.speedMask))
	, tournTypeMask(std::move(_o.tournTypeMask))
	, currencyMask(std::move(_o.currencyMask))
	, tableSizeMask(std::move(_o.tableSizeMask))
	, tournVariantMask(std::move(_o.tournVariantMask))
	, tournStateMask(std::move(_o.tournStateMask))
	, startingWithin(std::move(_o.startingWithin))
	, country(std::move(_o.country))
	, isPM(std::move(_o.isPM))
	, tournGroups(std::move(_o.tournGroups))
	, lateRegCutoff(std::move(_o.lateRegCutoff))
	, genderRestrictMask(std::move(_o.genderRestrictMask))
	, tournDisplayMask(std::move(_o.tournDisplayMask))
	, negateTournVariantMask(std::move(_o.negateTournVariantMask))
{
}

MLobbyNG::cli::TournSelectionFilter& MLobbyNG::cli::TournSelectionFilter::operator=(TournSelectionFilter&& _o)
{
	if(this != &_o)
	{
		locale = std::move(_o.locale);
		gameMask = std::move(_o.gameMask);
		buyInMask = std::move(_o.buyInMask);
		minBuyIn = std::move(_o.minBuyIn);
		maxBuyIn = std::move(_o.maxBuyIn);
		speedMask = std::move(_o.speedMask);
		tournTypeMask = std::move(_o.tournTypeMask);
		currencyMask = std::move(_o.currencyMask);
		tableSizeMask = std::move(_o.tableSizeMask);
		tournVariantMask = std::move(_o.tournVariantMask);
		tournStateMask = std::move(_o.tournStateMask);
		startingWithin = std::move(_o.startingWithin);
		country = std::move(_o.country);
		isPM = std::move(_o.isPM);
		tournGroups = std::move(_o.tournGroups);
		lateRegCutoff = std::move(_o.lateRegCutoff);
		genderRestrictMask = std::move(_o.genderRestrictMask);
		tournDisplayMask = std::move(_o.tournDisplayMask);
		negateTournVariantMask = std::move(_o.negateTournVariantMask);
	}
	return *this;
}

#endif

void MLobbyNG::cli::TournSelectionFilter::clear()
{
	locale = 0;
	gameMask = 0;
	buyInMask = 0;
	minBuyIn = 0;
	maxBuyIn = 0;
	speedMask = 0;
	tournTypeMask = 0;
	currencyMask = 0;
	tableSizeMask = 0;
	tournVariantMask = 0;
	tournStateMask = 0;
	startingWithin = 0;
	country.clear();
	isPM = false;
	tournGroups.clear();
	lateRegCutoff = 0;
	genderRestrictMask = 0;
	tournDisplayMask = 0;
	negateTournVariantMask = 0;
}

bool MLobbyNG::cli::TournSelectionFilter::equals(const TournSelectionFilter& _o) const
{
	return locale == _o.locale &&
		gameMask == _o.gameMask &&
		buyInMask == _o.buyInMask &&
		minBuyIn == _o.minBuyIn &&
		maxBuyIn == _o.maxBuyIn &&
		speedMask == _o.speedMask &&
		tournTypeMask == _o.tournTypeMask &&
		currencyMask == _o.currencyMask &&
		tableSizeMask == _o.tableSizeMask &&
		tournVariantMask == _o.tournVariantMask &&
		tournStateMask == _o.tournStateMask &&
		startingWithin == _o.startingWithin &&
		country.equals(_o.country) &&
		isPM == _o.isPM &&
		tournGroups.equals(_o.tournGroups) &&
		lateRegCutoff == _o.lateRegCutoff &&
		genderRestrictMask == _o.genderRestrictMask &&
		tournDisplayMask == _o.tournDisplayMask &&
		negateTournVariantMask == _o.negateTournVariantMask;
}

const char *MLobbyNG::cli::TournSelectionFilter::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("gameMask=");
	_buf.appendUint64(gameMask);
	_buf.append(',');
	_buf.append("buyInMask=");
	_buf.appendUint(buyInMask);
	_buf.append(',');
	_buf.append("minBuyIn=");
	_buf.appendUint64(minBuyIn);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendUint64(maxBuyIn);
	_buf.append(',');
	_buf.append("speedMask=");
	_buf.appendUint(speedMask);
	_buf.append(',');
	_buf.append("tournTypeMask=");
	_buf.appendUint(tournTypeMask);
	_buf.append(',');
	_buf.append("currencyMask=");
	_buf.appendUint(currencyMask);
	_buf.append(',');
	_buf.append("tableSizeMask=");
	_buf.appendUint(tableSizeMask);
	_buf.append(',');
	_buf.append("tournVariantMask=");
	_buf.appendUint(tournVariantMask);
	_buf.append(',');
	_buf.append("tournStateMask=");
	_buf.appendUint(tournStateMask);
	_buf.append(',');
	_buf.append("startingWithin=");
	_buf.appendUint(startingWithin);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("isPM=");
	_buf.appendUint(isPM);
	_buf.append(',');
	_buf.append("tournGroups=");
	tournGroups.toTraceString(_buf);
	_buf.append(',');
	_buf.append("lateRegCutoff=");
	_buf.appendInt(lateRegCutoff);
	_buf.append(',');
	_buf.append("genderRestrictMask=");
	_buf.appendUint(genderRestrictMask);
	_buf.append(',');
	_buf.append("tournDisplayMask=");
	_buf.appendUint(tournDisplayMask);
	_buf.append(',');
	_buf.append("negateTournVariantMask=");
	_buf.appendUint(negateTournVariantMask);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::TournSelectionFilter::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(TournSelectionFilter())) // not empty
	{
		_body.composeUINT32(locale);
		_body.composeUINT64(gameMask);
		_body.composeUINT32(buyInMask);
		_body.composeUINT64(minBuyIn);
		_body.composeUINT64(maxBuyIn);
		_body.composeUINT32(speedMask);
		_body.composeUINT32(tournTypeMask);
		_body.composeUINT32(currencyMask);
		_body.composeUINT32(tableSizeMask);
		_body.composeUINT32(tournVariantMask);
		_body.composeUINT32(tournStateMask);
		_body.composeUINT32(startingWithin);
		_body.composeString(country);
		_body.composeBOOL(isPM);
		tournGroups.composeMsg(_body);
		_body.composeINT32(lateRegCutoff);
		_body.composeUINT32(genderRestrictMask);
		_body.composeUINT32(tournDisplayMask);
		_body.composeUINT32(negateTournVariantMask);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::TournSelectionFilter::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(locale);
	_parser0.parseUINT64(gameMask);
	_parser0.parseUINT32(buyInMask);
	_parser0.parseUINT64(minBuyIn);
	_parser0.parseUINT64(maxBuyIn);
	_parser0.parseUINT32(speedMask);
	_parser0.parseUINT32(tournTypeMask);
	_parser0.parseUINT32(currencyMask);
	_parser0.parseUINT32(tableSizeMask);
	_parser0.parseUINT32(tournVariantMask);
	_parser0.parseUINT32(tournStateMask);
	_parser0.parseUINT32(startingWithin);
	_parser0.parseStringP(country);
	_parser0.parseBOOL(isPM);
	tournGroups.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT32(lateRegCutoff);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT32(genderRestrictMask);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT32(tournDisplayMask);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT32(negateTournVariantMask);
}

/*static*/ void MLobbyNG::cli::TournSelectionFilter::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 locale; _parser0.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT64 gameMask; _parser0.parseUINT64(gameMask);
	AtfValidator::validateUintMax(_descr, "gameMask", gameMask, (2*(UINT64)NGGameTypes::NGGame_Last-1), _checker, __FILE__, __LINE__);
	UINT32 buyInMask; _parser0.parseUINT32(buyInMask);
	AtfValidator::validateIntMax(_descr, "buyInMask", buyInMask, (2*NGBuyIn_Last-1), _checker, __FILE__, __LINE__);
	UINT64 minBuyIn; _parser0.parseUINT64(minBuyIn);
	AtfValidator::validateUint(_descr, "minBuyIn", minBuyIn, _checker, __FILE__, __LINE__);
	UINT64 maxBuyIn; _parser0.parseUINT64(maxBuyIn);
	AtfValidator::validateUint(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	UINT32 speedMask; _parser0.parseUINT32(speedMask);
	AtfValidator::validateIntMax(_descr, "speedMask", speedMask, (2*NGTournSpeed_Last-1), _checker, __FILE__, __LINE__);
	UINT32 tournTypeMask; _parser0.parseUINT32(tournTypeMask);
	AtfValidator::validateIntMax(_descr, "tournTypeMask", tournTypeMask, (2*NGTournType_Last-1), _checker, __FILE__, __LINE__);
	UINT32 currencyMask; _parser0.parseUINT32(currencyMask);
	AtfValidator::validateIntMax(_descr, "currencyMask", currencyMask, (2*NGCurrency_Last-1), _checker, __FILE__, __LINE__);
	UINT32 tableSizeMask; _parser0.parseUINT32(tableSizeMask);
	AtfValidator::validateIntMax(_descr, "tableSizeMask", tableSizeMask, (2*NGMaxTableSize_Last-1), _checker, __FILE__, __LINE__);
	UINT32 tournVariantMask; _parser0.parseUINT32(tournVariantMask);
	AtfValidator::validateIntMax(_descr, "tournVariantMask", tournVariantMask, (2*NGTournVariant_Last-1), _checker, __FILE__, __LINE__);
	UINT32 tournStateMask; _parser0.parseUINT32(tournStateMask);
	AtfValidator::validateIntMax(_descr, "tournStateMask", tournStateMask, (2*NGTournState_Last-1), _checker, __FILE__, __LINE__);
	UINT32 startingWithin; _parser0.parseUINT32(startingWithin);
	AtfValidator::validateIntMax(_descr, "startingWithin", startingWithin, 1440, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, 3, _checker, __FILE__, __LINE__);
	bool isPM; _parser0.parseBOOL(isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTournGroups = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tournGroups"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "tournGroups", szTournGroups, TournGroup_Last, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT32 lateRegCutoff; _parser0.parseINT32(lateRegCutoff);
	AtfValidator::validateInt(_descr, "lateRegCutoff", lateRegCutoff, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	UINT32 genderRestrictMask; _parser0.parseUINT32(genderRestrictMask);
	AtfValidator::validateIntMax(_descr, "genderRestrictMask", genderRestrictMask, (2*RestrictedTo_Last-1), _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	UINT32 tournDisplayMask; _parser0.parseUINT32(tournDisplayMask);
	AtfValidator::validateIntMax(_descr, "tournDisplayMask", tournDisplayMask, (2*NGTournDisplay_Last-1), _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	UINT32 negateTournVariantMask; _parser0.parseUINT32(negateTournVariantMask);
	AtfValidator::validateIntMax(_descr, "negateTournVariantMask", negateTournVariantMask, (2*NGTournVariant_Last-1), _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TournResultCriteria
//=================================================================

MLobbyNG::cli::TournResultCriteria::TournResultCriteria()
{
	clear();
}

void MLobbyNG::cli::TournResultCriteria::clear()
{
	sortOrder = 0;
	maxItems = 0;
}

bool MLobbyNG::cli::TournResultCriteria::equals(const TournResultCriteria& _o) const
{
	return sortOrder == _o.sortOrder &&
		maxItems == _o.maxItems;
}

const char *MLobbyNG::cli::TournResultCriteria::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("sortOrder=");
	_buf.appendUint(sortOrder);
	_buf.append(',');
	_buf.append("maxItems=");
	_buf.appendUint(maxItems);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::TournResultCriteria::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(TournResultCriteria())) // not empty
	{
		_body.composeUINT32(sortOrder);
		_body.composeUINT32(maxItems);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::TournResultCriteria::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(sortOrder);
	_parser0.parseUINT32(maxItems);
}

/*static*/ void MLobbyNG::cli::TournResultCriteria::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 sortOrder; _parser0.parseUINT32(sortOrder);
	AtfValidator::validateIntRange(_descr, "sortOrder", sortOrder, NGTournSort_BuyInAsc, NGTournSort_Last, _checker, __FILE__, __LINE__);
	UINT32 maxItems; _parser0.parseUINT32(maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ClientMarkers
//=================================================================

MLobbyNG::cli::ClientMarkers::ClientMarkers()
{
	clear();
}

void MLobbyNG::cli::ClientMarkers::clear()
{
	context = 0;
}

bool MLobbyNG::cli::ClientMarkers::equals(const ClientMarkers& _o) const
{
	return context == _o.context;
}

const char *MLobbyNG::cli::ClientMarkers::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("context=");
	_buf.appendUint(context);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::ClientMarkers::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(ClientMarkers())) // not empty
	{
		_body.composeUINT32(context);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::ClientMarkers::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(context);
}

/*static*/ void MLobbyNG::cli::ClientMarkers::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 context; _parser0.parseUINT32(context);
	AtfValidator::validateInt(_descr, "context", context, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    FppFactorStruct
//=================================================================

MLobbyNG::cli::FppFactorStruct::FppFactorStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::FppFactorStruct::FppFactorStruct(FppFactorStruct&& _o)
	: fppFactor(std::move(_o.fppFactor))
	, sites(std::move(_o.sites))
	, gameCategory(std::move(_o.gameCategory))
	, number(std::move(_o.number))
	, endT(std::move(_o.endT))
	, sitesEx(std::move(_o.sitesEx))
{
}

MLobbyNG::cli::FppFactorStruct& MLobbyNG::cli::FppFactorStruct::operator=(FppFactorStruct&& _o)
{
	if(this != &_o)
	{
		fppFactor = std::move(_o.fppFactor);
		sites = std::move(_o.sites);
		gameCategory = std::move(_o.gameCategory);
		number = std::move(_o.number);
		endT = std::move(_o.endT);
		sitesEx = std::move(_o.sitesEx);
	}
	return *this;
}

#endif

void MLobbyNG::cli::FppFactorStruct::clear()
{
	fppFactor = 0;
	sites = 0;
	gameCategory = 0;
	number = 0;
	endT.setNull();
	sitesEx.clear();
}

bool MLobbyNG::cli::FppFactorStruct::equals(const FppFactorStruct& _o) const
{
	return fppFactor == _o.fppFactor &&
		sites == _o.sites &&
		gameCategory == _o.gameCategory &&
		number == _o.number &&
		endT.equals(_o.endT) &&
		sitesEx.equals(_o.sitesEx);
}

const char *MLobbyNG::cli::FppFactorStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("fppFactor=");
	_buf.appendUint(fppFactor);
	_buf.append(',');
	_buf.append("sites=");
	_buf.appendUint(sites);
	_buf.append(',');
	_buf.append("gameCategory=");
	_buf.appendUint(gameCategory);
	_buf.append(',');
	_buf.append("number=");
	_buf.appendUint(number);
	_buf.append(',');
	_buf.append("endT=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, endT);
	_buf.append(',');
	_buf.append("sitesEx=");
	sitesEx.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::FppFactorStruct::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(FppFactorStruct())) // not empty
	{
		_body.composeUINT16(fppFactor);
		_body.composeUINT32(sites);
		_body.composeUINT32(gameCategory);
		_body.composeUINT32(number);
		_body.composeSrvTime(endT);
		sitesEx.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::FppFactorStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT16(fppFactor);
	_parser0.parseUINT32(sites);
	_parser0.parseUINT32(gameCategory);
	_parser0.parseUINT32(number);
	_parser0.parseSrvTime(endT);
	if(_parser0.parseEnded()) return;
	sitesEx.parseMsg(_parser0);
}

/*static*/ void MLobbyNG::cli::FppFactorStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT16 fppFactor; _parser0.parseUINT16(fppFactor);
	AtfValidator::validateInt(_descr, "fppFactor", fppFactor, _checker, __FILE__, __LINE__);
	UINT32 sites; _parser0.parseUINT32(sites);
	AtfValidator::validateInt(_descr, "sites", sites, _checker, __FILE__, __LINE__);
	UINT32 gameCategory; _parser0.parseUINT32(gameCategory);
	AtfValidator::validateInt(_descr, "gameCategory", gameCategory, _checker, __FILE__, __LINE__);
	UINT32 number; _parser0.parseUINT32(number);
	AtfValidator::validateInt(_descr, "number", number, _checker, __FILE__, __LINE__);
	SrvTime endT; _parser0.parseSrvTime(endT);
	AtfValidator::validateSrvDateTime(_descr, "endT", endT, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PString _descbuf;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("sitesEx"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TournStaticData
//=================================================================

MLobbyNG::cli::TournStaticData::TournStaticData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::TournStaticData::TournStaticData(TournStaticData&& _o)
	: tournamentId(std::move(_o.tournamentId))
	, server(std::move(_o.server))
	, targetServer(std::move(_o.targetServer))
	, hasSatellite(std::move(_o.hasSatellite))
	, whenStart(std::move(_o.whenStart))
	, buyIn(std::move(_o.buyIn))
	, rake(std::move(_o.rake))
	, fppBuyIn(std::move(_o.fppBuyIn))
	, isRestricted(std::move(_o.isRestricted))
	, isPwdProtected(std::move(_o.isPwdProtected))
	, name(std::move(_o.name))
	, admissionId(std::move(_o.admissionId))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, satelliteTarget(std::move(_o.satelliteTarget))
	, minPlayers(std::move(_o.minPlayers))
	, tournFlags(std::move(_o.tournFlags))
	, game(std::move(_o.game))
	, isHiLo(std::move(_o.isHiLo))
	, structure(std::move(_o.structure))
	, tournMask(std::move(_o.tournMask))
	, tournSites(std::move(_o.tournSites))
	, whenStartInt(std::move(_o.whenStartInt))
	, tournMask2(std::move(_o.tournMask2))
	, targetWhenStart(std::move(_o.targetWhenStart))
	, tournMask3(std::move(_o.tournMask3))
	, tournMask4(std::move(_o.tournMask4))
	, maxPerTable(std::move(_o.maxPerTable))
	, countryRestrictionInverted(std::move(_o.countryRestrictionInverted))
	, restrictedCountries(std::move(_o.restrictedCountries))
	, hasDayTwoStart(std::move(_o.hasDayTwoStart))
	, dayTwoStartSec(std::move(_o.dayTwoStartSec))
	, dayTwoStart(std::move(_o.dayTwoStart))
	, shortText(std::move(_o.shortText))
	, chatLang(std::move(_o.chatLang))
	, currency(std::move(_o.currency))
	, tournFlagsServInt(std::move(_o.tournFlagsServInt))
	, knockout(std::move(_o.knockout))
	, satelliteTargetReference(std::move(_o.satelliteTargetReference))
	, satelliteTargetReferenceLock(std::move(_o.satelliteTargetReferenceLock))
	, maxPlayers(std::move(_o.maxPlayers))
	, speedDisplay(std::move(_o.speedDisplay))
	, nameSnG(std::move(_o.nameSnG))
	, step(std::move(_o.step))
	, timedTournType(std::move(_o.timedTournType))
	, timedTournTime(std::move(_o.timedTournTime))
	, timedTournPayout(std::move(_o.timedTournPayout))
	, isFlightTourn(std::move(_o.isFlightTourn))
	, tournBrand(std::move(_o.tournBrand))
	, scalePM(std::move(_o.scalePM))
	, progressiveKnockout(std::move(_o.progressiveKnockout))
	, awardScheme(std::move(_o.awardScheme))
	, numReentries(std::move(_o.numReentries))
	, internalReference(std::move(_o.internalReference))
	, favReference(std::move(_o.favReference))
	, satelliteTargetName(std::move(_o.satelliteTargetName))
	, admissionPrice(std::move(_o.admissionPrice))
	, tournFlags2(std::move(_o.tournFlags2))
	, regEndAbs(std::move(_o.regEndAbs))
	, regEndAbsInt(std::move(_o.regEndAbsInt))
	, doNotAllowToUnreg(std::move(_o.doNotAllowToUnreg))
	, nStackInfo(std::move(_o.nStackInfo))
	, tournMask5(std::move(_o.tournMask5))
	, tournMask6(std::move(_o.tournMask6))
	, satelliteTargetNameMTT(std::move(_o.satelliteTargetNameMTT))
	, liveEventMask(std::move(_o.liveEventMask))
	, timedTournPlayersPercent(std::move(_o.timedTournPlayersPercent))
	, dummy1(std::move(_o.dummy1))
	, rmPmLobby(std::move(_o.rmPmLobby))
	, brandAccessMask(std::move(_o.brandAccessMask))
	, activeFlags(std::move(_o.activeFlags))
	, sngScriptId(std::move(_o.sngScriptId))
	, customSpeedDisplayName(std::move(_o.customSpeedDisplayName))
	, mobileName(std::move(_o.mobileName))
	, tournGroup(std::move(_o.tournGroup))
	, guaranteedPrizePool(std::move(_o.guaranteedPrizePool))
	, admissions(std::move(_o.admissions))
	, serverObj(std::move(_o.serverObj))
	, tournGroupRef(std::move(_o.tournGroupRef))
	, maxPayoutSag(std::move(_o.maxPayoutSag))
	, tournSitesEx(std::move(_o.tournSitesEx))
{
}

MLobbyNG::cli::TournStaticData& MLobbyNG::cli::TournStaticData::operator=(TournStaticData&& _o)
{
	if(this != &_o)
	{
		tournamentId = std::move(_o.tournamentId);
		server = std::move(_o.server);
		targetServer = std::move(_o.targetServer);
		hasSatellite = std::move(_o.hasSatellite);
		whenStart = std::move(_o.whenStart);
		buyIn = std::move(_o.buyIn);
		rake = std::move(_o.rake);
		fppBuyIn = std::move(_o.fppBuyIn);
		isRestricted = std::move(_o.isRestricted);
		isPwdProtected = std::move(_o.isPwdProtected);
		name = std::move(_o.name);
		admissionId = std::move(_o.admissionId);
		isPlayMoney = std::move(_o.isPlayMoney);
		satelliteTarget = std::move(_o.satelliteTarget);
		minPlayers = std::move(_o.minPlayers);
		tournFlags = std::move(_o.tournFlags);
		game = std::move(_o.game);
		isHiLo = std::move(_o.isHiLo);
		structure = std::move(_o.structure);
		tournMask = std::move(_o.tournMask);
		tournSites = std::move(_o.tournSites);
		whenStartInt = std::move(_o.whenStartInt);
		tournMask2 = std::move(_o.tournMask2);
		targetWhenStart = std::move(_o.targetWhenStart);
		tournMask3 = std::move(_o.tournMask3);
		tournMask4 = std::move(_o.tournMask4);
		maxPerTable = std::move(_o.maxPerTable);
		countryRestrictionInverted = std::move(_o.countryRestrictionInverted);
		restrictedCountries = std::move(_o.restrictedCountries);
		hasDayTwoStart = std::move(_o.hasDayTwoStart);
		dayTwoStartSec = std::move(_o.dayTwoStartSec);
		dayTwoStart = std::move(_o.dayTwoStart);
		shortText = std::move(_o.shortText);
		chatLang = std::move(_o.chatLang);
		currency = std::move(_o.currency);
		tournFlagsServInt = std::move(_o.tournFlagsServInt);
		knockout = std::move(_o.knockout);
		satelliteTargetReference = std::move(_o.satelliteTargetReference);
		satelliteTargetReferenceLock = std::move(_o.satelliteTargetReferenceLock);
		maxPlayers = std::move(_o.maxPlayers);
		speedDisplay = std::move(_o.speedDisplay);
		nameSnG = std::move(_o.nameSnG);
		step = std::move(_o.step);
		timedTournType = std::move(_o.timedTournType);
		timedTournTime = std::move(_o.timedTournTime);
		timedTournPayout = std::move(_o.timedTournPayout);
		isFlightTourn = std::move(_o.isFlightTourn);
		tournBrand = std::move(_o.tournBrand);
		scalePM = std::move(_o.scalePM);
		progressiveKnockout = std::move(_o.progressiveKnockout);
		awardScheme = std::move(_o.awardScheme);
		numReentries = std::move(_o.numReentries);
		internalReference = std::move(_o.internalReference);
		favReference = std::move(_o.favReference);
		satelliteTargetName = std::move(_o.satelliteTargetName);
		admissionPrice = std::move(_o.admissionPrice);
		tournFlags2 = std::move(_o.tournFlags2);
		regEndAbs = std::move(_o.regEndAbs);
		regEndAbsInt = std::move(_o.regEndAbsInt);
		doNotAllowToUnreg = std::move(_o.doNotAllowToUnreg);
		nStackInfo = std::move(_o.nStackInfo);
		tournMask5 = std::move(_o.tournMask5);
		tournMask6 = std::move(_o.tournMask6);
		satelliteTargetNameMTT = std::move(_o.satelliteTargetNameMTT);
		liveEventMask = std::move(_o.liveEventMask);
		timedTournPlayersPercent = std::move(_o.timedTournPlayersPercent);
		dummy1 = std::move(_o.dummy1);
		rmPmLobby = std::move(_o.rmPmLobby);
		brandAccessMask = std::move(_o.brandAccessMask);
		activeFlags = std::move(_o.activeFlags);
		sngScriptId = std::move(_o.sngScriptId);
		customSpeedDisplayName = std::move(_o.customSpeedDisplayName);
		mobileName = std::move(_o.mobileName);
		tournGroup = std::move(_o.tournGroup);
		guaranteedPrizePool = std::move(_o.guaranteedPrizePool);
		admissions = std::move(_o.admissions);
		serverObj = std::move(_o.serverObj);
		tournGroupRef = std::move(_o.tournGroupRef);
		maxPayoutSag = std::move(_o.maxPayoutSag);
		tournSitesEx = std::move(_o.tournSitesEx);
	}
	return *this;
}

#endif

void MLobbyNG::cli::TournStaticData::clear()
{
	tournamentId = 0;
	server.clear();
	targetServer.clear();
	hasSatellite.clear();
	whenStart.setNull();
	buyIn = 0;
	rake = 0;
	fppBuyIn = 0;
	isRestricted = 0;
	isPwdProtected = 0;
	name.clear();
	admissionId.clear();
	isPlayMoney = 0;
	satelliteTarget = 0;
	minPlayers = 0;
	tournFlags = 0;
	game = 0;
	isHiLo = 0;
	structure = 0;
	tournMask = 0;
	tournSites = 0;
	whenStartInt = 0;
	tournMask2 = 0;
	targetWhenStart.setNull();
	tournMask3 = 0;
	tournMask4 = 0;
	maxPerTable = 0;
	countryRestrictionInverted = false;
	restrictedCountries.clear();
	hasDayTwoStart = 0;
	dayTwoStartSec = 0;
	dayTwoStart.setNull();
	shortText.clear();
	chatLang = 0;
	currency.clear();
	tournFlagsServInt = 0;
	knockout = 0;
	satelliteTargetReference.clear();
	satelliteTargetReferenceLock = 0;
	maxPlayers = 0;
	speedDisplay = 0;
	nameSnG.clear();
	step = 0;
	timedTournType = 0;
	timedTournTime = 0;
	timedTournPayout = 0;
	isFlightTourn = false;
	tournBrand.clear();
	scalePM = 0;
	progressiveKnockout = 0;
	awardScheme = 0;
	numReentries = 0;
	internalReference.clear();
	favReference.clear();
	satelliteTargetName.clear();
	admissionPrice = 0;
	tournFlags2 = 0;
	regEndAbs.setNull();
	regEndAbsInt = 0;
	doNotAllowToUnreg = false;
	nStackInfo.clear();
	tournMask5 = 0;
	tournMask6 = 0;
	satelliteTargetNameMTT.clear();
	liveEventMask = 0;
	timedTournPlayersPercent = 0;
	dummy1 = 0;
	rmPmLobby = 0;
	brandAccessMask = 0;
	activeFlags = 0;
	sngScriptId = 0;
	customSpeedDisplayName.clear();
	mobileName.clear();
	tournGroup = 0;
	guaranteedPrizePool = 0;
	admissions.clear();
	serverObj.clear();
	tournGroupRef.clear();
	maxPayoutSag = 0;
	tournSitesEx.clear();
}

bool MLobbyNG::cli::TournStaticData::equals(const TournStaticData& _o) const
{
	return tournamentId == _o.tournamentId &&
		server.equals(_o.server) &&
		targetServer.equals(_o.targetServer) &&
		hasSatellite.equals(_o.hasSatellite) &&
		whenStart.equals(_o.whenStart) &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		fppBuyIn == _o.fppBuyIn &&
		isRestricted == _o.isRestricted &&
		isPwdProtected == _o.isPwdProtected &&
		name.equals(_o.name) &&
		admissionId.equals(_o.admissionId) &&
		isPlayMoney == _o.isPlayMoney &&
		satelliteTarget == _o.satelliteTarget &&
		minPlayers == _o.minPlayers &&
		tournFlags == _o.tournFlags &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		structure == _o.structure &&
		tournMask == _o.tournMask &&
		tournSites == _o.tournSites &&
		whenStartInt == _o.whenStartInt &&
		tournMask2 == _o.tournMask2 &&
		targetWhenStart.equals(_o.targetWhenStart) &&
		tournMask3 == _o.tournMask3 &&
		tournMask4 == _o.tournMask4 &&
		maxPerTable == _o.maxPerTable &&
		countryRestrictionInverted == _o.countryRestrictionInverted &&
		restrictedCountries.equals(_o.restrictedCountries) &&
		hasDayTwoStart == _o.hasDayTwoStart &&
		dayTwoStartSec == _o.dayTwoStartSec &&
		dayTwoStart.equals(_o.dayTwoStart) &&
		shortText.equals(_o.shortText) &&
		chatLang == _o.chatLang &&
		currency.equals(_o.currency) &&
		tournFlagsServInt == _o.tournFlagsServInt &&
		knockout == _o.knockout &&
		satelliteTargetReference.equals(_o.satelliteTargetReference) &&
		satelliteTargetReferenceLock == _o.satelliteTargetReferenceLock &&
		maxPlayers == _o.maxPlayers &&
		speedDisplay == _o.speedDisplay &&
		nameSnG.equals(_o.nameSnG) &&
		step == _o.step &&
		timedTournType == _o.timedTournType &&
		timedTournTime == _o.timedTournTime &&
		timedTournPayout == _o.timedTournPayout &&
		isFlightTourn == _o.isFlightTourn &&
		tournBrand.equals(_o.tournBrand) &&
		scalePM == _o.scalePM &&
		progressiveKnockout == _o.progressiveKnockout &&
		awardScheme == _o.awardScheme &&
		numReentries == _o.numReentries &&
		internalReference.equals(_o.internalReference) &&
		favReference.equals(_o.favReference) &&
		satelliteTargetName.equals(_o.satelliteTargetName) &&
		admissionPrice == _o.admissionPrice &&
		tournFlags2 == _o.tournFlags2 &&
		regEndAbs.equals(_o.regEndAbs) &&
		regEndAbsInt == _o.regEndAbsInt &&
		doNotAllowToUnreg == _o.doNotAllowToUnreg &&
		nStackInfo.equals(_o.nStackInfo) &&
		tournMask5 == _o.tournMask5 &&
		tournMask6 == _o.tournMask6 &&
		satelliteTargetNameMTT.equals(_o.satelliteTargetNameMTT) &&
		liveEventMask == _o.liveEventMask &&
		timedTournPlayersPercent == _o.timedTournPlayersPercent &&
		dummy1 == _o.dummy1 &&
		rmPmLobby == _o.rmPmLobby &&
		brandAccessMask == _o.brandAccessMask &&
		activeFlags == _o.activeFlags &&
		sngScriptId == _o.sngScriptId &&
		customSpeedDisplayName.equals(_o.customSpeedDisplayName) &&
		mobileName.equals(_o.mobileName) &&
		tournGroup == _o.tournGroup &&
		guaranteedPrizePool == _o.guaranteedPrizePool &&
		admissions.equals(_o.admissions) &&
		serverObj.equals(_o.serverObj) &&
		tournGroupRef.equals(_o.tournGroupRef) &&
		maxPayoutSag == _o.maxPayoutSag &&
		tournSitesEx.equals(_o.tournSitesEx);
}

const char *MLobbyNG::cli::TournStaticData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournamentId=");
	_buf.appendUint64(tournamentId);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("targetServer=");
	_buf.append(targetServer);
	_buf.append(',');
	_buf.append("hasSatellite=");
	_buf.append(hasSatellite);
	_buf.append(',');
	_buf.append("whenStart=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, whenStart);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendUint(buyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendUint(rake);
	_buf.append(',');
	_buf.append("fppBuyIn=");
	_buf.appendUint(fppBuyIn);
	_buf.append(',');
	_buf.append("isRestricted=");
	_buf.appendUint(isRestricted);
	_buf.append(',');
	_buf.append("isPwdProtected=");
	_buf.appendUint(isPwdProtected);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("admissionId=");
	_buf.append(admissionId);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("satelliteTarget=");
	_buf.appendUint(satelliteTarget);
	_buf.append(',');
	_buf.append("minPlayers=");
	_buf.appendUint(minPlayers);
	_buf.append(',');
	_buf.append("tournFlags=");
	_buf.appendUint(tournFlags);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("tournMask=");
	_buf.appendUint(tournMask);
	_buf.append(',');
	_buf.append("tournSites=");
	_buf.appendUint(tournSites);
	_buf.append(',');
	_buf.append("whenStartInt=");
	_buf.appendUint(whenStartInt);
	_buf.append(',');
	_buf.append("tournMask2=");
	_buf.appendUint(tournMask2);
	_buf.append(',');
	_buf.append("targetWhenStart=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, targetWhenStart);
	_buf.append(',');
	_buf.append("tournMask3=");
	_buf.appendUint(tournMask3);
	_buf.append(',');
	_buf.append("tournMask4=");
	_buf.appendUint(tournMask4);
	_buf.append(',');
	_buf.append("maxPerTable=");
	_buf.appendUint(maxPerTable);
	_buf.append(',');
	_buf.append("countryRestrictionInverted=");
	_buf.appendUint(countryRestrictionInverted);
	_buf.append(',');
	_buf.append("restrictedCountries=");
	restrictedCountries.toTraceString(_buf);
	_buf.append(',');
	_buf.append("hasDayTwoStart=");
	_buf.appendUint(hasDayTwoStart);
	_buf.append(',');
	_buf.append("dayTwoStartSec=");
	_buf.appendUint(dayTwoStartSec);
	_buf.append(',');
	_buf.append("dayTwoStart=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, dayTwoStart);
	_buf.append(',');
	_buf.append("shortText=");
	_buf.append(shortText);
	_buf.append(',');
	_buf.append("chatLang=");
	_buf.appendUint(chatLang);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("tournFlagsServInt=");
	_buf.appendUint(tournFlagsServInt);
	_buf.append(',');
	_buf.append("knockout=");
	_buf.appendUint(knockout);
	_buf.append(',');
	_buf.append("satelliteTargetReference=");
	_buf.append(satelliteTargetReference);
	_buf.append(',');
	_buf.append("satelliteTargetReferenceLock=");
	_buf.appendUint(satelliteTargetReferenceLock);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendUint(maxPlayers);
	_buf.append(',');
	_buf.append("speedDisplay=");
	_buf.appendUint(speedDisplay);
	_buf.append(',');
	_buf.append("nameSnG=");
	_buf.append(nameSnG);
	_buf.append(',');
	_buf.append("step=");
	_buf.appendUint(step);
	_buf.append(',');
	_buf.append("timedTournType=");
	_buf.appendUint(timedTournType);
	_buf.append(',');
	_buf.append("timedTournTime=");
	_buf.appendUint(timedTournTime);
	_buf.append(',');
	_buf.append("timedTournPayout=");
	_buf.appendUint(timedTournPayout);
	_buf.append(',');
	_buf.append("isFlightTourn=");
	_buf.appendUint(isFlightTourn);
	_buf.append(',');
	_buf.append("tournBrand=");
	_buf.append(tournBrand);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("progressiveKnockout=");
	_buf.appendUint(progressiveKnockout);
	_buf.append(',');
	_buf.append("awardScheme=");
	_buf.appendUint(awardScheme);
	_buf.append(',');
	_buf.append("numReentries=");
	_buf.appendUint(numReentries);
	_buf.append(',');
	_buf.append("internalReference=");
	_buf.append(internalReference);
	_buf.append(',');
	_buf.append("favReference=");
	_buf.append(favReference);
	_buf.append(',');
	_buf.append("satelliteTargetName=");
	_buf.append(satelliteTargetName);
	_buf.append(',');
	_buf.append("admissionPrice=");
	_buf.appendInt64(admissionPrice);
	_buf.append(',');
	_buf.append("tournFlags2=");
	_buf.appendUint64(tournFlags2);
	_buf.append(',');
	_buf.append("regEndAbs=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, regEndAbs);
	_buf.append(',');
	_buf.append("regEndAbsInt=");
	_buf.appendUint(regEndAbsInt);
	_buf.append(',');
	_buf.append("doNotAllowToUnreg=");
	_buf.appendUint(doNotAllowToUnreg);
	_buf.append(',');
	_buf.append("nStackInfo=");
	nStackInfo.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tournMask5=");
	_buf.appendUint(tournMask5);
	_buf.append(',');
	_buf.append("tournMask6=");
	_buf.appendUint(tournMask6);
	_buf.append(',');
	_buf.append("satelliteTargetNameMTT=");
	_buf.append(satelliteTargetNameMTT);
	_buf.append(',');
	_buf.append("liveEventMask=");
	_buf.appendUint(liveEventMask);
	_buf.append(',');
	_buf.append("timedTournPlayersPercent=");
	_buf.appendUint(timedTournPlayersPercent);
	_buf.append(',');
	_buf.append("dummy1=");
	_buf.appendUint(dummy1);
	_buf.append(',');
	_buf.append("rmPmLobby=");
	_buf.appendUint(rmPmLobby);
	_buf.append(',');
	_buf.append("brandAccessMask=");
	_buf.appendUint(brandAccessMask);
	_buf.append(',');
	_buf.append("activeFlags=");
	_buf.appendUint(activeFlags);
	_buf.append(',');
	_buf.append("sngScriptId=");
	_buf.appendUint(sngScriptId);
	_buf.append(',');
	_buf.append("customSpeedDisplayName=");
	_buf.append(customSpeedDisplayName);
	_buf.append(',');
	_buf.append("mobileName=");
	_buf.append(mobileName);
	_buf.append(',');
	_buf.append("tournGroup=");
	_buf.appendUint(tournGroup);
	_buf.append(',');
	_buf.append("guaranteedPrizePool=");
	_buf.appendInt(guaranteedPrizePool);
	_buf.append(',');
	_buf.append("admissions=");
	admissions.toTraceString(_buf);
	_buf.append(',');
	_buf.append("serverObj=");
	_buf.append(serverObj);
	_buf.append(',');
	_buf.append("tournGroupRef=");
	_buf.append(tournGroupRef);
	_buf.append(',');
	_buf.append("maxPayoutSag=");
	_buf.appendInt(maxPayoutSag);
	_buf.append(',');
	_buf.append("tournSitesEx=");
	tournSitesEx.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::TournStaticData::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(TournStaticData())) // not empty
	{
		_body.composeUINT64(tournamentId);
		_body.composeString(server);
		_body.composeString(targetServer);
		_body.composeString(hasSatellite);
		_body.composeSrvTime(whenStart);
		_body.composeUINT32(buyIn);
		_body.composeUINT32(rake);
		_body.composeUINT32(fppBuyIn);
		_body.composeBYTE(isRestricted);
		_body.composeBYTE(isPwdProtected);
		_body.composeString(name);
		_body.composeString(admissionId);
		_body.composeBYTE(isPlayMoney);
		_body.composeUINT32(satelliteTarget);
		_body.composeUINT32(minPlayers);
		_body.composeUINT32(tournFlags);
		_body.composeBYTE(game);
		_body.composeBYTE(isHiLo);
		_body.composeBYTE(structure);
		_body.composeUINT32(tournMask);
		_body.composeUINT32(tournSites);
		_body.composeUINT32(whenStartInt);
		_body.composeUINT32(tournMask2);
		_body.composeSrvTime(targetWhenStart);
		_body.composeUINT32(tournMask3);
		_body.composeUINT32(tournMask4);
		_body.composeUINT32(maxPerTable);
		_body.composeBOOL(countryRestrictionInverted);
		restrictedCountries.composeMsg(_body);
		_body.composeBYTE(hasDayTwoStart);
		_body.composeUINT32(dayTwoStartSec);
		_body.composeSrvTime(dayTwoStart);
		_body.composeString(shortText);
		_body.composeUINT16(chatLang);
		_body.composeString(currency);
		_body.composeUINT32(tournFlagsServInt);
		_body.composeUINT32(knockout);
		_body.composeString(satelliteTargetReference);
		_body.composeUINT16(satelliteTargetReferenceLock);
		_body.composeUINT32(maxPlayers);
		_body.composeBYTE(speedDisplay);
		_body.composeString(nameSnG);
		_body.composeBYTE(step);
		_body.composeBYTE(timedTournType);
		_body.composeUINT16(timedTournTime);
		_body.composeBYTE(timedTournPayout);
		_body.composeBOOL(isFlightTourn);
		_body.composeString(tournBrand);
		_body.composeUINT32(scalePM);
		_body.composeBYTE(progressiveKnockout);
		_body.composeBYTE(awardScheme);
		_body.composeUINT16(numReentries);
		_body.composeString(internalReference);
		_body.composeString(favReference);
		_body.composeString(satelliteTargetName);
		_body.composeINT64(admissionPrice);
		_body.composeUINT64(tournFlags2);
		_body.composeSrvTime(regEndAbs);
		_body.composeUINT32(regEndAbsInt);
		_body.composeBOOL(doNotAllowToUnreg);
		CommMsgBody _body0;
		nStackInfo.composeMsg(_body0);
		_body.composeMsgBody(_body0);
		_body.composeUINT32(tournMask5);
		_body.composeUINT32(tournMask6);
		_body.composeString(satelliteTargetNameMTT);
		_body.composeUINT32(liveEventMask);
		_body.composeBYTE(timedTournPlayersPercent);
		_body.composeUINT32(dummy1);
		_body.composeBYTE(rmPmLobby);
		_body.composeUINT32(brandAccessMask);
		_body.composeUINT32(activeFlags);
		_body.composeUINT32(sngScriptId);
		_body.composeString(customSpeedDisplayName);
		_body.composeString(mobileName);
		_body.composeUINT32(tournGroup);
		_body.composeINT32(guaranteedPrizePool);
		admissions.composeMsg(_body);
		_body.composeString(serverObj);
		_body.composeString(tournGroupRef);
		_body.composeINT32(maxPayoutSag);
		tournSitesEx.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::TournStaticData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT64(tournamentId);
	_parser0.parseStringP(server);
	_parser0.parseStringP(targetServer);
	_parser0.parseStringP(hasSatellite);
	_parser0.parseSrvTime(whenStart);
	_parser0.parseUINT32(buyIn);
	_parser0.parseUINT32(rake);
	_parser0.parseUINT32(fppBuyIn);
	_parser0.parseBYTE(isRestricted);
	_parser0.parseBYTE(isPwdProtected);
	_parser0.parseStringP(name);
	_parser0.parseStringP(admissionId);
	_parser0.parseBYTE(isPlayMoney);
	_parser0.parseUINT32(satelliteTarget);
	_parser0.parseUINT32(minPlayers);
	_parser0.parseUINT32(tournFlags);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(isHiLo);
	_parser0.parseBYTE(structure);
	_parser0.parseUINT32(tournMask);
	_parser0.parseUINT32(tournSites);
	_parser0.parseUINT32(whenStartInt);
	_parser0.parseUINT32(tournMask2);
	_parser0.parseSrvTime(targetWhenStart);
	_parser0.parseUINT32(tournMask3);
	_parser0.parseUINT32(tournMask4);
	_parser0.parseUINT32(maxPerTable);
	_parser0.parseBOOL(countryRestrictionInverted);
	restrictedCountries.parseMsg(_parser0);
	_parser0.parseBYTE(hasDayTwoStart);
	_parser0.parseUINT32(dayTwoStartSec);
	_parser0.parseSrvTime(dayTwoStart);
	_parser0.parseStringP(shortText);
	_parser0.parseUINT16(chatLang);
	_parser0.parseStringP(currency);
	_parser0.parseUINT32(tournFlagsServInt);
	_parser0.parseUINT32(knockout);
	_parser0.parseStringP(satelliteTargetReference);
	_parser0.parseUINT16(satelliteTargetReferenceLock);
	_parser0.parseUINT32(maxPlayers);
	_parser0.parseBYTE(speedDisplay);
	_parser0.parseStringP(nameSnG);
	_parser0.parseBYTE(step);
	_parser0.parseBYTE(timedTournType);
	_parser0.parseUINT16(timedTournTime);
	_parser0.parseBYTE(timedTournPayout);
	_parser0.parseBOOL(isFlightTourn);
	_parser0.parseStringP(tournBrand);
	_parser0.parseUINT32(scalePM);
	_parser0.parseBYTE(progressiveKnockout);
	_parser0.parseBYTE(awardScheme);
	_parser0.parseUINT16(numReentries);
	_parser0.parseStringP(internalReference);
	_parser0.parseStringP(favReference);
	_parser0.parseStringP(satelliteTargetName);
	_parser0.parseINT64(admissionPrice);
	_parser0.parseUINT64(tournFlags2);
	_parser0.parseSrvTime(regEndAbs);
	_parser0.parseUINT32(regEndAbsInt);
	_parser0.parseBOOL(doNotAllowToUnreg);
	parseAnonymousMsgBody0(_parser0);
	_parser0.parseUINT32(tournMask5);
	_parser0.parseUINT32(tournMask6);
	_parser0.parseStringP(satelliteTargetNameMTT);
	_parser0.parseUINT32(liveEventMask);
	_parser0.parseBYTE(timedTournPlayersPercent);
	_parser0.parseUINT32(dummy1);
	_parser0.parseBYTE(rmPmLobby);
	_parser0.parseUINT32(brandAccessMask);
	_parser0.parseUINT32(activeFlags);
	_parser0.parseUINT32(sngScriptId);
	_parser0.parseStringP(customSpeedDisplayName);
	_parser0.parseStringP(mobileName);
	_parser0.parseUINT32(tournGroup);
	_parser0.parseINT32(guaranteedPrizePool);
	admissions.parseMsg(_parser0);
	_parser0.parseStringP(serverObj);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(tournGroupRef);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT32(maxPayoutSag);
	if(_parser0.parseEnded()) return;
	tournSitesEx.parseMsg(_parser0);
}

/*static*/ void MLobbyNG::cli::TournStaticData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT64 tournamentId; _parser0.parseUINT64(tournamentId);
	AtfValidator::validateUint(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "targetServer"); size_t szTargetServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "targetServer", szTargetServer, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "hasSatellite"); size_t szHasSatellite = strlen(_dummy);
	AtfValidator::validateInt(_descr, "hasSatellite", szHasSatellite, _checker, __FILE__, __LINE__);
	SrvTime whenStart; _parser0.parseSrvTime(whenStart);
	AtfValidator::validateSrvDateTime(_descr, "whenStart", whenStart, _checker, __FILE__, __LINE__);
	UINT32 buyIn; _parser0.parseUINT32(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT32 rake; _parser0.parseUINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	UINT32 fppBuyIn; _parser0.parseUINT32(fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	BYTE isRestricted; _parser0.parseBYTE(isRestricted);
	AtfValidator::validateInt(_descr, "isRestricted", isRestricted, _checker, __FILE__, __LINE__);
	BYTE isPwdProtected; _parser0.parseBYTE(isPwdProtected);
	AtfValidator::validateInt(_descr, "isPwdProtected", isPwdProtected, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "admissionId"); size_t szAdmissionId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "admissionId", szAdmissionId, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser0.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 satelliteTarget; _parser0.parseUINT32(satelliteTarget);
	AtfValidator::validateInt(_descr, "satelliteTarget", satelliteTarget, _checker, __FILE__, __LINE__);
	UINT32 minPlayers; _parser0.parseUINT32(minPlayers);
	AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
	UINT32 tournFlags; _parser0.parseUINT32(tournFlags);
	AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser0.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	UINT32 tournMask; _parser0.parseUINT32(tournMask);
	AtfValidator::validateInt(_descr, "tournMask", tournMask, _checker, __FILE__, __LINE__);
	UINT32 tournSites; _parser0.parseUINT32(tournSites);
	AtfValidator::validateInt(_descr, "tournSites", tournSites, _checker, __FILE__, __LINE__);
	UINT32 whenStartInt; _parser0.parseUINT32(whenStartInt);
	AtfValidator::validateInt(_descr, "whenStartInt", whenStartInt, _checker, __FILE__, __LINE__);
	UINT32 tournMask2; _parser0.parseUINT32(tournMask2);
	AtfValidator::validateInt(_descr, "tournMask2", tournMask2, _checker, __FILE__, __LINE__);
	SrvTime targetWhenStart; _parser0.parseSrvTime(targetWhenStart);
	AtfValidator::validateSrvDateTime(_descr, "targetWhenStart", targetWhenStart, _checker, __FILE__, __LINE__);
	UINT32 tournMask3; _parser0.parseUINT32(tournMask3);
	AtfValidator::validateInt(_descr, "tournMask3", tournMask3, _checker, __FILE__, __LINE__);
	UINT32 tournMask4; _parser0.parseUINT32(tournMask4);
	AtfValidator::validateInt(_descr, "tournMask4", tournMask4, _checker, __FILE__, __LINE__);
	UINT32 maxPerTable; _parser0.parseUINT32(maxPerTable);
	AtfValidator::validateInt(_descr, "maxPerTable", maxPerTable, _checker, __FILE__, __LINE__);
	bool countryRestrictionInverted; _parser0.parseBOOL(countryRestrictionInverted);
	AtfValidator::validateInt(_descr, "countryRestrictionInverted", countryRestrictionInverted, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szRestrictedCountries = ThinAtf::LAtfVector< PString , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("restrictedCountries"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "restrictedCountries", szRestrictedCountries, _checker, __FILE__, __LINE__);
	BYTE hasDayTwoStart; _parser0.parseBYTE(hasDayTwoStart);
	AtfValidator::validateInt(_descr, "hasDayTwoStart", hasDayTwoStart, _checker, __FILE__, __LINE__);
	UINT32 dayTwoStartSec; _parser0.parseUINT32(dayTwoStartSec);
	AtfValidator::validateInt(_descr, "dayTwoStartSec", dayTwoStartSec, _checker, __FILE__, __LINE__);
	SrvTime dayTwoStart; _parser0.parseSrvTime(dayTwoStart);
	AtfValidator::validateSrvDateTime(_descr, "dayTwoStart", dayTwoStart, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "shortText"); size_t szShortText = strlen(_dummy);
	AtfValidator::validateInt(_descr, "shortText", szShortText, _checker, __FILE__, __LINE__);
	UINT16 chatLang; _parser0.parseUINT16(chatLang);
	AtfValidator::validateInt(_descr, "chatLang", chatLang, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 tournFlagsServInt; _parser0.parseUINT32(tournFlagsServInt);
	AtfValidator::validateInt(_descr, "tournFlagsServInt", tournFlagsServInt, _checker, __FILE__, __LINE__);
	UINT32 knockout; _parser0.parseUINT32(knockout);
	AtfValidator::validateInt(_descr, "knockout", knockout, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "satelliteTargetReference"); size_t szSatelliteTargetReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "satelliteTargetReference", szSatelliteTargetReference, _checker, __FILE__, __LINE__);
	UINT16 satelliteTargetReferenceLock; _parser0.parseUINT16(satelliteTargetReferenceLock);
	AtfValidator::validateInt(_descr, "satelliteTargetReferenceLock", satelliteTargetReferenceLock, _checker, __FILE__, __LINE__);
	UINT32 maxPlayers; _parser0.parseUINT32(maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	BYTE speedDisplay; _parser0.parseBYTE(speedDisplay);
	AtfValidator::validateInt(_descr, "speedDisplay", speedDisplay, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "nameSnG"); size_t szNameSnG = strlen(_dummy);
	AtfValidator::validateInt(_descr, "nameSnG", szNameSnG, _checker, __FILE__, __LINE__);
	BYTE step; _parser0.parseBYTE(step);
	AtfValidator::validateInt(_descr, "step", step, _checker, __FILE__, __LINE__);
	BYTE timedTournType; _parser0.parseBYTE(timedTournType);
	AtfValidator::validateInt(_descr, "timedTournType", timedTournType, _checker, __FILE__, __LINE__);
	UINT16 timedTournTime; _parser0.parseUINT16(timedTournTime);
	AtfValidator::validateInt(_descr, "timedTournTime", timedTournTime, _checker, __FILE__, __LINE__);
	BYTE timedTournPayout; _parser0.parseBYTE(timedTournPayout);
	AtfValidator::validateInt(_descr, "timedTournPayout", timedTournPayout, _checker, __FILE__, __LINE__);
	bool isFlightTourn; _parser0.parseBOOL(isFlightTourn);
	AtfValidator::validateInt(_descr, "isFlightTourn", isFlightTourn, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "tournBrand"); size_t szTournBrand = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tournBrand", szTournBrand, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser0.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	BYTE progressiveKnockout; _parser0.parseBYTE(progressiveKnockout);
	AtfValidator::validateInt(_descr, "progressiveKnockout", progressiveKnockout, _checker, __FILE__, __LINE__);
	BYTE awardScheme; _parser0.parseBYTE(awardScheme);
	AtfValidator::validateInt(_descr, "awardScheme", awardScheme, _checker, __FILE__, __LINE__);
	UINT16 numReentries; _parser0.parseUINT16(numReentries);
	AtfValidator::validateInt(_descr, "numReentries", numReentries, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "internalReference"); size_t szInternalReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "internalReference", szInternalReference, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "favReference"); size_t szFavReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "favReference", szFavReference, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "satelliteTargetName"); size_t szSatelliteTargetName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "satelliteTargetName", szSatelliteTargetName, _checker, __FILE__, __LINE__);
	INT64 admissionPrice; _parser0.parseINT64(admissionPrice);
	AtfValidator::validateInt(_descr, "admissionPrice", admissionPrice, _checker, __FILE__, __LINE__);
	UINT64 tournFlags2; _parser0.parseUINT64(tournFlags2);
	AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	SrvTime regEndAbs; _parser0.parseSrvTime(regEndAbs);
	AtfValidator::validateSrvDateTime(_descr, "regEndAbs", regEndAbs, _checker, __FILE__, __LINE__);
	UINT32 regEndAbsInt; _parser0.parseUINT32(regEndAbsInt);
	AtfValidator::validateInt(_descr, "regEndAbsInt", regEndAbsInt, _checker, __FILE__, __LINE__);
	bool doNotAllowToUnreg; _parser0.parseBOOL(doNotAllowToUnreg);
	AtfValidator::validateInt(_descr, "doNotAllowToUnreg", doNotAllowToUnreg, _checker, __FILE__, __LINE__);
	validateAnonymousMsgBody0(_parser0, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tournMask5; _parser0.parseUINT32(tournMask5);
	AtfValidator::validateInt(_descr, "tournMask5", tournMask5, _checker, __FILE__, __LINE__);
	UINT32 tournMask6; _parser0.parseUINT32(tournMask6);
	AtfValidator::validateInt(_descr, "tournMask6", tournMask6, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "satelliteTargetNameMTT"); size_t szSatelliteTargetNameMTT = strlen(_dummy);
	AtfValidator::validateInt(_descr, "satelliteTargetNameMTT", szSatelliteTargetNameMTT, _checker, __FILE__, __LINE__);
	UINT32 liveEventMask; _parser0.parseUINT32(liveEventMask);
	AtfValidator::validateInt(_descr, "liveEventMask", liveEventMask, _checker, __FILE__, __LINE__);
	BYTE timedTournPlayersPercent; _parser0.parseBYTE(timedTournPlayersPercent);
	AtfValidator::validateInt(_descr, "timedTournPlayersPercent", timedTournPlayersPercent, _checker, __FILE__, __LINE__);
	UINT32 dummy1; _parser0.parseUINT32(dummy1);
	AtfValidator::validateInt(_descr, "dummy1", dummy1, _checker, __FILE__, __LINE__);
	BYTE rmPmLobby; _parser0.parseBYTE(rmPmLobby);
	AtfValidator::validateInt(_descr, "rmPmLobby", rmPmLobby, _checker, __FILE__, __LINE__);
	UINT32 brandAccessMask; _parser0.parseUINT32(brandAccessMask);
	AtfValidator::validateInt(_descr, "brandAccessMask", brandAccessMask, _checker, __FILE__, __LINE__);
	UINT32 activeFlags; _parser0.parseUINT32(activeFlags);
	AtfValidator::validateInt(_descr, "activeFlags", activeFlags, _checker, __FILE__, __LINE__);
	UINT32 sngScriptId; _parser0.parseUINT32(sngScriptId);
	AtfValidator::validateInt(_descr, "sngScriptId", sngScriptId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "customSpeedDisplayName"); size_t szCustomSpeedDisplayName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "customSpeedDisplayName", szCustomSpeedDisplayName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "mobileName"); size_t szMobileName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "mobileName", szMobileName, _checker, __FILE__, __LINE__);
	UINT32 tournGroup; _parser0.parseUINT32(tournGroup);
	AtfValidator::validateInt(_descr, "tournGroup", tournGroup, _checker, __FILE__, __LINE__);
	INT32 guaranteedPrizePool; _parser0.parseINT32(guaranteedPrizePool);
	AtfValidator::validateInt(_descr, "guaranteedPrizePool", guaranteedPrizePool, _checker, __FILE__, __LINE__);
	int szAdmissions = ThinAtf::LAtfVector< PString, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("admissions"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "admissions", szAdmissions, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "serverObj"); size_t szServerObj = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObj", szServerObj, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "tournGroupRef"); size_t szTournGroupRef = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tournGroupRef", szTournGroupRef, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT32 maxPayoutSag; _parser0.parseINT32(maxPayoutSag);
	AtfValidator::validateInt(_descr, "maxPayoutSag", maxPayoutSag, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tournSitesEx"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void MLobbyNG::cli::TournStaticData::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	nStackInfo.parseMsg(_parser0);
}

/*static*/ void MLobbyNG::cli::TournStaticData::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	TournClientThin::NStackTournInfoStruct::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("nStackInfo"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TournDynaData
//=================================================================

MLobbyNG::cli::TournDynaData::TournDynaData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::TournDynaData::TournDynaData(TournDynaData&& _o)
	: fakeStatus(std::move(_o.fakeStatus))
	, entrants(std::move(_o.entrants))
	, publProp(std::move(_o.publProp))
	, prizePoolToPublish(std::move(_o.prizePoolToPublish))
	, prizePoolUnit(std::move(_o.prizePoolUnit))
	, happyHoursMultipliers(std::move(_o.happyHoursMultipliers))
	, goldenSnGMilestoneAwardStub(std::move(_o.goldenSnGMilestoneAwardStub))
	, dummy1(std::move(_o.dummy1))
	, goldenSnGEligibleStub(std::move(_o.goldenSnGEligibleStub))
	, goldenSnGTotalAddonStub(std::move(_o.goldenSnGTotalAddonStub))
	, prizePoolMoneyToPublish(std::move(_o.prizePoolMoneyToPublish))
	, timedTournPlayersThreshold(std::move(_o.timedTournPlayersThreshold))
	, mixTournSatellite(std::move(_o.mixTournSatellite))
{
}

MLobbyNG::cli::TournDynaData& MLobbyNG::cli::TournDynaData::operator=(TournDynaData&& _o)
{
	if(this != &_o)
	{
		fakeStatus = std::move(_o.fakeStatus);
		entrants = std::move(_o.entrants);
		publProp = std::move(_o.publProp);
		prizePoolToPublish = std::move(_o.prizePoolToPublish);
		prizePoolUnit = std::move(_o.prizePoolUnit);
		happyHoursMultipliers = std::move(_o.happyHoursMultipliers);
		goldenSnGMilestoneAwardStub = std::move(_o.goldenSnGMilestoneAwardStub);
		dummy1 = std::move(_o.dummy1);
		goldenSnGEligibleStub = std::move(_o.goldenSnGEligibleStub);
		goldenSnGTotalAddonStub = std::move(_o.goldenSnGTotalAddonStub);
		prizePoolMoneyToPublish = std::move(_o.prizePoolMoneyToPublish);
		timedTournPlayersThreshold = std::move(_o.timedTournPlayersThreshold);
		mixTournSatellite = std::move(_o.mixTournSatellite);
	}
	return *this;
}

#endif

void MLobbyNG::cli::TournDynaData::clear()
{
	fakeStatus = 0;
	entrants = 0;
	publProp = 0;
	prizePoolToPublish = 0;
	prizePoolUnit = 0;
	happyHoursMultipliers.clear();
	goldenSnGMilestoneAwardStub = 0;
	dummy1 = 0;
	goldenSnGEligibleStub = false;
	goldenSnGTotalAddonStub = 0;
	prizePoolMoneyToPublish = 0;
	timedTournPlayersThreshold = 0;
	mixTournSatellite = 0;
}

bool MLobbyNG::cli::TournDynaData::equals(const TournDynaData& _o) const
{
	return fakeStatus == _o.fakeStatus &&
		entrants == _o.entrants &&
		publProp == _o.publProp &&
		prizePoolToPublish == _o.prizePoolToPublish &&
		prizePoolUnit == _o.prizePoolUnit &&
		happyHoursMultipliers.equals(_o.happyHoursMultipliers) &&
		goldenSnGMilestoneAwardStub == _o.goldenSnGMilestoneAwardStub &&
		dummy1 == _o.dummy1 &&
		goldenSnGEligibleStub == _o.goldenSnGEligibleStub &&
		goldenSnGTotalAddonStub == _o.goldenSnGTotalAddonStub &&
		prizePoolMoneyToPublish == _o.prizePoolMoneyToPublish &&
		timedTournPlayersThreshold == _o.timedTournPlayersThreshold &&
		mixTournSatellite == _o.mixTournSatellite;
}

const char *MLobbyNG::cli::TournDynaData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("fakeStatus=");
	_buf.appendUint(fakeStatus);
	_buf.append(',');
	_buf.append("entrants=");
	_buf.appendUint(entrants);
	_buf.append(',');
	_buf.append("publProp=");
	_buf.appendUint(publProp);
	_buf.append(',');
	_buf.append("prizePoolToPublish=");
	_buf.appendUint(prizePoolToPublish);
	_buf.append(',');
	_buf.append("prizePoolUnit=");
	_buf.appendUint(prizePoolUnit);
	_buf.append(',');
	_buf.append("happyHoursMultipliers=");
	happyHoursMultipliers.toTraceString(_buf);
	_buf.append(',');
	_buf.append("goldenSnGMilestoneAwardStub=");
	_buf.appendUint(goldenSnGMilestoneAwardStub);
	_buf.append(',');
	_buf.append("dummy1=");
	_buf.appendUint(dummy1);
	_buf.append(',');
	_buf.append("goldenSnGEligibleStub=");
	_buf.appendUint(goldenSnGEligibleStub);
	_buf.append(',');
	_buf.append("goldenSnGTotalAddonStub=");
	_buf.appendUint(goldenSnGTotalAddonStub);
	_buf.append(',');
	_buf.append("prizePoolMoneyToPublish=");
	_buf.appendUint(prizePoolMoneyToPublish);
	_buf.append(',');
	_buf.append("timedTournPlayersThreshold=");
	_buf.appendUint(timedTournPlayersThreshold);
	_buf.append(',');
	_buf.append("mixTournSatellite=");
	_buf.appendInt(mixTournSatellite);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::TournDynaData::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(TournDynaData())) // not empty
	{
		_body.composeUINT32(fakeStatus);
		_body.composeUINT32(entrants);
		_body.composeBYTE(publProp);
		_body.composeUINT32(prizePoolToPublish);
		_body.composeBYTE(prizePoolUnit);
		happyHoursMultipliers.composeMsg(_body);
		_body.composeUINT32(goldenSnGMilestoneAwardStub);
		_body.composeUINT32(dummy1);
		_body.composeBOOL(goldenSnGEligibleStub);
		_body.composeUINT32(goldenSnGTotalAddonStub);
		_body.composeUINT32(prizePoolMoneyToPublish);
		_body.composeUINT32(timedTournPlayersThreshold);
		_body.composeINT8(mixTournSatellite);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::TournDynaData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(fakeStatus);
	_parser0.parseUINT32(entrants);
	_parser0.parseBYTE(publProp);
	_parser0.parseUINT32(prizePoolToPublish);
	_parser0.parseBYTE(prizePoolUnit);
	happyHoursMultipliers.parseMsg(_parser0);
	_parser0.parseUINT32(goldenSnGMilestoneAwardStub);
	_parser0.parseUINT32(dummy1);
	_parser0.parseBOOL(goldenSnGEligibleStub);
	_parser0.parseUINT32(goldenSnGTotalAddonStub);
	_parser0.parseUINT32(prizePoolMoneyToPublish);
	_parser0.parseUINT32(timedTournPlayersThreshold);
	_parser0.parseINT8(mixTournSatellite);
}

/*static*/ void MLobbyNG::cli::TournDynaData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 fakeStatus; _parser0.parseUINT32(fakeStatus);
	AtfValidator::validateInt(_descr, "fakeStatus", fakeStatus, _checker, __FILE__, __LINE__);
	UINT32 entrants; _parser0.parseUINT32(entrants);
	AtfValidator::validateInt(_descr, "entrants", entrants, _checker, __FILE__, __LINE__);
	BYTE publProp; _parser0.parseBYTE(publProp);
	AtfValidator::validateInt(_descr, "publProp", publProp, _checker, __FILE__, __LINE__);
	UINT32 prizePoolToPublish; _parser0.parseUINT32(prizePoolToPublish);
	AtfValidator::validateInt(_descr, "prizePoolToPublish", prizePoolToPublish, _checker, __FILE__, __LINE__);
	BYTE prizePoolUnit; _parser0.parseBYTE(prizePoolUnit);
	AtfValidator::validateInt(_descr, "prizePoolUnit", prizePoolUnit, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szHappyHoursMultipliers = ThinAtf::LAtfVector< FppFactorStruct, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("happyHoursMultipliers"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "happyHoursMultipliers", szHappyHoursMultipliers, _checker, __FILE__, __LINE__);
	UINT32 goldenSnGMilestoneAwardStub; _parser0.parseUINT32(goldenSnGMilestoneAwardStub);
	AtfValidator::validateInt(_descr, "goldenSnGMilestoneAwardStub", goldenSnGMilestoneAwardStub, _checker, __FILE__, __LINE__);
	UINT32 dummy1; _parser0.parseUINT32(dummy1);
	AtfValidator::validateInt(_descr, "dummy1", dummy1, _checker, __FILE__, __LINE__);
	bool goldenSnGEligibleStub; _parser0.parseBOOL(goldenSnGEligibleStub);
	AtfValidator::validateInt(_descr, "goldenSnGEligibleStub", goldenSnGEligibleStub, _checker, __FILE__, __LINE__);
	UINT32 goldenSnGTotalAddonStub; _parser0.parseUINT32(goldenSnGTotalAddonStub);
	AtfValidator::validateInt(_descr, "goldenSnGTotalAddonStub", goldenSnGTotalAddonStub, _checker, __FILE__, __LINE__);
	UINT32 prizePoolMoneyToPublish; _parser0.parseUINT32(prizePoolMoneyToPublish);
	AtfValidator::validateInt(_descr, "prizePoolMoneyToPublish", prizePoolMoneyToPublish, _checker, __FILE__, __LINE__);
	UINT32 timedTournPlayersThreshold; _parser0.parseUINT32(timedTournPlayersThreshold);
	AtfValidator::validateInt(_descr, "timedTournPlayersThreshold", timedTournPlayersThreshold, _checker, __FILE__, __LINE__);
	INT8 mixTournSatellite; _parser0.parseINT8(mixTournSatellite);
	AtfValidator::validateInt(_descr, "mixTournSatellite", mixTournSatellite, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TournDataStruct
//=================================================================

MLobbyNG::cli::TournDataStruct::TournDataStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::TournDataStruct::TournDataStruct(TournDataStruct&& _o)
	: staticData(std::move(_o.staticData))
	, dynamicData(std::move(_o.dynamicData))
	, lastEntry(std::move(_o.lastEntry))
	, userHasTicket(std::move(_o.userHasTicket))
{
}

MLobbyNG::cli::TournDataStruct& MLobbyNG::cli::TournDataStruct::operator=(TournDataStruct&& _o)
{
	if(this != &_o)
	{
		staticData = std::move(_o.staticData);
		dynamicData = std::move(_o.dynamicData);
		lastEntry = std::move(_o.lastEntry);
		userHasTicket = std::move(_o.userHasTicket);
	}
	return *this;
}

#endif

void MLobbyNG::cli::TournDataStruct::clear()
{
	staticData.clear();
	dynamicData.clear();
	lastEntry.setNull();
	userHasTicket = false;
}

bool MLobbyNG::cli::TournDataStruct::equals(const TournDataStruct& _o) const
{
	return staticData.equals(_o.staticData) &&
		dynamicData.equals(_o.dynamicData) &&
		lastEntry.equals(_o.lastEntry) &&
		userHasTicket == _o.userHasTicket;
}

const char *MLobbyNG::cli::TournDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("staticData=");
	staticData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("dynamicData=");
	dynamicData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("lastEntry=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, lastEntry);
	_buf.append(',');
	_buf.append("userHasTicket=");
	_buf.appendUint(userHasTicket);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::TournDataStruct::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(TournDataStruct())) // not empty
	{
		staticData.composeMsg(_body);
		dynamicData.composeMsg(_body);
		_body.composeSrvTime(lastEntry);
		_body.composeBOOL(userHasTicket);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::TournDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	staticData.parseMsg(_parser0);
	dynamicData.parseMsg(_parser0);
	_parser0.parseSrvTime(lastEntry);
	if(_parser0.parseEnded()) return;
	_parser0.parseBOOL(userHasTicket);
}

/*static*/ void MLobbyNG::cli::TournDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	TournStaticData::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("staticData"), _fieldsWithUnparsedContent);
	TournDynaData::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("dynamicData"), _fieldsWithUnparsedContent);
	SrvTime lastEntry; _parser0.parseSrvTime(lastEntry);
	AtfValidator::validateSrvDateTime(_descr, "lastEntry", lastEntry, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	bool userHasTicket; _parser0.parseBOOL(userHasTicket);
	AtfValidator::validateInt(_descr, "userHasTicket", userHasTicket, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SpinnerPrizeStruct
//=================================================================

MLobbyNG::cli::SpinnerPrizeStruct::SpinnerPrizeStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::SpinnerPrizeStruct::SpinnerPrizeStruct(SpinnerPrizeStruct&& _o)
	: level(std::move(_o.level))
	, type(std::move(_o.type))
	, value(std::move(_o.value))
	, targetRef(std::move(_o.targetRef))
{
}

MLobbyNG::cli::SpinnerPrizeStruct& MLobbyNG::cli::SpinnerPrizeStruct::operator=(SpinnerPrizeStruct&& _o)
{
	if(this != &_o)
	{
		level = std::move(_o.level);
		type = std::move(_o.type);
		value = std::move(_o.value);
		targetRef = std::move(_o.targetRef);
	}
	return *this;
}

#endif

void MLobbyNG::cli::SpinnerPrizeStruct::clear()
{
	level = 0;
	type = 0;
	value = 0;
	targetRef.clear();
}

bool MLobbyNG::cli::SpinnerPrizeStruct::equals(const SpinnerPrizeStruct& _o) const
{
	return level == _o.level &&
		type == _o.type &&
		value == _o.value &&
		targetRef.equals(_o.targetRef);
}

const char *MLobbyNG::cli::SpinnerPrizeStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("level=");
	_buf.appendUint(level);
	_buf.append(',');
	_buf.append("type=");
	_buf.appendUint(type);
	_buf.append(',');
	_buf.append("value=");
	_buf.appendUint(value);
	_buf.append(',');
	_buf.append("targetRef=");
	_buf.append(targetRef);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::SpinnerPrizeStruct::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(SpinnerPrizeStruct())) // not empty
	{
		_body.composeBYTE(level);
		_body.composeBYTE(type);
		_body.composeUINT32(value);
		_body.composeString(targetRef);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::SpinnerPrizeStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(level);
	_parser0.parseBYTE(type);
	_parser0.parseUINT32(value);
	_parser0.parseStringP(targetRef);
}

/*static*/ void MLobbyNG::cli::SpinnerPrizeStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	BYTE level; _parser0.parseBYTE(level);
	AtfValidator::validateInt(_descr, "level", level, _checker, __FILE__, __LINE__);
	BYTE type; _parser0.parseBYTE(type);
	AtfValidator::validateInt(_descr, "type", type, _checker, __FILE__, __LINE__);
	UINT32 value; _parser0.parseUINT32(value);
	AtfValidator::validateInt(_descr, "value", value, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "targetRef"); size_t szTargetRef = strlen(_dummy);
	AtfValidator::validateInt(_descr, "targetRef", szTargetRef, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SagMaxMods
//=================================================================

MLobbyNG::cli::SagMaxMods::SagMaxMods()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::SagMaxMods::SagMaxMods(SagMaxMods&& _o)
	: numUsers(std::move(_o.numUsers))
	, spinnerPrizes(std::move(_o.spinnerPrizes))
{
}

MLobbyNG::cli::SagMaxMods& MLobbyNG::cli::SagMaxMods::operator=(SagMaxMods&& _o)
{
	if(this != &_o)
	{
		numUsers = std::move(_o.numUsers);
		spinnerPrizes = std::move(_o.spinnerPrizes);
	}
	return *this;
}

#endif

void MLobbyNG::cli::SagMaxMods::clear()
{
	numUsers = 0;
	spinnerPrizes.clear();
}

bool MLobbyNG::cli::SagMaxMods::equals(const SagMaxMods& _o) const
{
	return numUsers == _o.numUsers &&
		spinnerPrizes.equals(_o.spinnerPrizes);
}

const char *MLobbyNG::cli::SagMaxMods::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("numUsers=");
	_buf.appendUint(numUsers);
	_buf.append(',');
	_buf.append("spinnerPrizes=");
	spinnerPrizes.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::SagMaxMods::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(SagMaxMods())) // not empty
	{
		_body.composeBYTE(numUsers);
		spinnerPrizes.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::SagMaxMods::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(numUsers);
	spinnerPrizes.parseMsg(_parser0);
}

/*static*/ void MLobbyNG::cli::SagMaxMods::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	BYTE numUsers; _parser0.parseBYTE(numUsers);
	AtfValidator::validateInt(_descr, "numUsers", numUsers, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szSpinnerPrizes = ThinAtf::LAtfVector< SpinnerPrizeStruct, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("spinnerPrizes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "spinnerPrizes", szSpinnerPrizes, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    StatesByCountryStruct
//=================================================================

MLobbyNG::cli::StatesByCountryStruct::StatesByCountryStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::StatesByCountryStruct::StatesByCountryStruct(StatesByCountryStruct&& _o)
	: country(std::move(_o.country))
	, stateInversion(std::move(_o.stateInversion))
	, states(std::move(_o.states))
{
}

MLobbyNG::cli::StatesByCountryStruct& MLobbyNG::cli::StatesByCountryStruct::operator=(StatesByCountryStruct&& _o)
{
	if(this != &_o)
	{
		country = std::move(_o.country);
		stateInversion = std::move(_o.stateInversion);
		states = std::move(_o.states);
	}
	return *this;
}

#endif

void MLobbyNG::cli::StatesByCountryStruct::clear()
{
	country.clear();
	stateInversion = false;
	states.clear();
}

bool MLobbyNG::cli::StatesByCountryStruct::equals(const StatesByCountryStruct& _o) const
{
	return country.equals(_o.country) &&
		stateInversion == _o.stateInversion &&
		states.equals(_o.states);
}

const char *MLobbyNG::cli::StatesByCountryStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("stateInversion=");
	_buf.appendUint(stateInversion);
	_buf.append(',');
	_buf.append("states=");
	states.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::StatesByCountryStruct::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(country);
	_msg.composeBOOL(stateInversion);
	states.composeMsg(_msg);
}

void MLobbyNG::cli::StatesByCountryStruct::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(country);
	_parser.parseBOOL(stateInversion);
	states.parseMsg(_parser);
}

/*static*/ void MLobbyNG::cli::StatesByCountryStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	bool stateInversion; _parser.parseBOOL(stateInversion);
	AtfValidator::validateInt(_descr, "stateInversion", stateInversion, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szStates = ThinAtf::LAtfVector< PString, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("states"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "states", szStates, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    MLobbyNGSagStaticDataStruct
//=================================================================

MLobbyNG::cli::MLobbyNGSagStaticDataStruct::MLobbyNGSagStaticDataStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::MLobbyNGSagStaticDataStruct::MLobbyNGSagStaticDataStruct(MLobbyNGSagStaticDataStruct&& _o)
	: active(std::move(_o.active))
	, scriptId(std::move(_o.scriptId))
	, flags(std::move(_o.flags))
	, brandMask(std::move(_o.brandMask))
	, siteMask(std::move(_o.siteMask))
	, buyin(std::move(_o.buyin))
	, rake(std::move(_o.rake))
	, currency(std::move(_o.currency))
	, scalePM(std::move(_o.scalePM))
	, game(std::move(_o.game))
	, isHiLo(std::move(_o.isHiLo))
	, structure(std::move(_o.structure))
	, speedDisplay(std::move(_o.speedDisplay))
	, minPrizePool(std::move(_o.minPrizePool))
	, maxPrizePool(std::move(_o.maxPrizePool))
	, maxPayout(std::move(_o.maxPayout))
	, promoRef(std::move(_o.promoRef))
	, minClientVersion(std::move(_o.minClientVersion))
	, maxClientVersion(std::move(_o.maxClientVersion))
	, mods(std::move(_o.mods))
	, tickets(std::move(_o.tickets))
	, customSpeedDisplayName(std::move(_o.customSpeedDisplayName))
	, restrictCountryInversion(std::move(_o.restrictCountryInversion))
	, statesByCountry(std::move(_o.statesByCountry))
	, visibilityCriteria(std::move(_o.visibilityCriteria))
	, mobileName(std::move(_o.mobileName))
	, tournGroup(std::move(_o.tournGroup))
	, admissions(std::move(_o.admissions))
	, tournFlags(std::move(_o.tournFlags))
	, tournGroupName(std::move(_o.tournGroupName))
	, tournGroupRef(std::move(_o.tournGroupRef))
	, tournSites(std::move(_o.tournSites))
	, eligibleGroups(std::move(_o.eligibleGroups))
{
}

MLobbyNG::cli::MLobbyNGSagStaticDataStruct& MLobbyNG::cli::MLobbyNGSagStaticDataStruct::operator=(MLobbyNGSagStaticDataStruct&& _o)
{
	if(this != &_o)
	{
		active = std::move(_o.active);
		scriptId = std::move(_o.scriptId);
		flags = std::move(_o.flags);
		brandMask = std::move(_o.brandMask);
		siteMask = std::move(_o.siteMask);
		buyin = std::move(_o.buyin);
		rake = std::move(_o.rake);
		currency = std::move(_o.currency);
		scalePM = std::move(_o.scalePM);
		game = std::move(_o.game);
		isHiLo = std::move(_o.isHiLo);
		structure = std::move(_o.structure);
		speedDisplay = std::move(_o.speedDisplay);
		minPrizePool = std::move(_o.minPrizePool);
		maxPrizePool = std::move(_o.maxPrizePool);
		maxPayout = std::move(_o.maxPayout);
		promoRef = std::move(_o.promoRef);
		minClientVersion = std::move(_o.minClientVersion);
		maxClientVersion = std::move(_o.maxClientVersion);
		mods = std::move(_o.mods);
		tickets = std::move(_o.tickets);
		customSpeedDisplayName = std::move(_o.customSpeedDisplayName);
		restrictCountryInversion = std::move(_o.restrictCountryInversion);
		statesByCountry = std::move(_o.statesByCountry);
		visibilityCriteria = std::move(_o.visibilityCriteria);
		mobileName = std::move(_o.mobileName);
		tournGroup = std::move(_o.tournGroup);
		admissions = std::move(_o.admissions);
		tournFlags = std::move(_o.tournFlags);
		tournGroupName = std::move(_o.tournGroupName);
		tournGroupRef = std::move(_o.tournGroupRef);
		tournSites = std::move(_o.tournSites);
		eligibleGroups = std::move(_o.eligibleGroups);
	}
	return *this;
}

#endif

void MLobbyNG::cli::MLobbyNGSagStaticDataStruct::clear()
{
	active = false;
	scriptId = 0;
	flags = 0;
	brandMask = 0;
	siteMask = 0;
	buyin = 0;
	rake = 0;
	currency = 0;
	scalePM = 0;
	game = 0;
	isHiLo = 0;
	structure = 0;
	speedDisplay = 0;
	minPrizePool = 0;
	maxPrizePool = 0;
	maxPayout = 0;
	promoRef.clear();
	minClientVersion = 0;
	maxClientVersion = 0;
	mods.clear();
	tickets.clear();
	customSpeedDisplayName.clear();
	restrictCountryInversion = false;
	statesByCountry.clear();
	visibilityCriteria.clear();
	mobileName.clear();
	tournGroup = 0;
	admissions.clear();
	tournFlags = 0;
	tournGroupName.clear();
	tournGroupRef.clear();
	tournSites.clear();
	eligibleGroups.clear();
}

bool MLobbyNG::cli::MLobbyNGSagStaticDataStruct::equals(const MLobbyNGSagStaticDataStruct& _o) const
{
	return active == _o.active &&
		scriptId == _o.scriptId &&
		flags == _o.flags &&
		brandMask == _o.brandMask &&
		siteMask == _o.siteMask &&
		buyin == _o.buyin &&
		rake == _o.rake &&
		currency == _o.currency &&
		scalePM == _o.scalePM &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		structure == _o.structure &&
		speedDisplay == _o.speedDisplay &&
		minPrizePool == _o.minPrizePool &&
		maxPrizePool == _o.maxPrizePool &&
		maxPayout == _o.maxPayout &&
		promoRef.equals(_o.promoRef) &&
		minClientVersion == _o.minClientVersion &&
		maxClientVersion == _o.maxClientVersion &&
		mods.equals(_o.mods) &&
		tickets.equals(_o.tickets) &&
		customSpeedDisplayName.equals(_o.customSpeedDisplayName) &&
		restrictCountryInversion == _o.restrictCountryInversion &&
		statesByCountry.equals(_o.statesByCountry) &&
		visibilityCriteria.equals(_o.visibilityCriteria) &&
		mobileName.equals(_o.mobileName) &&
		tournGroup == _o.tournGroup &&
		admissions.equals(_o.admissions) &&
		tournFlags == _o.tournFlags &&
		tournGroupName.equals(_o.tournGroupName) &&
		tournGroupRef.equals(_o.tournGroupRef) &&
		tournSites.equals(_o.tournSites) &&
		eligibleGroups.equals(_o.eligibleGroups);
}

const char *MLobbyNG::cli::MLobbyNGSagStaticDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("active=");
	_buf.appendUint(active);
	if( active )
	{
		_buf.append(',');
		_buf.append("scriptId=");
		_buf.appendUint(scriptId);
		_buf.append(',');
		_buf.append("flags=");
		_buf.appendUint(flags);
		_buf.append(',');
		_buf.append("brandMask=");
		_buf.appendUint(brandMask);
		_buf.append(',');
		_buf.append("siteMask=");
		_buf.appendUint(siteMask);
		_buf.append(',');
		_buf.append("buyin=");
		_buf.appendInt(buyin);
		_buf.append(',');
		_buf.append("rake=");
		_buf.appendInt(rake);
		_buf.append(',');
		_buf.append("currency=");
		_buf.appendInt(currency);
		_buf.append(',');
		_buf.append("scalePM=");
		_buf.appendInt(scalePM);
		_buf.append(',');
		_buf.append("game=");
		_buf.appendUint(game);
		_buf.append(',');
		_buf.append("isHiLo=");
		_buf.appendUint(isHiLo);
		_buf.append(',');
		_buf.append("structure=");
		_buf.appendUint(structure);
		_buf.append(',');
		_buf.append("speedDisplay=");
		_buf.appendUint(speedDisplay);
		_buf.append(',');
		_buf.append("minPrizePool=");
		_buf.appendInt(minPrizePool);
		_buf.append(',');
		_buf.append("maxPrizePool=");
		_buf.appendInt(maxPrizePool);
		_buf.append(',');
		_buf.append("maxPayout=");
		_buf.appendInt(maxPayout);
		_buf.append(',');
		_buf.append("promoRef=");
		_buf.append(promoRef);
		_buf.append(',');
		_buf.append("minClientVersion=");
		_buf.appendInt(minClientVersion);
		_buf.append(',');
		_buf.append("maxClientVersion=");
		_buf.appendInt(maxClientVersion);
		_buf.append(',');
		_buf.append("mods=");
		mods.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tickets=");
		tickets.toTraceString(_buf);
		_buf.append(',');
		_buf.append("customSpeedDisplayName=");
		ThinAtf::AtfTempl<I18nPString>::ToTraceString(_buf, customSpeedDisplayName);
		_buf.append(',');
		_buf.append("restrictCountryInversion=");
		_buf.appendUint(restrictCountryInversion);
		_buf.append(',');
		_buf.append("statesByCountry=");
		statesByCountry.toTraceString(_buf);
		_buf.append(',');
		_buf.append("visibilityCriteria=");
		_buf.append(visibilityCriteria);
		_buf.append(',');
		_buf.append("mobileName=");
		ThinAtf::AtfTempl<I18nPString>::ToTraceString(_buf, mobileName);
		_buf.append(',');
		_buf.append("tournGroup=");
		_buf.appendUint(tournGroup);
		_buf.append(',');
		_buf.append("admissions=");
		admissions.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tournFlags=");
		_buf.appendUint(tournFlags);
		_buf.append(',');
		_buf.append("tournGroupName=");
		_buf.append(tournGroupName);
		_buf.append(',');
		_buf.append("tournGroupRef=");
		_buf.append(tournGroupRef);
		_buf.append(',');
		_buf.append("tournSites=");
		tournSites.toTraceString(_buf);
		_buf.append(',');
		_buf.append("eligibleGroups=");
		eligibleGroups.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::MLobbyNGSagStaticDataStruct::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBOOL(active);
	if( active )
	{
		_msg.composeUINT32(scriptId);
		_msg.composeUINT32(flags);
		_msg.composeUINT32(brandMask);
		_msg.composeUINT32(siteMask);
		_msg.composeINT32(buyin);
		_msg.composeINT32(rake);
		_msg.composeINT32(currency);
		_msg.composeINT32(scalePM);
		_msg.composeBYTE(game);
		_msg.composeBYTE(isHiLo);
		_msg.composeBYTE(structure);
		_msg.composeBYTE(speedDisplay);
		_msg.composeINT32(minPrizePool);
		_msg.composeINT32(maxPrizePool);
		_msg.composeINT32(maxPayout);
		_msg.composeString(promoRef);
		_msg.composeINT32(minClientVersion);
		_msg.composeINT32(maxClientVersion);
		mods.composeMsg(_msg);
		tickets.composeMsg(_msg);
		customSpeedDisplayName.compose(_msg);
		_msg.composeBOOL(restrictCountryInversion);
		statesByCountry.composeMsg(_msg);
		_msg.composeString(visibilityCriteria);
		mobileName.compose(_msg);
		_msg.composeUINT32(tournGroup);
		admissions.composeMsg(_msg);
		_msg.composeUINT32(tournFlags);
		_msg.composeString(tournGroupName);
		_msg.composeString(tournGroupRef);
		tournSites.composeMsg(_msg);
		eligibleGroups.composeMsg(_msg);
	}
}

void MLobbyNG::cli::MLobbyNGSagStaticDataStruct::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(active);
	if( active )
	{
		_parser.parseUINT32(scriptId);
		_parser.parseUINT32(flags);
		_parser.parseUINT32(brandMask);
		_parser.parseUINT32(siteMask);
		_parser.parseINT32(buyin);
		_parser.parseINT32(rake);
		_parser.parseINT32(currency);
		_parser.parseINT32(scalePM);
		_parser.parseBYTE(game);
		_parser.parseBYTE(isHiLo);
		_parser.parseBYTE(structure);
		_parser.parseBYTE(speedDisplay);
		_parser.parseINT32(minPrizePool);
		_parser.parseINT32(maxPrizePool);
		_parser.parseINT32(maxPayout);
		_parser.parseStringP(promoRef);
		_parser.parseINT32(minClientVersion);
		_parser.parseINT32(maxClientVersion);
		mods.parseMsg(_parser);
		tickets.parseMsg(_parser);
		customSpeedDisplayName.parse(_parser);
		_parser.parseBOOL(restrictCountryInversion);
		statesByCountry.parseMsg(_parser);
		_parser.parseStringP(visibilityCriteria);
		mobileName.parse(_parser);
		_parser.parseUINT32(tournGroup);
		admissions.parseMsg(_parser);
		if(_parser.parseEnded()) return;
		_parser.parseUINT32(tournFlags);
		if(_parser.parseEnded()) return;
		_parser.parseStringP(tournGroupName);
		if(_parser.parseEnded()) return;
		_parser.parseStringP(tournGroupRef);
		if(_parser.parseEnded()) return;
		tournSites.parseMsg(_parser);
		if(_parser.parseEnded()) return;
		eligibleGroups.parseMsg(_parser);
	}
}

/*static*/ void MLobbyNG::cli::MLobbyNGSagStaticDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	bool active = false;
	_parser.parseBOOL(active);
	AtfValidator::validateInt(_descr, "active", active, _checker, __FILE__, __LINE__);
	if( active )
	{
		UINT32 scriptId; _parser.parseUINT32(scriptId);
		AtfValidator::validateInt(_descr, "scriptId", scriptId, _checker, __FILE__, __LINE__);
		UINT32 flags; _parser.parseUINT32(flags);
		AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
		UINT32 brandMask; _parser.parseUINT32(brandMask);
		AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
		UINT32 siteMask; _parser.parseUINT32(siteMask);
		AtfValidator::validateInt(_descr, "siteMask", siteMask, _checker, __FILE__, __LINE__);
		INT32 buyin; _parser.parseINT32(buyin);
		AtfValidator::validateInt(_descr, "buyin", buyin, _checker, __FILE__, __LINE__);
		INT32 rake; _parser.parseINT32(rake);
		AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
		INT32 currency; _parser.parseINT32(currency);
		AtfValidator::validateInt(_descr, "currency", currency, _checker, __FILE__, __LINE__);
		INT32 scalePM; _parser.parseINT32(scalePM);
		AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
		BYTE game; _parser.parseBYTE(game);
		AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
		BYTE isHiLo; _parser.parseBYTE(isHiLo);
		AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
		BYTE structure; _parser.parseBYTE(structure);
		AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
		BYTE speedDisplay; _parser.parseBYTE(speedDisplay);
		AtfValidator::validateInt(_descr, "speedDisplay", speedDisplay, _checker, __FILE__, __LINE__);
		INT32 minPrizePool; _parser.parseINT32(minPrizePool);
		AtfValidator::validateInt(_descr, "minPrizePool", minPrizePool, _checker, __FILE__, __LINE__);
		INT32 maxPrizePool; _parser.parseINT32(maxPrizePool);
		AtfValidator::validateInt(_descr, "maxPrizePool", maxPrizePool, _checker, __FILE__, __LINE__);
		INT32 maxPayout; _parser.parseINT32(maxPayout);
		AtfValidator::validateInt(_descr, "maxPayout", maxPayout, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "promoRef"); size_t szPromoRef = strlen(_dummy);
		AtfValidator::validateInt(_descr, "promoRef", szPromoRef, _checker, __FILE__, __LINE__);
		INT32 minClientVersion; _parser.parseINT32(minClientVersion);
		AtfValidator::validateInt(_descr, "minClientVersion", minClientVersion, _checker, __FILE__, __LINE__);
		INT32 maxClientVersion; _parser.parseINT32(maxClientVersion);
		AtfValidator::validateInt(_descr, "maxClientVersion", maxClientVersion, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szMods = ThinAtf::LAtfVector< SagMaxMods, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("mods"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "mods", szMods, _checker, __FILE__, __LINE__);
		int szTickets = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tickets"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tickets", szTickets, _checker, __FILE__, __LINE__);
		I18nPString customSpeedDisplayName; customSpeedDisplayName.parse(_parser);
		bool restrictCountryInversion; _parser.parseBOOL(restrictCountryInversion);
		AtfValidator::validateInt(_descr, "restrictCountryInversion", restrictCountryInversion, _checker, __FILE__, __LINE__);
		int szStatesByCountry = ThinAtf::LAtfVector< StatesByCountryStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("statesByCountry"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "statesByCountry", szStatesByCountry, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "visibilityCriteria"); size_t szVisibilityCriteria = strlen(_dummy);
		AtfValidator::validateInt(_descr, "visibilityCriteria", szVisibilityCriteria, _checker, __FILE__, __LINE__);
		I18nPString mobileName; mobileName.parse(_parser);
		UINT32 tournGroup; _parser.parseUINT32(tournGroup);
		AtfValidator::validateInt(_descr, "tournGroup", tournGroup, _checker, __FILE__, __LINE__);
		int szAdmissions = ThinAtf::LAtfVector< PString, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("admissions"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "admissions", szAdmissions, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		UINT32 tournFlags; _parser.parseUINT32(tournFlags);
		AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		_parser.parseStringN(_dummy, 0, "tournGroupName"); size_t szTournGroupName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tournGroupName", szTournGroupName, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		_parser.parseStringN(_dummy, 0, "tournGroupRef"); size_t szTournGroupRef = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tournGroupRef", szTournGroupRef, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		PSiteMask::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournSites"), _fieldsWithUnparsedContent);
		if(_parser.parseEnded()) return;
		int szEligibleGroups = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("eligibleGroups"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "eligibleGroups", szEligibleGroups, _checker, __FILE__, __LINE__);
	}
}

//=================================================================
//                    MLobbyNGSagLocalStaticDataStruct
//=================================================================

MLobbyNG::cli::MLobbyNGSagLocalStaticDataStruct::MLobbyNGSagLocalStaticDataStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::MLobbyNGSagLocalStaticDataStruct::MLobbyNGSagLocalStaticDataStruct(MLobbyNGSagLocalStaticDataStruct&& _o)
	: active(std::move(_o.active))
	, scriptId(std::move(_o.scriptId))
	, flags(std::move(_o.flags))
	, brandMask(std::move(_o.brandMask))
	, siteMask(std::move(_o.siteMask))
	, buyin(std::move(_o.buyin))
	, rake(std::move(_o.rake))
	, currency(std::move(_o.currency))
	, scalePM(std::move(_o.scalePM))
	, game(std::move(_o.game))
	, isHiLo(std::move(_o.isHiLo))
	, structure(std::move(_o.structure))
	, speedDisplay(std::move(_o.speedDisplay))
	, minPrizePool(std::move(_o.minPrizePool))
	, maxPrizePool(std::move(_o.maxPrizePool))
	, maxPayout(std::move(_o.maxPayout))
	, promoRef(std::move(_o.promoRef))
	, minClientVersion(std::move(_o.minClientVersion))
	, maxClientVersion(std::move(_o.maxClientVersion))
	, mods(std::move(_o.mods))
	, tickets(std::move(_o.tickets))
	, customSpeedDisplayName(std::move(_o.customSpeedDisplayName))
	, restrictCountryInversion(std::move(_o.restrictCountryInversion))
	, statesByCountry(std::move(_o.statesByCountry))
	, visibilityCriteria(std::move(_o.visibilityCriteria))
	, mobileName(std::move(_o.mobileName))
	, tournGroup(std::move(_o.tournGroup))
	, admissions(std::move(_o.admissions))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, tournFlags(std::move(_o.tournFlags))
	, tournGroupName(std::move(_o.tournGroupName))
	, tournGroupRef(std::move(_o.tournGroupRef))
	, tournSites(std::move(_o.tournSites))
{
}

MLobbyNG::cli::MLobbyNGSagLocalStaticDataStruct& MLobbyNG::cli::MLobbyNGSagLocalStaticDataStruct::operator=(MLobbyNGSagLocalStaticDataStruct&& _o)
{
	if(this != &_o)
	{
		active = std::move(_o.active);
		scriptId = std::move(_o.scriptId);
		flags = std::move(_o.flags);
		brandMask = std::move(_o.brandMask);
		siteMask = std::move(_o.siteMask);
		buyin = std::move(_o.buyin);
		rake = std::move(_o.rake);
		currency = std::move(_o.currency);
		scalePM = std::move(_o.scalePM);
		game = std::move(_o.game);
		isHiLo = std::move(_o.isHiLo);
		structure = std::move(_o.structure);
		speedDisplay = std::move(_o.speedDisplay);
		minPrizePool = std::move(_o.minPrizePool);
		maxPrizePool = std::move(_o.maxPrizePool);
		maxPayout = std::move(_o.maxPayout);
		promoRef = std::move(_o.promoRef);
		minClientVersion = std::move(_o.minClientVersion);
		maxClientVersion = std::move(_o.maxClientVersion);
		mods = std::move(_o.mods);
		tickets = std::move(_o.tickets);
		customSpeedDisplayName = std::move(_o.customSpeedDisplayName);
		restrictCountryInversion = std::move(_o.restrictCountryInversion);
		statesByCountry = std::move(_o.statesByCountry);
		visibilityCriteria = std::move(_o.visibilityCriteria);
		mobileName = std::move(_o.mobileName);
		tournGroup = std::move(_o.tournGroup);
		admissions = std::move(_o.admissions);
		isPlayMoney = std::move(_o.isPlayMoney);
		tournFlags = std::move(_o.tournFlags);
		tournGroupName = std::move(_o.tournGroupName);
		tournGroupRef = std::move(_o.tournGroupRef);
		tournSites = std::move(_o.tournSites);
	}
	return *this;
}

#endif

void MLobbyNG::cli::MLobbyNGSagLocalStaticDataStruct::clear()
{
	active = false;
	scriptId = 0;
	flags = 0;
	brandMask = 0;
	siteMask = 0;
	buyin = 0;
	rake = 0;
	currency = 0;
	scalePM = 0;
	game = 0;
	isHiLo = 0;
	structure = 0;
	speedDisplay = 0;
	minPrizePool = 0;
	maxPrizePool = 0;
	maxPayout = 0;
	promoRef.clear();
	minClientVersion = 0;
	maxClientVersion = 0;
	mods.clear();
	tickets.clear();
	customSpeedDisplayName.clear();
	restrictCountryInversion = false;
	statesByCountry.clear();
	visibilityCriteria.clear();
	mobileName.clear();
	tournGroup = 0;
	admissions.clear();
	isPlayMoney = false;
	tournFlags = 0;
	tournGroupName.clear();
	tournGroupRef.clear();
	tournSites.clear();
}

bool MLobbyNG::cli::MLobbyNGSagLocalStaticDataStruct::equals(const MLobbyNGSagLocalStaticDataStruct& _o) const
{
	return active == _o.active &&
		scriptId == _o.scriptId &&
		flags == _o.flags &&
		brandMask == _o.brandMask &&
		siteMask == _o.siteMask &&
		buyin == _o.buyin &&
		rake == _o.rake &&
		currency == _o.currency &&
		scalePM == _o.scalePM &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		structure == _o.structure &&
		speedDisplay == _o.speedDisplay &&
		minPrizePool == _o.minPrizePool &&
		maxPrizePool == _o.maxPrizePool &&
		maxPayout == _o.maxPayout &&
		promoRef.equals(_o.promoRef) &&
		minClientVersion == _o.minClientVersion &&
		maxClientVersion == _o.maxClientVersion &&
		mods.equals(_o.mods) &&
		tickets.equals(_o.tickets) &&
		customSpeedDisplayName.equals(_o.customSpeedDisplayName) &&
		restrictCountryInversion == _o.restrictCountryInversion &&
		statesByCountry.equals(_o.statesByCountry) &&
		visibilityCriteria.equals(_o.visibilityCriteria) &&
		mobileName.equals(_o.mobileName) &&
		tournGroup == _o.tournGroup &&
		admissions.equals(_o.admissions) &&
		isPlayMoney == _o.isPlayMoney &&
		tournFlags == _o.tournFlags &&
		tournGroupName.equals(_o.tournGroupName) &&
		tournGroupRef.equals(_o.tournGroupRef) &&
		tournSites.equals(_o.tournSites);
}

const char *MLobbyNG::cli::MLobbyNGSagLocalStaticDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("active=");
	_buf.appendUint(active);
	if( active )
	{
		_buf.append(',');
		_buf.append("scriptId=");
		_buf.appendUint(scriptId);
		_buf.append(',');
		_buf.append("flags=");
		_buf.appendUint(flags);
		_buf.append(',');
		_buf.append("brandMask=");
		_buf.appendUint(brandMask);
		_buf.append(',');
		_buf.append("siteMask=");
		_buf.appendUint(siteMask);
		_buf.append(',');
		_buf.append("buyin=");
		_buf.appendInt(buyin);
		_buf.append(',');
		_buf.append("rake=");
		_buf.appendInt(rake);
		_buf.append(',');
		_buf.append("currency=");
		_buf.appendInt(currency);
		_buf.append(',');
		_buf.append("scalePM=");
		_buf.appendInt(scalePM);
		_buf.append(',');
		_buf.append("game=");
		_buf.appendUint(game);
		_buf.append(',');
		_buf.append("isHiLo=");
		_buf.appendUint(isHiLo);
		_buf.append(',');
		_buf.append("structure=");
		_buf.appendUint(structure);
		_buf.append(',');
		_buf.append("speedDisplay=");
		_buf.appendUint(speedDisplay);
		_buf.append(',');
		_buf.append("minPrizePool=");
		_buf.appendInt(minPrizePool);
		_buf.append(',');
		_buf.append("maxPrizePool=");
		_buf.appendInt(maxPrizePool);
		_buf.append(',');
		_buf.append("maxPayout=");
		_buf.appendInt(maxPayout);
		_buf.append(',');
		_buf.append("promoRef=");
		_buf.append(promoRef);
		_buf.append(',');
		_buf.append("minClientVersion=");
		_buf.appendInt(minClientVersion);
		_buf.append(',');
		_buf.append("maxClientVersion=");
		_buf.appendInt(maxClientVersion);
		_buf.append(',');
		_buf.append("mods=");
		mods.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tickets=");
		tickets.toTraceString(_buf);
		_buf.append(',');
		_buf.append("customSpeedDisplayName=");
		_buf.append(customSpeedDisplayName);
		_buf.append(',');
		_buf.append("restrictCountryInversion=");
		_buf.appendUint(restrictCountryInversion);
		_buf.append(',');
		_buf.append("statesByCountry=");
		statesByCountry.toTraceString(_buf);
		_buf.append(',');
		_buf.append("visibilityCriteria=");
		_buf.append(visibilityCriteria);
		_buf.append(',');
		_buf.append("mobileName=");
		_buf.append(mobileName);
		_buf.append(',');
		_buf.append("tournGroup=");
		_buf.appendUint(tournGroup);
		_buf.append(',');
		_buf.append("admissions=");
		admissions.toTraceString(_buf);
		_buf.append(',');
		_buf.append("isPlayMoney=");
		_buf.appendUint(isPlayMoney);
		_buf.append(',');
		_buf.append("tournFlags=");
		_buf.appendUint(tournFlags);
		_buf.append(',');
		_buf.append("tournGroupName=");
		_buf.append(tournGroupName);
		_buf.append(',');
		_buf.append("tournGroupRef=");
		_buf.append(tournGroupRef);
		_buf.append(',');
		_buf.append("tournSites=");
		tournSites.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::MLobbyNGSagLocalStaticDataStruct::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(MLobbyNGSagLocalStaticDataStruct())) // not empty
	{
		_body.composeBOOL(active);
		if( active )
		{
			_body.composeUINT32(scriptId);
			_body.composeUINT32(flags);
			_body.composeUINT32(brandMask);
			_body.composeUINT32(siteMask);
			_body.composeINT32(buyin);
			_body.composeINT32(rake);
			_body.composeINT32(currency);
			_body.composeINT32(scalePM);
			_body.composeBYTE(game);
			_body.composeBYTE(isHiLo);
			_body.composeBYTE(structure);
			_body.composeBYTE(speedDisplay);
			_body.composeINT32(minPrizePool);
			_body.composeINT32(maxPrizePool);
			_body.composeINT32(maxPayout);
			_body.composeString(promoRef);
			_body.composeINT32(minClientVersion);
			_body.composeINT32(maxClientVersion);
			mods.composeMsg(_body);
			tickets.composeMsg(_body);
			_body.composeString(customSpeedDisplayName);
			_body.composeBOOL(restrictCountryInversion);
			statesByCountry.composeMsg(_body);
			_body.composeString(visibilityCriteria);
			_body.composeString(mobileName);
			_body.composeUINT32(tournGroup);
			admissions.composeMsg(_body);
			_body.composeBOOL(isPlayMoney);
			_body.composeUINT32(tournFlags);
			_body.composeString(tournGroupName);
			_body.composeString(tournGroupRef);
			tournSites.composeMsg(_body);
		}
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::MLobbyNGSagLocalStaticDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(active);
	if( active )
	{
		_parser0.parseUINT32(scriptId);
		_parser0.parseUINT32(flags);
		_parser0.parseUINT32(brandMask);
		_parser0.parseUINT32(siteMask);
		_parser0.parseINT32(buyin);
		_parser0.parseINT32(rake);
		_parser0.parseINT32(currency);
		_parser0.parseINT32(scalePM);
		_parser0.parseBYTE(game);
		_parser0.parseBYTE(isHiLo);
		_parser0.parseBYTE(structure);
		_parser0.parseBYTE(speedDisplay);
		_parser0.parseINT32(minPrizePool);
		_parser0.parseINT32(maxPrizePool);
		_parser0.parseINT32(maxPayout);
		_parser0.parseStringP(promoRef);
		_parser0.parseINT32(minClientVersion);
		_parser0.parseINT32(maxClientVersion);
		mods.parseMsg(_parser0);
		tickets.parseMsg(_parser0);
		_parser0.parseStringP(customSpeedDisplayName);
		_parser0.parseBOOL(restrictCountryInversion);
		statesByCountry.parseMsg(_parser0);
		_parser0.parseStringP(visibilityCriteria);
		_parser0.parseStringP(mobileName);
		_parser0.parseUINT32(tournGroup);
		admissions.parseMsg(_parser0);
		_parser0.parseBOOL(isPlayMoney);
		if(_parser0.parseEnded()) return;
		_parser0.parseUINT32(tournFlags);
		if(_parser0.parseEnded()) return;
		_parser0.parseStringP(tournGroupName);
		if(_parser0.parseEnded()) return;
		_parser0.parseStringP(tournGroupRef);
		if(_parser0.parseEnded()) return;
		tournSites.parseMsg(_parser0);
	}
}

/*static*/ void MLobbyNG::cli::MLobbyNGSagLocalStaticDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	bool active = false;
	_parser0.parseBOOL(active);
	AtfValidator::validateInt(_descr, "active", active, _checker, __FILE__, __LINE__);
	if( active )
	{
		UINT32 scriptId; _parser0.parseUINT32(scriptId);
		AtfValidator::validateInt(_descr, "scriptId", scriptId, _checker, __FILE__, __LINE__);
		UINT32 flags; _parser0.parseUINT32(flags);
		AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
		UINT32 brandMask; _parser0.parseUINT32(brandMask);
		AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
		UINT32 siteMask; _parser0.parseUINT32(siteMask);
		AtfValidator::validateInt(_descr, "siteMask", siteMask, _checker, __FILE__, __LINE__);
		INT32 buyin; _parser0.parseINT32(buyin);
		AtfValidator::validateInt(_descr, "buyin", buyin, _checker, __FILE__, __LINE__);
		INT32 rake; _parser0.parseINT32(rake);
		AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
		INT32 currency; _parser0.parseINT32(currency);
		AtfValidator::validateInt(_descr, "currency", currency, _checker, __FILE__, __LINE__);
		INT32 scalePM; _parser0.parseINT32(scalePM);
		AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
		BYTE game; _parser0.parseBYTE(game);
		AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
		BYTE isHiLo; _parser0.parseBYTE(isHiLo);
		AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
		BYTE structure; _parser0.parseBYTE(structure);
		AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
		BYTE speedDisplay; _parser0.parseBYTE(speedDisplay);
		AtfValidator::validateInt(_descr, "speedDisplay", speedDisplay, _checker, __FILE__, __LINE__);
		INT32 minPrizePool; _parser0.parseINT32(minPrizePool);
		AtfValidator::validateInt(_descr, "minPrizePool", minPrizePool, _checker, __FILE__, __LINE__);
		INT32 maxPrizePool; _parser0.parseINT32(maxPrizePool);
		AtfValidator::validateInt(_descr, "maxPrizePool", maxPrizePool, _checker, __FILE__, __LINE__);
		INT32 maxPayout; _parser0.parseINT32(maxPayout);
		AtfValidator::validateInt(_descr, "maxPayout", maxPayout, _checker, __FILE__, __LINE__);
		_parser0.parseStringN(_dummy, 0, "promoRef"); size_t szPromoRef = strlen(_dummy);
		AtfValidator::validateInt(_descr, "promoRef", szPromoRef, _checker, __FILE__, __LINE__);
		INT32 minClientVersion; _parser0.parseINT32(minClientVersion);
		AtfValidator::validateInt(_descr, "minClientVersion", minClientVersion, _checker, __FILE__, __LINE__);
		INT32 maxClientVersion; _parser0.parseINT32(maxClientVersion);
		AtfValidator::validateInt(_descr, "maxClientVersion", maxClientVersion, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szMods = ThinAtf::LAtfVector< SagMaxMods, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("mods"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "mods", szMods, _checker, __FILE__, __LINE__);
		int szTickets = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tickets"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tickets", szTickets, _checker, __FILE__, __LINE__);
		_parser0.parseStringN(_dummy, 0, "customSpeedDisplayName"); size_t szCustomSpeedDisplayName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "customSpeedDisplayName", szCustomSpeedDisplayName, _checker, __FILE__, __LINE__);
		bool restrictCountryInversion; _parser0.parseBOOL(restrictCountryInversion);
		AtfValidator::validateInt(_descr, "restrictCountryInversion", restrictCountryInversion, _checker, __FILE__, __LINE__);
		int szStatesByCountry = ThinAtf::LAtfVector< StatesByCountryStruct, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("statesByCountry"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "statesByCountry", szStatesByCountry, _checker, __FILE__, __LINE__);
		_parser0.parseStringN(_dummy, 0, "visibilityCriteria"); size_t szVisibilityCriteria = strlen(_dummy);
		AtfValidator::validateInt(_descr, "visibilityCriteria", szVisibilityCriteria, _checker, __FILE__, __LINE__);
		_parser0.parseStringN(_dummy, 0, "mobileName"); size_t szMobileName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "mobileName", szMobileName, _checker, __FILE__, __LINE__);
		UINT32 tournGroup; _parser0.parseUINT32(tournGroup);
		AtfValidator::validateInt(_descr, "tournGroup", tournGroup, _checker, __FILE__, __LINE__);
		int szAdmissions = ThinAtf::LAtfVector< PString, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("admissions"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "admissions", szAdmissions, _checker, __FILE__, __LINE__);
		bool isPlayMoney; _parser0.parseBOOL(isPlayMoney);
		AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
		if(_parser0.parseEnded()) return;
		UINT32 tournFlags; _parser0.parseUINT32(tournFlags);
		AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
		if(_parser0.parseEnded()) return;
		_parser0.parseStringN(_dummy, 0, "tournGroupName"); size_t szTournGroupName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tournGroupName", szTournGroupName, _checker, __FILE__, __LINE__);
		if(_parser0.parseEnded()) return;
		_parser0.parseStringN(_dummy, 0, "tournGroupRef"); size_t szTournGroupRef = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tournGroupRef", szTournGroupRef, _checker, __FILE__, __LINE__);
		if(_parser0.parseEnded()) return;
		PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tournSites"), _fieldsWithUnparsedContent);
	}
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SagDataStruct
//=================================================================

MLobbyNG::cli::SagDataStruct::SagDataStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::SagDataStruct::SagDataStruct(SagDataStruct&& _o)
	: staticData(std::move(_o.staticData))
	, lastEntry(std::move(_o.lastEntry))
	, userHasTicket(std::move(_o.userHasTicket))
	, ngSagFlags(std::move(_o.ngSagFlags))
{
}

MLobbyNG::cli::SagDataStruct& MLobbyNG::cli::SagDataStruct::operator=(SagDataStruct&& _o)
{
	if(this != &_o)
	{
		staticData = std::move(_o.staticData);
		lastEntry = std::move(_o.lastEntry);
		userHasTicket = std::move(_o.userHasTicket);
		ngSagFlags = std::move(_o.ngSagFlags);
	}
	return *this;
}

#endif

void MLobbyNG::cli::SagDataStruct::clear()
{
	staticData.clear();
	lastEntry.setNull();
	userHasTicket = false;
	ngSagFlags = 0;
}

bool MLobbyNG::cli::SagDataStruct::equals(const SagDataStruct& _o) const
{
	return staticData.equals(_o.staticData) &&
		lastEntry.equals(_o.lastEntry) &&
		userHasTicket == _o.userHasTicket &&
		ngSagFlags == _o.ngSagFlags;
}

const char *MLobbyNG::cli::SagDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("staticData=");
	staticData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("lastEntry=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, lastEntry);
	_buf.append(',');
	_buf.append("userHasTicket=");
	_buf.appendUint(userHasTicket);
	_buf.append(',');
	_buf.append("ngSagFlags=");
	_buf.appendUint(ngSagFlags);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::SagDataStruct::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(SagDataStruct())) // not empty
	{
		staticData.composeMsg(_body);
		_body.composeSrvTime(lastEntry);
		_body.composeBOOL(userHasTicket);
		_body.composeUINT32(ngSagFlags);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::SagDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	staticData.parseMsg(_parser0);
	_parser0.parseSrvTime(lastEntry);
	if(_parser0.parseEnded()) return;
	_parser0.parseBOOL(userHasTicket);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT32(ngSagFlags);
}

/*static*/ void MLobbyNG::cli::SagDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	MLobbyNGSagLocalStaticDataStruct::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("staticData"), _fieldsWithUnparsedContent);
	SrvTime lastEntry; _parser0.parseSrvTime(lastEntry);
	AtfValidator::validateSrvDateTime(_descr, "lastEntry", lastEntry, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	bool userHasTicket; _parser0.parseBOOL(userHasTicket);
	AtfValidator::validateInt(_descr, "userHasTicket", userHasTicket, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	UINT32 ngSagFlags; _parser0.parseUINT32(ngSagFlags);
	AtfValidator::validateInt(_descr, "ngSagFlags", ngSagFlags, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PPPDataStruct
//=================================================================

MLobbyNG::cli::PPPDataStruct::PPPDataStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::PPPDataStruct::PPPDataStruct(PPPDataStruct&& _o)
	: staticData(std::move(_o.staticData))
	, buyIn(std::move(_o.buyIn))
	, lastEntry(std::move(_o.lastEntry))
{
}

MLobbyNG::cli::PPPDataStruct& MLobbyNG::cli::PPPDataStruct::operator=(PPPDataStruct&& _o)
{
	if(this != &_o)
	{
		staticData = std::move(_o.staticData);
		buyIn = std::move(_o.buyIn);
		lastEntry = std::move(_o.lastEntry);
	}
	return *this;
}

#endif

void MLobbyNG::cli::PPPDataStruct::clear()
{
	staticData.clear();
	buyIn = 0;
	lastEntry.setNull();
}

bool MLobbyNG::cli::PPPDataStruct::equals(const PPPDataStruct& _o) const
{
	return staticData.equals(_o.staticData) &&
		buyIn == _o.buyIn &&
		lastEntry.equals(_o.lastEntry);
}

const char *MLobbyNG::cli::PPPDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("staticData=");
	staticData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendInt64(buyIn);
	_buf.append(',');
	_buf.append("lastEntry=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, lastEntry);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::PPPDataStruct::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(PPPDataStruct())) // not empty
	{
		staticData.composeMsg(_body);
		_body.composeINT64(buyIn);
		_body.composeSrvTime(lastEntry);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::PPPDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	staticData.parseMsg(_parser0);
	_parser0.parseINT64(buyIn);
	_parser0.parseSrvTime(lastEntry);
}

/*static*/ void MLobbyNG::cli::PPPDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	PPPClient::publication::PppStaticLeaf::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("staticData"), _fieldsWithUnparsedContent);
	INT64 buyIn; _parser0.parseINT64(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	SrvTime lastEntry; _parser0.parseSrvTime(lastEntry);
	AtfValidator::validateSrvDateTime(_descr, "lastEntry", lastEntry, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TableSelectionFilter
//=================================================================

MLobbyNG::cli::TableSelectionFilter::TableSelectionFilter()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::TableSelectionFilter::TableSelectionFilter(TableSelectionFilter&& _o)
	: locale(std::move(_o.locale))
	, gameMask(std::move(_o.gameMask))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, minStake(std::move(_o.minStake))
	, maxStake(std::move(_o.maxStake))
	, currencyMask(std::move(_o.currencyMask))
	, tableSizeMask(std::move(_o.tableSizeMask))
	, country(std::move(_o.country))
	, gameCategoryMask(std::move(_o.gameCategoryMask))
	, capMask(std::move(_o.capMask))
	, anteMask(std::move(_o.anteMask))
	, minDeepRatio(std::move(_o.minDeepRatio))
	, maxDeepRatio(std::move(_o.maxDeepRatio))
	, minBuyIn(std::move(_o.minBuyIn))
	, maxBuyIn(std::move(_o.maxBuyIn))
	, variantMask(std::move(_o.variantMask))
{
}

MLobbyNG::cli::TableSelectionFilter& MLobbyNG::cli::TableSelectionFilter::operator=(TableSelectionFilter&& _o)
{
	if(this != &_o)
	{
		locale = std::move(_o.locale);
		gameMask = std::move(_o.gameMask);
		isPlayMoney = std::move(_o.isPlayMoney);
		minStake = std::move(_o.minStake);
		maxStake = std::move(_o.maxStake);
		currencyMask = std::move(_o.currencyMask);
		tableSizeMask = std::move(_o.tableSizeMask);
		country = std::move(_o.country);
		gameCategoryMask = std::move(_o.gameCategoryMask);
		capMask = std::move(_o.capMask);
		anteMask = std::move(_o.anteMask);
		minDeepRatio = std::move(_o.minDeepRatio);
		maxDeepRatio = std::move(_o.maxDeepRatio);
		minBuyIn = std::move(_o.minBuyIn);
		maxBuyIn = std::move(_o.maxBuyIn);
		variantMask = std::move(_o.variantMask);
	}
	return *this;
}

#endif

void MLobbyNG::cli::TableSelectionFilter::clear()
{
	locale = 0;
	gameMask = 0;
	isPlayMoney = false;
	minStake = 0;
	maxStake = 0;
	currencyMask = 0;
	tableSizeMask = 0;
	country.clear();
	gameCategoryMask = 0;
	capMask = 0;
	anteMask = 0;
	minDeepRatio = 0;
	maxDeepRatio = 0;
	minBuyIn = 0;
	maxBuyIn = 0;
	variantMask = NGTableVariant_Regular;
}

bool MLobbyNG::cli::TableSelectionFilter::equals(const TableSelectionFilter& _o) const
{
	return locale == _o.locale &&
		gameMask == _o.gameMask &&
		isPlayMoney == _o.isPlayMoney &&
		minStake == _o.minStake &&
		maxStake == _o.maxStake &&
		currencyMask == _o.currencyMask &&
		tableSizeMask == _o.tableSizeMask &&
		country.equals(_o.country) &&
		gameCategoryMask == _o.gameCategoryMask &&
		capMask == _o.capMask &&
		anteMask == _o.anteMask &&
		minDeepRatio == _o.minDeepRatio &&
		maxDeepRatio == _o.maxDeepRatio &&
		minBuyIn == _o.minBuyIn &&
		maxBuyIn == _o.maxBuyIn &&
		variantMask == _o.variantMask;
}

const char *MLobbyNG::cli::TableSelectionFilter::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("gameMask=");
	_buf.appendUint64(gameMask);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("minStake=");
	_buf.appendInt64(minStake);
	_buf.append(',');
	_buf.append("maxStake=");
	_buf.appendInt64(maxStake);
	_buf.append(',');
	_buf.append("currencyMask=");
	_buf.appendUint(currencyMask);
	_buf.append(',');
	_buf.append("tableSizeMask=");
	_buf.appendUint(tableSizeMask);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("gameCategoryMask=");
	_buf.appendUint(gameCategoryMask);
	_buf.append(',');
	_buf.append("capMask=");
	_buf.appendUint(capMask);
	_buf.append(',');
	_buf.append("anteMask=");
	_buf.appendUint(anteMask);
	_buf.append(',');
	_buf.append("minDeepRatio=");
	_buf.appendInt(minDeepRatio);
	_buf.append(',');
	_buf.append("maxDeepRatio=");
	_buf.appendInt(maxDeepRatio);
	_buf.append(',');
	_buf.append("minBuyIn=");
	_buf.appendInt64(minBuyIn);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendInt64(maxBuyIn);
	_buf.append(',');
	_buf.append("variantMask=");
	_buf.appendUint(variantMask);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::TableSelectionFilter::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(TableSelectionFilter())) // not empty
	{
		_body.composeUINT32(locale);
		_body.composeUINT64(gameMask);
		_body.composeBOOL(isPlayMoney);
		_body.composeINT64(minStake);
		_body.composeINT64(maxStake);
		_body.composeUINT32(currencyMask);
		_body.composeUINT32(tableSizeMask);
		_body.composeString(country);
		_body.composeUINT32(gameCategoryMask);
		_body.composeUINT32(capMask);
		_body.composeUINT32(anteMask);
		_body.composeINT32(minDeepRatio);
		_body.composeINT32(maxDeepRatio);
		_body.composeINT64(minBuyIn);
		_body.composeINT64(maxBuyIn);
		_body.composeUINT32(variantMask);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::TableSelectionFilter::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(locale);
	_parser0.parseUINT64(gameMask);
	_parser0.parseBOOL(isPlayMoney);
	_parser0.parseINT64(minStake);
	_parser0.parseINT64(maxStake);
	_parser0.parseUINT32(currencyMask);
	_parser0.parseUINT32(tableSizeMask);
	_parser0.parseStringP(country);
	_parser0.parseUINT32(gameCategoryMask);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT32(capMask);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT32(anteMask);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT32(minDeepRatio);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT32(maxDeepRatio);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT64(minBuyIn);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT64(maxBuyIn);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT32(variantMask);
}

/*static*/ void MLobbyNG::cli::TableSelectionFilter::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 locale; _parser0.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT64 gameMask; _parser0.parseUINT64(gameMask);
	AtfValidator::validateUintMax(_descr, "gameMask", gameMask, (2*(UINT64)NGGameTypes::NGGame_Last-1), _checker, __FILE__, __LINE__);
	bool isPlayMoney; _parser0.parseBOOL(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	INT64 minStake; _parser0.parseINT64(minStake);
	AtfValidator::validateIntMax(_descr, "minStake", minStake, 2000000000, _checker, __FILE__, __LINE__);
	INT64 maxStake; _parser0.parseINT64(maxStake);
	AtfValidator::validateIntMax(_descr, "maxStake", maxStake, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 currencyMask; _parser0.parseUINT32(currencyMask);
	AtfValidator::validateIntMax(_descr, "currencyMask", currencyMask, (2*NGCurrency_Last-1), _checker, __FILE__, __LINE__);
	UINT32 tableSizeMask; _parser0.parseUINT32(tableSizeMask);
	AtfValidator::validateIntMax(_descr, "tableSizeMask", tableSizeMask, (2*NGMaxTableSize_Last-1), _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, 3, _checker, __FILE__, __LINE__);
	UINT32 gameCategoryMask; _parser0.parseUINT32(gameCategoryMask);
	AtfValidator::validateIntMax(_descr, "gameCategoryMask", gameCategoryMask, (2*GameCategory_Last-1), _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	UINT32 capMask; _parser0.parseUINT32(capMask);
	AtfValidator::validateIntMax(_descr, "capMask", capMask, (2*NGTableHasCap_Last-1), _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	UINT32 anteMask; _parser0.parseUINT32(anteMask);
	AtfValidator::validateIntMax(_descr, "anteMask", anteMask, (2*NGTableHasAnte_Last-1), _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT32 minDeepRatio; _parser0.parseINT32(minDeepRatio);
	AtfValidator::validateIntMax(_descr, "minDeepRatio", minDeepRatio, 2000000000, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT32 maxDeepRatio; _parser0.parseINT32(maxDeepRatio);
	AtfValidator::validateIntMax(_descr, "maxDeepRatio", maxDeepRatio, 2000000000, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT64 minBuyIn; _parser0.parseINT64(minBuyIn);
	AtfValidator::validateInt(_descr, "minBuyIn", minBuyIn, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT64 maxBuyIn; _parser0.parseINT64(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	UINT32 variantMask; _parser0.parseUINT32(variantMask);
	AtfValidator::validateIntMax(_descr, "variantMask", variantMask, (2*NGTableVariant_Last-1), _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TableResultCriteria
//=================================================================

MLobbyNG::cli::TableResultCriteria::TableResultCriteria()
{
	clear();
}

void MLobbyNG::cli::TableResultCriteria::clear()
{
	sortOrder = 0;
	maxItems = 0;
}

bool MLobbyNG::cli::TableResultCriteria::equals(const TableResultCriteria& _o) const
{
	return sortOrder == _o.sortOrder &&
		maxItems == _o.maxItems;
}

const char *MLobbyNG::cli::TableResultCriteria::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("sortOrder=");
	_buf.appendUint(sortOrder);
	_buf.append(',');
	_buf.append("maxItems=");
	_buf.appendUint(maxItems);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::TableResultCriteria::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(TableResultCriteria())) // not empty
	{
		_body.composeUINT32(sortOrder);
		_body.composeUINT32(maxItems);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::TableResultCriteria::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(sortOrder);
	_parser0.parseUINT32(maxItems);
}

/*static*/ void MLobbyNG::cli::TableResultCriteria::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 sortOrder; _parser0.parseUINT32(sortOrder);
	AtfValidator::validateIntRange(_descr, "sortOrder", sortOrder, NGTableSort_StakesAsc, NGTableSort_Last, _checker, __FILE__, __LINE__);
	UINT32 maxItems; _parser0.parseUINT32(maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TableDataStruct
//=================================================================

MLobbyNG::cli::TableDataStruct::TableDataStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::TableDataStruct::TableDataStruct(TableDataStruct&& _o)
	: id(std::move(_o.id))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, game(std::move(_o.game))
	, isHiLo(std::move(_o.isHiLo))
	, maxPlayers(std::move(_o.maxPlayers))
	, visibilityMask(std::move(_o.visibilityMask))
	, structure(std::move(_o.structure))
	, loBet(std::move(_o.loBet))
	, hiBet(std::move(_o.hiBet))
	, ante(std::move(_o.ante))
	, cap(std::move(_o.cap))
	, currency(std::move(_o.currency))
	, minChipsLimit(std::move(_o.minChipsLimit))
	, maxBuyIn(std::move(_o.maxBuyIn))
	, countryRestrictionInverted(std::move(_o.countryRestrictionInverted))
	, restrictedCountries(std::move(_o.restrictedCountries))
	, visible(std::move(_o.visible))
	, scalePM(std::move(_o.scalePM))
	, defaultBuyIn(std::move(_o.defaultBuyIn))
	, brandMask(std::move(_o.brandMask))
	, seatFinderId(std::move(_o.seatFinderId))
	, poolBlockMinHands(std::move(_o.poolBlockMinHands))
	, poolBlockTimePenalty(std::move(_o.poolBlockTimePenalty))
	, isPasswordProtected(std::move(_o.isPasswordProtected))
	, isMorphLobby(std::move(_o.isMorphLobby))
	, lastEntry(std::move(_o.lastEntry))
	, tableStakes(std::move(_o.tableStakes))
	, variableAntes(std::move(_o.variableAntes))
	, tableFlags(std::move(_o.tableFlags))
	, tableFlags2(std::move(_o.tableFlags2))
	, visibilityMaskEx(std::move(_o.visibilityMaskEx))
{
}

MLobbyNG::cli::TableDataStruct& MLobbyNG::cli::TableDataStruct::operator=(TableDataStruct&& _o)
{
	if(this != &_o)
	{
		id = std::move(_o.id);
		isPlayMoney = std::move(_o.isPlayMoney);
		game = std::move(_o.game);
		isHiLo = std::move(_o.isHiLo);
		maxPlayers = std::move(_o.maxPlayers);
		visibilityMask = std::move(_o.visibilityMask);
		structure = std::move(_o.structure);
		loBet = std::move(_o.loBet);
		hiBet = std::move(_o.hiBet);
		ante = std::move(_o.ante);
		cap = std::move(_o.cap);
		currency = std::move(_o.currency);
		minChipsLimit = std::move(_o.minChipsLimit);
		maxBuyIn = std::move(_o.maxBuyIn);
		countryRestrictionInverted = std::move(_o.countryRestrictionInverted);
		restrictedCountries = std::move(_o.restrictedCountries);
		visible = std::move(_o.visible);
		scalePM = std::move(_o.scalePM);
		defaultBuyIn = std::move(_o.defaultBuyIn);
		brandMask = std::move(_o.brandMask);
		seatFinderId = std::move(_o.seatFinderId);
		poolBlockMinHands = std::move(_o.poolBlockMinHands);
		poolBlockTimePenalty = std::move(_o.poolBlockTimePenalty);
		isPasswordProtected = std::move(_o.isPasswordProtected);
		isMorphLobby = std::move(_o.isMorphLobby);
		lastEntry = std::move(_o.lastEntry);
		tableStakes = std::move(_o.tableStakes);
		variableAntes = std::move(_o.variableAntes);
		tableFlags = std::move(_o.tableFlags);
		tableFlags2 = std::move(_o.tableFlags2);
		visibilityMaskEx = std::move(_o.visibilityMaskEx);
	}
	return *this;
}

#endif

void MLobbyNG::cli::TableDataStruct::clear()
{
	id = 0;
	isPlayMoney = 0;
	game = 0;
	isHiLo = 0;
	maxPlayers = 0;
	visibilityMask = 0;
	structure = 0;
	loBet = 0;
	hiBet = 0;
	ante = 0;
	cap = 0;
	currency.clear();
	minChipsLimit = 0;
	maxBuyIn = 0;
	countryRestrictionInverted = false;
	restrictedCountries.clear();
	visible = false;
	scalePM = 0;
	defaultBuyIn = 0;
	brandMask = 0;
	seatFinderId = 0;
	poolBlockMinHands = 0;
	poolBlockTimePenalty.clear();
	isPasswordProtected = false;
	isMorphLobby = false;
	lastEntry.setNull();
	tableStakes.clear();
	variableAntes.clear();
	tableFlags = 0;
	tableFlags2 = 0;
	visibilityMaskEx.clear();
}

bool MLobbyNG::cli::TableDataStruct::equals(const TableDataStruct& _o) const
{
	return id == _o.id &&
		isPlayMoney == _o.isPlayMoney &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		maxPlayers == _o.maxPlayers &&
		visibilityMask == _o.visibilityMask &&
		structure == _o.structure &&
		loBet == _o.loBet &&
		hiBet == _o.hiBet &&
		ante == _o.ante &&
		cap == _o.cap &&
		currency.equals(_o.currency) &&
		minChipsLimit == _o.minChipsLimit &&
		maxBuyIn == _o.maxBuyIn &&
		countryRestrictionInverted == _o.countryRestrictionInverted &&
		restrictedCountries.equals(_o.restrictedCountries) &&
		visible == _o.visible &&
		scalePM == _o.scalePM &&
		defaultBuyIn == _o.defaultBuyIn &&
		brandMask == _o.brandMask &&
		seatFinderId == _o.seatFinderId &&
		poolBlockMinHands == _o.poolBlockMinHands &&
		poolBlockTimePenalty.equals(_o.poolBlockTimePenalty) &&
		isPasswordProtected == _o.isPasswordProtected &&
		isMorphLobby == _o.isMorphLobby &&
		lastEntry.equals(_o.lastEntry) &&
		tableStakes.equals(_o.tableStakes) &&
		variableAntes.equals(_o.variableAntes) &&
		tableFlags == _o.tableFlags &&
		tableFlags2 == _o.tableFlags2 &&
		visibilityMaskEx.equals(_o.visibilityMaskEx);
}

const char *MLobbyNG::cli::TableDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("id=");
	_buf.appendUint(id);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendUint(maxPlayers);
	_buf.append(',');
	_buf.append("visibilityMask=");
	_buf.appendUint(visibilityMask);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("loBet=");
	_buf.appendUint(loBet);
	_buf.append(',');
	_buf.append("hiBet=");
	_buf.appendUint(hiBet);
	_buf.append(',');
	_buf.append("ante=");
	_buf.appendUint(ante);
	_buf.append(',');
	_buf.append("cap=");
	_buf.appendUint(cap);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("minChipsLimit=");
	_buf.appendUint(minChipsLimit);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendUint(maxBuyIn);
	_buf.append(',');
	_buf.append("countryRestrictionInverted=");
	_buf.appendUint(countryRestrictionInverted);
	_buf.append(',');
	_buf.append("restrictedCountries=");
	restrictedCountries.toTraceString(_buf);
	_buf.append(',');
	_buf.append("visible=");
	_buf.appendUint(visible);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("defaultBuyIn=");
	_buf.appendUint(defaultBuyIn);
	_buf.append(',');
	_buf.append("brandMask=");
	_buf.appendUint(brandMask);
	_buf.append(',');
	_buf.append("seatFinderId=");
	_buf.appendUint(seatFinderId);
	_buf.append(',');
	_buf.append("poolBlockMinHands=");
	_buf.appendInt(poolBlockMinHands);
	_buf.append(',');
	_buf.append("poolBlockTimePenalty=");
	poolBlockTimePenalty.toTraceString(_buf);
	_buf.append(',');
	_buf.append("isPasswordProtected=");
	_buf.appendUint(isPasswordProtected);
	_buf.append(',');
	_buf.append("isMorphLobby=");
	_buf.appendUint(isMorphLobby);
	_buf.append(',');
	_buf.append("lastEntry=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, lastEntry);
	_buf.append(',');
	_buf.append("tableStakes=");
	tableStakes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("variableAntes=");
	variableAntes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableFlags=");
	_buf.appendUint(tableFlags);
	_buf.append(',');
	_buf.append("tableFlags2=");
	_buf.appendUint64(tableFlags2);
	_buf.append(',');
	_buf.append("visibilityMaskEx=");
	visibilityMaskEx.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::TableDataStruct::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(TableDataStruct())) // not empty
	{
		_body.composeUINT32(id);
		_body.composeBYTE(isPlayMoney);
		_body.composeBYTE(game);
		_body.composeBYTE(isHiLo);
		_body.composeBYTE(maxPlayers);
		_body.composeUINT32(visibilityMask);
		_body.composeBYTE(structure);
		_body.composeUINT32(loBet);
		_body.composeUINT32(hiBet);
		_body.composeUINT32(ante);
		_body.composeUINT32(cap);
		_body.composeString(currency);
		_body.composeUINT32(minChipsLimit);
		_body.composeUINT32(maxBuyIn);
		_body.composeBOOL(countryRestrictionInverted);
		restrictedCountries.composeMsg(_body);
		_body.composeBOOL(visible);
		_body.composeUINT32(scalePM);
		_body.composeUINT32(defaultBuyIn);
		_body.composeUINT32(brandMask);
		_body.composeUINT32(seatFinderId);
		_body.composeINT32(poolBlockMinHands);
		poolBlockTimePenalty.composeMsg(_body);
		_body.composeBOOL(isPasswordProtected);
		_body.composeBOOL(isMorphLobby);
		_body.composeSrvTime(lastEntry);
		tableStakes.composeMsg(_body);
		variableAntes.composeMsg(_body);
		_body.composeUINT32(tableFlags);
		_body.composeUINT64(tableFlags2);
		visibilityMaskEx.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::TableDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(id);
	_parser0.parseBYTE(isPlayMoney);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(isHiLo);
	_parser0.parseBYTE(maxPlayers);
	_parser0.parseUINT32(visibilityMask);
	_parser0.parseBYTE(structure);
	_parser0.parseUINT32(loBet);
	_parser0.parseUINT32(hiBet);
	_parser0.parseUINT32(ante);
	_parser0.parseUINT32(cap);
	_parser0.parseStringP(currency);
	_parser0.parseUINT32(minChipsLimit);
	_parser0.parseUINT32(maxBuyIn);
	_parser0.parseBOOL(countryRestrictionInverted);
	restrictedCountries.parseMsg(_parser0);
	_parser0.parseBOOL(visible);
	_parser0.parseUINT32(scalePM);
	_parser0.parseUINT32(defaultBuyIn);
	_parser0.parseUINT32(brandMask);
	_parser0.parseUINT32(seatFinderId);
	_parser0.parseINT32(poolBlockMinHands);
	poolBlockTimePenalty.parseMsg(_parser0);
	_parser0.parseBOOL(isPasswordProtected);
	_parser0.parseBOOL(isMorphLobby);
	_parser0.parseSrvTime(lastEntry);
	if(_parser0.parseEnded()) return;
	tableStakes.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	variableAntes.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT32(tableFlags);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT64(tableFlags2);
	if(_parser0.parseEnded()) return;
	visibilityMaskEx.parseMsg(_parser0);
}

/*static*/ void MLobbyNG::cli::TableDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 id; _parser0.parseUINT32(id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser0.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser0.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE maxPlayers; _parser0.parseBYTE(maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	UINT32 visibilityMask; _parser0.parseUINT32(visibilityMask);
	AtfValidator::validateInt(_descr, "visibilityMask", visibilityMask, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	UINT32 loBet; _parser0.parseUINT32(loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	UINT32 hiBet; _parser0.parseUINT32(hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	UINT32 ante; _parser0.parseUINT32(ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	UINT32 cap; _parser0.parseUINT32(cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 minChipsLimit; _parser0.parseUINT32(minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	UINT32 maxBuyIn; _parser0.parseUINT32(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	bool countryRestrictionInverted; _parser0.parseBOOL(countryRestrictionInverted);
	AtfValidator::validateInt(_descr, "countryRestrictionInverted", countryRestrictionInverted, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szRestrictedCountries = ThinAtf::LAtfVector< PString, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("restrictedCountries"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "restrictedCountries", szRestrictedCountries, _checker, __FILE__, __LINE__);
	bool visible; _parser0.parseBOOL(visible);
	AtfValidator::validateInt(_descr, "visible", visible, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser0.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT32 defaultBuyIn; _parser0.parseUINT32(defaultBuyIn);
	AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	UINT32 brandMask; _parser0.parseUINT32(brandMask);
	AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
	UINT32 seatFinderId; _parser0.parseUINT32(seatFinderId);
	AtfValidator::validateInt(_descr, "seatFinderId", seatFinderId, _checker, __FILE__, __LINE__);
	INT32 poolBlockMinHands; _parser0.parseINT32(poolBlockMinHands);
	AtfValidator::validateInt(_descr, "poolBlockMinHands", poolBlockMinHands, _checker, __FILE__, __LINE__);
	int szPoolBlockTimePenalty = ThinAtf::LAtfVector< INT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("poolBlockTimePenalty"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "poolBlockTimePenalty", szPoolBlockTimePenalty, _checker, __FILE__, __LINE__);
	bool isPasswordProtected; _parser0.parseBOOL(isPasswordProtected);
	AtfValidator::validateInt(_descr, "isPasswordProtected", isPasswordProtected, _checker, __FILE__, __LINE__);
	bool isMorphLobby; _parser0.parseBOOL(isMorphLobby);
	AtfValidator::validateInt(_descr, "isMorphLobby", isMorphLobby, _checker, __FILE__, __LINE__);
	SrvTime lastEntry; _parser0.parseSrvTime(lastEntry);
	AtfValidator::validateSrvDateTime(_descr, "lastEntry", lastEntry, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	TableCommonThin::TableStakes::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tableStakes"), _fieldsWithUnparsedContent);
	if(_parser0.parseEnded()) return;
	int szVariableAntes = ThinAtf::LAtfVector< INT64, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("variableAntes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "variableAntes", szVariableAntes, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	UINT32 tableFlags; _parser0.parseUINT32(tableFlags);
	AtfValidator::validateInt(_descr, "tableFlags", tableFlags, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	UINT64 tableFlags2; _parser0.parseUINT64(tableFlags2);
	AtfValidator::validateUint(_descr, "tableFlags2", tableFlags2, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("visibilityMaskEx"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ZoomStaticDataStruct
//=================================================================

MLobbyNG::cli::ZoomStaticDataStruct::ZoomStaticDataStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::ZoomStaticDataStruct::ZoomStaticDataStruct(ZoomStaticDataStruct&& _o)
	: id(std::move(_o.id))
	, game(std::move(_o.game))
	, structure(std::move(_o.structure))
	, isHiLo(std::move(_o.isHiLo))
	, maxPlayersPerTable(std::move(_o.maxPlayersPerTable))
	, loBet(std::move(_o.loBet))
	, hiBet(std::move(_o.hiBet))
	, ante(std::move(_o.ante))
	, cap(std::move(_o.cap))
	, currency(std::move(_o.currency))
	, minChipsLimit(std::move(_o.minChipsLimit))
	, maxBuyIn(std::move(_o.maxBuyIn))
	, visibilityMask(std::move(_o.visibilityMask))
	, defaultBuyIn(std::move(_o.defaultBuyIn))
	, specialName(std::move(_o.specialName))
	, countryRestrictionInverted(std::move(_o.countryRestrictionInverted))
	, restrictedCountries(std::move(_o.restrictedCountries))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, isMorphLobby(std::move(_o.isMorphLobby))
	, scalePM(std::move(_o.scalePM))
	, server(std::move(_o.server))
	, name(std::move(_o.name))
	, replayerInstance(std::move(_o.replayerInstance))
	, isOneOnOne(std::move(_o.isOneOnOne))
	, tableFlags(std::move(_o.tableFlags))
	, chatLang(std::move(_o.chatLang))
	, quickLobbyVisible(std::move(_o.quickLobbyVisible))
	, blitzFlags(std::move(_o.blitzFlags))
	, brandMask(std::move(_o.brandMask))
	, serverObj(std::move(_o.serverObj))
	, tableStakes(std::move(_o.tableStakes))
	, visibilityMaskEx(std::move(_o.visibilityMaskEx))
	, tableFlags2(std::move(_o.tableFlags2))
{
}

MLobbyNG::cli::ZoomStaticDataStruct& MLobbyNG::cli::ZoomStaticDataStruct::operator=(ZoomStaticDataStruct&& _o)
{
	if(this != &_o)
	{
		id = std::move(_o.id);
		game = std::move(_o.game);
		structure = std::move(_o.structure);
		isHiLo = std::move(_o.isHiLo);
		maxPlayersPerTable = std::move(_o.maxPlayersPerTable);
		loBet = std::move(_o.loBet);
		hiBet = std::move(_o.hiBet);
		ante = std::move(_o.ante);
		cap = std::move(_o.cap);
		currency = std::move(_o.currency);
		minChipsLimit = std::move(_o.minChipsLimit);
		maxBuyIn = std::move(_o.maxBuyIn);
		visibilityMask = std::move(_o.visibilityMask);
		defaultBuyIn = std::move(_o.defaultBuyIn);
		specialName = std::move(_o.specialName);
		countryRestrictionInverted = std::move(_o.countryRestrictionInverted);
		restrictedCountries = std::move(_o.restrictedCountries);
		isPlayMoney = std::move(_o.isPlayMoney);
		isMorphLobby = std::move(_o.isMorphLobby);
		scalePM = std::move(_o.scalePM);
		server = std::move(_o.server);
		name = std::move(_o.name);
		replayerInstance = std::move(_o.replayerInstance);
		isOneOnOne = std::move(_o.isOneOnOne);
		tableFlags = std::move(_o.tableFlags);
		chatLang = std::move(_o.chatLang);
		quickLobbyVisible = std::move(_o.quickLobbyVisible);
		blitzFlags = std::move(_o.blitzFlags);
		brandMask = std::move(_o.brandMask);
		serverObj = std::move(_o.serverObj);
		tableStakes = std::move(_o.tableStakes);
		visibilityMaskEx = std::move(_o.visibilityMaskEx);
		tableFlags2 = std::move(_o.tableFlags2);
	}
	return *this;
}

#endif

void MLobbyNG::cli::ZoomStaticDataStruct::clear()
{
	id = 0;
	game = 0;
	structure = 0;
	isHiLo = 0;
	maxPlayersPerTable = 0;
	loBet = 0;
	hiBet = 0;
	ante = 0;
	cap = 0;
	currency.clear();
	minChipsLimit = 0;
	maxBuyIn = 0;
	visibilityMask = 0;
	defaultBuyIn = 0;
	specialName.clear();
	countryRestrictionInverted = false;
	restrictedCountries.clear();
	isPlayMoney = 0;
	isMorphLobby = false;
	scalePM = 0;
	server.clear();
	name.clear();
	replayerInstance.clear();
	isOneOnOne = 0;
	tableFlags = 0;
	chatLang = 0;
	quickLobbyVisible = false;
	blitzFlags = 0;
	brandMask = 0;
	serverObj.clear();
	tableStakes.clear();
	visibilityMaskEx.clear();
	tableFlags2 = 0;
}

bool MLobbyNG::cli::ZoomStaticDataStruct::equals(const ZoomStaticDataStruct& _o) const
{
	return id == _o.id &&
		game == _o.game &&
		structure == _o.structure &&
		isHiLo == _o.isHiLo &&
		maxPlayersPerTable == _o.maxPlayersPerTable &&
		loBet == _o.loBet &&
		hiBet == _o.hiBet &&
		ante == _o.ante &&
		cap == _o.cap &&
		currency.equals(_o.currency) &&
		minChipsLimit == _o.minChipsLimit &&
		maxBuyIn == _o.maxBuyIn &&
		visibilityMask == _o.visibilityMask &&
		defaultBuyIn == _o.defaultBuyIn &&
		specialName.equals(_o.specialName) &&
		countryRestrictionInverted == _o.countryRestrictionInverted &&
		restrictedCountries.equals(_o.restrictedCountries) &&
		isPlayMoney == _o.isPlayMoney &&
		isMorphLobby == _o.isMorphLobby &&
		scalePM == _o.scalePM &&
		server.equals(_o.server) &&
		name.equals(_o.name) &&
		replayerInstance.equals(_o.replayerInstance) &&
		isOneOnOne == _o.isOneOnOne &&
		tableFlags == _o.tableFlags &&
		chatLang == _o.chatLang &&
		quickLobbyVisible == _o.quickLobbyVisible &&
		blitzFlags == _o.blitzFlags &&
		brandMask == _o.brandMask &&
		serverObj.equals(_o.serverObj) &&
		tableStakes.equals(_o.tableStakes) &&
		visibilityMaskEx.equals(_o.visibilityMaskEx) &&
		tableFlags2 == _o.tableFlags2;
}

const char *MLobbyNG::cli::ZoomStaticDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("id=");
	_buf.appendUint(id);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("maxPlayersPerTable=");
	_buf.appendUint(maxPlayersPerTable);
	_buf.append(',');
	_buf.append("loBet=");
	_buf.appendInt(loBet);
	_buf.append(',');
	_buf.append("hiBet=");
	_buf.appendInt(hiBet);
	_buf.append(',');
	_buf.append("ante=");
	_buf.appendInt(ante);
	_buf.append(',');
	_buf.append("cap=");
	_buf.appendInt(cap);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("minChipsLimit=");
	_buf.appendInt(minChipsLimit);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendInt(maxBuyIn);
	_buf.append(',');
	_buf.append("visibilityMask=");
	_buf.appendUint(visibilityMask);
	_buf.append(',');
	_buf.append("defaultBuyIn=");
	_buf.appendInt(defaultBuyIn);
	_buf.append(',');
	_buf.append("specialName=");
	_buf.append(specialName);
	_buf.append(',');
	_buf.append("countryRestrictionInverted=");
	_buf.appendUint(countryRestrictionInverted);
	_buf.append(',');
	_buf.append("restrictedCountries=");
	restrictedCountries.toTraceString(_buf);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("isMorphLobby=");
	_buf.appendUint(isMorphLobby);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("replayerInstance=");
	_buf.append(replayerInstance);
	_buf.append(',');
	_buf.append("isOneOnOne=");
	_buf.appendUint(isOneOnOne);
	_buf.append(',');
	_buf.append("tableFlags=");
	_buf.appendUint(tableFlags);
	_buf.append(',');
	_buf.append("chatLang=");
	_buf.appendUint(chatLang);
	_buf.append(',');
	_buf.append("quickLobbyVisible=");
	_buf.appendUint(quickLobbyVisible);
	_buf.append(',');
	_buf.append("blitzFlags=");
	_buf.appendUint(blitzFlags);
	_buf.append(',');
	_buf.append("brandMask=");
	_buf.appendUint(brandMask);
	_buf.append(',');
	_buf.append("serverObj=");
	_buf.append(serverObj);
	_buf.append(',');
	_buf.append("tableStakes=");
	tableStakes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("visibilityMaskEx=");
	visibilityMaskEx.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableFlags2=");
	_buf.appendUint64(tableFlags2);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::ZoomStaticDataStruct::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(ZoomStaticDataStruct())) // not empty
	{
		_body.composeUINT32(id);
		_body.composeBYTE(game);
		_body.composeBYTE(structure);
		_body.composeBYTE(isHiLo);
		_body.composeBYTE(maxPlayersPerTable);
		_body.composeINT32(loBet);
		_body.composeINT32(hiBet);
		_body.composeINT32(ante);
		_body.composeINT32(cap);
		_body.composeString(currency);
		_body.composeINT32(minChipsLimit);
		_body.composeINT32(maxBuyIn);
		_body.composeUINT32(visibilityMask);
		_body.composeINT32(defaultBuyIn);
		_body.composeString(specialName);
		_body.composeBOOL(countryRestrictionInverted);
		restrictedCountries.composeMsg(_body);
		_body.composeBYTE(isPlayMoney);
		_body.composeBOOL(isMorphLobby);
		_body.composeUINT32(scalePM);
		_body.composeString(server);
		_body.composeString(name);
		_body.composeString(replayerInstance);
		_body.composeBYTE(isOneOnOne);
		_body.composeUINT32(tableFlags);
		_body.composeUINT16(chatLang);
		_body.composeBOOL(quickLobbyVisible);
		_body.composeUINT32(blitzFlags);
		_body.composeUINT32(brandMask);
		_body.composeString(serverObj);
		tableStakes.composeMsg(_body);
		visibilityMaskEx.composeMsg(_body);
		_body.composeUINT64(tableFlags2);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::ZoomStaticDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(id);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(structure);
	_parser0.parseBYTE(isHiLo);
	_parser0.parseBYTE(maxPlayersPerTable);
	_parser0.parseINT32(loBet);
	_parser0.parseINT32(hiBet);
	_parser0.parseINT32(ante);
	_parser0.parseINT32(cap);
	_parser0.parseStringP(currency);
	_parser0.parseINT32(minChipsLimit);
	_parser0.parseINT32(maxBuyIn);
	_parser0.parseUINT32(visibilityMask);
	_parser0.parseINT32(defaultBuyIn);
	_parser0.parseStringP(specialName);
	_parser0.parseBOOL(countryRestrictionInverted);
	restrictedCountries.parseMsg(_parser0);
	_parser0.parseBYTE(isPlayMoney);
	_parser0.parseBOOL(isMorphLobby);
	_parser0.parseUINT32(scalePM);
	_parser0.parseStringP(server);
	_parser0.parseStringP(name);
	_parser0.parseStringP(replayerInstance);
	_parser0.parseBYTE(isOneOnOne);
	_parser0.parseUINT32(tableFlags);
	_parser0.parseUINT16(chatLang);
	_parser0.parseBOOL(quickLobbyVisible);
	_parser0.parseUINT32(blitzFlags);
	_parser0.parseUINT32(brandMask);
	_parser0.parseStringP(serverObj);
	if(_parser0.parseEnded()) return;
	tableStakes.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	visibilityMaskEx.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT64(tableFlags2);
}

/*static*/ void MLobbyNG::cli::ZoomStaticDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 id; _parser0.parseUINT32(id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser0.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE maxPlayersPerTable; _parser0.parseBYTE(maxPlayersPerTable);
	AtfValidator::validateInt(_descr, "maxPlayersPerTable", maxPlayersPerTable, _checker, __FILE__, __LINE__);
	INT32 loBet; _parser0.parseINT32(loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	INT32 hiBet; _parser0.parseINT32(hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	INT32 ante; _parser0.parseINT32(ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	INT32 cap; _parser0.parseINT32(cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT32 minChipsLimit; _parser0.parseINT32(minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	INT32 maxBuyIn; _parser0.parseINT32(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	UINT32 visibilityMask; _parser0.parseUINT32(visibilityMask);
	AtfValidator::validateInt(_descr, "visibilityMask", visibilityMask, _checker, __FILE__, __LINE__);
	INT32 defaultBuyIn; _parser0.parseINT32(defaultBuyIn);
	AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "specialName"); size_t szSpecialName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "specialName", szSpecialName, _checker, __FILE__, __LINE__);
	bool countryRestrictionInverted; _parser0.parseBOOL(countryRestrictionInverted);
	AtfValidator::validateInt(_descr, "countryRestrictionInverted", countryRestrictionInverted, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szRestrictedCountries = ThinAtf::LAtfVector< PString, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("restrictedCountries"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "restrictedCountries", szRestrictedCountries, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser0.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	bool isMorphLobby; _parser0.parseBOOL(isMorphLobby);
	AtfValidator::validateInt(_descr, "isMorphLobby", isMorphLobby, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser0.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "replayerInstance"); size_t szReplayerInstance = strlen(_dummy);
	AtfValidator::validateInt(_descr, "replayerInstance", szReplayerInstance, _checker, __FILE__, __LINE__);
	BYTE isOneOnOne; _parser0.parseBYTE(isOneOnOne);
	AtfValidator::validateInt(_descr, "isOneOnOne", isOneOnOne, _checker, __FILE__, __LINE__);
	UINT32 tableFlags; _parser0.parseUINT32(tableFlags);
	AtfValidator::validateInt(_descr, "tableFlags", tableFlags, _checker, __FILE__, __LINE__);
	UINT16 chatLang; _parser0.parseUINT16(chatLang);
	AtfValidator::validateInt(_descr, "chatLang", chatLang, _checker, __FILE__, __LINE__);
	bool quickLobbyVisible; _parser0.parseBOOL(quickLobbyVisible);
	AtfValidator::validateInt(_descr, "quickLobbyVisible", quickLobbyVisible, _checker, __FILE__, __LINE__);
	UINT32 blitzFlags; _parser0.parseUINT32(blitzFlags);
	AtfValidator::validateInt(_descr, "blitzFlags", blitzFlags, _checker, __FILE__, __LINE__);
	UINT32 brandMask; _parser0.parseUINT32(brandMask);
	AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "serverObj"); size_t szServerObj = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObj", szServerObj, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	TableCommonThin::TableStakes::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tableStakes"), _fieldsWithUnparsedContent);
	if(_parser0.parseEnded()) return;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("visibilityMaskEx"), _fieldsWithUnparsedContent);
	if(_parser0.parseEnded()) return;
	UINT64 tableFlags2; _parser0.parseUINT64(tableFlags2);
	AtfValidator::validateUint(_descr, "tableFlags2", tableFlags2, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    EarlyBirdMultiplier
//=================================================================

MLobbyNG::cli::EarlyBirdMultiplier::EarlyBirdMultiplier()
{
	clear();
}

void MLobbyNG::cli::EarlyBirdMultiplier::clear()
{
	licenseId = 0;
	multiplier = 0;
}

bool MLobbyNG::cli::EarlyBirdMultiplier::equals(const EarlyBirdMultiplier& _o) const
{
	return licenseId == _o.licenseId &&
		multiplier == _o.multiplier;
}

const char *MLobbyNG::cli::EarlyBirdMultiplier::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("licenseId=");
	_buf.appendUint(licenseId);
	_buf.append(',');
	_buf.append("multiplier=");
	_buf.appendUint(multiplier);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::EarlyBirdMultiplier::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(EarlyBirdMultiplier())) // not empty
	{
		_body.composeUINT32(licenseId);
		_body.composeUINT32(multiplier);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::EarlyBirdMultiplier::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(licenseId);
	_parser0.parseUINT32(multiplier);
}

/*static*/ void MLobbyNG::cli::EarlyBirdMultiplier::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 licenseId; _parser0.parseUINT32(licenseId);
	AtfValidator::validateInt(_descr, "licenseId", licenseId, _checker, __FILE__, __LINE__);
	UINT32 multiplier; _parser0.parseUINT32(multiplier);
	AtfValidator::validateInt(_descr, "multiplier", multiplier, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ZoomDynaDataStruct
//=================================================================

MLobbyNG::cli::ZoomDynaDataStruct::ZoomDynaDataStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::ZoomDynaDataStruct::ZoomDynaDataStruct(ZoomDynaDataStruct&& _o)
	: handsPerHour(std::move(_o.handsPerHour))
	, avgPotSize(std::move(_o.avgPotSize))
	, avgStackSize(std::move(_o.avgStackSize))
	, numPlayers(std::move(_o.numPlayers))
	, publProp(std::move(_o.publProp))
	, avgPlayers(std::move(_o.avgPlayers))
	, avgVpip(std::move(_o.avgVpip))
	, earlyBirdMins(std::move(_o.earlyBirdMins))
	, earlyBirdMultipliers(std::move(_o.earlyBirdMultipliers))
	, licenseEarlyBirdMultiplier(std::move(_o.licenseEarlyBirdMultiplier))
{
}

MLobbyNG::cli::ZoomDynaDataStruct& MLobbyNG::cli::ZoomDynaDataStruct::operator=(ZoomDynaDataStruct&& _o)
{
	if(this != &_o)
	{
		handsPerHour = std::move(_o.handsPerHour);
		avgPotSize = std::move(_o.avgPotSize);
		avgStackSize = std::move(_o.avgStackSize);
		numPlayers = std::move(_o.numPlayers);
		publProp = std::move(_o.publProp);
		avgPlayers = std::move(_o.avgPlayers);
		avgVpip = std::move(_o.avgVpip);
		earlyBirdMins = std::move(_o.earlyBirdMins);
		earlyBirdMultipliers = std::move(_o.earlyBirdMultipliers);
		licenseEarlyBirdMultiplier = std::move(_o.licenseEarlyBirdMultiplier);
	}
	return *this;
}

#endif

void MLobbyNG::cli::ZoomDynaDataStruct::clear()
{
	handsPerHour = 0;
	avgPotSize = 0;
	avgStackSize = 0;
	numPlayers = 0;
	publProp = 0;
	avgPlayers = 0;
	avgVpip = 0;
	earlyBirdMins = 0;
	earlyBirdMultipliers.clear();
	licenseEarlyBirdMultiplier = 0;
}

bool MLobbyNG::cli::ZoomDynaDataStruct::equals(const ZoomDynaDataStruct& _o) const
{
	return handsPerHour == _o.handsPerHour &&
		avgPotSize == _o.avgPotSize &&
		avgStackSize == _o.avgStackSize &&
		numPlayers == _o.numPlayers &&
		publProp == _o.publProp &&
		avgPlayers == _o.avgPlayers &&
		avgVpip == _o.avgVpip &&
		earlyBirdMins == _o.earlyBirdMins &&
		earlyBirdMultipliers.equals(_o.earlyBirdMultipliers) &&
		licenseEarlyBirdMultiplier == _o.licenseEarlyBirdMultiplier;
}

const char *MLobbyNG::cli::ZoomDynaDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("handsPerHour=");
	_buf.appendInt(handsPerHour);
	_buf.append(',');
	_buf.append("avgPotSize=");
	_buf.appendInt(avgPotSize);
	_buf.append(',');
	_buf.append("avgStackSize=");
	_buf.appendInt(avgStackSize);
	_buf.append(',');
	_buf.append("numPlayers=");
	_buf.appendInt(numPlayers);
	_buf.append(',');
	_buf.append("publProp=");
	_buf.appendUint(publProp);
	_buf.append(',');
	_buf.append("avgPlayers=");
	_buf.appendUint(avgPlayers);
	_buf.append(',');
	_buf.append("avgVpip=");
	_buf.appendUint(avgVpip);
	_buf.append(',');
	_buf.append("earlyBirdMins=");
	_buf.appendInt(earlyBirdMins);
	_buf.append(',');
	_buf.append("earlyBirdMultipliers=");
	earlyBirdMultipliers.toTraceString(_buf);
	_buf.append(',');
	_buf.append("licenseEarlyBirdMultiplier=");
	_buf.appendUint(licenseEarlyBirdMultiplier);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::ZoomDynaDataStruct::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(ZoomDynaDataStruct())) // not empty
	{
		_body.composeINT32(handsPerHour);
		_body.composeINT32(avgPotSize);
		_body.composeINT32(avgStackSize);
		_body.composeINT32(numPlayers);
		_body.composeBYTE(publProp);
		_body.composeBYTE(avgPlayers);
		_body.composeBYTE(avgVpip);
		_body.composeINT32(earlyBirdMins);
		earlyBirdMultipliers.composeMsg(_body);
		_body.composeUINT32(licenseEarlyBirdMultiplier);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::ZoomDynaDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(handsPerHour);
	_parser0.parseINT32(avgPotSize);
	_parser0.parseINT32(avgStackSize);
	_parser0.parseINT32(numPlayers);
	_parser0.parseBYTE(publProp);
	_parser0.parseBYTE(avgPlayers);
	_parser0.parseBYTE(avgVpip);
	_parser0.parseINT32(earlyBirdMins);
	earlyBirdMultipliers.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT32(licenseEarlyBirdMultiplier);
}

/*static*/ void MLobbyNG::cli::ZoomDynaDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 handsPerHour; _parser0.parseINT32(handsPerHour);
	AtfValidator::validateInt(_descr, "handsPerHour", handsPerHour, _checker, __FILE__, __LINE__);
	INT32 avgPotSize; _parser0.parseINT32(avgPotSize);
	AtfValidator::validateInt(_descr, "avgPotSize", avgPotSize, _checker, __FILE__, __LINE__);
	INT32 avgStackSize; _parser0.parseINT32(avgStackSize);
	AtfValidator::validateInt(_descr, "avgStackSize", avgStackSize, _checker, __FILE__, __LINE__);
	INT32 numPlayers; _parser0.parseINT32(numPlayers);
	AtfValidator::validateInt(_descr, "numPlayers", numPlayers, _checker, __FILE__, __LINE__);
	BYTE publProp; _parser0.parseBYTE(publProp);
	AtfValidator::validateInt(_descr, "publProp", publProp, _checker, __FILE__, __LINE__);
	BYTE avgPlayers; _parser0.parseBYTE(avgPlayers);
	AtfValidator::validateInt(_descr, "avgPlayers", avgPlayers, _checker, __FILE__, __LINE__);
	BYTE avgVpip; _parser0.parseBYTE(avgVpip);
	AtfValidator::validateInt(_descr, "avgVpip", avgVpip, _checker, __FILE__, __LINE__);
	INT32 earlyBirdMins; _parser0.parseINT32(earlyBirdMins);
	AtfValidator::validateInt(_descr, "earlyBirdMins", earlyBirdMins, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szEarlyBirdMultipliers = ThinAtf::LAtfVector< EarlyBirdMultiplier, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("earlyBirdMultipliers"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "earlyBirdMultipliers", szEarlyBirdMultipliers, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	UINT32 licenseEarlyBirdMultiplier; _parser0.parseUINT32(licenseEarlyBirdMultiplier);
	AtfValidator::validateInt(_descr, "licenseEarlyBirdMultiplier", licenseEarlyBirdMultiplier, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ZoomDataStruct
//=================================================================

MLobbyNG::cli::ZoomDataStruct::ZoomDataStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::ZoomDataStruct::ZoomDataStruct(ZoomDataStruct&& _o)
	: staticData(std::move(_o.staticData))
	, dynamicData(std::move(_o.dynamicData))
	, lastEntry(std::move(_o.lastEntry))
{
}

MLobbyNG::cli::ZoomDataStruct& MLobbyNG::cli::ZoomDataStruct::operator=(ZoomDataStruct&& _o)
{
	if(this != &_o)
	{
		staticData = std::move(_o.staticData);
		dynamicData = std::move(_o.dynamicData);
		lastEntry = std::move(_o.lastEntry);
	}
	return *this;
}

#endif

void MLobbyNG::cli::ZoomDataStruct::clear()
{
	staticData.clear();
	dynamicData.clear();
	lastEntry.setNull();
}

bool MLobbyNG::cli::ZoomDataStruct::equals(const ZoomDataStruct& _o) const
{
	return staticData.equals(_o.staticData) &&
		dynamicData.equals(_o.dynamicData) &&
		lastEntry.equals(_o.lastEntry);
}

const char *MLobbyNG::cli::ZoomDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("staticData=");
	staticData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("dynamicData=");
	dynamicData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("lastEntry=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, lastEntry);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::ZoomDataStruct::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(ZoomDataStruct())) // not empty
	{
		staticData.composeMsg(_body);
		dynamicData.composeMsg(_body);
		_body.composeSrvTime(lastEntry);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::ZoomDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	staticData.parseMsg(_parser0);
	dynamicData.parseMsg(_parser0);
	_parser0.parseSrvTime(lastEntry);
}

/*static*/ void MLobbyNG::cli::ZoomDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	ZoomStaticDataStruct::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("staticData"), _fieldsWithUnparsedContent);
	ZoomDynaDataStruct::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("dynamicData"), _fieldsWithUnparsedContent);
	SrvTime lastEntry; _parser0.parseSrvTime(lastEntry);
	AtfValidator::validateSrvDateTime(_descr, "lastEntry", lastEntry, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SeatFinderStaticDataStruct
//=================================================================

MLobbyNG::cli::SeatFinderStaticDataStruct::SeatFinderStaticDataStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::SeatFinderStaticDataStruct::SeatFinderStaticDataStruct(SeatFinderStaticDataStruct&& _o)
	: id(std::move(_o.id))
	, game(std::move(_o.game))
	, structure(std::move(_o.structure))
	, isHiLo(std::move(_o.isHiLo))
	, maxPlayersPerTable(std::move(_o.maxPlayersPerTable))
	, loBet(std::move(_o.loBet))
	, hiBet(std::move(_o.hiBet))
	, ante(std::move(_o.ante))
	, cap(std::move(_o.cap))
	, currency(std::move(_o.currency))
	, minChipsLimit(std::move(_o.minChipsLimit))
	, maxBuyIn(std::move(_o.maxBuyIn))
	, visibilityMask(std::move(_o.visibilityMask))
	, defaultBuyIn(std::move(_o.defaultBuyIn))
	, specialName(std::move(_o.specialName))
	, countryRestrictionInverted(std::move(_o.countryRestrictionInverted))
	, restrictedCountries(std::move(_o.restrictedCountries))
	, replayerAddress(std::move(_o.replayerAddress))
	, replayerInstance(std::move(_o.replayerInstance))
	, minPlayersPerTable(std::move(_o.minPlayersPerTable))
	, isPasswordProtected(std::move(_o.isPasswordProtected))
	, poolBlockMinHands(std::move(_o.poolBlockMinHands))
	, poolBlockTimePenalty(std::move(_o.poolBlockTimePenalty))
	, flags(std::move(_o.flags))
	, flags2(std::move(_o.flags2))
	, isPM(std::move(_o.isPM))
	, scalePM(std::move(_o.scalePM))
	, tableStakes(std::move(_o.tableStakes))
	, variableAntes(std::move(_o.variableAntes))
	, visibilityMaskEx(std::move(_o.visibilityMaskEx))
{
}

MLobbyNG::cli::SeatFinderStaticDataStruct& MLobbyNG::cli::SeatFinderStaticDataStruct::operator=(SeatFinderStaticDataStruct&& _o)
{
	if(this != &_o)
	{
		id = std::move(_o.id);
		game = std::move(_o.game);
		structure = std::move(_o.structure);
		isHiLo = std::move(_o.isHiLo);
		maxPlayersPerTable = std::move(_o.maxPlayersPerTable);
		loBet = std::move(_o.loBet);
		hiBet = std::move(_o.hiBet);
		ante = std::move(_o.ante);
		cap = std::move(_o.cap);
		currency = std::move(_o.currency);
		minChipsLimit = std::move(_o.minChipsLimit);
		maxBuyIn = std::move(_o.maxBuyIn);
		visibilityMask = std::move(_o.visibilityMask);
		defaultBuyIn = std::move(_o.defaultBuyIn);
		specialName = std::move(_o.specialName);
		countryRestrictionInverted = std::move(_o.countryRestrictionInverted);
		restrictedCountries = std::move(_o.restrictedCountries);
		replayerAddress = std::move(_o.replayerAddress);
		replayerInstance = std::move(_o.replayerInstance);
		minPlayersPerTable = std::move(_o.minPlayersPerTable);
		isPasswordProtected = std::move(_o.isPasswordProtected);
		poolBlockMinHands = std::move(_o.poolBlockMinHands);
		poolBlockTimePenalty = std::move(_o.poolBlockTimePenalty);
		flags = std::move(_o.flags);
		flags2 = std::move(_o.flags2);
		isPM = std::move(_o.isPM);
		scalePM = std::move(_o.scalePM);
		tableStakes = std::move(_o.tableStakes);
		variableAntes = std::move(_o.variableAntes);
		visibilityMaskEx = std::move(_o.visibilityMaskEx);
	}
	return *this;
}

#endif

void MLobbyNG::cli::SeatFinderStaticDataStruct::clear()
{
	id = 0;
	game = 0;
	structure = 0;
	isHiLo = 0;
	maxPlayersPerTable = 0;
	loBet = 0;
	hiBet = 0;
	ante = 0;
	cap = 0;
	currency.clear();
	minChipsLimit = 0;
	maxBuyIn = 0;
	visibilityMask = 0;
	defaultBuyIn = 0;
	specialName.clear();
	countryRestrictionInverted = false;
	restrictedCountries.clear();
	replayerAddress.clear();
	replayerInstance.clear();
	minPlayersPerTable = 0;
	isPasswordProtected = false;
	poolBlockMinHands = 0;
	poolBlockTimePenalty.clear();
	flags = 0;
	flags2 = 0;
	isPM = false;
	scalePM = 0;
	tableStakes.clear();
	variableAntes.clear();
	visibilityMaskEx.clear();
}

bool MLobbyNG::cli::SeatFinderStaticDataStruct::equals(const SeatFinderStaticDataStruct& _o) const
{
	return id == _o.id &&
		game == _o.game &&
		structure == _o.structure &&
		isHiLo == _o.isHiLo &&
		maxPlayersPerTable == _o.maxPlayersPerTable &&
		loBet == _o.loBet &&
		hiBet == _o.hiBet &&
		ante == _o.ante &&
		cap == _o.cap &&
		currency.equals(_o.currency) &&
		minChipsLimit == _o.minChipsLimit &&
		maxBuyIn == _o.maxBuyIn &&
		visibilityMask == _o.visibilityMask &&
		defaultBuyIn == _o.defaultBuyIn &&
		specialName.equals(_o.specialName) &&
		countryRestrictionInverted == _o.countryRestrictionInverted &&
		restrictedCountries.equals(_o.restrictedCountries) &&
		replayerAddress.equals(_o.replayerAddress) &&
		replayerInstance.equals(_o.replayerInstance) &&
		minPlayersPerTable == _o.minPlayersPerTable &&
		isPasswordProtected == _o.isPasswordProtected &&
		poolBlockMinHands == _o.poolBlockMinHands &&
		poolBlockTimePenalty.equals(_o.poolBlockTimePenalty) &&
		flags == _o.flags &&
		flags2 == _o.flags2 &&
		isPM == _o.isPM &&
		scalePM == _o.scalePM &&
		tableStakes.equals(_o.tableStakes) &&
		variableAntes.equals(_o.variableAntes) &&
		visibilityMaskEx.equals(_o.visibilityMaskEx);
}

const char *MLobbyNG::cli::SeatFinderStaticDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("id=");
	_buf.appendUint(id);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("maxPlayersPerTable=");
	_buf.appendUint(maxPlayersPerTable);
	_buf.append(',');
	_buf.append("loBet=");
	_buf.appendInt(loBet);
	_buf.append(',');
	_buf.append("hiBet=");
	_buf.appendInt(hiBet);
	_buf.append(',');
	_buf.append("ante=");
	_buf.appendInt(ante);
	_buf.append(',');
	_buf.append("cap=");
	_buf.appendInt(cap);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("minChipsLimit=");
	_buf.appendInt(minChipsLimit);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendInt(maxBuyIn);
	_buf.append(',');
	_buf.append("visibilityMask=");
	_buf.appendUint(visibilityMask);
	_buf.append(',');
	_buf.append("defaultBuyIn=");
	_buf.appendInt(defaultBuyIn);
	_buf.append(',');
	_buf.append("specialName=");
	_buf.append(specialName);
	_buf.append(',');
	_buf.append("countryRestrictionInverted=");
	_buf.appendUint(countryRestrictionInverted);
	_buf.append(',');
	_buf.append("restrictedCountries=");
	restrictedCountries.toTraceString(_buf);
	_buf.append(',');
	_buf.append("replayerAddress=");
	_buf.append(replayerAddress);
	_buf.append(',');
	_buf.append("replayerInstance=");
	_buf.append(replayerInstance);
	_buf.append(',');
	_buf.append("minPlayersPerTable=");
	_buf.appendInt(minPlayersPerTable);
	_buf.append(',');
	_buf.append("isPasswordProtected=");
	_buf.appendUint(isPasswordProtected);
	_buf.append(',');
	_buf.append("poolBlockMinHands=");
	_buf.appendInt(poolBlockMinHands);
	_buf.append(',');
	_buf.append("poolBlockTimePenalty=");
	poolBlockTimePenalty.toTraceString(_buf);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("flags2=");
	_buf.appendUint64(flags2);
	_buf.append(',');
	_buf.append("isPM=");
	_buf.appendUint(isPM);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("tableStakes=");
	tableStakes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("variableAntes=");
	variableAntes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("visibilityMaskEx=");
	visibilityMaskEx.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::SeatFinderStaticDataStruct::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(SeatFinderStaticDataStruct())) // not empty
	{
		_body.composeUINT32(id);
		_body.composeBYTE(game);
		_body.composeBYTE(structure);
		_body.composeBYTE(isHiLo);
		_body.composeBYTE(maxPlayersPerTable);
		_body.composeINT32(loBet);
		_body.composeINT32(hiBet);
		_body.composeINT32(ante);
		_body.composeINT32(cap);
		_body.composeString(currency);
		_body.composeINT32(minChipsLimit);
		_body.composeINT32(maxBuyIn);
		_body.composeUINT32(visibilityMask);
		_body.composeINT32(defaultBuyIn);
		_body.composeString(specialName);
		_body.composeBOOL(countryRestrictionInverted);
		restrictedCountries.composeMsg(_body);
		_body.composeString(replayerAddress);
		_body.composeString(replayerInstance);
		_body.composeINT8(minPlayersPerTable);
		_body.composeBOOL(isPasswordProtected);
		_body.composeINT32(poolBlockMinHands);
		poolBlockTimePenalty.composeMsg(_body);
		_body.composeUINT32(flags);
		_body.composeUINT64(flags2);
		_body.composeBOOL(isPM);
		_body.composeUINT32(scalePM);
		tableStakes.composeMsg(_body);
		variableAntes.composeMsg(_body);
		visibilityMaskEx.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::SeatFinderStaticDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(id);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(structure);
	_parser0.parseBYTE(isHiLo);
	_parser0.parseBYTE(maxPlayersPerTable);
	_parser0.parseINT32(loBet);
	_parser0.parseINT32(hiBet);
	_parser0.parseINT32(ante);
	_parser0.parseINT32(cap);
	_parser0.parseStringP(currency);
	_parser0.parseINT32(minChipsLimit);
	_parser0.parseINT32(maxBuyIn);
	_parser0.parseUINT32(visibilityMask);
	_parser0.parseINT32(defaultBuyIn);
	_parser0.parseStringP(specialName);
	_parser0.parseBOOL(countryRestrictionInverted);
	restrictedCountries.parseMsg(_parser0);
	_parser0.parseStringP(replayerAddress);
	_parser0.parseStringP(replayerInstance);
	_parser0.parseINT8(minPlayersPerTable);
	_parser0.parseBOOL(isPasswordProtected);
	_parser0.parseINT32(poolBlockMinHands);
	poolBlockTimePenalty.parseMsg(_parser0);
	_parser0.parseUINT32(flags);
	_parser0.parseUINT64(flags2);
	_parser0.parseBOOL(isPM);
	_parser0.parseUINT32(scalePM);
	if(_parser0.parseEnded()) return;
	tableStakes.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	variableAntes.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	visibilityMaskEx.parseMsg(_parser0);
}

/*static*/ void MLobbyNG::cli::SeatFinderStaticDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 id; _parser0.parseUINT32(id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser0.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE maxPlayersPerTable; _parser0.parseBYTE(maxPlayersPerTable);
	AtfValidator::validateInt(_descr, "maxPlayersPerTable", maxPlayersPerTable, _checker, __FILE__, __LINE__);
	INT32 loBet; _parser0.parseINT32(loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	INT32 hiBet; _parser0.parseINT32(hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	INT32 ante; _parser0.parseINT32(ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	INT32 cap; _parser0.parseINT32(cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT32 minChipsLimit; _parser0.parseINT32(minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	INT32 maxBuyIn; _parser0.parseINT32(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	UINT32 visibilityMask; _parser0.parseUINT32(visibilityMask);
	AtfValidator::validateInt(_descr, "visibilityMask", visibilityMask, _checker, __FILE__, __LINE__);
	INT32 defaultBuyIn; _parser0.parseINT32(defaultBuyIn);
	AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "specialName"); size_t szSpecialName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "specialName", szSpecialName, _checker, __FILE__, __LINE__);
	bool countryRestrictionInverted; _parser0.parseBOOL(countryRestrictionInverted);
	AtfValidator::validateInt(_descr, "countryRestrictionInverted", countryRestrictionInverted, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szRestrictedCountries = ThinAtf::LAtfVector< PString, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("restrictedCountries"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "restrictedCountries", szRestrictedCountries, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "replayerAddress"); size_t szReplayerAddress = strlen(_dummy);
	AtfValidator::validateInt(_descr, "replayerAddress", szReplayerAddress, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "replayerInstance"); size_t szReplayerInstance = strlen(_dummy);
	AtfValidator::validateInt(_descr, "replayerInstance", szReplayerInstance, _checker, __FILE__, __LINE__);
	INT8 minPlayersPerTable; _parser0.parseINT8(minPlayersPerTable);
	AtfValidator::validateInt(_descr, "minPlayersPerTable", minPlayersPerTable, _checker, __FILE__, __LINE__);
	bool isPasswordProtected; _parser0.parseBOOL(isPasswordProtected);
	AtfValidator::validateInt(_descr, "isPasswordProtected", isPasswordProtected, _checker, __FILE__, __LINE__);
	INT32 poolBlockMinHands; _parser0.parseINT32(poolBlockMinHands);
	AtfValidator::validateInt(_descr, "poolBlockMinHands", poolBlockMinHands, _checker, __FILE__, __LINE__);
	int szPoolBlockTimePenalty = ThinAtf::LAtfVector< INT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("poolBlockTimePenalty"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "poolBlockTimePenalty", szPoolBlockTimePenalty, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser0.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT64 flags2; _parser0.parseUINT64(flags2);
	AtfValidator::validateUint(_descr, "flags2", flags2, _checker, __FILE__, __LINE__);
	bool isPM; _parser0.parseBOOL(isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser0.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	TableCommonThin::TableStakes::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tableStakes"), _fieldsWithUnparsedContent);
	if(_parser0.parseEnded()) return;
	int szVariableAntes = ThinAtf::LAtfVector< INT64, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("variableAntes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "variableAntes", szVariableAntes, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("visibilityMaskEx"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SeatFinderDynaDataStruct
//=================================================================

MLobbyNG::cli::SeatFinderDynaDataStruct::SeatFinderDynaDataStruct()
{
	clear();
}

void MLobbyNG::cli::SeatFinderDynaDataStruct::clear()
{
	handsPerHour = 0;
	avgPotSize = 0;
	avgStackSize = 0;
	numPlayers = 0;
	numTables = 0;
	numFullTables = 0;
}

bool MLobbyNG::cli::SeatFinderDynaDataStruct::equals(const SeatFinderDynaDataStruct& _o) const
{
	return handsPerHour == _o.handsPerHour &&
		avgPotSize == _o.avgPotSize &&
		avgStackSize == _o.avgStackSize &&
		numPlayers == _o.numPlayers &&
		numTables == _o.numTables &&
		numFullTables == _o.numFullTables;
}

const char *MLobbyNG::cli::SeatFinderDynaDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("handsPerHour=");
	_buf.appendInt(handsPerHour);
	_buf.append(',');
	_buf.append("avgPotSize=");
	_buf.appendInt(avgPotSize);
	_buf.append(',');
	_buf.append("avgStackSize=");
	_buf.appendInt(avgStackSize);
	_buf.append(',');
	_buf.append("numPlayers=");
	_buf.appendInt(numPlayers);
	_buf.append(',');
	_buf.append("numTables=");
	_buf.appendInt(numTables);
	_buf.append(',');
	_buf.append("numFullTables=");
	_buf.appendInt(numFullTables);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::SeatFinderDynaDataStruct::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(SeatFinderDynaDataStruct())) // not empty
	{
		_body.composeINT32(handsPerHour);
		_body.composeINT32(avgPotSize);
		_body.composeINT32(avgStackSize);
		_body.composeINT32(numPlayers);
		_body.composeINT32(numTables);
		_body.composeINT32(numFullTables);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::SeatFinderDynaDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(handsPerHour);
	_parser0.parseINT32(avgPotSize);
	_parser0.parseINT32(avgStackSize);
	_parser0.parseINT32(numPlayers);
	_parser0.parseINT32(numTables);
	_parser0.parseINT32(numFullTables);
}

/*static*/ void MLobbyNG::cli::SeatFinderDynaDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 handsPerHour; _parser0.parseINT32(handsPerHour);
	AtfValidator::validateInt(_descr, "handsPerHour", handsPerHour, _checker, __FILE__, __LINE__);
	INT32 avgPotSize; _parser0.parseINT32(avgPotSize);
	AtfValidator::validateInt(_descr, "avgPotSize", avgPotSize, _checker, __FILE__, __LINE__);
	INT32 avgStackSize; _parser0.parseINT32(avgStackSize);
	AtfValidator::validateInt(_descr, "avgStackSize", avgStackSize, _checker, __FILE__, __LINE__);
	INT32 numPlayers; _parser0.parseINT32(numPlayers);
	AtfValidator::validateInt(_descr, "numPlayers", numPlayers, _checker, __FILE__, __LINE__);
	INT32 numTables; _parser0.parseINT32(numTables);
	AtfValidator::validateInt(_descr, "numTables", numTables, _checker, __FILE__, __LINE__);
	INT32 numFullTables; _parser0.parseINT32(numFullTables);
	AtfValidator::validateInt(_descr, "numFullTables", numFullTables, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SeatFinderDataStruct
//=================================================================

MLobbyNG::cli::SeatFinderDataStruct::SeatFinderDataStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::SeatFinderDataStruct::SeatFinderDataStruct(SeatFinderDataStruct&& _o)
	: staticData(std::move(_o.staticData))
	, dynamicData(std::move(_o.dynamicData))
	, lastEntry(std::move(_o.lastEntry))
{
}

MLobbyNG::cli::SeatFinderDataStruct& MLobbyNG::cli::SeatFinderDataStruct::operator=(SeatFinderDataStruct&& _o)
{
	if(this != &_o)
	{
		staticData = std::move(_o.staticData);
		dynamicData = std::move(_o.dynamicData);
		lastEntry = std::move(_o.lastEntry);
	}
	return *this;
}

#endif

void MLobbyNG::cli::SeatFinderDataStruct::clear()
{
	staticData.clear();
	dynamicData.clear();
	lastEntry.setNull();
}

bool MLobbyNG::cli::SeatFinderDataStruct::equals(const SeatFinderDataStruct& _o) const
{
	return staticData.equals(_o.staticData) &&
		dynamicData.equals(_o.dynamicData) &&
		lastEntry.equals(_o.lastEntry);
}

const char *MLobbyNG::cli::SeatFinderDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("staticData=");
	staticData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("dynamicData=");
	dynamicData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("lastEntry=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, lastEntry);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::SeatFinderDataStruct::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(SeatFinderDataStruct())) // not empty
	{
		staticData.composeMsg(_body);
		dynamicData.composeMsg(_body);
		_body.composeSrvTime(lastEntry);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::SeatFinderDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	staticData.parseMsg(_parser0);
	dynamicData.parseMsg(_parser0);
	_parser0.parseSrvTime(lastEntry);
}

/*static*/ void MLobbyNG::cli::SeatFinderDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	SeatFinderStaticDataStruct::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("staticData"), _fieldsWithUnparsedContent);
	SeatFinderDynaDataStruct::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("dynamicData"), _fieldsWithUnparsedContent);
	SrvTime lastEntry; _parser0.parseSrvTime(lastEntry);
	AtfValidator::validateSrvDateTime(_descr, "lastEntry", lastEntry, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SngSelectionFilter
//=================================================================

MLobbyNG::cli::SngSelectionFilter::SngSelectionFilter()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::SngSelectionFilter::SngSelectionFilter(SngSelectionFilter&& _o)
	: locale(std::move(_o.locale))
	, gameMask(std::move(_o.gameMask))
	, buyInMask(std::move(_o.buyInMask))
	, minBuyIn(std::move(_o.minBuyIn))
	, maxBuyIn(std::move(_o.maxBuyIn))
	, speedMask(std::move(_o.speedMask))
	, currencyMask(std::move(_o.currencyMask))
	, tableSizeMask(std::move(_o.tableSizeMask))
	, tournVariantMask(std::move(_o.tournVariantMask))
	, country(std::move(_o.country))
	, isPM(std::move(_o.isPM))
	, tableNumMask(std::move(_o.tableNumMask))
	, gameCategoryMask(std::move(_o.gameCategoryMask))
	, tournGroups(std::move(_o.tournGroups))
	, tournStateMask(std::move(_o.tournStateMask))
	, negateTournVariantMask(std::move(_o.negateTournVariantMask))
	, numPlayers(std::move(_o.numPlayers))
{
}

MLobbyNG::cli::SngSelectionFilter& MLobbyNG::cli::SngSelectionFilter::operator=(SngSelectionFilter&& _o)
{
	if(this != &_o)
	{
		locale = std::move(_o.locale);
		gameMask = std::move(_o.gameMask);
		buyInMask = std::move(_o.buyInMask);
		minBuyIn = std::move(_o.minBuyIn);
		maxBuyIn = std::move(_o.maxBuyIn);
		speedMask = std::move(_o.speedMask);
		currencyMask = std::move(_o.currencyMask);
		tableSizeMask = std::move(_o.tableSizeMask);
		tournVariantMask = std::move(_o.tournVariantMask);
		country = std::move(_o.country);
		isPM = std::move(_o.isPM);
		tableNumMask = std::move(_o.tableNumMask);
		gameCategoryMask = std::move(_o.gameCategoryMask);
		tournGroups = std::move(_o.tournGroups);
		tournStateMask = std::move(_o.tournStateMask);
		negateTournVariantMask = std::move(_o.negateTournVariantMask);
		numPlayers = std::move(_o.numPlayers);
	}
	return *this;
}

#endif

void MLobbyNG::cli::SngSelectionFilter::clear()
{
	locale = 0;
	gameMask = 0;
	buyInMask = 0;
	minBuyIn = 0;
	maxBuyIn = 0;
	speedMask = 0;
	currencyMask = 0;
	tableSizeMask = 0;
	tournVariantMask = 0;
	country.clear();
	isPM = false;
	tableNumMask = 0;
	gameCategoryMask = 0;
	tournGroups.clear();
	tournStateMask = 0;
	negateTournVariantMask = 0;
	numPlayers = 0;
}

bool MLobbyNG::cli::SngSelectionFilter::equals(const SngSelectionFilter& _o) const
{
	return locale == _o.locale &&
		gameMask == _o.gameMask &&
		buyInMask == _o.buyInMask &&
		minBuyIn == _o.minBuyIn &&
		maxBuyIn == _o.maxBuyIn &&
		speedMask == _o.speedMask &&
		currencyMask == _o.currencyMask &&
		tableSizeMask == _o.tableSizeMask &&
		tournVariantMask == _o.tournVariantMask &&
		country.equals(_o.country) &&
		isPM == _o.isPM &&
		tableNumMask == _o.tableNumMask &&
		gameCategoryMask == _o.gameCategoryMask &&
		tournGroups.equals(_o.tournGroups) &&
		tournStateMask == _o.tournStateMask &&
		negateTournVariantMask == _o.negateTournVariantMask &&
		numPlayers == _o.numPlayers;
}

const char *MLobbyNG::cli::SngSelectionFilter::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("gameMask=");
	_buf.appendUint64(gameMask);
	_buf.append(',');
	_buf.append("buyInMask=");
	_buf.appendUint(buyInMask);
	_buf.append(',');
	_buf.append("minBuyIn=");
	_buf.appendInt64(minBuyIn);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendInt64(maxBuyIn);
	_buf.append(',');
	_buf.append("speedMask=");
	_buf.appendUint(speedMask);
	_buf.append(',');
	_buf.append("currencyMask=");
	_buf.appendUint(currencyMask);
	_buf.append(',');
	_buf.append("tableSizeMask=");
	_buf.appendUint(tableSizeMask);
	_buf.append(',');
	_buf.append("tournVariantMask=");
	_buf.appendUint(tournVariantMask);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("isPM=");
	_buf.appendUint(isPM);
	_buf.append(',');
	_buf.append("tableNumMask=");
	_buf.appendUint(tableNumMask);
	_buf.append(',');
	_buf.append("gameCategoryMask=");
	_buf.appendUint(gameCategoryMask);
	_buf.append(',');
	_buf.append("tournGroups=");
	tournGroups.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tournStateMask=");
	_buf.appendUint(tournStateMask);
	_buf.append(',');
	_buf.append("negateTournVariantMask=");
	_buf.appendUint(negateTournVariantMask);
	_buf.append(',');
	_buf.append("numPlayers=");
	_buf.appendInt(numPlayers);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::SngSelectionFilter::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(SngSelectionFilter())) // not empty
	{
		_body.composeUINT32(locale);
		_body.composeUINT64(gameMask);
		_body.composeUINT32(buyInMask);
		_body.composeINT64(minBuyIn);
		_body.composeINT64(maxBuyIn);
		_body.composeUINT32(speedMask);
		_body.composeUINT32(currencyMask);
		_body.composeUINT32(tableSizeMask);
		_body.composeUINT32(tournVariantMask);
		_body.composeString(country);
		_body.composeBOOL(isPM);
		_body.composeUINT32(tableNumMask);
		_body.composeUINT32(gameCategoryMask);
		tournGroups.composeMsg(_body);
		_body.composeUINT32(tournStateMask);
		_body.composeUINT32(negateTournVariantMask);
		_body.composeINT32(numPlayers);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::SngSelectionFilter::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(locale);
	_parser0.parseUINT64(gameMask);
	_parser0.parseUINT32(buyInMask);
	_parser0.parseINT64(minBuyIn);
	_parser0.parseINT64(maxBuyIn);
	_parser0.parseUINT32(speedMask);
	_parser0.parseUINT32(currencyMask);
	_parser0.parseUINT32(tableSizeMask);
	_parser0.parseUINT32(tournVariantMask);
	_parser0.parseStringP(country);
	_parser0.parseBOOL(isPM);
	_parser0.parseUINT32(tableNumMask);
	_parser0.parseUINT32(gameCategoryMask);
	tournGroups.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT32(tournStateMask);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT32(negateTournVariantMask);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT32(numPlayers);
}

/*static*/ void MLobbyNG::cli::SngSelectionFilter::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 locale; _parser0.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT64 gameMask; _parser0.parseUINT64(gameMask);
	AtfValidator::validateUintMax(_descr, "gameMask", gameMask, (2*(UINT64)NGGameTypes::NGGame_Last-1), _checker, __FILE__, __LINE__);
	UINT32 buyInMask; _parser0.parseUINT32(buyInMask);
	AtfValidator::validateIntMax(_descr, "buyInMask", buyInMask, (2*NGBuyIn_Last-1), _checker, __FILE__, __LINE__);
	INT64 minBuyIn; _parser0.parseINT64(minBuyIn);
	AtfValidator::validateInt(_descr, "minBuyIn", minBuyIn, _checker, __FILE__, __LINE__);
	INT64 maxBuyIn; _parser0.parseINT64(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	UINT32 speedMask; _parser0.parseUINT32(speedMask);
	AtfValidator::validateIntMax(_descr, "speedMask", speedMask, (2*NGTournSpeed_Last-1), _checker, __FILE__, __LINE__);
	UINT32 currencyMask; _parser0.parseUINT32(currencyMask);
	AtfValidator::validateIntMax(_descr, "currencyMask", currencyMask, (2*NGCurrency_Last-1), _checker, __FILE__, __LINE__);
	UINT32 tableSizeMask; _parser0.parseUINT32(tableSizeMask);
	AtfValidator::validateIntMax(_descr, "tableSizeMask", tableSizeMask, (2*NGMaxTableSize_Last-1), _checker, __FILE__, __LINE__);
	UINT32 tournVariantMask; _parser0.parseUINT32(tournVariantMask);
	AtfValidator::validateIntMax(_descr, "tournVariantMask", tournVariantMask, (2*NGTournVariant_Last-1), _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, 3, _checker, __FILE__, __LINE__);
	bool isPM; _parser0.parseBOOL(isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
	UINT32 tableNumMask; _parser0.parseUINT32(tableNumMask);
	AtfValidator::validateIntMax(_descr, "tableNumMask", tableNumMask, (2*NGTableNum_Last-1), _checker, __FILE__, __LINE__);
	UINT32 gameCategoryMask; _parser0.parseUINT32(gameCategoryMask);
	AtfValidator::validateIntMax(_descr, "gameCategoryMask", gameCategoryMask, (2*GameCategory_Last-1), _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTournGroups = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tournGroups"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "tournGroups", szTournGroups, TournGroup_Last, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	UINT32 tournStateMask; _parser0.parseUINT32(tournStateMask);
	AtfValidator::validateIntMax(_descr, "tournStateMask", tournStateMask, (2*NGTournState_Last-1), _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	UINT32 negateTournVariantMask; _parser0.parseUINT32(negateTournVariantMask);
	AtfValidator::validateIntMax(_descr, "negateTournVariantMask", negateTournVariantMask, (2*NGTournVariant_Last-1), _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT32 numPlayers; _parser0.parseINT32(numPlayers);
	AtfValidator::validateIntRange(_descr, "numPlayers", numPlayers, 0, 10000000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    WinnerAmountData
//=================================================================

MLobbyNG::cli::WinnerAmountData::WinnerAmountData()
{
	clear();
}

void MLobbyNG::cli::WinnerAmountData::clear()
{
	amount = 0;
	flags = 0;
}

bool MLobbyNG::cli::WinnerAmountData::equals(const WinnerAmountData& _o) const
{
	return amount == _o.amount &&
		flags == _o.flags;
}

const char *MLobbyNG::cli::WinnerAmountData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("amount=");
	_buf.appendInt(amount);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::WinnerAmountData::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(WinnerAmountData())) // not empty
	{
		_body.composeINT32(amount);
		_body.composeBYTE(flags);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::WinnerAmountData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(amount);
	_parser0.parseBYTE(flags);
}

/*static*/ void MLobbyNG::cli::WinnerAmountData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 amount; _parser0.parseINT32(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	BYTE flags; _parser0.parseBYTE(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PrizeData
//=================================================================

MLobbyNG::cli::PrizeData::PrizeData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::PrizeData::PrizeData(PrizeData&& _o)
	: min(std::move(_o.min))
	, max(std::move(_o.max))
	, numTickets(std::move(_o.numTickets))
	, winners(std::move(_o.winners))
{
}

MLobbyNG::cli::PrizeData& MLobbyNG::cli::PrizeData::operator=(PrizeData&& _o)
{
	if(this != &_o)
	{
		min = std::move(_o.min);
		max = std::move(_o.max);
		numTickets = std::move(_o.numTickets);
		winners = std::move(_o.winners);
	}
	return *this;
}

#endif

void MLobbyNG::cli::PrizeData::clear()
{
	min = 0;
	max = 0;
	numTickets = 0;
	winners.clear();
}

bool MLobbyNG::cli::PrizeData::equals(const PrizeData& _o) const
{
	return min == _o.min &&
		max == _o.max &&
		numTickets == _o.numTickets &&
		winners.equals(_o.winners);
}

const char *MLobbyNG::cli::PrizeData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("min=");
	_buf.appendInt(min);
	_buf.append(',');
	_buf.append("max=");
	_buf.appendInt(max);
	_buf.append(',');
	_buf.append("numTickets=");
	_buf.appendInt(numTickets);
	_buf.append(',');
	_buf.append("winners=");
	winners.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::PrizeData::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(PrizeData())) // not empty
	{
		_body.composeINT32(min);
		_body.composeINT32(max);
		_body.composeINT32(numTickets);
		winners.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::PrizeData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(min);
	_parser0.parseINT32(max);
	_parser0.parseINT32(numTickets);
	winners.parseMsg(_parser0);
}

/*static*/ void MLobbyNG::cli::PrizeData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 min; _parser0.parseINT32(min);
	AtfValidator::validateInt(_descr, "min", min, _checker, __FILE__, __LINE__);
	INT32 max; _parser0.parseINT32(max);
	AtfValidator::validateInt(_descr, "max", max, _checker, __FILE__, __LINE__);
	INT32 numTickets; _parser0.parseINT32(numTickets);
	AtfValidator::validateInt(_descr, "numTickets", numTickets, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szWinners = ThinAtf::LAtfVector< WinnerAmountData, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("winners"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "winners", szWinners, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TicketData
//=================================================================

MLobbyNG::cli::TicketData::TicketData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::TicketData::TicketData(TicketData&& _o)
	: ticketId(std::move(_o.ticketId))
	, admission(std::move(_o.admission))
{
}

MLobbyNG::cli::TicketData& MLobbyNG::cli::TicketData::operator=(TicketData&& _o)
{
	if(this != &_o)
	{
		ticketId = std::move(_o.ticketId);
		admission = std::move(_o.admission);
	}
	return *this;
}

#endif

void MLobbyNG::cli::TicketData::clear()
{
	ticketId = 0;
	admission.clear();
}

bool MLobbyNG::cli::TicketData::equals(const TicketData& _o) const
{
	return ticketId == _o.ticketId &&
		admission.equals(_o.admission);
}

const char *MLobbyNG::cli::TicketData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("ticketId=");
	_buf.appendUint(ticketId);
	_buf.append(',');
	_buf.append("admission=");
	_buf.append(admission);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::TicketData::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(TicketData())) // not empty
	{
		_body.composeUINT16(ticketId);
		_body.composeString(admission);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::TicketData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT16(ticketId);
	_parser0.parseStringP(admission);
}

/*static*/ void MLobbyNG::cli::TicketData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT16 ticketId; _parser0.parseUINT16(ticketId);
	AtfValidator::validateInt(_descr, "ticketId", ticketId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "admission"); size_t szAdmission = strlen(_dummy);
	AtfValidator::validateInt(_descr, "admission", szAdmission, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SngDataStruct
//=================================================================

MLobbyNG::cli::SngDataStruct::SngDataStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::SngDataStruct::SngDataStruct(SngDataStruct&& _o)
	: id(std::move(_o.id))
	, tournSites(std::move(_o.tournSites))
	, visible(std::move(_o.visible))
	, game(std::move(_o.game))
	, structure(std::move(_o.structure))
	, isHiLo(std::move(_o.isHiLo))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, currency(std::move(_o.currency))
	, buyIn(std::move(_o.buyIn))
	, rake(std::move(_o.rake))
	, knockout(std::move(_o.knockout))
	, speedDisplay(std::move(_o.speedDisplay))
	, minPlayers(std::move(_o.minPlayers))
	, countryRestrictionInverted(std::move(_o.countryRestrictionInverted))
	, restrictedCountries(std::move(_o.restrictedCountries))
	, scalePM(std::move(_o.scalePM))
	, brandAccessMask(std::move(_o.brandAccessMask))
	, timedTournType(std::move(_o.timedTournType))
	, timedTournTime(std::move(_o.timedTournTime))
	, visibilityCriteria(std::move(_o.visibilityCriteria))
	, maxPerTable(std::move(_o.maxPerTable))
	, timedTournPlayersPercent(std::move(_o.timedTournPlayersPercent))
	, tournFlags(std::move(_o.tournFlags))
	, tournFlags2(std::move(_o.tournFlags2))
	, satelliteTarget(std::move(_o.satelliteTarget))
	, satelliteTargetReference(std::move(_o.satelliteTargetReference))
	, tournFlagsServInt(std::move(_o.tournFlagsServInt))
	, regTournId(std::move(_o.regTournId))
	, mobileName(std::move(_o.mobileName))
	, tournGroup(std::move(_o.tournGroup))
	, maxPlayers(std::move(_o.maxPlayers))
	, lastEntry(std::move(_o.lastEntry))
	, admissions(std::move(_o.admissions))
	, fppBuyIn(std::move(_o.fppBuyIn))
	, prizes(std::move(_o.prizes))
	, tickets(std::move(_o.tickets))
	, awardScheme(std::move(_o.awardScheme))
	, tournGroupName(std::move(_o.tournGroupName))
	, tournGroupRef(std::move(_o.tournGroupRef))
	, tournSitesEx(std::move(_o.tournSitesEx))
	, userHasTicket(std::move(_o.userHasTicket))
{
}

MLobbyNG::cli::SngDataStruct& MLobbyNG::cli::SngDataStruct::operator=(SngDataStruct&& _o)
{
	if(this != &_o)
	{
		id = std::move(_o.id);
		tournSites = std::move(_o.tournSites);
		visible = std::move(_o.visible);
		game = std::move(_o.game);
		structure = std::move(_o.structure);
		isHiLo = std::move(_o.isHiLo);
		isPlayMoney = std::move(_o.isPlayMoney);
		currency = std::move(_o.currency);
		buyIn = std::move(_o.buyIn);
		rake = std::move(_o.rake);
		knockout = std::move(_o.knockout);
		speedDisplay = std::move(_o.speedDisplay);
		minPlayers = std::move(_o.minPlayers);
		countryRestrictionInverted = std::move(_o.countryRestrictionInverted);
		restrictedCountries = std::move(_o.restrictedCountries);
		scalePM = std::move(_o.scalePM);
		brandAccessMask = std::move(_o.brandAccessMask);
		timedTournType = std::move(_o.timedTournType);
		timedTournTime = std::move(_o.timedTournTime);
		visibilityCriteria = std::move(_o.visibilityCriteria);
		maxPerTable = std::move(_o.maxPerTable);
		timedTournPlayersPercent = std::move(_o.timedTournPlayersPercent);
		tournFlags = std::move(_o.tournFlags);
		tournFlags2 = std::move(_o.tournFlags2);
		satelliteTarget = std::move(_o.satelliteTarget);
		satelliteTargetReference = std::move(_o.satelliteTargetReference);
		tournFlagsServInt = std::move(_o.tournFlagsServInt);
		regTournId = std::move(_o.regTournId);
		mobileName = std::move(_o.mobileName);
		tournGroup = std::move(_o.tournGroup);
		maxPlayers = std::move(_o.maxPlayers);
		lastEntry = std::move(_o.lastEntry);
		admissions = std::move(_o.admissions);
		fppBuyIn = std::move(_o.fppBuyIn);
		prizes = std::move(_o.prizes);
		tickets = std::move(_o.tickets);
		awardScheme = std::move(_o.awardScheme);
		tournGroupName = std::move(_o.tournGroupName);
		tournGroupRef = std::move(_o.tournGroupRef);
		tournSitesEx = std::move(_o.tournSitesEx);
		userHasTicket = std::move(_o.userHasTicket);
	}
	return *this;
}

#endif

void MLobbyNG::cli::SngDataStruct::clear()
{
	id = 0;
	tournSites = 0;
	visible = false;
	game = 0;
	structure = 0;
	isHiLo = 0;
	isPlayMoney = 0;
	currency.clear();
	buyIn = 0;
	rake = 0;
	knockout = 0;
	speedDisplay = 0;
	minPlayers = 0;
	countryRestrictionInverted = false;
	restrictedCountries.clear();
	scalePM = 0;
	brandAccessMask = 0;
	timedTournType = 0;
	timedTournTime = 0;
	visibilityCriteria.clear();
	maxPerTable = 0;
	timedTournPlayersPercent = 0;
	tournFlags = 0;
	tournFlags2 = 0;
	satelliteTarget = 0;
	satelliteTargetReference.clear();
	tournFlagsServInt = 0;
	regTournId = 0;
	mobileName.clear();
	tournGroup = 0;
	maxPlayers = 0;
	lastEntry.setNull();
	admissions.clear();
	fppBuyIn = 0;
	prizes.clear();
	tickets.clear();
	awardScheme = 0;
	tournGroupName.clear();
	tournGroupRef.clear();
	tournSitesEx.clear();
	userHasTicket = false;
}

bool MLobbyNG::cli::SngDataStruct::equals(const SngDataStruct& _o) const
{
	return id == _o.id &&
		tournSites == _o.tournSites &&
		visible == _o.visible &&
		game == _o.game &&
		structure == _o.structure &&
		isHiLo == _o.isHiLo &&
		isPlayMoney == _o.isPlayMoney &&
		currency.equals(_o.currency) &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		knockout == _o.knockout &&
		speedDisplay == _o.speedDisplay &&
		minPlayers == _o.minPlayers &&
		countryRestrictionInverted == _o.countryRestrictionInverted &&
		restrictedCountries.equals(_o.restrictedCountries) &&
		scalePM == _o.scalePM &&
		brandAccessMask == _o.brandAccessMask &&
		timedTournType == _o.timedTournType &&
		timedTournTime == _o.timedTournTime &&
		visibilityCriteria.equals(_o.visibilityCriteria) &&
		maxPerTable == _o.maxPerTable &&
		timedTournPlayersPercent == _o.timedTournPlayersPercent &&
		tournFlags == _o.tournFlags &&
		tournFlags2 == _o.tournFlags2 &&
		satelliteTarget == _o.satelliteTarget &&
		satelliteTargetReference.equals(_o.satelliteTargetReference) &&
		tournFlagsServInt == _o.tournFlagsServInt &&
		regTournId == _o.regTournId &&
		mobileName.equals(_o.mobileName) &&
		tournGroup == _o.tournGroup &&
		maxPlayers == _o.maxPlayers &&
		lastEntry.equals(_o.lastEntry) &&
		admissions.equals(_o.admissions) &&
		fppBuyIn == _o.fppBuyIn &&
		prizes.equals(_o.prizes) &&
		tickets.equals(_o.tickets) &&
		awardScheme == _o.awardScheme &&
		tournGroupName.equals(_o.tournGroupName) &&
		tournGroupRef.equals(_o.tournGroupRef) &&
		tournSitesEx.equals(_o.tournSitesEx) &&
		userHasTicket == _o.userHasTicket;
}

const char *MLobbyNG::cli::SngDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("id=");
	_buf.appendUint(id);
	_buf.append(',');
	_buf.append("tournSites=");
	_buf.appendUint(tournSites);
	_buf.append(',');
	_buf.append("visible=");
	_buf.appendUint(visible);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendInt(buyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendInt(rake);
	_buf.append(',');
	_buf.append("knockout=");
	_buf.appendInt(knockout);
	_buf.append(',');
	_buf.append("speedDisplay=");
	_buf.appendUint(speedDisplay);
	_buf.append(',');
	_buf.append("minPlayers=");
	_buf.appendUint(minPlayers);
	_buf.append(',');
	_buf.append("countryRestrictionInverted=");
	_buf.appendUint(countryRestrictionInverted);
	_buf.append(',');
	_buf.append("restrictedCountries=");
	restrictedCountries.toTraceString(_buf);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("brandAccessMask=");
	_buf.appendUint(brandAccessMask);
	_buf.append(',');
	_buf.append("timedTournType=");
	_buf.appendUint(timedTournType);
	_buf.append(',');
	_buf.append("timedTournTime=");
	_buf.appendUint(timedTournTime);
	_buf.append(',');
	_buf.append("visibilityCriteria=");
	_buf.append(visibilityCriteria);
	_buf.append(',');
	_buf.append("maxPerTable=");
	_buf.appendUint(maxPerTable);
	_buf.append(',');
	_buf.append("timedTournPlayersPercent=");
	_buf.appendUint(timedTournPlayersPercent);
	_buf.append(',');
	_buf.append("tournFlags=");
	_buf.appendUint(tournFlags);
	_buf.append(',');
	_buf.append("tournFlags2=");
	_buf.appendUint64(tournFlags2);
	_buf.append(',');
	_buf.append("satelliteTarget=");
	_buf.appendUint(satelliteTarget);
	_buf.append(',');
	_buf.append("satelliteTargetReference=");
	_buf.append(satelliteTargetReference);
	_buf.append(',');
	_buf.append("tournFlagsServInt=");
	_buf.appendUint(tournFlagsServInt);
	_buf.append(',');
	_buf.append("regTournId=");
	_buf.appendUint64(regTournId);
	_buf.append(',');
	_buf.append("mobileName=");
	_buf.append(mobileName);
	_buf.append(',');
	_buf.append("tournGroup=");
	_buf.appendUint(tournGroup);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendUint(maxPlayers);
	_buf.append(',');
	_buf.append("lastEntry=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, lastEntry);
	_buf.append(',');
	_buf.append("admissions=");
	admissions.toTraceString(_buf);
	_buf.append(',');
	_buf.append("fppBuyIn=");
	_buf.appendInt(fppBuyIn);
	_buf.append(',');
	_buf.append("prizes=");
	prizes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tickets=");
	tickets.toTraceString(_buf);
	_buf.append(',');
	_buf.append("awardScheme=");
	_buf.appendInt(awardScheme);
	_buf.append(',');
	_buf.append("tournGroupName=");
	_buf.append(tournGroupName);
	_buf.append(',');
	_buf.append("tournGroupRef=");
	_buf.append(tournGroupRef);
	_buf.append(',');
	_buf.append("tournSitesEx=");
	tournSitesEx.toTraceString(_buf);
	_buf.append(',');
	_buf.append("userHasTicket=");
	_buf.appendUint(userHasTicket);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::SngDataStruct::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(SngDataStruct())) // not empty
	{
		_body.composeUINT32(id);
		_body.composeUINT32(tournSites);
		_body.composeBOOL(visible);
		_body.composeBYTE(game);
		_body.composeBYTE(structure);
		_body.composeBYTE(isHiLo);
		_body.composeBYTE(isPlayMoney);
		_body.composeString(currency);
		_body.composeINT32(buyIn);
		_body.composeINT32(rake);
		_body.composeINT32(knockout);
		_body.composeBYTE(speedDisplay);
		_body.composeUINT32(minPlayers);
		_body.composeBOOL(countryRestrictionInverted);
		restrictedCountries.composeMsg(_body);
		_body.composeUINT32(scalePM);
		_body.composeUINT32(brandAccessMask);
		_body.composeBYTE(timedTournType);
		_body.composeUINT16(timedTournTime);
		_body.composeString(visibilityCriteria);
		_body.composeUINT32(maxPerTable);
		_body.composeBYTE(timedTournPlayersPercent);
		_body.composeUINT32(tournFlags);
		_body.composeUINT64(tournFlags2);
		_body.composeUINT32(satelliteTarget);
		_body.composeString(satelliteTargetReference);
		_body.composeUINT32(tournFlagsServInt);
		_body.composeUINT64(regTournId);
		_body.composeString(mobileName);
		_body.composeUINT32(tournGroup);
		_body.composeUINT32(maxPlayers);
		_body.composeSrvTime(lastEntry);
		admissions.composeMsg(_body);
		_body.composeINT32(fppBuyIn);
		prizes.composeMsg(_body);
		tickets.composeMsg(_body);
		_body.composeINT32(awardScheme);
		_body.composeString(tournGroupName);
		_body.composeString(tournGroupRef);
		tournSitesEx.composeMsg(_body);
		_body.composeBOOL(userHasTicket);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::SngDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(id);
	_parser0.parseUINT32(tournSites);
	_parser0.parseBOOL(visible);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(structure);
	_parser0.parseBYTE(isHiLo);
	_parser0.parseBYTE(isPlayMoney);
	_parser0.parseStringP(currency);
	_parser0.parseINT32(buyIn);
	_parser0.parseINT32(rake);
	_parser0.parseINT32(knockout);
	_parser0.parseBYTE(speedDisplay);
	_parser0.parseUINT32(minPlayers);
	_parser0.parseBOOL(countryRestrictionInverted);
	restrictedCountries.parseMsg(_parser0);
	_parser0.parseUINT32(scalePM);
	_parser0.parseUINT32(brandAccessMask);
	_parser0.parseBYTE(timedTournType);
	_parser0.parseUINT16(timedTournTime);
	_parser0.parseStringP(visibilityCriteria);
	_parser0.parseUINT32(maxPerTable);
	_parser0.parseBYTE(timedTournPlayersPercent);
	_parser0.parseUINT32(tournFlags);
	_parser0.parseUINT64(tournFlags2);
	_parser0.parseUINT32(satelliteTarget);
	_parser0.parseStringP(satelliteTargetReference);
	_parser0.parseUINT32(tournFlagsServInt);
	_parser0.parseUINT64(regTournId);
	_parser0.parseStringP(mobileName);
	_parser0.parseUINT32(tournGroup);
	_parser0.parseUINT32(maxPlayers);
	_parser0.parseSrvTime(lastEntry);
	admissions.parseMsg(_parser0);
	_parser0.parseINT32(fppBuyIn);
	prizes.parseMsg(_parser0);
	tickets.parseMsg(_parser0);
	_parser0.parseINT32(awardScheme);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(tournGroupName);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(tournGroupRef);
	if(_parser0.parseEnded()) return;
	tournSitesEx.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	_parser0.parseBOOL(userHasTicket);
}

/*static*/ void MLobbyNG::cli::SngDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 id; _parser0.parseUINT32(id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	UINT32 tournSites; _parser0.parseUINT32(tournSites);
	AtfValidator::validateInt(_descr, "tournSites", tournSites, _checker, __FILE__, __LINE__);
	bool visible; _parser0.parseBOOL(visible);
	AtfValidator::validateInt(_descr, "visible", visible, _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser0.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser0.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT32 buyIn; _parser0.parseINT32(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	INT32 rake; _parser0.parseINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	INT32 knockout; _parser0.parseINT32(knockout);
	AtfValidator::validateInt(_descr, "knockout", knockout, _checker, __FILE__, __LINE__);
	BYTE speedDisplay; _parser0.parseBYTE(speedDisplay);
	AtfValidator::validateInt(_descr, "speedDisplay", speedDisplay, _checker, __FILE__, __LINE__);
	UINT32 minPlayers; _parser0.parseUINT32(minPlayers);
	AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
	bool countryRestrictionInverted; _parser0.parseBOOL(countryRestrictionInverted);
	AtfValidator::validateInt(_descr, "countryRestrictionInverted", countryRestrictionInverted, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szRestrictedCountries = ThinAtf::LAtfVector< PString, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("restrictedCountries"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "restrictedCountries", szRestrictedCountries, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser0.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT32 brandAccessMask; _parser0.parseUINT32(brandAccessMask);
	AtfValidator::validateInt(_descr, "brandAccessMask", brandAccessMask, _checker, __FILE__, __LINE__);
	BYTE timedTournType; _parser0.parseBYTE(timedTournType);
	AtfValidator::validateInt(_descr, "timedTournType", timedTournType, _checker, __FILE__, __LINE__);
	UINT16 timedTournTime; _parser0.parseUINT16(timedTournTime);
	AtfValidator::validateInt(_descr, "timedTournTime", timedTournTime, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "visibilityCriteria"); size_t szVisibilityCriteria = strlen(_dummy);
	AtfValidator::validateInt(_descr, "visibilityCriteria", szVisibilityCriteria, _checker, __FILE__, __LINE__);
	UINT32 maxPerTable; _parser0.parseUINT32(maxPerTable);
	AtfValidator::validateInt(_descr, "maxPerTable", maxPerTable, _checker, __FILE__, __LINE__);
	BYTE timedTournPlayersPercent; _parser0.parseBYTE(timedTournPlayersPercent);
	AtfValidator::validateInt(_descr, "timedTournPlayersPercent", timedTournPlayersPercent, _checker, __FILE__, __LINE__);
	UINT32 tournFlags; _parser0.parseUINT32(tournFlags);
	AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
	UINT64 tournFlags2; _parser0.parseUINT64(tournFlags2);
	AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	UINT32 satelliteTarget; _parser0.parseUINT32(satelliteTarget);
	AtfValidator::validateInt(_descr, "satelliteTarget", satelliteTarget, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "satelliteTargetReference"); size_t szSatelliteTargetReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "satelliteTargetReference", szSatelliteTargetReference, _checker, __FILE__, __LINE__);
	UINT32 tournFlagsServInt; _parser0.parseUINT32(tournFlagsServInt);
	AtfValidator::validateInt(_descr, "tournFlagsServInt", tournFlagsServInt, _checker, __FILE__, __LINE__);
	UINT64 regTournId; _parser0.parseUINT64(regTournId);
	AtfValidator::validateUint(_descr, "regTournId", regTournId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "mobileName"); size_t szMobileName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "mobileName", szMobileName, _checker, __FILE__, __LINE__);
	UINT32 tournGroup; _parser0.parseUINT32(tournGroup);
	AtfValidator::validateInt(_descr, "tournGroup", tournGroup, _checker, __FILE__, __LINE__);
	UINT32 maxPlayers; _parser0.parseUINT32(maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	SrvTime lastEntry; _parser0.parseSrvTime(lastEntry);
	AtfValidator::validateSrvDateTime(_descr, "lastEntry", lastEntry, _checker, __FILE__, __LINE__);
	int szAdmissions = ThinAtf::LAtfVector< PString, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("admissions"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "admissions", szAdmissions, _checker, __FILE__, __LINE__);
	INT32 fppBuyIn; _parser0.parseINT32(fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	int szPrizes = ThinAtf::LAtfVector< PrizeData, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("prizes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "prizes", szPrizes, _checker, __FILE__, __LINE__);
	int szTickets = ThinAtf::LAtfVector< TicketData, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tickets"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tickets", szTickets, _checker, __FILE__, __LINE__);
	INT32 awardScheme; _parser0.parseINT32(awardScheme);
	AtfValidator::validateInt(_descr, "awardScheme", awardScheme, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "tournGroupName"); size_t szTournGroupName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tournGroupName", szTournGroupName, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "tournGroupRef"); size_t szTournGroupRef = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tournGroupRef", szTournGroupRef, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tournSitesEx"), _fieldsWithUnparsedContent);
	if(_parser0.parseEnded()) return;
	bool userHasTicket; _parser0.parseBOOL(userHasTicket);
	AtfValidator::validateInt(_descr, "userHasTicket", userHasTicket, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ActivityStruct
//=================================================================

MLobbyNG::cli::ActivityStruct::ActivityStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::ActivityStruct::ActivityStruct(ActivityStruct&& _o)
	: eventTime(std::move(_o.eventTime))
	, gameCategory(std::move(_o.gameCategory))
	, handType(std::move(_o.handType))
	, limit(std::move(_o.limit))
	, minPlayers(std::move(_o.minPlayers))
	, maxPlayers(std::move(_o.maxPlayers))
	, playersPerTable(std::move(_o.playersPerTable))
	, loBet(std::move(_o.loBet))
	, hiBet(std::move(_o.hiBet))
	, buyIn(std::move(_o.buyIn))
	, speed(std::move(_o.speed))
	, tournVariant(std::move(_o.tournVariant))
	, strRef(std::move(_o.strRef))
	, flags(std::move(_o.flags))
	, currency(std::move(_o.currency))
{
}

MLobbyNG::cli::ActivityStruct& MLobbyNG::cli::ActivityStruct::operator=(ActivityStruct&& _o)
{
	if(this != &_o)
	{
		eventTime = std::move(_o.eventTime);
		gameCategory = std::move(_o.gameCategory);
		handType = std::move(_o.handType);
		limit = std::move(_o.limit);
		minPlayers = std::move(_o.minPlayers);
		maxPlayers = std::move(_o.maxPlayers);
		playersPerTable = std::move(_o.playersPerTable);
		loBet = std::move(_o.loBet);
		hiBet = std::move(_o.hiBet);
		buyIn = std::move(_o.buyIn);
		speed = std::move(_o.speed);
		tournVariant = std::move(_o.tournVariant);
		strRef = std::move(_o.strRef);
		flags = std::move(_o.flags);
		currency = std::move(_o.currency);
	}
	return *this;
}

#endif

void MLobbyNG::cli::ActivityStruct::clear()
{
	eventTime.setNull();
	gameCategory = 0;
	handType = 0;
	limit = 0;
	minPlayers = 0;
	maxPlayers = 0;
	playersPerTable = 0;
	loBet = 0;
	hiBet = 0;
	buyIn = 0;
	speed = 0;
	tournVariant = 0;
	strRef.clear();
	flags = 0;
	currency.clear();
}

bool MLobbyNG::cli::ActivityStruct::equals(const ActivityStruct& _o) const
{
	return eventTime.equals(_o.eventTime) &&
		gameCategory == _o.gameCategory &&
		handType == _o.handType &&
		limit == _o.limit &&
		minPlayers == _o.minPlayers &&
		maxPlayers == _o.maxPlayers &&
		playersPerTable == _o.playersPerTable &&
		loBet == _o.loBet &&
		hiBet == _o.hiBet &&
		buyIn == _o.buyIn &&
		speed == _o.speed &&
		tournVariant == _o.tournVariant &&
		strRef.equals(_o.strRef) &&
		flags == _o.flags &&
		currency.equals(_o.currency);
}

const char *MLobbyNG::cli::ActivityStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("eventTime=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, eventTime);
	_buf.append(',');
	_buf.append("gameCategory=");
	_buf.appendUint(gameCategory);
	_buf.append(',');
	_buf.append("handType=");
	_buf.appendUint(handType);
	_buf.append(',');
	_buf.append("limit=");
	_buf.appendUint(limit);
	_buf.append(',');
	_buf.append("minPlayers=");
	_buf.appendUint(minPlayers);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendUint(maxPlayers);
	_buf.append(',');
	_buf.append("playersPerTable=");
	_buf.appendUint(playersPerTable);
	_buf.append(',');
	_buf.append("loBet=");
	_buf.appendUint(loBet);
	_buf.append(',');
	_buf.append("hiBet=");
	_buf.appendUint(hiBet);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendInt64(buyIn);
	_buf.append(',');
	_buf.append("speed=");
	_buf.appendUint(speed);
	_buf.append(',');
	_buf.append("tournVariant=");
	_buf.appendUint(tournVariant);
	_buf.append(',');
	_buf.append("strRef=");
	_buf.append(strRef);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::ActivityStruct::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(ActivityStruct())) // not empty
	{
		_body.composeSrvTime(eventTime);
		_body.composeUINT32(gameCategory);
		_body.composeBYTE(handType);
		_body.composeBYTE(limit);
		_body.composeUINT32(minPlayers);
		_body.composeUINT32(maxPlayers);
		_body.composeUINT16(playersPerTable);
		_body.composeUINT32(loBet);
		_body.composeUINT32(hiBet);
		_body.composeINT64(buyIn);
		_body.composeUINT16(speed);
		_body.composeUINT32(tournVariant);
		_body.composeString(strRef);
		_body.composeUINT32(flags);
		_body.composeString(currency);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::ActivityStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseSrvTime(eventTime);
	_parser0.parseUINT32(gameCategory);
	_parser0.parseBYTE(handType);
	_parser0.parseBYTE(limit);
	_parser0.parseUINT32(minPlayers);
	_parser0.parseUINT32(maxPlayers);
	_parser0.parseUINT16(playersPerTable);
	_parser0.parseUINT32(loBet);
	_parser0.parseUINT32(hiBet);
	_parser0.parseINT64(buyIn);
	_parser0.parseUINT16(speed);
	_parser0.parseUINT32(tournVariant);
	_parser0.parseStringP(strRef);
	_parser0.parseUINT32(flags);
	_parser0.parseStringP(currency);
}

/*static*/ void MLobbyNG::cli::ActivityStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	SrvTime eventTime; _parser0.parseSrvTime(eventTime);
	AtfValidator::validateSrvDateTime(_descr, "eventTime", eventTime, _checker, __FILE__, __LINE__);
	UINT32 gameCategory; _parser0.parseUINT32(gameCategory);
	AtfValidator::validateIntMax(_descr, "gameCategory", gameCategory, (2*GameCategory_Last-1), _checker, __FILE__, __LINE__);
	BYTE handType; _parser0.parseBYTE(handType);
	AtfValidator::validateIntMax(_descr, "handType", handType, HandType_Last, _checker, __FILE__, __LINE__);
	BYTE limit; _parser0.parseBYTE(limit);
	AtfValidator::validateIntMax(_descr, "limit", limit, PotStruct_Last, _checker, __FILE__, __LINE__);
	UINT32 minPlayers; _parser0.parseUINT32(minPlayers);
	AtfValidator::validateIntMax(_descr, "minPlayers", minPlayers, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 maxPlayers; _parser0.parseUINT32(maxPlayers);
	AtfValidator::validateIntMax(_descr, "maxPlayers", maxPlayers, 2000000000, _checker, __FILE__, __LINE__);
	UINT16 playersPerTable; _parser0.parseUINT16(playersPerTable);
	AtfValidator::validateIntMax(_descr, "playersPerTable", playersPerTable, 10, _checker, __FILE__, __LINE__);
	UINT32 loBet; _parser0.parseUINT32(loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	UINT32 hiBet; _parser0.parseUINT32(hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	INT64 buyIn; _parser0.parseINT64(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT16 speed; _parser0.parseUINT16(speed);
	AtfValidator::validateIntMax(_descr, "speed", speed, SpeedDisplay_LastSlot, _checker, __FILE__, __LINE__);
	UINT32 tournVariant; _parser0.parseUINT32(tournVariant);
	AtfValidator::validateIntMax(_descr, "tournVariant", tournVariant, (2*NGTournVariant_Last-1), _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "strRef"); size_t szStrRef = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "strRef", szStrRef, 20, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser0.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, 7, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    GameListFilter
//=================================================================

MLobbyNG::cli::GameListFilter::GameListFilter()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::GameListFilter::GameListFilter(GameListFilter&& _o)
	: locale(std::move(_o.locale))
	, siteId(std::move(_o.siteId))
	, brandId(std::move(_o.brandId))
	, country(std::move(_o.country))
	, state(std::move(_o.state))
	, isPM(std::move(_o.isPM))
{
}

MLobbyNG::cli::GameListFilter& MLobbyNG::cli::GameListFilter::operator=(GameListFilter&& _o)
{
	if(this != &_o)
	{
		locale = std::move(_o.locale);
		siteId = std::move(_o.siteId);
		brandId = std::move(_o.brandId);
		country = std::move(_o.country);
		state = std::move(_o.state);
		isPM = std::move(_o.isPM);
	}
	return *this;
}

#endif

void MLobbyNG::cli::GameListFilter::clear()
{
	locale = 0;
	siteId = 0;
	brandId = 0;
	country.clear();
	state.clear();
	isPM = false;
}

bool MLobbyNG::cli::GameListFilter::equals(const GameListFilter& _o) const
{
	return locale == _o.locale &&
		siteId == _o.siteId &&
		brandId == _o.brandId &&
		country.equals(_o.country) &&
		state.equals(_o.state) &&
		isPM == _o.isPM;
}

const char *MLobbyNG::cli::GameListFilter::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("brandId=");
	_buf.appendUint(brandId);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("state=");
	_buf.append(state);
	_buf.append(',');
	_buf.append("isPM=");
	_buf.appendUint(isPM);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::GameListFilter::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(GameListFilter())) // not empty
	{
		_body.composeUINT32(locale);
		_body.composeUINT32(siteId);
		_body.composeUINT32(brandId);
		_body.composeString(country);
		_body.composeString(state);
		_body.composeBOOL(isPM);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::GameListFilter::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(locale);
	_parser0.parseUINT32(siteId);
	_parser0.parseUINT32(brandId);
	_parser0.parseStringP(country);
	_parser0.parseStringP(state);
	_parser0.parseBOOL(isPM);
}

/*static*/ void MLobbyNG::cli::GameListFilter::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 locale; _parser0.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT32 siteId; _parser0.parseUINT32(siteId);
	AtfValidator::validateIntMax(_descr, "siteId", siteId, PokerStars_Last, _checker, __FILE__, __LINE__);
	UINT32 brandId; _parser0.parseUINT32(brandId);
	AtfValidator::validateIntMax(_descr, "brandId", brandId, BrandType_Last, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, 7, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "state"); size_t szState = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "state", szState, 50, _checker, __FILE__, __LINE__);
	bool isPM; _parser0.parseBOOL(isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SuggestedGamesSelectionFilter
//=================================================================

MLobbyNG::cli::SuggestedGamesSelectionFilter::SuggestedGamesSelectionFilter()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::SuggestedGamesSelectionFilter::SuggestedGamesSelectionFilter(SuggestedGamesSelectionFilter&& _o)
	: locale(std::move(_o.locale))
	, country(std::move(_o.country))
	, isPM(std::move(_o.isPM))
	, tournMedianValue(std::move(_o.tournMedianValue))
	, sngMedianValue(std::move(_o.sngMedianValue))
	, ringMedianValue(std::move(_o.ringMedianValue))
	, tournFilter(std::move(_o.tournFilter))
	, tableFilter(std::move(_o.tableFilter))
	, sngFilter(std::move(_o.sngFilter))
{
}

MLobbyNG::cli::SuggestedGamesSelectionFilter& MLobbyNG::cli::SuggestedGamesSelectionFilter::operator=(SuggestedGamesSelectionFilter&& _o)
{
	if(this != &_o)
	{
		locale = std::move(_o.locale);
		country = std::move(_o.country);
		isPM = std::move(_o.isPM);
		tournMedianValue = std::move(_o.tournMedianValue);
		sngMedianValue = std::move(_o.sngMedianValue);
		ringMedianValue = std::move(_o.ringMedianValue);
		tournFilter = std::move(_o.tournFilter);
		tableFilter = std::move(_o.tableFilter);
		sngFilter = std::move(_o.sngFilter);
	}
	return *this;
}

#endif

void MLobbyNG::cli::SuggestedGamesSelectionFilter::clear()
{
	locale = 0;
	country.clear();
	isPM = false;
	tournMedianValue = 0;
	sngMedianValue = 0;
	ringMedianValue = 0;
	tournFilter.clear();
	tableFilter.clear();
	sngFilter.clear();
}

bool MLobbyNG::cli::SuggestedGamesSelectionFilter::equals(const SuggestedGamesSelectionFilter& _o) const
{
	return locale == _o.locale &&
		country.equals(_o.country) &&
		isPM == _o.isPM &&
		tournMedianValue == _o.tournMedianValue &&
		sngMedianValue == _o.sngMedianValue &&
		ringMedianValue == _o.ringMedianValue &&
		tournFilter.equals(_o.tournFilter) &&
		tableFilter.equals(_o.tableFilter) &&
		sngFilter.equals(_o.sngFilter);
}

const char *MLobbyNG::cli::SuggestedGamesSelectionFilter::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("isPM=");
	_buf.appendUint(isPM);
	_buf.append(',');
	_buf.append("tournMedianValue=");
	_buf.appendInt64(tournMedianValue);
	_buf.append(',');
	_buf.append("sngMedianValue=");
	_buf.appendInt64(sngMedianValue);
	_buf.append(',');
	_buf.append("ringMedianValue=");
	_buf.appendInt64(ringMedianValue);
	_buf.append(',');
	_buf.append("tournFilter=");
	tournFilter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableFilter=");
	tableFilter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sngFilter=");
	sngFilter.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::SuggestedGamesSelectionFilter::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(SuggestedGamesSelectionFilter())) // not empty
	{
		_body.composeUINT32(locale);
		_body.composeString(country);
		_body.composeBOOL(isPM);
		_body.composeINT64(tournMedianValue);
		_body.composeINT64(sngMedianValue);
		_body.composeINT64(ringMedianValue);
		tournFilter.composeMsg(_body);
		tableFilter.composeMsg(_body);
		sngFilter.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::SuggestedGamesSelectionFilter::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(locale);
	_parser0.parseStringP(country);
	_parser0.parseBOOL(isPM);
	_parser0.parseINT64(tournMedianValue);
	_parser0.parseINT64(sngMedianValue);
	_parser0.parseINT64(ringMedianValue);
	tournFilter.parseMsg(_parser0);
	tableFilter.parseMsg(_parser0);
	sngFilter.parseMsg(_parser0);
}

/*static*/ void MLobbyNG::cli::SuggestedGamesSelectionFilter::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 locale; _parser0.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, 3, _checker, __FILE__, __LINE__);
	bool isPM; _parser0.parseBOOL(isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
	INT64 tournMedianValue; _parser0.parseINT64(tournMedianValue);
	AtfValidator::validateInt(_descr, "tournMedianValue", tournMedianValue, _checker, __FILE__, __LINE__);
	INT64 sngMedianValue; _parser0.parseINT64(sngMedianValue);
	AtfValidator::validateInt(_descr, "sngMedianValue", sngMedianValue, _checker, __FILE__, __LINE__);
	INT64 ringMedianValue; _parser0.parseINT64(ringMedianValue);
	AtfValidator::validateInt(_descr, "ringMedianValue", ringMedianValue, _checker, __FILE__, __LINE__);
	PString _descbuf;
	TournSelectionFilter::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tournFilter"), _fieldsWithUnparsedContent);
	TableSelectionFilter::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tableFilter"), _fieldsWithUnparsedContent);
	SngSelectionFilter::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("sngFilter"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    FilterCountKey
//=================================================================

// @Override
bool MLobbyNG::cli::FilterCountKey::operator<(const FilterCountKey& rhs) const
{
	if( intVal1 == rhs.intVal1 )
	{
		if( intVal2 == rhs.intVal2 )
		{
			return intVal3 < rhs.intVal3;
		}

		return intVal2 < rhs.intVal2;
	}
	
	return intVal1 < rhs.intVal1;
}

MLobbyNG::cli::FilterCountKey::FilterCountKey()
{
	clear();
}

void MLobbyNG::cli::FilterCountKey::clear()
{
	intVal1 = 0;
	intVal2 = 0;
	intVal3 = 0;
}

bool MLobbyNG::cli::FilterCountKey::equals(const FilterCountKey& _o) const
{
	return intVal1 == _o.intVal1 &&
		intVal2 == _o.intVal2 &&
		intVal3 == _o.intVal3;
}

const char *MLobbyNG::cli::FilterCountKey::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("intVal1=");
	_buf.appendInt64(intVal1);
	_buf.append(',');
	_buf.append("intVal2=");
	_buf.appendInt64(intVal2);
	_buf.append(',');
	_buf.append("intVal3=");
	_buf.appendInt64(intVal3);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::FilterCountKey::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(FilterCountKey())) // not empty
	{
		_body.composeINT64(intVal1);
		_body.composeINT64(intVal2);
		_body.composeINT64(intVal3);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::FilterCountKey::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT64(intVal1);
	_parser0.parseINT64(intVal2);
	_parser0.parseINT64(intVal3);
}

/*static*/ void MLobbyNG::cli::FilterCountKey::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT64 intVal1; _parser0.parseINT64(intVal1);
	AtfValidator::validateInt(_descr, "intVal1", intVal1, _checker, __FILE__, __LINE__);
	INT64 intVal2; _parser0.parseINT64(intVal2);
	AtfValidator::validateInt(_descr, "intVal2", intVal2, _checker, __FILE__, __LINE__);
	INT64 intVal3; _parser0.parseINT64(intVal3);
	AtfValidator::validateInt(_descr, "intVal3", intVal3, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    FilterCountInfo
//=================================================================

MLobbyNG::cli::FilterCountInfo::FilterCountInfo()
{
	clear();
}

void MLobbyNG::cli::FilterCountInfo::clear()
{
	key.clear();
	value = 0;
}

bool MLobbyNG::cli::FilterCountInfo::equals(const FilterCountInfo& _o) const
{
	return key.equals(_o.key) &&
		value == _o.value;
}

const char *MLobbyNG::cli::FilterCountInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("key=");
	key.toTraceString(_buf);
	_buf.append(',');
	_buf.append("value=");
	_buf.appendInt64(value);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::FilterCountInfo::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(FilterCountInfo())) // not empty
	{
		key.composeMsg(_body);
		_body.composeINT64(value);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::FilterCountInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	key.parseMsg(_parser0);
	_parser0.parseINT64(value);
}

/*static*/ void MLobbyNG::cli::FilterCountInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	FilterCountKey::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("key"), _fieldsWithUnparsedContent);
	INT64 value; _parser0.parseINT64(value);
	AtfValidator::validateInt(_descr, "value", value, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    GameConnInfoReqStruct
//=================================================================

MLobbyNG::cli::GameConnInfoReqStruct::GameConnInfoReqStruct()
{
	clear();
}

void MLobbyNG::cli::GameConnInfoReqStruct::clear()
{
	gameId = 0;
	category = 0;
	ngSagFlags = 0;
}

bool MLobbyNG::cli::GameConnInfoReqStruct::equals(const GameConnInfoReqStruct& _o) const
{
	return gameId == _o.gameId &&
		category == _o.category &&
		ngSagFlags == _o.ngSagFlags;
}

const char *MLobbyNG::cli::GameConnInfoReqStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("gameId=");
	_buf.appendUint64(gameId);
	_buf.append(',');
	_buf.append("category=");
	_buf.appendUint(category);
	_buf.append(',');
	_buf.append("ngSagFlags=");
	_buf.appendUint(ngSagFlags);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::GameConnInfoReqStruct::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(GameConnInfoReqStruct())) // not empty
	{
		_body.composeUINT64(gameId);
		_body.composeUINT32(category);
		_body.composeUINT32(ngSagFlags);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::GameConnInfoReqStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT64(gameId);
	_parser0.parseUINT32(category);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT32(ngSagFlags);
}

/*static*/ void MLobbyNG::cli::GameConnInfoReqStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT64 gameId; _parser0.parseUINT64(gameId);
	AtfValidator::validateUint(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
	UINT32 category; _parser0.parseUINT32(category);
	AtfValidator::validateIntMax(_descr, "category", category, GameCategory_Last, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	UINT32 ngSagFlags; _parser0.parseUINT32(ngSagFlags);
	AtfValidator::validateIntMax(_descr, "ngSagFlags", ngSagFlags, (2*NGSAGFlag_Last-1), _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    GameConnectInfo
//=================================================================

MLobbyNG::cli::GameConnectInfo::GameConnectInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::GameConnectInfo::GameConnectInfo(GameConnectInfo&& _o)
	: gameId(std::move(_o.gameId))
	, server(std::move(_o.server))
	, serverObject(std::move(_o.serverObject))
	, scriptId(std::move(_o.scriptId))
	, category(std::move(_o.category))
	, shouldOpen(std::move(_o.shouldOpen))
{
}

MLobbyNG::cli::GameConnectInfo& MLobbyNG::cli::GameConnectInfo::operator=(GameConnectInfo&& _o)
{
	if(this != &_o)
	{
		gameId = std::move(_o.gameId);
		server = std::move(_o.server);
		serverObject = std::move(_o.serverObject);
		scriptId = std::move(_o.scriptId);
		category = std::move(_o.category);
		shouldOpen = std::move(_o.shouldOpen);
	}
	return *this;
}

#endif

void MLobbyNG::cli::GameConnectInfo::clear()
{
	gameId = 0;
	server.clear();
	serverObject.clear();
	scriptId = 0;
	category = 0;
	shouldOpen = false;
}

bool MLobbyNG::cli::GameConnectInfo::equals(const GameConnectInfo& _o) const
{
	return gameId == _o.gameId &&
		server.equals(_o.server) &&
		serverObject.equals(_o.serverObject) &&
		scriptId == _o.scriptId &&
		category == _o.category &&
		shouldOpen == _o.shouldOpen;
}

const char *MLobbyNG::cli::GameConnectInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("gameId=");
	_buf.appendUint64(gameId);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("serverObject=");
	_buf.append(serverObject);
	_buf.append(',');
	_buf.append("scriptId=");
	_buf.appendUint(scriptId);
	_buf.append(',');
	_buf.append("category=");
	_buf.appendUint(category);
	_buf.append(',');
	_buf.append("shouldOpen=");
	_buf.appendUint(shouldOpen);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::GameConnectInfo::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(GameConnectInfo())) // not empty
	{
		_body.composeUINT64(gameId);
		_body.composeString(server);
		_body.composeString(serverObject);
		_body.composeUINT32(scriptId);
		_body.composeUINT32(category);
		_body.composeBOOL(shouldOpen);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::GameConnectInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT64(gameId);
	_parser0.parseStringP(server);
	_parser0.parseStringP(serverObject);
	_parser0.parseUINT32(scriptId);
	_parser0.parseUINT32(category);
	_parser0.parseBOOL(shouldOpen);
}

/*static*/ void MLobbyNG::cli::GameConnectInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT64 gameId; _parser0.parseUINT64(gameId);
	AtfValidator::validateUint(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "serverObject"); size_t szServerObject = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObject", szServerObject, _checker, __FILE__, __LINE__);
	UINT32 scriptId; _parser0.parseUINT32(scriptId);
	AtfValidator::validateInt(_descr, "scriptId", scriptId, _checker, __FILE__, __LINE__);
	UINT32 category; _parser0.parseUINT32(category);
	AtfValidator::validateInt(_descr, "category", category, _checker, __FILE__, __LINE__);
	bool shouldOpen; _parser0.parseBOOL(shouldOpen);
	AtfValidator::validateInt(_descr, "shouldOpen", shouldOpen, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TicketTournInfo
//=================================================================

MLobbyNG::cli::TicketTournInfo::TicketTournInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::TicketTournInfo::TicketTournInfo(TicketTournInfo&& _o)
	: ticketName(std::move(_o.ticketName))
	, tourns(std::move(_o.tourns))
	, sngTypes(std::move(_o.sngTypes))
	, sagTypes(std::move(_o.sagTypes))
{
}

MLobbyNG::cli::TicketTournInfo& MLobbyNG::cli::TicketTournInfo::operator=(TicketTournInfo&& _o)
{
	if(this != &_o)
	{
		ticketName = std::move(_o.ticketName);
		tourns = std::move(_o.tourns);
		sngTypes = std::move(_o.sngTypes);
		sagTypes = std::move(_o.sagTypes);
	}
	return *this;
}

#endif

void MLobbyNG::cli::TicketTournInfo::clear()
{
	ticketName.clear();
	tourns.clear();
	sngTypes.clear();
	sagTypes.clear();
}

bool MLobbyNG::cli::TicketTournInfo::equals(const TicketTournInfo& _o) const
{
	return ticketName.equals(_o.ticketName) &&
		tourns.equals(_o.tourns) &&
		sngTypes.equals(_o.sngTypes) &&
		sagTypes.equals(_o.sagTypes);
}

const char *MLobbyNG::cli::TicketTournInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("ticketName=");
	_buf.append(ticketName);
	_buf.append(',');
	_buf.append("tourns=");
	tourns.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sngTypes=");
	sngTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sagTypes=");
	sagTypes.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::TicketTournInfo::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(TicketTournInfo())) // not empty
	{
		_body.composeString(ticketName);
		tourns.composeMsg(_body);
		sngTypes.composeMsg(_body);
		sagTypes.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::TicketTournInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(ticketName);
	tourns.parseMsg(_parser0);
	sngTypes.parseMsg(_parser0);
	sagTypes.parseMsg(_parser0);
}

/*static*/ void MLobbyNG::cli::TicketTournInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "ticketName"); size_t szTicketName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "ticketName", szTicketName, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTourns = ThinAtf::LAtfVector< TournDataStruct, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
	int szSngTypes = ThinAtf::LAtfVector< SngDataStruct, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("sngTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sngTypes", szSngTypes, _checker, __FILE__, __LINE__);
	int szSagTypes = ThinAtf::LAtfVector< SagDataStruct, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("sagTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sagTypes", szSagTypes, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TableStaticDataStruct
//=================================================================

MLobbyNG::cli::TableStaticDataStruct::TableStaticDataStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::TableStaticDataStruct::TableStaticDataStruct(TableStaticDataStruct&& _o)
	: tableId(std::move(_o.tableId))
	, name(std::move(_o.name))
	, server(std::move(_o.server))
	, serverObject(std::move(_o.serverObject))
	, clubId(std::move(_o.clubId))
	, isOneOnOne(std::move(_o.isOneOnOne))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, game(std::move(_o.game))
	, isHiLo(std::move(_o.isHiLo))
	, maxPlayers(std::move(_o.maxPlayers))
	, visibilityMask(std::move(_o.visibilityMask))
	, tableFlags(std::move(_o.tableFlags))
	, tableInstanceFlags(std::move(_o.tableInstanceFlags))
	, chatLang(std::move(_o.chatLang))
	, structure(std::move(_o.structure))
	, loBet(std::move(_o.loBet))
	, hiBet(std::move(_o.hiBet))
	, ante(std::move(_o.ante))
	, cap(std::move(_o.cap))
	, specialName(std::move(_o.specialName))
	, currency(std::move(_o.currency))
	, minChipsLimit(std::move(_o.minChipsLimit))
	, maxBuyIn(std::move(_o.maxBuyIn))
	, icon(std::move(_o.icon))
	, filter(std::move(_o.filter))
	, countryRestrictionInverted(std::move(_o.countryRestrictionInverted))
	, restrictedCountries(std::move(_o.restrictedCountries))
	, scalePM(std::move(_o.scalePM))
	, defaultBuyIn(std::move(_o.defaultBuyIn))
	, tableFlags2(std::move(_o.tableFlags2))
	, isTableStarter(std::move(_o.isTableStarter))
	, brandMask(std::move(_o.brandMask))
	, poolBlockMinHands(std::move(_o.poolBlockMinHands))
	, tableTypeId(std::move(_o.tableTypeId))
	, tableStakes(std::move(_o.tableStakes))
	, variableAntes(std::move(_o.variableAntes))
	, visibilityMaskEx(std::move(_o.visibilityMaskEx))
	, seatFinderId(std::move(_o.seatFinderId))
{
}

MLobbyNG::cli::TableStaticDataStruct& MLobbyNG::cli::TableStaticDataStruct::operator=(TableStaticDataStruct&& _o)
{
	if(this != &_o)
	{
		tableId = std::move(_o.tableId);
		name = std::move(_o.name);
		server = std::move(_o.server);
		serverObject = std::move(_o.serverObject);
		clubId = std::move(_o.clubId);
		isOneOnOne = std::move(_o.isOneOnOne);
		isPlayMoney = std::move(_o.isPlayMoney);
		game = std::move(_o.game);
		isHiLo = std::move(_o.isHiLo);
		maxPlayers = std::move(_o.maxPlayers);
		visibilityMask = std::move(_o.visibilityMask);
		tableFlags = std::move(_o.tableFlags);
		tableInstanceFlags = std::move(_o.tableInstanceFlags);
		chatLang = std::move(_o.chatLang);
		structure = std::move(_o.structure);
		loBet = std::move(_o.loBet);
		hiBet = std::move(_o.hiBet);
		ante = std::move(_o.ante);
		cap = std::move(_o.cap);
		specialName = std::move(_o.specialName);
		currency = std::move(_o.currency);
		minChipsLimit = std::move(_o.minChipsLimit);
		maxBuyIn = std::move(_o.maxBuyIn);
		icon = std::move(_o.icon);
		filter = std::move(_o.filter);
		countryRestrictionInverted = std::move(_o.countryRestrictionInverted);
		restrictedCountries = std::move(_o.restrictedCountries);
		scalePM = std::move(_o.scalePM);
		defaultBuyIn = std::move(_o.defaultBuyIn);
		tableFlags2 = std::move(_o.tableFlags2);
		isTableStarter = std::move(_o.isTableStarter);
		brandMask = std::move(_o.brandMask);
		poolBlockMinHands = std::move(_o.poolBlockMinHands);
		tableTypeId = std::move(_o.tableTypeId);
		tableStakes = std::move(_o.tableStakes);
		variableAntes = std::move(_o.variableAntes);
		visibilityMaskEx = std::move(_o.visibilityMaskEx);
		seatFinderId = std::move(_o.seatFinderId);
	}
	return *this;
}

#endif

void MLobbyNG::cli::TableStaticDataStruct::clear()
{
	tableId = 0;
	name.clear();
	server.clear();
	serverObject.clear();
	clubId = 0;
	isOneOnOne = 0;
	isPlayMoney = 0;
	game = 0;
	isHiLo = 0;
	maxPlayers = 0;
	visibilityMask = 0;
	tableFlags = 0;
	tableInstanceFlags = 0;
	chatLang = 0;
	structure = 0;
	loBet = 0;
	hiBet = 0;
	ante = 0;
	cap = 0;
	specialName.clear();
	currency.clear();
	minChipsLimit = 0;
	maxBuyIn = 0;
	icon = 0;
	filter = 0;
	countryRestrictionInverted = false;
	restrictedCountries.clear();
	scalePM = 0;
	defaultBuyIn = 0;
	tableFlags2 = 0;
	isTableStarter = false;
	brandMask = 0;
	poolBlockMinHands = 0;
	tableTypeId = 0;
	tableStakes.clear();
	variableAntes.clear();
	visibilityMaskEx.clear();
	seatFinderId = 0;
}

bool MLobbyNG::cli::TableStaticDataStruct::equals(const TableStaticDataStruct& _o) const
{
	return tableId == _o.tableId &&
		name.equals(_o.name) &&
		server.equals(_o.server) &&
		serverObject.equals(_o.serverObject) &&
		clubId == _o.clubId &&
		isOneOnOne == _o.isOneOnOne &&
		isPlayMoney == _o.isPlayMoney &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		maxPlayers == _o.maxPlayers &&
		visibilityMask == _o.visibilityMask &&
		tableFlags == _o.tableFlags &&
		tableInstanceFlags == _o.tableInstanceFlags &&
		chatLang == _o.chatLang &&
		structure == _o.structure &&
		loBet == _o.loBet &&
		hiBet == _o.hiBet &&
		ante == _o.ante &&
		cap == _o.cap &&
		specialName.equals(_o.specialName) &&
		currency.equals(_o.currency) &&
		minChipsLimit == _o.minChipsLimit &&
		maxBuyIn == _o.maxBuyIn &&
		icon == _o.icon &&
		filter == _o.filter &&
		countryRestrictionInverted == _o.countryRestrictionInverted &&
		restrictedCountries.equals(_o.restrictedCountries) &&
		scalePM == _o.scalePM &&
		defaultBuyIn == _o.defaultBuyIn &&
		tableFlags2 == _o.tableFlags2 &&
		isTableStarter == _o.isTableStarter &&
		brandMask == _o.brandMask &&
		poolBlockMinHands == _o.poolBlockMinHands &&
		tableTypeId == _o.tableTypeId &&
		tableStakes.equals(_o.tableStakes) &&
		variableAntes.equals(_o.variableAntes) &&
		visibilityMaskEx.equals(_o.visibilityMaskEx) &&
		seatFinderId == _o.seatFinderId;
}

const char *MLobbyNG::cli::TableStaticDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("serverObject=");
	_buf.append(serverObject);
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("isOneOnOne=");
	_buf.appendUint(isOneOnOne);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendUint(maxPlayers);
	_buf.append(',');
	_buf.append("visibilityMask=");
	_buf.appendUint(visibilityMask);
	_buf.append(',');
	_buf.append("tableFlags=");
	_buf.appendUint(tableFlags);
	_buf.append(',');
	_buf.append("tableInstanceFlags=");
	_buf.appendUint(tableInstanceFlags);
	_buf.append(',');
	_buf.append("chatLang=");
	_buf.appendUint(chatLang);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("loBet=");
	_buf.appendUint(loBet);
	_buf.append(',');
	_buf.append("hiBet=");
	_buf.appendUint(hiBet);
	_buf.append(',');
	_buf.append("ante=");
	_buf.appendUint(ante);
	_buf.append(',');
	_buf.append("cap=");
	_buf.appendUint(cap);
	_buf.append(',');
	_buf.append("specialName=");
	_buf.append(specialName);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("minChipsLimit=");
	_buf.appendUint(minChipsLimit);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendUint(maxBuyIn);
	_buf.append(',');
	_buf.append("icon=");
	_buf.appendUint(icon);
	_buf.append(',');
	_buf.append("filter=");
	_buf.appendUint(filter);
	_buf.append(',');
	_buf.append("countryRestrictionInverted=");
	_buf.appendUint(countryRestrictionInverted);
	_buf.append(',');
	_buf.append("restrictedCountries=");
	restrictedCountries.toTraceString(_buf);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("defaultBuyIn=");
	_buf.appendUint(defaultBuyIn);
	_buf.append(',');
	_buf.append("tableFlags2=");
	_buf.appendUint64(tableFlags2);
	_buf.append(',');
	_buf.append("isTableStarter=");
	_buf.appendUint(isTableStarter);
	_buf.append(',');
	_buf.append("brandMask=");
	_buf.appendUint(brandMask);
	_buf.append(',');
	_buf.append("poolBlockMinHands=");
	_buf.appendInt(poolBlockMinHands);
	_buf.append(',');
	_buf.append("tableTypeId=");
	_buf.appendUint(tableTypeId);
	_buf.append(',');
	_buf.append("tableStakes=");
	tableStakes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("variableAntes=");
	variableAntes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("visibilityMaskEx=");
	visibilityMaskEx.toTraceString(_buf);
	_buf.append(',');
	_buf.append("seatFinderId=");
	_buf.appendUint(seatFinderId);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::TableStaticDataStruct::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(TableStaticDataStruct())) // not empty
	{
		_body.composeUINT64(tableId);
		_body.composeString(name);
		_body.composeString(server);
		_body.composeString(serverObject);
		_body.composeUINT32(clubId);
		_body.composeBYTE(isOneOnOne);
		_body.composeBYTE(isPlayMoney);
		_body.composeBYTE(game);
		_body.composeBYTE(isHiLo);
		_body.composeBYTE(maxPlayers);
		_body.composeUINT32(visibilityMask);
		_body.composeUINT32(tableFlags);
		_body.composeUINT32(tableInstanceFlags);
		_body.composeUINT16(chatLang);
		_body.composeBYTE(structure);
		_body.composeUINT32(loBet);
		_body.composeUINT32(hiBet);
		_body.composeUINT32(ante);
		_body.composeUINT32(cap);
		_body.composeString(specialName);
		_body.composeString(currency);
		_body.composeUINT32(minChipsLimit);
		_body.composeUINT32(maxBuyIn);
		_body.composeBYTE(icon);
		_body.composeBYTE(filter);
		_body.composeBOOL(countryRestrictionInverted);
		restrictedCountries.composeMsg(_body);
		_body.composeUINT32(scalePM);
		_body.composeUINT32(defaultBuyIn);
		_body.composeUINT64(tableFlags2);
		_body.composeBOOL(isTableStarter);
		_body.composeUINT32(brandMask);
		_body.composeINT32(poolBlockMinHands);
		_body.composeUINT32(tableTypeId);
		tableStakes.composeMsg(_body);
		variableAntes.composeMsg(_body);
		visibilityMaskEx.composeMsg(_body);
		_body.composeUINT32(seatFinderId);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::TableStaticDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT64(tableId);
	_parser0.parseStringP(name);
	_parser0.parseStringP(server);
	_parser0.parseStringP(serverObject);
	_parser0.parseUINT32(clubId);
	_parser0.parseBYTE(isOneOnOne);
	_parser0.parseBYTE(isPlayMoney);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(isHiLo);
	_parser0.parseBYTE(maxPlayers);
	_parser0.parseUINT32(visibilityMask);
	_parser0.parseUINT32(tableFlags);
	_parser0.parseUINT32(tableInstanceFlags);
	_parser0.parseUINT16(chatLang);
	_parser0.parseBYTE(structure);
	_parser0.parseUINT32(loBet);
	_parser0.parseUINT32(hiBet);
	_parser0.parseUINT32(ante);
	_parser0.parseUINT32(cap);
	_parser0.parseStringP(specialName);
	_parser0.parseStringP(currency);
	_parser0.parseUINT32(minChipsLimit);
	_parser0.parseUINT32(maxBuyIn);
	_parser0.parseBYTE(icon);
	_parser0.parseBYTE(filter);
	_parser0.parseBOOL(countryRestrictionInverted);
	restrictedCountries.parseMsg(_parser0);
	_parser0.parseUINT32(scalePM);
	_parser0.parseUINT32(defaultBuyIn);
	_parser0.parseUINT64(tableFlags2);
	_parser0.parseBOOL(isTableStarter);
	_parser0.parseUINT32(brandMask);
	_parser0.parseINT32(poolBlockMinHands);
	_parser0.parseUINT32(tableTypeId);
	if(_parser0.parseEnded()) return;
	tableStakes.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	variableAntes.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	visibilityMaskEx.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT32(seatFinderId);
}

/*static*/ void MLobbyNG::cli::TableStaticDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT64 tableId; _parser0.parseUINT64(tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "serverObject"); size_t szServerObject = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObject", szServerObject, _checker, __FILE__, __LINE__);
	UINT32 clubId; _parser0.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	BYTE isOneOnOne; _parser0.parseBYTE(isOneOnOne);
	AtfValidator::validateInt(_descr, "isOneOnOne", isOneOnOne, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser0.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser0.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE maxPlayers; _parser0.parseBYTE(maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	UINT32 visibilityMask; _parser0.parseUINT32(visibilityMask);
	AtfValidator::validateInt(_descr, "visibilityMask", visibilityMask, _checker, __FILE__, __LINE__);
	UINT32 tableFlags; _parser0.parseUINT32(tableFlags);
	AtfValidator::validateInt(_descr, "tableFlags", tableFlags, _checker, __FILE__, __LINE__);
	UINT32 tableInstanceFlags; _parser0.parseUINT32(tableInstanceFlags);
	AtfValidator::validateInt(_descr, "tableInstanceFlags", tableInstanceFlags, _checker, __FILE__, __LINE__);
	UINT16 chatLang; _parser0.parseUINT16(chatLang);
	AtfValidator::validateInt(_descr, "chatLang", chatLang, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	UINT32 loBet; _parser0.parseUINT32(loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	UINT32 hiBet; _parser0.parseUINT32(hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	UINT32 ante; _parser0.parseUINT32(ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	UINT32 cap; _parser0.parseUINT32(cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "specialName"); size_t szSpecialName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "specialName", szSpecialName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 minChipsLimit; _parser0.parseUINT32(minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	UINT32 maxBuyIn; _parser0.parseUINT32(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	BYTE icon; _parser0.parseBYTE(icon);
	AtfValidator::validateInt(_descr, "icon", icon, _checker, __FILE__, __LINE__);
	BYTE filter; _parser0.parseBYTE(filter);
	AtfValidator::validateInt(_descr, "filter", filter, _checker, __FILE__, __LINE__);
	bool countryRestrictionInverted; _parser0.parseBOOL(countryRestrictionInverted);
	AtfValidator::validateInt(_descr, "countryRestrictionInverted", countryRestrictionInverted, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szRestrictedCountries = ThinAtf::LAtfVector< PString , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("restrictedCountries"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "restrictedCountries", szRestrictedCountries, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser0.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT32 defaultBuyIn; _parser0.parseUINT32(defaultBuyIn);
	AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	UINT64 tableFlags2; _parser0.parseUINT64(tableFlags2);
	AtfValidator::validateUint(_descr, "tableFlags2", tableFlags2, _checker, __FILE__, __LINE__);
	bool isTableStarter; _parser0.parseBOOL(isTableStarter);
	AtfValidator::validateInt(_descr, "isTableStarter", isTableStarter, _checker, __FILE__, __LINE__);
	UINT32 brandMask; _parser0.parseUINT32(brandMask);
	AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
	INT32 poolBlockMinHands; _parser0.parseINT32(poolBlockMinHands);
	AtfValidator::validateInt(_descr, "poolBlockMinHands", poolBlockMinHands, _checker, __FILE__, __LINE__);
	UINT32 tableTypeId; _parser0.parseUINT32(tableTypeId);
	AtfValidator::validateInt(_descr, "tableTypeId", tableTypeId, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	TableCommonThin::TableStakes::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tableStakes"), _fieldsWithUnparsedContent);
	if(_parser0.parseEnded()) return;
	int szVariableAntes = ThinAtf::LAtfVector< INT64, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("variableAntes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "variableAntes", szVariableAntes, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("visibilityMaskEx"), _fieldsWithUnparsedContent);
	if(_parser0.parseEnded()) return;
	UINT32 seatFinderId; _parser0.parseUINT32(seatFinderId);
	AtfValidator::validateInt(_descr, "seatFinderId", seatFinderId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TableData
//=================================================================

MLobbyNG::cli::TableData::TableData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::TableData::TableData(TableData&& _o)
	: staticData(std::move(_o.staticData))
{
}

MLobbyNG::cli::TableData& MLobbyNG::cli::TableData::operator=(TableData&& _o)
{
	if(this != &_o)
	{
		staticData = std::move(_o.staticData);
	}
	return *this;
}

#endif

void MLobbyNG::cli::TableData::clear()
{
	staticData.clear();
}

bool MLobbyNG::cli::TableData::equals(const TableData& _o) const
{
	return staticData.equals(_o.staticData);
}

const char *MLobbyNG::cli::TableData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("staticData=");
	staticData.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::TableData::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(TableData())) // not empty
	{
		staticData.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::TableData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	staticData.parseMsg(_parser0);
}

/*static*/ void MLobbyNG::cli::TableData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	TableStaticDataStruct::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("staticData"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SuggestedGames2SelectionFilter
//=================================================================

MLobbyNG::cli::SuggestedGames2SelectionFilter::SuggestedGames2SelectionFilter()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::SuggestedGames2SelectionFilter::SuggestedGames2SelectionFilter(SuggestedGames2SelectionFilter&& _o)
	: locale(std::move(_o.locale))
	, tournMedianValue(std::move(_o.tournMedianValue))
	, sngMedianValue(std::move(_o.sngMedianValue))
	, ringMedianValue(std::move(_o.ringMedianValue))
	, tournFilters(std::move(_o.tournFilters))
	, tableFilters(std::move(_o.tableFilters))
	, sngFilters(std::move(_o.sngFilters))
{
}

MLobbyNG::cli::SuggestedGames2SelectionFilter& MLobbyNG::cli::SuggestedGames2SelectionFilter::operator=(SuggestedGames2SelectionFilter&& _o)
{
	if(this != &_o)
	{
		locale = std::move(_o.locale);
		tournMedianValue = std::move(_o.tournMedianValue);
		sngMedianValue = std::move(_o.sngMedianValue);
		ringMedianValue = std::move(_o.ringMedianValue);
		tournFilters = std::move(_o.tournFilters);
		tableFilters = std::move(_o.tableFilters);
		sngFilters = std::move(_o.sngFilters);
	}
	return *this;
}

#endif

void MLobbyNG::cli::SuggestedGames2SelectionFilter::clear()
{
	locale = 0;
	tournMedianValue = 0;
	sngMedianValue = 0;
	ringMedianValue = 0;
	tournFilters.clear();
	tableFilters.clear();
	sngFilters.clear();
}

bool MLobbyNG::cli::SuggestedGames2SelectionFilter::equals(const SuggestedGames2SelectionFilter& _o) const
{
	return locale == _o.locale &&
		tournMedianValue == _o.tournMedianValue &&
		sngMedianValue == _o.sngMedianValue &&
		ringMedianValue == _o.ringMedianValue &&
		tournFilters.equals(_o.tournFilters) &&
		tableFilters.equals(_o.tableFilters) &&
		sngFilters.equals(_o.sngFilters);
}

const char *MLobbyNG::cli::SuggestedGames2SelectionFilter::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("tournMedianValue=");
	_buf.appendInt64(tournMedianValue);
	_buf.append(',');
	_buf.append("sngMedianValue=");
	_buf.appendInt64(sngMedianValue);
	_buf.append(',');
	_buf.append("ringMedianValue=");
	_buf.appendInt64(ringMedianValue);
	_buf.append(',');
	_buf.append("tournFilters=");
	tournFilters.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableFilters=");
	tableFilters.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sngFilters=");
	sngFilters.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::SuggestedGames2SelectionFilter::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(SuggestedGames2SelectionFilter())) // not empty
	{
		_body.composeUINT32(locale);
		_body.composeINT64(tournMedianValue);
		_body.composeINT64(sngMedianValue);
		_body.composeINT64(ringMedianValue);
		tournFilters.composeMsg(_body);
		tableFilters.composeMsg(_body);
		sngFilters.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::SuggestedGames2SelectionFilter::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(locale);
	_parser0.parseINT64(tournMedianValue);
	_parser0.parseINT64(sngMedianValue);
	_parser0.parseINT64(ringMedianValue);
	tournFilters.parseMsg(_parser0);
	tableFilters.parseMsg(_parser0);
	sngFilters.parseMsg(_parser0);
}

/*static*/ void MLobbyNG::cli::SuggestedGames2SelectionFilter::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 locale; _parser0.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	INT64 tournMedianValue; _parser0.parseINT64(tournMedianValue);
	AtfValidator::validateInt(_descr, "tournMedianValue", tournMedianValue, _checker, __FILE__, __LINE__);
	INT64 sngMedianValue; _parser0.parseINT64(sngMedianValue);
	AtfValidator::validateInt(_descr, "sngMedianValue", sngMedianValue, _checker, __FILE__, __LINE__);
	INT64 ringMedianValue; _parser0.parseINT64(ringMedianValue);
	AtfValidator::validateInt(_descr, "ringMedianValue", ringMedianValue, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTournFilters = ThinAtf::LAtfVector< TournSelectionFilter, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tournFilters"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "tournFilters", szTournFilters, 10, _checker, __FILE__, __LINE__);
	int szTableFilters = ThinAtf::LAtfVector< TableSelectionFilter, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tableFilters"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "tableFilters", szTableFilters, 10, _checker, __FILE__, __LINE__);
	int szSngFilters = ThinAtf::LAtfVector< SngSelectionFilter, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("sngFilters"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "sngFilters", szSngFilters, 10, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    FilterGamesSelectionFilter
//=================================================================

MLobbyNG::cli::FilterGamesSelectionFilter::FilterGamesSelectionFilter()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::FilterGamesSelectionFilter::FilterGamesSelectionFilter(FilterGamesSelectionFilter&& _o)
	: locale(std::move(_o.locale))
	, tournFilters(std::move(_o.tournFilters))
	, tableFilters(std::move(_o.tableFilters))
	, sngFilters(std::move(_o.sngFilters))
{
}

MLobbyNG::cli::FilterGamesSelectionFilter& MLobbyNG::cli::FilterGamesSelectionFilter::operator=(FilterGamesSelectionFilter&& _o)
{
	if(this != &_o)
	{
		locale = std::move(_o.locale);
		tournFilters = std::move(_o.tournFilters);
		tableFilters = std::move(_o.tableFilters);
		sngFilters = std::move(_o.sngFilters);
	}
	return *this;
}

#endif

void MLobbyNG::cli::FilterGamesSelectionFilter::clear()
{
	locale = 0;
	tournFilters.clear();
	tableFilters.clear();
	sngFilters.clear();
}

bool MLobbyNG::cli::FilterGamesSelectionFilter::equals(const FilterGamesSelectionFilter& _o) const
{
	return locale == _o.locale &&
		tournFilters.equals(_o.tournFilters) &&
		tableFilters.equals(_o.tableFilters) &&
		sngFilters.equals(_o.sngFilters);
}

const char *MLobbyNG::cli::FilterGamesSelectionFilter::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("tournFilters=");
	tournFilters.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableFilters=");
	tableFilters.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sngFilters=");
	sngFilters.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::FilterGamesSelectionFilter::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(FilterGamesSelectionFilter())) // not empty
	{
		_body.composeUINT32(locale);
		tournFilters.composeMsg(_body);
		tableFilters.composeMsg(_body);
		sngFilters.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::FilterGamesSelectionFilter::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(locale);
	tournFilters.parseMsg(_parser0);
	tableFilters.parseMsg(_parser0);
	sngFilters.parseMsg(_parser0);
}

/*static*/ void MLobbyNG::cli::FilterGamesSelectionFilter::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 locale; _parser0.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTournFilters = ThinAtf::LAtfVector< TournSelectionFilter, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tournFilters"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "tournFilters", szTournFilters, 10, _checker, __FILE__, __LINE__);
	int szTableFilters = ThinAtf::LAtfVector< TableSelectionFilter, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tableFilters"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "tableFilters", szTableFilters, 10, _checker, __FILE__, __LINE__);
	int szSngFilters = ThinAtf::LAtfVector< SngSelectionFilter, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("sngFilters"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "sngFilters", szSngFilters, 10, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    FilterGamesResultCriteria
//=================================================================

MLobbyNG::cli::FilterGamesResultCriteria::FilterGamesResultCriteria()
{
	clear();
}

void MLobbyNG::cli::FilterGamesResultCriteria::clear()
{
	maxItems = 0;
}

bool MLobbyNG::cli::FilterGamesResultCriteria::equals(const FilterGamesResultCriteria& _o) const
{
	return maxItems == _o.maxItems;
}

const char *MLobbyNG::cli::FilterGamesResultCriteria::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("maxItems=");
	_buf.appendUint(maxItems);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::FilterGamesResultCriteria::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(FilterGamesResultCriteria())) // not empty
	{
		_body.composeUINT32(maxItems);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::FilterGamesResultCriteria::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(maxItems);
}

/*static*/ void MLobbyNG::cli::FilterGamesResultCriteria::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 maxItems; _parser0.parseUINT32(maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    NameSearchSelectionFilter
//=================================================================

MLobbyNG::cli::NameSearchSelectionFilter::NameSearchSelectionFilter()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::NameSearchSelectionFilter::NameSearchSelectionFilter(NameSearchSelectionFilter&& _o)
	: locale(std::move(_o.locale))
	, name(std::move(_o.name))
	, country(std::move(_o.country))
	, isPM(std::move(_o.isPM))
{
}

MLobbyNG::cli::NameSearchSelectionFilter& MLobbyNG::cli::NameSearchSelectionFilter::operator=(NameSearchSelectionFilter&& _o)
{
	if(this != &_o)
	{
		locale = std::move(_o.locale);
		name = std::move(_o.name);
		country = std::move(_o.country);
		isPM = std::move(_o.isPM);
	}
	return *this;
}

#endif

void MLobbyNG::cli::NameSearchSelectionFilter::clear()
{
	locale = 0;
	name.clear();
	country.clear();
	isPM = false;
}

bool MLobbyNG::cli::NameSearchSelectionFilter::equals(const NameSearchSelectionFilter& _o) const
{
	return locale == _o.locale &&
		name.equals(_o.name) &&
		country.equals(_o.country) &&
		isPM == _o.isPM;
}

const char *MLobbyNG::cli::NameSearchSelectionFilter::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("isPM=");
	_buf.appendUint(isPM);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::NameSearchSelectionFilter::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(NameSearchSelectionFilter())) // not empty
	{
		_body.composeUINT32(locale);
		_body.composeString(name);
		_body.composeString(country);
		_body.composeBOOL(isPM);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::NameSearchSelectionFilter::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(locale);
	_parser0.parseStringP(name);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(country);
	if(_parser0.parseEnded()) return;
	_parser0.parseBOOL(isPM);
}

/*static*/ void MLobbyNG::cli::NameSearchSelectionFilter::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 locale; _parser0.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "name", szName, 50, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, 7, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	bool isPM; _parser0.parseBOOL(isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    OrderedTicketTournInfo
//=================================================================

MLobbyNG::cli::OrderedTicketTournInfo::OrderedTicketTournInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::OrderedTicketTournInfo::OrderedTicketTournInfo(OrderedTicketTournInfo&& _o)
	: ticketName(std::move(_o.ticketName))
	, tourns(std::move(_o.tourns))
	, sngTypes(std::move(_o.sngTypes))
	, sagTypes(std::move(_o.sagTypes))
	, gameOrder(std::move(_o.gameOrder))
{
}

MLobbyNG::cli::OrderedTicketTournInfo& MLobbyNG::cli::OrderedTicketTournInfo::operator=(OrderedTicketTournInfo&& _o)
{
	if(this != &_o)
	{
		ticketName = std::move(_o.ticketName);
		tourns = std::move(_o.tourns);
		sngTypes = std::move(_o.sngTypes);
		sagTypes = std::move(_o.sagTypes);
		gameOrder = std::move(_o.gameOrder);
	}
	return *this;
}

#endif

void MLobbyNG::cli::OrderedTicketTournInfo::clear()
{
	ticketName.clear();
	tourns.clear();
	sngTypes.clear();
	sagTypes.clear();
	gameOrder.clear();
}

bool MLobbyNG::cli::OrderedTicketTournInfo::equals(const OrderedTicketTournInfo& _o) const
{
	return ticketName.equals(_o.ticketName) &&
		tourns.equals(_o.tourns) &&
		sngTypes.equals(_o.sngTypes) &&
		sagTypes.equals(_o.sagTypes) &&
		gameOrder.equals(_o.gameOrder);
}

const char *MLobbyNG::cli::OrderedTicketTournInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("ticketName=");
	_buf.append(ticketName);
	_buf.append(',');
	_buf.append("tourns=");
	tourns.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sngTypes=");
	sngTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sagTypes=");
	sagTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameOrder=");
	gameOrder.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::OrderedTicketTournInfo::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(OrderedTicketTournInfo())) // not empty
	{
		_body.composeString(ticketName);
		tourns.composeMsg(_body);
		sngTypes.composeMsg(_body);
		sagTypes.composeMsg(_body);
		gameOrder.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::OrderedTicketTournInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(ticketName);
	tourns.parseMsg(_parser0);
	sngTypes.parseMsg(_parser0);
	sagTypes.parseMsg(_parser0);
	gameOrder.parseMsg(_parser0);
}

/*static*/ void MLobbyNG::cli::OrderedTicketTournInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "ticketName"); size_t szTicketName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "ticketName", szTicketName, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTourns = ThinAtf::LAtfVector< TournDataStruct, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
	int szSngTypes = ThinAtf::LAtfVector< SngDataStruct, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("sngTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sngTypes", szSngTypes, _checker, __FILE__, __LINE__);
	int szSagTypes = ThinAtf::LAtfVector< SagDataStruct, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("sagTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sagTypes", szSagTypes, _checker, __FILE__, __LINE__);
	int szGameOrder = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("gameOrder"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "gameOrder", szGameOrder, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TicketTournRequestData
//=================================================================

MLobbyNG::cli::TicketTournRequestData::TicketTournRequestData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::TicketTournRequestData::TicketTournRequestData(TicketTournRequestData&& _o)
	: ticketNames(std::move(_o.ticketNames))
	, gameCategoryMask(std::move(_o.gameCategoryMask))
	, ticketTournRequestMask(std::move(_o.ticketTournRequestMask))
	, filter(std::move(_o.filter))
	, activities(std::move(_o.activities))
	, gameMask(std::move(_o.gameMask))
{
}

MLobbyNG::cli::TicketTournRequestData& MLobbyNG::cli::TicketTournRequestData::operator=(TicketTournRequestData&& _o)
{
	if(this != &_o)
	{
		ticketNames = std::move(_o.ticketNames);
		gameCategoryMask = std::move(_o.gameCategoryMask);
		ticketTournRequestMask = std::move(_o.ticketTournRequestMask);
		filter = std::move(_o.filter);
		activities = std::move(_o.activities);
		gameMask = std::move(_o.gameMask);
	}
	return *this;
}

#endif

void MLobbyNG::cli::TicketTournRequestData::clear()
{
	ticketNames.clear();
	gameCategoryMask = 0;
	ticketTournRequestMask = 0;
	filter.clear();
	activities.clear();
	gameMask = (2*(UINT64)NGGameTypes::NGGame_Last-1);
}

bool MLobbyNG::cli::TicketTournRequestData::equals(const TicketTournRequestData& _o) const
{
	return ticketNames.equals(_o.ticketNames) &&
		gameCategoryMask == _o.gameCategoryMask &&
		ticketTournRequestMask == _o.ticketTournRequestMask &&
		filter.equals(_o.filter) &&
		activities.equals(_o.activities) &&
		gameMask == _o.gameMask;
}

const char *MLobbyNG::cli::TicketTournRequestData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("ticketNames=");
	ticketNames.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameCategoryMask=");
	_buf.appendUint(gameCategoryMask);
	_buf.append(',');
	_buf.append("ticketTournRequestMask=");
	_buf.appendUint(ticketTournRequestMask);
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("activities=");
	activities.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameMask=");
	_buf.appendUint64(gameMask);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::TicketTournRequestData::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(TicketTournRequestData())) // not empty
	{
		ticketNames.composeMsg(_body);
		_body.composeUINT32(gameCategoryMask);
		_body.composeUINT32(ticketTournRequestMask);
		filter.composeMsg(_body);
		activities.composeMsg(_body);
		_body.composeUINT64(gameMask);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::TicketTournRequestData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	ticketNames.parseMsg(_parser0);
	_parser0.parseUINT32(gameCategoryMask);
	_parser0.parseUINT32(ticketTournRequestMask);
	filter.parseMsg(_parser0);
	activities.parseMsg(_parser0);
	_parser0.parseUINT64(gameMask);
}

/*static*/ void MLobbyNG::cli::TicketTournRequestData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szTicketNames = ThinAtf::LAtfVector< PString, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("ticketNames"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "ticketNames", szTicketNames, 100, _checker, __FILE__, __LINE__);
	UINT32 gameCategoryMask; _parser0.parseUINT32(gameCategoryMask);
	AtfValidator::validateIntMax(_descr, "gameCategoryMask", gameCategoryMask, (2*GameCategory_Last-1), _checker, __FILE__, __LINE__);
	UINT32 ticketTournRequestMask; _parser0.parseUINT32(ticketTournRequestMask);
	AtfValidator::validateIntMax(_descr, "ticketTournRequestMask", ticketTournRequestMask, (2*TicketTournRequest_Last-1), _checker, __FILE__, __LINE__);
	GameListFilter::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	int szActivities = ThinAtf::LAtfVector< ActivityStruct, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("activities"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "activities", szActivities, 100, _checker, __FILE__, __LINE__);
	UINT64 gameMask; _parser0.parseUINT64(gameMask);
	AtfValidator::validateUintMax(_descr, "gameMask", gameMask, (2*(UINT64)NGGameTypes::NGGame_Last-1), _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    BrandedLobbyInfo
//=================================================================

MLobbyNG::cli::BrandedLobbyInfo::BrandedLobbyInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::BrandedLobbyInfo::BrandedLobbyInfo(BrandedLobbyInfo&& _o)
	: lobbyName(std::move(_o.lobbyName))
	, displayName(std::move(_o.displayName))
	, tournFilters(std::move(_o.tournFilters))
	, tableFilters(std::move(_o.tableFilters))
	, sngFilters(std::move(_o.sngFilters))
	, gameCount(std::move(_o.gameCount))
	, playerCount(std::move(_o.playerCount))
{
}

MLobbyNG::cli::BrandedLobbyInfo& MLobbyNG::cli::BrandedLobbyInfo::operator=(BrandedLobbyInfo&& _o)
{
	if(this != &_o)
	{
		lobbyName = std::move(_o.lobbyName);
		displayName = std::move(_o.displayName);
		tournFilters = std::move(_o.tournFilters);
		tableFilters = std::move(_o.tableFilters);
		sngFilters = std::move(_o.sngFilters);
		gameCount = std::move(_o.gameCount);
		playerCount = std::move(_o.playerCount);
	}
	return *this;
}

#endif

void MLobbyNG::cli::BrandedLobbyInfo::clear()
{
	lobbyName.clear();
	displayName.clear();
	tournFilters.clear();
	tableFilters.clear();
	sngFilters.clear();
	gameCount = 0;
	playerCount = 0;
}

bool MLobbyNG::cli::BrandedLobbyInfo::equals(const BrandedLobbyInfo& _o) const
{
	return lobbyName.equals(_o.lobbyName) &&
		displayName.equals(_o.displayName) &&
		tournFilters.equals(_o.tournFilters) &&
		tableFilters.equals(_o.tableFilters) &&
		sngFilters.equals(_o.sngFilters) &&
		gameCount == _o.gameCount &&
		playerCount == _o.playerCount;
}

const char *MLobbyNG::cli::BrandedLobbyInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("lobbyName=");
	_buf.append(lobbyName);
	_buf.append(',');
	_buf.append("displayName=");
	_buf.append(displayName);
	_buf.append(',');
	_buf.append("tournFilters=");
	tournFilters.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableFilters=");
	tableFilters.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sngFilters=");
	sngFilters.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameCount=");
	_buf.appendInt(gameCount);
	_buf.append(',');
	_buf.append("playerCount=");
	_buf.appendInt(playerCount);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::BrandedLobbyInfo::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(BrandedLobbyInfo())) // not empty
	{
		_body.composeString(lobbyName);
		_body.composeString(displayName);
		tournFilters.composeMsg(_body);
		tableFilters.composeMsg(_body);
		sngFilters.composeMsg(_body);
		_body.composeINT32(gameCount);
		_body.composeINT32(playerCount);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::BrandedLobbyInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(lobbyName);
	_parser0.parseStringP(displayName);
	tournFilters.parseMsg(_parser0);
	tableFilters.parseMsg(_parser0);
	sngFilters.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT32(gameCount);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT32(playerCount);
}

/*static*/ void MLobbyNG::cli::BrandedLobbyInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "lobbyName"); size_t szLobbyName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "lobbyName", szLobbyName, 100, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "displayName"); size_t szDisplayName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "displayName", szDisplayName, 200, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTournFilters = ThinAtf::LAtfVector< TournSelectionFilter, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tournFilters"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "tournFilters", szTournFilters, 10, _checker, __FILE__, __LINE__);
	int szTableFilters = ThinAtf::LAtfVector< TableSelectionFilter, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tableFilters"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "tableFilters", szTableFilters, 10, _checker, __FILE__, __LINE__);
	int szSngFilters = ThinAtf::LAtfVector< SngSelectionFilter, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("sngFilters"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "sngFilters", szSngFilters, 10, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT32 gameCount; _parser0.parseINT32(gameCount);
	AtfValidator::validateInt(_descr, "gameCount", gameCount, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT32 playerCount; _parser0.parseINT32(playerCount);
	AtfValidator::validateInt(_descr, "playerCount", playerCount, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    FullBrandedLobbyInfo
//=================================================================

MLobbyNG::cli::FullBrandedLobbyInfo::FullBrandedLobbyInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::FullBrandedLobbyInfo::FullBrandedLobbyInfo(FullBrandedLobbyInfo&& _o)
	: lobbyName(std::move(_o.lobbyName))
	, displayName(std::move(_o.displayName))
	, sites(std::move(_o.sites))
	, tournFilters(std::move(_o.tournFilters))
	, tableFilters(std::move(_o.tableFilters))
	, sngFilters(std::move(_o.sngFilters))
{
}

MLobbyNG::cli::FullBrandedLobbyInfo& MLobbyNG::cli::FullBrandedLobbyInfo::operator=(FullBrandedLobbyInfo&& _o)
{
	if(this != &_o)
	{
		lobbyName = std::move(_o.lobbyName);
		displayName = std::move(_o.displayName);
		sites = std::move(_o.sites);
		tournFilters = std::move(_o.tournFilters);
		tableFilters = std::move(_o.tableFilters);
		sngFilters = std::move(_o.sngFilters);
	}
	return *this;
}

#endif

void MLobbyNG::cli::FullBrandedLobbyInfo::clear()
{
	lobbyName.clear();
	displayName.clear();
	sites.clear();
	tournFilters.clear();
	tableFilters.clear();
	sngFilters.clear();
}

bool MLobbyNG::cli::FullBrandedLobbyInfo::equals(const FullBrandedLobbyInfo& _o) const
{
	return lobbyName.equals(_o.lobbyName) &&
		displayName.equals(_o.displayName) &&
		sites.equals(_o.sites) &&
		tournFilters.equals(_o.tournFilters) &&
		tableFilters.equals(_o.tableFilters) &&
		sngFilters.equals(_o.sngFilters);
}

const char *MLobbyNG::cli::FullBrandedLobbyInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("lobbyName=");
	_buf.append(lobbyName);
	_buf.append(',');
	_buf.append("displayName=");
	ThinAtf::AtfTempl<I18nPString>::ToTraceString(_buf, displayName);
	_buf.append(',');
	_buf.append("sites=");
	sites.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tournFilters=");
	tournFilters.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableFilters=");
	tableFilters.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sngFilters=");
	sngFilters.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::FullBrandedLobbyInfo::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(FullBrandedLobbyInfo())) // not empty
	{
		_body.composeString(lobbyName);
		displayName.compose(_body);
		sites.composeMsg(_body);
		tournFilters.composeMsg(_body);
		tableFilters.composeMsg(_body);
		sngFilters.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::FullBrandedLobbyInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(lobbyName);
	displayName.parse(_parser0);
	sites.parseMsg(_parser0);
	tournFilters.parseMsg(_parser0);
	tableFilters.parseMsg(_parser0);
	sngFilters.parseMsg(_parser0);
}

/*static*/ void MLobbyNG::cli::FullBrandedLobbyInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "lobbyName"); size_t szLobbyName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "lobbyName", szLobbyName, 100, _checker, __FILE__, __LINE__);
	I18nPString displayName; displayName.parse(_parser0);
	PString _descbuf;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("sites"), _fieldsWithUnparsedContent);
	int szTournFilters = ThinAtf::LAtfVector< TournSelectionFilter, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tournFilters"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "tournFilters", szTournFilters, 10, _checker, __FILE__, __LINE__);
	int szTableFilters = ThinAtf::LAtfVector< TableSelectionFilter, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tableFilters"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "tableFilters", szTableFilters, 10, _checker, __FILE__, __LINE__);
	int szSngFilters = ThinAtf::LAtfVector< SngSelectionFilter, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("sngFilters"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "sngFilters", szSngFilters, 10, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ResultRanges
//=================================================================

MLobbyNG::cli::ResultRanges::ResultRanges()
{
	clear();
}

void MLobbyNG::cli::ResultRanges::clear()
{
	gameMask = 0;
	tableSizeMask = 0;
	speedMask = 0;
	tournVariantMask = 0;
	minNumPlayers = 0;
	maxNumPlayers = 0;
	minBuyIn = 0;
	maxBuyIn = 0;
	tournStateMask = 0;
	gameCategoryMask = 0;
}

bool MLobbyNG::cli::ResultRanges::equals(const ResultRanges& _o) const
{
	return gameMask == _o.gameMask &&
		tableSizeMask == _o.tableSizeMask &&
		speedMask == _o.speedMask &&
		tournVariantMask == _o.tournVariantMask &&
		minNumPlayers == _o.minNumPlayers &&
		maxNumPlayers == _o.maxNumPlayers &&
		minBuyIn == _o.minBuyIn &&
		maxBuyIn == _o.maxBuyIn &&
		tournStateMask == _o.tournStateMask &&
		gameCategoryMask == _o.gameCategoryMask;
}

const char *MLobbyNG::cli::ResultRanges::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("gameMask=");
	_buf.appendUint64(gameMask);
	_buf.append(',');
	_buf.append("tableSizeMask=");
	_buf.appendUint(tableSizeMask);
	_buf.append(',');
	_buf.append("speedMask=");
	_buf.appendUint(speedMask);
	_buf.append(',');
	_buf.append("tournVariantMask=");
	_buf.appendUint(tournVariantMask);
	_buf.append(',');
	_buf.append("minNumPlayers=");
	_buf.appendInt(minNumPlayers);
	_buf.append(',');
	_buf.append("maxNumPlayers=");
	_buf.appendInt(maxNumPlayers);
	_buf.append(',');
	_buf.append("minBuyIn=");
	_buf.appendInt64(minBuyIn);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendInt64(maxBuyIn);
	_buf.append(',');
	_buf.append("tournStateMask=");
	_buf.appendUint(tournStateMask);
	_buf.append(',');
	_buf.append("gameCategoryMask=");
	_buf.appendUint(gameCategoryMask);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::ResultRanges::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(ResultRanges())) // not empty
	{
		_body.composeUINT64(gameMask);
		_body.composeUINT32(tableSizeMask);
		_body.composeUINT32(speedMask);
		_body.composeUINT32(tournVariantMask);
		_body.composeINT32(minNumPlayers);
		_body.composeINT32(maxNumPlayers);
		_body.composeINT64(minBuyIn);
		_body.composeINT64(maxBuyIn);
		_body.composeUINT32(tournStateMask);
		_body.composeUINT32(gameCategoryMask);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::ResultRanges::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT64(gameMask);
	_parser0.parseUINT32(tableSizeMask);
	_parser0.parseUINT32(speedMask);
	_parser0.parseUINT32(tournVariantMask);
	_parser0.parseINT32(minNumPlayers);
	_parser0.parseINT32(maxNumPlayers);
	_parser0.parseINT64(minBuyIn);
	_parser0.parseINT64(maxBuyIn);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT32(tournStateMask);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT32(gameCategoryMask);
}

/*static*/ void MLobbyNG::cli::ResultRanges::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT64 gameMask; _parser0.parseUINT64(gameMask);
	AtfValidator::validateUintMax(_descr, "gameMask", gameMask, (2*(UINT64)NGGameTypes::NGGame_Last-1), _checker, __FILE__, __LINE__);
	UINT32 tableSizeMask; _parser0.parseUINT32(tableSizeMask);
	AtfValidator::validateIntMax(_descr, "tableSizeMask", tableSizeMask, (2*NGMaxTableSize_Last-1), _checker, __FILE__, __LINE__);
	UINT32 speedMask; _parser0.parseUINT32(speedMask);
	AtfValidator::validateIntMax(_descr, "speedMask", speedMask, (2*NGTournSpeed_Last-1), _checker, __FILE__, __LINE__);
	UINT32 tournVariantMask; _parser0.parseUINT32(tournVariantMask);
	AtfValidator::validateIntMax(_descr, "tournVariantMask", tournVariantMask, (2*NGTournVariant_Last-1), _checker, __FILE__, __LINE__);
	INT32 minNumPlayers; _parser0.parseINT32(minNumPlayers);
	AtfValidator::validateIntMax(_descr, "minNumPlayers", minNumPlayers, 1000000000, _checker, __FILE__, __LINE__);
	INT32 maxNumPlayers; _parser0.parseINT32(maxNumPlayers);
	AtfValidator::validateIntMax(_descr, "maxNumPlayers", maxNumPlayers, 1000000000, _checker, __FILE__, __LINE__);
	INT64 minBuyIn; _parser0.parseINT64(minBuyIn);
	AtfValidator::validateInt(_descr, "minBuyIn", minBuyIn, _checker, __FILE__, __LINE__);
	INT64 maxBuyIn; _parser0.parseINT64(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	UINT32 tournStateMask; _parser0.parseUINT32(tournStateMask);
	AtfValidator::validateIntMax(_descr, "tournStateMask", tournStateMask, (2*NGTournState_Last-1), _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	UINT32 gameCategoryMask; _parser0.parseUINT32(gameCategoryMask);
	AtfValidator::validateIntMax(_descr, "gameCategoryMask", gameCategoryMask, (2*GameCategory_Last-1), _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    FindTournsByRefFilter
//=================================================================

MLobbyNG::cli::FindTournsByRefFilter::FindTournsByRefFilter()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::FindTournsByRefFilter::FindTournsByRefFilter(FindTournsByRefFilter&& _o)
	: internalRef(std::move(_o.internalRef))
	, siteId(std::move(_o.siteId))
	, brandId(std::move(_o.brandId))
	, country(std::move(_o.country))
	, usePMFlag(std::move(_o.usePMFlag))
	, isPM(std::move(_o.isPM))
	, locale(std::move(_o.locale))
{
}

MLobbyNG::cli::FindTournsByRefFilter& MLobbyNG::cli::FindTournsByRefFilter::operator=(FindTournsByRefFilter&& _o)
{
	if(this != &_o)
	{
		internalRef = std::move(_o.internalRef);
		siteId = std::move(_o.siteId);
		brandId = std::move(_o.brandId);
		country = std::move(_o.country);
		usePMFlag = std::move(_o.usePMFlag);
		isPM = std::move(_o.isPM);
		locale = std::move(_o.locale);
	}
	return *this;
}

#endif

void MLobbyNG::cli::FindTournsByRefFilter::clear()
{
	internalRef.clear();
	siteId = 0;
	brandId = BrandType_AllDefined;
	country.clear();
	usePMFlag = false;
	isPM = false;
	locale = 0;
}

bool MLobbyNG::cli::FindTournsByRefFilter::equals(const FindTournsByRefFilter& _o) const
{
	return internalRef.equals(_o.internalRef) &&
		siteId == _o.siteId &&
		brandId == _o.brandId &&
		country.equals(_o.country) &&
		usePMFlag == _o.usePMFlag &&
		isPM == _o.isPM &&
		locale == _o.locale;
}

const char *MLobbyNG::cli::FindTournsByRefFilter::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("internalRef=");
	_buf.append(internalRef);
	_buf.append(',');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("brandId=");
	_buf.appendUint(brandId);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("usePMFlag=");
	_buf.appendUint(usePMFlag);
	_buf.append(',');
	_buf.append("isPM=");
	_buf.appendUint(isPM);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append('}');
	return _buf.c_str();
}

void MLobbyNG::cli::FindTournsByRefFilter::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(FindTournsByRefFilter())) // not empty
	{
		_body.composeString(internalRef);
		_body.composeUINT32(siteId);
		_body.composeUINT32(brandId);
		_body.composeString(country);
		_body.composeBOOL(usePMFlag);
		_body.composeBOOL(isPM);
		_body.composeUINT32(locale);
	}

	_msg.composeMsgBody(_body);
}

void MLobbyNG::cli::FindTournsByRefFilter::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(internalRef);
	_parser0.parseUINT32(siteId);
	_parser0.parseUINT32(brandId);
	_parser0.parseStringP(country);
	_parser0.parseBOOL(usePMFlag);
	_parser0.parseBOOL(isPM);
	_parser0.parseUINT32(locale);
}

/*static*/ void MLobbyNG::cli::FindTournsByRefFilter::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "internalRef"); size_t szInternalRef = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "internalRef", szInternalRef, 100, _checker, __FILE__, __LINE__);
	UINT32 siteId; _parser0.parseUINT32(siteId);
	AtfValidator::validateInt(_descr, "siteId", siteId, _checker, __FILE__, __LINE__);
	UINT32 brandId; _parser0.parseUINT32(brandId);
	AtfValidator::validateInt(_descr, "brandId", brandId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, 20, _checker, __FILE__, __LINE__);
	bool usePMFlag; _parser0.parseBOOL(usePMFlag);
	AtfValidator::validateInt(_descr, "usePMFlag", usePMFlag, _checker, __FILE__, __LINE__);
	bool isPM; _parser0.parseBOOL(isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser0.parseUINT32(locale);
	AtfValidator::validateInt(_descr, "locale", locale, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_GET_GAME_LIST
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST::Protocol_MSG_MLOBBYNG_GET_GAME_LIST()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST::Protocol_MSG_MLOBBYNG_GET_GAME_LIST(Protocol_MSG_MLOBBYNG_GET_GAME_LIST&& _o)
	: filter(std::move(_o.filter))
	, activities(std::move(_o.activities))
	, licenseId(std::move(_o.licenseId))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST::operator=(Protocol_MSG_MLOBBYNG_GET_GAME_LIST&& _o)
{
	if(this != &_o)
	{
		filter = std::move(_o.filter);
		activities = std::move(_o.activities);
		licenseId = std::move(_o.licenseId);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST::clear()
{
	filter.clear();
	activities.clear();
	licenseId = 0;
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST::equals(const Protocol_MSG_MLOBBYNG_GET_GAME_LIST& _o) const
{
	return filter.equals(_o.filter) &&
		activities.equals(_o.activities) &&
		licenseId == _o.licenseId;
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_GET_GAME_LIST).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("activities=");
	activities.toTraceString(_buf);
	_buf.append(',');
	_buf.append("licenseId=");
	_buf.appendUint(licenseId);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST::composeMsg(CommMsgBody& _msg) const
{
	filter.composeMsg(_msg);
	activities.composeMsg(_msg);
	_msg.composeUINT32(licenseId);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	activities.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(licenseId);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_GET_GAME_LIST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	GameListFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	int szActivities = ThinAtf::LAtfVector< ActivityStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("activities"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "activities", szActivities, 100, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 licenseId; _parser.parseUINT32(licenseId);
	AtfValidator::validateIntMax(_descr, "licenseId", licenseId, eLicenceLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY::Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY::Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY(Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY&& _o)
	: tourns(std::move(_o.tourns))
	, tableTypes(std::move(_o.tableTypes))
	, sngTypes(std::move(_o.sngTypes))
	, sagTypes(std::move(_o.sagTypes))
	, zoomTypes(std::move(_o.zoomTypes))
	, seatFinders(std::move(_o.seatFinders))
	, gameOrder(std::move(_o.gameOrder))
	, pppTypes(std::move(_o.pppTypes))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY::operator=(Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY&& _o)
{
	if(this != &_o)
	{
		tourns = std::move(_o.tourns);
		tableTypes = std::move(_o.tableTypes);
		sngTypes = std::move(_o.sngTypes);
		sagTypes = std::move(_o.sagTypes);
		zoomTypes = std::move(_o.zoomTypes);
		seatFinders = std::move(_o.seatFinders);
		gameOrder = std::move(_o.gameOrder);
		pppTypes = std::move(_o.pppTypes);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY::clear()
{
	tourns.clear();
	tableTypes.clear();
	sngTypes.clear();
	sagTypes.clear();
	zoomTypes.clear();
	seatFinders.clear();
	gameOrder.clear();
	pppTypes.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY::equals(const Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY& _o) const
{
	return tourns.equals(_o.tourns) &&
		tableTypes.equals(_o.tableTypes) &&
		sngTypes.equals(_o.sngTypes) &&
		sagTypes.equals(_o.sagTypes) &&
		zoomTypes.equals(_o.zoomTypes) &&
		seatFinders.equals(_o.seatFinders) &&
		gameOrder.equals(_o.gameOrder) &&
		pppTypes.equals(_o.pppTypes);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_GET_GAME_LIST_REPLY).append(")");
	_buf.append(',');
	_buf.append("tourns=");
	tourns.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableTypes=");
	tableTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sngTypes=");
	sngTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sagTypes=");
	sagTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("zoomTypes=");
	zoomTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("seatFinders=");
	seatFinders.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameOrder=");
	gameOrder.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pppTypes=");
	pppTypes.toTraceString(_buf);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY::composeMsg(CommMsgBody& _msg) const
{
	tourns.composeMsg(_msg);
	tableTypes.composeMsg(_msg);
	sngTypes.composeMsg(_msg);
	sagTypes.composeMsg(_msg);
	zoomTypes.composeMsg(_msg);
	seatFinders.composeMsg(_msg);
	gameOrder.composeMsg(_msg);
	pppTypes.composeMsg(_msg);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY::parseMsg(CommMsgParser& _parser)
{
	tourns.parseMsg(_parser);
	tableTypes.parseMsg(_parser);
	sngTypes.parseMsg(_parser);
	sagTypes.parseMsg(_parser);
	zoomTypes.parseMsg(_parser);
	seatFinders.parseMsg(_parser);
	gameOrder.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	pppTypes.parseMsg(_parser);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_GET_GAME_LIST_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTourns = ThinAtf::LAtfVector< TournDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
	int szTableTypes = ThinAtf::LAtfVector< TableDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tableTypes", szTableTypes, _checker, __FILE__, __LINE__);
	int szSngTypes = ThinAtf::LAtfVector< SngDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sngTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sngTypes", szSngTypes, _checker, __FILE__, __LINE__);
	int szSagTypes = ThinAtf::LAtfVector< SagDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sagTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sagTypes", szSagTypes, _checker, __FILE__, __LINE__);
	int szZoomTypes = ThinAtf::LAtfVector< ZoomDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("zoomTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "zoomTypes", szZoomTypes, _checker, __FILE__, __LINE__);
	int szSeatFinders = ThinAtf::LAtfVector< SeatFinderDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("seatFinders"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "seatFinders", szSeatFinders, _checker, __FILE__, __LINE__);
	int szGameOrder = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("gameOrder"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "gameOrder", szGameOrder, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	int szPppTypes = ThinAtf::LAtfVector< PPPDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pppTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "pppTypes", szPppTypes, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS(Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS&& _o)
	: filter(std::move(_o.filter))
	, loginExtraData(std::move(_o.loginExtraData))
	, clientMarkers(std::move(_o.clientMarkers))
	, filterTypeToCount(std::move(_o.filterTypeToCount))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS::operator=(Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS&& _o)
{
	if(this != &_o)
	{
		filter = std::move(_o.filter);
		loginExtraData = std::move(_o.loginExtraData);
		clientMarkers = std::move(_o.clientMarkers);
		filterTypeToCount = std::move(_o.filterTypeToCount);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS::clear()
{
	filter.clear();
	loginExtraData.clear();
	clientMarkers.clear();
	filterTypeToCount = 0;
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS::equals(const Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS& _o) const
{
	return filter.equals(_o.filter) &&
		loginExtraData.equals(_o.loginExtraData) &&
		clientMarkers.equals(_o.clientMarkers) &&
		filterTypeToCount == _o.filterTypeToCount;
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_TABLE_TYPE_COUNTS).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("loginExtraData=");
	loginExtraData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clientMarkers=");
	clientMarkers.toTraceString(_buf);
	_buf.append(',');
	_buf.append("filterTypeToCount=");
	_buf.appendInt(filterTypeToCount);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS::composeMsg(CommMsgBody& _msg) const
{
	filter.composeMsg(_msg);
	loginExtraData.composeMsg(_msg);
	clientMarkers.composeMsg(_msg);
	_msg.composeINT32(filterTypeToCount);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	loginExtraData.parseMsg(_parser);
	clientMarkers.parseMsg(_parser);
	_parser.parseINT32(filterTypeToCount);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_TABLE_TYPE_COUNTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	TableSelectionFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	CommonThin::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("loginExtraData"), _fieldsWithUnparsedContent);
	ClientMarkers::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientMarkers"), _fieldsWithUnparsedContent);
	INT32 filterTypeToCount; _parser.parseINT32(filterTypeToCount);
	AtfValidator::validateIntMax(_descr, "filterTypeToCount", filterTypeToCount, NGFilter_Last, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY(Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY&& _o)
	: filterTypeToCount(std::move(_o.filterTypeToCount))
	, counts(std::move(_o.counts))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY::operator=(Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY&& _o)
{
	if(this != &_o)
	{
		filterTypeToCount = std::move(_o.filterTypeToCount);
		counts = std::move(_o.counts);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY::clear()
{
	filterTypeToCount = 0;
	counts.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY::equals(const Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY& _o) const
{
	return filterTypeToCount == _o.filterTypeToCount &&
		counts.equals(_o.counts);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY).append(")");
	_buf.append(',');
	_buf.append("filterTypeToCount=");
	_buf.appendInt(filterTypeToCount);
	_buf.append(',');
	_buf.append("counts=");
	counts.toTraceString(_buf);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(filterTypeToCount);
	counts.composeMsg(_msg);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(filterTypeToCount);
	counts.parseMsg(_parser);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 filterTypeToCount; _parser.parseINT32(filterTypeToCount);
	AtfValidator::validateInt(_descr, "filterTypeToCount", filterTypeToCount, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szCounts = ThinAtf::LAtfVector< FilterCountInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("counts"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "counts", szCounts, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS(Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS&& _o)
	: filter(std::move(_o.filter))
	, loginExtraData(std::move(_o.loginExtraData))
	, clientMarkers(std::move(_o.clientMarkers))
	, filterTypeToCount(std::move(_o.filterTypeToCount))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS::operator=(Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS&& _o)
{
	if(this != &_o)
	{
		filter = std::move(_o.filter);
		loginExtraData = std::move(_o.loginExtraData);
		clientMarkers = std::move(_o.clientMarkers);
		filterTypeToCount = std::move(_o.filterTypeToCount);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS::clear()
{
	filter.clear();
	loginExtraData.clear();
	clientMarkers.clear();
	filterTypeToCount = 0;
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS::equals(const Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS& _o) const
{
	return filter.equals(_o.filter) &&
		loginExtraData.equals(_o.loginExtraData) &&
		clientMarkers.equals(_o.clientMarkers) &&
		filterTypeToCount == _o.filterTypeToCount;
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_TOURNAMENT_COUNTS).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("loginExtraData=");
	loginExtraData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clientMarkers=");
	clientMarkers.toTraceString(_buf);
	_buf.append(',');
	_buf.append("filterTypeToCount=");
	_buf.appendInt(filterTypeToCount);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS::composeMsg(CommMsgBody& _msg) const
{
	filter.composeMsg(_msg);
	loginExtraData.composeMsg(_msg);
	clientMarkers.composeMsg(_msg);
	_msg.composeINT32(filterTypeToCount);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	loginExtraData.parseMsg(_parser);
	clientMarkers.parseMsg(_parser);
	_parser.parseINT32(filterTypeToCount);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_TOURNAMENT_COUNTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	TournSelectionFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	CommonThin::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("loginExtraData"), _fieldsWithUnparsedContent);
	ClientMarkers::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientMarkers"), _fieldsWithUnparsedContent);
	INT32 filterTypeToCount; _parser.parseINT32(filterTypeToCount);
	AtfValidator::validateIntMax(_descr, "filterTypeToCount", filterTypeToCount, NGFilter_Last, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY(Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY&& _o)
	: filterTypeToCount(std::move(_o.filterTypeToCount))
	, counts(std::move(_o.counts))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY::operator=(Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY&& _o)
{
	if(this != &_o)
	{
		filterTypeToCount = std::move(_o.filterTypeToCount);
		counts = std::move(_o.counts);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY::clear()
{
	filterTypeToCount = 0;
	counts.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY::equals(const Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY& _o) const
{
	return filterTypeToCount == _o.filterTypeToCount &&
		counts.equals(_o.counts);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY).append(")");
	_buf.append(',');
	_buf.append("filterTypeToCount=");
	_buf.appendInt(filterTypeToCount);
	_buf.append(',');
	_buf.append("counts=");
	counts.toTraceString(_buf);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(filterTypeToCount);
	counts.composeMsg(_msg);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(filterTypeToCount);
	counts.parseMsg(_parser);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 filterTypeToCount; _parser.parseINT32(filterTypeToCount);
	AtfValidator::validateInt(_descr, "filterTypeToCount", filterTypeToCount, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szCounts = ThinAtf::LAtfVector< FilterCountInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("counts"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "counts", szCounts, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_SNG_COUNTS
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS::Protocol_MSG_MLOBBYNG_SNG_COUNTS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS::Protocol_MSG_MLOBBYNG_SNG_COUNTS(Protocol_MSG_MLOBBYNG_SNG_COUNTS&& _o)
	: filter(std::move(_o.filter))
	, loginExtraData(std::move(_o.loginExtraData))
	, clientMarkers(std::move(_o.clientMarkers))
	, filterTypeToCount(std::move(_o.filterTypeToCount))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS::operator=(Protocol_MSG_MLOBBYNG_SNG_COUNTS&& _o)
{
	if(this != &_o)
	{
		filter = std::move(_o.filter);
		loginExtraData = std::move(_o.loginExtraData);
		clientMarkers = std::move(_o.clientMarkers);
		filterTypeToCount = std::move(_o.filterTypeToCount);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS::clear()
{
	filter.clear();
	loginExtraData.clear();
	clientMarkers.clear();
	filterTypeToCount = 0;
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS::equals(const Protocol_MSG_MLOBBYNG_SNG_COUNTS& _o) const
{
	return filter.equals(_o.filter) &&
		loginExtraData.equals(_o.loginExtraData) &&
		clientMarkers.equals(_o.clientMarkers) &&
		filterTypeToCount == _o.filterTypeToCount;
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_SNG_COUNTS).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("loginExtraData=");
	loginExtraData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clientMarkers=");
	clientMarkers.toTraceString(_buf);
	_buf.append(',');
	_buf.append("filterTypeToCount=");
	_buf.appendInt(filterTypeToCount);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS::composeMsg(CommMsgBody& _msg) const
{
	filter.composeMsg(_msg);
	loginExtraData.composeMsg(_msg);
	clientMarkers.composeMsg(_msg);
	_msg.composeINT32(filterTypeToCount);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	loginExtraData.parseMsg(_parser);
	clientMarkers.parseMsg(_parser);
	_parser.parseINT32(filterTypeToCount);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_SNG_COUNTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	SngSelectionFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	CommonThin::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("loginExtraData"), _fieldsWithUnparsedContent);
	ClientMarkers::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientMarkers"), _fieldsWithUnparsedContent);
	INT32 filterTypeToCount; _parser.parseINT32(filterTypeToCount);
	AtfValidator::validateIntMax(_descr, "filterTypeToCount", filterTypeToCount, NGFilter_Last, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY::Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY::Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY(Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY&& _o)
	: filterTypeToCount(std::move(_o.filterTypeToCount))
	, counts(std::move(_o.counts))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY::operator=(Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY&& _o)
{
	if(this != &_o)
	{
		filterTypeToCount = std::move(_o.filterTypeToCount);
		counts = std::move(_o.counts);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY::clear()
{
	filterTypeToCount = 0;
	counts.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY::equals(const Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY& _o) const
{
	return filterTypeToCount == _o.filterTypeToCount &&
		counts.equals(_o.counts);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_SNG_COUNTS_REPLY).append(")");
	_buf.append(',');
	_buf.append("filterTypeToCount=");
	_buf.appendInt(filterTypeToCount);
	_buf.append(',');
	_buf.append("counts=");
	counts.toTraceString(_buf);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(filterTypeToCount);
	counts.composeMsg(_msg);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(filterTypeToCount);
	counts.parseMsg(_parser);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_SNG_COUNTS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 filterTypeToCount; _parser.parseINT32(filterTypeToCount);
	AtfValidator::validateInt(_descr, "filterTypeToCount", filterTypeToCount, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szCounts = ThinAtf::LAtfVector< FilterCountInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("counts"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "counts", szCounts, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO(Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO&& _o)
	: game(std::move(_o.game))
	, locale(std::move(_o.locale))
	, licenseId(std::move(_o.licenseId))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO::operator=(Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO&& _o)
{
	if(this != &_o)
	{
		game = std::move(_o.game);
		locale = std::move(_o.locale);
		licenseId = std::move(_o.licenseId);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO::clear()
{
	game.clear();
	locale = 0;
	licenseId = 0;
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO::equals(const Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO& _o) const
{
	return game.equals(_o.game) &&
		locale == _o.locale &&
		licenseId == _o.licenseId;
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_GET_GAME_CONN_INFO).append(")");
	_buf.append(',');
	_buf.append("game=");
	game.toTraceString(_buf);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("licenseId=");
	_buf.appendUint(licenseId);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO::composeMsg(CommMsgBody& _msg) const
{
	game.composeMsg(_msg);
	_msg.composeUINT32(locale);
	_msg.composeUINT32(licenseId);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO::parseMsg(CommMsgParser& _parser)
{
	game.parseMsg(_parser);
	_parser.parseUINT32(locale);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(licenseId);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_GET_GAME_CONN_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szGame = ThinAtf::LAtfVector< GameConnInfoReqStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("game"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "game", szGame, 1000, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 licenseId; _parser.parseUINT32(licenseId);
	AtfValidator::validateIntMax(_descr, "licenseId", licenseId, eLicenceLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY(Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY&& _o)
	: tourns(std::move(_o.tourns))
	, tables(std::move(_o.tables))
	, zoomTypes(std::move(_o.zoomTypes))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY::operator=(Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		tourns = std::move(_o.tourns);
		tables = std::move(_o.tables);
		zoomTypes = std::move(_o.zoomTypes);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY::clear()
{
	tourns.clear();
	tables.clear();
	zoomTypes.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY::equals(const Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY& _o) const
{
	return tourns.equals(_o.tourns) &&
		tables.equals(_o.tables) &&
		zoomTypes.equals(_o.zoomTypes);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("tourns=");
	tourns.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tables=");
	tables.toTraceString(_buf);
	_buf.append(',');
	_buf.append("zoomTypes=");
	zoomTypes.toTraceString(_buf);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY::composeMsg(CommMsgBody& _msg) const
{
	tourns.composeMsg(_msg);
	tables.composeMsg(_msg);
	zoomTypes.composeMsg(_msg);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	tourns.parseMsg(_parser);
	tables.parseMsg(_parser);
	zoomTypes.parseMsg(_parser);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTourns = ThinAtf::LAtfVector< TournDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
	int szTables = ThinAtf::LAtfVector< TableData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tables"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tables", szTables, _checker, __FILE__, __LINE__);
	int szZoomTypes = ThinAtf::LAtfVector< ZoomDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("zoomTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "zoomTypes", szZoomTypes, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_TICKET_TOURNS
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS::Protocol_MSG_MLOBBYNG_TICKET_TOURNS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS::Protocol_MSG_MLOBBYNG_TICKET_TOURNS(Protocol_MSG_MLOBBYNG_TICKET_TOURNS&& _o)
	: ticketNames(std::move(_o.ticketNames))
	, locale(std::move(_o.locale))
	, loginExtraData(std::move(_o.loginExtraData))
	, clientMarkers(std::move(_o.clientMarkers))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS::operator=(Protocol_MSG_MLOBBYNG_TICKET_TOURNS&& _o)
{
	if(this != &_o)
	{
		ticketNames = std::move(_o.ticketNames);
		locale = std::move(_o.locale);
		loginExtraData = std::move(_o.loginExtraData);
		clientMarkers = std::move(_o.clientMarkers);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS::clear()
{
	ticketNames.clear();
	locale = 0;
	loginExtraData.clear();
	clientMarkers.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS::equals(const Protocol_MSG_MLOBBYNG_TICKET_TOURNS& _o) const
{
	return ticketNames.equals(_o.ticketNames) &&
		locale == _o.locale &&
		loginExtraData.equals(_o.loginExtraData) &&
		clientMarkers.equals(_o.clientMarkers);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_TICKET_TOURNS).append(")");
	_buf.append(',');
	_buf.append("ticketNames=");
	ticketNames.toTraceString(_buf);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("loginExtraData=");
	loginExtraData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clientMarkers=");
	clientMarkers.toTraceString(_buf);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS::composeMsg(CommMsgBody& _msg) const
{
	ticketNames.composeMsg(_msg);
	_msg.composeUINT32(locale);
	loginExtraData.composeMsg(_msg);
	clientMarkers.composeMsg(_msg);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS::parseMsg(CommMsgParser& _parser)
{
	ticketNames.parseMsg(_parser);
	_parser.parseUINT32(locale);
	loginExtraData.parseMsg(_parser);
	clientMarkers.parseMsg(_parser);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_TICKET_TOURNS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTicketNames = ThinAtf::LAtfVector< PString, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("ticketNames"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "ticketNames", szTicketNames, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	CommonThin::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("loginExtraData"), _fieldsWithUnparsedContent);
	ClientMarkers::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientMarkers"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY::Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY::Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY(Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY&& _o)
	: ticketInfos(std::move(_o.ticketInfos))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY::operator=(Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY&& _o)
{
	if(this != &_o)
	{
		ticketInfos = std::move(_o.ticketInfos);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY::clear()
{
	ticketInfos.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY::equals(const Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY& _o) const
{
	return ticketInfos.equals(_o.ticketInfos);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_TICKET_TOURNS_REPLY).append(")");
	_buf.append(',');
	_buf.append("ticketInfos=");
	ticketInfos.toTraceString(_buf);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	ticketInfos.composeMsg(_msg);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY::parseMsg(CommMsgParser& _parser)
{
	ticketInfos.parseMsg(_parser);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_TICKET_TOURNS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTicketInfos = ThinAtf::LAtfVector< TicketTournInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("ticketInfos"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "ticketInfos", szTicketInfos, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_GET_GAME_INFO
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO::Protocol_MSG_MLOBBYNG_GET_GAME_INFO()
{
	clear();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO::clear()
{
	gameToFind.clear();
	isPM = false;
	locale = 0;
	clientMarkers.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO::equals(const Protocol_MSG_MLOBBYNG_GET_GAME_INFO& _o) const
{
	return gameToFind.equals(_o.gameToFind) &&
		isPM == _o.isPM &&
		locale == _o.locale &&
		clientMarkers.equals(_o.clientMarkers);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_GET_GAME_INFO).append(")");
	_buf.append(',');
	_buf.append("gameToFind=");
	gameToFind.toTraceString(_buf);
	_buf.append(',');
	_buf.append("isPM=");
	_buf.appendUint(isPM);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("clientMarkers=");
	clientMarkers.toTraceString(_buf);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO::composeMsg(CommMsgBody& _msg) const
{
	gameToFind.composeMsg(_msg);
	_msg.composeBOOL(isPM);
	_msg.composeUINT32(locale);
	clientMarkers.composeMsg(_msg);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO::parseMsg(CommMsgParser& _parser)
{
	gameToFind.parseMsg(_parser);
	_parser.parseBOOL(isPM);
	_parser.parseUINT32(locale);
	clientMarkers.parseMsg(_parser);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_GET_GAME_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	GameConnInfoReqStruct::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("gameToFind"), _fieldsWithUnparsedContent);
	bool isPM; _parser.parseBOOL(isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	ClientMarkers::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientMarkers"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY::Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY::Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY(Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY&& _o)
	: tourns(std::move(_o.tourns))
	, tableTypes(std::move(_o.tableTypes))
	, sngTypes(std::move(_o.sngTypes))
	, sagTypes(std::move(_o.sagTypes))
	, zoomTypes(std::move(_o.zoomTypes))
	, seatFinders(std::move(_o.seatFinders))
	, tables(std::move(_o.tables))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY::operator=(Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		tourns = std::move(_o.tourns);
		tableTypes = std::move(_o.tableTypes);
		sngTypes = std::move(_o.sngTypes);
		sagTypes = std::move(_o.sagTypes);
		zoomTypes = std::move(_o.zoomTypes);
		seatFinders = std::move(_o.seatFinders);
		tables = std::move(_o.tables);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY::clear()
{
	tourns.clear();
	tableTypes.clear();
	sngTypes.clear();
	sagTypes.clear();
	zoomTypes.clear();
	seatFinders.clear();
	tables.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY::equals(const Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY& _o) const
{
	return tourns.equals(_o.tourns) &&
		tableTypes.equals(_o.tableTypes) &&
		sngTypes.equals(_o.sngTypes) &&
		sagTypes.equals(_o.sagTypes) &&
		zoomTypes.equals(_o.zoomTypes) &&
		seatFinders.equals(_o.seatFinders) &&
		tables.equals(_o.tables);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_GET_GAME_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("tourns=");
	tourns.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableTypes=");
	tableTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sngTypes=");
	sngTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sagTypes=");
	sagTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("zoomTypes=");
	zoomTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("seatFinders=");
	seatFinders.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tables=");
	tables.toTraceString(_buf);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY::composeMsg(CommMsgBody& _msg) const
{
	tourns.composeMsg(_msg);
	tableTypes.composeMsg(_msg);
	sngTypes.composeMsg(_msg);
	sagTypes.composeMsg(_msg);
	zoomTypes.composeMsg(_msg);
	seatFinders.composeMsg(_msg);
	tables.composeMsg(_msg);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	tourns.parseMsg(_parser);
	tableTypes.parseMsg(_parser);
	sngTypes.parseMsg(_parser);
	sagTypes.parseMsg(_parser);
	zoomTypes.parseMsg(_parser);
	seatFinders.parseMsg(_parser);
	tables.parseMsg(_parser);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_GET_GAME_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTourns = ThinAtf::LAtfVector< TournDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
	int szTableTypes = ThinAtf::LAtfVector< TableDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tableTypes", szTableTypes, _checker, __FILE__, __LINE__);
	int szSngTypes = ThinAtf::LAtfVector< SngDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sngTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sngTypes", szSngTypes, _checker, __FILE__, __LINE__);
	int szSagTypes = ThinAtf::LAtfVector< SagDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sagTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sagTypes", szSagTypes, _checker, __FILE__, __LINE__);
	int szZoomTypes = ThinAtf::LAtfVector< ZoomDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("zoomTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "zoomTypes", szZoomTypes, _checker, __FILE__, __LINE__);
	int szSeatFinders = ThinAtf::LAtfVector< SeatFinderDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("seatFinders"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "seatFinders", szSeatFinders, _checker, __FILE__, __LINE__);
	int szTables = ThinAtf::LAtfVector< TableData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tables"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tables", szTables, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_FILTER_GAMES
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES::Protocol_MSG_MLOBBYNG_FILTER_GAMES()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES::Protocol_MSG_MLOBBYNG_FILTER_GAMES(Protocol_MSG_MLOBBYNG_FILTER_GAMES&& _o)
	: filter(std::move(_o.filter))
	, criteria(std::move(_o.criteria))
	, loginExtraData(std::move(_o.loginExtraData))
	, clientMarkers(std::move(_o.clientMarkers))
	, licenseId(std::move(_o.licenseId))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES::operator=(Protocol_MSG_MLOBBYNG_FILTER_GAMES&& _o)
{
	if(this != &_o)
	{
		filter = std::move(_o.filter);
		criteria = std::move(_o.criteria);
		loginExtraData = std::move(_o.loginExtraData);
		clientMarkers = std::move(_o.clientMarkers);
		licenseId = std::move(_o.licenseId);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES::clear()
{
	filter.clear();
	criteria.clear();
	loginExtraData.clear();
	clientMarkers.clear();
	licenseId = 0;
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES::equals(const Protocol_MSG_MLOBBYNG_FILTER_GAMES& _o) const
{
	return filter.equals(_o.filter) &&
		criteria.equals(_o.criteria) &&
		loginExtraData.equals(_o.loginExtraData) &&
		clientMarkers.equals(_o.clientMarkers) &&
		licenseId == _o.licenseId;
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_FILTER_GAMES).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("criteria=");
	criteria.toTraceString(_buf);
	_buf.append(',');
	_buf.append("loginExtraData=");
	loginExtraData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clientMarkers=");
	clientMarkers.toTraceString(_buf);
	_buf.append(',');
	_buf.append("licenseId=");
	_buf.appendUint(licenseId);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES::composeMsg(CommMsgBody& _msg) const
{
	filter.composeMsg(_msg);
	criteria.composeMsg(_msg);
	loginExtraData.composeMsg(_msg);
	clientMarkers.composeMsg(_msg);
	_msg.composeUINT32(licenseId);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	criteria.parseMsg(_parser);
	loginExtraData.parseMsg(_parser);
	clientMarkers.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(licenseId);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_FILTER_GAMES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	FilterGamesSelectionFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	FilterGamesResultCriteria::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("criteria"), _fieldsWithUnparsedContent);
	CommonThin::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("loginExtraData"), _fieldsWithUnparsedContent);
	ClientMarkers::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientMarkers"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	UINT32 licenseId; _parser.parseUINT32(licenseId);
	AtfValidator::validateIntMax(_descr, "licenseId", licenseId, eLicenceLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY::Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY::Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY(Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY&& _o)
	: tourns(std::move(_o.tourns))
	, tableTypes(std::move(_o.tableTypes))
	, sngTypes(std::move(_o.sngTypes))
	, sagTypes(std::move(_o.sagTypes))
	, zoomTypes(std::move(_o.zoomTypes))
	, seatFinders(std::move(_o.seatFinders))
	, gameOrder(std::move(_o.gameOrder))
	, totalItems(std::move(_o.totalItems))
	, minBuyIn(std::move(_o.minBuyIn))
	, maxBuyIn(std::move(_o.maxBuyIn))
	, resultRanges(std::move(_o.resultRanges))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY::operator=(Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY&& _o)
{
	if(this != &_o)
	{
		tourns = std::move(_o.tourns);
		tableTypes = std::move(_o.tableTypes);
		sngTypes = std::move(_o.sngTypes);
		sagTypes = std::move(_o.sagTypes);
		zoomTypes = std::move(_o.zoomTypes);
		seatFinders = std::move(_o.seatFinders);
		gameOrder = std::move(_o.gameOrder);
		totalItems = std::move(_o.totalItems);
		minBuyIn = std::move(_o.minBuyIn);
		maxBuyIn = std::move(_o.maxBuyIn);
		resultRanges = std::move(_o.resultRanges);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY::clear()
{
	tourns.clear();
	tableTypes.clear();
	sngTypes.clear();
	sagTypes.clear();
	zoomTypes.clear();
	seatFinders.clear();
	gameOrder.clear();
	totalItems = 0;
	minBuyIn = 0;
	maxBuyIn = 0;
	resultRanges.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY::equals(const Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY& _o) const
{
	return tourns.equals(_o.tourns) &&
		tableTypes.equals(_o.tableTypes) &&
		sngTypes.equals(_o.sngTypes) &&
		sagTypes.equals(_o.sagTypes) &&
		zoomTypes.equals(_o.zoomTypes) &&
		seatFinders.equals(_o.seatFinders) &&
		gameOrder.equals(_o.gameOrder) &&
		totalItems == _o.totalItems &&
		minBuyIn == _o.minBuyIn &&
		maxBuyIn == _o.maxBuyIn &&
		resultRanges.equals(_o.resultRanges);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_FILTER_GAMES_REPLY).append(")");
	_buf.append(',');
	_buf.append("tourns=");
	tourns.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableTypes=");
	tableTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sngTypes=");
	sngTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sagTypes=");
	sagTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("zoomTypes=");
	zoomTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("seatFinders=");
	seatFinders.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameOrder=");
	gameOrder.toTraceString(_buf);
	_buf.append(',');
	_buf.append("totalItems=");
	_buf.appendInt(totalItems);
	_buf.append(',');
	_buf.append("minBuyIn=");
	_buf.appendInt64(minBuyIn);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendInt64(maxBuyIn);
	_buf.append(',');
	_buf.append("resultRanges=");
	resultRanges.toTraceString(_buf);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY::composeMsg(CommMsgBody& _msg) const
{
	tourns.composeMsg(_msg);
	tableTypes.composeMsg(_msg);
	sngTypes.composeMsg(_msg);
	sagTypes.composeMsg(_msg);
	zoomTypes.composeMsg(_msg);
	seatFinders.composeMsg(_msg);
	gameOrder.composeMsg(_msg);
	_msg.composeINT32(totalItems);
	_msg.composeINT64(minBuyIn);
	_msg.composeINT64(maxBuyIn);
	resultRanges.composeMsg(_msg);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY::parseMsg(CommMsgParser& _parser)
{
	tourns.parseMsg(_parser);
	tableTypes.parseMsg(_parser);
	sngTypes.parseMsg(_parser);
	sagTypes.parseMsg(_parser);
	zoomTypes.parseMsg(_parser);
	seatFinders.parseMsg(_parser);
	gameOrder.parseMsg(_parser);
	_parser.parseINT32(totalItems);
	_parser.parseINT64(minBuyIn);
	_parser.parseINT64(maxBuyIn);
	resultRanges.parseMsg(_parser);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_FILTER_GAMES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTourns = ThinAtf::LAtfVector< TournDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
	int szTableTypes = ThinAtf::LAtfVector< TableDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tableTypes", szTableTypes, _checker, __FILE__, __LINE__);
	int szSngTypes = ThinAtf::LAtfVector< SngDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sngTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sngTypes", szSngTypes, _checker, __FILE__, __LINE__);
	int szSagTypes = ThinAtf::LAtfVector< SagDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sagTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sagTypes", szSagTypes, _checker, __FILE__, __LINE__);
	int szZoomTypes = ThinAtf::LAtfVector< ZoomDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("zoomTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "zoomTypes", szZoomTypes, _checker, __FILE__, __LINE__);
	int szSeatFinders = ThinAtf::LAtfVector< SeatFinderDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("seatFinders"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "seatFinders", szSeatFinders, _checker, __FILE__, __LINE__);
	int szGameOrder = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("gameOrder"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "gameOrder", szGameOrder, _checker, __FILE__, __LINE__);
	INT32 totalItems; _parser.parseINT32(totalItems);
	AtfValidator::validateInt(_descr, "totalItems", totalItems, _checker, __FILE__, __LINE__);
	INT64 minBuyIn; _parser.parseINT64(minBuyIn);
	AtfValidator::validateInt(_descr, "minBuyIn", minBuyIn, _checker, __FILE__, __LINE__);
	INT64 maxBuyIn; _parser.parseINT64(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	ResultRanges::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("resultRanges"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS(Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS&& _o)
	: filter(std::move(_o.filter))
	, criteria(std::move(_o.criteria))
	, loginExtraData(std::move(_o.loginExtraData))
	, clientMarkers(std::move(_o.clientMarkers))
	, licenseId(std::move(_o.licenseId))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS::operator=(Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS&& _o)
{
	if(this != &_o)
	{
		filter = std::move(_o.filter);
		criteria = std::move(_o.criteria);
		loginExtraData = std::move(_o.loginExtraData);
		clientMarkers = std::move(_o.clientMarkers);
		licenseId = std::move(_o.licenseId);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS::clear()
{
	filter.clear();
	criteria.clear();
	loginExtraData.clear();
	clientMarkers.clear();
	licenseId = 0;
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS::equals(const Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS& _o) const
{
	return filter.equals(_o.filter) &&
		criteria.equals(_o.criteria) &&
		loginExtraData.equals(_o.loginExtraData) &&
		clientMarkers.equals(_o.clientMarkers) &&
		licenseId == _o.licenseId;
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_FILTER_GAMES_PS).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("criteria=");
	criteria.toTraceString(_buf);
	_buf.append(',');
	_buf.append("loginExtraData=");
	loginExtraData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clientMarkers=");
	clientMarkers.toTraceString(_buf);
	_buf.append(',');
	_buf.append("licenseId=");
	_buf.appendUint(licenseId);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS::composeMsg(CommMsgBody& _msg) const
{
	filter.composeMsg(_msg);
	criteria.composeMsg(_msg);
	loginExtraData.composeMsg(_msg);
	clientMarkers.composeMsg(_msg);
	_msg.composeUINT32(licenseId);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	criteria.parseMsg(_parser);
	loginExtraData.parseMsg(_parser);
	clientMarkers.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(licenseId);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_FILTER_GAMES_PS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	FilterGamesSelectionFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	FilterGamesResultCriteria::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("criteria"), _fieldsWithUnparsedContent);
	CommonThin::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("loginExtraData"), _fieldsWithUnparsedContent);
	ClientMarkers::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientMarkers"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	UINT32 licenseId; _parser.parseUINT32(licenseId);
	AtfValidator::validateIntMax(_descr, "licenseId", licenseId, eLicenceLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY(Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY&& _o)
	: tourns(std::move(_o.tourns))
	, tableTypes(std::move(_o.tableTypes))
	, sngTypes(std::move(_o.sngTypes))
	, sagTypes(std::move(_o.sagTypes))
	, zoomTypes(std::move(_o.zoomTypes))
	, seatFinders(std::move(_o.seatFinders))
	, gameOrder(std::move(_o.gameOrder))
	, totalItems(std::move(_o.totalItems))
	, minBuyIn(std::move(_o.minBuyIn))
	, maxBuyIn(std::move(_o.maxBuyIn))
	, resultRanges(std::move(_o.resultRanges))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY::operator=(Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY&& _o)
{
	if(this != &_o)
	{
		tourns = std::move(_o.tourns);
		tableTypes = std::move(_o.tableTypes);
		sngTypes = std::move(_o.sngTypes);
		sagTypes = std::move(_o.sagTypes);
		zoomTypes = std::move(_o.zoomTypes);
		seatFinders = std::move(_o.seatFinders);
		gameOrder = std::move(_o.gameOrder);
		totalItems = std::move(_o.totalItems);
		minBuyIn = std::move(_o.minBuyIn);
		maxBuyIn = std::move(_o.maxBuyIn);
		resultRanges = std::move(_o.resultRanges);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY::clear()
{
	tourns.clear();
	tableTypes.clear();
	sngTypes.clear();
	sagTypes.clear();
	zoomTypes.clear();
	seatFinders.clear();
	gameOrder.clear();
	totalItems = 0;
	minBuyIn = 0;
	maxBuyIn = 0;
	resultRanges.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY::equals(const Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY& _o) const
{
	return tourns.equals(_o.tourns) &&
		tableTypes.equals(_o.tableTypes) &&
		sngTypes.equals(_o.sngTypes) &&
		sagTypes.equals(_o.sagTypes) &&
		zoomTypes.equals(_o.zoomTypes) &&
		seatFinders.equals(_o.seatFinders) &&
		gameOrder.equals(_o.gameOrder) &&
		totalItems == _o.totalItems &&
		minBuyIn == _o.minBuyIn &&
		maxBuyIn == _o.maxBuyIn &&
		resultRanges.equals(_o.resultRanges);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY).append(")");
	_buf.append(',');
	_buf.append("tourns=");
	tourns.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableTypes=");
	tableTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sngTypes=");
	sngTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sagTypes=");
	sagTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("zoomTypes=");
	zoomTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("seatFinders=");
	seatFinders.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameOrder=");
	gameOrder.toTraceString(_buf);
	_buf.append(',');
	_buf.append("totalItems=");
	_buf.appendInt(totalItems);
	_buf.append(',');
	_buf.append("minBuyIn=");
	_buf.appendInt64(minBuyIn);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendInt64(maxBuyIn);
	_buf.append(',');
	_buf.append("resultRanges=");
	resultRanges.toTraceString(_buf);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	tourns.composeMsg(_msg);
	tableTypes.composeMsg(_msg);
	sngTypes.composeMsg(_msg);
	sagTypes.composeMsg(_msg);
	zoomTypes.composeMsg(_msg);
	seatFinders.composeMsg(_msg);
	gameOrder.composeMsg(_msg);
	_msg.composeINT32(totalItems);
	_msg.composeINT64(minBuyIn);
	_msg.composeINT64(maxBuyIn);
	resultRanges.composeMsg(_msg);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY::parseMsg(CommMsgParser& _parser)
{
	tourns.parseMsg(_parser);
	tableTypes.parseMsg(_parser);
	sngTypes.parseMsg(_parser);
	sagTypes.parseMsg(_parser);
	zoomTypes.parseMsg(_parser);
	seatFinders.parseMsg(_parser);
	gameOrder.parseMsg(_parser);
	_parser.parseINT32(totalItems);
	_parser.parseINT64(minBuyIn);
	_parser.parseINT64(maxBuyIn);
	resultRanges.parseMsg(_parser);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTourns = ThinAtf::LAtfVector< TournDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
	int szTableTypes = ThinAtf::LAtfVector< TableDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tableTypes", szTableTypes, _checker, __FILE__, __LINE__);
	int szSngTypes = ThinAtf::LAtfVector< SngDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sngTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sngTypes", szSngTypes, _checker, __FILE__, __LINE__);
	int szSagTypes = ThinAtf::LAtfVector< SagDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sagTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sagTypes", szSagTypes, _checker, __FILE__, __LINE__);
	int szZoomTypes = ThinAtf::LAtfVector< ZoomDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("zoomTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "zoomTypes", szZoomTypes, _checker, __FILE__, __LINE__);
	int szSeatFinders = ThinAtf::LAtfVector< SeatFinderDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("seatFinders"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "seatFinders", szSeatFinders, _checker, __FILE__, __LINE__);
	int szGameOrder = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("gameOrder"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "gameOrder", szGameOrder, _checker, __FILE__, __LINE__);
	INT32 totalItems; _parser.parseINT32(totalItems);
	AtfValidator::validateInt(_descr, "totalItems", totalItems, _checker, __FILE__, __LINE__);
	INT64 minBuyIn; _parser.parseINT64(minBuyIn);
	AtfValidator::validateInt(_descr, "minBuyIn", minBuyIn, _checker, __FILE__, __LINE__);
	INT64 maxBuyIn; _parser.parseINT64(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	ResultRanges::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("resultRanges"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2(Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2&& _o)
	: filter(std::move(_o.filter))
	, loginExtraData(std::move(_o.loginExtraData))
	, clientMarkers(std::move(_o.clientMarkers))
	, licenseId(std::move(_o.licenseId))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2::operator=(Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2&& _o)
{
	if(this != &_o)
	{
		filter = std::move(_o.filter);
		loginExtraData = std::move(_o.loginExtraData);
		clientMarkers = std::move(_o.clientMarkers);
		licenseId = std::move(_o.licenseId);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2::clear()
{
	filter.clear();
	loginExtraData.clear();
	clientMarkers.clear();
	licenseId = 0;
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2::equals(const Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2& _o) const
{
	return filter.equals(_o.filter) &&
		loginExtraData.equals(_o.loginExtraData) &&
		clientMarkers.equals(_o.clientMarkers) &&
		licenseId == _o.licenseId;
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_GET_SUGGESTED_GAMES2).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("loginExtraData=");
	loginExtraData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clientMarkers=");
	clientMarkers.toTraceString(_buf);
	_buf.append(',');
	_buf.append("licenseId=");
	_buf.appendUint(licenseId);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2::composeMsg(CommMsgBody& _msg) const
{
	filter.composeMsg(_msg);
	loginExtraData.composeMsg(_msg);
	clientMarkers.composeMsg(_msg);
	_msg.composeUINT32(licenseId);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	loginExtraData.parseMsg(_parser);
	clientMarkers.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(licenseId);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_GET_SUGGESTED_GAMES2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	SuggestedGames2SelectionFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	CommonThin::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("loginExtraData"), _fieldsWithUnparsedContent);
	ClientMarkers::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientMarkers"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	UINT32 licenseId; _parser.parseUINT32(licenseId);
	AtfValidator::validateIntMax(_descr, "licenseId", licenseId, eLicenceLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY(Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY&& _o)
	: tourns(std::move(_o.tourns))
	, tableTypes(std::move(_o.tableTypes))
	, sngTypes(std::move(_o.sngTypes))
	, sagTypes(std::move(_o.sagTypes))
	, zoomTypes(std::move(_o.zoomTypes))
	, seatFinders(std::move(_o.seatFinders))
	, gameOrder(std::move(_o.gameOrder))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY::operator=(Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY&& _o)
{
	if(this != &_o)
	{
		tourns = std::move(_o.tourns);
		tableTypes = std::move(_o.tableTypes);
		sngTypes = std::move(_o.sngTypes);
		sagTypes = std::move(_o.sagTypes);
		zoomTypes = std::move(_o.zoomTypes);
		seatFinders = std::move(_o.seatFinders);
		gameOrder = std::move(_o.gameOrder);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY::clear()
{
	tourns.clear();
	tableTypes.clear();
	sngTypes.clear();
	sagTypes.clear();
	zoomTypes.clear();
	seatFinders.clear();
	gameOrder.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY::equals(const Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY& _o) const
{
	return tourns.equals(_o.tourns) &&
		tableTypes.equals(_o.tableTypes) &&
		sngTypes.equals(_o.sngTypes) &&
		sagTypes.equals(_o.sagTypes) &&
		zoomTypes.equals(_o.zoomTypes) &&
		seatFinders.equals(_o.seatFinders) &&
		gameOrder.equals(_o.gameOrder);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY).append(")");
	_buf.append(',');
	_buf.append("tourns=");
	tourns.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableTypes=");
	tableTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sngTypes=");
	sngTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sagTypes=");
	sagTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("zoomTypes=");
	zoomTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("seatFinders=");
	seatFinders.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameOrder=");
	gameOrder.toTraceString(_buf);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY::composeMsg(CommMsgBody& _msg) const
{
	tourns.composeMsg(_msg);
	tableTypes.composeMsg(_msg);
	sngTypes.composeMsg(_msg);
	sagTypes.composeMsg(_msg);
	zoomTypes.composeMsg(_msg);
	seatFinders.composeMsg(_msg);
	gameOrder.composeMsg(_msg);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY::parseMsg(CommMsgParser& _parser)
{
	tourns.parseMsg(_parser);
	tableTypes.parseMsg(_parser);
	sngTypes.parseMsg(_parser);
	sagTypes.parseMsg(_parser);
	zoomTypes.parseMsg(_parser);
	seatFinders.parseMsg(_parser);
	gameOrder.parseMsg(_parser);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTourns = ThinAtf::LAtfVector< TournDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
	int szTableTypes = ThinAtf::LAtfVector< TableDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tableTypes", szTableTypes, _checker, __FILE__, __LINE__);
	int szSngTypes = ThinAtf::LAtfVector< SngDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sngTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sngTypes", szSngTypes, _checker, __FILE__, __LINE__);
	int szSagTypes = ThinAtf::LAtfVector< SagDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sagTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sagTypes", szSagTypes, _checker, __FILE__, __LINE__);
	int szZoomTypes = ThinAtf::LAtfVector< ZoomDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("zoomTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "zoomTypes", szZoomTypes, _checker, __FILE__, __LINE__);
	int szSeatFinders = ThinAtf::LAtfVector< SeatFinderDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("seatFinders"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "seatFinders", szSeatFinders, _checker, __FILE__, __LINE__);
	int szGameOrder = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("gameOrder"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "gameOrder", szGameOrder, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS(Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS&& _o)
	: filter(std::move(_o.filter))
	, loginExtraData(std::move(_o.loginExtraData))
	, clientMarkers(std::move(_o.clientMarkers))
	, licenseId(std::move(_o.licenseId))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS::operator=(Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS&& _o)
{
	if(this != &_o)
	{
		filter = std::move(_o.filter);
		loginExtraData = std::move(_o.loginExtraData);
		clientMarkers = std::move(_o.clientMarkers);
		licenseId = std::move(_o.licenseId);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS::clear()
{
	filter.clear();
	loginExtraData.clear();
	clientMarkers.clear();
	licenseId = 0;
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS::equals(const Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS& _o) const
{
	return filter.equals(_o.filter) &&
		loginExtraData.equals(_o.loginExtraData) &&
		clientMarkers.equals(_o.clientMarkers) &&
		licenseId == _o.licenseId;
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("loginExtraData=");
	loginExtraData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clientMarkers=");
	clientMarkers.toTraceString(_buf);
	_buf.append(',');
	_buf.append("licenseId=");
	_buf.appendUint(licenseId);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS::composeMsg(CommMsgBody& _msg) const
{
	filter.composeMsg(_msg);
	loginExtraData.composeMsg(_msg);
	clientMarkers.composeMsg(_msg);
	_msg.composeUINT32(licenseId);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	loginExtraData.parseMsg(_parser);
	clientMarkers.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(licenseId);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	SuggestedGames2SelectionFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	CommonThin::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("loginExtraData"), _fieldsWithUnparsedContent);
	ClientMarkers::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientMarkers"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	UINT32 licenseId; _parser.parseUINT32(licenseId);
	AtfValidator::validateIntMax(_descr, "licenseId", licenseId, eLicenceLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY(Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY&& _o)
	: tourns(std::move(_o.tourns))
	, tableTypes(std::move(_o.tableTypes))
	, sngTypes(std::move(_o.sngTypes))
	, sagTypes(std::move(_o.sagTypes))
	, zoomTypes(std::move(_o.zoomTypes))
	, seatFinders(std::move(_o.seatFinders))
	, gameOrder(std::move(_o.gameOrder))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY::operator=(Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY&& _o)
{
	if(this != &_o)
	{
		tourns = std::move(_o.tourns);
		tableTypes = std::move(_o.tableTypes);
		sngTypes = std::move(_o.sngTypes);
		sagTypes = std::move(_o.sagTypes);
		zoomTypes = std::move(_o.zoomTypes);
		seatFinders = std::move(_o.seatFinders);
		gameOrder = std::move(_o.gameOrder);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY::clear()
{
	tourns.clear();
	tableTypes.clear();
	sngTypes.clear();
	sagTypes.clear();
	zoomTypes.clear();
	seatFinders.clear();
	gameOrder.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY::equals(const Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY& _o) const
{
	return tourns.equals(_o.tourns) &&
		tableTypes.equals(_o.tableTypes) &&
		sngTypes.equals(_o.sngTypes) &&
		sagTypes.equals(_o.sagTypes) &&
		zoomTypes.equals(_o.zoomTypes) &&
		seatFinders.equals(_o.seatFinders) &&
		gameOrder.equals(_o.gameOrder);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY).append(")");
	_buf.append(',');
	_buf.append("tourns=");
	tourns.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableTypes=");
	tableTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sngTypes=");
	sngTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sagTypes=");
	sagTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("zoomTypes=");
	zoomTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("seatFinders=");
	seatFinders.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameOrder=");
	gameOrder.toTraceString(_buf);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	tourns.composeMsg(_msg);
	tableTypes.composeMsg(_msg);
	sngTypes.composeMsg(_msg);
	sagTypes.composeMsg(_msg);
	zoomTypes.composeMsg(_msg);
	seatFinders.composeMsg(_msg);
	gameOrder.composeMsg(_msg);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY::parseMsg(CommMsgParser& _parser)
{
	tourns.parseMsg(_parser);
	tableTypes.parseMsg(_parser);
	sngTypes.parseMsg(_parser);
	sagTypes.parseMsg(_parser);
	zoomTypes.parseMsg(_parser);
	seatFinders.parseMsg(_parser);
	gameOrder.parseMsg(_parser);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTourns = ThinAtf::LAtfVector< TournDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
	int szTableTypes = ThinAtf::LAtfVector< TableDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tableTypes", szTableTypes, _checker, __FILE__, __LINE__);
	int szSngTypes = ThinAtf::LAtfVector< SngDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sngTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sngTypes", szSngTypes, _checker, __FILE__, __LINE__);
	int szSagTypes = ThinAtf::LAtfVector< SagDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sagTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sagTypes", szSagTypes, _checker, __FILE__, __LINE__);
	int szZoomTypes = ThinAtf::LAtfVector< ZoomDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("zoomTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "zoomTypes", szZoomTypes, _checker, __FILE__, __LINE__);
	int szSeatFinders = ThinAtf::LAtfVector< SeatFinderDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("seatFinders"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "seatFinders", szSeatFinders, _checker, __FILE__, __LINE__);
	int szGameOrder = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("gameOrder"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "gameOrder", szGameOrder, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME(Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME&& _o)
	: filter(std::move(_o.filter))
	, criteria(std::move(_o.criteria))
	, loginExtraData(std::move(_o.loginExtraData))
	, clientMarkers(std::move(_o.clientMarkers))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME::operator=(Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME&& _o)
{
	if(this != &_o)
	{
		filter = std::move(_o.filter);
		criteria = std::move(_o.criteria);
		loginExtraData = std::move(_o.loginExtraData);
		clientMarkers = std::move(_o.clientMarkers);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME::clear()
{
	filter.clear();
	criteria.clear();
	loginExtraData.clear();
	clientMarkers.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME::equals(const Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME& _o) const
{
	return filter.equals(_o.filter) &&
		criteria.equals(_o.criteria) &&
		loginExtraData.equals(_o.loginExtraData) &&
		clientMarkers.equals(_o.clientMarkers);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_SEARCH_BY_NAME).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("criteria=");
	criteria.toTraceString(_buf);
	_buf.append(',');
	_buf.append("loginExtraData=");
	loginExtraData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clientMarkers=");
	clientMarkers.toTraceString(_buf);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME::composeMsg(CommMsgBody& _msg) const
{
	filter.composeMsg(_msg);
	criteria.composeMsg(_msg);
	loginExtraData.composeMsg(_msg);
	clientMarkers.composeMsg(_msg);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	criteria.parseMsg(_parser);
	loginExtraData.parseMsg(_parser);
	clientMarkers.parseMsg(_parser);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_SEARCH_BY_NAME";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	NameSearchSelectionFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	FilterGamesResultCriteria::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("criteria"), _fieldsWithUnparsedContent);
	CommonThin::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("loginExtraData"), _fieldsWithUnparsedContent);
	ClientMarkers::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientMarkers"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY(Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY&& _o)
	: tourns(std::move(_o.tourns))
	, tableTypes(std::move(_o.tableTypes))
	, sngTypes(std::move(_o.sngTypes))
	, sagTypes(std::move(_o.sagTypes))
	, zoomTypes(std::move(_o.zoomTypes))
	, seatFinders(std::move(_o.seatFinders))
	, gameOrder(std::move(_o.gameOrder))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY::operator=(Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY&& _o)
{
	if(this != &_o)
	{
		tourns = std::move(_o.tourns);
		tableTypes = std::move(_o.tableTypes);
		sngTypes = std::move(_o.sngTypes);
		sagTypes = std::move(_o.sagTypes);
		zoomTypes = std::move(_o.zoomTypes);
		seatFinders = std::move(_o.seatFinders);
		gameOrder = std::move(_o.gameOrder);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY::clear()
{
	tourns.clear();
	tableTypes.clear();
	sngTypes.clear();
	sagTypes.clear();
	zoomTypes.clear();
	seatFinders.clear();
	gameOrder.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY::equals(const Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY& _o) const
{
	return tourns.equals(_o.tourns) &&
		tableTypes.equals(_o.tableTypes) &&
		sngTypes.equals(_o.sngTypes) &&
		sagTypes.equals(_o.sagTypes) &&
		zoomTypes.equals(_o.zoomTypes) &&
		seatFinders.equals(_o.seatFinders) &&
		gameOrder.equals(_o.gameOrder);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY).append(")");
	_buf.append(',');
	_buf.append("tourns=");
	tourns.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableTypes=");
	tableTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sngTypes=");
	sngTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sagTypes=");
	sagTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("zoomTypes=");
	zoomTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("seatFinders=");
	seatFinders.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameOrder=");
	gameOrder.toTraceString(_buf);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY::composeMsg(CommMsgBody& _msg) const
{
	tourns.composeMsg(_msg);
	tableTypes.composeMsg(_msg);
	sngTypes.composeMsg(_msg);
	sagTypes.composeMsg(_msg);
	zoomTypes.composeMsg(_msg);
	seatFinders.composeMsg(_msg);
	gameOrder.composeMsg(_msg);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY::parseMsg(CommMsgParser& _parser)
{
	tourns.parseMsg(_parser);
	tableTypes.parseMsg(_parser);
	sngTypes.parseMsg(_parser);
	sagTypes.parseMsg(_parser);
	zoomTypes.parseMsg(_parser);
	seatFinders.parseMsg(_parser);
	gameOrder.parseMsg(_parser);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTourns = ThinAtf::LAtfVector< TournDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
	int szTableTypes = ThinAtf::LAtfVector< TableDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tableTypes", szTableTypes, _checker, __FILE__, __LINE__);
	int szSngTypes = ThinAtf::LAtfVector< SngDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sngTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sngTypes", szSngTypes, _checker, __FILE__, __LINE__);
	int szSagTypes = ThinAtf::LAtfVector< SagDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sagTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sagTypes", szSagTypes, _checker, __FILE__, __LINE__);
	int szZoomTypes = ThinAtf::LAtfVector< ZoomDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("zoomTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "zoomTypes", szZoomTypes, _checker, __FILE__, __LINE__);
	int szSeatFinders = ThinAtf::LAtfVector< SeatFinderDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("seatFinders"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "seatFinders", szSeatFinders, _checker, __FILE__, __LINE__);
	int szGameOrder = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("gameOrder"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "gameOrder", szGameOrder, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS(Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS&& _o)
	: filter(std::move(_o.filter))
	, criteria(std::move(_o.criteria))
	, loginExtraData(std::move(_o.loginExtraData))
	, clientMarkers(std::move(_o.clientMarkers))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS::operator=(Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS&& _o)
{
	if(this != &_o)
	{
		filter = std::move(_o.filter);
		criteria = std::move(_o.criteria);
		loginExtraData = std::move(_o.loginExtraData);
		clientMarkers = std::move(_o.clientMarkers);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS::clear()
{
	filter.clear();
	criteria.clear();
	loginExtraData.clear();
	clientMarkers.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS::equals(const Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS& _o) const
{
	return filter.equals(_o.filter) &&
		criteria.equals(_o.criteria) &&
		loginExtraData.equals(_o.loginExtraData) &&
		clientMarkers.equals(_o.clientMarkers);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_SEARCH_BY_NAME_PS).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("criteria=");
	criteria.toTraceString(_buf);
	_buf.append(',');
	_buf.append("loginExtraData=");
	loginExtraData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clientMarkers=");
	clientMarkers.toTraceString(_buf);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS::composeMsg(CommMsgBody& _msg) const
{
	filter.composeMsg(_msg);
	criteria.composeMsg(_msg);
	loginExtraData.composeMsg(_msg);
	clientMarkers.composeMsg(_msg);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	criteria.parseMsg(_parser);
	loginExtraData.parseMsg(_parser);
	clientMarkers.parseMsg(_parser);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_SEARCH_BY_NAME_PS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	NameSearchSelectionFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	FilterGamesResultCriteria::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("criteria"), _fieldsWithUnparsedContent);
	CommonThin::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("loginExtraData"), _fieldsWithUnparsedContent);
	ClientMarkers::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientMarkers"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY(Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY&& _o)
	: tourns(std::move(_o.tourns))
	, tableTypes(std::move(_o.tableTypes))
	, sngTypes(std::move(_o.sngTypes))
	, sagTypes(std::move(_o.sagTypes))
	, zoomTypes(std::move(_o.zoomTypes))
	, seatFinders(std::move(_o.seatFinders))
	, gameOrder(std::move(_o.gameOrder))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY::operator=(Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY&& _o)
{
	if(this != &_o)
	{
		tourns = std::move(_o.tourns);
		tableTypes = std::move(_o.tableTypes);
		sngTypes = std::move(_o.sngTypes);
		sagTypes = std::move(_o.sagTypes);
		zoomTypes = std::move(_o.zoomTypes);
		seatFinders = std::move(_o.seatFinders);
		gameOrder = std::move(_o.gameOrder);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY::clear()
{
	tourns.clear();
	tableTypes.clear();
	sngTypes.clear();
	sagTypes.clear();
	zoomTypes.clear();
	seatFinders.clear();
	gameOrder.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY::equals(const Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY& _o) const
{
	return tourns.equals(_o.tourns) &&
		tableTypes.equals(_o.tableTypes) &&
		sngTypes.equals(_o.sngTypes) &&
		sagTypes.equals(_o.sagTypes) &&
		zoomTypes.equals(_o.zoomTypes) &&
		seatFinders.equals(_o.seatFinders) &&
		gameOrder.equals(_o.gameOrder);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY).append(")");
	_buf.append(',');
	_buf.append("tourns=");
	tourns.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableTypes=");
	tableTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sngTypes=");
	sngTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sagTypes=");
	sagTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("zoomTypes=");
	zoomTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("seatFinders=");
	seatFinders.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameOrder=");
	gameOrder.toTraceString(_buf);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	tourns.composeMsg(_msg);
	tableTypes.composeMsg(_msg);
	sngTypes.composeMsg(_msg);
	sagTypes.composeMsg(_msg);
	zoomTypes.composeMsg(_msg);
	seatFinders.composeMsg(_msg);
	gameOrder.composeMsg(_msg);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY::parseMsg(CommMsgParser& _parser)
{
	tourns.parseMsg(_parser);
	tableTypes.parseMsg(_parser);
	sngTypes.parseMsg(_parser);
	sagTypes.parseMsg(_parser);
	zoomTypes.parseMsg(_parser);
	seatFinders.parseMsg(_parser);
	gameOrder.parseMsg(_parser);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTourns = ThinAtf::LAtfVector< TournDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
	int szTableTypes = ThinAtf::LAtfVector< TableDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tableTypes", szTableTypes, _checker, __FILE__, __LINE__);
	int szSngTypes = ThinAtf::LAtfVector< SngDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sngTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sngTypes", szSngTypes, _checker, __FILE__, __LINE__);
	int szSagTypes = ThinAtf::LAtfVector< SagDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sagTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sagTypes", szSagTypes, _checker, __FILE__, __LINE__);
	int szZoomTypes = ThinAtf::LAtfVector< ZoomDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("zoomTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "zoomTypes", szZoomTypes, _checker, __FILE__, __LINE__);
	int szSeatFinders = ThinAtf::LAtfVector< SeatFinderDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("seatFinders"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "seatFinders", szSeatFinders, _checker, __FILE__, __LINE__);
	int szGameOrder = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("gameOrder"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "gameOrder", szGameOrder, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS(Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS&& _o)
	: input(std::move(_o.input))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS::operator=(Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS&& _o)
{
	if(this != &_o)
	{
		input = std::move(_o.input);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS::clear()
{
	input.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS::equals(const Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS& _o) const
{
	return input.equals(_o.input);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_FILTER_TICKET_TOURNS).append(")");
	_buf.append(',');
	_buf.append("input=");
	input.toTraceString(_buf);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS::composeMsg(CommMsgBody& _msg) const
{
	input.composeMsg(_msg);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS::parseMsg(CommMsgParser& _parser)
{
	input.parseMsg(_parser);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_FILTER_TICKET_TOURNS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	TicketTournRequestData::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("input"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY(Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY&& _o)
	: ticketInfos(std::move(_o.ticketInfos))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY::operator=(Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY&& _o)
{
	if(this != &_o)
	{
		ticketInfos = std::move(_o.ticketInfos);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY::clear()
{
	ticketInfos.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY::equals(const Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY& _o) const
{
	return ticketInfos.equals(_o.ticketInfos);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY).append(")");
	_buf.append(',');
	_buf.append("ticketInfos=");
	ticketInfos.toTraceString(_buf);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	ticketInfos.composeMsg(_msg);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY::parseMsg(CommMsgParser& _parser)
{
	ticketInfos.parseMsg(_parser);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTicketInfos = ThinAtf::LAtfVector< MLobbyNG::cli::OrderedTicketTournInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("ticketInfos"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "ticketInfos", szTicketInfos, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES(Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES&& _o)
	: locale(std::move(_o.locale))
	, loginExtraData(std::move(_o.loginExtraData))
	, clientMarkers(std::move(_o.clientMarkers))
	, currencyMask(std::move(_o.currencyMask))
	, country(std::move(_o.country))
	, isPM(std::move(_o.isPM))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES::operator=(Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES&& _o)
{
	if(this != &_o)
	{
		locale = std::move(_o.locale);
		loginExtraData = std::move(_o.loginExtraData);
		clientMarkers = std::move(_o.clientMarkers);
		currencyMask = std::move(_o.currencyMask);
		country = std::move(_o.country);
		isPM = std::move(_o.isPM);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES::clear()
{
	locale = 0;
	loginExtraData.clear();
	clientMarkers.clear();
	currencyMask = 0;
	country.clear();
	isPM = false;
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES::equals(const Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES& _o) const
{
	return locale == _o.locale &&
		loginExtraData.equals(_o.loginExtraData) &&
		clientMarkers.equals(_o.clientMarkers) &&
		currencyMask == _o.currencyMask &&
		country.equals(_o.country) &&
		isPM == _o.isPM;
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_GET_BRANDED_LOBBIES).append(")");
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("loginExtraData=");
	loginExtraData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clientMarkers=");
	clientMarkers.toTraceString(_buf);
	_buf.append(',');
	_buf.append("currencyMask=");
	_buf.appendUint(currencyMask);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("isPM=");
	_buf.appendUint(isPM);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(locale);
	loginExtraData.composeMsg(_msg);
	clientMarkers.composeMsg(_msg);
	_msg.composeUINT32(currencyMask);
	_msg.composeString(country);
	_msg.composeBOOL(isPM);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(locale);
	loginExtraData.parseMsg(_parser);
	clientMarkers.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(currencyMask);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(country);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(isPM);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_GET_BRANDED_LOBBIES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	PString _descbuf;
	CommonThin::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("loginExtraData"), _fieldsWithUnparsedContent);
	ClientMarkers::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientMarkers"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	UINT32 currencyMask; _parser.parseUINT32(currencyMask);
	AtfValidator::validateInt(_descr, "currencyMask", currencyMask, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool isPM; _parser.parseBOOL(isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY(Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY&& _o)
	: lobbies(std::move(_o.lobbies))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY::operator=(Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY&& _o)
{
	if(this != &_o)
	{
		lobbies = std::move(_o.lobbies);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY::clear()
{
	lobbies.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY::equals(const Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY& _o) const
{
	return lobbies.equals(_o.lobbies);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY).append(")");
	_buf.append(',');
	_buf.append("lobbies=");
	lobbies.toTraceString(_buf);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY::composeMsg(CommMsgBody& _msg) const
{
	lobbies.composeMsg(_msg);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY::parseMsg(CommMsgParser& _parser)
{
	lobbies.parseMsg(_parser);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szLobbies = ThinAtf::LAtfVector< BrandedLobbyInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("lobbies"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "lobbies", szLobbies, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF(Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF&& _o)
	: input(std::move(_o.input))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF::operator=(Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF&& _o)
{
	if(this != &_o)
	{
		input = std::move(_o.input);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF::clear()
{
	input.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF::equals(const Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF& _o) const
{
	return input.equals(_o.input);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_FIND_TOURNS_BY_REF).append(")");
	_buf.append(',');
	_buf.append("input=");
	input.toTraceString(_buf);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF::composeMsg(CommMsgBody& _msg) const
{
	input.composeMsg(_msg);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF::parseMsg(CommMsgParser& _parser)
{
	input.parseMsg(_parser);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_FIND_TOURNS_BY_REF";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	FindTournsByRefFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("input"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY
//=================================================================

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY(Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY&& _o)
	: tourns(std::move(_o.tourns))
{
}

MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY& MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY::operator=(Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY&& _o)
{
	if(this != &_o)
	{
		tourns = std::move(_o.tourns);
	}
	return *this;
}

#endif

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY::clear()
{
	tourns.clear();
}

bool MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY::equals(const Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY& _o) const
{
	return tourns.equals(_o.tourns);
}

const char *MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY).append(")");
	_buf.append(',');
	_buf.append("tourns=");
	tourns.toTraceString(_buf);
	return _buf.c_str();
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY::composeMsg(CommMsgBody& _msg) const
{
	tourns.composeMsg(_msg);
}

void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY::parseMsg(CommMsgParser& _parser)
{
	tourns.parseMsg(_parser);
}

/*static*/ void MLobbyNG::cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTourns = ThinAtf::LAtfVector< TournDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ bool MLobbyNG::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_MLOBBYNG_FILTER_GAMES: cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_FILTER_GAMES_PS: cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY: cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_PS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_FILTER_GAMES_REPLY: cli::Protocol_MSG_MLOBBYNG_FILTER_GAMES_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_FILTER_TICKET_TOURNS: cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY: cli::Protocol_MSG_MLOBBYNG_FILTER_TICKET_TOURNS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_FIND_TOURNS_BY_REF: cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY: cli::Protocol_MSG_MLOBBYNG_FIND_TOURNS_BY_REF_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_GET_BRANDED_LOBBIES: cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY: cli::Protocol_MSG_MLOBBYNG_GET_BRANDED_LOBBIES_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_GET_GAME_CONN_INFO: cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY: cli::Protocol_MSG_MLOBBYNG_GET_GAME_CONN_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_GET_GAME_INFO: cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_GET_GAME_INFO_REPLY: cli::Protocol_MSG_MLOBBYNG_GET_GAME_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_GET_GAME_LIST: cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_GET_GAME_LIST_REPLY: cli::Protocol_MSG_MLOBBYNG_GET_GAME_LIST_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_GET_SUGGESTED_GAMES2: cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS: cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY: cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_PS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY: cli::Protocol_MSG_MLOBBYNG_GET_SUGGESTED_GAMES2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_SEARCH_BY_NAME: cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_SEARCH_BY_NAME_PS: cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY: cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_PS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY: cli::Protocol_MSG_MLOBBYNG_SEARCH_BY_NAME_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_SNG_COUNTS: cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_SNG_COUNTS_REPLY: cli::Protocol_MSG_MLOBBYNG_SNG_COUNTS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_TABLE_TYPE_COUNTS: cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY: cli::Protocol_MSG_MLOBBYNG_TABLE_TYPE_COUNTS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_TICKET_TOURNS: cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_TICKET_TOURNS_REPLY: cli::Protocol_MSG_MLOBBYNG_TICKET_TOURNS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_TOURNAMENT_COUNTS: cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY: cli::Protocol_MSG_MLOBBYNG_TOURNAMENT_COUNTS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

