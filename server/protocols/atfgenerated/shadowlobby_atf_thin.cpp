/**
 * shadowlobby_atf_thin.cpp
 *
 * This file was auto-generated from shadowlobby_atf.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor -thin shadowlobby_atf.txt
 */
 
#include "shadowlobby_atf_thin.h"

//=================================================================
//                    TableType2
//=================================================================

ShadowLobby::publication::TableType2::TableType2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

ShadowLobby::publication::TableType2::TableType2(TableType2&& _o)
	: tableTypeId(std::move(_o.tableTypeId))
	, siteVisibilityMask(std::move(_o.siteVisibilityMask))
	, brandVisibilityMask(std::move(_o.brandVisibilityMask))
	, invertCountryFilter(std::move(_o.invertCountryFilter))
	, countryFilter(std::move(_o.countryFilter))
	, quickLobbyVisible(std::move(_o.quickLobbyVisible))
	, game(std::move(_o.game))
	, structure(std::move(_o.structure))
	, isHiLo(std::move(_o.isHiLo))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, currency(std::move(_o.currency))
	, loBet(std::move(_o.loBet))
	, hiBet(std::move(_o.hiBet))
	, cap(std::move(_o.cap))
	, ante(std::move(_o.ante))
	, minChipsLimit(std::move(_o.minChipsLimit))
	, maxBuyIn(std::move(_o.maxBuyIn))
	, playerPerTable(std::move(_o.playerPerTable))
	, scalePM(std::move(_o.scalePM))
	, defaultBuyIn(std::move(_o.defaultBuyIn))
	, seatFinderId(std::move(_o.seatFinderId))
	, poolBlockMinHands(std::move(_o.poolBlockMinHands))
	, poolBlockTimePenalty(std::move(_o.poolBlockTimePenalty))
	, passwordProtected(std::move(_o.passwordProtected))
	, morphLobby(std::move(_o.morphLobby))
	, tableStakes(std::move(_o.tableStakes))
	, variableAntes(std::move(_o.variableAntes))
	, isHybridSingle(std::move(_o.isHybridSingle))
	, siteVisibilityMaskEx(std::move(_o.siteVisibilityMaskEx))
	, tableFlags2(std::move(_o.tableFlags2))
{
}

ShadowLobby::publication::TableType2& ShadowLobby::publication::TableType2::operator=(TableType2&& _o)
{
	if(this != &_o)
	{
		tableTypeId = std::move(_o.tableTypeId);
		siteVisibilityMask = std::move(_o.siteVisibilityMask);
		brandVisibilityMask = std::move(_o.brandVisibilityMask);
		invertCountryFilter = std::move(_o.invertCountryFilter);
		countryFilter = std::move(_o.countryFilter);
		quickLobbyVisible = std::move(_o.quickLobbyVisible);
		game = std::move(_o.game);
		structure = std::move(_o.structure);
		isHiLo = std::move(_o.isHiLo);
		isPlayMoney = std::move(_o.isPlayMoney);
		currency = std::move(_o.currency);
		loBet = std::move(_o.loBet);
		hiBet = std::move(_o.hiBet);
		cap = std::move(_o.cap);
		ante = std::move(_o.ante);
		minChipsLimit = std::move(_o.minChipsLimit);
		maxBuyIn = std::move(_o.maxBuyIn);
		playerPerTable = std::move(_o.playerPerTable);
		scalePM = std::move(_o.scalePM);
		defaultBuyIn = std::move(_o.defaultBuyIn);
		seatFinderId = std::move(_o.seatFinderId);
		poolBlockMinHands = std::move(_o.poolBlockMinHands);
		poolBlockTimePenalty = std::move(_o.poolBlockTimePenalty);
		passwordProtected = std::move(_o.passwordProtected);
		morphLobby = std::move(_o.morphLobby);
		tableStakes = std::move(_o.tableStakes);
		variableAntes = std::move(_o.variableAntes);
		isHybridSingle = std::move(_o.isHybridSingle);
		siteVisibilityMaskEx = std::move(_o.siteVisibilityMaskEx);
		tableFlags2 = std::move(_o.tableFlags2);
	}
	return *this;
}

#endif

void ShadowLobby::publication::TableType2::clear()
{
	tableTypeId = 0;
	siteVisibilityMask = 0;
	brandVisibilityMask = 0;
	invertCountryFilter = false;
	countryFilter.clear();
	quickLobbyVisible = false;
	game = 0;
	structure = 0;
	isHiLo = 0;
	isPlayMoney = 0;
	currency.clear();
	loBet = 0;
	hiBet = 0;
	cap = 0;
	ante = 0;
	minChipsLimit = 0;
	maxBuyIn = 0;
	playerPerTable = 0;
	scalePM = 0;
	defaultBuyIn = 0;
	seatFinderId = 0;
	poolBlockMinHands = 0;
	poolBlockTimePenalty.clear();
	passwordProtected = false;
	morphLobby = false;
	tableStakes.clear();
	variableAntes.clear();
	isHybridSingle = false;
	siteVisibilityMaskEx.clear();
	tableFlags2 = 0;
}

bool ShadowLobby::publication::TableType2::equals(const TableType2& _o) const
{
	return tableTypeId == _o.tableTypeId &&
		siteVisibilityMask == _o.siteVisibilityMask &&
		brandVisibilityMask == _o.brandVisibilityMask &&
		invertCountryFilter == _o.invertCountryFilter &&
		countryFilter.equals(_o.countryFilter) &&
		quickLobbyVisible == _o.quickLobbyVisible &&
		game == _o.game &&
		structure == _o.structure &&
		isHiLo == _o.isHiLo &&
		isPlayMoney == _o.isPlayMoney &&
		currency.equals(_o.currency) &&
		loBet == _o.loBet &&
		hiBet == _o.hiBet &&
		cap == _o.cap &&
		ante == _o.ante &&
		minChipsLimit == _o.minChipsLimit &&
		maxBuyIn == _o.maxBuyIn &&
		playerPerTable == _o.playerPerTable &&
		scalePM == _o.scalePM &&
		defaultBuyIn == _o.defaultBuyIn &&
		seatFinderId == _o.seatFinderId &&
		poolBlockMinHands == _o.poolBlockMinHands &&
		poolBlockTimePenalty.equals(_o.poolBlockTimePenalty) &&
		passwordProtected == _o.passwordProtected &&
		morphLobby == _o.morphLobby &&
		tableStakes.equals(_o.tableStakes) &&
		variableAntes.equals(_o.variableAntes) &&
		isHybridSingle == _o.isHybridSingle &&
		siteVisibilityMaskEx.equals(_o.siteVisibilityMaskEx) &&
		tableFlags2 == _o.tableFlags2;
}

const char *ShadowLobby::publication::TableType2::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tableTypeId=");
	_buf.appendUint(tableTypeId);
	_buf.append(',');
	_buf.append("siteVisibilityMask=");
	_buf.appendUint(siteVisibilityMask);
	_buf.append(',');
	_buf.append("brandVisibilityMask=");
	_buf.appendUint(brandVisibilityMask);
	_buf.append(',');
	_buf.append("invertCountryFilter=");
	_buf.appendUint(invertCountryFilter);
	_buf.append(',');
	_buf.append("countryFilter=");
	countryFilter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("quickLobbyVisible=");
	_buf.appendUint(quickLobbyVisible);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("loBet=");
	_buf.appendUint(loBet);
	_buf.append(',');
	_buf.append("hiBet=");
	_buf.appendUint(hiBet);
	_buf.append(',');
	_buf.append("cap=");
	_buf.appendUint(cap);
	_buf.append(',');
	_buf.append("ante=");
	_buf.appendUint(ante);
	_buf.append(',');
	_buf.append("minChipsLimit=");
	_buf.appendUint(minChipsLimit);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendUint(maxBuyIn);
	_buf.append(',');
	_buf.append("playerPerTable=");
	_buf.appendUint(playerPerTable);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("defaultBuyIn=");
	_buf.appendUint(defaultBuyIn);
	_buf.append(',');
	_buf.append("seatFinderId=");
	_buf.appendUint(seatFinderId);
	_buf.append(',');
	_buf.append("poolBlockMinHands=");
	_buf.appendInt(poolBlockMinHands);
	_buf.append(',');
	_buf.append("poolBlockTimePenalty=");
	poolBlockTimePenalty.toTraceString(_buf);
	_buf.append(',');
	_buf.append("passwordProtected=");
	_buf.appendUint(passwordProtected);
	_buf.append(',');
	_buf.append("morphLobby=");
	_buf.appendUint(morphLobby);
	_buf.append(',');
	_buf.append("tableStakes=");
	tableStakes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("variableAntes=");
	variableAntes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("isHybridSingle=");
	_buf.appendUint(isHybridSingle);
	_buf.append(',');
	_buf.append("siteVisibilityMaskEx=");
	siteVisibilityMaskEx.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableFlags2=");
	_buf.appendUint64(tableFlags2);
	_buf.append('}');
	return _buf.c_str();
}

void ShadowLobby::publication::TableType2::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(tableTypeId);
	_msg.composeUINT32(siteVisibilityMask);
	_msg.composeUINT32(brandVisibilityMask);
	_msg.composeBOOL(invertCountryFilter);
	countryFilter.composeMsg(_msg);
	_msg.composeBOOL(quickLobbyVisible);
	_msg.composeBYTE(game);
	_msg.composeBYTE(structure);
	_msg.composeBYTE(isHiLo);
	_msg.composeBYTE(isPlayMoney);
	_msg.composeString(currency);
	_msg.composeUINT32(loBet);
	_msg.composeUINT32(hiBet);
	_msg.composeUINT32(cap);
	_msg.composeUINT32(ante);
	_msg.composeUINT32(minChipsLimit);
	_msg.composeUINT32(maxBuyIn);
	_msg.composeBYTE(playerPerTable);
	_msg.composeUINT32(scalePM);
	_msg.composeUINT32(defaultBuyIn);
	_msg.composeUINT32(seatFinderId);
	_msg.composeINT32(poolBlockMinHands);
	poolBlockTimePenalty.composeMsg(_msg);
	_msg.composeBOOL(passwordProtected);
	_msg.composeBOOL(morphLobby);
	tableStakes.composeMsg(_msg);
	variableAntes.composeMsg(_msg);
	_msg.composeBOOL(isHybridSingle);
	siteVisibilityMaskEx.composeMsg(_msg);
	_msg.composeUINT64(tableFlags2);
}

void ShadowLobby::publication::TableType2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tableTypeId);
	_parser.parseUINT32(siteVisibilityMask);
	_parser.parseUINT32(brandVisibilityMask);
	_parser.parseBOOL(invertCountryFilter);
	countryFilter.parseMsg(_parser);
	_parser.parseBOOL(quickLobbyVisible);
	_parser.parseBYTE(game);
	_parser.parseBYTE(structure);
	_parser.parseBYTE(isHiLo);
	_parser.parseBYTE(isPlayMoney);
	_parser.parseStringP(currency);
	_parser.parseUINT32(loBet);
	_parser.parseUINT32(hiBet);
	_parser.parseUINT32(cap);
	_parser.parseUINT32(ante);
	_parser.parseUINT32(minChipsLimit);
	_parser.parseUINT32(maxBuyIn);
	_parser.parseBYTE(playerPerTable);
	_parser.parseUINT32(scalePM);
	_parser.parseUINT32(defaultBuyIn);
	_parser.parseUINT32(seatFinderId);
	_parser.parseINT32(poolBlockMinHands);
	poolBlockTimePenalty.parseMsg(_parser);
	_parser.parseBOOL(passwordProtected);
	_parser.parseBOOL(morphLobby);
	if(_parser.parseEnded()) return;
	tableStakes.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	variableAntes.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(isHybridSingle);
	if(_parser.parseEnded()) return;
	siteVisibilityMaskEx.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(tableFlags2);
}

/*static*/ void ShadowLobby::publication::TableType2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 tableTypeId; _parser.parseUINT32(tableTypeId);
	AtfValidator::validateInt(_descr, "tableTypeId", tableTypeId, _checker, __FILE__, __LINE__);
	UINT32 siteVisibilityMask; _parser.parseUINT32(siteVisibilityMask);
	AtfValidator::validateInt(_descr, "siteVisibilityMask", siteVisibilityMask, _checker, __FILE__, __LINE__);
	UINT32 brandVisibilityMask; _parser.parseUINT32(brandVisibilityMask);
	AtfValidator::validateInt(_descr, "brandVisibilityMask", brandVisibilityMask, _checker, __FILE__, __LINE__);
	bool invertCountryFilter; _parser.parseBOOL(invertCountryFilter);
	AtfValidator::validateInt(_descr, "invertCountryFilter", invertCountryFilter, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szCountryFilter = ThinAtf::LAtfVector< PString , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("countryFilter"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "countryFilter", szCountryFilter, _checker, __FILE__, __LINE__);
	bool quickLobbyVisible; _parser.parseBOOL(quickLobbyVisible);
	AtfValidator::validateInt(_descr, "quickLobbyVisible", quickLobbyVisible, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 loBet; _parser.parseUINT32(loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	UINT32 hiBet; _parser.parseUINT32(hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	UINT32 cap; _parser.parseUINT32(cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	UINT32 ante; _parser.parseUINT32(ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	UINT32 minChipsLimit; _parser.parseUINT32(minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	UINT32 maxBuyIn; _parser.parseUINT32(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	BYTE playerPerTable; _parser.parseBYTE(playerPerTable);
	AtfValidator::validateInt(_descr, "playerPerTable", playerPerTable, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT32 defaultBuyIn; _parser.parseUINT32(defaultBuyIn);
	AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	UINT32 seatFinderId; _parser.parseUINT32(seatFinderId);
	AtfValidator::validateInt(_descr, "seatFinderId", seatFinderId, _checker, __FILE__, __LINE__);
	INT32 poolBlockMinHands; _parser.parseINT32(poolBlockMinHands);
	AtfValidator::validateInt(_descr, "poolBlockMinHands", poolBlockMinHands, _checker, __FILE__, __LINE__);
	int szPoolBlockTimePenalty = ThinAtf::LAtfVector< INT32 , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("poolBlockTimePenalty"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "poolBlockTimePenalty", szPoolBlockTimePenalty, _checker, __FILE__, __LINE__);
	bool passwordProtected; _parser.parseBOOL(passwordProtected);
	AtfValidator::validateInt(_descr, "passwordProtected", passwordProtected, _checker, __FILE__, __LINE__);
	bool morphLobby; _parser.parseBOOL(morphLobby);
	AtfValidator::validateInt(_descr, "morphLobby", morphLobby, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	TableCommonThin::TableStakes::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableStakes"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	int szVariableAntes = ThinAtf::LAtfVector< INT64 , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("variableAntes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "variableAntes", szVariableAntes, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool isHybridSingle; _parser.parseBOOL(isHybridSingle);
	AtfValidator::validateInt(_descr, "isHybridSingle", isHybridSingle, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PSiteMask::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("siteVisibilityMaskEx"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	UINT64 tableFlags2; _parser.parseUINT64(tableFlags2);
	AtfValidator::validateUint(_descr, "tableFlags2", tableFlags2, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TableSubscr_Static
//=================================================================

ShadowLobby::publication::TableSubscr_Static::TableSubscr_Static()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

ShadowLobby::publication::TableSubscr_Static::TableSubscr_Static(TableSubscr_Static&& _o)
	: _obsolete_1(std::move(_o._obsolete_1))
	, name(std::move(_o.name))
	, server(std::move(_o.server))
	, serverObject(std::move(_o.serverObject))
	, tableFlags(std::move(_o.tableFlags))
	, isOneOnOne(std::move(_o.isOneOnOne))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, playerPerTable(std::move(_o.playerPerTable))
	, game(std::move(_o.game))
	, isHiLo(std::move(_o.isHiLo))
	, _obsolete_2(std::move(_o._obsolete_2))
	, _obsolete_3(std::move(_o._obsolete_3))
	, structure(std::move(_o.structure))
	, typeName(std::move(_o.typeName))
	, _obsolete_4(std::move(_o._obsolete_4))
	, chatLang(std::move(_o.chatLang))
	, currency(std::move(_o.currency))
	, minChipsLimit(std::move(_o.minChipsLimit))
	, maxBuyIn(std::move(_o.maxBuyIn))
	, _obsolete_5(std::move(_o._obsolete_5))
	, countryFilter(std::move(_o.countryFilter))
	, cap(std::move(_o.cap))
	, iconIndex(std::move(_o.iconIndex))
	, filterIndex(std::move(_o.filterIndex))
	, tableInstanceFlag(std::move(_o.tableInstanceFlag))
	, _obsolete_6(std::move(_o._obsolete_6))
	, tableFlags2(std::move(_o.tableFlags2))
	, tableTypeId(std::move(_o.tableTypeId))
	, scalePM(std::move(_o.scalePM))
	, defaultBuyIn(std::move(_o.defaultBuyIn))
	, tableId(std::move(_o.tableId))
	, brandVisibilityMask(std::move(_o.brandVisibilityMask))
	, _obsolete_7(std::move(_o._obsolete_7))
	, criteria(std::move(_o.criteria))
	, tableStakes(std::move(_o.tableStakes))
	, varAnte(std::move(_o.varAnte))
	, siteVisibilityMask(std::move(_o.siteVisibilityMask))
{
}

ShadowLobby::publication::TableSubscr_Static& ShadowLobby::publication::TableSubscr_Static::operator=(TableSubscr_Static&& _o)
{
	if(this != &_o)
	{
		_obsolete_1 = std::move(_o._obsolete_1);
		name = std::move(_o.name);
		server = std::move(_o.server);
		serverObject = std::move(_o.serverObject);
		tableFlags = std::move(_o.tableFlags);
		isOneOnOne = std::move(_o.isOneOnOne);
		isPlayMoney = std::move(_o.isPlayMoney);
		playerPerTable = std::move(_o.playerPerTable);
		game = std::move(_o.game);
		isHiLo = std::move(_o.isHiLo);
		_obsolete_2 = std::move(_o._obsolete_2);
		_obsolete_3 = std::move(_o._obsolete_3);
		structure = std::move(_o.structure);
		typeName = std::move(_o.typeName);
		_obsolete_4 = std::move(_o._obsolete_4);
		chatLang = std::move(_o.chatLang);
		currency = std::move(_o.currency);
		minChipsLimit = std::move(_o.minChipsLimit);
		maxBuyIn = std::move(_o.maxBuyIn);
		_obsolete_5 = std::move(_o._obsolete_5);
		countryFilter = std::move(_o.countryFilter);
		cap = std::move(_o.cap);
		iconIndex = std::move(_o.iconIndex);
		filterIndex = std::move(_o.filterIndex);
		tableInstanceFlag = std::move(_o.tableInstanceFlag);
		_obsolete_6 = std::move(_o._obsolete_6);
		tableFlags2 = std::move(_o.tableFlags2);
		tableTypeId = std::move(_o.tableTypeId);
		scalePM = std::move(_o.scalePM);
		defaultBuyIn = std::move(_o.defaultBuyIn);
		tableId = std::move(_o.tableId);
		brandVisibilityMask = std::move(_o.brandVisibilityMask);
		_obsolete_7 = std::move(_o._obsolete_7);
		criteria = std::move(_o.criteria);
		tableStakes = std::move(_o.tableStakes);
		varAnte = std::move(_o.varAnte);
		siteVisibilityMask = std::move(_o.siteVisibilityMask);
	}
	return *this;
}

#endif

void ShadowLobby::publication::TableSubscr_Static::clear()
{
	_obsolete_1 = 0;
	name.clear();
	server.clear();
	serverObject.clear();
	tableFlags = 0;
	isOneOnOne = 0;
	isPlayMoney = 0;
	playerPerTable = 0;
	game = 0;
	isHiLo = 0;
	_obsolete_2 = 0;
	_obsolete_3 = 0;
	structure = 0;
	typeName.clear();
	_obsolete_4 = 0;
	chatLang = 0;
	currency.clear();
	minChipsLimit = 0;
	maxBuyIn = 0;
	_obsolete_5 = 0;
	countryFilter.clear();
	cap = 0;
	iconIndex = 0;
	filterIndex = 0;
	tableInstanceFlag = 0;
	_obsolete_6 = false;
	tableFlags2 = 0;
	tableTypeId = 0;
	scalePM = 0;
	defaultBuyIn = 0;
	tableId = 0;
	brandVisibilityMask = 0;
	_obsolete_7 = 0;
	criteria.clear();
	tableStakes.clear();
	varAnte.clear();
	siteVisibilityMask.clear();
}

bool ShadowLobby::publication::TableSubscr_Static::equals(const TableSubscr_Static& _o) const
{
	return _obsolete_1 == _o._obsolete_1 &&
		name.equals(_o.name) &&
		server.equals(_o.server) &&
		serverObject.equals(_o.serverObject) &&
		tableFlags == _o.tableFlags &&
		isOneOnOne == _o.isOneOnOne &&
		isPlayMoney == _o.isPlayMoney &&
		playerPerTable == _o.playerPerTable &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		_obsolete_2 == _o._obsolete_2 &&
		_obsolete_3 == _o._obsolete_3 &&
		structure == _o.structure &&
		typeName.equals(_o.typeName) &&
		_obsolete_4 == _o._obsolete_4 &&
		chatLang == _o.chatLang &&
		currency.equals(_o.currency) &&
		minChipsLimit == _o.minChipsLimit &&
		maxBuyIn == _o.maxBuyIn &&
		_obsolete_5 == _o._obsolete_5 &&
		countryFilter.equals(_o.countryFilter) &&
		cap == _o.cap &&
		iconIndex == _o.iconIndex &&
		filterIndex == _o.filterIndex &&
		tableInstanceFlag == _o.tableInstanceFlag &&
		_obsolete_6 == _o._obsolete_6 &&
		tableFlags2 == _o.tableFlags2 &&
		tableTypeId == _o.tableTypeId &&
		scalePM == _o.scalePM &&
		defaultBuyIn == _o.defaultBuyIn &&
		tableId == _o.tableId &&
		brandVisibilityMask == _o.brandVisibilityMask &&
		_obsolete_7 == _o._obsolete_7 &&
		criteria.equals(_o.criteria) &&
		tableStakes.equals(_o.tableStakes) &&
		varAnte.equals(_o.varAnte) &&
		siteVisibilityMask.equals(_o.siteVisibilityMask);
}

const char *ShadowLobby::publication::TableSubscr_Static::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("_obsolete_1=");
	_buf.appendUint(_obsolete_1);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("serverObject=");
	_buf.append(serverObject);
	_buf.append(',');
	_buf.append("tableFlags=");
	_buf.appendUint(tableFlags);
	_buf.append(',');
	_buf.append("isOneOnOne=");
	_buf.appendUint(isOneOnOne);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("playerPerTable=");
	_buf.appendUint(playerPerTable);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("_obsolete_2=");
	_buf.appendUint(_obsolete_2);
	_buf.append(',');
	_buf.append("_obsolete_3=");
	_buf.appendUint(_obsolete_3);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("typeName=");
	_buf.append(typeName);
	_buf.append(',');
	_buf.append("_obsolete_4=");
	_buf.appendUint(_obsolete_4);
	_buf.append(',');
	_buf.append("chatLang=");
	_buf.appendUint(chatLang);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("minChipsLimit=");
	_buf.appendUint(minChipsLimit);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendUint(maxBuyIn);
	_buf.append(',');
	_buf.append("_obsolete_5=");
	_buf.appendUint(_obsolete_5);
	_buf.append(',');
	_buf.append("countryFilter=");
	countryFilter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("cap=");
	_buf.appendUint(cap);
	_buf.append(',');
	_buf.append("iconIndex=");
	_buf.appendUint(iconIndex);
	_buf.append(',');
	_buf.append("filterIndex=");
	_buf.appendUint(filterIndex);
	_buf.append(',');
	_buf.append("tableInstanceFlag=");
	_buf.appendUint(tableInstanceFlag);
	_buf.append(',');
	_buf.append("_obsolete_6=");
	_buf.appendUint(_obsolete_6);
	_buf.append(',');
	_buf.append("tableFlags2=");
	_buf.appendUint64(tableFlags2);
	_buf.append(',');
	_buf.append("tableTypeId=");
	_buf.appendUint(tableTypeId);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("defaultBuyIn=");
	_buf.appendUint(defaultBuyIn);
	_buf.append(',');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	_buf.append(',');
	_buf.append("brandVisibilityMask=");
	_buf.appendUint(brandVisibilityMask);
	_buf.append(',');
	_buf.append("_obsolete_7=");
	_buf.appendInt(_obsolete_7);
	_buf.append(',');
	_buf.append("criteria=");
	_buf.append(criteria);
	_buf.append(',');
	_buf.append("tableStakes=");
	tableStakes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("varAnte=");
	varAnte.toTraceString(_buf);
	_buf.append(',');
	_buf.append("siteVisibilityMask=");
	siteVisibilityMask.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void ShadowLobby::publication::TableSubscr_Static::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(_obsolete_1);
	_msg.composeString(name);
	_msg.composeString(server);
	_msg.composeString(serverObject);
	_msg.composeUINT32(tableFlags);
	_msg.composeBYTE(isOneOnOne);
	_msg.composeBYTE(isPlayMoney);
	_msg.composeBYTE(playerPerTable);
	_msg.composeBYTE(game);
	_msg.composeBYTE(isHiLo);
	_msg.composeUINT32(_obsolete_2);
	_msg.composeUINT32(_obsolete_3);
	_msg.composeBYTE(structure);
	_msg.composeString(typeName);
	_msg.composeUINT32(_obsolete_4);
	_msg.composeUINT16(chatLang);
	_msg.composeString(currency);
	_msg.composeUINT32(minChipsLimit);
	_msg.composeUINT32(maxBuyIn);
	_msg.composeUINT32(_obsolete_5);
	countryFilter.composeMsg(_msg);
	_msg.composeUINT32(cap);
	_msg.composeBYTE(iconIndex);
	_msg.composeBYTE(filterIndex);
	_msg.composeUINT32(tableInstanceFlag);
	_msg.composeBOOL(_obsolete_6);
	_msg.composeUINT64(tableFlags2);
	_msg.composeUINT32(tableTypeId);
	_msg.composeUINT32(scalePM);
	_msg.composeUINT32(defaultBuyIn);
	_msg.composeUINT64(tableId);
	_msg.composeUINT32(brandVisibilityMask);
	_msg.composeINT32(_obsolete_7);
	_msg.composeString(criteria);
	tableStakes.composeMsg(_msg);
	varAnte.composeMsg(_msg);
	siteVisibilityMask.composeMsg(_msg);
}

void ShadowLobby::publication::TableSubscr_Static::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(_obsolete_1);
	_parser.parseStringP(name);
	_parser.parseStringP(server);
	_parser.parseStringP(serverObject);
	_parser.parseUINT32(tableFlags);
	_parser.parseBYTE(isOneOnOne);
	_parser.parseBYTE(isPlayMoney);
	_parser.parseBYTE(playerPerTable);
	_parser.parseBYTE(game);
	_parser.parseBYTE(isHiLo);
	_parser.parseUINT32(_obsolete_2);
	_parser.parseUINT32(_obsolete_3);
	_parser.parseBYTE(structure);
	_parser.parseStringP(typeName);
	_parser.parseUINT32(_obsolete_4);
	_parser.parseUINT16(chatLang);
	_parser.parseStringP(currency);
	_parser.parseUINT32(minChipsLimit);
	_parser.parseUINT32(maxBuyIn);
	_parser.parseUINT32(_obsolete_5);
	countryFilter.parseMsg(_parser);
	_parser.parseUINT32(cap);
	_parser.parseBYTE(iconIndex);
	_parser.parseBYTE(filterIndex);
	_parser.parseUINT32(tableInstanceFlag);
	_parser.parseBOOL(_obsolete_6);
	_parser.parseUINT64(tableFlags2);
	_parser.parseUINT32(tableTypeId);
	_parser.parseUINT32(scalePM);
	_parser.parseUINT32(defaultBuyIn);
	_parser.parseUINT64(tableId);
	_parser.parseUINT32(brandVisibilityMask);
	_parser.parseINT32(_obsolete_7);
	_parser.parseStringP(criteria);
	tableStakes.parseMsg(_parser);
	varAnte.parseMsg(_parser);
	siteVisibilityMask.parseMsg(_parser);
}

/*static*/ void ShadowLobby::publication::TableSubscr_Static::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 _obsolete_1; _parser.parseUINT32(_obsolete_1);
	AtfValidator::validateInt(_descr, "_obsolete_1", _obsolete_1, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "serverObject"); size_t szServerObject = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObject", szServerObject, _checker, __FILE__, __LINE__);
	UINT32 tableFlags; _parser.parseUINT32(tableFlags);
	AtfValidator::validateInt(_descr, "tableFlags", tableFlags, _checker, __FILE__, __LINE__);
	BYTE isOneOnOne; _parser.parseBYTE(isOneOnOne);
	AtfValidator::validateInt(_descr, "isOneOnOne", isOneOnOne, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	BYTE playerPerTable; _parser.parseBYTE(playerPerTable);
	AtfValidator::validateInt(_descr, "playerPerTable", playerPerTable, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	UINT32 _obsolete_2; _parser.parseUINT32(_obsolete_2);
	AtfValidator::validateInt(_descr, "_obsolete_2", _obsolete_2, _checker, __FILE__, __LINE__);
	UINT32 _obsolete_3; _parser.parseUINT32(_obsolete_3);
	AtfValidator::validateInt(_descr, "_obsolete_3", _obsolete_3, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "typeName"); size_t szTypeName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "typeName", szTypeName, _checker, __FILE__, __LINE__);
	UINT32 _obsolete_4; _parser.parseUINT32(_obsolete_4);
	AtfValidator::validateInt(_descr, "_obsolete_4", _obsolete_4, _checker, __FILE__, __LINE__);
	UINT16 chatLang; _parser.parseUINT16(chatLang);
	AtfValidator::validateInt(_descr, "chatLang", chatLang, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 minChipsLimit; _parser.parseUINT32(minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	UINT32 maxBuyIn; _parser.parseUINT32(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	UINT32 _obsolete_5; _parser.parseUINT32(_obsolete_5);
	AtfValidator::validateInt(_descr, "_obsolete_5", _obsolete_5, _checker, __FILE__, __LINE__);
	PString _descbuf;
	CommonThin::AtfShared::LegacyCountryVisibilityFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("countryFilter"), _fieldsWithUnparsedContent);
	UINT32 cap; _parser.parseUINT32(cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	BYTE iconIndex; _parser.parseBYTE(iconIndex);
	AtfValidator::validateInt(_descr, "iconIndex", iconIndex, _checker, __FILE__, __LINE__);
	BYTE filterIndex; _parser.parseBYTE(filterIndex);
	AtfValidator::validateInt(_descr, "filterIndex", filterIndex, _checker, __FILE__, __LINE__);
	UINT32 tableInstanceFlag; _parser.parseUINT32(tableInstanceFlag);
	AtfValidator::validateInt(_descr, "tableInstanceFlag", tableInstanceFlag, _checker, __FILE__, __LINE__);
	bool _obsolete_6; _parser.parseBOOL(_obsolete_6);
	AtfValidator::validateInt(_descr, "_obsolete_6", _obsolete_6, _checker, __FILE__, __LINE__);
	UINT64 tableFlags2; _parser.parseUINT64(tableFlags2);
	AtfValidator::validateUint(_descr, "tableFlags2", tableFlags2, _checker, __FILE__, __LINE__);
	UINT32 tableTypeId; _parser.parseUINT32(tableTypeId);
	AtfValidator::validateInt(_descr, "tableTypeId", tableTypeId, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT32 defaultBuyIn; _parser.parseUINT32(defaultBuyIn);
	AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	UINT64 tableId; _parser.parseUINT64(tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	UINT32 brandVisibilityMask; _parser.parseUINT32(brandVisibilityMask);
	AtfValidator::validateInt(_descr, "brandVisibilityMask", brandVisibilityMask, _checker, __FILE__, __LINE__);
	INT32 _obsolete_7; _parser.parseINT32(_obsolete_7);
	AtfValidator::validateInt(_descr, "_obsolete_7", _obsolete_7, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "criteria"); size_t szCriteria = strlen(_dummy);
	AtfValidator::validateInt(_descr, "criteria", szCriteria, _checker, __FILE__, __LINE__);
	TableCommonThin::TableStakes::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableStakes"), _fieldsWithUnparsedContent);
	int szVarAnte = ThinAtf::LAtfVector< INT64 , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("varAnte"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "varAnte", szVarAnte, _checker, __FILE__, __LINE__);
	PSiteMask::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("siteVisibilityMask"), _fieldsWithUnparsedContent);
}

//=================================================================
//                    TableSubscr_Status
//=================================================================

ShadowLobby::publication::TableSubscr_Status::TableSubscr_Status()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

ShadowLobby::publication::TableSubscr_Status::TableSubscr_Status(TableSubscr_Status&& _o)
	: players(std::move(_o.players))
	, waitingList(std::move(_o.waitingList))
	, playersPerFlop(std::move(_o.playersPerFlop))
	, averagePot(std::move(_o.averagePot))
	, handsPerHour(std::move(_o.handsPerHour))
	, publPropFlag(std::move(_o.publPropFlag))
	, averageStack(std::move(_o.averageStack))
	, vpip(std::move(_o.vpip))
	, fppFactor(std::move(_o.fppFactor))
	, active(std::move(_o.active))
{
}

ShadowLobby::publication::TableSubscr_Status& ShadowLobby::publication::TableSubscr_Status::operator=(TableSubscr_Status&& _o)
{
	if(this != &_o)
	{
		players = std::move(_o.players);
		waitingList = std::move(_o.waitingList);
		playersPerFlop = std::move(_o.playersPerFlop);
		averagePot = std::move(_o.averagePot);
		handsPerHour = std::move(_o.handsPerHour);
		publPropFlag = std::move(_o.publPropFlag);
		averageStack = std::move(_o.averageStack);
		vpip = std::move(_o.vpip);
		fppFactor = std::move(_o.fppFactor);
		active = std::move(_o.active);
	}
	return *this;
}

#endif

void ShadowLobby::publication::TableSubscr_Status::clear()
{
	players = 0;
	waitingList = 0;
	playersPerFlop = 0;
	averagePot = 0;
	handsPerHour = 0;
	publPropFlag = 0;
	averageStack = 0;
	vpip = 0;
	fppFactor.clear();
	active = false;
}

bool ShadowLobby::publication::TableSubscr_Status::equals(const TableSubscr_Status& _o) const
{
	return players == _o.players &&
		waitingList == _o.waitingList &&
		playersPerFlop == _o.playersPerFlop &&
		averagePot == _o.averagePot &&
		handsPerHour == _o.handsPerHour &&
		publPropFlag == _o.publPropFlag &&
		averageStack == _o.averageStack &&
		vpip == _o.vpip &&
		fppFactor.equals(_o.fppFactor) &&
		active == _o.active;
}

const char *ShadowLobby::publication::TableSubscr_Status::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("players=");
	_buf.appendUint(players);
	_buf.append(',');
	_buf.append("waitingList=");
	_buf.appendUint(waitingList);
	_buf.append(',');
	_buf.append("playersPerFlop=");
	_buf.appendUint(playersPerFlop);
	_buf.append(',');
	_buf.append("averagePot=");
	_buf.appendUint(averagePot);
	_buf.append(',');
	_buf.append("handsPerHour=");
	_buf.appendUint(handsPerHour);
	_buf.append(',');
	_buf.append("publPropFlag=");
	_buf.appendUint(publPropFlag);
	_buf.append(',');
	_buf.append("averageStack=");
	_buf.appendUint(averageStack);
	_buf.append(',');
	_buf.append("vpip=");
	_buf.appendUint(vpip);
	_buf.append(',');
	_buf.append("fppFactor=");
	fppFactor.toTraceString(_buf);
	_buf.append(',');
	_buf.append("active=");
	_buf.appendUint(active);
	_buf.append('}');
	return _buf.c_str();
}

void ShadowLobby::publication::TableSubscr_Status::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(players);
	_msg.composeBYTE(waitingList);
	_msg.composeBYTE(playersPerFlop);
	_msg.composeUINT32(averagePot);
	_msg.composeUINT16(handsPerHour);
	_msg.composeBYTE(publPropFlag);
	_msg.composeUINT32(averageStack);
	_msg.composeBYTE(vpip);
	fppFactor.composeMsg(_msg);
	_msg.composeBOOL(active);
}

void ShadowLobby::publication::TableSubscr_Status::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(players);
	_parser.parseBYTE(waitingList);
	_parser.parseBYTE(playersPerFlop);
	_parser.parseUINT32(averagePot);
	_parser.parseUINT16(handsPerHour);
	_parser.parseBYTE(publPropFlag);
	_parser.parseUINT32(averageStack);
	_parser.parseBYTE(vpip);
	fppFactor.parseMsg(_parser);
	_parser.parseBOOL(active);
}

/*static*/ void ShadowLobby::publication::TableSubscr_Status::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	BYTE players; _parser.parseBYTE(players);
	AtfValidator::validateInt(_descr, "players", players, _checker, __FILE__, __LINE__);
	BYTE waitingList; _parser.parseBYTE(waitingList);
	AtfValidator::validateInt(_descr, "waitingList", waitingList, _checker, __FILE__, __LINE__);
	BYTE playersPerFlop; _parser.parseBYTE(playersPerFlop);
	AtfValidator::validateInt(_descr, "playersPerFlop", playersPerFlop, _checker, __FILE__, __LINE__);
	UINT32 averagePot; _parser.parseUINT32(averagePot);
	AtfValidator::validateInt(_descr, "averagePot", averagePot, _checker, __FILE__, __LINE__);
	UINT16 handsPerHour; _parser.parseUINT16(handsPerHour);
	AtfValidator::validateInt(_descr, "handsPerHour", handsPerHour, _checker, __FILE__, __LINE__);
	BYTE publPropFlag; _parser.parseBYTE(publPropFlag);
	AtfValidator::validateInt(_descr, "publPropFlag", publPropFlag, _checker, __FILE__, __LINE__);
	UINT32 averageStack; _parser.parseUINT32(averageStack);
	AtfValidator::validateInt(_descr, "averageStack", averageStack, _checker, __FILE__, __LINE__);
	BYTE vpip; _parser.parseBYTE(vpip);
	AtfValidator::validateInt(_descr, "vpip", vpip, _checker, __FILE__, __LINE__);
	PString _descbuf;
	TableClientThin::publication::TableSubscr_Static::_HappyHourInfoPublMsgType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("fppFactor"), _fieldsWithUnparsedContent);
	bool active; _parser.parseBOOL(active);
	AtfValidator::validateInt(_descr, "active", active, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    ReplaySubscr_Winner
//=================================================================

ShadowLobby::publication::ReplaySubscr_Winner::ReplaySubscr_Winner()
{
	clear();
}

void ShadowLobby::publication::ReplaySubscr_Winner::clear()
{
	award = 0;
	bounty = 0;
	wasDealMode = false;
}

bool ShadowLobby::publication::ReplaySubscr_Winner::equals(const ReplaySubscr_Winner& _o) const
{
	return award == _o.award &&
		bounty == _o.bounty &&
		wasDealMode == _o.wasDealMode;
}

const char *ShadowLobby::publication::ReplaySubscr_Winner::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("award=");
	_buf.appendInt64(award);
	_buf.append(',');
	_buf.append("bounty=");
	_buf.appendInt64(bounty);
	_buf.append(',');
	_buf.append("wasDealMode=");
	_buf.appendUint(wasDealMode);
	_buf.append('}');
	return _buf.c_str();
}

void ShadowLobby::publication::ReplaySubscr_Winner::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(ReplaySubscr_Winner())) // not empty
	{
		_body.composeINT64(award);
		_body.composeINT64(bounty);
		_body.composeBOOL(wasDealMode);
	}

	_msg.composeMsgBody(_body);
}

void ShadowLobby::publication::ReplaySubscr_Winner::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT64(award);
	_parser0.parseINT64(bounty);
	_parser0.parseBOOL(wasDealMode);
}

/*static*/ void ShadowLobby::publication::ReplaySubscr_Winner::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT64 award; _parser0.parseINT64(award);
	AtfValidator::validateInt(_descr, "award", award, _checker, __FILE__, __LINE__);
	INT64 bounty; _parser0.parseINT64(bounty);
	AtfValidator::validateInt(_descr, "bounty", bounty, _checker, __FILE__, __LINE__);
	bool wasDealMode; _parser0.parseBOOL(wasDealMode);
	AtfValidator::validateInt(_descr, "wasDealMode", wasDealMode, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ReplaySubscr_Static
//=================================================================

ShadowLobby::publication::ReplaySubscr_Static::ReplaySubscr_Static()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

ShadowLobby::publication::ReplaySubscr_Static::ReplaySubscr_Static(ReplaySubscr_Static&& _o)
	: tournamentId(std::move(_o.tournamentId))
	, server(std::move(_o.server))
	, serverObj(std::move(_o.serverObj))
	, whenStart(std::move(_o.whenStart))
	, name(std::move(_o.name))
	, game(std::move(_o.game))
	, isHiLo(std::move(_o.isHiLo))
	, structure(std::move(_o.structure))
	, tournMask(std::move(_o.tournMask))
	, info(std::move(_o.info))
	, siteVisibilityMask(std::move(_o.siteVisibilityMask))
	, whenStart_t(std::move(_o.whenStart_t))
	, tournMask2(std::move(_o.tournMask2))
	, tournMask3(std::move(_o.tournMask3))
	, tournMask4(std::move(_o.tournMask4))
	, currency(std::move(_o.currency))
	, tournMask5(std::move(_o.tournMask5))
	, tournMask6(std::move(_o.tournMask6))
	, brandVisibilityMask(std::move(_o.brandVisibilityMask))
	, origTournDate(std::move(_o.origTournDate))
	, finalPrizePool(std::move(_o.finalPrizePool))
	, origTournName(std::move(_o.origTournName))
	, winners(std::move(_o.winners))
	, criteria(std::move(_o.criteria))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, buyIn(std::move(_o.buyIn))
	, rake(std::move(_o.rake))
	, bounty(std::move(_o.bounty))
	, maxPlayers(std::move(_o.maxPlayers))
	, tournFlags(std::move(_o.tournFlags))
	, tournFlags2(std::move(_o.tournFlags2))
	, tournFlagsServInt(std::move(_o.tournFlagsServInt))
	, groupReference(std::move(_o.groupReference))
	, pokerNgGroup(std::move(_o.pokerNgGroup))
	, siteVisibilityMaskEx(std::move(_o.siteVisibilityMaskEx))
{
}

ShadowLobby::publication::ReplaySubscr_Static& ShadowLobby::publication::ReplaySubscr_Static::operator=(ReplaySubscr_Static&& _o)
{
	if(this != &_o)
	{
		tournamentId = std::move(_o.tournamentId);
		server = std::move(_o.server);
		serverObj = std::move(_o.serverObj);
		whenStart = std::move(_o.whenStart);
		name = std::move(_o.name);
		game = std::move(_o.game);
		isHiLo = std::move(_o.isHiLo);
		structure = std::move(_o.structure);
		tournMask = std::move(_o.tournMask);
		info = std::move(_o.info);
		siteVisibilityMask = std::move(_o.siteVisibilityMask);
		whenStart_t = std::move(_o.whenStart_t);
		tournMask2 = std::move(_o.tournMask2);
		tournMask3 = std::move(_o.tournMask3);
		tournMask4 = std::move(_o.tournMask4);
		currency = std::move(_o.currency);
		tournMask5 = std::move(_o.tournMask5);
		tournMask6 = std::move(_o.tournMask6);
		brandVisibilityMask = std::move(_o.brandVisibilityMask);
		origTournDate = std::move(_o.origTournDate);
		finalPrizePool = std::move(_o.finalPrizePool);
		origTournName = std::move(_o.origTournName);
		winners = std::move(_o.winners);
		criteria = std::move(_o.criteria);
		isPlayMoney = std::move(_o.isPlayMoney);
		buyIn = std::move(_o.buyIn);
		rake = std::move(_o.rake);
		bounty = std::move(_o.bounty);
		maxPlayers = std::move(_o.maxPlayers);
		tournFlags = std::move(_o.tournFlags);
		tournFlags2 = std::move(_o.tournFlags2);
		tournFlagsServInt = std::move(_o.tournFlagsServInt);
		groupReference = std::move(_o.groupReference);
		pokerNgGroup = std::move(_o.pokerNgGroup);
		siteVisibilityMaskEx = std::move(_o.siteVisibilityMaskEx);
	}
	return *this;
}

#endif

void ShadowLobby::publication::ReplaySubscr_Static::clear()
{
	tournamentId = 0;
	server.clear();
	serverObj.clear();
	whenStart.setNull();
	name.clear();
	game = 0;
	isHiLo = 0;
	structure = 0;
	tournMask = 0;
	info.clear();
	siteVisibilityMask = 0;
	whenStart_t = 0;
	tournMask2 = 0;
	tournMask3 = 0;
	tournMask4 = 0;
	currency.clear();
	tournMask5 = 0;
	tournMask6 = 0;
	brandVisibilityMask = 0;
	origTournDate.setNull();
	finalPrizePool = 0;
	origTournName.clear();
	winners.clear();
	criteria.clear();
	isPlayMoney = false;
	buyIn = 0;
	rake = 0;
	bounty = 0;
	maxPlayers = 0;
	tournFlags = 0;
	tournFlags2 = 0;
	tournFlagsServInt = 0;
	groupReference.clear();
	pokerNgGroup.clear();
	siteVisibilityMaskEx.clear();
}

bool ShadowLobby::publication::ReplaySubscr_Static::equals(const ReplaySubscr_Static& _o) const
{
	return tournamentId == _o.tournamentId &&
		server.equals(_o.server) &&
		serverObj.equals(_o.serverObj) &&
		whenStart.equals(_o.whenStart) &&
		name.equals(_o.name) &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		structure == _o.structure &&
		tournMask == _o.tournMask &&
		info.equals(_o.info) &&
		siteVisibilityMask == _o.siteVisibilityMask &&
		whenStart_t == _o.whenStart_t &&
		tournMask2 == _o.tournMask2 &&
		tournMask3 == _o.tournMask3 &&
		tournMask4 == _o.tournMask4 &&
		currency.equals(_o.currency) &&
		tournMask5 == _o.tournMask5 &&
		tournMask6 == _o.tournMask6 &&
		brandVisibilityMask == _o.brandVisibilityMask &&
		origTournDate.equals(_o.origTournDate) &&
		finalPrizePool == _o.finalPrizePool &&
		origTournName.equals(_o.origTournName) &&
		winners.equals(_o.winners) &&
		criteria.equals(_o.criteria) &&
		isPlayMoney == _o.isPlayMoney &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		bounty == _o.bounty &&
		maxPlayers == _o.maxPlayers &&
		tournFlags == _o.tournFlags &&
		tournFlags2 == _o.tournFlags2 &&
		tournFlagsServInt == _o.tournFlagsServInt &&
		groupReference.equals(_o.groupReference) &&
		pokerNgGroup.equals(_o.pokerNgGroup) &&
		siteVisibilityMaskEx.equals(_o.siteVisibilityMaskEx);
}

const char *ShadowLobby::publication::ReplaySubscr_Static::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournamentId=");
	_buf.appendUint(tournamentId);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("serverObj=");
	_buf.append(serverObj);
	_buf.append(',');
	_buf.append("whenStart=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, whenStart);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("tournMask=");
	_buf.appendUint(tournMask);
	_buf.append(',');
	_buf.append("info=");
	_buf.append(info);
	_buf.append(',');
	_buf.append("siteVisibilityMask=");
	_buf.appendUint(siteVisibilityMask);
	_buf.append(',');
	_buf.append("whenStart_t=");
	_buf.appendUint(whenStart_t);
	_buf.append(',');
	_buf.append("tournMask2=");
	_buf.appendUint(tournMask2);
	_buf.append(',');
	_buf.append("tournMask3=");
	_buf.appendUint(tournMask3);
	_buf.append(',');
	_buf.append("tournMask4=");
	_buf.appendUint(tournMask4);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("tournMask5=");
	_buf.appendUint(tournMask5);
	_buf.append(',');
	_buf.append("tournMask6=");
	_buf.appendUint(tournMask6);
	_buf.append(',');
	_buf.append("brandVisibilityMask=");
	_buf.appendUint(brandVisibilityMask);
	_buf.append(',');
	_buf.append("origTournDate=");
	ThinAtf::AtfTempl<SrvDate>::ToTraceString(_buf, origTournDate);
	_buf.append(',');
	_buf.append("finalPrizePool=");
	_buf.appendInt64(finalPrizePool);
	_buf.append(',');
	_buf.append("origTournName=");
	ThinAtf::AtfTempl<I18nPString>::ToTraceString(_buf, origTournName);
	_buf.append(',');
	_buf.append("winners=");
	winners.toTraceString(_buf);
	_buf.append(',');
	_buf.append("criteria=");
	_buf.append(criteria);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendInt64(buyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendInt64(rake);
	_buf.append(',');
	_buf.append("bounty=");
	_buf.appendInt64(bounty);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendInt(maxPlayers);
	_buf.append(',');
	_buf.append("tournFlags=");
	_buf.appendUint(tournFlags);
	_buf.append(',');
	_buf.append("tournFlags2=");
	_buf.appendUint64(tournFlags2);
	_buf.append(',');
	_buf.append("tournFlagsServInt=");
	_buf.appendUint(tournFlagsServInt);
	_buf.append(',');
	_buf.append("groupReference=");
	_buf.append(groupReference);
	_buf.append(',');
	_buf.append("pokerNgGroup=");
	_buf.append(pokerNgGroup);
	_buf.append(',');
	_buf.append("siteVisibilityMaskEx=");
	siteVisibilityMaskEx.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void ShadowLobby::publication::ReplaySubscr_Static::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(tournamentId);
	_msg.composeString(server);
	_msg.composeString(serverObj);
	_msg.composeSrvTime(whenStart);
	_msg.composeString(name);
	_msg.composeBYTE(game);
	_msg.composeBYTE(isHiLo);
	_msg.composeBYTE(structure);
	_msg.composeUINT32(tournMask);
	_msg.composeString(info);
	_msg.composeUINT32(siteVisibilityMask);
	_msg.composeUINT32(whenStart_t);
	_msg.composeUINT32(tournMask2);
	_msg.composeUINT32(tournMask3);
	_msg.composeUINT32(tournMask4);
	_msg.composeString(currency);
	_msg.composeUINT32(tournMask5);
	_msg.composeUINT32(tournMask6);
	_msg.composeUINT32(brandVisibilityMask);
	CommMsgBody _msg0;
	_msg0.composeSrvDate(origTournDate);
	_msg0.composeINT64(finalPrizePool);
	origTournName.compose(_msg0);
	winners.composeMsg(_msg0);
	_msg.composeMsgBody(_msg0);
	_msg.composeString(criteria);
	_msg.composeBOOL(isPlayMoney);
	_msg.composeINT64(buyIn);
	_msg.composeINT64(rake);
	_msg.composeINT64(bounty);
	_msg.composeINT32(maxPlayers);
	_msg.composeUINT32(tournFlags);
	_msg.composeUINT64(tournFlags2);
	_msg.composeUINT32(tournFlagsServInt);
	_msg.composeString(groupReference);
	_msg.composeString(pokerNgGroup);
	siteVisibilityMaskEx.composeMsg(_msg);
}

void ShadowLobby::publication::ReplaySubscr_Static::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tournamentId);
	_parser.parseStringP(server);
	_parser.parseStringP(serverObj);
	_parser.parseSrvTime(whenStart);
	_parser.parseStringP(name);
	_parser.parseBYTE(game);
	_parser.parseBYTE(isHiLo);
	_parser.parseBYTE(structure);
	_parser.parseUINT32(tournMask);
	_parser.parseStringP(info);
	_parser.parseUINT32(siteVisibilityMask);
	_parser.parseUINT32(whenStart_t);
	_parser.parseUINT32(tournMask2);
	_parser.parseUINT32(tournMask3);
	_parser.parseUINT32(tournMask4);
	_parser.parseStringP(currency);
	_parser.parseUINT32(tournMask5);
	_parser.parseUINT32(tournMask6);
	_parser.parseUINT32(brandVisibilityMask);
	parseAnonymousMsgBody0(_parser);
	_parser.parseStringP(criteria);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(isPlayMoney);
	_parser.parseINT64(buyIn);
	_parser.parseINT64(rake);
	_parser.parseINT64(bounty);
	_parser.parseINT32(maxPlayers);
	_parser.parseUINT32(tournFlags);
	_parser.parseUINT64(tournFlags2);
	_parser.parseUINT32(tournFlagsServInt);
	_parser.parseStringP(groupReference);
	_parser.parseStringP(pokerNgGroup);
	siteVisibilityMaskEx.parseMsg(_parser);
}

/*static*/ void ShadowLobby::publication::ReplaySubscr_Static::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 tournamentId; _parser.parseUINT32(tournamentId);
	AtfValidator::validateInt(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "serverObj"); size_t szServerObj = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObj", szServerObj, _checker, __FILE__, __LINE__);
	SrvTime whenStart; _parser.parseSrvTime(whenStart);
	AtfValidator::validateSrvDateTime(_descr, "whenStart", whenStart, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	UINT32 tournMask; _parser.parseUINT32(tournMask);
	AtfValidator::validateInt(_descr, "tournMask", tournMask, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "info"); size_t szInfo = strlen(_dummy);
	AtfValidator::validateInt(_descr, "info", szInfo, _checker, __FILE__, __LINE__);
	UINT32 siteVisibilityMask; _parser.parseUINT32(siteVisibilityMask);
	AtfValidator::validateInt(_descr, "siteVisibilityMask", siteVisibilityMask, _checker, __FILE__, __LINE__);
	UINT32 whenStart_t; _parser.parseUINT32(whenStart_t);
	AtfValidator::validateInt(_descr, "whenStart_t", whenStart_t, _checker, __FILE__, __LINE__);
	UINT32 tournMask2; _parser.parseUINT32(tournMask2);
	AtfValidator::validateInt(_descr, "tournMask2", tournMask2, _checker, __FILE__, __LINE__);
	UINT32 tournMask3; _parser.parseUINT32(tournMask3);
	AtfValidator::validateInt(_descr, "tournMask3", tournMask3, _checker, __FILE__, __LINE__);
	UINT32 tournMask4; _parser.parseUINT32(tournMask4);
	AtfValidator::validateInt(_descr, "tournMask4", tournMask4, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 tournMask5; _parser.parseUINT32(tournMask5);
	AtfValidator::validateInt(_descr, "tournMask5", tournMask5, _checker, __FILE__, __LINE__);
	UINT32 tournMask6; _parser.parseUINT32(tournMask6);
	AtfValidator::validateInt(_descr, "tournMask6", tournMask6, _checker, __FILE__, __LINE__);
	UINT32 brandVisibilityMask; _parser.parseUINT32(brandVisibilityMask);
	AtfValidator::validateInt(_descr, "brandVisibilityMask", brandVisibilityMask, _checker, __FILE__, __LINE__);
	validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	_parser.parseStringN(_dummy, 0, "criteria"); size_t szCriteria = strlen(_dummy);
	AtfValidator::validateInt(_descr, "criteria", szCriteria, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	INT64 buyIn; _parser.parseINT64(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	INT64 rake; _parser.parseINT64(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	INT64 bounty; _parser.parseINT64(bounty);
	AtfValidator::validateInt(_descr, "bounty", bounty, _checker, __FILE__, __LINE__);
	INT32 maxPlayers; _parser.parseINT32(maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	UINT32 tournFlags; _parser.parseUINT32(tournFlags);
	AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
	UINT64 tournFlags2; _parser.parseUINT64(tournFlags2);
	AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	UINT32 tournFlagsServInt; _parser.parseUINT32(tournFlagsServInt);
	AtfValidator::validateInt(_descr, "tournFlagsServInt", tournFlagsServInt, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "groupReference"); size_t szGroupReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "groupReference", szGroupReference, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "pokerNgGroup"); size_t szPokerNgGroup = strlen(_dummy);
	AtfValidator::validateInt(_descr, "pokerNgGroup", szPokerNgGroup, _checker, __FILE__, __LINE__);
	PString _descbuf;
	PSiteMask::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("siteVisibilityMaskEx"), _fieldsWithUnparsedContent);
}

void ShadowLobby::publication::ReplaySubscr_Static::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseSrvDate(origTournDate);
	_parser0.parseINT64(finalPrizePool);
	origTournName.parse(_parser0);
	winners.parseMsg(_parser0);
}

/*static*/ void ShadowLobby::publication::ReplaySubscr_Static::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	SrvDate origTournDate; _parser0.parseSrvDate(origTournDate);
	AtfValidator::validateSrvDateTime(_descr, "origTournDate", origTournDate, _checker, __FILE__, __LINE__);
	INT64 finalPrizePool; _parser0.parseINT64(finalPrizePool);
	AtfValidator::validateInt(_descr, "finalPrizePool", finalPrizePool, _checker, __FILE__, __LINE__);
	I18nPString origTournName; origTournName.parse(_parser0);
	PString _descbuf;
	int szWinners = ThinAtf::LAtfVector< ReplaySubscr_Winner, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("winners"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "winners", szWinners, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ReplaySubscr_Status
//=================================================================

ShadowLobby::publication::ReplaySubscr_Status::ReplaySubscr_Status()
{
	clear();
}

void ShadowLobby::publication::ReplaySubscr_Status::clear()
{
	status = 0;
}

bool ShadowLobby::publication::ReplaySubscr_Status::equals(const ReplaySubscr_Status& _o) const
{
	return status == _o.status;
}

const char *ShadowLobby::publication::ReplaySubscr_Status::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("status=");
	_buf.appendUint(status);
	_buf.append('}');
	return _buf.c_str();
}

void ShadowLobby::publication::ReplaySubscr_Status::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(status);
}

void ShadowLobby::publication::ReplaySubscr_Status::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(status);
}

/*static*/ void ShadowLobby::publication::ReplaySubscr_Status::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 status; _parser.parseUINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
}

