/**
 * mlobby_atf_thin.cpp
 *
 * This file was auto-generated from mlobby_atf.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -thin mlobby_atf.txt
 */
 
#include "mlobby_atf_thin.h"

//=================================================================
//                    Filter
//=================================================================

MLobby::cli::Filter::Filter()
{
	clear();
}

void MLobby::cli::Filter::clear()
{
	version = 0;
	locale = 0;
	country.clear();
	siteId = 0;
	game = 0;
	hiLo = 0;
	limit = 0;
	minStake = 0;
	maxStake = 0;
	buyInMask = 0;
	minBuyIn = 0;
	maxBuyIn = 0;
	maxPlayers = 0;
	minSeated = 0;
	minAvailable = 0;
	speed = 0;
	currencies = 0;
	format = 0;
	startingSoon = 0;
	state = 0;
	order = 0;
	realMoney = false;
	minEntrants = 0;
	maxEntrants = 0;
	zoomTournaments = 0;
	multiplierPM = 0;
	features = 0;
	tableStarters = false;
	nameCriteria.clear();
	specialSearchMode = 0;
	clientSortingSeed = 0;
	brandMask = 0;
	notUsed = 0;
	seatFindersAndBlitzes = 0;
}

bool MLobby::cli::Filter::equals(const Filter& _o) const
{
	return version == _o.version &&
		locale == _o.locale &&
		country.equals(_o.country) &&
		siteId == _o.siteId &&
		game == _o.game &&
		hiLo == _o.hiLo &&
		limit == _o.limit &&
		minStake == _o.minStake &&
		maxStake == _o.maxStake &&
		buyInMask == _o.buyInMask &&
		minBuyIn == _o.minBuyIn &&
		maxBuyIn == _o.maxBuyIn &&
		maxPlayers == _o.maxPlayers &&
		minSeated == _o.minSeated &&
		minAvailable == _o.minAvailable &&
		speed == _o.speed &&
		currencies == _o.currencies &&
		format == _o.format &&
		startingSoon == _o.startingSoon &&
		state == _o.state &&
		order == _o.order &&
		realMoney == _o.realMoney &&
		minEntrants == _o.minEntrants &&
		maxEntrants == _o.maxEntrants &&
		zoomTournaments == _o.zoomTournaments &&
		multiplierPM == _o.multiplierPM &&
		features == _o.features &&
		tableStarters == _o.tableStarters &&
		nameCriteria.equals(_o.nameCriteria) &&
		specialSearchMode == _o.specialSearchMode &&
		clientSortingSeed == _o.clientSortingSeed &&
		brandMask == _o.brandMask &&
		notUsed == _o.notUsed &&
		seatFindersAndBlitzes == _o.seatFindersAndBlitzes;
}

const char *MLobby::cli::Filter::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("version=");
	_buf.appendUint(version);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("hiLo=");
	_buf.appendUint(hiLo);
	_buf.append(',');
	_buf.append("limit=");
	_buf.appendUint(limit);
	_buf.append(',');
	_buf.append("minStake=");
	_buf.appendUint(minStake);
	_buf.append(',');
	_buf.append("maxStake=");
	_buf.appendUint(maxStake);
	_buf.append(',');
	_buf.append("buyInMask=");
	_buf.appendUint(buyInMask);
	_buf.append(',');
	_buf.append("minBuyIn=");
	_buf.appendUint(minBuyIn);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendUint(maxBuyIn);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendUint(maxPlayers);
	_buf.append(',');
	_buf.append("minSeated=");
	_buf.appendUint(minSeated);
	_buf.append(',');
	_buf.append("minAvailable=");
	_buf.appendUint(minAvailable);
	_buf.append(',');
	_buf.append("speed=");
	_buf.appendUint(speed);
	_buf.append(',');
	_buf.append("currencies=");
	_buf.appendUint(currencies);
	_buf.append(',');
	_buf.append("format=");
	_buf.appendUint(format);
	_buf.append(',');
	_buf.append("startingSoon=");
	_buf.appendUint(startingSoon);
	_buf.append(',');
	_buf.append("state=");
	_buf.appendUint(state);
	_buf.append(',');
	_buf.append("order=");
	_buf.appendUint(order);
	if( version >= 2 )
	{
		_buf.append(',');
		_buf.append("realMoney=");
		_buf.appendUint(realMoney);
	}
	if( version >= 3 )
	{
		_buf.append(',');
		_buf.append("minEntrants=");
		_buf.appendUint(minEntrants);
		_buf.append(',');
		_buf.append("maxEntrants=");
		_buf.appendUint(maxEntrants);
	}
	if( version >= 4 )
	{
		_buf.append(',');
		_buf.append("zoomTournaments=");
		_buf.appendUint(zoomTournaments);
		_buf.append(',');
		_buf.append("multiplierPM=");
		_buf.appendUint(multiplierPM);
		_buf.append(',');
		_buf.append("features=");
		_buf.appendUint(features);
	}
	if( version >= 5 )
	{
		_buf.append(',');
		_buf.append("tableStarters=");
		_buf.appendUint(tableStarters);
	}
	if( version >= 6 )
	{
		_buf.append(',');
		_buf.append("nameCriteria=");
		_buf.append(nameCriteria);
		_buf.append(',');
		_buf.append("specialSearchMode=");
		_buf.appendUint(specialSearchMode);
	}
	if( version >= 7 )
	{
		_buf.append(',');
		_buf.append("clientSortingSeed=");
		_buf.appendUint(clientSortingSeed);
	}
	if( version >= 8 )
	{
		_buf.append(',');
		_buf.append("brandMask=");
		_buf.appendUint(brandMask);
	}
	if (version == 9)
	{
		_buf.append(',');
		_buf.append("notUsed=");
		_buf.appendInt(notUsed);
	}
	if( version >= 10 )
	{
		_buf.append(',');
		_buf.append("seatFindersAndBlitzes=");
		_buf.appendInt(seatFindersAndBlitzes);
	}
	_buf.append('}');
	return _buf.c_str();
}

void MLobby::cli::Filter::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(Filter())) // not empty
	{
		_body.composeBYTE(version);
		_body.composeUINT32(locale);
		_body.composeString(country);
		_body.composeUINT32(siteId);
		_body.composeBYTE(game);
		_body.composeBYTE(hiLo);
		_body.composeBYTE(limit);
		_body.composeUINT32(minStake);
		_body.composeUINT32(maxStake);
		_body.composeUINT32(buyInMask);
		_body.composeUINT32(minBuyIn);
		_body.composeUINT32(maxBuyIn);
		_body.composeUINT32(maxPlayers);
		_body.composeBYTE(minSeated);
		_body.composeBYTE(minAvailable);
		_body.composeBYTE(speed);
		_body.composeUINT32(currencies);
		_body.composeUINT32(format);
		_body.composeUINT32(startingSoon);
		_body.composeUINT32(state);
		_body.composeBYTE(order);
		if( version >= 2 )
		{
			_body.composeBOOL(realMoney);
		}
		if( version >= 3 )
		{
			_body.composeUINT32(minEntrants);
			_body.composeUINT32(maxEntrants);
		}
		if( version >= 4 )
		{
			_body.composeUINT32(zoomTournaments);
			_body.composeUINT32(multiplierPM);
			_body.composeUINT32(features);
		}
		if( version >= 5 )
		{
			_body.composeBOOL(tableStarters);
		}
		if( version >= 6 )
		{
			_body.composeString(nameCriteria);
			_body.composeUINT32(specialSearchMode);
		}
		if( version >= 7 )
		{
			_body.composeUINT32(clientSortingSeed);
		}
		if( version >= 8 )
		{
			_body.composeUINT32(brandMask);
		}
		if (version == 9)
		{
			_body.composeINT8(notUsed);
		}
		if( version >= 10 )
		{
			_body.composeINT8(seatFindersAndBlitzes);
		}
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::Filter::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(version);
	_parser0.parseUINT32(locale);
	_parser0.parseStringP(country);
	_parser0.parseUINT32(siteId);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(hiLo);
	_parser0.parseBYTE(limit);
	_parser0.parseUINT32(minStake);
	_parser0.parseUINT32(maxStake);
	_parser0.parseUINT32(buyInMask);
	_parser0.parseUINT32(minBuyIn);
	_parser0.parseUINT32(maxBuyIn);
	_parser0.parseUINT32(maxPlayers);
	_parser0.parseBYTE(minSeated);
	_parser0.parseBYTE(minAvailable);
	_parser0.parseBYTE(speed);
	_parser0.parseUINT32(currencies);
	_parser0.parseUINT32(format);
	_parser0.parseUINT32(startingSoon);
	_parser0.parseUINT32(state);
	_parser0.parseBYTE(order);
	if( version >= 2 )
	{
		_parser0.parseBOOL(realMoney);
	}
	if( version >= 3 )
	{
		_parser0.parseUINT32(minEntrants);
		_parser0.parseUINT32(maxEntrants);
	}
	if( version >= 4 )
	{
		_parser0.parseUINT32(zoomTournaments);
		_parser0.parseUINT32(multiplierPM);
		_parser0.parseUINT32(features);
	}
	if( version >= 5 )
	{
		_parser0.parseBOOL(tableStarters);
	}
	if( version >= 6 )
	{
		_parser0.parseStringP(nameCriteria);
		_parser0.parseUINT32(specialSearchMode);
	}
	if( version >= 7 )
	{
		_parser0.parseUINT32(clientSortingSeed);
	}
	if( version >= 8 )
	{
		_parser0.parseUINT32(brandMask);
	}
	if (version == 9)
	{
		if(_parser0.parseEnded()) return;
		_parser0.parseINT8(notUsed);
	}
	if( version >= 10 )
	{
		_parser0.parseINT8(seatFindersAndBlitzes);
	}
}

/*static*/ void MLobby::cli::Filter::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	BYTE version = 0;
	_parser0.parseBYTE(version);
	AtfValidator::validateInt(_descr, "version", version, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser0.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, 3, _checker, __FILE__, __LINE__);
	UINT32 siteId; _parser0.parseUINT32(siteId);
	AtfValidator::validateIntRange(_descr, "siteId", siteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateIntRange(_descr, "game", game, HandTypeNone, HandType_Last, _checker, __FILE__, __LINE__);
	BYTE hiLo; _parser0.parseBYTE(hiLo);
	AtfValidator::validateIntMax(_descr, "hiLo", hiLo, 1, _checker, __FILE__, __LINE__);
	BYTE limit; _parser0.parseBYTE(limit);
	AtfValidator::validateIntRange(_descr, "limit", limit, StructNonDefined, PotStruct_Last, _checker, __FILE__, __LINE__);
	UINT32 minStake; _parser0.parseUINT32(minStake);
	AtfValidator::validateIntMax(_descr, "minStake", minStake, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 maxStake; _parser0.parseUINT32(maxStake);
	AtfValidator::validateIntMax(_descr, "maxStake", maxStake, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 buyInMask; _parser0.parseUINT32(buyInMask);
	AtfValidator::validateIntRange(_descr, "buyInMask", buyInMask, SelectionFilter::Cash, SelectionFilter::BuyInMask_Last, _checker, __FILE__, __LINE__);
	UINT32 minBuyIn; _parser0.parseUINT32(minBuyIn);
	AtfValidator::validateIntMax(_descr, "minBuyIn", minBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 maxBuyIn; _parser0.parseUINT32(maxBuyIn);
	AtfValidator::validateIntMax(_descr, "maxBuyIn", maxBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 maxPlayers; _parser0.parseUINT32(maxPlayers);
	AtfValidator::validateIntMax(_descr, "maxPlayers", maxPlayers, SelectionFilter::MaxPlayers_Mask_Max, _checker, __FILE__, __LINE__);
	BYTE minSeated; _parser0.parseBYTE(minSeated);
	AtfValidator::validateIntMax(_descr, "minSeated", minSeated, 10, _checker, __FILE__, __LINE__);
	BYTE minAvailable; _parser0.parseBYTE(minAvailable);
	AtfValidator::validateIntMax(_descr, "minAvailable", minAvailable, 10, _checker, __FILE__, __LINE__);
	BYTE speed; _parser0.parseBYTE(speed);
	AtfValidator::validateIntMax(_descr, "speed", speed, (2*SelectionFilter::TourneySpeed_Last-1), _checker, __FILE__, __LINE__);
	UINT32 currencies; _parser0.parseUINT32(currencies);
	AtfValidator::validateInt(_descr, "currencies", currencies, _checker, __FILE__, __LINE__);
	UINT32 format; _parser0.parseUINT32(format);
	AtfValidator::validateIntMax(_descr, "format", format, (2*SelectionFilter::Format_Last-1), _checker, __FILE__, __LINE__);
	UINT32 startingSoon; _parser0.parseUINT32(startingSoon);
	AtfValidator::validateInt(_descr, "startingSoon", startingSoon, _checker, __FILE__, __LINE__);
	UINT32 state; _parser0.parseUINT32(state);
	AtfValidator::validateIntMax(_descr, "state", state, (2*SelectionFilter::State_Last-1), _checker, __FILE__, __LINE__);
	BYTE order; _parser0.parseBYTE(order);
	AtfValidator::validateIntMax(_descr, "order", order, SelectionFilter::TableOrder_Last, _checker, __FILE__, __LINE__);
	if( version >= 2 )
	{
		bool realMoney; _parser0.parseBOOL(realMoney);
		AtfValidator::validateInt(_descr, "realMoney", realMoney, _checker, __FILE__, __LINE__);
	}
	if( version >= 3 )
	{
		UINT32 minEntrants; _parser0.parseUINT32(minEntrants);
		AtfValidator::validateIntMax(_descr, "minEntrants", minEntrants, 1000000, _checker, __FILE__, __LINE__);
		UINT32 maxEntrants; _parser0.parseUINT32(maxEntrants);
		AtfValidator::validateIntMax(_descr, "maxEntrants", maxEntrants, 1000000, _checker, __FILE__, __LINE__);
	}
	if( version >= 4 )
	{
		UINT32 zoomTournaments; _parser0.parseUINT32(zoomTournaments);
		AtfValidator::validateIntRange(_descr, "zoomTournaments", zoomTournaments, SelectionFilter::zoom_Exclude, SelectionFilter::ZoomTournaments_Last, _checker, __FILE__, __LINE__);
		UINT32 multiplierPM; _parser0.parseUINT32(multiplierPM);
		AtfValidator::validateInt(_descr, "multiplierPM", multiplierPM, _checker, __FILE__, __LINE__);
		UINT32 features; _parser0.parseUINT32(features);
		AtfValidator::validateIntRange(_descr, "features", features, SelectionFilter::feature_None, (2*SelectionFilter::ClientFeaturesMobile_Last-1), _checker, __FILE__, __LINE__);
	}
	if( version >= 5 )
	{
		bool tableStarters; _parser0.parseBOOL(tableStarters);
		AtfValidator::validateInt(_descr, "tableStarters", tableStarters, _checker, __FILE__, __LINE__);
	}
	if( version >= 6 )
	{
		_parser0.parseStringN(_dummy, 0, "nameCriteria"); size_t szNameCriteria = strlen(_dummy);
		AtfValidator::validateIntMax(_descr, "nameCriteria", szNameCriteria, 1000, _checker, __FILE__, __LINE__);
		UINT32 specialSearchMode; _parser0.parseUINT32(specialSearchMode);
		AtfValidator::validateIntRange(_descr, "specialSearchMode", specialSearchMode, SelectionFilter::specialSearchMode_None, SelectionFilter::specialSearchMode_tournByNameOnly, _checker, __FILE__, __LINE__);
	}
	if( version >= 7 )
	{
		UINT32 clientSortingSeed; _parser0.parseUINT32(clientSortingSeed);
		AtfValidator::validateInt(_descr, "clientSortingSeed", clientSortingSeed, _checker, __FILE__, __LINE__);
	}
	if( version >= 8 )
	{
		UINT32 brandMask; _parser0.parseUINT32(brandMask);
		AtfValidator::validateIntRange(_descr, "brandMask", brandMask, BrandType_None, BrandType_Last, _checker, __FILE__, __LINE__);
	}
	if (version == 9)
	{
		if(_parser0.parseEnded()) return;
		INT8 notUsed; _parser0.parseINT8(notUsed);
		AtfValidator::validateInt(_descr, "notUsed", notUsed, _checker, __FILE__, __LINE__);
	}
	if( version >= 10 )
	{
		INT8 seatFindersAndBlitzes; _parser0.parseINT8(seatFindersAndBlitzes);
		AtfValidator::validateIntRange(_descr, "seatFindersAndBlitzes", seatFindersAndBlitzes, SelectionFilter::SeatFindersAndBlitzes_Both, SelectionFilter::SeatFindersAndBlitzes_Last, _checker, __FILE__, __LINE__);
	}
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_RINGGAMES
//=================================================================

MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES::Protocol_MSG_MLOBBY_FIND_RINGGAMES()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES::clear()
{
	filter.clear();
	maxItems = 0;
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES::equals(const Protocol_MSG_MLOBBY_FIND_RINGGAMES& _o) const
{
	return filter.equals(_o.filter) &&
		maxItems == _o.maxItems;
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_RINGGAMES).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("maxItems=");
	_buf.appendUint(maxItems);
	return _buf.c_str();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES::composeMsg(CommMsgBody& _msg) const
{
	filter.composeMsg(_msg);
	_msg.composeUINT32(maxItems);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	_parser.parseUINT32(maxItems);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_RINGGAMES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	Filter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	UINT32 maxItems; _parser.parseUINT32(maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_TOURNAMENTS
//=================================================================

MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS::clear()
{
	filter.clear();
	maxItems = 0;
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS::equals(const Protocol_MSG_MLOBBY_FIND_TOURNAMENTS& _o) const
{
	return filter.equals(_o.filter) &&
		maxItems == _o.maxItems;
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_TOURNAMENTS).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("maxItems=");
	_buf.appendUint(maxItems);
	return _buf.c_str();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS::composeMsg(CommMsgBody& _msg) const
{
	filter.composeMsg(_msg);
	_msg.composeUINT32(maxItems);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	_parser.parseUINT32(maxItems);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_TOURNAMENTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	Filter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	UINT32 maxItems; _parser.parseUINT32(maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_TABLE_OLD
//=================================================================

MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE_OLD::Protocol_MSG_MLOBBY_FIND_TABLE_OLD()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE_OLD::clear()
{
	filter.clear();
	excludedTables.clear();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE_OLD::equals(const Protocol_MSG_MLOBBY_FIND_TABLE_OLD& _o) const
{
	return filter.equals(_o.filter) &&
		excludedTables.equals(_o.excludedTables);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE_OLD::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_TABLE_OLD).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("excludedTables=");
	excludedTables.toTraceString(_buf);
	return _buf.c_str();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE_OLD::composeMsg(CommMsgBody& _msg) const
{
	filter.composeMsg(_msg);
	excludedTables.composeMsg(_msg);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE_OLD::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	excludedTables.parseMsg(_parser);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE_OLD::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_TABLE_OLD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	Filter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	int szExcludedTables = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("excludedTables"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "excludedTables", szExcludedTables, 1024, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_TABLE64
//=================================================================

MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64::Protocol_MSG_MLOBBY_FIND_TABLE64()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64::clear()
{
	filter.clear();
	excludedTables.clear();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64::equals(const Protocol_MSG_MLOBBY_FIND_TABLE64& _o) const
{
	return filter.equals(_o.filter) &&
		excludedTables.equals(_o.excludedTables);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_TABLE64).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("excludedTables=");
	excludedTables.toTraceString(_buf);
	return _buf.c_str();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64::composeMsg(CommMsgBody& _msg) const
{
	filter.composeMsg(_msg);
	excludedTables.composeMsg(_msg);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	excludedTables.parseMsg(_parser);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_TABLE64";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	Filter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	int szExcludedTables = ThinAtf::LAtfVector< UINT64, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("excludedTables"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "excludedTables", szExcludedTables, 1024, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_BLITZ
//=================================================================

MLobby::cli::Protocol_MSG_MLOBBY_FIND_BLITZ::Protocol_MSG_MLOBBY_FIND_BLITZ()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_BLITZ::clear()
{
	filter.clear();
	maxItems = 0;
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_BLITZ::equals(const Protocol_MSG_MLOBBY_FIND_BLITZ& _o) const
{
	return filter.equals(_o.filter) &&
		maxItems == _o.maxItems;
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_BLITZ::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_BLITZ).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("maxItems=");
	_buf.appendUint(maxItems);
	return _buf.c_str();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_BLITZ::composeMsg(CommMsgBody& _msg) const
{
	filter.composeMsg(_msg);
	_msg.composeUINT32(maxItems);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_BLITZ::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	_parser.parseUINT32(maxItems);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_BLITZ::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_BLITZ";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	Filter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	UINT32 maxItems; _parser.parseUINT32(maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES
//=================================================================

MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES::clear()
{
	filter.clear();
	maxItems = 0;
	excludedFinders.clear();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES::equals(const Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES& _o) const
{
	return filter.equals(_o.filter) &&
		maxItems == _o.maxItems &&
		excludedFinders.equals(_o.excludedFinders);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("maxItems=");
	_buf.appendUint(maxItems);
	_buf.append(',');
	_buf.append("excludedFinders=");
	excludedFinders.toTraceString(_buf);
	return _buf.c_str();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES::composeMsg(CommMsgBody& _msg) const
{
	filter.composeMsg(_msg);
	_msg.composeUINT32(maxItems);
	excludedFinders.composeMsg(_msg);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	_parser.parseUINT32(maxItems);
	excludedFinders.parseMsg(_parser);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	Filter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	UINT32 maxItems; _parser.parseUINT32(maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
	int szExcludedFinders = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("excludedFinders"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "excludedFinders", szExcludedFinders, 1024, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    TableSelectionFilter
//=================================================================

MLobby::cli::TableSelectionFilter::TableSelectionFilter()
{
	clear();
}

void MLobby::cli::TableSelectionFilter::clear()
{
	version = 0;
	country.clear();
	siteId = 0;
	brandId = 0;
	gameMask = 0;
	buyInMask = 0;
	minBuyIn = 0;
	maxBuyIn = 0;
	multiplierPM = 0;
	currencyMask = 0;
	sortOrder = 0;
	maxPlayerMask = 0;
	clientSortingSeed = 0;
	standardFormatOnly = false;
}

bool MLobby::cli::TableSelectionFilter::equals(const TableSelectionFilter& _o) const
{
	return version == _o.version &&
		country.equals(_o.country) &&
		siteId == _o.siteId &&
		brandId == _o.brandId &&
		gameMask == _o.gameMask &&
		buyInMask == _o.buyInMask &&
		minBuyIn == _o.minBuyIn &&
		maxBuyIn == _o.maxBuyIn &&
		multiplierPM == _o.multiplierPM &&
		currencyMask == _o.currencyMask &&
		sortOrder == _o.sortOrder &&
		maxPlayerMask == _o.maxPlayerMask &&
		clientSortingSeed == _o.clientSortingSeed &&
		standardFormatOnly == _o.standardFormatOnly;
}

const char *MLobby::cli::TableSelectionFilter::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("version=");
	_buf.appendUint(version);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("brandId=");
	_buf.appendUint(brandId);
	_buf.append(',');
	_buf.append("gameMask=");
	_buf.appendUint64(gameMask);
	_buf.append(',');
	_buf.append("buyInMask=");
	_buf.appendUint(buyInMask);
	_buf.append(',');
	_buf.append("minBuyIn=");
	_buf.appendUint64(minBuyIn);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendUint64(maxBuyIn);
	_buf.append(',');
	_buf.append("multiplierPM=");
	_buf.appendUint(multiplierPM);
	_buf.append(',');
	_buf.append("currencyMask=");
	_buf.appendUint(currencyMask);
	_buf.append(',');
	_buf.append("sortOrder=");
	_buf.appendUint(sortOrder);
	_buf.append(',');
	_buf.append("maxPlayerMask=");
	_buf.appendUint(maxPlayerMask);
	_buf.append(',');
	_buf.append("clientSortingSeed=");
	_buf.appendUint(clientSortingSeed);
	_buf.append(',');
	_buf.append("standardFormatOnly=");
	_buf.appendUint(standardFormatOnly);
	_buf.append('}');
	return _buf.c_str();
}

void MLobby::cli::TableSelectionFilter::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(TableSelectionFilter())) // not empty
	{
		_body.composeBYTE(version);
		_body.composeString(country);
		_body.composeUINT32(siteId);
		_body.composeUINT32(brandId);
		_body.composeUINT64(gameMask);
		_body.composeUINT32(buyInMask);
		_body.composeUINT64(minBuyIn);
		_body.composeUINT64(maxBuyIn);
		_body.composeUINT32(multiplierPM);
		_body.composeUINT32(currencyMask);
		_body.composeUINT32(sortOrder);
		_body.composeUINT32(maxPlayerMask);
		_body.composeUINT32(clientSortingSeed);
		_body.composeBOOL(standardFormatOnly);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::TableSelectionFilter::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(version);
	_parser0.parseStringP(country);
	_parser0.parseUINT32(siteId);
	_parser0.parseUINT32(brandId);
	_parser0.parseUINT64(gameMask);
	_parser0.parseUINT32(buyInMask);
	_parser0.parseUINT64(minBuyIn);
	_parser0.parseUINT64(maxBuyIn);
	_parser0.parseUINT32(multiplierPM);
	_parser0.parseUINT32(currencyMask);
	_parser0.parseUINT32(sortOrder);
	_parser0.parseUINT32(maxPlayerMask);
	_parser0.parseUINT32(clientSortingSeed);
	_parser0.parseBOOL(standardFormatOnly);
}

/*static*/ void MLobby::cli::TableSelectionFilter::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	BYTE version; _parser0.parseBYTE(version);
	AtfValidator::validateInt(_descr, "version", version, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	UINT32 siteId; _parser0.parseUINT32(siteId);
	AtfValidator::validateIntRange(_descr, "siteId", siteId, PokerStars_SiteUnknown, (2*PokerStars_Last-1), _checker, __FILE__, __LINE__);
	UINT32 brandId; _parser0.parseUINT32(brandId);
	AtfValidator::validateIntRange(_descr, "brandId", brandId, BrandType_None, (2*BrandType_Last-1), _checker, __FILE__, __LINE__);
	UINT64 gameMask; _parser0.parseUINT64(gameMask);
	AtfValidator::validateUintMax(_descr, "gameMask", gameMask, (2*(UINT64)MobileGameTypes::MobileGame_Last-1), _checker, __FILE__, __LINE__);
	UINT32 buyInMask; _parser0.parseUINT32(buyInMask);
	AtfValidator::validateIntMax(_descr, "buyInMask", buyInMask, (2*MobileBuyIn_Last-1), _checker, __FILE__, __LINE__);
	UINT64 minBuyIn; _parser0.parseUINT64(minBuyIn);
	AtfValidator::validateUintMax(_descr, "minBuyIn", minBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	UINT64 maxBuyIn; _parser0.parseUINT64(maxBuyIn);
	AtfValidator::validateUintMax(_descr, "maxBuyIn", maxBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 multiplierPM; _parser0.parseUINT32(multiplierPM);
	AtfValidator::validateIntMax(_descr, "multiplierPM", multiplierPM, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 currencyMask; _parser0.parseUINT32(currencyMask);
	AtfValidator::validateIntMax(_descr, "currencyMask", currencyMask, (2*MobileCurrency_Last-1), _checker, __FILE__, __LINE__);
	UINT32 sortOrder; _parser0.parseUINT32(sortOrder);
	AtfValidator::validateIntRange(_descr, "sortOrder", sortOrder, MobileSortOrder_None, MobileSortOrder_Last, _checker, __FILE__, __LINE__);
	UINT32 maxPlayerMask; _parser0.parseUINT32(maxPlayerMask);
	AtfValidator::validateIntMax(_descr, "maxPlayerMask", maxPlayerMask, (2*MobileMaxPlayer_Last-1), _checker, __FILE__, __LINE__);
	UINT32 clientSortingSeed; _parser0.parseUINT32(clientSortingSeed);
	AtfValidator::validateInt(_descr, "clientSortingSeed", clientSortingSeed, _checker, __FILE__, __LINE__);
	bool standardFormatOnly; _parser0.parseBOOL(standardFormatOnly);
	AtfValidator::validateInt(_descr, "standardFormatOnly", standardFormatOnly, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TournSelectionFilter
//=================================================================

MLobby::cli::TournSelectionFilter::TournSelectionFilter()
{
	clear();
}

void MLobby::cli::TournSelectionFilter::clear()
{
	version = 0;
	country.clear();
	siteId = 0;
	brandId = 0;
	gameMask = 0;
	buyInMask = 0;
	minBuyIn = 0;
	maxBuyIn = 0;
	multiplierPM = 0;
	currencyMask = 0;
	sortOrder = 0;
	locale = 0;
	speedMask = 0;
	gameVariantMask = 0;
	startingWithin = 0;
	registeringOnly = false;
	tournName.clear();
	tableSize = 0;
	visibilityStrings.clear();
	tournLobbies.clear();
}

bool MLobby::cli::TournSelectionFilter::equals(const TournSelectionFilter& _o) const
{
	return version == _o.version &&
		country.equals(_o.country) &&
		siteId == _o.siteId &&
		brandId == _o.brandId &&
		gameMask == _o.gameMask &&
		buyInMask == _o.buyInMask &&
		minBuyIn == _o.minBuyIn &&
		maxBuyIn == _o.maxBuyIn &&
		multiplierPM == _o.multiplierPM &&
		currencyMask == _o.currencyMask &&
		sortOrder == _o.sortOrder &&
		locale == _o.locale &&
		speedMask == _o.speedMask &&
		gameVariantMask == _o.gameVariantMask &&
		startingWithin == _o.startingWithin &&
		registeringOnly == _o.registeringOnly &&
		tournName.equals(_o.tournName) &&
		tableSize == _o.tableSize &&
		visibilityStrings.equals(_o.visibilityStrings) &&
		tournLobbies.equals(_o.tournLobbies);
}

const char *MLobby::cli::TournSelectionFilter::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("version=");
	_buf.appendUint(version);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("brandId=");
	_buf.appendUint(brandId);
	_buf.append(',');
	_buf.append("gameMask=");
	_buf.appendUint64(gameMask);
	_buf.append(',');
	_buf.append("buyInMask=");
	_buf.appendUint(buyInMask);
	_buf.append(',');
	_buf.append("minBuyIn=");
	_buf.appendUint64(minBuyIn);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendUint64(maxBuyIn);
	_buf.append(',');
	_buf.append("multiplierPM=");
	_buf.appendUint(multiplierPM);
	_buf.append(',');
	_buf.append("currencyMask=");
	_buf.appendUint(currencyMask);
	_buf.append(',');
	_buf.append("sortOrder=");
	_buf.appendUint(sortOrder);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("speedMask=");
	_buf.appendUint(speedMask);
	_buf.append(',');
	_buf.append("gameVariantMask=");
	_buf.appendUint(gameVariantMask);
	_buf.append(',');
	_buf.append("startingWithin=");
	_buf.appendUint(startingWithin);
	_buf.append(',');
	_buf.append("registeringOnly=");
	_buf.appendUint(registeringOnly);
	_buf.append(',');
	_buf.append("tournName=");
	_buf.append(tournName);
	_buf.append(',');
	_buf.append("tableSize=");
	_buf.appendUint(tableSize);
	_buf.append(',');
	_buf.append("visibilityStrings=");
	visibilityStrings.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tournLobbies=");
	tournLobbies.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MLobby::cli::TournSelectionFilter::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(TournSelectionFilter())) // not empty
	{
		_body.composeBYTE(version);
		_body.composeString(country);
		_body.composeUINT32(siteId);
		_body.composeUINT32(brandId);
		_body.composeUINT64(gameMask);
		_body.composeUINT32(buyInMask);
		_body.composeUINT64(minBuyIn);
		_body.composeUINT64(maxBuyIn);
		_body.composeUINT32(multiplierPM);
		_body.composeUINT32(currencyMask);
		_body.composeUINT32(sortOrder);
		_body.composeUINT32(locale);
		_body.composeUINT32(speedMask);
		_body.composeUINT32(gameVariantMask);
		_body.composeUINT32(startingWithin);
		_body.composeBOOL(registeringOnly);
		_body.composeString(tournName);
		_body.composeUINT32(tableSize);
		visibilityStrings.composeMsg(_body);
		tournLobbies.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::TournSelectionFilter::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(version);
	_parser0.parseStringP(country);
	_parser0.parseUINT32(siteId);
	_parser0.parseUINT32(brandId);
	_parser0.parseUINT64(gameMask);
	_parser0.parseUINT32(buyInMask);
	_parser0.parseUINT64(minBuyIn);
	_parser0.parseUINT64(maxBuyIn);
	_parser0.parseUINT32(multiplierPM);
	_parser0.parseUINT32(currencyMask);
	_parser0.parseUINT32(sortOrder);
	_parser0.parseUINT32(locale);
	_parser0.parseUINT32(speedMask);
	_parser0.parseUINT32(gameVariantMask);
	_parser0.parseUINT32(startingWithin);
	_parser0.parseBOOL(registeringOnly);
	_parser0.parseStringP(tournName);
	_parser0.parseUINT32(tableSize);
	if(_parser0.parseEnded()) return;
	visibilityStrings.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	tournLobbies.parseMsg(_parser0);
}

/*static*/ void MLobby::cli::TournSelectionFilter::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	BYTE version; _parser0.parseBYTE(version);
	AtfValidator::validateInt(_descr, "version", version, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, 3, _checker, __FILE__, __LINE__);
	UINT32 siteId; _parser0.parseUINT32(siteId);
	AtfValidator::validateIntRange(_descr, "siteId", siteId, PokerStars_SiteUnknown, (2*PokerStars_Last-1), _checker, __FILE__, __LINE__);
	UINT32 brandId; _parser0.parseUINT32(brandId);
	AtfValidator::validateIntRange(_descr, "brandId", brandId, BrandType_None, (2*BrandType_Last-1), _checker, __FILE__, __LINE__);
	UINT64 gameMask; _parser0.parseUINT64(gameMask);
	AtfValidator::validateUintMax(_descr, "gameMask", gameMask, (2*(UINT64)MobileGameTypes::MobileGame_Last-1), _checker, __FILE__, __LINE__);
	UINT32 buyInMask; _parser0.parseUINT32(buyInMask);
	AtfValidator::validateIntMax(_descr, "buyInMask", buyInMask, (2*MobileBuyIn_Last-1), _checker, __FILE__, __LINE__);
	UINT64 minBuyIn; _parser0.parseUINT64(minBuyIn);
	AtfValidator::validateUintMax(_descr, "minBuyIn", minBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	UINT64 maxBuyIn; _parser0.parseUINT64(maxBuyIn);
	AtfValidator::validateUintMax(_descr, "maxBuyIn", maxBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 multiplierPM; _parser0.parseUINT32(multiplierPM);
	AtfValidator::validateIntMax(_descr, "multiplierPM", multiplierPM, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 currencyMask; _parser0.parseUINT32(currencyMask);
	AtfValidator::validateIntMax(_descr, "currencyMask", currencyMask, (2*MobileCurrency_Last-1), _checker, __FILE__, __LINE__);
	UINT32 sortOrder; _parser0.parseUINT32(sortOrder);
	AtfValidator::validateIntRange(_descr, "sortOrder", sortOrder, MobileSortOrder_None, MobileSortOrder_Last, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser0.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT32 speedMask; _parser0.parseUINT32(speedMask);
	AtfValidator::validateIntMax(_descr, "speedMask", speedMask, (2*MobileTournSpeed_Last-1), _checker, __FILE__, __LINE__);
	UINT32 gameVariantMask; _parser0.parseUINT32(gameVariantMask);
	AtfValidator::validateIntMax(_descr, "gameVariantMask", gameVariantMask, (2*MobileGameVariant_Last-1), _checker, __FILE__, __LINE__);
	UINT32 startingWithin; _parser0.parseUINT32(startingWithin);
	AtfValidator::validateIntMax(_descr, "startingWithin", startingWithin, 1440, _checker, __FILE__, __LINE__);
	bool registeringOnly; _parser0.parseBOOL(registeringOnly);
	AtfValidator::validateInt(_descr, "registeringOnly", registeringOnly, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "tournName"); size_t szTournName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "tournName", szTournName, 1000, _checker, __FILE__, __LINE__);
	UINT32 tableSize; _parser0.parseUINT32(tableSize);
	AtfValidator::validateIntRange(_descr, "tableSize", tableSize, MobileTournTableSize_None, (2*MobileTournTableSize_Last-1), _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PString _descbuf;
	int szVisibilityStrings = ThinAtf::LAtfVector< PString , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("visibilityStrings"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "visibilityStrings", szVisibilityStrings, 100, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	int szTournLobbies = ThinAtf::LAtfVector< PString, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tournLobbies"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "tournLobbies", szTournLobbies, 1024, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    FinderAndBlitzSelectionFilter
//=================================================================

MLobby::cli::FinderAndBlitzSelectionFilter::FinderAndBlitzSelectionFilter()
{
	clear();
}

void MLobby::cli::FinderAndBlitzSelectionFilter::clear()
{
	version = 0;
	country.clear();
	siteId = 0;
	brandId = 0;
	gameMask = 0;
	buyInMask = 0;
	minBuyIn = 0;
	maxBuyIn = 0;
	multiplierPM = 0;
	currencyMask = 0;
	order = 0;
	maxPlayerMask = 0;
	clientSortingSeed = 0;
	standardFormatOnly = false;
	seatFindersAndBlitzes = 0;
}

bool MLobby::cli::FinderAndBlitzSelectionFilter::equals(const FinderAndBlitzSelectionFilter& _o) const
{
	return version == _o.version &&
		country.equals(_o.country) &&
		siteId == _o.siteId &&
		brandId == _o.brandId &&
		gameMask == _o.gameMask &&
		buyInMask == _o.buyInMask &&
		minBuyIn == _o.minBuyIn &&
		maxBuyIn == _o.maxBuyIn &&
		multiplierPM == _o.multiplierPM &&
		currencyMask == _o.currencyMask &&
		order == _o.order &&
		maxPlayerMask == _o.maxPlayerMask &&
		clientSortingSeed == _o.clientSortingSeed &&
		standardFormatOnly == _o.standardFormatOnly &&
		seatFindersAndBlitzes == _o.seatFindersAndBlitzes;
}

const char *MLobby::cli::FinderAndBlitzSelectionFilter::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("version=");
	_buf.appendUint(version);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("brandId=");
	_buf.appendUint(brandId);
	_buf.append(',');
	_buf.append("gameMask=");
	_buf.appendUint64(gameMask);
	_buf.append(',');
	_buf.append("buyInMask=");
	_buf.appendUint(buyInMask);
	_buf.append(',');
	_buf.append("minBuyIn=");
	_buf.appendUint64(minBuyIn);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendUint64(maxBuyIn);
	_buf.append(',');
	_buf.append("multiplierPM=");
	_buf.appendUint(multiplierPM);
	_buf.append(',');
	_buf.append("currencyMask=");
	_buf.appendUint(currencyMask);
	_buf.append(',');
	_buf.append("order=");
	_buf.appendUint(order);
	_buf.append(',');
	_buf.append("maxPlayerMask=");
	_buf.appendUint(maxPlayerMask);
	_buf.append(',');
	_buf.append("clientSortingSeed=");
	_buf.appendUint(clientSortingSeed);
	_buf.append(',');
	_buf.append("standardFormatOnly=");
	_buf.appendUint(standardFormatOnly);
	_buf.append(',');
	_buf.append("seatFindersAndBlitzes=");
	_buf.appendInt(seatFindersAndBlitzes);
	_buf.append('}');
	return _buf.c_str();
}

void MLobby::cli::FinderAndBlitzSelectionFilter::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(FinderAndBlitzSelectionFilter())) // not empty
	{
		_body.composeBYTE(version);
		_body.composeString(country);
		_body.composeUINT32(siteId);
		_body.composeUINT32(brandId);
		_body.composeUINT64(gameMask);
		_body.composeUINT32(buyInMask);
		_body.composeUINT64(minBuyIn);
		_body.composeUINT64(maxBuyIn);
		_body.composeUINT32(multiplierPM);
		_body.composeUINT32(currencyMask);
		_body.composeUINT32(order);
		_body.composeUINT32(maxPlayerMask);
		_body.composeUINT32(clientSortingSeed);
		_body.composeBOOL(standardFormatOnly);
		_body.composeINT8(seatFindersAndBlitzes);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::FinderAndBlitzSelectionFilter::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(version);
	_parser0.parseStringP(country);
	_parser0.parseUINT32(siteId);
	_parser0.parseUINT32(brandId);
	_parser0.parseUINT64(gameMask);
	_parser0.parseUINT32(buyInMask);
	_parser0.parseUINT64(minBuyIn);
	_parser0.parseUINT64(maxBuyIn);
	_parser0.parseUINT32(multiplierPM);
	_parser0.parseUINT32(currencyMask);
	_parser0.parseUINT32(order);
	_parser0.parseUINT32(maxPlayerMask);
	_parser0.parseUINT32(clientSortingSeed);
	_parser0.parseBOOL(standardFormatOnly);
	_parser0.parseINT8(seatFindersAndBlitzes);
}

/*static*/ void MLobby::cli::FinderAndBlitzSelectionFilter::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	BYTE version; _parser0.parseBYTE(version);
	AtfValidator::validateInt(_descr, "version", version, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, 3, _checker, __FILE__, __LINE__);
	UINT32 siteId; _parser0.parseUINT32(siteId);
	AtfValidator::validateIntRange(_descr, "siteId", siteId, PokerStars_SiteUnknown, (2*PokerStars_Last-1), _checker, __FILE__, __LINE__);
	UINT32 brandId; _parser0.parseUINT32(brandId);
	AtfValidator::validateIntRange(_descr, "brandId", brandId, BrandType_None, (2*BrandType_Last-1), _checker, __FILE__, __LINE__);
	UINT64 gameMask; _parser0.parseUINT64(gameMask);
	AtfValidator::validateUintMax(_descr, "gameMask", gameMask, (2*(UINT64)MobileGameTypes::MobileGame_Last-1), _checker, __FILE__, __LINE__);
	UINT32 buyInMask; _parser0.parseUINT32(buyInMask);
	AtfValidator::validateIntMax(_descr, "buyInMask", buyInMask, (2*MobileBuyIn_Last-1), _checker, __FILE__, __LINE__);
	UINT64 minBuyIn; _parser0.parseUINT64(minBuyIn);
	AtfValidator::validateUintMax(_descr, "minBuyIn", minBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	UINT64 maxBuyIn; _parser0.parseUINT64(maxBuyIn);
	AtfValidator::validateUintMax(_descr, "maxBuyIn", maxBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 multiplierPM; _parser0.parseUINT32(multiplierPM);
	AtfValidator::validateIntMax(_descr, "multiplierPM", multiplierPM, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 currencyMask; _parser0.parseUINT32(currencyMask);
	AtfValidator::validateIntMax(_descr, "currencyMask", currencyMask, (2*MobileCurrency_Last-1), _checker, __FILE__, __LINE__);
	UINT32 order; _parser0.parseUINT32(order);
	AtfValidator::validateIntMax(_descr, "order", order, SelectionFilter::TableOrder_Last, _checker, __FILE__, __LINE__);
	UINT32 maxPlayerMask; _parser0.parseUINT32(maxPlayerMask);
	AtfValidator::validateIntMax(_descr, "maxPlayerMask", maxPlayerMask, (2*MobileMaxPlayer_Last-1), _checker, __FILE__, __LINE__);
	UINT32 clientSortingSeed; _parser0.parseUINT32(clientSortingSeed);
	AtfValidator::validateInt(_descr, "clientSortingSeed", clientSortingSeed, _checker, __FILE__, __LINE__);
	bool standardFormatOnly; _parser0.parseBOOL(standardFormatOnly);
	AtfValidator::validateInt(_descr, "standardFormatOnly", standardFormatOnly, _checker, __FILE__, __LINE__);
	INT8 seatFindersAndBlitzes; _parser0.parseINT8(seatFindersAndBlitzes);
	AtfValidator::validateIntRange(_descr, "seatFindersAndBlitzes", seatFindersAndBlitzes, SelectionFilter::SeatFindersAndBlitzes_Both, SelectionFilter::SeatFindersAndBlitzes_Last, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    RingStaticData
//=================================================================

MLobby::cli::RingStaticData::RingStaticData()
{
	clear();
}

void MLobby::cli::RingStaticData::clear()
{
	tableId32 = 0;
	name.clear();
	server.clear();
	serverObject.clear();
	tableFlags = 0;
	isOneOnOne = 0;
	isPlayMoney = 0;
	maxPlayers = 0;
	game = 0;
	isHiLo = 0;
	loBet = 0;
	hiBet = 0;
	structure = 0;
	specialName.clear();
	visibilityMask = 0;
	chatLang = 0;
	currency.clear();
	minChipsLimit = 0;
	maxBuyIn = 0;
	ante = 0;
	countryRestrictionInverted = false;
	restrictedCountries.clear();
	cap = 0;
	icon = 0;
	filter = 0;
	tableInstanceFlags = 0;
	isTableStarter = false;
	tableFlags2 = 0;
	tableTypeId = 0;
	scalePM = 0;
	defaultBuyIn = 0;
	tableId = 0;
	brandMask = 0;
	poolBlockMinHands = 0;
	visibilityCriteria.clear();
	tableStakes.clear();
	variableAntes.clear();
	visibilityMaskEx.clear();
}

bool MLobby::cli::RingStaticData::equals(const RingStaticData& _o) const
{
	return tableId32 == _o.tableId32 &&
		name.equals(_o.name) &&
		server.equals(_o.server) &&
		serverObject.equals(_o.serverObject) &&
		tableFlags == _o.tableFlags &&
		isOneOnOne == _o.isOneOnOne &&
		isPlayMoney == _o.isPlayMoney &&
		maxPlayers == _o.maxPlayers &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		loBet == _o.loBet &&
		hiBet == _o.hiBet &&
		structure == _o.structure &&
		specialName.equals(_o.specialName) &&
		visibilityMask == _o.visibilityMask &&
		chatLang == _o.chatLang &&
		currency.equals(_o.currency) &&
		minChipsLimit == _o.minChipsLimit &&
		maxBuyIn == _o.maxBuyIn &&
		ante == _o.ante &&
		countryRestrictionInverted == _o.countryRestrictionInverted &&
		restrictedCountries.equals(_o.restrictedCountries) &&
		cap == _o.cap &&
		icon == _o.icon &&
		filter == _o.filter &&
		tableInstanceFlags == _o.tableInstanceFlags &&
		isTableStarter == _o.isTableStarter &&
		tableFlags2 == _o.tableFlags2 &&
		tableTypeId == _o.tableTypeId &&
		scalePM == _o.scalePM &&
		defaultBuyIn == _o.defaultBuyIn &&
		tableId == _o.tableId &&
		brandMask == _o.brandMask &&
		poolBlockMinHands == _o.poolBlockMinHands &&
		visibilityCriteria.equals(_o.visibilityCriteria) &&
		tableStakes.equals(_o.tableStakes) &&
		variableAntes.equals(_o.variableAntes) &&
		visibilityMaskEx.equals(_o.visibilityMaskEx);
}

const char *MLobby::cli::RingStaticData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tableId32=");
	_buf.appendUint(tableId32);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("serverObject=");
	_buf.append(serverObject);
	_buf.append(',');
	_buf.append("tableFlags=");
	_buf.appendUint(tableFlags);
	_buf.append(',');
	_buf.append("isOneOnOne=");
	_buf.appendUint(isOneOnOne);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendUint(maxPlayers);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("loBet=");
	_buf.appendUint(loBet);
	_buf.append(',');
	_buf.append("hiBet=");
	_buf.appendUint(hiBet);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("specialName=");
	_buf.append(specialName);
	_buf.append(',');
	_buf.append("visibilityMask=");
	_buf.appendUint(visibilityMask);
	_buf.append(',');
	_buf.append("chatLang=");
	_buf.appendUint(chatLang);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("minChipsLimit=");
	_buf.appendUint(minChipsLimit);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendInt(maxBuyIn);
	_buf.append(',');
	_buf.append("ante=");
	_buf.appendUint(ante);
	_buf.append(',');
	_buf.append("countryRestrictionInverted=");
	_buf.appendUint(countryRestrictionInverted);
	_buf.append(',');
	_buf.append("restrictedCountries=");
	restrictedCountries.toTraceString(_buf);
	_buf.append(',');
	_buf.append("cap=");
	_buf.appendUint(cap);
	_buf.append(',');
	_buf.append("icon=");
	_buf.appendUint(icon);
	_buf.append(',');
	_buf.append("filter=");
	_buf.appendUint(filter);
	_buf.append(',');
	_buf.append("tableInstanceFlags=");
	_buf.appendUint(tableInstanceFlags);
	_buf.append(',');
	_buf.append("isTableStarter=");
	_buf.appendUint(isTableStarter);
	_buf.append(',');
	_buf.append("tableFlags2=");
	_buf.appendUint64(tableFlags2);
	_buf.append(',');
	_buf.append("tableTypeId=");
	_buf.appendUint(tableTypeId);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("defaultBuyIn=");
	_buf.appendUint(defaultBuyIn);
	_buf.append(',');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	_buf.append(',');
	_buf.append("brandMask=");
	_buf.appendUint(brandMask);
	_buf.append(',');
	_buf.append("poolBlockMinHands=");
	_buf.appendInt(poolBlockMinHands);
	_buf.append(',');
	_buf.append("visibilityCriteria=");
	_buf.append(visibilityCriteria);
	_buf.append(',');
	_buf.append("tableStakes=");
	tableStakes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("variableAntes=");
	variableAntes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("visibilityMaskEx=");
	visibilityMaskEx.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MLobby::cli::RingStaticData::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(RingStaticData())) // not empty
	{
		_body.composeUINT32(tableId32);
		_body.composeString(name);
		_body.composeString(server);
		_body.composeString(serverObject);
		_body.composeUINT32(tableFlags);
		_body.composeBYTE(isOneOnOne);
		_body.composeBYTE(isPlayMoney);
		_body.composeBYTE(maxPlayers);
		_body.composeBYTE(game);
		_body.composeBYTE(isHiLo);
		_body.composeUINT32(loBet);
		_body.composeUINT32(hiBet);
		_body.composeBYTE(structure);
		_body.composeString(specialName);
		_body.composeUINT32(visibilityMask);
		_body.composeUINT16(chatLang);
		_body.composeString(currency);
		_body.composeUINT32(minChipsLimit);
		_body.composeINT32(maxBuyIn);
		_body.composeUINT32(ante);
		_body.composeBOOL(countryRestrictionInverted);
		restrictedCountries.composeMsg(_body);
		_body.composeUINT32(cap);
		_body.composeBYTE(icon);
		_body.composeBYTE(filter);
		_body.composeUINT32(tableInstanceFlags);
		_body.composeBOOL(isTableStarter);
		_body.composeUINT64(tableFlags2);
		_body.composeUINT32(tableTypeId);
		_body.composeUINT32(scalePM);
		_body.composeUINT32(defaultBuyIn);
		_body.composeUINT64(tableId);
		_body.composeUINT32(brandMask);
		_body.composeINT32(poolBlockMinHands);
		_body.composeString(visibilityCriteria);
		tableStakes.composeMsg(_body);
		variableAntes.composeMsg(_body);
		visibilityMaskEx.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::RingStaticData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(tableId32);
	_parser0.parseStringP(name);
	_parser0.parseStringP(server);
	_parser0.parseStringP(serverObject);
	_parser0.parseUINT32(tableFlags);
	_parser0.parseBYTE(isOneOnOne);
	_parser0.parseBYTE(isPlayMoney);
	_parser0.parseBYTE(maxPlayers);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(isHiLo);
	_parser0.parseUINT32(loBet);
	_parser0.parseUINT32(hiBet);
	_parser0.parseBYTE(structure);
	_parser0.parseStringP(specialName);
	_parser0.parseUINT32(visibilityMask);
	_parser0.parseUINT16(chatLang);
	_parser0.parseStringP(currency);
	_parser0.parseUINT32(minChipsLimit);
	_parser0.parseINT32(maxBuyIn);
	_parser0.parseUINT32(ante);
	_parser0.parseBOOL(countryRestrictionInverted);
	restrictedCountries.parseMsg(_parser0);
	_parser0.parseUINT32(cap);
	_parser0.parseBYTE(icon);
	_parser0.parseBYTE(filter);
	_parser0.parseUINT32(tableInstanceFlags);
	_parser0.parseBOOL(isTableStarter);
	_parser0.parseUINT64(tableFlags2);
	_parser0.parseUINT32(tableTypeId);
	_parser0.parseUINT32(scalePM);
	_parser0.parseUINT32(defaultBuyIn);
	_parser0.parseUINT64(tableId);
	_parser0.parseUINT32(brandMask);
	_parser0.parseINT32(poolBlockMinHands);
	_parser0.parseStringP(visibilityCriteria);
	if(_parser0.parseEnded()) return;
	tableStakes.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	variableAntes.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	visibilityMaskEx.parseMsg(_parser0);
}

/*static*/ void MLobby::cli::RingStaticData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 tableId32; _parser0.parseUINT32(tableId32);
	AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "serverObject"); size_t szServerObject = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObject", szServerObject, _checker, __FILE__, __LINE__);
	UINT32 tableFlags; _parser0.parseUINT32(tableFlags);
	AtfValidator::validateInt(_descr, "tableFlags", tableFlags, _checker, __FILE__, __LINE__);
	BYTE isOneOnOne; _parser0.parseBYTE(isOneOnOne);
	AtfValidator::validateInt(_descr, "isOneOnOne", isOneOnOne, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser0.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	BYTE maxPlayers; _parser0.parseBYTE(maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser0.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	UINT32 loBet; _parser0.parseUINT32(loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	UINT32 hiBet; _parser0.parseUINT32(hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "specialName"); size_t szSpecialName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "specialName", szSpecialName, _checker, __FILE__, __LINE__);
	UINT32 visibilityMask; _parser0.parseUINT32(visibilityMask);
	AtfValidator::validateInt(_descr, "visibilityMask", visibilityMask, _checker, __FILE__, __LINE__);
	UINT16 chatLang; _parser0.parseUINT16(chatLang);
	AtfValidator::validateInt(_descr, "chatLang", chatLang, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 minChipsLimit; _parser0.parseUINT32(minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	INT32 maxBuyIn; _parser0.parseINT32(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	UINT32 ante; _parser0.parseUINT32(ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	bool countryRestrictionInverted; _parser0.parseBOOL(countryRestrictionInverted);
	AtfValidator::validateInt(_descr, "countryRestrictionInverted", countryRestrictionInverted, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szRestrictedCountries = ThinAtf::LAtfVector< PString , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("restrictedCountries"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "restrictedCountries", szRestrictedCountries, _checker, __FILE__, __LINE__);
	UINT32 cap; _parser0.parseUINT32(cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	BYTE icon; _parser0.parseBYTE(icon);
	AtfValidator::validateInt(_descr, "icon", icon, _checker, __FILE__, __LINE__);
	BYTE filter; _parser0.parseBYTE(filter);
	AtfValidator::validateInt(_descr, "filter", filter, _checker, __FILE__, __LINE__);
	UINT32 tableInstanceFlags; _parser0.parseUINT32(tableInstanceFlags);
	AtfValidator::validateInt(_descr, "tableInstanceFlags", tableInstanceFlags, _checker, __FILE__, __LINE__);
	bool isTableStarter; _parser0.parseBOOL(isTableStarter);
	AtfValidator::validateInt(_descr, "isTableStarter", isTableStarter, _checker, __FILE__, __LINE__);
	UINT64 tableFlags2; _parser0.parseUINT64(tableFlags2);
	AtfValidator::validateUint(_descr, "tableFlags2", tableFlags2, _checker, __FILE__, __LINE__);
	UINT32 tableTypeId; _parser0.parseUINT32(tableTypeId);
	AtfValidator::validateInt(_descr, "tableTypeId", tableTypeId, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser0.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT32 defaultBuyIn; _parser0.parseUINT32(defaultBuyIn);
	AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	UINT64 tableId; _parser0.parseUINT64(tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	UINT32 brandMask; _parser0.parseUINT32(brandMask);
	AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
	INT32 poolBlockMinHands; _parser0.parseINT32(poolBlockMinHands);
	AtfValidator::validateInt(_descr, "poolBlockMinHands", poolBlockMinHands, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "visibilityCriteria"); size_t szVisibilityCriteria = strlen(_dummy);
	AtfValidator::validateInt(_descr, "visibilityCriteria", szVisibilityCriteria, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	TableCommonThin::TableStakes::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tableStakes"), _fieldsWithUnparsedContent);
	if(_parser0.parseEnded()) return;
	int szVariableAntes = ThinAtf::LAtfVector< INT64, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("variableAntes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "variableAntes", szVariableAntes, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("visibilityMaskEx"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    FppFactorStruct
//=================================================================

MLobby::cli::FppFactorStruct::FppFactorStruct()
{
	clear();
}

void MLobby::cli::FppFactorStruct::clear()
{
	fppFactor = 0;
	sites = 0;
	gameCategory = 0;
	number = 0;
	endT.setNull();
	sitesEx.clear();
}

bool MLobby::cli::FppFactorStruct::equals(const FppFactorStruct& _o) const
{
	return fppFactor == _o.fppFactor &&
		sites == _o.sites &&
		gameCategory == _o.gameCategory &&
		number == _o.number &&
		endT.equals(_o.endT) &&
		sitesEx.equals(_o.sitesEx);
}

const char *MLobby::cli::FppFactorStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("fppFactor=");
	_buf.appendUint(fppFactor);
	_buf.append(',');
	_buf.append("sites=");
	_buf.appendUint(sites);
	_buf.append(',');
	_buf.append("gameCategory=");
	_buf.appendUint(gameCategory);
	_buf.append(',');
	_buf.append("number=");
	_buf.appendUint(number);
	_buf.append(',');
	_buf.append("endT=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, endT);
	_buf.append(',');
	_buf.append("sitesEx=");
	sitesEx.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MLobby::cli::FppFactorStruct::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(FppFactorStruct())) // not empty
	{
		_body.composeUINT16(fppFactor);
		_body.composeUINT32(sites);
		_body.composeUINT32(gameCategory);
		_body.composeUINT32(number);
		_body.composeSrvTime(endT);
		sitesEx.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::FppFactorStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT16(fppFactor);
	_parser0.parseUINT32(sites);
	_parser0.parseUINT32(gameCategory);
	_parser0.parseUINT32(number);
	_parser0.parseSrvTime(endT);
	if(_parser0.parseEnded()) return;
	sitesEx.parseMsg(_parser0);
}

/*static*/ void MLobby::cli::FppFactorStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT16 fppFactor; _parser0.parseUINT16(fppFactor);
	AtfValidator::validateInt(_descr, "fppFactor", fppFactor, _checker, __FILE__, __LINE__);
	UINT32 sites; _parser0.parseUINT32(sites);
	AtfValidator::validateInt(_descr, "sites", sites, _checker, __FILE__, __LINE__);
	UINT32 gameCategory; _parser0.parseUINT32(gameCategory);
	AtfValidator::validateInt(_descr, "gameCategory", gameCategory, _checker, __FILE__, __LINE__);
	UINT32 number; _parser0.parseUINT32(number);
	AtfValidator::validateInt(_descr, "number", number, _checker, __FILE__, __LINE__);
	SrvTime endT; _parser0.parseSrvTime(endT);
	AtfValidator::validateSrvDateTime(_descr, "endT", endT, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PString _descbuf;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("sitesEx"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    RingDynaData
//=================================================================

MLobby::cli::RingDynaData::RingDynaData()
{
	clear();
}

void MLobby::cli::RingDynaData::clear()
{
	numPlayers = 0;
	wait = 0;
	playersPerFlop = 0;
	potSize = 0;
	handsPerHour = 0;
	publProp = 0;
	averageStackSize = 0;
	vpip = 0;
	fppFactors.clear();
	isTableDealingCards = false;
}

bool MLobby::cli::RingDynaData::equals(const RingDynaData& _o) const
{
	return numPlayers == _o.numPlayers &&
		wait == _o.wait &&
		playersPerFlop == _o.playersPerFlop &&
		potSize == _o.potSize &&
		handsPerHour == _o.handsPerHour &&
		publProp == _o.publProp &&
		averageStackSize == _o.averageStackSize &&
		vpip == _o.vpip &&
		fppFactors.equals(_o.fppFactors) &&
		isTableDealingCards == _o.isTableDealingCards;
}

const char *MLobby::cli::RingDynaData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("numPlayers=");
	_buf.appendUint(numPlayers);
	_buf.append(',');
	_buf.append("wait=");
	_buf.appendUint(wait);
	_buf.append(',');
	_buf.append("playersPerFlop=");
	_buf.appendUint(playersPerFlop);
	_buf.append(',');
	_buf.append("potSize=");
	_buf.appendUint(potSize);
	_buf.append(',');
	_buf.append("handsPerHour=");
	_buf.appendUint(handsPerHour);
	_buf.append(',');
	_buf.append("publProp=");
	_buf.appendUint(publProp);
	_buf.append(',');
	_buf.append("averageStackSize=");
	_buf.appendUint(averageStackSize);
	_buf.append(',');
	_buf.append("vpip=");
	_buf.appendUint(vpip);
	_buf.append(',');
	_buf.append("fppFactors=");
	fppFactors.toTraceString(_buf);
	_buf.append(',');
	_buf.append("isTableDealingCards=");
	_buf.appendUint(isTableDealingCards);
	_buf.append('}');
	return _buf.c_str();
}

void MLobby::cli::RingDynaData::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(RingDynaData())) // not empty
	{
		_body.composeBYTE(numPlayers);
		_body.composeBYTE(wait);
		_body.composeBYTE(playersPerFlop);
		_body.composeUINT32(potSize);
		_body.composeUINT16(handsPerHour);
		_body.composeBYTE(publProp);
		_body.composeUINT32(averageStackSize);
		_body.composeBYTE(vpip);
		fppFactors.composeMsg(_body);
		_body.composeBOOL(isTableDealingCards);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::RingDynaData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(numPlayers);
	_parser0.parseBYTE(wait);
	_parser0.parseBYTE(playersPerFlop);
	_parser0.parseUINT32(potSize);
	_parser0.parseUINT16(handsPerHour);
	_parser0.parseBYTE(publProp);
	_parser0.parseUINT32(averageStackSize);
	_parser0.parseBYTE(vpip);
	fppFactors.parseMsg(_parser0);
	_parser0.parseBOOL(isTableDealingCards);
}

/*static*/ void MLobby::cli::RingDynaData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	BYTE numPlayers; _parser0.parseBYTE(numPlayers);
	AtfValidator::validateInt(_descr, "numPlayers", numPlayers, _checker, __FILE__, __LINE__);
	BYTE wait; _parser0.parseBYTE(wait);
	AtfValidator::validateInt(_descr, "wait", wait, _checker, __FILE__, __LINE__);
	BYTE playersPerFlop; _parser0.parseBYTE(playersPerFlop);
	AtfValidator::validateInt(_descr, "playersPerFlop", playersPerFlop, _checker, __FILE__, __LINE__);
	UINT32 potSize; _parser0.parseUINT32(potSize);
	AtfValidator::validateInt(_descr, "potSize", potSize, _checker, __FILE__, __LINE__);
	UINT16 handsPerHour; _parser0.parseUINT16(handsPerHour);
	AtfValidator::validateInt(_descr, "handsPerHour", handsPerHour, _checker, __FILE__, __LINE__);
	BYTE publProp; _parser0.parseBYTE(publProp);
	AtfValidator::validateInt(_descr, "publProp", publProp, _checker, __FILE__, __LINE__);
	UINT32 averageStackSize; _parser0.parseUINT32(averageStackSize);
	AtfValidator::validateInt(_descr, "averageStackSize", averageStackSize, _checker, __FILE__, __LINE__);
	BYTE vpip; _parser0.parseBYTE(vpip);
	AtfValidator::validateInt(_descr, "vpip", vpip, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szFppFactors = ThinAtf::LAtfVector< FppFactorStruct, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("fppFactors"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "fppFactors", szFppFactors, _checker, __FILE__, __LINE__);
	bool isTableDealingCards; _parser0.parseBOOL(isTableDealingCards);
	AtfValidator::validateInt(_descr, "isTableDealingCards", isTableDealingCards, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    RingDataStruct
//=================================================================

MLobby::cli::RingDataStruct::RingDataStruct()
{
	clear();
}

void MLobby::cli::RingDataStruct::clear()
{
	staticData.clear();
	dynamicData.clear();
}

bool MLobby::cli::RingDataStruct::equals(const RingDataStruct& _o) const
{
	return staticData.equals(_o.staticData) &&
		dynamicData.equals(_o.dynamicData);
}

const char *MLobby::cli::RingDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("staticData=");
	staticData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("dynamicData=");
	dynamicData.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MLobby::cli::RingDataStruct::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(RingDataStruct())) // not empty
	{
		staticData.composeMsg(_body);
		dynamicData.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::RingDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	staticData.parseMsg(_parser0);
	dynamicData.parseMsg(_parser0);
}

/*static*/ void MLobby::cli::RingDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	RingStaticData::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("staticData"), _fieldsWithUnparsedContent);
	RingDynaData::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("dynamicData"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    HybridLobbySelectionFilter
//=================================================================

MLobby::cli::HybridLobbySelectionFilter::HybridLobbySelectionFilter()
{
	clear();
}

void MLobby::cli::HybridLobbySelectionFilter::clear()
{
	version = 0;
	country.clear();
	siteId = 0;
	brandId = 0;
	gameMask = 0;
	buyInMask = 0;
	minBuyIn = 0;
	maxBuyIn = 0;
	multiplierPM = 0;
	currencyMask = 0;
	order = 0;
	maxPlayerMask = 0;
	clientSortingSeed = 0;
	standardFormatOnly = false;
	gameTypes = 0;
	showStealthTables = true;
}

bool MLobby::cli::HybridLobbySelectionFilter::equals(const HybridLobbySelectionFilter& _o) const
{
	return version == _o.version &&
		country.equals(_o.country) &&
		siteId == _o.siteId &&
		brandId == _o.brandId &&
		gameMask == _o.gameMask &&
		buyInMask == _o.buyInMask &&
		minBuyIn == _o.minBuyIn &&
		maxBuyIn == _o.maxBuyIn &&
		multiplierPM == _o.multiplierPM &&
		currencyMask == _o.currencyMask &&
		order == _o.order &&
		maxPlayerMask == _o.maxPlayerMask &&
		clientSortingSeed == _o.clientSortingSeed &&
		standardFormatOnly == _o.standardFormatOnly &&
		gameTypes == _o.gameTypes &&
		showStealthTables == _o.showStealthTables;
}

const char *MLobby::cli::HybridLobbySelectionFilter::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("version=");
	_buf.appendUint(version);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("brandId=");
	_buf.appendUint(brandId);
	_buf.append(',');
	_buf.append("gameMask=");
	_buf.appendUint64(gameMask);
	_buf.append(',');
	_buf.append("buyInMask=");
	_buf.appendUint(buyInMask);
	_buf.append(',');
	_buf.append("minBuyIn=");
	_buf.appendUint64(minBuyIn);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendUint64(maxBuyIn);
	_buf.append(',');
	_buf.append("multiplierPM=");
	_buf.appendUint(multiplierPM);
	_buf.append(',');
	_buf.append("currencyMask=");
	_buf.appendUint(currencyMask);
	_buf.append(',');
	_buf.append("order=");
	_buf.appendUint(order);
	_buf.append(',');
	_buf.append("maxPlayerMask=");
	_buf.appendUint(maxPlayerMask);
	_buf.append(',');
	_buf.append("clientSortingSeed=");
	_buf.appendUint(clientSortingSeed);
	_buf.append(',');
	_buf.append("standardFormatOnly=");
	_buf.appendUint(standardFormatOnly);
	_buf.append(',');
	_buf.append("gameTypes=");
	_buf.appendUint(gameTypes);
	_buf.append(',');
	_buf.append("showStealthTables=");
	_buf.appendUint(showStealthTables);
	_buf.append('}');
	return _buf.c_str();
}

void MLobby::cli::HybridLobbySelectionFilter::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(HybridLobbySelectionFilter())) // not empty
	{
		_body.composeBYTE(version);
		_body.composeString(country);
		_body.composeUINT32(siteId);
		_body.composeUINT32(brandId);
		_body.composeUINT64(gameMask);
		_body.composeUINT32(buyInMask);
		_body.composeUINT64(minBuyIn);
		_body.composeUINT64(maxBuyIn);
		_body.composeUINT32(multiplierPM);
		_body.composeUINT32(currencyMask);
		_body.composeUINT32(order);
		_body.composeUINT32(maxPlayerMask);
		_body.composeUINT32(clientSortingSeed);
		_body.composeBOOL(standardFormatOnly);
		_body.composeUINT32(gameTypes);
		_body.composeBOOL(showStealthTables);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::HybridLobbySelectionFilter::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(version);
	_parser0.parseStringP(country);
	_parser0.parseUINT32(siteId);
	_parser0.parseUINT32(brandId);
	_parser0.parseUINT64(gameMask);
	_parser0.parseUINT32(buyInMask);
	_parser0.parseUINT64(minBuyIn);
	_parser0.parseUINT64(maxBuyIn);
	_parser0.parseUINT32(multiplierPM);
	_parser0.parseUINT32(currencyMask);
	_parser0.parseUINT32(order);
	_parser0.parseUINT32(maxPlayerMask);
	_parser0.parseUINT32(clientSortingSeed);
	_parser0.parseBOOL(standardFormatOnly);
	_parser0.parseUINT32(gameTypes);
	if(_parser0.parseEnded()) return;
	_parser0.parseBOOL(showStealthTables);
}

/*static*/ void MLobby::cli::HybridLobbySelectionFilter::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	BYTE version; _parser0.parseBYTE(version);
	AtfValidator::validateInt(_descr, "version", version, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, 3, _checker, __FILE__, __LINE__);
	UINT32 siteId; _parser0.parseUINT32(siteId);
	AtfValidator::validateIntRange(_descr, "siteId", siteId, PokerStars_SiteUnknown, (2*PokerStars_Last-1), _checker, __FILE__, __LINE__);
	UINT32 brandId; _parser0.parseUINT32(brandId);
	AtfValidator::validateIntRange(_descr, "brandId", brandId, BrandType_None, (2*BrandType_Last-1), _checker, __FILE__, __LINE__);
	UINT64 gameMask; _parser0.parseUINT64(gameMask);
	AtfValidator::validateUintMax(_descr, "gameMask", gameMask, (2*(UINT64)MobileGameTypes::MobileGame_Last-1), _checker, __FILE__, __LINE__);
	UINT32 buyInMask; _parser0.parseUINT32(buyInMask);
	AtfValidator::validateIntMax(_descr, "buyInMask", buyInMask, (2*MobileBuyIn_Last-1), _checker, __FILE__, __LINE__);
	UINT64 minBuyIn; _parser0.parseUINT64(minBuyIn);
	AtfValidator::validateUintMax(_descr, "minBuyIn", minBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	UINT64 maxBuyIn; _parser0.parseUINT64(maxBuyIn);
	AtfValidator::validateUintMax(_descr, "maxBuyIn", maxBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 multiplierPM; _parser0.parseUINT32(multiplierPM);
	AtfValidator::validateIntMax(_descr, "multiplierPM", multiplierPM, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 currencyMask; _parser0.parseUINT32(currencyMask);
	AtfValidator::validateIntMax(_descr, "currencyMask", currencyMask, (2*MobileCurrency_Last-1), _checker, __FILE__, __LINE__);
	UINT32 order; _parser0.parseUINT32(order);
	AtfValidator::validateIntMax(_descr, "order", order, SelectionFilter::TableOrder_Last, _checker, __FILE__, __LINE__);
	UINT32 maxPlayerMask; _parser0.parseUINT32(maxPlayerMask);
	AtfValidator::validateIntMax(_descr, "maxPlayerMask", maxPlayerMask, (2*MobileMaxPlayer_Last-1), _checker, __FILE__, __LINE__);
	UINT32 clientSortingSeed; _parser0.parseUINT32(clientSortingSeed);
	AtfValidator::validateInt(_descr, "clientSortingSeed", clientSortingSeed, _checker, __FILE__, __LINE__);
	bool standardFormatOnly; _parser0.parseBOOL(standardFormatOnly);
	AtfValidator::validateInt(_descr, "standardFormatOnly", standardFormatOnly, _checker, __FILE__, __LINE__);
	UINT32 gameTypes; _parser0.parseUINT32(gameTypes);
	AtfValidator::validateIntRange(_descr, "gameTypes", gameTypes, MobileHybridLobbyGameTypes_None, (2*MobileHybridLobbyGameTypes_Last-1), _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	bool showStealthTables; _parser0.parseBOOL(showStealthTables);
	AtfValidator::validateInt(_descr, "showStealthTables", showStealthTables, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_RINGGAMES2
//=================================================================

MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2::Protocol_MSG_MLOBBY_FIND_RINGGAMES2()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2::clear()
{
	filter.clear();
	maxItems = 0;
	excludedTables.clear();
	context = 0;
	installId.clear();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2::equals(const Protocol_MSG_MLOBBY_FIND_RINGGAMES2& _o) const
{
	return filter.equals(_o.filter) &&
		maxItems == _o.maxItems &&
		excludedTables.equals(_o.excludedTables) &&
		context == _o.context &&
		installId.equals(_o.installId);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_RINGGAMES2).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("maxItems=");
	_buf.appendUint(maxItems);
	_buf.append(',');
	_buf.append("excludedTables=");
	excludedTables.toTraceString(_buf);
	_buf.append(',');
	_buf.append("context=");
	_buf.appendUint(context);
	_buf.append(',');
	_buf.append("installId=");
	_buf.append(installId);
	return _buf.c_str();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2::composeMsg(CommMsgBody& _msg) const
{
	filter.composeMsg(_msg);
	_msg.composeUINT32(maxItems);
	excludedTables.composeMsg(_msg);
	_msg.composeUINT32(context);
	_msg.composeString(installId);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	_parser.parseUINT32(maxItems);
	if(_parser.parseEnded()) return;
	excludedTables.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(context);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(installId);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_RINGGAMES2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	PString _descbuf;
	TableSelectionFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	UINT32 maxItems; _parser.parseUINT32(maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	int szExcludedTables = ThinAtf::LAtfVector< UINT64, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("excludedTables"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "excludedTables", szExcludedTables, 1024, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 context; _parser.parseUINT32(context);
	AtfValidator::validateInt(_descr, "context", context, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "installId"); size_t szInstallId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "installId", szInstallId, 128, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_RINGGAMES2_REPLY
//=================================================================

MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2_REPLY::Protocol_MSG_MLOBBY_FIND_RINGGAMES2_REPLY()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2_REPLY::clear()
{
	totalItems = 0;
	tables.clear();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2_REPLY::equals(const Protocol_MSG_MLOBBY_FIND_RINGGAMES2_REPLY& _o) const
{
	return totalItems == _o.totalItems &&
		tables.equals(_o.tables);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_RINGGAMES2_REPLY).append(")");
	_buf.append(',');
	_buf.append("totalItems=");
	_buf.appendUint(totalItems);
	_buf.append(',');
	_buf.append("tables=");
	tables.toTraceString(_buf);
	return _buf.c_str();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(totalItems);
	tables.composeMsg(_msg);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(totalItems);
	tables.parseMsg(_parser);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_RINGGAMES2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 totalItems; _parser.parseUINT32(totalItems);
	AtfValidator::validateInt(_descr, "totalItems", totalItems, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTables = ThinAtf::LAtfVector< RingDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tables"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tables", szTables, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    TournStaticData
//=================================================================

MLobby::cli::TournStaticData::TournStaticData()
{
	clear();
}

void MLobby::cli::TournStaticData::clear()
{
	tournamentId = 0;
	server.clear();
	targetServer.clear();
	hasSatellite.clear();
	whenStart.setNull();
	buyIn = 0;
	rake = 0;
	fppBuyIn = 0;
	isRestricted = 0;
	isPwdProtected = 0;
	name.clear();
	admissionId.clear();
	isPlayMoney = 0;
	satelliteTarget = 0;
	minPlayers = 0;
	tournFlags = 0;
	game = 0;
	isHiLo = 0;
	structure = 0;
	tournMask = 0;
	tournSites = 0;
	whenStartInt = 0;
	tournMask2 = 0;
	targetWhenStart.setNull();
	tournMask3 = 0;
	tournMask4 = 0;
	maxPerTable = 0;
	countryRestrictionInverted = false;
	restrictedCountries.clear();
	hasDayTwoStart = 0;
	dayTwoStartSec = 0;
	dayTwoStart.setNull();
	shortText.clear();
	chatLang = 0;
	currency.clear();
	tournFlagsServInt = 0;
	knockout = 0;
	satelliteTargetReference.clear();
	satelliteTargetReferenceLock = 0;
	maxPlayers = 0;
	speedDisplay = 0;
	nameSnG.clear();
	step = 0;
	timedTournType = 0;
	timedTournTime = 0;
	timedTournPayout = 0;
	isFlightTourn = false;
	tournBrand.clear();
	scalePM = 0;
	progressiveKnockout = 0;
	awardScheme = 0;
	numReentries = 0;
	internalReference.clear();
	favReference.clear();
	satelliteTargetName.clear();
	admissionPrice = 0;
	tournFlags2 = 0;
	regEndAbs.setNull();
	regEndAbsInt = 0;
	doNotAllowToUnreg = false;
	nStackInfo.clear();
	tournMask5 = 0;
	tournMask6 = 0;
	satelliteTargetNameMTT.clear();
	liveEventMask = 0;
	timedTournPlayersPercent = 0;
	dummy1 = 0;
	rmPmLobby = 0;
	brandAccessMask = 0;
	activeFlags = 0;
	sngScriptId = 0;
	customSpeedDisplayName.clear();
	tournSitesEx.clear();
}

bool MLobby::cli::TournStaticData::equals(const TournStaticData& _o) const
{
	return tournamentId == _o.tournamentId &&
		server.equals(_o.server) &&
		targetServer.equals(_o.targetServer) &&
		hasSatellite.equals(_o.hasSatellite) &&
		whenStart.equals(_o.whenStart) &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		fppBuyIn == _o.fppBuyIn &&
		isRestricted == _o.isRestricted &&
		isPwdProtected == _o.isPwdProtected &&
		name.equals(_o.name) &&
		admissionId.equals(_o.admissionId) &&
		isPlayMoney == _o.isPlayMoney &&
		satelliteTarget == _o.satelliteTarget &&
		minPlayers == _o.minPlayers &&
		tournFlags == _o.tournFlags &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		structure == _o.structure &&
		tournMask == _o.tournMask &&
		tournSites == _o.tournSites &&
		whenStartInt == _o.whenStartInt &&
		tournMask2 == _o.tournMask2 &&
		targetWhenStart.equals(_o.targetWhenStart) &&
		tournMask3 == _o.tournMask3 &&
		tournMask4 == _o.tournMask4 &&
		maxPerTable == _o.maxPerTable &&
		countryRestrictionInverted == _o.countryRestrictionInverted &&
		restrictedCountries.equals(_o.restrictedCountries) &&
		hasDayTwoStart == _o.hasDayTwoStart &&
		dayTwoStartSec == _o.dayTwoStartSec &&
		dayTwoStart.equals(_o.dayTwoStart) &&
		shortText.equals(_o.shortText) &&
		chatLang == _o.chatLang &&
		currency.equals(_o.currency) &&
		tournFlagsServInt == _o.tournFlagsServInt &&
		knockout == _o.knockout &&
		satelliteTargetReference.equals(_o.satelliteTargetReference) &&
		satelliteTargetReferenceLock == _o.satelliteTargetReferenceLock &&
		maxPlayers == _o.maxPlayers &&
		speedDisplay == _o.speedDisplay &&
		nameSnG.equals(_o.nameSnG) &&
		step == _o.step &&
		timedTournType == _o.timedTournType &&
		timedTournTime == _o.timedTournTime &&
		timedTournPayout == _o.timedTournPayout &&
		isFlightTourn == _o.isFlightTourn &&
		tournBrand.equals(_o.tournBrand) &&
		scalePM == _o.scalePM &&
		progressiveKnockout == _o.progressiveKnockout &&
		awardScheme == _o.awardScheme &&
		numReentries == _o.numReentries &&
		internalReference.equals(_o.internalReference) &&
		favReference.equals(_o.favReference) &&
		satelliteTargetName.equals(_o.satelliteTargetName) &&
		admissionPrice == _o.admissionPrice &&
		tournFlags2 == _o.tournFlags2 &&
		regEndAbs.equals(_o.regEndAbs) &&
		regEndAbsInt == _o.regEndAbsInt &&
		doNotAllowToUnreg == _o.doNotAllowToUnreg &&
		nStackInfo.equals(_o.nStackInfo) &&
		tournMask5 == _o.tournMask5 &&
		tournMask6 == _o.tournMask6 &&
		satelliteTargetNameMTT.equals(_o.satelliteTargetNameMTT) &&
		liveEventMask == _o.liveEventMask &&
		timedTournPlayersPercent == _o.timedTournPlayersPercent &&
		dummy1 == _o.dummy1 &&
		rmPmLobby == _o.rmPmLobby &&
		brandAccessMask == _o.brandAccessMask &&
		activeFlags == _o.activeFlags &&
		sngScriptId == _o.sngScriptId &&
		customSpeedDisplayName.equals(_o.customSpeedDisplayName) &&
		tournSitesEx.equals(_o.tournSitesEx);
}

const char *MLobby::cli::TournStaticData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournamentId=");
	_buf.appendUint(tournamentId);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("targetServer=");
	_buf.append(targetServer);
	_buf.append(',');
	_buf.append("hasSatellite=");
	_buf.append(hasSatellite);
	_buf.append(',');
	_buf.append("whenStart=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, whenStart);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendUint(buyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendUint(rake);
	_buf.append(',');
	_buf.append("fppBuyIn=");
	_buf.appendUint(fppBuyIn);
	_buf.append(',');
	_buf.append("isRestricted=");
	_buf.appendUint(isRestricted);
	_buf.append(',');
	_buf.append("isPwdProtected=");
	_buf.appendUint(isPwdProtected);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("admissionId=");
	_buf.append(admissionId);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("satelliteTarget=");
	_buf.appendUint(satelliteTarget);
	_buf.append(',');
	_buf.append("minPlayers=");
	_buf.appendUint(minPlayers);
	_buf.append(',');
	_buf.append("tournFlags=");
	_buf.appendUint(tournFlags);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("tournMask=");
	_buf.appendUint(tournMask);
	_buf.append(',');
	_buf.append("tournSites=");
	_buf.appendUint(tournSites);
	_buf.append(',');
	_buf.append("whenStartInt=");
	_buf.appendUint(whenStartInt);
	_buf.append(',');
	_buf.append("tournMask2=");
	_buf.appendUint(tournMask2);
	_buf.append(',');
	_buf.append("targetWhenStart=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, targetWhenStart);
	_buf.append(',');
	_buf.append("tournMask3=");
	_buf.appendUint(tournMask3);
	_buf.append(',');
	_buf.append("tournMask4=");
	_buf.appendUint(tournMask4);
	_buf.append(',');
	_buf.append("maxPerTable=");
	_buf.appendUint(maxPerTable);
	_buf.append(',');
	_buf.append("countryRestrictionInverted=");
	_buf.appendUint(countryRestrictionInverted);
	_buf.append(',');
	_buf.append("restrictedCountries=");
	restrictedCountries.toTraceString(_buf);
	_buf.append(',');
	_buf.append("hasDayTwoStart=");
	_buf.appendUint(hasDayTwoStart);
	_buf.append(',');
	_buf.append("dayTwoStartSec=");
	_buf.appendUint(dayTwoStartSec);
	_buf.append(',');
	_buf.append("dayTwoStart=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, dayTwoStart);
	_buf.append(',');
	_buf.append("shortText=");
	ThinAtf::AtfTempl<I18nPString>::ToTraceString(_buf, shortText);
	_buf.append(',');
	_buf.append("chatLang=");
	_buf.appendUint(chatLang);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("tournFlagsServInt=");
	_buf.appendUint(tournFlagsServInt);
	_buf.append(',');
	_buf.append("knockout=");
	_buf.appendUint(knockout);
	_buf.append(',');
	_buf.append("satelliteTargetReference=");
	_buf.append(satelliteTargetReference);
	_buf.append(',');
	_buf.append("satelliteTargetReferenceLock=");
	_buf.appendUint(satelliteTargetReferenceLock);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendUint(maxPlayers);
	_buf.append(',');
	_buf.append("speedDisplay=");
	_buf.appendUint(speedDisplay);
	_buf.append(',');
	_buf.append("nameSnG=");
	ThinAtf::AtfTempl<I18nPString>::ToTraceString(_buf, nameSnG);
	_buf.append(',');
	_buf.append("step=");
	_buf.appendUint(step);
	_buf.append(',');
	_buf.append("timedTournType=");
	_buf.appendUint(timedTournType);
	_buf.append(',');
	_buf.append("timedTournTime=");
	_buf.appendUint(timedTournTime);
	_buf.append(',');
	_buf.append("timedTournPayout=");
	_buf.appendUint(timedTournPayout);
	_buf.append(',');
	_buf.append("isFlightTourn=");
	_buf.appendUint(isFlightTourn);
	_buf.append(',');
	_buf.append("tournBrand=");
	_buf.append(tournBrand);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("progressiveKnockout=");
	_buf.appendUint(progressiveKnockout);
	_buf.append(',');
	_buf.append("awardScheme=");
	_buf.appendUint(awardScheme);
	_buf.append(',');
	_buf.append("numReentries=");
	_buf.appendUint(numReentries);
	_buf.append(',');
	_buf.append("internalReference=");
	_buf.append(internalReference);
	_buf.append(',');
	_buf.append("favReference=");
	_buf.append(favReference);
	_buf.append(',');
	_buf.append("satelliteTargetName=");
	_buf.append(satelliteTargetName);
	_buf.append(',');
	_buf.append("admissionPrice=");
	_buf.appendInt64(admissionPrice);
	_buf.append(',');
	_buf.append("tournFlags2=");
	_buf.appendUint64(tournFlags2);
	_buf.append(',');
	_buf.append("regEndAbs=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, regEndAbs);
	_buf.append(',');
	_buf.append("regEndAbsInt=");
	_buf.appendUint(regEndAbsInt);
	_buf.append(',');
	_buf.append("doNotAllowToUnreg=");
	_buf.appendUint(doNotAllowToUnreg);
	_buf.append(',');
	_buf.append("nStackInfo=");
	nStackInfo.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tournMask5=");
	_buf.appendUint(tournMask5);
	_buf.append(',');
	_buf.append("tournMask6=");
	_buf.appendUint(tournMask6);
	_buf.append(',');
	_buf.append("satelliteTargetNameMTT=");
	_buf.append(satelliteTargetNameMTT);
	_buf.append(',');
	_buf.append("liveEventMask=");
	_buf.appendUint(liveEventMask);
	_buf.append(',');
	_buf.append("timedTournPlayersPercent=");
	_buf.appendUint(timedTournPlayersPercent);
	_buf.append(',');
	_buf.append("dummy1=");
	_buf.appendUint(dummy1);
	_buf.append(',');
	_buf.append("rmPmLobby=");
	_buf.appendUint(rmPmLobby);
	_buf.append(',');
	_buf.append("brandAccessMask=");
	_buf.appendUint(brandAccessMask);
	_buf.append(',');
	_buf.append("activeFlags=");
	_buf.appendUint(activeFlags);
	_buf.append(',');
	_buf.append("sngScriptId=");
	_buf.appendUint(sngScriptId);
	_buf.append(',');
	_buf.append("customSpeedDisplayName=");
	_buf.append(customSpeedDisplayName);
	_buf.append(',');
	_buf.append("tournSitesEx=");
	tournSitesEx.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MLobby::cli::TournStaticData::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(TournStaticData())) // not empty
	{
		_body.composeUINT32(tournamentId);
		_body.composeString(server);
		_body.composeString(targetServer);
		_body.composeString(hasSatellite);
		_body.composeSrvTime(whenStart);
		_body.composeUINT32(buyIn);
		_body.composeUINT32(rake);
		_body.composeUINT32(fppBuyIn);
		_body.composeBYTE(isRestricted);
		_body.composeBYTE(isPwdProtected);
		_body.composeString(name);
		_body.composeString(admissionId);
		_body.composeBYTE(isPlayMoney);
		_body.composeUINT32(satelliteTarget);
		_body.composeUINT32(minPlayers);
		_body.composeUINT32(tournFlags);
		_body.composeBYTE(game);
		_body.composeBYTE(isHiLo);
		_body.composeBYTE(structure);
		_body.composeUINT32(tournMask);
		_body.composeUINT32(tournSites);
		_body.composeUINT32(whenStartInt);
		_body.composeUINT32(tournMask2);
		_body.composeSrvTime(targetWhenStart);
		_body.composeUINT32(tournMask3);
		_body.composeUINT32(tournMask4);
		_body.composeUINT32(maxPerTable);
		_body.composeBOOL(countryRestrictionInverted);
		restrictedCountries.composeMsg(_body);
		_body.composeBYTE(hasDayTwoStart);
		_body.composeUINT32(dayTwoStartSec);
		_body.composeSrvTime(dayTwoStart);
		shortText.compose(_body);
		_body.composeUINT16(chatLang);
		_body.composeString(currency);
		_body.composeUINT32(tournFlagsServInt);
		_body.composeUINT32(knockout);
		_body.composeString(satelliteTargetReference);
		_body.composeUINT16(satelliteTargetReferenceLock);
		_body.composeUINT32(maxPlayers);
		_body.composeBYTE(speedDisplay);
		nameSnG.compose(_body);
		_body.composeBYTE(step);
		_body.composeBYTE(timedTournType);
		_body.composeUINT16(timedTournTime);
		_body.composeBYTE(timedTournPayout);
		_body.composeBOOL(isFlightTourn);
		_body.composeString(tournBrand);
		_body.composeUINT32(scalePM);
		_body.composeBYTE(progressiveKnockout);
		_body.composeBYTE(awardScheme);
		_body.composeUINT16(numReentries);
		_body.composeString(internalReference);
		_body.composeString(favReference);
		_body.composeString(satelliteTargetName);
		_body.composeINT64(admissionPrice);
		_body.composeUINT64(tournFlags2);
		_body.composeSrvTime(regEndAbs);
		_body.composeUINT32(regEndAbsInt);
		_body.composeBOOL(doNotAllowToUnreg);
		nStackInfo.composeMsg(_body);
		_body.composeUINT32(tournMask5);
		_body.composeUINT32(tournMask6);
		_body.composeString(satelliteTargetNameMTT);
		_body.composeUINT32(liveEventMask);
		_body.composeBYTE(timedTournPlayersPercent);
		_body.composeUINT32(dummy1);
		_body.composeBYTE(rmPmLobby);
		_body.composeUINT32(brandAccessMask);
		_body.composeUINT32(activeFlags);
		_body.composeUINT32(sngScriptId);
		_body.composeString(customSpeedDisplayName);
		tournSitesEx.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::TournStaticData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(tournamentId);
	_parser0.parseStringP(server);
	_parser0.parseStringP(targetServer);
	_parser0.parseStringP(hasSatellite);
	_parser0.parseSrvTime(whenStart);
	_parser0.parseUINT32(buyIn);
	_parser0.parseUINT32(rake);
	_parser0.parseUINT32(fppBuyIn);
	_parser0.parseBYTE(isRestricted);
	_parser0.parseBYTE(isPwdProtected);
	_parser0.parseStringP(name);
	_parser0.parseStringP(admissionId);
	_parser0.parseBYTE(isPlayMoney);
	_parser0.parseUINT32(satelliteTarget);
	_parser0.parseUINT32(minPlayers);
	_parser0.parseUINT32(tournFlags);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(isHiLo);
	_parser0.parseBYTE(structure);
	_parser0.parseUINT32(tournMask);
	_parser0.parseUINT32(tournSites);
	_parser0.parseUINT32(whenStartInt);
	_parser0.parseUINT32(tournMask2);
	_parser0.parseSrvTime(targetWhenStart);
	_parser0.parseUINT32(tournMask3);
	_parser0.parseUINT32(tournMask4);
	_parser0.parseUINT32(maxPerTable);
	_parser0.parseBOOL(countryRestrictionInverted);
	restrictedCountries.parseMsg(_parser0);
	_parser0.parseBYTE(hasDayTwoStart);
	_parser0.parseUINT32(dayTwoStartSec);
	_parser0.parseSrvTime(dayTwoStart);
	shortText.parse(_parser0);
	_parser0.parseUINT16(chatLang);
	_parser0.parseStringP(currency);
	_parser0.parseUINT32(tournFlagsServInt);
	_parser0.parseUINT32(knockout);
	_parser0.parseStringP(satelliteTargetReference);
	_parser0.parseUINT16(satelliteTargetReferenceLock);
	_parser0.parseUINT32(maxPlayers);
	_parser0.parseBYTE(speedDisplay);
	nameSnG.parse(_parser0);
	_parser0.parseBYTE(step);
	_parser0.parseBYTE(timedTournType);
	_parser0.parseUINT16(timedTournTime);
	_parser0.parseBYTE(timedTournPayout);
	_parser0.parseBOOL(isFlightTourn);
	_parser0.parseStringP(tournBrand);
	_parser0.parseUINT32(scalePM);
	_parser0.parseBYTE(progressiveKnockout);
	_parser0.parseBYTE(awardScheme);
	_parser0.parseUINT16(numReentries);
	_parser0.parseStringP(internalReference);
	_parser0.parseStringP(favReference);
	_parser0.parseStringP(satelliteTargetName);
	_parser0.parseINT64(admissionPrice);
	_parser0.parseUINT64(tournFlags2);
	_parser0.parseSrvTime(regEndAbs);
	_parser0.parseUINT32(regEndAbsInt);
	_parser0.parseBOOL(doNotAllowToUnreg);
	nStackInfo.parseMsg(_parser0);
	_parser0.parseUINT32(tournMask5);
	_parser0.parseUINT32(tournMask6);
	_parser0.parseStringP(satelliteTargetNameMTT);
	_parser0.parseUINT32(liveEventMask);
	_parser0.parseBYTE(timedTournPlayersPercent);
	_parser0.parseUINT32(dummy1);
	_parser0.parseBYTE(rmPmLobby);
	_parser0.parseUINT32(brandAccessMask);
	_parser0.parseUINT32(activeFlags);
	_parser0.parseUINT32(sngScriptId);
	_parser0.parseStringP(customSpeedDisplayName);
	if(_parser0.parseEnded()) return;
	tournSitesEx.parseMsg(_parser0);
}

/*static*/ void MLobby::cli::TournStaticData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 tournamentId; _parser0.parseUINT32(tournamentId);
	AtfValidator::validateInt(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "targetServer"); size_t szTargetServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "targetServer", szTargetServer, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "hasSatellite"); size_t szHasSatellite = strlen(_dummy);
	AtfValidator::validateInt(_descr, "hasSatellite", szHasSatellite, _checker, __FILE__, __LINE__);
	SrvTime whenStart; _parser0.parseSrvTime(whenStart);
	AtfValidator::validateSrvDateTime(_descr, "whenStart", whenStart, _checker, __FILE__, __LINE__);
	UINT32 buyIn; _parser0.parseUINT32(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT32 rake; _parser0.parseUINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	UINT32 fppBuyIn; _parser0.parseUINT32(fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	BYTE isRestricted; _parser0.parseBYTE(isRestricted);
	AtfValidator::validateInt(_descr, "isRestricted", isRestricted, _checker, __FILE__, __LINE__);
	BYTE isPwdProtected; _parser0.parseBYTE(isPwdProtected);
	AtfValidator::validateInt(_descr, "isPwdProtected", isPwdProtected, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "admissionId"); size_t szAdmissionId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "admissionId", szAdmissionId, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser0.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 satelliteTarget; _parser0.parseUINT32(satelliteTarget);
	AtfValidator::validateInt(_descr, "satelliteTarget", satelliteTarget, _checker, __FILE__, __LINE__);
	UINT32 minPlayers; _parser0.parseUINT32(minPlayers);
	AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
	UINT32 tournFlags; _parser0.parseUINT32(tournFlags);
	AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser0.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	UINT32 tournMask; _parser0.parseUINT32(tournMask);
	AtfValidator::validateInt(_descr, "tournMask", tournMask, _checker, __FILE__, __LINE__);
	UINT32 tournSites; _parser0.parseUINT32(tournSites);
	AtfValidator::validateInt(_descr, "tournSites", tournSites, _checker, __FILE__, __LINE__);
	UINT32 whenStartInt; _parser0.parseUINT32(whenStartInt);
	AtfValidator::validateInt(_descr, "whenStartInt", whenStartInt, _checker, __FILE__, __LINE__);
	UINT32 tournMask2; _parser0.parseUINT32(tournMask2);
	AtfValidator::validateInt(_descr, "tournMask2", tournMask2, _checker, __FILE__, __LINE__);
	SrvTime targetWhenStart; _parser0.parseSrvTime(targetWhenStart);
	AtfValidator::validateSrvDateTime(_descr, "targetWhenStart", targetWhenStart, _checker, __FILE__, __LINE__);
	UINT32 tournMask3; _parser0.parseUINT32(tournMask3);
	AtfValidator::validateInt(_descr, "tournMask3", tournMask3, _checker, __FILE__, __LINE__);
	UINT32 tournMask4; _parser0.parseUINT32(tournMask4);
	AtfValidator::validateInt(_descr, "tournMask4", tournMask4, _checker, __FILE__, __LINE__);
	UINT32 maxPerTable; _parser0.parseUINT32(maxPerTable);
	AtfValidator::validateInt(_descr, "maxPerTable", maxPerTable, _checker, __FILE__, __LINE__);
	bool countryRestrictionInverted; _parser0.parseBOOL(countryRestrictionInverted);
	AtfValidator::validateInt(_descr, "countryRestrictionInverted", countryRestrictionInverted, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szRestrictedCountries = ThinAtf::LAtfVector< PString , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("restrictedCountries"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "restrictedCountries", szRestrictedCountries, _checker, __FILE__, __LINE__);
	BYTE hasDayTwoStart; _parser0.parseBYTE(hasDayTwoStart);
	AtfValidator::validateInt(_descr, "hasDayTwoStart", hasDayTwoStart, _checker, __FILE__, __LINE__);
	UINT32 dayTwoStartSec; _parser0.parseUINT32(dayTwoStartSec);
	AtfValidator::validateInt(_descr, "dayTwoStartSec", dayTwoStartSec, _checker, __FILE__, __LINE__);
	SrvTime dayTwoStart; _parser0.parseSrvTime(dayTwoStart);
	AtfValidator::validateSrvDateTime(_descr, "dayTwoStart", dayTwoStart, _checker, __FILE__, __LINE__);
	I18nPString shortText; shortText.parse(_parser0);
	UINT16 chatLang; _parser0.parseUINT16(chatLang);
	AtfValidator::validateInt(_descr, "chatLang", chatLang, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 tournFlagsServInt; _parser0.parseUINT32(tournFlagsServInt);
	AtfValidator::validateInt(_descr, "tournFlagsServInt", tournFlagsServInt, _checker, __FILE__, __LINE__);
	UINT32 knockout; _parser0.parseUINT32(knockout);
	AtfValidator::validateInt(_descr, "knockout", knockout, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "satelliteTargetReference"); size_t szSatelliteTargetReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "satelliteTargetReference", szSatelliteTargetReference, _checker, __FILE__, __LINE__);
	UINT16 satelliteTargetReferenceLock; _parser0.parseUINT16(satelliteTargetReferenceLock);
	AtfValidator::validateInt(_descr, "satelliteTargetReferenceLock", satelliteTargetReferenceLock, _checker, __FILE__, __LINE__);
	UINT32 maxPlayers; _parser0.parseUINT32(maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	BYTE speedDisplay; _parser0.parseBYTE(speedDisplay);
	AtfValidator::validateInt(_descr, "speedDisplay", speedDisplay, _checker, __FILE__, __LINE__);
	I18nPString nameSnG; nameSnG.parse(_parser0);
	BYTE step; _parser0.parseBYTE(step);
	AtfValidator::validateInt(_descr, "step", step, _checker, __FILE__, __LINE__);
	BYTE timedTournType; _parser0.parseBYTE(timedTournType);
	AtfValidator::validateInt(_descr, "timedTournType", timedTournType, _checker, __FILE__, __LINE__);
	UINT16 timedTournTime; _parser0.parseUINT16(timedTournTime);
	AtfValidator::validateInt(_descr, "timedTournTime", timedTournTime, _checker, __FILE__, __LINE__);
	BYTE timedTournPayout; _parser0.parseBYTE(timedTournPayout);
	AtfValidator::validateInt(_descr, "timedTournPayout", timedTournPayout, _checker, __FILE__, __LINE__);
	bool isFlightTourn; _parser0.parseBOOL(isFlightTourn);
	AtfValidator::validateInt(_descr, "isFlightTourn", isFlightTourn, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "tournBrand"); size_t szTournBrand = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tournBrand", szTournBrand, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser0.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	BYTE progressiveKnockout; _parser0.parseBYTE(progressiveKnockout);
	AtfValidator::validateInt(_descr, "progressiveKnockout", progressiveKnockout, _checker, __FILE__, __LINE__);
	BYTE awardScheme; _parser0.parseBYTE(awardScheme);
	AtfValidator::validateInt(_descr, "awardScheme", awardScheme, _checker, __FILE__, __LINE__);
	UINT16 numReentries; _parser0.parseUINT16(numReentries);
	AtfValidator::validateInt(_descr, "numReentries", numReentries, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "internalReference"); size_t szInternalReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "internalReference", szInternalReference, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "favReference"); size_t szFavReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "favReference", szFavReference, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "satelliteTargetName"); size_t szSatelliteTargetName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "satelliteTargetName", szSatelliteTargetName, _checker, __FILE__, __LINE__);
	INT64 admissionPrice; _parser0.parseINT64(admissionPrice);
	AtfValidator::validateInt(_descr, "admissionPrice", admissionPrice, _checker, __FILE__, __LINE__);
	UINT64 tournFlags2; _parser0.parseUINT64(tournFlags2);
	AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	SrvTime regEndAbs; _parser0.parseSrvTime(regEndAbs);
	AtfValidator::validateSrvDateTime(_descr, "regEndAbs", regEndAbs, _checker, __FILE__, __LINE__);
	UINT32 regEndAbsInt; _parser0.parseUINT32(regEndAbsInt);
	AtfValidator::validateInt(_descr, "regEndAbsInt", regEndAbsInt, _checker, __FILE__, __LINE__);
	bool doNotAllowToUnreg; _parser0.parseBOOL(doNotAllowToUnreg);
	AtfValidator::validateInt(_descr, "doNotAllowToUnreg", doNotAllowToUnreg, _checker, __FILE__, __LINE__);
	TournClientThin::NStackTournInfoStruct::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("nStackInfo"), _fieldsWithUnparsedContent);
	UINT32 tournMask5; _parser0.parseUINT32(tournMask5);
	AtfValidator::validateInt(_descr, "tournMask5", tournMask5, _checker, __FILE__, __LINE__);
	UINT32 tournMask6; _parser0.parseUINT32(tournMask6);
	AtfValidator::validateInt(_descr, "tournMask6", tournMask6, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "satelliteTargetNameMTT"); size_t szSatelliteTargetNameMTT = strlen(_dummy);
	AtfValidator::validateInt(_descr, "satelliteTargetNameMTT", szSatelliteTargetNameMTT, _checker, __FILE__, __LINE__);
	UINT32 liveEventMask; _parser0.parseUINT32(liveEventMask);
	AtfValidator::validateInt(_descr, "liveEventMask", liveEventMask, _checker, __FILE__, __LINE__);
	BYTE timedTournPlayersPercent; _parser0.parseBYTE(timedTournPlayersPercent);
	AtfValidator::validateInt(_descr, "timedTournPlayersPercent", timedTournPlayersPercent, _checker, __FILE__, __LINE__);
	UINT32 dummy1; _parser0.parseUINT32(dummy1);
	AtfValidator::validateInt(_descr, "dummy1", dummy1, _checker, __FILE__, __LINE__);
	BYTE rmPmLobby; _parser0.parseBYTE(rmPmLobby);
	AtfValidator::validateInt(_descr, "rmPmLobby", rmPmLobby, _checker, __FILE__, __LINE__);
	UINT32 brandAccessMask; _parser0.parseUINT32(brandAccessMask);
	AtfValidator::validateInt(_descr, "brandAccessMask", brandAccessMask, _checker, __FILE__, __LINE__);
	UINT32 activeFlags; _parser0.parseUINT32(activeFlags);
	AtfValidator::validateInt(_descr, "activeFlags", activeFlags, _checker, __FILE__, __LINE__);
	UINT32 sngScriptId; _parser0.parseUINT32(sngScriptId);
	AtfValidator::validateInt(_descr, "sngScriptId", sngScriptId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "customSpeedDisplayName"); size_t szCustomSpeedDisplayName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "customSpeedDisplayName", szCustomSpeedDisplayName, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tournSitesEx"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TournDynaData
//=================================================================

MLobby::cli::TournDynaData::TournDynaData()
{
	clear();
}

void MLobby::cli::TournDynaData::clear()
{
	fakeStatus = 0;
	entrants = 0;
	publProp = 0;
	prizePoolToPublish = 0;
	prizePoolUnit = 0;
	happyHoursMultipliers.clear();
	goldenSnGMilestoneAwardStub = 0;
	dummy1 = 0;
	goldenSnGEligibleStub = false;
	goldenSnGTotalAddonStub = 0;
	prizePoolMoneyToPublish = 0;
	timedTournPlayersThreshold = 0;
	mixTournSatellite = 0;
}

bool MLobby::cli::TournDynaData::equals(const TournDynaData& _o) const
{
	return fakeStatus == _o.fakeStatus &&
		entrants == _o.entrants &&
		publProp == _o.publProp &&
		prizePoolToPublish == _o.prizePoolToPublish &&
		prizePoolUnit == _o.prizePoolUnit &&
		happyHoursMultipliers.equals(_o.happyHoursMultipliers) &&
		goldenSnGMilestoneAwardStub == _o.goldenSnGMilestoneAwardStub &&
		dummy1 == _o.dummy1 &&
		goldenSnGEligibleStub == _o.goldenSnGEligibleStub &&
		goldenSnGTotalAddonStub == _o.goldenSnGTotalAddonStub &&
		prizePoolMoneyToPublish == _o.prizePoolMoneyToPublish &&
		timedTournPlayersThreshold == _o.timedTournPlayersThreshold &&
		mixTournSatellite == _o.mixTournSatellite;
}

const char *MLobby::cli::TournDynaData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("fakeStatus=");
	_buf.appendUint(fakeStatus);
	_buf.append(',');
	_buf.append("entrants=");
	_buf.appendUint(entrants);
	_buf.append(',');
	_buf.append("publProp=");
	_buf.appendUint(publProp);
	_buf.append(',');
	_buf.append("prizePoolToPublish=");
	_buf.appendUint(prizePoolToPublish);
	_buf.append(',');
	_buf.append("prizePoolUnit=");
	_buf.appendUint(prizePoolUnit);
	_buf.append(',');
	_buf.append("happyHoursMultipliers=");
	happyHoursMultipliers.toTraceString(_buf);
	_buf.append(',');
	_buf.append("goldenSnGMilestoneAwardStub=");
	_buf.appendUint(goldenSnGMilestoneAwardStub);
	_buf.append(',');
	_buf.append("dummy1=");
	_buf.appendUint(dummy1);
	_buf.append(',');
	_buf.append("goldenSnGEligibleStub=");
	_buf.appendUint(goldenSnGEligibleStub);
	_buf.append(',');
	_buf.append("goldenSnGTotalAddonStub=");
	_buf.appendUint(goldenSnGTotalAddonStub);
	_buf.append(',');
	_buf.append("prizePoolMoneyToPublish=");
	_buf.appendUint(prizePoolMoneyToPublish);
	_buf.append(',');
	_buf.append("timedTournPlayersThreshold=");
	_buf.appendUint(timedTournPlayersThreshold);
	_buf.append(',');
	_buf.append("mixTournSatellite=");
	_buf.appendInt(mixTournSatellite);
	_buf.append('}');
	return _buf.c_str();
}

void MLobby::cli::TournDynaData::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(TournDynaData())) // not empty
	{
		_body.composeUINT32(fakeStatus);
		_body.composeUINT32(entrants);
		_body.composeBYTE(publProp);
		_body.composeUINT32(prizePoolToPublish);
		_body.composeBYTE(prizePoolUnit);
		happyHoursMultipliers.composeMsg(_body);
		_body.composeUINT32(goldenSnGMilestoneAwardStub);
		_body.composeUINT32(dummy1);
		_body.composeBOOL(goldenSnGEligibleStub);
		_body.composeUINT32(goldenSnGTotalAddonStub);
		_body.composeUINT32(prizePoolMoneyToPublish);
		_body.composeUINT32(timedTournPlayersThreshold);
		_body.composeINT8(mixTournSatellite);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::TournDynaData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(fakeStatus);
	_parser0.parseUINT32(entrants);
	_parser0.parseBYTE(publProp);
	_parser0.parseUINT32(prizePoolToPublish);
	_parser0.parseBYTE(prizePoolUnit);
	happyHoursMultipliers.parseMsg(_parser0);
	_parser0.parseUINT32(goldenSnGMilestoneAwardStub);
	_parser0.parseUINT32(dummy1);
	_parser0.parseBOOL(goldenSnGEligibleStub);
	_parser0.parseUINT32(goldenSnGTotalAddonStub);
	_parser0.parseUINT32(prizePoolMoneyToPublish);
	_parser0.parseUINT32(timedTournPlayersThreshold);
	_parser0.parseINT8(mixTournSatellite);
}

/*static*/ void MLobby::cli::TournDynaData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 fakeStatus; _parser0.parseUINT32(fakeStatus);
	AtfValidator::validateInt(_descr, "fakeStatus", fakeStatus, _checker, __FILE__, __LINE__);
	UINT32 entrants; _parser0.parseUINT32(entrants);
	AtfValidator::validateInt(_descr, "entrants", entrants, _checker, __FILE__, __LINE__);
	BYTE publProp; _parser0.parseBYTE(publProp);
	AtfValidator::validateInt(_descr, "publProp", publProp, _checker, __FILE__, __LINE__);
	UINT32 prizePoolToPublish; _parser0.parseUINT32(prizePoolToPublish);
	AtfValidator::validateInt(_descr, "prizePoolToPublish", prizePoolToPublish, _checker, __FILE__, __LINE__);
	BYTE prizePoolUnit; _parser0.parseBYTE(prizePoolUnit);
	AtfValidator::validateInt(_descr, "prizePoolUnit", prizePoolUnit, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szHappyHoursMultipliers = ThinAtf::LAtfVector< FppFactorStruct, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("happyHoursMultipliers"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "happyHoursMultipliers", szHappyHoursMultipliers, _checker, __FILE__, __LINE__);
	UINT32 goldenSnGMilestoneAwardStub; _parser0.parseUINT32(goldenSnGMilestoneAwardStub);
	AtfValidator::validateInt(_descr, "goldenSnGMilestoneAwardStub", goldenSnGMilestoneAwardStub, _checker, __FILE__, __LINE__);
	UINT32 dummy1; _parser0.parseUINT32(dummy1);
	AtfValidator::validateInt(_descr, "dummy1", dummy1, _checker, __FILE__, __LINE__);
	bool goldenSnGEligibleStub; _parser0.parseBOOL(goldenSnGEligibleStub);
	AtfValidator::validateInt(_descr, "goldenSnGEligibleStub", goldenSnGEligibleStub, _checker, __FILE__, __LINE__);
	UINT32 goldenSnGTotalAddonStub; _parser0.parseUINT32(goldenSnGTotalAddonStub);
	AtfValidator::validateInt(_descr, "goldenSnGTotalAddonStub", goldenSnGTotalAddonStub, _checker, __FILE__, __LINE__);
	UINT32 prizePoolMoneyToPublish; _parser0.parseUINT32(prizePoolMoneyToPublish);
	AtfValidator::validateInt(_descr, "prizePoolMoneyToPublish", prizePoolMoneyToPublish, _checker, __FILE__, __LINE__);
	UINT32 timedTournPlayersThreshold; _parser0.parseUINT32(timedTournPlayersThreshold);
	AtfValidator::validateInt(_descr, "timedTournPlayersThreshold", timedTournPlayersThreshold, _checker, __FILE__, __LINE__);
	INT8 mixTournSatellite; _parser0.parseINT8(mixTournSatellite);
	AtfValidator::validateInt(_descr, "mixTournSatellite", mixTournSatellite, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TournDataStruct
//=================================================================

MLobby::cli::TournDataStruct::TournDataStruct()
{
	clear();
}

void MLobby::cli::TournDataStruct::clear()
{
	staticData.clear();
	dynamicData.clear();
}

bool MLobby::cli::TournDataStruct::equals(const TournDataStruct& _o) const
{
	return staticData.equals(_o.staticData) &&
		dynamicData.equals(_o.dynamicData);
}

const char *MLobby::cli::TournDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("staticData=");
	staticData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("dynamicData=");
	dynamicData.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MLobby::cli::TournDataStruct::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(TournDataStruct())) // not empty
	{
		staticData.composeMsg(_body);
		dynamicData.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::TournDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	staticData.parseMsg(_parser0);
	dynamicData.parseMsg(_parser0);
}

/*static*/ void MLobby::cli::TournDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	TournStaticData::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("staticData"), _fieldsWithUnparsedContent);
	TournDynaData::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("dynamicData"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2
//=================================================================

MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2::clear()
{
	filter.clear();
	maxItems = 0;
	context = 0;
	installId.clear();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2::equals(const Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2& _o) const
{
	return filter.equals(_o.filter) &&
		maxItems == _o.maxItems &&
		context == _o.context &&
		installId.equals(_o.installId);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_TOURNAMENTS2).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("maxItems=");
	_buf.appendUint(maxItems);
	_buf.append(',');
	_buf.append("context=");
	_buf.appendUint(context);
	_buf.append(',');
	_buf.append("installId=");
	_buf.append(installId);
	return _buf.c_str();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2::composeMsg(CommMsgBody& _msg) const
{
	filter.composeMsg(_msg);
	_msg.composeUINT32(maxItems);
	_msg.composeUINT32(context);
	_msg.composeString(installId);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	_parser.parseUINT32(maxItems);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(context);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(installId);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_TOURNAMENTS2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	PString _descbuf;
	TournSelectionFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	UINT32 maxItems; _parser.parseUINT32(maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 context; _parser.parseUINT32(context);
	AtfValidator::validateInt(_descr, "context", context, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "installId"); size_t szInstallId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "installId", szInstallId, 128, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY
//=================================================================

MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY::clear()
{
	totalItems = 0;
	tourns.clear();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY::equals(const Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY& _o) const
{
	return totalItems == _o.totalItems &&
		tourns.equals(_o.tourns);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY).append(")");
	_buf.append(',');
	_buf.append("totalItems=");
	_buf.appendUint(totalItems);
	_buf.append(',');
	_buf.append("tourns=");
	tourns.toTraceString(_buf);
	return _buf.c_str();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(totalItems);
	tourns.composeMsg(_msg);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(totalItems);
	tourns.parseMsg(_parser);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 totalItems; _parser.parseUINT32(totalItems);
	AtfValidator::validateInt(_descr, "totalItems", totalItems, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTourns = ThinAtf::LAtfVector< TournDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2
//=================================================================

MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2::clear()
{
	filter.clear();
	maxItems = 0;
	excludedFinders.clear();
	context = 0;
	installId.clear();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2::equals(const Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2& _o) const
{
	return filter.equals(_o.filter) &&
		maxItems == _o.maxItems &&
		excludedFinders.equals(_o.excludedFinders) &&
		context == _o.context &&
		installId.equals(_o.installId);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("maxItems=");
	_buf.appendUint(maxItems);
	_buf.append(',');
	_buf.append("excludedFinders=");
	excludedFinders.toTraceString(_buf);
	_buf.append(',');
	_buf.append("context=");
	_buf.appendUint(context);
	_buf.append(',');
	_buf.append("installId=");
	_buf.append(installId);
	return _buf.c_str();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2::composeMsg(CommMsgBody& _msg) const
{
	filter.composeMsg(_msg);
	_msg.composeUINT32(maxItems);
	excludedFinders.composeMsg(_msg);
	_msg.composeUINT32(context);
	_msg.composeString(installId);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	_parser.parseUINT32(maxItems);
	excludedFinders.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(context);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(installId);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	PString _descbuf;
	FinderAndBlitzSelectionFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	UINT32 maxItems; _parser.parseUINT32(maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
	int szExcludedFinders = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("excludedFinders"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "excludedFinders", szExcludedFinders, 1024, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 context; _parser.parseUINT32(context);
	AtfValidator::validateInt(_descr, "context", context, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "installId"); size_t szInstallId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "installId", szInstallId, 128, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY
//=================================================================

// @Override
bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY::equals(const Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY& _o) const
{ 
	return false; 
}

// @Override
const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY).append(")");
	_buf.append(',');
	_buf.append("sortedSeatFindersAndBlitzes= NOT IMPLEMENTED!!!!");
	return _buf.c_str();
}

// @Override
const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("NOT IMPLEMENTED!!!!");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

// @Override
bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY::loadFromXmlString(const PString& _xmlString)
{
	return false;
}

// @Override
const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY::asJSONString(PString& _buf) const
{
	return"";
}

// @Override
void MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY::loadFromJSONString(const PString& _jsonString)
{
}

// @Override
void MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
}

// @Override
void MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{}

MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY::clear()
{
	sortedSeatFindersAndBlitzes.clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY::composeMsg(CommMsgBody& _msg) const
{
	sortedSeatFindersAndBlitzes.composeMsg(_msg);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY::parseMsg(CommMsgParser& _parser)
{
	sortedSeatFindersAndBlitzes.parseMsg(_parser);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_TABLE64_2
//=================================================================

MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2::Protocol_MSG_MLOBBY_FIND_TABLE64_2()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2::clear()
{
	filter.clear();
	maxItems = 0;
	excludedTables.clear();
	context = 0;
	installId.clear();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2::equals(const Protocol_MSG_MLOBBY_FIND_TABLE64_2& _o) const
{
	return filter.equals(_o.filter) &&
		maxItems == _o.maxItems &&
		excludedTables.equals(_o.excludedTables) &&
		context == _o.context &&
		installId.equals(_o.installId);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_TABLE64_2).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("maxItems=");
	_buf.appendUint(maxItems);
	_buf.append(',');
	_buf.append("excludedTables=");
	excludedTables.toTraceString(_buf);
	_buf.append(',');
	_buf.append("context=");
	_buf.appendUint(context);
	_buf.append(',');
	_buf.append("installId=");
	_buf.append(installId);
	return _buf.c_str();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2::composeMsg(CommMsgBody& _msg) const
{
	filter.composeMsg(_msg);
	_msg.composeUINT32(maxItems);
	excludedTables.composeMsg(_msg);
	_msg.composeUINT32(context);
	_msg.composeString(installId);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	_parser.parseUINT32(maxItems);
	if(_parser.parseEnded()) return;
	excludedTables.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(context);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(installId);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_TABLE64_2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	PString _descbuf;
	TableSelectionFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	UINT32 maxItems; _parser.parseUINT32(maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	int szExcludedTables = ThinAtf::LAtfVector< UINT64, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("excludedTables"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "excludedTables", szExcludedTables, 1024, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 context; _parser.parseUINT32(context);
	AtfValidator::validateInt(_descr, "context", context, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "installId"); size_t szInstallId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "installId", szInstallId, 128, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_TABLE64_2_REPLY
//=================================================================

MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2_REPLY::Protocol_MSG_MLOBBY_FIND_TABLE64_2_REPLY()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2_REPLY::clear()
{
	totalItems = 0;
	tables.clear();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2_REPLY::equals(const Protocol_MSG_MLOBBY_FIND_TABLE64_2_REPLY& _o) const
{
	return totalItems == _o.totalItems &&
		tables.equals(_o.tables);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_TABLE64_2_REPLY).append(")");
	_buf.append(',');
	_buf.append("totalItems=");
	_buf.appendUint(totalItems);
	_buf.append(',');
	_buf.append("tables=");
	tables.toTraceString(_buf);
	return _buf.c_str();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(totalItems);
	tables.composeMsg(_msg);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(totalItems);
	tables.parseMsg(_parser);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_TABLE64_2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 totalItems; _parser.parseUINT32(totalItems);
	AtfValidator::validateInt(_descr, "totalItems", totalItems, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTables = ThinAtf::LAtfVector< RingDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tables"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tables", szTables, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    Game
//=================================================================

MLobby::cli::Game::Game()
{
	clear();
}

void MLobby::cli::Game::clear()
{
	handType = 0;
	structure = 0;
	hiLo = 0;
}

bool MLobby::cli::Game::equals(const Game& _o) const
{
	return handType == _o.handType &&
		structure == _o.structure &&
		hiLo == _o.hiLo;
}

const char *MLobby::cli::Game::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("handType=");
	_buf.appendUint(handType);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("hiLo=");
	_buf.appendUint(hiLo);
	_buf.append('}');
	return _buf.c_str();
}

void MLobby::cli::Game::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(Game())) // not empty
	{
		_body.composeBYTE(handType);
		_body.composeBYTE(structure);
		_body.composeBYTE(hiLo);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::Game::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(handType);
	_parser0.parseBYTE(structure);
	_parser0.parseBYTE(hiLo);
}

/*static*/ void MLobby::cli::Game::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	BYTE handType; _parser0.parseBYTE(handType);
	AtfValidator::validateIntRange(_descr, "handType", handType, HandTypeNone, HandType_Last, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateIntRange(_descr, "structure", structure, StructNonDefined, PotStruct_Last, _checker, __FILE__, __LINE__);
	BYTE hiLo; _parser0.parseBYTE(hiLo);
	AtfValidator::validateIntMax(_descr, "hiLo", hiLo, 1, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    MorphLobbySelectionFilter
//=================================================================

MLobby::cli::MorphLobbySelectionFilter::MorphLobbySelectionFilter()
{
	clear();
}

void MLobby::cli::MorphLobbySelectionFilter::clear()
{
	version = 0;
	country.clear();
	siteId = 0;
	brandId = 0;
	game = 0;
	hiLo = 0;
	limit = 0;
	currencyMask = 0;
	isPM = false;
	games.clear();
	showStealthTables = true;
}

bool MLobby::cli::MorphLobbySelectionFilter::equals(const MorphLobbySelectionFilter& _o) const
{
	return version == _o.version &&
		country.equals(_o.country) &&
		siteId == _o.siteId &&
		brandId == _o.brandId &&
		game == _o.game &&
		hiLo == _o.hiLo &&
		limit == _o.limit &&
		currencyMask == _o.currencyMask &&
		isPM == _o.isPM &&
		games.equals(_o.games) &&
		showStealthTables == _o.showStealthTables;
}

const char *MLobby::cli::MorphLobbySelectionFilter::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("version=");
	_buf.appendUint(version);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("brandId=");
	_buf.appendUint(brandId);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("hiLo=");
	_buf.appendUint(hiLo);
	_buf.append(',');
	_buf.append("limit=");
	_buf.appendUint(limit);
	_buf.append(',');
	_buf.append("currencyMask=");
	_buf.appendUint(currencyMask);
	_buf.append(',');
	_buf.append("isPM=");
	_buf.appendUint(isPM);
	_buf.append(',');
	_buf.append("games=");
	games.toTraceString(_buf);
	_buf.append(',');
	_buf.append("showStealthTables=");
	_buf.appendUint(showStealthTables);
	_buf.append('}');
	return _buf.c_str();
}

void MLobby::cli::MorphLobbySelectionFilter::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(MorphLobbySelectionFilter())) // not empty
	{
		_body.composeBYTE(version);
		_body.composeString(country);
		_body.composeUINT32(siteId);
		_body.composeUINT32(brandId);
		_body.composeBYTE(game);
		_body.composeBYTE(hiLo);
		_body.composeBYTE(limit);
		_body.composeUINT32(currencyMask);
		_body.composeBOOL(isPM);
		games.composeMsg(_body);
		_body.composeBOOL(showStealthTables);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::MorphLobbySelectionFilter::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(version);
	_parser0.parseStringP(country);
	_parser0.parseUINT32(siteId);
	_parser0.parseUINT32(brandId);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(hiLo);
	_parser0.parseBYTE(limit);
	_parser0.parseUINT32(currencyMask);
	_parser0.parseBOOL(isPM);
	if(_parser0.parseEnded()) return;
	games.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	_parser0.parseBOOL(showStealthTables);
}

/*static*/ void MLobby::cli::MorphLobbySelectionFilter::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	BYTE version; _parser0.parseBYTE(version);
	AtfValidator::validateInt(_descr, "version", version, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, 3, _checker, __FILE__, __LINE__);
	UINT32 siteId; _parser0.parseUINT32(siteId);
	AtfValidator::validateIntRange(_descr, "siteId", siteId, PokerStars_SiteUnknown, (2*PokerStars_Last-1), _checker, __FILE__, __LINE__);
	UINT32 brandId; _parser0.parseUINT32(brandId);
	AtfValidator::validateIntRange(_descr, "brandId", brandId, BrandType_None, (2*BrandType_Last-1), _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateIntRange(_descr, "game", game, HandTypeNone, HandType_Last, _checker, __FILE__, __LINE__);
	BYTE hiLo; _parser0.parseBYTE(hiLo);
	AtfValidator::validateIntMax(_descr, "hiLo", hiLo, 1, _checker, __FILE__, __LINE__);
	BYTE limit; _parser0.parseBYTE(limit);
	AtfValidator::validateIntRange(_descr, "limit", limit, StructNonDefined, PotStruct_Last, _checker, __FILE__, __LINE__);
	UINT32 currencyMask; _parser0.parseUINT32(currencyMask);
	AtfValidator::validateIntMax(_descr, "currencyMask", currencyMask, (2*MobileCurrency_Last-1), _checker, __FILE__, __LINE__);
	bool isPM; _parser0.parseBOOL(isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PString _descbuf;
	int szGames = ThinAtf::LAtfVector< Game, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("games"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "games", szGames, 128, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	bool showStealthTables; _parser0.parseBOOL(showStealthTables);
	AtfValidator::validateInt(_descr, "showStealthTables", showStealthTables, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SeatFinderStruct
//=================================================================

MLobby::cli::SeatFinderStruct::SeatFinderStruct()
{
	clear();
}

void MLobby::cli::SeatFinderStruct::clear()
{
	id = 0;
	game = 0;
	structure = 0;
	isHiLo = 0;
	maxPlayersPerTable = 0;
	loBet = 0;
	hiBet = 0;
	ante = 0;
	cap = 0;
	currency.clear();
	minChipsLimit = 0;
	maxBuyIn = 0;
	visibilityMask = 0;
	defaultBuyIn = 0;
	specialName.clear();
	countryRestrictionInverted = false;
	restrictedCountries.clear();
	replayerAddress.clear();
	replayerInstance.clear();
	minPlayersPerTable = 0;
	isPasswordProtected = false;
	poolBlockMinHands = 0;
	poolBlockTimePenalty.clear();
	flags = 0;
	flags2 = 0;
	isPM = false;
	scalePM = 0;
	handsPerHour = 0;
	avgPotSize = 0;
	avgStackSize = 0;
	numPlayers = 0;
	numTables = 0;
	numFullTables = 0;
	tableStakes.clear();
	variableAntes.clear();
	visibilityMaskEx.clear();
}

bool MLobby::cli::SeatFinderStruct::equals(const SeatFinderStruct& _o) const
{
	return id == _o.id &&
		game == _o.game &&
		structure == _o.structure &&
		isHiLo == _o.isHiLo &&
		maxPlayersPerTable == _o.maxPlayersPerTable &&
		loBet == _o.loBet &&
		hiBet == _o.hiBet &&
		ante == _o.ante &&
		cap == _o.cap &&
		currency.equals(_o.currency) &&
		minChipsLimit == _o.minChipsLimit &&
		maxBuyIn == _o.maxBuyIn &&
		visibilityMask == _o.visibilityMask &&
		defaultBuyIn == _o.defaultBuyIn &&
		specialName.equals(_o.specialName) &&
		countryRestrictionInverted == _o.countryRestrictionInverted &&
		restrictedCountries.equals(_o.restrictedCountries) &&
		replayerAddress.equals(_o.replayerAddress) &&
		replayerInstance.equals(_o.replayerInstance) &&
		minPlayersPerTable == _o.minPlayersPerTable &&
		isPasswordProtected == _o.isPasswordProtected &&
		poolBlockMinHands == _o.poolBlockMinHands &&
		poolBlockTimePenalty.equals(_o.poolBlockTimePenalty) &&
		flags == _o.flags &&
		flags2 == _o.flags2 &&
		isPM == _o.isPM &&
		scalePM == _o.scalePM &&
		handsPerHour == _o.handsPerHour &&
		avgPotSize == _o.avgPotSize &&
		avgStackSize == _o.avgStackSize &&
		numPlayers == _o.numPlayers &&
		numTables == _o.numTables &&
		numFullTables == _o.numFullTables &&
		tableStakes.equals(_o.tableStakes) &&
		variableAntes.equals(_o.variableAntes) &&
		visibilityMaskEx.equals(_o.visibilityMaskEx);
}

const char *MLobby::cli::SeatFinderStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("id=");
	_buf.appendUint(id);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("maxPlayersPerTable=");
	_buf.appendUint(maxPlayersPerTable);
	_buf.append(',');
	_buf.append("loBet=");
	_buf.appendInt(loBet);
	_buf.append(',');
	_buf.append("hiBet=");
	_buf.appendInt(hiBet);
	_buf.append(',');
	_buf.append("ante=");
	_buf.appendInt(ante);
	_buf.append(',');
	_buf.append("cap=");
	_buf.appendInt(cap);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("minChipsLimit=");
	_buf.appendInt(minChipsLimit);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendInt(maxBuyIn);
	_buf.append(',');
	_buf.append("visibilityMask=");
	_buf.appendUint(visibilityMask);
	_buf.append(',');
	_buf.append("defaultBuyIn=");
	_buf.appendInt(defaultBuyIn);
	_buf.append(',');
	_buf.append("specialName=");
	_buf.append(specialName);
	_buf.append(',');
	_buf.append("countryRestrictionInverted=");
	_buf.appendUint(countryRestrictionInverted);
	_buf.append(',');
	_buf.append("restrictedCountries=");
	restrictedCountries.toTraceString(_buf);
	_buf.append(',');
	_buf.append("replayerAddress=");
	_buf.append(replayerAddress);
	_buf.append(',');
	_buf.append("replayerInstance=");
	_buf.append(replayerInstance);
	_buf.append(',');
	_buf.append("minPlayersPerTable=");
	_buf.appendInt(minPlayersPerTable);
	_buf.append(',');
	_buf.append("isPasswordProtected=");
	_buf.appendUint(isPasswordProtected);
	_buf.append(',');
	_buf.append("poolBlockMinHands=");
	_buf.appendInt(poolBlockMinHands);
	_buf.append(',');
	_buf.append("poolBlockTimePenalty=");
	poolBlockTimePenalty.toTraceString(_buf);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("flags2=");
	_buf.appendUint64(flags2);
	_buf.append(',');
	_buf.append("isPM=");
	_buf.appendUint(isPM);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("handsPerHour=");
	_buf.appendInt(handsPerHour);
	_buf.append(',');
	_buf.append("avgPotSize=");
	_buf.appendInt(avgPotSize);
	_buf.append(',');
	_buf.append("avgStackSize=");
	_buf.appendInt(avgStackSize);
	_buf.append(',');
	_buf.append("numPlayers=");
	_buf.appendInt(numPlayers);
	_buf.append(',');
	_buf.append("numTables=");
	_buf.appendInt(numTables);
	_buf.append(',');
	_buf.append("numFullTables=");
	_buf.appendInt(numFullTables);
	_buf.append(',');
	_buf.append("tableStakes=");
	tableStakes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("variableAntes=");
	variableAntes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("visibilityMaskEx=");
	visibilityMaskEx.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MLobby::cli::SeatFinderStruct::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(SeatFinderStruct())) // not empty
	{
		_body.composeUINT32(id);
		_body.composeBYTE(game);
		_body.composeBYTE(structure);
		_body.composeBYTE(isHiLo);
		_body.composeBYTE(maxPlayersPerTable);
		_body.composeINT32(loBet);
		_body.composeINT32(hiBet);
		_body.composeINT32(ante);
		_body.composeINT32(cap);
		_body.composeString(currency);
		_body.composeINT32(minChipsLimit);
		_body.composeINT32(maxBuyIn);
		_body.composeUINT32(visibilityMask);
		_body.composeINT32(defaultBuyIn);
		_body.composeString(specialName);
		_body.composeBOOL(countryRestrictionInverted);
		restrictedCountries.composeMsg(_body);
		_body.composeString(replayerAddress);
		_body.composeString(replayerInstance);
		_body.composeINT8(minPlayersPerTable);
		_body.composeBOOL(isPasswordProtected);
		_body.composeINT32(poolBlockMinHands);
		poolBlockTimePenalty.composeMsg(_body);
		_body.composeUINT32(flags);
		_body.composeUINT64(flags2);
		_body.composeBOOL(isPM);
		_body.composeUINT32(scalePM);
		_body.composeINT32(handsPerHour);
		_body.composeINT32(avgPotSize);
		_body.composeINT32(avgStackSize);
		_body.composeINT32(numPlayers);
		_body.composeINT32(numTables);
		_body.composeINT32(numFullTables);
		tableStakes.composeMsg(_body);
		variableAntes.composeMsg(_body);
		visibilityMaskEx.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::SeatFinderStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(id);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(structure);
	_parser0.parseBYTE(isHiLo);
	_parser0.parseBYTE(maxPlayersPerTable);
	_parser0.parseINT32(loBet);
	_parser0.parseINT32(hiBet);
	_parser0.parseINT32(ante);
	_parser0.parseINT32(cap);
	_parser0.parseStringP(currency);
	_parser0.parseINT32(minChipsLimit);
	_parser0.parseINT32(maxBuyIn);
	_parser0.parseUINT32(visibilityMask);
	_parser0.parseINT32(defaultBuyIn);
	_parser0.parseStringP(specialName);
	_parser0.parseBOOL(countryRestrictionInverted);
	restrictedCountries.parseMsg(_parser0);
	_parser0.parseStringP(replayerAddress);
	_parser0.parseStringP(replayerInstance);
	_parser0.parseINT8(minPlayersPerTable);
	_parser0.parseBOOL(isPasswordProtected);
	_parser0.parseINT32(poolBlockMinHands);
	poolBlockTimePenalty.parseMsg(_parser0);
	_parser0.parseUINT32(flags);
	_parser0.parseUINT64(flags2);
	_parser0.parseBOOL(isPM);
	_parser0.parseUINT32(scalePM);
	_parser0.parseINT32(handsPerHour);
	_parser0.parseINT32(avgPotSize);
	_parser0.parseINT32(avgStackSize);
	_parser0.parseINT32(numPlayers);
	_parser0.parseINT32(numTables);
	_parser0.parseINT32(numFullTables);
	if(_parser0.parseEnded()) return;
	tableStakes.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	variableAntes.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	visibilityMaskEx.parseMsg(_parser0);
}

/*static*/ void MLobby::cli::SeatFinderStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 id; _parser0.parseUINT32(id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser0.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE maxPlayersPerTable; _parser0.parseBYTE(maxPlayersPerTable);
	AtfValidator::validateInt(_descr, "maxPlayersPerTable", maxPlayersPerTable, _checker, __FILE__, __LINE__);
	INT32 loBet; _parser0.parseINT32(loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	INT32 hiBet; _parser0.parseINT32(hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	INT32 ante; _parser0.parseINT32(ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	INT32 cap; _parser0.parseINT32(cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT32 minChipsLimit; _parser0.parseINT32(minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	INT32 maxBuyIn; _parser0.parseINT32(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	UINT32 visibilityMask; _parser0.parseUINT32(visibilityMask);
	AtfValidator::validateInt(_descr, "visibilityMask", visibilityMask, _checker, __FILE__, __LINE__);
	INT32 defaultBuyIn; _parser0.parseINT32(defaultBuyIn);
	AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "specialName"); size_t szSpecialName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "specialName", szSpecialName, _checker, __FILE__, __LINE__);
	bool countryRestrictionInverted; _parser0.parseBOOL(countryRestrictionInverted);
	AtfValidator::validateInt(_descr, "countryRestrictionInverted", countryRestrictionInverted, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szRestrictedCountries = ThinAtf::LAtfVector< PString, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("restrictedCountries"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "restrictedCountries", szRestrictedCountries, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "replayerAddress"); size_t szReplayerAddress = strlen(_dummy);
	AtfValidator::validateInt(_descr, "replayerAddress", szReplayerAddress, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "replayerInstance"); size_t szReplayerInstance = strlen(_dummy);
	AtfValidator::validateInt(_descr, "replayerInstance", szReplayerInstance, _checker, __FILE__, __LINE__);
	INT8 minPlayersPerTable; _parser0.parseINT8(minPlayersPerTable);
	AtfValidator::validateInt(_descr, "minPlayersPerTable", minPlayersPerTable, _checker, __FILE__, __LINE__);
	bool isPasswordProtected; _parser0.parseBOOL(isPasswordProtected);
	AtfValidator::validateInt(_descr, "isPasswordProtected", isPasswordProtected, _checker, __FILE__, __LINE__);
	INT32 poolBlockMinHands; _parser0.parseINT32(poolBlockMinHands);
	AtfValidator::validateInt(_descr, "poolBlockMinHands", poolBlockMinHands, _checker, __FILE__, __LINE__);
	int szPoolBlockTimePenalty = ThinAtf::LAtfVector< INT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("poolBlockTimePenalty"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "poolBlockTimePenalty", szPoolBlockTimePenalty, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser0.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT64 flags2; _parser0.parseUINT64(flags2);
	AtfValidator::validateUint(_descr, "flags2", flags2, _checker, __FILE__, __LINE__);
	bool isPM; _parser0.parseBOOL(isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser0.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	INT32 handsPerHour; _parser0.parseINT32(handsPerHour);
	AtfValidator::validateInt(_descr, "handsPerHour", handsPerHour, _checker, __FILE__, __LINE__);
	INT32 avgPotSize; _parser0.parseINT32(avgPotSize);
	AtfValidator::validateInt(_descr, "avgPotSize", avgPotSize, _checker, __FILE__, __LINE__);
	INT32 avgStackSize; _parser0.parseINT32(avgStackSize);
	AtfValidator::validateInt(_descr, "avgStackSize", avgStackSize, _checker, __FILE__, __LINE__);
	INT32 numPlayers; _parser0.parseINT32(numPlayers);
	AtfValidator::validateInt(_descr, "numPlayers", numPlayers, _checker, __FILE__, __LINE__);
	INT32 numTables; _parser0.parseINT32(numTables);
	AtfValidator::validateInt(_descr, "numTables", numTables, _checker, __FILE__, __LINE__);
	INT32 numFullTables; _parser0.parseINT32(numFullTables);
	AtfValidator::validateInt(_descr, "numFullTables", numFullTables, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	TableCommonThin::TableStakes::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tableStakes"), _fieldsWithUnparsedContent);
	if(_parser0.parseEnded()) return;
	int szVariableAntes = ThinAtf::LAtfVector< INT64, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("variableAntes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "variableAntes", szVariableAntes, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("visibilityMaskEx"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TableTypeStaticDataStruct
//=================================================================

MLobby::cli::TableTypeStaticDataStruct::TableTypeStaticDataStruct()
{
	clear();
}

void MLobby::cli::TableTypeStaticDataStruct::clear()
{
	id = 0;
	isPlayMoney = 0;
	game = 0;
	isHiLo = 0;
	maxPlayers = 0;
	visibilityMask = 0;
	structure = 0;
	loBet = 0;
	hiBet = 0;
	ante = 0;
	cap = 0;
	currency.clear();
	minChipsLimit = 0;
	maxBuyIn = 0;
	countryRestrictionInverted = false;
	restrictedCountries.clear();
	visible = false;
	scalePM = 0;
	defaultBuyIn = 0;
	brandMask = 0;
	seatFinderId = 0;
	poolBlockMinHands = 0;
	poolBlockTimePenalty.clear();
	isPasswordProtected = false;
	isMorphLobby = false;
	tableStakes.clear();
	variableAntes.clear();
	specialName.clear();
	visibilityMaskEx.clear();
}

bool MLobby::cli::TableTypeStaticDataStruct::equals(const TableTypeStaticDataStruct& _o) const
{
	return id == _o.id &&
		isPlayMoney == _o.isPlayMoney &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		maxPlayers == _o.maxPlayers &&
		visibilityMask == _o.visibilityMask &&
		structure == _o.structure &&
		loBet == _o.loBet &&
		hiBet == _o.hiBet &&
		ante == _o.ante &&
		cap == _o.cap &&
		currency.equals(_o.currency) &&
		minChipsLimit == _o.minChipsLimit &&
		maxBuyIn == _o.maxBuyIn &&
		countryRestrictionInverted == _o.countryRestrictionInverted &&
		restrictedCountries.equals(_o.restrictedCountries) &&
		visible == _o.visible &&
		scalePM == _o.scalePM &&
		defaultBuyIn == _o.defaultBuyIn &&
		brandMask == _o.brandMask &&
		seatFinderId == _o.seatFinderId &&
		poolBlockMinHands == _o.poolBlockMinHands &&
		poolBlockTimePenalty.equals(_o.poolBlockTimePenalty) &&
		isPasswordProtected == _o.isPasswordProtected &&
		isMorphLobby == _o.isMorphLobby &&
		tableStakes.equals(_o.tableStakes) &&
		variableAntes.equals(_o.variableAntes) &&
		specialName.equals(_o.specialName) &&
		visibilityMaskEx.equals(_o.visibilityMaskEx);
}

const char *MLobby::cli::TableTypeStaticDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("id=");
	_buf.appendUint(id);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendUint(maxPlayers);
	_buf.append(',');
	_buf.append("visibilityMask=");
	_buf.appendUint(visibilityMask);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("loBet=");
	_buf.appendUint(loBet);
	_buf.append(',');
	_buf.append("hiBet=");
	_buf.appendUint(hiBet);
	_buf.append(',');
	_buf.append("ante=");
	_buf.appendUint(ante);
	_buf.append(',');
	_buf.append("cap=");
	_buf.appendUint(cap);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("minChipsLimit=");
	_buf.appendUint(minChipsLimit);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendUint(maxBuyIn);
	_buf.append(',');
	_buf.append("countryRestrictionInverted=");
	_buf.appendUint(countryRestrictionInverted);
	_buf.append(',');
	_buf.append("restrictedCountries=");
	restrictedCountries.toTraceString(_buf);
	_buf.append(',');
	_buf.append("visible=");
	_buf.appendUint(visible);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("defaultBuyIn=");
	_buf.appendUint(defaultBuyIn);
	_buf.append(',');
	_buf.append("brandMask=");
	_buf.appendUint(brandMask);
	_buf.append(',');
	_buf.append("seatFinderId=");
	_buf.appendUint(seatFinderId);
	_buf.append(',');
	_buf.append("poolBlockMinHands=");
	_buf.appendInt(poolBlockMinHands);
	_buf.append(',');
	_buf.append("poolBlockTimePenalty=");
	poolBlockTimePenalty.toTraceString(_buf);
	_buf.append(',');
	_buf.append("isPasswordProtected=");
	_buf.appendUint(isPasswordProtected);
	_buf.append(',');
	_buf.append("isMorphLobby=");
	_buf.appendUint(isMorphLobby);
	_buf.append(',');
	_buf.append("tableStakes=");
	tableStakes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("variableAntes=");
	variableAntes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("specialName=");
	_buf.append(specialName);
	_buf.append(',');
	_buf.append("visibilityMaskEx=");
	visibilityMaskEx.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MLobby::cli::TableTypeStaticDataStruct::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(TableTypeStaticDataStruct())) // not empty
	{
		_body.composeUINT32(id);
		_body.composeBYTE(isPlayMoney);
		_body.composeBYTE(game);
		_body.composeBYTE(isHiLo);
		_body.composeBYTE(maxPlayers);
		_body.composeUINT32(visibilityMask);
		_body.composeBYTE(structure);
		_body.composeUINT32(loBet);
		_body.composeUINT32(hiBet);
		_body.composeUINT32(ante);
		_body.composeUINT32(cap);
		_body.composeString(currency);
		_body.composeUINT32(minChipsLimit);
		_body.composeUINT32(maxBuyIn);
		_body.composeBOOL(countryRestrictionInverted);
		restrictedCountries.composeMsg(_body);
		_body.composeBOOL(visible);
		_body.composeUINT32(scalePM);
		_body.composeUINT32(defaultBuyIn);
		_body.composeUINT32(brandMask);
		_body.composeUINT32(seatFinderId);
		_body.composeINT32(poolBlockMinHands);
		poolBlockTimePenalty.composeMsg(_body);
		_body.composeBOOL(isPasswordProtected);
		_body.composeBOOL(isMorphLobby);
		tableStakes.composeMsg(_body);
		variableAntes.composeMsg(_body);
		_body.composeString(specialName);
		visibilityMaskEx.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::TableTypeStaticDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(id);
	_parser0.parseBYTE(isPlayMoney);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(isHiLo);
	_parser0.parseBYTE(maxPlayers);
	_parser0.parseUINT32(visibilityMask);
	_parser0.parseBYTE(structure);
	_parser0.parseUINT32(loBet);
	_parser0.parseUINT32(hiBet);
	_parser0.parseUINT32(ante);
	_parser0.parseUINT32(cap);
	_parser0.parseStringP(currency);
	_parser0.parseUINT32(minChipsLimit);
	_parser0.parseUINT32(maxBuyIn);
	_parser0.parseBOOL(countryRestrictionInverted);
	restrictedCountries.parseMsg(_parser0);
	_parser0.parseBOOL(visible);
	_parser0.parseUINT32(scalePM);
	_parser0.parseUINT32(defaultBuyIn);
	_parser0.parseUINT32(brandMask);
	_parser0.parseUINT32(seatFinderId);
	_parser0.parseINT32(poolBlockMinHands);
	poolBlockTimePenalty.parseMsg(_parser0);
	_parser0.parseBOOL(isPasswordProtected);
	_parser0.parseBOOL(isMorphLobby);
	tableStakes.parseMsg(_parser0);
	variableAntes.parseMsg(_parser0);
	_parser0.parseStringP(specialName);
	if(_parser0.parseEnded()) return;
	visibilityMaskEx.parseMsg(_parser0);
}

/*static*/ void MLobby::cli::TableTypeStaticDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 id; _parser0.parseUINT32(id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser0.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser0.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE maxPlayers; _parser0.parseBYTE(maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	UINT32 visibilityMask; _parser0.parseUINT32(visibilityMask);
	AtfValidator::validateInt(_descr, "visibilityMask", visibilityMask, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	UINT32 loBet; _parser0.parseUINT32(loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	UINT32 hiBet; _parser0.parseUINT32(hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	UINT32 ante; _parser0.parseUINT32(ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	UINT32 cap; _parser0.parseUINT32(cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 minChipsLimit; _parser0.parseUINT32(minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	UINT32 maxBuyIn; _parser0.parseUINT32(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	bool countryRestrictionInverted; _parser0.parseBOOL(countryRestrictionInverted);
	AtfValidator::validateInt(_descr, "countryRestrictionInverted", countryRestrictionInverted, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szRestrictedCountries = ThinAtf::LAtfVector< PString, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("restrictedCountries"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "restrictedCountries", szRestrictedCountries, _checker, __FILE__, __LINE__);
	bool visible; _parser0.parseBOOL(visible);
	AtfValidator::validateInt(_descr, "visible", visible, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser0.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT32 defaultBuyIn; _parser0.parseUINT32(defaultBuyIn);
	AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	UINT32 brandMask; _parser0.parseUINT32(brandMask);
	AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
	UINT32 seatFinderId; _parser0.parseUINT32(seatFinderId);
	AtfValidator::validateInt(_descr, "seatFinderId", seatFinderId, _checker, __FILE__, __LINE__);
	INT32 poolBlockMinHands; _parser0.parseINT32(poolBlockMinHands);
	AtfValidator::validateInt(_descr, "poolBlockMinHands", poolBlockMinHands, _checker, __FILE__, __LINE__);
	int szPoolBlockTimePenalty = ThinAtf::LAtfVector< INT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("poolBlockTimePenalty"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "poolBlockTimePenalty", szPoolBlockTimePenalty, _checker, __FILE__, __LINE__);
	bool isPasswordProtected; _parser0.parseBOOL(isPasswordProtected);
	AtfValidator::validateInt(_descr, "isPasswordProtected", isPasswordProtected, _checker, __FILE__, __LINE__);
	bool isMorphLobby; _parser0.parseBOOL(isMorphLobby);
	AtfValidator::validateInt(_descr, "isMorphLobby", isMorphLobby, _checker, __FILE__, __LINE__);
	TableCommonThin::TableStakes::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tableStakes"), _fieldsWithUnparsedContent);
	int szVariableAntes = ThinAtf::LAtfVector< INT64, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("variableAntes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "variableAntes", szVariableAntes, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "specialName"); size_t szSpecialName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "specialName", szSpecialName, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("visibilityMaskEx"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TableTypeDynaDataStruct
//=================================================================

MLobby::cli::TableTypeDynaDataStruct::TableTypeDynaDataStruct()
{
	clear();
}

void MLobby::cli::TableTypeDynaDataStruct::clear()
{
	numPlayers = 0;
	numTables = 0;
}

bool MLobby::cli::TableTypeDynaDataStruct::equals(const TableTypeDynaDataStruct& _o) const
{
	return numPlayers == _o.numPlayers &&
		numTables == _o.numTables;
}

const char *MLobby::cli::TableTypeDynaDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("numPlayers=");
	_buf.appendUint(numPlayers);
	_buf.append(',');
	_buf.append("numTables=");
	_buf.appendUint(numTables);
	_buf.append('}');
	return _buf.c_str();
}

void MLobby::cli::TableTypeDynaDataStruct::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(TableTypeDynaDataStruct())) // not empty
	{
		_body.composeUINT32(numPlayers);
		_body.composeUINT32(numTables);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::TableTypeDynaDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(numPlayers);
	_parser0.parseUINT32(numTables);
}

/*static*/ void MLobby::cli::TableTypeDynaDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 numPlayers; _parser0.parseUINT32(numPlayers);
	AtfValidator::validateInt(_descr, "numPlayers", numPlayers, _checker, __FILE__, __LINE__);
	UINT32 numTables; _parser0.parseUINT32(numTables);
	AtfValidator::validateInt(_descr, "numTables", numTables, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TableTypeDataStruct
//=================================================================

MLobby::cli::TableTypeDataStruct::TableTypeDataStruct()
{
	clear();
}

void MLobby::cli::TableTypeDataStruct::clear()
{
	staticData.clear();
	dynamicData.clear();
}

bool MLobby::cli::TableTypeDataStruct::equals(const TableTypeDataStruct& _o) const
{
	return staticData.equals(_o.staticData) &&
		dynamicData.equals(_o.dynamicData);
}

const char *MLobby::cli::TableTypeDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("staticData=");
	staticData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("dynamicData=");
	dynamicData.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MLobby::cli::TableTypeDataStruct::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(TableTypeDataStruct())) // not empty
	{
		staticData.composeMsg(_body);
		dynamicData.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::TableTypeDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	staticData.parseMsg(_parser0);
	dynamicData.parseMsg(_parser0);
}

/*static*/ void MLobby::cli::TableTypeDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	TableTypeStaticDataStruct::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("staticData"), _fieldsWithUnparsedContent);
	TableTypeDynaDataStruct::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("dynamicData"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ZoomStaticDataStruct
//=================================================================

MLobby::cli::ZoomStaticDataStruct::ZoomStaticDataStruct()
{
	clear();
}

void MLobby::cli::ZoomStaticDataStruct::clear()
{
	id = 0;
	game = 0;
	structure = 0;
	isHiLo = 0;
	maxPlayersPerTable = 0;
	loBet = 0;
	hiBet = 0;
	ante = 0;
	cap = 0;
	currency.clear();
	minChipsLimit = 0;
	maxBuyIn = 0;
	visibilityMask = 0;
	defaultBuyIn = 0;
	specialName.clear();
	countryRestrictionInverted = false;
	restrictedCountries.clear();
	isPlayMoney = 0;
	isMorphLobby = false;
	scalePM = 0;
	server.clear();
	name.clear();
	replayerInstance.clear();
	isOneOnOne = 0;
	tableFlags = 0;
	chatLang = 0;
	quickLobbyVisible = false;
	blitzFlags = 0;
	brandMask = 0;
	serverObj.clear();
	tableStakes.clear();
	visibilityMaskEx.clear();
	tableFlags2 = 0;
}

bool MLobby::cli::ZoomStaticDataStruct::equals(const ZoomStaticDataStruct& _o) const
{
	return id == _o.id &&
		game == _o.game &&
		structure == _o.structure &&
		isHiLo == _o.isHiLo &&
		maxPlayersPerTable == _o.maxPlayersPerTable &&
		loBet == _o.loBet &&
		hiBet == _o.hiBet &&
		ante == _o.ante &&
		cap == _o.cap &&
		currency.equals(_o.currency) &&
		minChipsLimit == _o.minChipsLimit &&
		maxBuyIn == _o.maxBuyIn &&
		visibilityMask == _o.visibilityMask &&
		defaultBuyIn == _o.defaultBuyIn &&
		specialName.equals(_o.specialName) &&
		countryRestrictionInverted == _o.countryRestrictionInverted &&
		restrictedCountries.equals(_o.restrictedCountries) &&
		isPlayMoney == _o.isPlayMoney &&
		isMorphLobby == _o.isMorphLobby &&
		scalePM == _o.scalePM &&
		server.equals(_o.server) &&
		name.equals(_o.name) &&
		replayerInstance.equals(_o.replayerInstance) &&
		isOneOnOne == _o.isOneOnOne &&
		tableFlags == _o.tableFlags &&
		chatLang == _o.chatLang &&
		quickLobbyVisible == _o.quickLobbyVisible &&
		blitzFlags == _o.blitzFlags &&
		brandMask == _o.brandMask &&
		serverObj.equals(_o.serverObj) &&
		tableStakes.equals(_o.tableStakes) &&
		visibilityMaskEx.equals(_o.visibilityMaskEx) &&
		tableFlags2 == _o.tableFlags2;
}

const char *MLobby::cli::ZoomStaticDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("id=");
	_buf.appendUint(id);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("maxPlayersPerTable=");
	_buf.appendUint(maxPlayersPerTable);
	_buf.append(',');
	_buf.append("loBet=");
	_buf.appendInt(loBet);
	_buf.append(',');
	_buf.append("hiBet=");
	_buf.appendInt(hiBet);
	_buf.append(',');
	_buf.append("ante=");
	_buf.appendInt(ante);
	_buf.append(',');
	_buf.append("cap=");
	_buf.appendInt(cap);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("minChipsLimit=");
	_buf.appendInt(minChipsLimit);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendInt(maxBuyIn);
	_buf.append(',');
	_buf.append("visibilityMask=");
	_buf.appendUint(visibilityMask);
	_buf.append(',');
	_buf.append("defaultBuyIn=");
	_buf.appendInt(defaultBuyIn);
	_buf.append(',');
	_buf.append("specialName=");
	_buf.append(specialName);
	_buf.append(',');
	_buf.append("countryRestrictionInverted=");
	_buf.appendUint(countryRestrictionInverted);
	_buf.append(',');
	_buf.append("restrictedCountries=");
	restrictedCountries.toTraceString(_buf);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("isMorphLobby=");
	_buf.appendUint(isMorphLobby);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("replayerInstance=");
	_buf.append(replayerInstance);
	_buf.append(',');
	_buf.append("isOneOnOne=");
	_buf.appendUint(isOneOnOne);
	_buf.append(',');
	_buf.append("tableFlags=");
	_buf.appendUint(tableFlags);
	_buf.append(',');
	_buf.append("chatLang=");
	_buf.appendUint(chatLang);
	_buf.append(',');
	_buf.append("quickLobbyVisible=");
	_buf.appendUint(quickLobbyVisible);
	_buf.append(',');
	_buf.append("blitzFlags=");
	_buf.appendUint(blitzFlags);
	_buf.append(',');
	_buf.append("brandMask=");
	_buf.appendUint(brandMask);
	_buf.append(',');
	_buf.append("serverObj=");
	_buf.append(serverObj);
	_buf.append(',');
	_buf.append("tableStakes=");
	tableStakes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("visibilityMaskEx=");
	visibilityMaskEx.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableFlags2=");
	_buf.appendUint64(tableFlags2);
	_buf.append('}');
	return _buf.c_str();
}

void MLobby::cli::ZoomStaticDataStruct::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(ZoomStaticDataStruct())) // not empty
	{
		_body.composeUINT32(id);
		_body.composeBYTE(game);
		_body.composeBYTE(structure);
		_body.composeBYTE(isHiLo);
		_body.composeBYTE(maxPlayersPerTable);
		_body.composeINT32(loBet);
		_body.composeINT32(hiBet);
		_body.composeINT32(ante);
		_body.composeINT32(cap);
		_body.composeString(currency);
		_body.composeINT32(minChipsLimit);
		_body.composeINT32(maxBuyIn);
		_body.composeUINT32(visibilityMask);
		_body.composeINT32(defaultBuyIn);
		_body.composeString(specialName);
		_body.composeBOOL(countryRestrictionInverted);
		restrictedCountries.composeMsg(_body);
		_body.composeBYTE(isPlayMoney);
		_body.composeBOOL(isMorphLobby);
		_body.composeUINT32(scalePM);
		_body.composeString(server);
		_body.composeString(name);
		_body.composeString(replayerInstance);
		_body.composeBYTE(isOneOnOne);
		_body.composeUINT32(tableFlags);
		_body.composeUINT16(chatLang);
		_body.composeBOOL(quickLobbyVisible);
		_body.composeUINT32(blitzFlags);
		_body.composeUINT32(brandMask);
		_body.composeString(serverObj);
		tableStakes.composeMsg(_body);
		visibilityMaskEx.composeMsg(_body);
		_body.composeUINT64(tableFlags2);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::ZoomStaticDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(id);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(structure);
	_parser0.parseBYTE(isHiLo);
	_parser0.parseBYTE(maxPlayersPerTable);
	_parser0.parseINT32(loBet);
	_parser0.parseINT32(hiBet);
	_parser0.parseINT32(ante);
	_parser0.parseINT32(cap);
	_parser0.parseStringP(currency);
	_parser0.parseINT32(minChipsLimit);
	_parser0.parseINT32(maxBuyIn);
	_parser0.parseUINT32(visibilityMask);
	_parser0.parseINT32(defaultBuyIn);
	_parser0.parseStringP(specialName);
	_parser0.parseBOOL(countryRestrictionInverted);
	restrictedCountries.parseMsg(_parser0);
	_parser0.parseBYTE(isPlayMoney);
	_parser0.parseBOOL(isMorphLobby);
	_parser0.parseUINT32(scalePM);
	_parser0.parseStringP(server);
	_parser0.parseStringP(name);
	_parser0.parseStringP(replayerInstance);
	_parser0.parseBYTE(isOneOnOne);
	_parser0.parseUINT32(tableFlags);
	_parser0.parseUINT16(chatLang);
	_parser0.parseBOOL(quickLobbyVisible);
	_parser0.parseUINT32(blitzFlags);
	_parser0.parseUINT32(brandMask);
	_parser0.parseStringP(serverObj);
	if(_parser0.parseEnded()) return;
	tableStakes.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	visibilityMaskEx.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT64(tableFlags2);
}

/*static*/ void MLobby::cli::ZoomStaticDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 id; _parser0.parseUINT32(id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser0.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE maxPlayersPerTable; _parser0.parseBYTE(maxPlayersPerTable);
	AtfValidator::validateInt(_descr, "maxPlayersPerTable", maxPlayersPerTable, _checker, __FILE__, __LINE__);
	INT32 loBet; _parser0.parseINT32(loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	INT32 hiBet; _parser0.parseINT32(hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	INT32 ante; _parser0.parseINT32(ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	INT32 cap; _parser0.parseINT32(cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT32 minChipsLimit; _parser0.parseINT32(minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	INT32 maxBuyIn; _parser0.parseINT32(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	UINT32 visibilityMask; _parser0.parseUINT32(visibilityMask);
	AtfValidator::validateInt(_descr, "visibilityMask", visibilityMask, _checker, __FILE__, __LINE__);
	INT32 defaultBuyIn; _parser0.parseINT32(defaultBuyIn);
	AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "specialName"); size_t szSpecialName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "specialName", szSpecialName, _checker, __FILE__, __LINE__);
	bool countryRestrictionInverted; _parser0.parseBOOL(countryRestrictionInverted);
	AtfValidator::validateInt(_descr, "countryRestrictionInverted", countryRestrictionInverted, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szRestrictedCountries = ThinAtf::LAtfVector< PString, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("restrictedCountries"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "restrictedCountries", szRestrictedCountries, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser0.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	bool isMorphLobby; _parser0.parseBOOL(isMorphLobby);
	AtfValidator::validateInt(_descr, "isMorphLobby", isMorphLobby, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser0.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "replayerInstance"); size_t szReplayerInstance = strlen(_dummy);
	AtfValidator::validateInt(_descr, "replayerInstance", szReplayerInstance, _checker, __FILE__, __LINE__);
	BYTE isOneOnOne; _parser0.parseBYTE(isOneOnOne);
	AtfValidator::validateInt(_descr, "isOneOnOne", isOneOnOne, _checker, __FILE__, __LINE__);
	UINT32 tableFlags; _parser0.parseUINT32(tableFlags);
	AtfValidator::validateInt(_descr, "tableFlags", tableFlags, _checker, __FILE__, __LINE__);
	UINT16 chatLang; _parser0.parseUINT16(chatLang);
	AtfValidator::validateInt(_descr, "chatLang", chatLang, _checker, __FILE__, __LINE__);
	bool quickLobbyVisible; _parser0.parseBOOL(quickLobbyVisible);
	AtfValidator::validateInt(_descr, "quickLobbyVisible", quickLobbyVisible, _checker, __FILE__, __LINE__);
	UINT32 blitzFlags; _parser0.parseUINT32(blitzFlags);
	AtfValidator::validateInt(_descr, "blitzFlags", blitzFlags, _checker, __FILE__, __LINE__);
	UINT32 brandMask; _parser0.parseUINT32(brandMask);
	AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "serverObj"); size_t szServerObj = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObj", szServerObj, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	TableCommonThin::TableStakes::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tableStakes"), _fieldsWithUnparsedContent);
	if(_parser0.parseEnded()) return;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("visibilityMaskEx"), _fieldsWithUnparsedContent);
	if(_parser0.parseEnded()) return;
	UINT64 tableFlags2; _parser0.parseUINT64(tableFlags2);
	AtfValidator::validateUint(_descr, "tableFlags2", tableFlags2, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    EarlyBirdMultiplier
//=================================================================

MLobby::cli::EarlyBirdMultiplier::EarlyBirdMultiplier()
{
	clear();
}

void MLobby::cli::EarlyBirdMultiplier::clear()
{
	licenseId = 0;
	multiplier = 0;
}

bool MLobby::cli::EarlyBirdMultiplier::equals(const EarlyBirdMultiplier& _o) const
{
	return licenseId == _o.licenseId &&
		multiplier == _o.multiplier;
}

const char *MLobby::cli::EarlyBirdMultiplier::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("licenseId=");
	_buf.appendUint(licenseId);
	_buf.append(',');
	_buf.append("multiplier=");
	_buf.appendUint(multiplier);
	_buf.append('}');
	return _buf.c_str();
}

void MLobby::cli::EarlyBirdMultiplier::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(EarlyBirdMultiplier())) // not empty
	{
		_body.composeUINT32(licenseId);
		_body.composeUINT32(multiplier);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::EarlyBirdMultiplier::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(licenseId);
	_parser0.parseUINT32(multiplier);
}

/*static*/ void MLobby::cli::EarlyBirdMultiplier::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 licenseId; _parser0.parseUINT32(licenseId);
	AtfValidator::validateInt(_descr, "licenseId", licenseId, _checker, __FILE__, __LINE__);
	UINT32 multiplier; _parser0.parseUINT32(multiplier);
	AtfValidator::validateInt(_descr, "multiplier", multiplier, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ZoomDynaDataStruct
//=================================================================

MLobby::cli::ZoomDynaDataStruct::ZoomDynaDataStruct()
{
	clear();
}

void MLobby::cli::ZoomDynaDataStruct::clear()
{
	handsPerHour = 0;
	avgPotSize = 0;
	avgStackSize = 0;
	numPlayers = 0;
	publProp = 0;
	avgPlayers = 0;
	avgVpip = 0;
	fppFactors.clear();
	earlyBirdMins = 0;
	earlyBirdMultipliers.clear();
}

bool MLobby::cli::ZoomDynaDataStruct::equals(const ZoomDynaDataStruct& _o) const
{
	return handsPerHour == _o.handsPerHour &&
		avgPotSize == _o.avgPotSize &&
		avgStackSize == _o.avgStackSize &&
		numPlayers == _o.numPlayers &&
		publProp == _o.publProp &&
		avgPlayers == _o.avgPlayers &&
		avgVpip == _o.avgVpip &&
		fppFactors.equals(_o.fppFactors) &&
		earlyBirdMins == _o.earlyBirdMins &&
		earlyBirdMultipliers.equals(_o.earlyBirdMultipliers);
}

const char *MLobby::cli::ZoomDynaDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("handsPerHour=");
	_buf.appendInt(handsPerHour);
	_buf.append(',');
	_buf.append("avgPotSize=");
	_buf.appendInt(avgPotSize);
	_buf.append(',');
	_buf.append("avgStackSize=");
	_buf.appendInt(avgStackSize);
	_buf.append(',');
	_buf.append("numPlayers=");
	_buf.appendInt(numPlayers);
	_buf.append(',');
	_buf.append("publProp=");
	_buf.appendUint(publProp);
	_buf.append(',');
	_buf.append("avgPlayers=");
	_buf.appendUint(avgPlayers);
	_buf.append(',');
	_buf.append("avgVpip=");
	_buf.appendUint(avgVpip);
	_buf.append(',');
	_buf.append("fppFactors=");
	fppFactors.toTraceString(_buf);
	_buf.append(',');
	_buf.append("earlyBirdMins=");
	_buf.appendInt(earlyBirdMins);
	_buf.append(',');
	_buf.append("earlyBirdMultipliers=");
	earlyBirdMultipliers.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MLobby::cli::ZoomDynaDataStruct::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(ZoomDynaDataStruct())) // not empty
	{
		_body.composeINT32(handsPerHour);
		_body.composeINT32(avgPotSize);
		_body.composeINT32(avgStackSize);
		_body.composeINT32(numPlayers);
		_body.composeBYTE(publProp);
		_body.composeBYTE(avgPlayers);
		_body.composeBYTE(avgVpip);
		fppFactors.composeMsg(_body);
		_body.composeINT32(earlyBirdMins);
		earlyBirdMultipliers.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::ZoomDynaDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(handsPerHour);
	_parser0.parseINT32(avgPotSize);
	_parser0.parseINT32(avgStackSize);
	_parser0.parseINT32(numPlayers);
	_parser0.parseBYTE(publProp);
	_parser0.parseBYTE(avgPlayers);
	_parser0.parseBYTE(avgVpip);
	fppFactors.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT32(earlyBirdMins);
	if(_parser0.parseEnded()) return;
	earlyBirdMultipliers.parseMsg(_parser0);
}

/*static*/ void MLobby::cli::ZoomDynaDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 handsPerHour; _parser0.parseINT32(handsPerHour);
	AtfValidator::validateInt(_descr, "handsPerHour", handsPerHour, _checker, __FILE__, __LINE__);
	INT32 avgPotSize; _parser0.parseINT32(avgPotSize);
	AtfValidator::validateInt(_descr, "avgPotSize", avgPotSize, _checker, __FILE__, __LINE__);
	INT32 avgStackSize; _parser0.parseINT32(avgStackSize);
	AtfValidator::validateInt(_descr, "avgStackSize", avgStackSize, _checker, __FILE__, __LINE__);
	INT32 numPlayers; _parser0.parseINT32(numPlayers);
	AtfValidator::validateInt(_descr, "numPlayers", numPlayers, _checker, __FILE__, __LINE__);
	BYTE publProp; _parser0.parseBYTE(publProp);
	AtfValidator::validateInt(_descr, "publProp", publProp, _checker, __FILE__, __LINE__);
	BYTE avgPlayers; _parser0.parseBYTE(avgPlayers);
	AtfValidator::validateInt(_descr, "avgPlayers", avgPlayers, _checker, __FILE__, __LINE__);
	BYTE avgVpip; _parser0.parseBYTE(avgVpip);
	AtfValidator::validateInt(_descr, "avgVpip", avgVpip, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szFppFactors = ThinAtf::LAtfVector< FppFactorStruct, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("fppFactors"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "fppFactors", szFppFactors, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT32 earlyBirdMins; _parser0.parseINT32(earlyBirdMins);
	AtfValidator::validateInt(_descr, "earlyBirdMins", earlyBirdMins, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	int szEarlyBirdMultipliers = ThinAtf::LAtfVector< EarlyBirdMultiplier, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("earlyBirdMultipliers"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "earlyBirdMultipliers", szEarlyBirdMultipliers, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ZoomDataStruct
//=================================================================

MLobby::cli::ZoomDataStruct::ZoomDataStruct()
{
	clear();
}

void MLobby::cli::ZoomDataStruct::clear()
{
	staticData.clear();
	dynamicData.clear();
}

bool MLobby::cli::ZoomDataStruct::equals(const ZoomDataStruct& _o) const
{
	return staticData.equals(_o.staticData) &&
		dynamicData.equals(_o.dynamicData);
}

const char *MLobby::cli::ZoomDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("staticData=");
	staticData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("dynamicData=");
	dynamicData.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MLobby::cli::ZoomDataStruct::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(ZoomDataStruct())) // not empty
	{
		staticData.composeMsg(_body);
		dynamicData.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::ZoomDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	staticData.parseMsg(_parser0);
	dynamicData.parseMsg(_parser0);
}

/*static*/ void MLobby::cli::ZoomDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	ZoomStaticDataStruct::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("staticData"), _fieldsWithUnparsedContent);
	ZoomDynaDataStruct::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("dynamicData"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SeatFinderStaticDataStruct
//=================================================================

MLobby::cli::SeatFinderStaticDataStruct::SeatFinderStaticDataStruct()
{
	clear();
}

void MLobby::cli::SeatFinderStaticDataStruct::clear()
{
	id = 0;
	game = 0;
	structure = 0;
	isHiLo = 0;
	maxPlayersPerTable = 0;
	loBet = 0;
	hiBet = 0;
	ante = 0;
	cap = 0;
	currency.clear();
	minChipsLimit = 0;
	maxBuyIn = 0;
	visibilityMask = 0;
	defaultBuyIn = 0;
	specialName.clear();
	countryRestrictionInverted = false;
	restrictedCountries.clear();
	replayerAddress.clear();
	replayerInstance.clear();
	minPlayersPerTable = 0;
	isPasswordProtected = false;
	poolBlockMinHands = 0;
	poolBlockTimePenalty.clear();
	flags = 0;
	flags2 = 0;
	isPM = false;
	scalePM = 0;
	tableStakes.clear();
	variableAntes.clear();
	visibilityMaskEx.clear();
}

bool MLobby::cli::SeatFinderStaticDataStruct::equals(const SeatFinderStaticDataStruct& _o) const
{
	return id == _o.id &&
		game == _o.game &&
		structure == _o.structure &&
		isHiLo == _o.isHiLo &&
		maxPlayersPerTable == _o.maxPlayersPerTable &&
		loBet == _o.loBet &&
		hiBet == _o.hiBet &&
		ante == _o.ante &&
		cap == _o.cap &&
		currency.equals(_o.currency) &&
		minChipsLimit == _o.minChipsLimit &&
		maxBuyIn == _o.maxBuyIn &&
		visibilityMask == _o.visibilityMask &&
		defaultBuyIn == _o.defaultBuyIn &&
		specialName.equals(_o.specialName) &&
		countryRestrictionInverted == _o.countryRestrictionInverted &&
		restrictedCountries.equals(_o.restrictedCountries) &&
		replayerAddress.equals(_o.replayerAddress) &&
		replayerInstance.equals(_o.replayerInstance) &&
		minPlayersPerTable == _o.minPlayersPerTable &&
		isPasswordProtected == _o.isPasswordProtected &&
		poolBlockMinHands == _o.poolBlockMinHands &&
		poolBlockTimePenalty.equals(_o.poolBlockTimePenalty) &&
		flags == _o.flags &&
		flags2 == _o.flags2 &&
		isPM == _o.isPM &&
		scalePM == _o.scalePM &&
		tableStakes.equals(_o.tableStakes) &&
		variableAntes.equals(_o.variableAntes) &&
		visibilityMaskEx.equals(_o.visibilityMaskEx);
}

const char *MLobby::cli::SeatFinderStaticDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("id=");
	_buf.appendUint(id);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("maxPlayersPerTable=");
	_buf.appendUint(maxPlayersPerTable);
	_buf.append(',');
	_buf.append("loBet=");
	_buf.appendInt(loBet);
	_buf.append(',');
	_buf.append("hiBet=");
	_buf.appendInt(hiBet);
	_buf.append(',');
	_buf.append("ante=");
	_buf.appendInt(ante);
	_buf.append(',');
	_buf.append("cap=");
	_buf.appendInt(cap);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("minChipsLimit=");
	_buf.appendInt(minChipsLimit);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendInt(maxBuyIn);
	_buf.append(',');
	_buf.append("visibilityMask=");
	_buf.appendUint(visibilityMask);
	_buf.append(',');
	_buf.append("defaultBuyIn=");
	_buf.appendInt(defaultBuyIn);
	_buf.append(',');
	_buf.append("specialName=");
	_buf.append(specialName);
	_buf.append(',');
	_buf.append("countryRestrictionInverted=");
	_buf.appendUint(countryRestrictionInverted);
	_buf.append(',');
	_buf.append("restrictedCountries=");
	restrictedCountries.toTraceString(_buf);
	_buf.append(',');
	_buf.append("replayerAddress=");
	_buf.append(replayerAddress);
	_buf.append(',');
	_buf.append("replayerInstance=");
	_buf.append(replayerInstance);
	_buf.append(',');
	_buf.append("minPlayersPerTable=");
	_buf.appendInt(minPlayersPerTable);
	_buf.append(',');
	_buf.append("isPasswordProtected=");
	_buf.appendUint(isPasswordProtected);
	_buf.append(',');
	_buf.append("poolBlockMinHands=");
	_buf.appendInt(poolBlockMinHands);
	_buf.append(',');
	_buf.append("poolBlockTimePenalty=");
	poolBlockTimePenalty.toTraceString(_buf);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("flags2=");
	_buf.appendUint64(flags2);
	_buf.append(',');
	_buf.append("isPM=");
	_buf.appendUint(isPM);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("tableStakes=");
	tableStakes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("variableAntes=");
	variableAntes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("visibilityMaskEx=");
	visibilityMaskEx.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MLobby::cli::SeatFinderStaticDataStruct::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(SeatFinderStaticDataStruct())) // not empty
	{
		_body.composeUINT32(id);
		_body.composeBYTE(game);
		_body.composeBYTE(structure);
		_body.composeBYTE(isHiLo);
		_body.composeBYTE(maxPlayersPerTable);
		_body.composeINT32(loBet);
		_body.composeINT32(hiBet);
		_body.composeINT32(ante);
		_body.composeINT32(cap);
		_body.composeString(currency);
		_body.composeINT32(minChipsLimit);
		_body.composeINT32(maxBuyIn);
		_body.composeUINT32(visibilityMask);
		_body.composeINT32(defaultBuyIn);
		_body.composeString(specialName);
		_body.composeBOOL(countryRestrictionInverted);
		restrictedCountries.composeMsg(_body);
		_body.composeString(replayerAddress);
		_body.composeString(replayerInstance);
		_body.composeINT8(minPlayersPerTable);
		_body.composeBOOL(isPasswordProtected);
		_body.composeINT32(poolBlockMinHands);
		poolBlockTimePenalty.composeMsg(_body);
		_body.composeUINT32(flags);
		_body.composeUINT64(flags2);
		_body.composeBOOL(isPM);
		_body.composeUINT32(scalePM);
		tableStakes.composeMsg(_body);
		variableAntes.composeMsg(_body);
		visibilityMaskEx.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::SeatFinderStaticDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(id);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(structure);
	_parser0.parseBYTE(isHiLo);
	_parser0.parseBYTE(maxPlayersPerTable);
	_parser0.parseINT32(loBet);
	_parser0.parseINT32(hiBet);
	_parser0.parseINT32(ante);
	_parser0.parseINT32(cap);
	_parser0.parseStringP(currency);
	_parser0.parseINT32(minChipsLimit);
	_parser0.parseINT32(maxBuyIn);
	_parser0.parseUINT32(visibilityMask);
	_parser0.parseINT32(defaultBuyIn);
	_parser0.parseStringP(specialName);
	_parser0.parseBOOL(countryRestrictionInverted);
	restrictedCountries.parseMsg(_parser0);
	_parser0.parseStringP(replayerAddress);
	_parser0.parseStringP(replayerInstance);
	_parser0.parseINT8(minPlayersPerTable);
	_parser0.parseBOOL(isPasswordProtected);
	_parser0.parseINT32(poolBlockMinHands);
	poolBlockTimePenalty.parseMsg(_parser0);
	_parser0.parseUINT32(flags);
	_parser0.parseUINT64(flags2);
	_parser0.parseBOOL(isPM);
	_parser0.parseUINT32(scalePM);
	if(_parser0.parseEnded()) return;
	tableStakes.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	variableAntes.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	visibilityMaskEx.parseMsg(_parser0);
}

/*static*/ void MLobby::cli::SeatFinderStaticDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 id; _parser0.parseUINT32(id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser0.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE maxPlayersPerTable; _parser0.parseBYTE(maxPlayersPerTable);
	AtfValidator::validateInt(_descr, "maxPlayersPerTable", maxPlayersPerTable, _checker, __FILE__, __LINE__);
	INT32 loBet; _parser0.parseINT32(loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	INT32 hiBet; _parser0.parseINT32(hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	INT32 ante; _parser0.parseINT32(ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	INT32 cap; _parser0.parseINT32(cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT32 minChipsLimit; _parser0.parseINT32(minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	INT32 maxBuyIn; _parser0.parseINT32(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	UINT32 visibilityMask; _parser0.parseUINT32(visibilityMask);
	AtfValidator::validateInt(_descr, "visibilityMask", visibilityMask, _checker, __FILE__, __LINE__);
	INT32 defaultBuyIn; _parser0.parseINT32(defaultBuyIn);
	AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "specialName"); size_t szSpecialName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "specialName", szSpecialName, _checker, __FILE__, __LINE__);
	bool countryRestrictionInverted; _parser0.parseBOOL(countryRestrictionInverted);
	AtfValidator::validateInt(_descr, "countryRestrictionInverted", countryRestrictionInverted, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szRestrictedCountries = ThinAtf::LAtfVector< PString, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("restrictedCountries"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "restrictedCountries", szRestrictedCountries, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "replayerAddress"); size_t szReplayerAddress = strlen(_dummy);
	AtfValidator::validateInt(_descr, "replayerAddress", szReplayerAddress, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "replayerInstance"); size_t szReplayerInstance = strlen(_dummy);
	AtfValidator::validateInt(_descr, "replayerInstance", szReplayerInstance, _checker, __FILE__, __LINE__);
	INT8 minPlayersPerTable; _parser0.parseINT8(minPlayersPerTable);
	AtfValidator::validateInt(_descr, "minPlayersPerTable", minPlayersPerTable, _checker, __FILE__, __LINE__);
	bool isPasswordProtected; _parser0.parseBOOL(isPasswordProtected);
	AtfValidator::validateInt(_descr, "isPasswordProtected", isPasswordProtected, _checker, __FILE__, __LINE__);
	INT32 poolBlockMinHands; _parser0.parseINT32(poolBlockMinHands);
	AtfValidator::validateInt(_descr, "poolBlockMinHands", poolBlockMinHands, _checker, __FILE__, __LINE__);
	int szPoolBlockTimePenalty = ThinAtf::LAtfVector< INT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("poolBlockTimePenalty"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "poolBlockTimePenalty", szPoolBlockTimePenalty, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser0.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT64 flags2; _parser0.parseUINT64(flags2);
	AtfValidator::validateUint(_descr, "flags2", flags2, _checker, __FILE__, __LINE__);
	bool isPM; _parser0.parseBOOL(isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser0.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	TableCommonThin::TableStakes::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tableStakes"), _fieldsWithUnparsedContent);
	if(_parser0.parseEnded()) return;
	int szVariableAntes = ThinAtf::LAtfVector< INT64, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("variableAntes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "variableAntes", szVariableAntes, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("visibilityMaskEx"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SeatFinderDynaDataStruct
//=================================================================

MLobby::cli::SeatFinderDynaDataStruct::SeatFinderDynaDataStruct()
{
	clear();
}

void MLobby::cli::SeatFinderDynaDataStruct::clear()
{
	handsPerHour = 0;
	avgPotSize = 0;
	avgStackSize = 0;
	numPlayers = 0;
	numTables = 0;
	numFullTables = 0;
}

bool MLobby::cli::SeatFinderDynaDataStruct::equals(const SeatFinderDynaDataStruct& _o) const
{
	return handsPerHour == _o.handsPerHour &&
		avgPotSize == _o.avgPotSize &&
		avgStackSize == _o.avgStackSize &&
		numPlayers == _o.numPlayers &&
		numTables == _o.numTables &&
		numFullTables == _o.numFullTables;
}

const char *MLobby::cli::SeatFinderDynaDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("handsPerHour=");
	_buf.appendInt(handsPerHour);
	_buf.append(',');
	_buf.append("avgPotSize=");
	_buf.appendInt(avgPotSize);
	_buf.append(',');
	_buf.append("avgStackSize=");
	_buf.appendInt(avgStackSize);
	_buf.append(',');
	_buf.append("numPlayers=");
	_buf.appendInt(numPlayers);
	_buf.append(',');
	_buf.append("numTables=");
	_buf.appendInt(numTables);
	_buf.append(',');
	_buf.append("numFullTables=");
	_buf.appendInt(numFullTables);
	_buf.append('}');
	return _buf.c_str();
}

void MLobby::cli::SeatFinderDynaDataStruct::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(SeatFinderDynaDataStruct())) // not empty
	{
		_body.composeINT32(handsPerHour);
		_body.composeINT32(avgPotSize);
		_body.composeINT32(avgStackSize);
		_body.composeINT32(numPlayers);
		_body.composeINT32(numTables);
		_body.composeINT32(numFullTables);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::SeatFinderDynaDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(handsPerHour);
	_parser0.parseINT32(avgPotSize);
	_parser0.parseINT32(avgStackSize);
	_parser0.parseINT32(numPlayers);
	_parser0.parseINT32(numTables);
	_parser0.parseINT32(numFullTables);
}

/*static*/ void MLobby::cli::SeatFinderDynaDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 handsPerHour; _parser0.parseINT32(handsPerHour);
	AtfValidator::validateInt(_descr, "handsPerHour", handsPerHour, _checker, __FILE__, __LINE__);
	INT32 avgPotSize; _parser0.parseINT32(avgPotSize);
	AtfValidator::validateInt(_descr, "avgPotSize", avgPotSize, _checker, __FILE__, __LINE__);
	INT32 avgStackSize; _parser0.parseINT32(avgStackSize);
	AtfValidator::validateInt(_descr, "avgStackSize", avgStackSize, _checker, __FILE__, __LINE__);
	INT32 numPlayers; _parser0.parseINT32(numPlayers);
	AtfValidator::validateInt(_descr, "numPlayers", numPlayers, _checker, __FILE__, __LINE__);
	INT32 numTables; _parser0.parseINT32(numTables);
	AtfValidator::validateInt(_descr, "numTables", numTables, _checker, __FILE__, __LINE__);
	INT32 numFullTables; _parser0.parseINT32(numFullTables);
	AtfValidator::validateInt(_descr, "numFullTables", numFullTables, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SeatFinderDataStruct
//=================================================================

MLobby::cli::SeatFinderDataStruct::SeatFinderDataStruct()
{
	clear();
}

void MLobby::cli::SeatFinderDataStruct::clear()
{
	staticData.clear();
	dynamicData.clear();
}

bool MLobby::cli::SeatFinderDataStruct::equals(const SeatFinderDataStruct& _o) const
{
	return staticData.equals(_o.staticData) &&
		dynamicData.equals(_o.dynamicData);
}

const char *MLobby::cli::SeatFinderDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("staticData=");
	staticData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("dynamicData=");
	dynamicData.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MLobby::cli::SeatFinderDataStruct::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(SeatFinderDataStruct())) // not empty
	{
		staticData.composeMsg(_body);
		dynamicData.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::SeatFinderDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	staticData.parseMsg(_parser0);
	dynamicData.parseMsg(_parser0);
}

/*static*/ void MLobby::cli::SeatFinderDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	SeatFinderStaticDataStruct::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("staticData"), _fieldsWithUnparsedContent);
	SeatFinderDynaDataStruct::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("dynamicData"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES
//=================================================================

MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES::clear()
{
	filter.clear();
	maxItems = 0;
	excludedFinders.clear();
	context = 0;
	installId.clear();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES::equals(const Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES& _o) const
{
	return filter.equals(_o.filter) &&
		maxItems == _o.maxItems &&
		excludedFinders.equals(_o.excludedFinders) &&
		context == _o.context &&
		installId.equals(_o.installId);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_MORPH_LOBBIES).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("maxItems=");
	_buf.appendUint(maxItems);
	_buf.append(',');
	_buf.append("excludedFinders=");
	excludedFinders.toTraceString(_buf);
	_buf.append(',');
	_buf.append("context=");
	_buf.appendUint(context);
	_buf.append(',');
	_buf.append("installId=");
	_buf.append(installId);
	return _buf.c_str();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES::composeMsg(CommMsgBody& _msg) const
{
	filter.composeMsg(_msg);
	_msg.composeUINT32(maxItems);
	excludedFinders.composeMsg(_msg);
	_msg.composeUINT32(context);
	_msg.composeString(installId);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	_parser.parseUINT32(maxItems);
	excludedFinders.parseMsg(_parser);
	_parser.parseUINT32(context);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(installId);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_MORPH_LOBBIES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	PString _descbuf;
	MorphLobbySelectionFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	UINT32 maxItems; _parser.parseUINT32(maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
	int szExcludedFinders = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("excludedFinders"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "excludedFinders", szExcludedFinders, 1024, _checker, __FILE__, __LINE__);
	UINT32 context; _parser.parseUINT32(context);
	AtfValidator::validateInt(_descr, "context", context, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "installId"); size_t szInstallId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "installId", szInstallId, 128, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY
//=================================================================

MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY::clear()
{
	totalItems = 0;
	sf.clear();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY::equals(const Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY& _o) const
{
	return totalItems == _o.totalItems &&
		sf.equals(_o.sf);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY).append(")");
	_buf.append(',');
	_buf.append("totalItems=");
	_buf.appendUint(totalItems);
	_buf.append(',');
	_buf.append("sf=");
	sf.toTraceString(_buf);
	return _buf.c_str();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(totalItems);
	sf.composeMsg(_msg);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(totalItems);
	sf.parseMsg(_parser);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 totalItems; _parser.parseUINT32(totalItems);
	AtfValidator::validateInt(_descr, "totalItems", totalItems, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szSf = ThinAtf::LAtfVector< SeatFinderStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sf"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sf", szSf, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES
//=================================================================

MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES::clear()
{
	filter.clear();
	maxItems = 0;
	excludedFinders.clear();
	context = 0;
	installId.clear();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES::equals(const Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES& _o) const
{
	return filter.equals(_o.filter) &&
		maxItems == _o.maxItems &&
		excludedFinders.equals(_o.excludedFinders) &&
		context == _o.context &&
		installId.equals(_o.installId);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_HYBRID_GAMES).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("maxItems=");
	_buf.appendUint(maxItems);
	_buf.append(',');
	_buf.append("excludedFinders=");
	excludedFinders.toTraceString(_buf);
	_buf.append(',');
	_buf.append("context=");
	_buf.appendUint(context);
	_buf.append(',');
	_buf.append("installId=");
	_buf.append(installId);
	return _buf.c_str();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES::composeMsg(CommMsgBody& _msg) const
{
	filter.composeMsg(_msg);
	_msg.composeUINT32(maxItems);
	excludedFinders.composeMsg(_msg);
	_msg.composeUINT32(context);
	_msg.composeString(installId);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	_parser.parseUINT32(maxItems);
	excludedFinders.parseMsg(_parser);
	_parser.parseUINT32(context);
	_parser.parseStringP(installId);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_HYBRID_GAMES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	PString _descbuf;
	HybridLobbySelectionFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	UINT32 maxItems; _parser.parseUINT32(maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
	int szExcludedFinders = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("excludedFinders"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "excludedFinders", szExcludedFinders, 1024, _checker, __FILE__, __LINE__);
	UINT32 context; _parser.parseUINT32(context);
	AtfValidator::validateInt(_descr, "context", context, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "installId"); size_t szInstallId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "installId", szInstallId, 128, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY
//=================================================================

MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY::clear()
{
	totalItems = 0;
	sfs.clear();
	blitzes.clear();
	tableTypes.clear();
	gameOrder.clear();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY::equals(const Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY& _o) const
{
	return totalItems == _o.totalItems &&
		sfs.equals(_o.sfs) &&
		blitzes.equals(_o.blitzes) &&
		tableTypes.equals(_o.tableTypes) &&
		gameOrder.equals(_o.gameOrder);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY).append(")");
	_buf.append(',');
	_buf.append("totalItems=");
	_buf.appendUint(totalItems);
	_buf.append(',');
	_buf.append("sfs=");
	sfs.toTraceString(_buf);
	_buf.append(',');
	_buf.append("blitzes=");
	blitzes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableTypes=");
	tableTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameOrder=");
	gameOrder.toTraceString(_buf);
	return _buf.c_str();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(totalItems);
	sfs.composeMsg(_msg);
	blitzes.composeMsg(_msg);
	tableTypes.composeMsg(_msg);
	gameOrder.composeMsg(_msg);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(totalItems);
	sfs.parseMsg(_parser);
	blitzes.parseMsg(_parser);
	tableTypes.parseMsg(_parser);
	gameOrder.parseMsg(_parser);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 totalItems; _parser.parseUINT32(totalItems);
	AtfValidator::validateInt(_descr, "totalItems", totalItems, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szSfs = ThinAtf::LAtfVector< SeatFinderDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sfs"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sfs", szSfs, _checker, __FILE__, __LINE__);
	int szBlitzes = ThinAtf::LAtfVector< ZoomDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("blitzes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "blitzes", szBlitzes, _checker, __FILE__, __LINE__);
	int szTableTypes = ThinAtf::LAtfVector< TableTypeDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tableTypes", szTableTypes, _checker, __FILE__, __LINE__);
	int szGameOrder = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("gameOrder"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "gameOrder", szGameOrder, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE
//=================================================================

MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE::clear()
{
	tableTypeId = 0;
	maxItems = 0;
	order = 0;
	context = 0;
	installId.clear();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE::equals(const Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE& _o) const
{
	return tableTypeId == _o.tableTypeId &&
		maxItems == _o.maxItems &&
		order == _o.order &&
		context == _o.context &&
		installId.equals(_o.installId);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_RING_GAME_BY_TYPE).append(")");
	_buf.append(',');
	_buf.append("tableTypeId=");
	_buf.appendUint(tableTypeId);
	_buf.append(',');
	_buf.append("maxItems=");
	_buf.appendUint(maxItems);
	_buf.append(',');
	_buf.append("order=");
	_buf.appendUint(order);
	_buf.append(',');
	_buf.append("context=");
	_buf.appendUint(context);
	_buf.append(',');
	_buf.append("installId=");
	_buf.append(installId);
	return _buf.c_str();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(tableTypeId);
	_msg.composeUINT32(maxItems);
	_msg.composeUINT32(order);
	_msg.composeUINT32(context);
	_msg.composeString(installId);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tableTypeId);
	_parser.parseUINT32(maxItems);
	_parser.parseUINT32(order);
	_parser.parseUINT32(context);
	_parser.parseStringP(installId);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_RING_GAME_BY_TYPE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 tableTypeId; _parser.parseUINT32(tableTypeId);
	AtfValidator::validateInt(_descr, "tableTypeId", tableTypeId, _checker, __FILE__, __LINE__);
	UINT32 maxItems; _parser.parseUINT32(maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
	UINT32 order; _parser.parseUINT32(order);
	AtfValidator::validateIntMax(_descr, "order", order, SelectionFilter::TableOrder_Last, _checker, __FILE__, __LINE__);
	UINT32 context; _parser.parseUINT32(context);
	AtfValidator::validateInt(_descr, "context", context, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "installId"); size_t szInstallId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "installId", szInstallId, 128, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY
//=================================================================

MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY::clear()
{
	totalItems = 0;
	tables.clear();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY::equals(const Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY& _o) const
{
	return totalItems == _o.totalItems &&
		tables.equals(_o.tables);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY).append(")");
	_buf.append(',');
	_buf.append("totalItems=");
	_buf.appendUint(totalItems);
	_buf.append(',');
	_buf.append("tables=");
	tables.toTraceString(_buf);
	return _buf.c_str();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(totalItems);
	tables.composeMsg(_msg);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(totalItems);
	tables.parseMsg(_parser);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 totalItems; _parser.parseUINT32(totalItems);
	AtfValidator::validateInt(_descr, "totalItems", totalItems, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTables = ThinAtf::LAtfVector< RingDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tables"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tables", szTables, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ bool MLobby::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_MLOBBY_FIND_BLITZ: cli::Protocol_MSG_MLOBBY_FIND_BLITZ::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_HYBRID_GAMES: cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY: cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_MORPH_LOBBIES: cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY: cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_RINGGAMES: cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_RINGGAMES2: cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_RINGGAMES2_REPLY: cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_RING_GAME_BY_TYPE: cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY: cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES: cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2: cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY: cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_TABLE64: cli::Protocol_MSG_MLOBBY_FIND_TABLE64::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_TABLE64_2: cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_TABLE64_2_REPLY: cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_TABLE_OLD: cli::Protocol_MSG_MLOBBY_FIND_TABLE_OLD::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_TOURNAMENTS: cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_TOURNAMENTS2: cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY: cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

