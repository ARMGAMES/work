/**
 * lobby_atf_thin.cpp
 *
 * This file was auto-generated from lobby_atf.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor -thin lobby_atf.txt
 */
 
#include "lobby_atf_thin.h"

//=================================================================
//                Protocol_MSG_LOBBY_SUBMIT_STARCODE
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE::Protocol_MSG_LOBBY_SUBMIT_STARCODE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE::Protocol_MSG_LOBBY_SUBMIT_STARCODE(Protocol_MSG_LOBBY_SUBMIT_STARCODE&& _o)
	: starCode(std::move(_o.starCode))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE& Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE::operator=(Protocol_MSG_LOBBY_SUBMIT_STARCODE&& _o)
{
	if(this != &_o)
	{
		starCode = std::move(_o.starCode);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE::clear()
{
	starCode.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE::equals(const Protocol_MSG_LOBBY_SUBMIT_STARCODE& _o) const
{
	return starCode.equals(_o.starCode);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SUBMIT_STARCODE).append(")");
	_buf.append(',');
	_buf.append("starCode=");
	_buf.append(starCode);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(starCode);
}

void Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(starCode);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SUBMIT_STARCODE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "starCode"); size_t szStarCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "starCode", szStarCode, 10000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY::Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY::Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY(Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, successDescr(std::move(_o.successDescr))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY& Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY::operator=(Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		successDescr = std::move(_o.successDescr);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	successDescr.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY::equals(const Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		successDescr.equals(_o.successDescr);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SUBMIT_STARCODE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("successDescr=");
		_buf.append(successDescr);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(successDescr);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(successDescr);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SUBMIT_STARCODE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "successDescr"); size_t szSuccessDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "successDescr", szSuccessDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT(Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, doConvertBuyIn(std::move(_o.doConvertBuyIn))
	, doConvertWinnings(std::move(_o.doConvertWinnings))
{
}

Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT& Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT::operator=(Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		doConvertBuyIn = std::move(_o.doConvertBuyIn);
		doConvertWinnings = std::move(_o.doConvertWinnings);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT::clear()
{
	notUsedStr.clear();
	doConvertBuyIn = false;
	doConvertWinnings = false;
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT::equals(const Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT& _o) const
{
	return notUsedStr.equals(_o.notUsedStr) &&
		doConvertBuyIn == _o.doConvertBuyIn &&
		doConvertWinnings == _o.doConvertWinnings;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CLIENT_CURR_CONV_OPT).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("doConvertBuyIn=");
	_buf.appendUint(doConvertBuyIn);
	_buf.append(',');
	_buf.append("doConvertWinnings=");
	_buf.appendUint(doConvertWinnings);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(notUsedStr);
	_msg.composeBOOL(doConvertBuyIn);
	_msg.composeBOOL(doConvertWinnings);
}

void Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseBOOL(doConvertBuyIn);
	_parser.parseBOOL(doConvertWinnings);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLIENT_CURR_CONV_OPT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	bool doConvertBuyIn; _parser.parseBOOL(doConvertBuyIn);
	AtfValidator::validateInt(_descr, "doConvertBuyIn", doConvertBuyIn, _checker, __FILE__, __LINE__);
	bool doConvertWinnings; _parser.parseBOOL(doConvertWinnings);
	AtfValidator::validateInt(_descr, "doConvertWinnings", doConvertWinnings, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY(Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, flags2(std::move(_o.flags2))
{
}

Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY& Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY::operator=(Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		flags2 = std::move(_o.flags2);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	flags2 = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY::equals(const Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		flags2 == _o.flags2;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("flags2=");
		_buf.appendUint64(flags2);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT64(flags2);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT64(flags2);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT64 flags2; _parser.parseUINT64(flags2);
		AtfValidator::validateUint(_descr, "flags2", flags2, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION(Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION&& _o)
	: redirectorUrl(std::move(_o.redirectorUrl))
{
}

Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION& Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::operator=(Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION&& _o)
{
	if(this != &_o)
	{
		redirectorUrl = std::move(_o.redirectorUrl);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::clear()
{
	redirectorUrl.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::equals(const Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION& _o) const
{
	return redirectorUrl.equals(_o.redirectorUrl);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_INIT_NETVERIFY_SESSION).append(")");
	_buf.append(',');
	_buf.append("redirectorUrl=");
	_buf.append(redirectorUrl);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(redirectorUrl);
}

void Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(redirectorUrl);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_INIT_NETVERIFY_SESSION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "redirectorUrl"); size_t szRedirectorUrl = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "redirectorUrl", szRedirectorUrl, 10000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY(Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, url(std::move(_o.url))
{
}

Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY& Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::operator=(Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		url = std::move(_o.url);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	url.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::equals(const Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		url.equals(_o.url);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("url=");
		_buf.append(url);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(url);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(url);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "url"); size_t szUrl = strlen(_dummy);
		AtfValidator::validateInt(_descr, "url", szUrl, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT(Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, startDate(std::move(_o.startDate))
	, endDate(std::move(_o.endDate))
	, password(std::move(_o.password))
	, includeFPP(std::move(_o.includeFPP))
	, reportFormat(std::move(_o.reportFormat))
	, isHtmlForClient(std::move(_o.isHtmlForClient))
	, reportFlags(std::move(_o.reportFlags))
{
}

Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT& Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::operator=(Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		startDate = std::move(_o.startDate);
		endDate = std::move(_o.endDate);
		password = std::move(_o.password);
		includeFPP = std::move(_o.includeFPP);
		reportFormat = std::move(_o.reportFormat);
		isHtmlForClient = std::move(_o.isHtmlForClient);
		reportFlags = std::move(_o.reportFlags);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::clear()
{
	notUsedStr.clear();
	startDate.setNull();
	endDate.setNull();
	password.clear();
	includeFPP = false;
	reportFormat = 0;
	isHtmlForClient = false;
	reportFlags = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::equals(const Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT& _o) const
{
	return notUsedStr.equals(_o.notUsedStr) &&
		startDate.equals(_o.startDate) &&
		endDate.equals(_o.endDate) &&
		password.equals(_o.password) &&
		includeFPP == _o.includeFPP &&
		reportFormat == _o.reportFormat &&
		isHtmlForClient == _o.isHtmlForClient &&
		reportFlags == _o.reportFlags;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_PLAYING_HISTORY_AUDIT).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("startDate=");
	ThinAtf::AtfTempl<SrvDate>::ToTraceString(_buf, startDate);
	_buf.append(',');
	_buf.append("endDate=");
	ThinAtf::AtfTempl<SrvDate>::ToTraceString(_buf, endDate);
	_buf.append(',');
	_buf.append("password=");
	_buf.append(password);
	_buf.append(',');
	_buf.append("includeFPP=");
	_buf.appendUint(includeFPP);
	_buf.append(',');
	_buf.append("reportFormat=");
	_buf.appendUint(reportFormat);
	_buf.append(',');
	_buf.append("isHtmlForClient=");
	_buf.appendUint(isHtmlForClient);
	_buf.append(',');
	_buf.append("reportFlags=");
	_buf.appendUint(reportFlags);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(notUsedStr);
	_msg.composeSrvDate(startDate);
	_msg.composeSrvDate(endDate);
	_msg.composeString(password);
	_msg.composeBOOL(includeFPP);
	_msg.composeUINT32(reportFormat);
	_msg.composeBOOL(isHtmlForClient);
	_msg.composeUINT32(reportFlags);
}

void Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseSrvDate(startDate);
	_parser.parseSrvDate(endDate);
	_parser.parseStringP(password);
	_parser.parseBOOL(includeFPP);
	_parser.parseUINT32(reportFormat);
	_parser.parseBOOL(isHtmlForClient);
	_parser.parseUINT32(reportFlags);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_PLAYING_HISTORY_AUDIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	SrvDate startDate; _parser.parseSrvDate(startDate);
	AtfValidator::validateSrvDateTime(_descr, "startDate", startDate, _checker, __FILE__, __LINE__);
	SrvDate endDate; _parser.parseSrvDate(endDate);
	AtfValidator::validateSrvDateTime(_descr, "endDate", endDate, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "password"); size_t szPassword = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "password", szPassword, 1000, _checker, __FILE__, __LINE__);
	bool includeFPP; _parser.parseBOOL(includeFPP);
	AtfValidator::validateInt(_descr, "includeFPP", includeFPP, _checker, __FILE__, __LINE__);
	UINT32 reportFormat; _parser.parseUINT32(reportFormat);
	AtfValidator::validateIntMax(_descr, "reportFormat", reportFormat, 100, _checker, __FILE__, __LINE__);
	bool isHtmlForClient; _parser.parseBOOL(isHtmlForClient);
	AtfValidator::validateInt(_descr, "isHtmlForClient", isHtmlForClient, _checker, __FILE__, __LINE__);
	UINT32 reportFlags; _parser.parseUINT32(reportFlags);
	AtfValidator::validateInt(_descr, "reportFlags", reportFlags, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY(Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY& Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::operator=(Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::equals(const Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT(Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, startDate(std::move(_o.startDate))
	, endDate(std::move(_o.endDate))
	, password(std::move(_o.password))
	, reportFormat(std::move(_o.reportFormat))
{
}

Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT& Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::operator=(Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		startDate = std::move(_o.startDate);
		endDate = std::move(_o.endDate);
		password = std::move(_o.password);
		reportFormat = std::move(_o.reportFormat);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::clear()
{
	notUsedStr.clear();
	startDate.setNull();
	endDate.setNull();
	password.clear();
	reportFormat = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::equals(const Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT& _o) const
{
	return notUsedStr.equals(_o.notUsedStr) &&
		startDate.equals(_o.startDate) &&
		endDate.equals(_o.endDate) &&
		password.equals(_o.password) &&
		reportFormat == _o.reportFormat;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("startDate=");
	ThinAtf::AtfTempl<SrvDate>::ToTraceString(_buf, startDate);
	_buf.append(',');
	_buf.append("endDate=");
	ThinAtf::AtfTempl<SrvDate>::ToTraceString(_buf, endDate);
	_buf.append(',');
	_buf.append("password=");
	_buf.append(password);
	_buf.append(',');
	_buf.append("reportFormat=");
	_buf.appendUint(reportFormat);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(notUsedStr);
	_msg.composeSrvDate(startDate);
	_msg.composeSrvDate(endDate);
	_msg.composeString(password);
	_msg.composeUINT32(reportFormat);
}

void Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseSrvDate(startDate);
	_parser.parseSrvDate(endDate);
	_parser.parseStringP(password);
	_parser.parseUINT32(reportFormat);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	SrvDate startDate; _parser.parseSrvDate(startDate);
	AtfValidator::validateSrvDateTime(_descr, "startDate", startDate, _checker, __FILE__, __LINE__);
	SrvDate endDate; _parser.parseSrvDate(endDate);
	AtfValidator::validateSrvDateTime(_descr, "endDate", endDate, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "password"); size_t szPassword = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "password", szPassword, 1000, _checker, __FILE__, __LINE__);
	UINT32 reportFormat; _parser.parseUINT32(reportFormat);
	AtfValidator::validateIntMax(_descr, "reportFormat", reportFormat, 100, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY(Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY& Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY::operator=(Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY::equals(const Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != 0 )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode != 0 )
	{
		_msg.composeString(errDescr);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != 0 )
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CHALLENGE_QUESTION
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::Protocol_MSG_LOBBY_CHALLENGE_QUESTION()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::clear()
{
	locale = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::equals(const Protocol_MSG_LOBBY_CHALLENGE_QUESTION& _o) const
{
	return locale == _o.locale;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CHALLENGE_QUESTION).append(")");
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(locale);
}

void Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(locale);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CHALLENGE_QUESTION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    ChallengeQuestion
//=================================================================

Lobby::cli::ChallengeQuestion::ChallengeQuestion()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::ChallengeQuestion::ChallengeQuestion(ChallengeQuestion&& _o)
	: id(std::move(_o.id))
	, txt(std::move(_o.txt))
{
}

Lobby::cli::ChallengeQuestion& Lobby::cli::ChallengeQuestion::operator=(ChallengeQuestion&& _o)
{
	if(this != &_o)
	{
		id = std::move(_o.id);
		txt = std::move(_o.txt);
	}
	return *this;
}

#endif

void Lobby::cli::ChallengeQuestion::clear()
{
	id = 0;
	txt.clear();
}

bool Lobby::cli::ChallengeQuestion::equals(const ChallengeQuestion& _o) const
{
	return id == _o.id &&
		txt.equals(_o.txt);
}

const char *Lobby::cli::ChallengeQuestion::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("id=");
	_buf.appendUint(id);
	_buf.append(',');
	_buf.append("txt=");
	_buf.append(txt);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::ChallengeQuestion::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(id);
	_msg.composeString(txt);
}

void Lobby::cli::ChallengeQuestion::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(id);
	_parser.parseStringP(txt);
}

/*static*/ void Lobby::cli::ChallengeQuestion::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 id; _parser.parseUINT32(id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "txt"); size_t szTxt = strlen(_dummy);
	AtfValidator::validateInt(_descr, "txt", szTxt, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY(Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, challenges(std::move(_o.challenges))
{
}

Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY& Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::operator=(Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		challenges = std::move(_o.challenges);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	challenges.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::equals(const Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		challenges.equals(_o.challenges);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CHALLENGE_QUESTION_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("challenges=");
		challenges.toTraceString(_buf);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		challenges.composeMsg(_msg);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		challenges.parseMsg(_parser);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CHALLENGE_QUESTION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szChallenges = ThinAtf::LAtfVector< ChallengeQuestion, 2 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("challenges"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "challenges", szChallenges, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT::clear()
{
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT::equals(const Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT& _o) const
{
	return true;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_PLAYING_TIME_LIMIT).append(")");
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT::composeMsg(CommMsgBody& _msg) const
{
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_PLAYING_TIME_LIMIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY(Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, limit(std::move(_o.limit))
	, autoLimiHour(std::move(_o.autoLimiHour))
{
}

Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY& Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY::operator=(Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		limit = std::move(_o.limit);
		autoLimiHour = std::move(_o.autoLimiHour);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	limit = 0;
	autoLimiHour = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY::equals(const Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		limit == _o.limit &&
		autoLimiHour == _o.autoLimiHour;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("limit=");
		_buf.appendInt(limit);
		_buf.append(',');
		_buf.append("autoLimiHour=");
		_buf.appendUint(autoLimiHour);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeINT32(limit);
		_msg.composeUINT32(autoLimiHour);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseINT32(limit);
		_parser.parseUINT32(autoLimiHour);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 limit; _parser.parseINT32(limit);
		AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
		UINT32 autoLimiHour; _parser.parseUINT32(autoLimiHour);
		AtfValidator::validateInt(_descr, "autoLimiHour", autoLimiHour, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT::clear()
{
	limit = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT::equals(const Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT& _o) const
{
	return limit == _o.limit;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SET_PLAYING_TIME_LIMIT).append(")");
	_buf.append(',');
	_buf.append("limit=");
	_buf.appendInt(limit);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(limit);
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(limit);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_PLAYING_TIME_LIMIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 limit; _parser.parseINT32(limit);
	AtfValidator::validateIntRange(_descr, "limit", limit, -1, 100000000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY(Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, effectiveNow(std::move(_o.effectiveNow))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY& Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY::operator=(Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		effectiveNow = std::move(_o.effectiveNow);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	effectiveNow = false;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY::equals(const Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		effectiveNow == _o.effectiveNow;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("effectiveNow=");
		_buf.appendUint(effectiveNow);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeBOOL(effectiveNow);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseBOOL(effectiveNow);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool effectiveNow; _parser.parseBOOL(effectiveNow);
		AtfValidator::validateInt(_descr, "effectiveNow", effectiveNow, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL::clear()
{
}

bool Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL::equals(const Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL& _o) const
{
	return true;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_RESEND_ACTIVATION_EMAIL).append(")");
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL::composeMsg(CommMsgBody& _msg) const
{
}

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_RESEND_ACTIVATION_EMAIL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY(Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY& Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY::operator=(Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY::equals(const Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION(Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION&& _o)
	: unusedStr(std::move(_o.unusedStr))
	, newCode(std::move(_o.newCode))
{
}

Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION& Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION::operator=(Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION&& _o)
{
	if(this != &_o)
	{
		unusedStr = std::move(_o.unusedStr);
		newCode = std::move(_o.newCode);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION::clear()
{
	unusedStr.clear();
	newCode = false;
}

bool Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION::equals(const Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION& _o) const
{
	return unusedStr.equals(_o.unusedStr) &&
		newCode == _o.newCode;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_RESEND_MOBILE_VALIDATION).append(")");
	_buf.append(',');
	_buf.append("unusedStr=");
	_buf.append(unusedStr);
	_buf.append(',');
	_buf.append("newCode=");
	_buf.appendUint(newCode);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(unusedStr);
	_msg.composeBOOL(newCode);
}

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(unusedStr);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(newCode);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_RESEND_MOBILE_VALIDATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "unusedStr"); size_t szUnusedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "unusedStr", szUnusedStr, 20, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool newCode; _parser.parseBOOL(newCode);
	AtfValidator::validateInt(_descr, "newCode", newCode, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY(Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY& Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY::operator=(Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY::equals(const Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errDesc=");
	_buf.append(errDesc);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errDesc);
}

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(errDesc);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::clear()
{
	optionType = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::equals(const Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS& _o) const
{
	return optionType == _o.optionType;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_CLIENT_OPTIONS).append(")");
	_buf.append(',');
	_buf.append("optionType=");
	_buf.appendUint(optionType);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(optionType);
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(optionType);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_CLIENT_OPTIONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(_parser.parseEnded()) return;
	UINT32 optionType; _parser.parseUINT32(optionType);
	AtfValidator::validateIntRange(_descr, "optionType", optionType, eClientCustomOptionsBegin, eClientCustomOptionsEnd, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY(Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, encodedPropStr(std::move(_o.encodedPropStr))
{
}

Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY& Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::operator=(Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		encodedPropStr = std::move(_o.encodedPropStr);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	encodedPropStr.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::equals(const Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		encodedPropStr.size() == _o.encodedPropStr.size() && memcmp(encodedPropStr.ptr(), _o.encodedPropStr.ptr(), encodedPropStr.size()) == 0;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("encodedPropStr=");
		ThinAtf::AtfTempl<PBlock>::ToTraceString(_buf, encodedPropStr);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		CommMsgBody _msg0;
		_msg0._composeVarBlock(encodedPropStr.ptr(), encodedPropStr.size());
		_msg.composeMsgBody(_msg0);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		parseAnonymousMsgBody0(_parser);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parsePBlock(encodedPropStr);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const BYTE* encodedPropStr; size_t szEncodedPropStr; _parser0._parseVarBlock(encodedPropStr, szEncodedPropStr);  /*encodedPropStr*/
	AtfValidator::validateInt(_descr, "encodedPropStr", szEncodedPropStr, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS(Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS&& _o)
	: body(std::move(_o.body))
	, propType(std::move(_o.propType))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS& Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::operator=(Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS&& _o)
{
	if(this != &_o)
	{
		body = std::move(_o.body);
		propType = std::move(_o.propType);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::clear()
{
	body.clear();
	propType = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::equals(const Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS& _o) const
{
	return body.equals(_o.body) &&
		propType == _o.propType;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SET_CLIENT_OPTIONS).append(")");
	_buf.append(',');
	_buf.append("body=");
	body.toTraceString(_buf);
	_buf.append(',');
	_buf.append("propType=");
	_buf.appendUint(propType);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeMsgBody(body);
	_msg.composeUINT32(propType);
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseMsgBody(body);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(propType);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_CLIENT_OPTIONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	size_t szBody; _parser.skipMsgBody(szBody);  /*body*/
	AtfValidator::validateIntMax(_descr, "body", szBody, USER_PROPERTYSTR_LEN, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 propType; _parser.parseUINT32(propType);
	AtfValidator::validateIntRange(_descr, "propType", propType, eClientCustomOptionsBegin, eClientCustomOptionsEnd, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY(Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY& Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::operator=(Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::equals(const Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    WaitOnTable
//=================================================================

Lobby::cli::WaitOnTable::WaitOnTable()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::WaitOnTable::WaitOnTable(WaitOnTable&& _o)
	: tableId32(std::move(_o.tableId32))
	, clubId(std::move(_o.clubId))
	, server(std::move(_o.server))
	, serverObject(std::move(_o.serverObject))
	, tableName(std::move(_o.tableName))
	, specialName(std::move(_o.specialName))
	, game(std::move(_o.game))
	, limit(std::move(_o.limit))
	, isHiLo(std::move(_o.isHiLo))
	, currency(std::move(_o.currency))
	, stakeLo(std::move(_o.stakeLo))
	, stakeHi(std::move(_o.stakeHi))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, numPlayers(std::move(_o.numPlayers))
	, maxPlayers(std::move(_o.maxPlayers))
	, isOneOnOne(std::move(_o.isOneOnOne))
	, waitListSize(std::move(_o.waitListSize))
	, waitListPos(std::move(_o.waitListPos))
	, scalePM(std::move(_o.scalePM))
	, tableId(std::move(_o.tableId))
{
}

Lobby::cli::WaitOnTable& Lobby::cli::WaitOnTable::operator=(WaitOnTable&& _o)
{
	if(this != &_o)
	{
		tableId32 = std::move(_o.tableId32);
		clubId = std::move(_o.clubId);
		server = std::move(_o.server);
		serverObject = std::move(_o.serverObject);
		tableName = std::move(_o.tableName);
		specialName = std::move(_o.specialName);
		game = std::move(_o.game);
		limit = std::move(_o.limit);
		isHiLo = std::move(_o.isHiLo);
		currency = std::move(_o.currency);
		stakeLo = std::move(_o.stakeLo);
		stakeHi = std::move(_o.stakeHi);
		isPlayMoney = std::move(_o.isPlayMoney);
		numPlayers = std::move(_o.numPlayers);
		maxPlayers = std::move(_o.maxPlayers);
		isOneOnOne = std::move(_o.isOneOnOne);
		waitListSize = std::move(_o.waitListSize);
		waitListPos = std::move(_o.waitListPos);
		scalePM = std::move(_o.scalePM);
		tableId = std::move(_o.tableId);
	}
	return *this;
}

#endif

void Lobby::cli::WaitOnTable::clear()
{
	tableId32 = 0;
	clubId = 0;
	server.clear();
	serverObject.clear();
	tableName.clear();
	specialName.clear();
	game = 0;
	limit = 0;
	isHiLo = false;
	currency.clear();
	stakeLo = 0;
	stakeHi = 0;
	isPlayMoney = false;
	numPlayers = 0;
	maxPlayers = 0;
	isOneOnOne = false;
	waitListSize = 0;
	waitListPos = 0;
	scalePM = 0;
	tableId = 0;
}

bool Lobby::cli::WaitOnTable::equals(const WaitOnTable& _o) const
{
	return tableId32 == _o.tableId32 &&
		clubId == _o.clubId &&
		server.equals(_o.server) &&
		serverObject.equals(_o.serverObject) &&
		tableName.equals(_o.tableName) &&
		specialName.equals(_o.specialName) &&
		game == _o.game &&
		limit == _o.limit &&
		isHiLo == _o.isHiLo &&
		currency.equals(_o.currency) &&
		stakeLo == _o.stakeLo &&
		stakeHi == _o.stakeHi &&
		isPlayMoney == _o.isPlayMoney &&
		numPlayers == _o.numPlayers &&
		maxPlayers == _o.maxPlayers &&
		isOneOnOne == _o.isOneOnOne &&
		waitListSize == _o.waitListSize &&
		waitListPos == _o.waitListPos &&
		scalePM == _o.scalePM &&
		tableId == _o.tableId;
}

const char *Lobby::cli::WaitOnTable::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tableId32=");
	_buf.appendUint(tableId32);
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("serverObject=");
	_buf.append(serverObject);
	_buf.append(',');
	_buf.append("tableName=");
	_buf.append(tableName);
	_buf.append(',');
	_buf.append("specialName=");
	_buf.append(specialName);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("limit=");
	_buf.appendUint(limit);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("stakeLo=");
	_buf.appendUint(stakeLo);
	_buf.append(',');
	_buf.append("stakeHi=");
	_buf.appendUint(stakeHi);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("numPlayers=");
	_buf.appendUint(numPlayers);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendUint(maxPlayers);
	_buf.append(',');
	_buf.append("isOneOnOne=");
	_buf.appendUint(isOneOnOne);
	_buf.append(',');
	_buf.append("waitListSize=");
	_buf.appendUint(waitListSize);
	_buf.append(',');
	_buf.append("waitListPos=");
	_buf.appendUint(waitListPos);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::WaitOnTable::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(WaitOnTable())) // not empty
	{
		_body.composeUINT32(tableId32);
		_body.composeUINT32(clubId);
		_body.composeString(server);
		_body.composeString(serverObject);
		_body.composeString(tableName);
		_body.composeString(specialName);
		_body.composeBYTE(game);
		_body.composeBYTE(limit);
		_body.composeBOOL(isHiLo);
		_body.composeString(currency);
		_body.composeUINT32(stakeLo);
		_body.composeUINT32(stakeHi);
		_body.composeBOOL(isPlayMoney);
		_body.composeUINT32(numPlayers);
		_body.composeUINT32(maxPlayers);
		_body.composeBOOL(isOneOnOne);
		_body.composeUINT32(waitListSize);
		_body.composeUINT32(waitListPos);
		_body.composeUINT32(scalePM);
		_body.composeUINT64(tableId);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::cli::WaitOnTable::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(tableId32);
	_parser0.parseUINT32(clubId);
	_parser0.parseStringP(server);
	_parser0.parseStringP(serverObject);
	_parser0.parseStringP(tableName);
	_parser0.parseStringP(specialName);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(limit);
	_parser0.parseBOOL(isHiLo);
	_parser0.parseStringP(currency);
	_parser0.parseUINT32(stakeLo);
	_parser0.parseUINT32(stakeHi);
	_parser0.parseBOOL(isPlayMoney);
	_parser0.parseUINT32(numPlayers);
	_parser0.parseUINT32(maxPlayers);
	_parser0.parseBOOL(isOneOnOne);
	_parser0.parseUINT32(waitListSize);
	_parser0.parseUINT32(waitListPos);
	_parser0.parseUINT32(scalePM);
	_parser0.parseUINT64(tableId);
}

/*static*/ void Lobby::cli::WaitOnTable::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 tableId32; _parser0.parseUINT32(tableId32);
	AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
	UINT32 clubId; _parser0.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "serverObject"); size_t szServerObject = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObject", szServerObject, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "tableName"); size_t szTableName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tableName", szTableName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "specialName"); size_t szSpecialName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "specialName", szSpecialName, _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE limit; _parser0.parseBYTE(limit);
	AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
	bool isHiLo; _parser0.parseBOOL(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 stakeLo; _parser0.parseUINT32(stakeLo);
	AtfValidator::validateInt(_descr, "stakeLo", stakeLo, _checker, __FILE__, __LINE__);
	UINT32 stakeHi; _parser0.parseUINT32(stakeHi);
	AtfValidator::validateInt(_descr, "stakeHi", stakeHi, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _parser0.parseBOOL(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 numPlayers; _parser0.parseUINT32(numPlayers);
	AtfValidator::validateInt(_descr, "numPlayers", numPlayers, _checker, __FILE__, __LINE__);
	UINT32 maxPlayers; _parser0.parseUINT32(maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	bool isOneOnOne; _parser0.parseBOOL(isOneOnOne);
	AtfValidator::validateInt(_descr, "isOneOnOne", isOneOnOne, _checker, __FILE__, __LINE__);
	UINT32 waitListSize; _parser0.parseUINT32(waitListSize);
	AtfValidator::validateInt(_descr, "waitListSize", waitListSize, _checker, __FILE__, __LINE__);
	UINT32 waitListPos; _parser0.parseUINT32(waitListPos);
	AtfValidator::validateInt(_descr, "waitListPos", waitListPos, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser0.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT64 tableId; _parser0.parseUINT64(tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBY_WAIT_ON_TABLES
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES::Protocol_MSG_LOBBY_WAIT_ON_TABLES()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES::clear()
{
}

bool Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES::equals(const Protocol_MSG_LOBBY_WAIT_ON_TABLES& _o) const
{
	return true;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_WAIT_ON_TABLES).append(")");
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES::composeMsg(CommMsgBody& _msg) const
{
}

void Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_WAIT_ON_TABLES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY::Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY::Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY(Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, waitOnTables(std::move(_o.waitOnTables))
{
}

Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY& Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY::operator=(Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		waitOnTables = std::move(_o.waitOnTables);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	waitOnTables.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY::equals(const Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		waitOnTables.equals(_o.waitOnTables);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_WAIT_ON_TABLES_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("waitOnTables=");
		waitOnTables.toTraceString(_buf);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		waitOnTables.composeMsg(_msg);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		waitOnTables.parseMsg(_parser);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_WAIT_ON_TABLES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szWaitOnTables = ThinAtf::LAtfVector< WaitOnTable, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("waitOnTables"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "waitOnTables", szWaitOnTables, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND(Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND&& _o)
	: tournamentName(std::move(_o.tournamentName))
	, tableName(std::move(_o.tableName))
	, nick(std::move(_o.nick))
	, handText(std::move(_o.handText))
	, heroTheme(std::move(_o.heroTheme))
	, opponentTheme(std::move(_o.opponentTheme))
	, longText(std::move(_o.longText))
	, shortText(std::move(_o.shortText))
	, showHoleCards(std::move(_o.showHoleCards))
	, showRealTableName(std::move(_o.showRealTableName))
	, showAmountInBB(std::move(_o.showAmountInBB))
	, showRealNicks(std::move(_o.showRealNicks))
	, showHandId(std::move(_o.showHandId))
	, showHeroNick(std::move(_o.showHeroNick))
	, typeOfShow(std::move(_o.typeOfShow))
	, language(std::move(_o.language))
	, methodOfShare(std::move(_o.methodOfShare))
	, client(std::move(_o.client))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND& Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND::operator=(Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND&& _o)
{
	if(this != &_o)
	{
		tournamentName = std::move(_o.tournamentName);
		tableName = std::move(_o.tableName);
		nick = std::move(_o.nick);
		handText = std::move(_o.handText);
		heroTheme = std::move(_o.heroTheme);
		opponentTheme = std::move(_o.opponentTheme);
		longText = std::move(_o.longText);
		shortText = std::move(_o.shortText);
		showHoleCards = std::move(_o.showHoleCards);
		showRealTableName = std::move(_o.showRealTableName);
		showAmountInBB = std::move(_o.showAmountInBB);
		showRealNicks = std::move(_o.showRealNicks);
		showHandId = std::move(_o.showHandId);
		showHeroNick = std::move(_o.showHeroNick);
		typeOfShow = std::move(_o.typeOfShow);
		language = std::move(_o.language);
		methodOfShare = std::move(_o.methodOfShare);
		client = std::move(_o.client);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND::clear()
{
	tournamentName.clear();
	tableName.clear();
	nick.clear();
	handText.clear();
	heroTheme.clear();
	opponentTheme.clear();
	longText.clear();
	shortText.clear();
	showHoleCards = false;
	showRealTableName = false;
	showAmountInBB = false;
	showRealNicks = false;
	showHandId = false;
	showHeroNick = false;
	typeOfShow.clear();
	language.clear();
	methodOfShare.clear();
	client.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND::equals(const Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND& _o) const
{
	return tournamentName.equals(_o.tournamentName) &&
		tableName.equals(_o.tableName) &&
		nick.equals(_o.nick) &&
		handText.equals(_o.handText) &&
		heroTheme.equals(_o.heroTheme) &&
		opponentTheme.equals(_o.opponentTheme) &&
		longText.equals(_o.longText) &&
		shortText.equals(_o.shortText) &&
		showHoleCards == _o.showHoleCards &&
		showRealTableName == _o.showRealTableName &&
		showAmountInBB == _o.showAmountInBB &&
		showRealNicks == _o.showRealNicks &&
		showHandId == _o.showHandId &&
		showHeroNick == _o.showHeroNick &&
		typeOfShow.equals(_o.typeOfShow) &&
		language.equals(_o.language) &&
		methodOfShare.equals(_o.methodOfShare) &&
		client.equals(_o.client);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SOCIAL_SHARE_HAND).append(")");
	_buf.append(',');
	_buf.append("tournamentName=");
	_buf.append(tournamentName);
	_buf.append(',');
	_buf.append("tableName=");
	_buf.append(tableName);
	_buf.append(',');
	_buf.append("nick=");
	_buf.append(nick);
	_buf.append(',');
	_buf.append("handText=");
	_buf.append(handText);
	_buf.append(',');
	_buf.append("heroTheme=");
	_buf.append(heroTheme);
	_buf.append(',');
	_buf.append("opponentTheme=");
	_buf.append(opponentTheme);
	_buf.append(',');
	_buf.append("longText=");
	_buf.append(longText);
	_buf.append(',');
	_buf.append("shortText=");
	_buf.append(shortText);
	_buf.append(',');
	_buf.append("showHoleCards=");
	_buf.appendUint(showHoleCards);
	_buf.append(',');
	_buf.append("showRealTableName=");
	_buf.appendUint(showRealTableName);
	_buf.append(',');
	_buf.append("showAmountInBB=");
	_buf.appendUint(showAmountInBB);
	_buf.append(',');
	_buf.append("showRealNicks=");
	_buf.appendUint(showRealNicks);
	_buf.append(',');
	_buf.append("showHandId=");
	_buf.appendUint(showHandId);
	_buf.append(',');
	_buf.append("showHeroNick=");
	_buf.appendUint(showHeroNick);
	_buf.append(',');
	_buf.append("typeOfShow=");
	_buf.append(typeOfShow);
	_buf.append(',');
	_buf.append("language=");
	_buf.append(language);
	_buf.append(',');
	_buf.append("methodOfShare=");
	_buf.append(methodOfShare);
	_buf.append(',');
	_buf.append("client=");
	_buf.append(client);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(tournamentName);
	_msg.composeString(tableName);
	_msg.composeString(nick);
	_msg.composeString(handText);
	_msg.composeString(heroTheme);
	_msg.composeString(opponentTheme);
	_msg.composeString(longText);
	_msg.composeString(shortText);
	_msg.composeBOOL(showHoleCards);
	_msg.composeBOOL(showRealTableName);
	_msg.composeBOOL(showAmountInBB);
	_msg.composeBOOL(showRealNicks);
	_msg.composeBOOL(showHandId);
	_msg.composeBOOL(showHeroNick);
	_msg.composeString(typeOfShow);
	_msg.composeString(language);
	_msg.composeString(methodOfShare);
	_msg.composeString(client);
}

void Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(tournamentName);
	_parser.parseStringP(tableName);
	_parser.parseStringP(nick);
	_parser.parseStringP(handText);
	_parser.parseStringP(heroTheme);
	_parser.parseStringP(opponentTheme);
	_parser.parseStringP(longText);
	_parser.parseStringP(shortText);
	_parser.parseBOOL(showHoleCards);
	_parser.parseBOOL(showRealTableName);
	_parser.parseBOOL(showAmountInBB);
	_parser.parseBOOL(showRealNicks);
	_parser.parseBOOL(showHandId);
	_parser.parseBOOL(showHeroNick);
	_parser.parseStringP(typeOfShow);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(language);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(methodOfShare);
	_parser.parseStringP(client);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SOCIAL_SHARE_HAND";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "tournamentName"); size_t szTournamentName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "tournamentName", szTournamentName, 1000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "tableName"); size_t szTableName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "tableName", szTableName, 1000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "nick"); size_t szNick = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "nick", szNick, 1000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "handText"); size_t szHandText = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "handText", szHandText, 100000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "heroTheme"); size_t szHeroTheme = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "heroTheme", szHeroTheme, 1000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "opponentTheme"); size_t szOpponentTheme = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "opponentTheme", szOpponentTheme, 1000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "longText"); size_t szLongText = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "longText", szLongText, 1000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "shortText"); size_t szShortText = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "shortText", szShortText, 256, _checker, __FILE__, __LINE__);
	bool showHoleCards; _parser.parseBOOL(showHoleCards);
	AtfValidator::validateInt(_descr, "showHoleCards", showHoleCards, _checker, __FILE__, __LINE__);
	bool showRealTableName; _parser.parseBOOL(showRealTableName);
	AtfValidator::validateInt(_descr, "showRealTableName", showRealTableName, _checker, __FILE__, __LINE__);
	bool showAmountInBB; _parser.parseBOOL(showAmountInBB);
	AtfValidator::validateInt(_descr, "showAmountInBB", showAmountInBB, _checker, __FILE__, __LINE__);
	bool showRealNicks; _parser.parseBOOL(showRealNicks);
	AtfValidator::validateInt(_descr, "showRealNicks", showRealNicks, _checker, __FILE__, __LINE__);
	bool showHandId; _parser.parseBOOL(showHandId);
	AtfValidator::validateInt(_descr, "showHandId", showHandId, _checker, __FILE__, __LINE__);
	bool showHeroNick; _parser.parseBOOL(showHeroNick);
	AtfValidator::validateInt(_descr, "showHeroNick", showHeroNick, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "typeOfShow"); size_t szTypeOfShow = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "typeOfShow", szTypeOfShow, 1000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "language"); size_t szLanguage = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "language", szLanguage, 128, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "methodOfShare"); size_t szMethodOfShare = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "methodOfShare", szMethodOfShare, 1000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "client"); size_t szClient = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "client", szClient, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY(Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, encUrl(std::move(_o.encUrl))
	, psapiUrl(std::move(_o.psapiUrl))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY& Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY::operator=(Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		encUrl = std::move(_o.encUrl);
		psapiUrl = std::move(_o.psapiUrl);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	encUrl.clear();
	psapiUrl.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY::equals(const Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		encUrl.equals(_o.encUrl) &&
		psapiUrl.equals(_o.psapiUrl);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("encUrl=");
		_buf.append(encUrl);
		_buf.append(',');
		_buf.append("psapiUrl=");
		_buf.append(psapiUrl);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeString(encUrl);
		_msg.composeString(psapiUrl);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseStringP(encUrl);
		_parser.parseStringP(psapiUrl);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "encUrl"); size_t szEncUrl = strlen(_dummy);
		AtfValidator::validateInt(_descr, "encUrl", szEncUrl, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "psapiUrl"); size_t szPsapiUrl = strlen(_dummy);
		AtfValidator::validateInt(_descr, "psapiUrl", szPsapiUrl, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_BE_AVC_VALIDATE
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE::Protocol_MSG_LOBBY_BE_AVC_VALIDATE()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE::clear()
{
	avc = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE::equals(const Protocol_MSG_LOBBY_BE_AVC_VALIDATE& _o) const
{
	return avc == _o.avc;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_BE_AVC_VALIDATE).append(")");
	_buf.append(',');
	_buf.append("avc=");
	_buf.appendUint(avc);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(avc);
}

void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(avc);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_BE_AVC_VALIDATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 avc; _parser.parseUINT32(avc);
	AtfValidator::validateInt(_descr, "avc", avc, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY::Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY::Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY(Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY& Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY::operator=(Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY::equals(const Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_BE_AVC_VALIDATE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_BE_AVC_VALIDATE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_BE_AVC_RESEND
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND::Protocol_MSG_LOBBY_BE_AVC_RESEND()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND::clear()
{
}

bool Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND::equals(const Protocol_MSG_LOBBY_BE_AVC_RESEND& _o) const
{
	return true;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_BE_AVC_RESEND).append(")");
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND::composeMsg(CommMsgBody& _msg) const
{
}

void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_BE_AVC_RESEND";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY::Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY::Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY(Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY& Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY::operator=(Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY::equals(const Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_BE_AVC_RESEND_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_BE_AVC_RESEND_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN::Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN::Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN(Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN&& _o)
	: installIdDeprecated(std::move(_o.installIdDeprecated))
	, siteId(std::move(_o.siteId))
	, platformId(std::move(_o.platformId))
	, extraData(std::move(_o.extraData))
{
}

Lobby::cli::Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN& Lobby::cli::Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN::operator=(Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN&& _o)
{
	if(this != &_o)
	{
		installIdDeprecated = std::move(_o.installIdDeprecated);
		siteId = std::move(_o.siteId);
		platformId = std::move(_o.platformId);
		extraData = std::move(_o.extraData);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN::clear()
{
	installIdDeprecated.clear();
	siteId = 0;
	platformId = 0;
	extraData.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN::equals(const Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN& _o) const
{
	return installIdDeprecated.equals(_o.installIdDeprecated) &&
		siteId == _o.siteId &&
		platformId == _o.platformId &&
		extraData.equals(_o.extraData);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_REPORT_FIRST_LOGIN).append(")");
	_buf.append(',');
	_buf.append("installIdDeprecated=");
	_buf.append(installIdDeprecated);
	_buf.append(',');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("platformId=");
	_buf.appendUint(platformId);
	_buf.append(',');
	_buf.append("extraData=");
	extraData.toTraceString(_buf);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(installIdDeprecated);
	_msg.composeUINT32(siteId);
	_msg.composeUINT32(platformId);
	extraData.composeMsg(_msg);
}

void Lobby::cli::Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(installIdDeprecated);
	_parser.parseUINT32(siteId);
	_parser.parseUINT32(platformId);
	if(_parser.parseEnded()) return;
	extraData.parseMsg(_parser);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_REPORT_FIRST_LOGIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "installIdDeprecated"); size_t szInstallIdDeprecated = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "installIdDeprecated", szInstallIdDeprecated, 40, _checker, __FILE__, __LINE__);
	UINT32 siteId; _parser.parseUINT32(siteId);
	AtfValidator::validateIntMax(_descr, "siteId", siteId, PokerStars_Last, _checker, __FILE__, __LINE__);
	UINT32 platformId; _parser.parseUINT32(platformId);
	AtfValidator::validateIntMax(_descr, "platformId", platformId, Client_Last, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PString _descbuf;
	CommonThin::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("extraData"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_IP_CHECK
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_IP_CHECK::Protocol_MSG_LOBBY_IP_CHECK()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_IP_CHECK::clear()
{
	code = 0;
	lobbyIp = 0;
	pingIp = 0;
	errCode = 0;
	myIpi = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_IP_CHECK::equals(const Protocol_MSG_LOBBY_IP_CHECK& _o) const
{
	return code == _o.code &&
		lobbyIp == _o.lobbyIp &&
		pingIp == _o.pingIp &&
		errCode == _o.errCode &&
		myIpi == _o.myIpi;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_IP_CHECK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_IP_CHECK).append(")");
	_buf.append(',');
	_buf.append("code=");
	_buf.appendUint(code);
	if (code == 0)
	{
		_buf.append(',');
		_buf.append("lobbyIp=");
		_buf.appendUint(lobbyIp);
		_buf.append(',');
		_buf.append("pingIp=");
		_buf.appendUint(pingIp);
	}
	else
	{
		_buf.append(',');
		_buf.append("errCode=");
		_buf.appendUint(errCode);
		_buf.append(',');
		_buf.append("myIpi=");
		_buf.appendUint(myIpi);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_IP_CHECK::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(code);
	if (code == 0)
	{
		_msg.composeUINT32(lobbyIp);
		_msg.composeUINT32(pingIp);
	}
	else
	{
		_msg.composeUINT32(errCode);
		_msg.composeUINT32(myIpi);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_IP_CHECK::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(code);
	if (code == 0)
	{
		_parser.parseUINT32(lobbyIp);
		_parser.parseUINT32(pingIp);
	}
	else
	{
		_parser.parseUINT32(errCode);
		_parser.parseUINT32(myIpi);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_IP_CHECK::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_IP_CHECK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE code = 0;
	_parser.parseBYTE(code);
	AtfValidator::validateIntMax(_descr, "code", code, 6, _checker, __FILE__, __LINE__);
	if (code == 0)
	{
		UINT32 lobbyIp; _parser.parseUINT32(lobbyIp);
		AtfValidator::validateInt(_descr, "lobbyIp", lobbyIp, _checker, __FILE__, __LINE__);
		UINT32 pingIp; _parser.parseUINT32(pingIp);
		AtfValidator::validateInt(_descr, "pingIp", pingIp, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 errCode; _parser.parseUINT32(errCode);
		AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
		UINT32 myIpi; _parser.parseUINT32(myIpi);
		AtfValidator::validateInt(_descr, "myIpi", myIpi, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    TableSize
//=================================================================

Lobby::cli::TableSize::TableSize()
{
	clear();
}

void Lobby::cli::TableSize::clear()
{
	min = 0;
	max = 0;
}

bool Lobby::cli::TableSize::equals(const TableSize& _o) const
{
	return min == _o.min &&
		max == _o.max;
}

const char *Lobby::cli::TableSize::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("min=");
	_buf.appendUint(min);
	_buf.append(',');
	_buf.append("max=");
	_buf.appendUint(max);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::TableSize::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(min);
	_msg.composeBYTE(max);
}

void Lobby::cli::TableSize::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(min);
	_parser.parseBYTE(max);
}

/*static*/ void Lobby::cli::TableSize::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	BYTE min; _parser.parseBYTE(min);
	AtfValidator::validateInt(_descr, "min", min, _checker, __FILE__, __LINE__);
	BYTE max; _parser.parseBYTE(max);
	AtfValidator::validateInt(_descr, "max", max, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG
//=================================================================

Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG(Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG&& _o)
	: sngId(std::move(_o.sngId))
	, game(std::move(_o.game))
	, hiLo(std::move(_o.hiLo))
	, structure(std::move(_o.structure))
	, speed(std::move(_o.speed))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, currency(std::move(_o.currency))
	, minPlayersFrom(std::move(_o.minPlayersFrom))
	, minPlayersTo(std::move(_o.minPlayersTo))
	, minBuyIn(std::move(_o.minBuyIn))
	, maxBuyIn(std::move(_o.maxBuyIn))
	, flags(std::move(_o.flags))
	, tableSizes(std::move(_o.tableSizes))
{
}

Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG& Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG::operator=(Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG&& _o)
{
	if(this != &_o)
	{
		sngId = std::move(_o.sngId);
		game = std::move(_o.game);
		hiLo = std::move(_o.hiLo);
		structure = std::move(_o.structure);
		speed = std::move(_o.speed);
		isPlayMoney = std::move(_o.isPlayMoney);
		currency = std::move(_o.currency);
		minPlayersFrom = std::move(_o.minPlayersFrom);
		minPlayersTo = std::move(_o.minPlayersTo);
		minBuyIn = std::move(_o.minBuyIn);
		maxBuyIn = std::move(_o.maxBuyIn);
		flags = std::move(_o.flags);
		tableSizes = std::move(_o.tableSizes);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG::clear()
{
	sngId = 0;
	game = 0;
	hiLo = 0;
	structure = 0;
	speed = 0;
	isPlayMoney = false;
	currency.clear();
	minPlayersFrom = 0;
	minPlayersTo = 0;
	minBuyIn = 0;
	maxBuyIn = 0;
	flags = 0;
	tableSizes.clear();
}

bool Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG::equals(const Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG& _o) const
{
	return sngId == _o.sngId &&
		game == _o.game &&
		hiLo == _o.hiLo &&
		structure == _o.structure &&
		speed == _o.speed &&
		isPlayMoney == _o.isPlayMoney &&
		currency.equals(_o.currency) &&
		minPlayersFrom == _o.minPlayersFrom &&
		minPlayersTo == _o.minPlayersTo &&
		minBuyIn == _o.minBuyIn &&
		maxBuyIn == _o.maxBuyIn &&
		flags == _o.flags &&
		tableSizes.equals(_o.tableSizes);
}

const char *Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CLI_LOBBY_FIND_QUICKSTART_SNG).append(")");
	_buf.append(',');
	_buf.append("sngId=");
	_buf.appendUint(sngId);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("hiLo=");
	_buf.appendUint(hiLo);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("speed=");
	_buf.appendUint(speed);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("minPlayersFrom=");
	_buf.appendUint(minPlayersFrom);
	_buf.append(',');
	_buf.append("minPlayersTo=");
	_buf.appendUint(minPlayersTo);
	_buf.append(',');
	_buf.append("minBuyIn=");
	_buf.appendUint(minBuyIn);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendUint(maxBuyIn);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("tableSizes=");
	tableSizes.toTraceString(_buf);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(sngId);
	_msg.composeBYTE(game);
	_msg.composeBYTE(hiLo);
	_msg.composeBYTE(structure);
	_msg.composeBYTE(speed);
	_msg.composeBOOL(isPlayMoney);
	_msg.composeString(currency);
	_msg.composeUINT32(minPlayersFrom);
	_msg.composeUINT32(minPlayersTo);
	_msg.composeUINT32(minBuyIn);
	_msg.composeUINT32(maxBuyIn);
	_msg.composeUINT32(flags);
	tableSizes.composeMsg(_msg);
}

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(sngId);
	_parser.parseBYTE(game);
	_parser.parseBYTE(hiLo);
	_parser.parseBYTE(structure);
	_parser.parseBYTE(speed);
	_parser.parseBOOL(isPlayMoney);
	_parser.parseStringP(currency);
	_parser.parseUINT32(minPlayersFrom);
	_parser.parseUINT32(minPlayersTo);
	_parser.parseUINT32(minBuyIn);
	_parser.parseUINT32(maxBuyIn);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(flags);
	tableSizes.parseMsg(_parser);
}

/*static*/ void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CLI_LOBBY_FIND_QUICKSTART_SNG";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 sngId; _parser.parseUINT32(sngId);
	AtfValidator::validateInt(_descr, "sngId", sngId, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateIntRange(_descr, "game", game, HandTypeNone, HandType_Last, _checker, __FILE__, __LINE__);
	BYTE hiLo; _parser.parseBYTE(hiLo);
	AtfValidator::validateIntMax(_descr, "hiLo", hiLo, 1, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateIntRange(_descr, "structure", structure, StructLimit, PotStruct_Last, _checker, __FILE__, __LINE__);
	BYTE speed; _parser.parseBYTE(speed);
	AtfValidator::validateIntMax(_descr, "speed", speed, SpeedDisplay_LastSlot-1, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, 7, _checker, __FILE__, __LINE__);
	UINT32 minPlayersFrom; _parser.parseUINT32(minPlayersFrom);
	AtfValidator::validateIntMax(_descr, "minPlayersFrom", minPlayersFrom, 1000000, _checker, __FILE__, __LINE__);
	UINT32 minPlayersTo; _parser.parseUINT32(minPlayersTo);
	AtfValidator::validateIntMax(_descr, "minPlayersTo", minPlayersTo, 1000000, _checker, __FILE__, __LINE__);
	UINT32 minBuyIn; _parser.parseUINT32(minBuyIn);
	AtfValidator::validateIntMax(_descr, "minBuyIn", minBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 maxBuyIn; _parser.parseUINT32(maxBuyIn);
	AtfValidator::validateIntMax(_descr, "maxBuyIn", maxBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 flags; _parser.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTableSizes = ThinAtf::LAtfVector< TableSize, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableSizes"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "tableSizes", szTableSizes, 10240, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY(Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY&& _o)
	: sngId(std::move(_o.sngId))
	, errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, tournId(std::move(_o.tournId))
	, server(std::move(_o.server))
	, tournFlags(std::move(_o.tournFlags))
	, tournFlagsServInt(std::move(_o.tournFlagsServInt))
	, isStarted(std::move(_o.isStarted))
{
}

Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY& Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY::operator=(Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY&& _o)
{
	if(this != &_o)
	{
		sngId = std::move(_o.sngId);
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		tournId = std::move(_o.tournId);
		server = std::move(_o.server);
		tournFlags = std::move(_o.tournFlags);
		tournFlagsServInt = std::move(_o.tournFlagsServInt);
		isStarted = std::move(_o.isStarted);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY::clear()
{
	sngId = 0;
	errCode = 0;
	errDesc.clear();
	tournId = 0;
	server.clear();
	tournFlags = 0;
	tournFlagsServInt = 0;
	isStarted = false;
}

bool Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY::equals(const Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY& _o) const
{
	return sngId == _o.sngId &&
		errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		tournId == _o.tournId &&
		server.equals(_o.server) &&
		tournFlags == _o.tournFlags &&
		tournFlagsServInt == _o.tournFlagsServInt &&
		isStarted == _o.isStarted;
}

const char *Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY).append(")");
	_buf.append(',');
	_buf.append("sngId=");
	_buf.appendUint(sngId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("tournId=");
		_buf.appendUint(tournId);
		_buf.append(',');
		_buf.append("server=");
		_buf.append(server);
		_buf.append(',');
		_buf.append("tournFlags=");
		_buf.appendUint(tournFlags);
		_buf.append(',');
		_buf.append("tournFlagsServInt=");
		_buf.appendUint(tournFlagsServInt);
		_buf.append(',');
		_buf.append("isStarted=");
		_buf.appendUint(isStarted);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(sngId);
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeUINT32(tournId);
		_msg.composeString(server);
		_msg.composeUINT32(tournFlags);
		_msg.composeUINT32(tournFlagsServInt);
		_msg.composeBOOL(isStarted);
	}
}

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(sngId);
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseUINT32(tournId);
		_parser.parseStringP(server);
		_parser.parseUINT32(tournFlags);
		_parser.parseUINT32(tournFlagsServInt);
		_parser.parseBOOL(isStarted);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	UINT32 sngId; _parser.parseUINT32(sngId);
	AtfValidator::validateInt(_descr, "sngId", sngId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 tournId; _parser.parseUINT32(tournId);
		AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
		UINT32 tournFlags; _parser.parseUINT32(tournFlags);
		AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
		UINT32 tournFlagsServInt; _parser.parseUINT32(tournFlagsServInt);
		AtfValidator::validateInt(_descr, "tournFlagsServInt", tournFlagsServInt, _checker, __FILE__, __LINE__);
		bool isStarted; _parser.parseBOOL(isStarted);
		AtfValidator::validateInt(_descr, "isStarted", isStarted, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    DurationSize
//=================================================================

Lobby::cli::DurationSize::DurationSize()
{
	clear();
}

void Lobby::cli::DurationSize::clear()
{
	minD = 0;
	maxD = 0;
}

bool Lobby::cli::DurationSize::equals(const DurationSize& _o) const
{
	return minD == _o.minD &&
		maxD == _o.maxD;
}

const char *Lobby::cli::DurationSize::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("minD=");
	_buf.appendUint(minD);
	_buf.append(',');
	_buf.append("maxD=");
	_buf.appendUint(maxD);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::DurationSize::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT16(minD);
	_msg.composeUINT16(maxD);
}

void Lobby::cli::DurationSize::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT16(minD);
	_parser.parseUINT16(maxD);
}

/*static*/ void Lobby::cli::DurationSize::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT16 minD; _parser.parseUINT16(minD);
	AtfValidator::validateInt(_descr, "minD", minD, _checker, __FILE__, __LINE__);
	UINT16 maxD; _parser.parseUINT16(maxD);
	AtfValidator::validateInt(_descr, "maxD", maxD, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2
//=================================================================

Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2(Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2&& _o)
	: sngId(std::move(_o.sngId))
	, game(std::move(_o.game))
	, hiLo(std::move(_o.hiLo))
	, structure(std::move(_o.structure))
	, minPlayersFrom(std::move(_o.minPlayersFrom))
	, minPlayersTo(std::move(_o.minPlayersTo))
	, minBuyIn(std::move(_o.minBuyIn))
	, maxBuyIn(std::move(_o.maxBuyIn))
	, flags(std::move(_o.flags))
	, tableSizes(std::move(_o.tableSizes))
	, durationSizes(std::move(_o.durationSizes))
{
}

Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2& Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2::operator=(Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2&& _o)
{
	if(this != &_o)
	{
		sngId = std::move(_o.sngId);
		game = std::move(_o.game);
		hiLo = std::move(_o.hiLo);
		structure = std::move(_o.structure);
		minPlayersFrom = std::move(_o.minPlayersFrom);
		minPlayersTo = std::move(_o.minPlayersTo);
		minBuyIn = std::move(_o.minBuyIn);
		maxBuyIn = std::move(_o.maxBuyIn);
		flags = std::move(_o.flags);
		tableSizes = std::move(_o.tableSizes);
		durationSizes = std::move(_o.durationSizes);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2::clear()
{
	sngId = 0;
	game = 0;
	hiLo = 0;
	structure = 0;
	minPlayersFrom = 0;
	minPlayersTo = 0;
	minBuyIn = 0;
	maxBuyIn = 0;
	flags = 0;
	tableSizes.clear();
	durationSizes.clear();
}

bool Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2::equals(const Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2& _o) const
{
	return sngId == _o.sngId &&
		game == _o.game &&
		hiLo == _o.hiLo &&
		structure == _o.structure &&
		minPlayersFrom == _o.minPlayersFrom &&
		minPlayersTo == _o.minPlayersTo &&
		minBuyIn == _o.minBuyIn &&
		maxBuyIn == _o.maxBuyIn &&
		flags == _o.flags &&
		tableSizes.equals(_o.tableSizes) &&
		durationSizes.equals(_o.durationSizes);
}

const char *Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2).append(")");
	_buf.append(',');
	_buf.append("sngId=");
	_buf.appendUint(sngId);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("hiLo=");
	_buf.appendUint(hiLo);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("minPlayersFrom=");
	_buf.appendUint(minPlayersFrom);
	_buf.append(',');
	_buf.append("minPlayersTo=");
	_buf.appendUint(minPlayersTo);
	_buf.append(',');
	_buf.append("minBuyIn=");
	_buf.appendUint64(minBuyIn);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendUint64(maxBuyIn);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("tableSizes=");
	tableSizes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("durationSizes=");
	durationSizes.toTraceString(_buf);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(sngId);
	_msg.composeBYTE(game);
	_msg.composeBYTE(hiLo);
	_msg.composeBYTE(structure);
	_msg.composeUINT32(minPlayersFrom);
	_msg.composeUINT32(minPlayersTo);
	_msg.composeUINT64(minBuyIn);
	_msg.composeUINT64(maxBuyIn);
	_msg.composeUINT32(flags);
	tableSizes.composeMsg(_msg);
	durationSizes.composeMsg(_msg);
}

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(sngId);
	_parser.parseBYTE(game);
	_parser.parseBYTE(hiLo);
	_parser.parseBYTE(structure);
	_parser.parseUINT32(minPlayersFrom);
	_parser.parseUINT32(minPlayersTo);
	_parser.parseUINT64(minBuyIn);
	_parser.parseUINT64(maxBuyIn);
	_parser.parseUINT32(flags);
	tableSizes.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	durationSizes.parseMsg(_parser);
}

/*static*/ void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 sngId; _parser.parseUINT32(sngId);
	AtfValidator::validateInt(_descr, "sngId", sngId, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateIntRange(_descr, "game", game, HandTypeNone, HandType_Last, _checker, __FILE__, __LINE__);
	BYTE hiLo; _parser.parseBYTE(hiLo);
	AtfValidator::validateIntMax(_descr, "hiLo", hiLo, 1, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateIntRange(_descr, "structure", structure, StructLimit, PotStruct_Last, _checker, __FILE__, __LINE__);
	UINT32 minPlayersFrom; _parser.parseUINT32(minPlayersFrom);
	AtfValidator::validateIntMax(_descr, "minPlayersFrom", minPlayersFrom, 1000000, _checker, __FILE__, __LINE__);
	UINT32 minPlayersTo; _parser.parseUINT32(minPlayersTo);
	AtfValidator::validateIntMax(_descr, "minPlayersTo", minPlayersTo, 1000000, _checker, __FILE__, __LINE__);
	UINT64 minBuyIn; _parser.parseUINT64(minBuyIn);
	AtfValidator::validateUintMax(_descr, "minBuyIn", minBuyIn, 1000000000000ull, _checker, __FILE__, __LINE__);
	UINT64 maxBuyIn; _parser.parseUINT64(maxBuyIn);
	AtfValidator::validateUintMax(_descr, "maxBuyIn", maxBuyIn, 1000000000000ull, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser.parseUINT32(flags);
	AtfValidator::validateIntMax(_descr, "flags", flags, (qsftSpeedDisplayLast*2-1), _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTableSizes = ThinAtf::LAtfVector< TableSize, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableSizes"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "tableSizes", szTableSizes, 10240, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	int szDurationSizes = ThinAtf::LAtfVector< DurationSize, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("durationSizes"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "durationSizes", szDurationSizes, 10240, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY(Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY&& _o)
	: sngId(std::move(_o.sngId))
	, errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, tournId(std::move(_o.tournId))
	, server(std::move(_o.server))
	, tournFlags(std::move(_o.tournFlags))
	, tournFlagsServInt(std::move(_o.tournFlagsServInt))
	, sngScriptId(std::move(_o.sngScriptId))
	, isStarted(std::move(_o.isStarted))
{
}

Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY& Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY::operator=(Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY&& _o)
{
	if(this != &_o)
	{
		sngId = std::move(_o.sngId);
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		tournId = std::move(_o.tournId);
		server = std::move(_o.server);
		tournFlags = std::move(_o.tournFlags);
		tournFlagsServInt = std::move(_o.tournFlagsServInt);
		sngScriptId = std::move(_o.sngScriptId);
		isStarted = std::move(_o.isStarted);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY::clear()
{
	sngId = 0;
	errCode = 0;
	errDesc.clear();
	tournId = 0;
	server.clear();
	tournFlags = 0;
	tournFlagsServInt = 0;
	sngScriptId = 0;
	isStarted = false;
}

bool Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY::equals(const Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY& _o) const
{
	return sngId == _o.sngId &&
		errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		tournId == _o.tournId &&
		server.equals(_o.server) &&
		tournFlags == _o.tournFlags &&
		tournFlagsServInt == _o.tournFlagsServInt &&
		sngScriptId == _o.sngScriptId &&
		isStarted == _o.isStarted;
}

const char *Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY).append(")");
	_buf.append(',');
	_buf.append("sngId=");
	_buf.appendUint(sngId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("tournId=");
		_buf.appendUint(tournId);
		_buf.append(',');
		_buf.append("server=");
		_buf.append(server);
		_buf.append(',');
		_buf.append("tournFlags=");
		_buf.appendUint(tournFlags);
		_buf.append(',');
		_buf.append("tournFlagsServInt=");
		_buf.appendUint(tournFlagsServInt);
		_buf.append(',');
		_buf.append("sngScriptId=");
		_buf.appendUint(sngScriptId);
		_buf.append(',');
		_buf.append("isStarted=");
		_buf.appendUint(isStarted);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(sngId);
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeUINT32(tournId);
		_msg.composeString(server);
		_msg.composeUINT32(tournFlags);
		_msg.composeUINT32(tournFlagsServInt);
		_msg.composeUINT32(sngScriptId);
		_msg.composeBOOL(isStarted);
	}
}

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(sngId);
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseUINT32(tournId);
		_parser.parseStringP(server);
		_parser.parseUINT32(tournFlags);
		_parser.parseUINT32(tournFlagsServInt);
		_parser.parseUINT32(sngScriptId);
		_parser.parseBOOL(isStarted);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	UINT32 sngId; _parser.parseUINT32(sngId);
	AtfValidator::validateInt(_descr, "sngId", sngId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 tournId; _parser.parseUINT32(tournId);
		AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
		UINT32 tournFlags; _parser.parseUINT32(tournFlags);
		AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
		UINT32 tournFlagsServInt; _parser.parseUINT32(tournFlagsServInt);
		AtfValidator::validateInt(_descr, "tournFlagsServInt", tournFlagsServInt, _checker, __FILE__, __LINE__);
		UINT32 sngScriptId; _parser.parseUINT32(sngScriptId);
		AtfValidator::validateInt(_descr, "sngScriptId", sngScriptId, _checker, __FILE__, __LINE__);
		bool isStarted; _parser.parseBOOL(isStarted);
		AtfValidator::validateInt(_descr, "isStarted", isStarted, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3
//=================================================================

Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3(Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3&& _o)
	: sngId(std::move(_o.sngId))
	, game(std::move(_o.game))
	, hiLo(std::move(_o.hiLo))
	, structure(std::move(_o.structure))
	, minPlayersFrom(std::move(_o.minPlayersFrom))
	, minPlayersTo(std::move(_o.minPlayersTo))
	, minBuyIn(std::move(_o.minBuyIn))
	, maxBuyIn(std::move(_o.maxBuyIn))
	, flags(std::move(_o.flags))
	, tableSizes(std::move(_o.tableSizes))
	, durationSizes(std::move(_o.durationSizes))
{
}

Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3& Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3::operator=(Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3&& _o)
{
	if(this != &_o)
	{
		sngId = std::move(_o.sngId);
		game = std::move(_o.game);
		hiLo = std::move(_o.hiLo);
		structure = std::move(_o.structure);
		minPlayersFrom = std::move(_o.minPlayersFrom);
		minPlayersTo = std::move(_o.minPlayersTo);
		minBuyIn = std::move(_o.minBuyIn);
		maxBuyIn = std::move(_o.maxBuyIn);
		flags = std::move(_o.flags);
		tableSizes = std::move(_o.tableSizes);
		durationSizes = std::move(_o.durationSizes);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3::clear()
{
	sngId = 0;
	game = 0;
	hiLo = 0;
	structure = 0;
	minPlayersFrom = 0;
	minPlayersTo = 0;
	minBuyIn = 0;
	maxBuyIn = 0;
	flags = 0;
	tableSizes.clear();
	durationSizes.clear();
}

bool Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3::equals(const Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3& _o) const
{
	return sngId == _o.sngId &&
		game == _o.game &&
		hiLo == _o.hiLo &&
		structure == _o.structure &&
		minPlayersFrom == _o.minPlayersFrom &&
		minPlayersTo == _o.minPlayersTo &&
		minBuyIn == _o.minBuyIn &&
		maxBuyIn == _o.maxBuyIn &&
		flags == _o.flags &&
		tableSizes.equals(_o.tableSizes) &&
		durationSizes.equals(_o.durationSizes);
}

const char *Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3).append(")");
	_buf.append(',');
	_buf.append("sngId=");
	_buf.appendUint(sngId);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("hiLo=");
	_buf.appendUint(hiLo);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("minPlayersFrom=");
	_buf.appendUint(minPlayersFrom);
	_buf.append(',');
	_buf.append("minPlayersTo=");
	_buf.appendUint(minPlayersTo);
	_buf.append(',');
	_buf.append("minBuyIn=");
	_buf.appendUint64(minBuyIn);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendUint64(maxBuyIn);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("tableSizes=");
	tableSizes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("durationSizes=");
	durationSizes.toTraceString(_buf);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(sngId);
	_msg.composeBYTE(game);
	_msg.composeBYTE(hiLo);
	_msg.composeBYTE(structure);
	_msg.composeUINT32(minPlayersFrom);
	_msg.composeUINT32(minPlayersTo);
	_msg.composeUINT64(minBuyIn);
	_msg.composeUINT64(maxBuyIn);
	_msg.composeUINT32(flags);
	tableSizes.composeMsg(_msg);
	durationSizes.composeMsg(_msg);
}

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(sngId);
	_parser.parseBYTE(game);
	_parser.parseBYTE(hiLo);
	_parser.parseBYTE(structure);
	_parser.parseUINT32(minPlayersFrom);
	_parser.parseUINT32(minPlayersTo);
	_parser.parseUINT64(minBuyIn);
	_parser.parseUINT64(maxBuyIn);
	_parser.parseUINT32(flags);
	tableSizes.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	durationSizes.parseMsg(_parser);
}

/*static*/ void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 sngId; _parser.parseUINT32(sngId);
	AtfValidator::validateInt(_descr, "sngId", sngId, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateIntRange(_descr, "game", game, HandTypeNone, HandType_Last, _checker, __FILE__, __LINE__);
	BYTE hiLo; _parser.parseBYTE(hiLo);
	AtfValidator::validateIntMax(_descr, "hiLo", hiLo, 1, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateIntMax(_descr, "structure", structure, PotStruct_Last, _checker, __FILE__, __LINE__);
	UINT32 minPlayersFrom; _parser.parseUINT32(minPlayersFrom);
	AtfValidator::validateIntMax(_descr, "minPlayersFrom", minPlayersFrom, 1000000, _checker, __FILE__, __LINE__);
	UINT32 minPlayersTo; _parser.parseUINT32(minPlayersTo);
	AtfValidator::validateIntMax(_descr, "minPlayersTo", minPlayersTo, 1000000, _checker, __FILE__, __LINE__);
	UINT64 minBuyIn; _parser.parseUINT64(minBuyIn);
	AtfValidator::validateUintMax(_descr, "minBuyIn", minBuyIn, 1000000000000ull, _checker, __FILE__, __LINE__);
	UINT64 maxBuyIn; _parser.parseUINT64(maxBuyIn);
	AtfValidator::validateUintMax(_descr, "maxBuyIn", maxBuyIn, 1000000000000ull, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser.parseUINT32(flags);
	AtfValidator::validateIntMax(_descr, "flags", flags, (qsftSpeedDisplayLast*2-1), _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTableSizes = ThinAtf::LAtfVector< TableSize, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableSizes"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "tableSizes", szTableSizes, 10240, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	int szDurationSizes = ThinAtf::LAtfVector< DurationSize, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("durationSizes"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "durationSizes", szDurationSizes, 10240, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY(Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY&& _o)
	: sngId(std::move(_o.sngId))
	, errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, tournId(std::move(_o.tournId))
	, server(std::move(_o.server))
	, tournFlags(std::move(_o.tournFlags))
	, tournFlagsServInt(std::move(_o.tournFlagsServInt))
	, sngScriptId(std::move(_o.sngScriptId))
	, isStarted(std::move(_o.isStarted))
{
}

Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY& Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY::operator=(Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY&& _o)
{
	if(this != &_o)
	{
		sngId = std::move(_o.sngId);
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		tournId = std::move(_o.tournId);
		server = std::move(_o.server);
		tournFlags = std::move(_o.tournFlags);
		tournFlagsServInt = std::move(_o.tournFlagsServInt);
		sngScriptId = std::move(_o.sngScriptId);
		isStarted = std::move(_o.isStarted);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY::clear()
{
	sngId = 0;
	errCode = 0;
	errDesc.clear();
	tournId = 0;
	server.clear();
	tournFlags = 0;
	tournFlagsServInt = 0;
	sngScriptId = 0;
	isStarted = false;
}

bool Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY::equals(const Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY& _o) const
{
	return sngId == _o.sngId &&
		errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		tournId == _o.tournId &&
		server.equals(_o.server) &&
		tournFlags == _o.tournFlags &&
		tournFlagsServInt == _o.tournFlagsServInt &&
		sngScriptId == _o.sngScriptId &&
		isStarted == _o.isStarted;
}

const char *Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY).append(")");
	_buf.append(',');
	_buf.append("sngId=");
	_buf.appendUint(sngId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("tournId=");
		_buf.appendUint(tournId);
		_buf.append(',');
		_buf.append("server=");
		_buf.append(server);
		_buf.append(',');
		_buf.append("tournFlags=");
		_buf.appendUint(tournFlags);
		_buf.append(',');
		_buf.append("tournFlagsServInt=");
		_buf.appendUint(tournFlagsServInt);
		_buf.append(',');
		_buf.append("sngScriptId=");
		_buf.appendUint(sngScriptId);
		_buf.append(',');
		_buf.append("isStarted=");
		_buf.appendUint(isStarted);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(sngId);
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeUINT32(tournId);
		_msg.composeString(server);
		_msg.composeUINT32(tournFlags);
		_msg.composeUINT32(tournFlagsServInt);
		_msg.composeUINT32(sngScriptId);
		_msg.composeBOOL(isStarted);
	}
}

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(sngId);
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseUINT32(tournId);
		_parser.parseStringP(server);
		_parser.parseUINT32(tournFlags);
		_parser.parseUINT32(tournFlagsServInt);
		_parser.parseUINT32(sngScriptId);
		_parser.parseBOOL(isStarted);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	UINT32 sngId; _parser.parseUINT32(sngId);
	AtfValidator::validateInt(_descr, "sngId", sngId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 tournId; _parser.parseUINT32(tournId);
		AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
		UINT32 tournFlags; _parser.parseUINT32(tournFlags);
		AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
		UINT32 tournFlagsServInt; _parser.parseUINT32(tournFlagsServInt);
		AtfValidator::validateInt(_descr, "tournFlagsServInt", tournFlagsServInt, _checker, __FILE__, __LINE__);
		UINT32 sngScriptId; _parser.parseUINT32(sngScriptId);
		AtfValidator::validateInt(_descr, "sngScriptId", sngScriptId, _checker, __FILE__, __LINE__);
		bool isStarted; _parser.parseBOOL(isStarted);
		AtfValidator::validateInt(_descr, "isStarted", isStarted, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT(Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT&& _o)
	: tournStatType(std::move(_o.tournStatType))
	, tournIds(std::move(_o.tournIds))
	, handIds(std::move(_o.handIds))
{
}

Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT& Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT::operator=(Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT&& _o)
{
	if(this != &_o)
	{
		tournStatType = std::move(_o.tournStatType);
		tournIds = std::move(_o.tournIds);
		handIds = std::move(_o.handIds);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT::clear()
{
	tournStatType = 0;
	tournIds.clear();
	handIds.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT::equals(const Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT& _o) const
{
	return tournStatType == _o.tournStatType &&
		tournIds.equals(_o.tournIds) &&
		handIds.equals(_o.handIds);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT).append(")");
	_buf.append(',');
	_buf.append("tournStatType=");
	_buf.appendUint(tournStatType);
	_buf.append(',');
	_buf.append("tournIds=");
	tournIds.toTraceString(_buf);
	_buf.append(',');
	_buf.append("handIds=");
	handIds.toTraceString(_buf);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(tournStatType);
	tournIds.composeMsg(_msg);
	handIds.composeMsg(_msg);
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(tournStatType);
	tournIds.parseMsg(_parser);
	handIds.parseMsg(_parser);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE tournStatType; _parser.parseBYTE(tournStatType);
	AtfValidator::validateInt(_descr, "tournStatType", tournStatType, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTournIds = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournIds"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "tournIds", szTournIds, 10240, _checker, __FILE__, __LINE__);
	int szHandIds = ThinAtf::LAtfVector< UINT64, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("handIds"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "handIds", szHandIds, 10240, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY(Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY& Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY::operator=(Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY::equals(const Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_USER_CAPS
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS::Protocol_MSG_LOBBY_GET_USER_CAPS()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS::clear()
{
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS::equals(const Protocol_MSG_LOBBY_GET_USER_CAPS& _o) const
{
	return true;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_USER_CAPS).append(")");
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS::composeMsg(CommMsgBody& _msg) const
{
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_USER_CAPS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY(Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, maxTablesLimitPM(std::move(_o.maxTablesLimitPM))
	, maxTablesLimitRM(std::move(_o.maxTablesLimitRM))
{
}

Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY& Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::operator=(Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		maxTablesLimitPM = std::move(_o.maxTablesLimitPM);
		maxTablesLimitRM = std::move(_o.maxTablesLimitRM);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	maxTablesLimitPM = 0;
	maxTablesLimitRM = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::equals(const Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		maxTablesLimitPM == _o.maxTablesLimitPM &&
		maxTablesLimitRM == _o.maxTablesLimitRM;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_USER_CAPS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("maxTablesLimitPM=");
		_buf.appendUint(maxTablesLimitPM);
		_buf.append(',');
		_buf.append("maxTablesLimitRM=");
		_buf.appendUint(maxTablesLimitRM);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeUINT32(maxTablesLimitPM);
		_msg.composeUINT32(maxTablesLimitRM);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseUINT32(maxTablesLimitPM);
		_parser.parseUINT32(maxTablesLimitRM);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_USER_CAPS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 maxTablesLimitPM; _parser.parseUINT32(maxTablesLimitPM);
		AtfValidator::validateInt(_descr, "maxTablesLimitPM", maxTablesLimitPM, _checker, __FILE__, __LINE__);
		UINT32 maxTablesLimitRM; _parser.parseUINT32(maxTablesLimitRM);
		AtfValidator::validateInt(_descr, "maxTablesLimitRM", maxTablesLimitRM, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_DISABLE_SNG_AUTO_UNREG
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_DISABLE_SNG_AUTO_UNREG::Protocol_MSG_LOBBY_DISABLE_SNG_AUTO_UNREG()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_DISABLE_SNG_AUTO_UNREG::clear()
{
	setPriv = false;
}

bool Lobby::cli::Protocol_MSG_LOBBY_DISABLE_SNG_AUTO_UNREG::equals(const Protocol_MSG_LOBBY_DISABLE_SNG_AUTO_UNREG& _o) const
{
	return setPriv == _o.setPriv;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_DISABLE_SNG_AUTO_UNREG::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_DISABLE_SNG_AUTO_UNREG).append(")");
	_buf.append(',');
	_buf.append("setPriv=");
	_buf.appendUint(setPriv);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_DISABLE_SNG_AUTO_UNREG::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBOOL(setPriv);
}

void Lobby::cli::Protocol_MSG_LOBBY_DISABLE_SNG_AUTO_UNREG::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(setPriv);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_DISABLE_SNG_AUTO_UNREG::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_DISABLE_SNG_AUTO_UNREG";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	bool setPriv; _parser.parseBOOL(setPriv);
	AtfValidator::validateInt(_descr, "setPriv", setPriv, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::clear()
{
	onlyTargetBanner = false;
	newsTypeMask = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::equals(const Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP& _o) const
{
	return onlyTargetBanner == _o.onlyTargetBanner &&
		newsTypeMask == _o.newsTypeMask;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_TARGET_NEWS_DESKTOP).append(")");
	_buf.append(',');
	_buf.append("onlyTargetBanner=");
	_buf.appendUint(onlyTargetBanner);
	_buf.append(',');
	_buf.append("newsTypeMask=");
	_buf.appendUint(newsTypeMask);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBOOL(onlyTargetBanner);
	_msg.composeUINT32(newsTypeMask);
}

void Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(onlyTargetBanner);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(newsTypeMask);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TARGET_NEWS_DESKTOP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(_parser.parseEnded()) return;
	bool onlyTargetBanner; _parser.parseBOOL(onlyTargetBanner);
	AtfValidator::validateInt(_descr, "onlyTargetBanner", onlyTargetBanner, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 newsTypeMask; _parser.parseUINT32(newsTypeMask);
	AtfValidator::validateIntRange(_descr, "newsTypeMask", newsTypeMask, eTargetNewsGeneral, eTargetNewsAll, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::clear()
{
	clientDownloadSource = 0;
	newsProductMask = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::equals(const Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE& _o) const
{
	return clientDownloadSource == _o.clientDownloadSource &&
		newsProductMask == _o.newsProductMask;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_TARGET_NEWS_MOBILE).append(")");
	_buf.append(',');
	_buf.append("clientDownloadSource=");
	_buf.appendUint(clientDownloadSource);
	_buf.append(',');
	_buf.append("newsProductMask=");
	_buf.appendUint(newsProductMask);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(clientDownloadSource);
	_msg.composeUINT32(newsProductMask);
}

void Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clientDownloadSource);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(newsProductMask);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TARGET_NEWS_MOBILE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clientDownloadSource; _parser.parseUINT32(clientDownloadSource);
	AtfValidator::validateInt(_descr, "clientDownloadSource", clientDownloadSource, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 newsProductMask; _parser.parseUINT32(newsProductMask);
	AtfValidator::validateIntRange(_descr, "newsProductMask", newsProductMask, eTargetNewsGeneral, eTargetNewsAll, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CLI_LOBBY_CONFIRM_POPUP
//=================================================================

Lobby::cli::Protocol_MSG_CLI_LOBBY_CONFIRM_POPUP::Protocol_MSG_CLI_LOBBY_CONFIRM_POPUP()
{
	clear();
}

void Lobby::cli::Protocol_MSG_CLI_LOBBY_CONFIRM_POPUP::clear()
{
	confirmId = 0;
	understood = false;
}

bool Lobby::cli::Protocol_MSG_CLI_LOBBY_CONFIRM_POPUP::equals(const Protocol_MSG_CLI_LOBBY_CONFIRM_POPUP& _o) const
{
	return confirmId == _o.confirmId &&
		understood == _o.understood;
}

const char *Lobby::cli::Protocol_MSG_CLI_LOBBY_CONFIRM_POPUP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CLI_LOBBY_CONFIRM_POPUP).append(")");
	_buf.append(',');
	_buf.append("confirmId=");
	_buf.appendUint(confirmId);
	_buf.append(',');
	_buf.append("understood=");
	_buf.appendUint(understood);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_CLI_LOBBY_CONFIRM_POPUP::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(confirmId);
	_msg.composeBOOL(understood);
}

void Lobby::cli::Protocol_MSG_CLI_LOBBY_CONFIRM_POPUP::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(confirmId);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(understood);
}

/*static*/ void Lobby::cli::Protocol_MSG_CLI_LOBBY_CONFIRM_POPUP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CLI_LOBBY_CONFIRM_POPUP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 confirmId; _parser.parseUINT32(confirmId);
	AtfValidator::validateInt(_descr, "confirmId", confirmId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool understood; _parser.parseBOOL(understood);
	AtfValidator::validateInt(_descr, "understood", understood, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF(Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF&& _o)
	: internalRef(std::move(_o.internalRef))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF& Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF::operator=(Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF&& _o)
{
	if(this != &_o)
	{
		internalRef = std::move(_o.internalRef);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF::clear()
{
	internalRef.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF::equals(const Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF& _o) const
{
	return internalRef.equals(_o.internalRef);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF).append(")");
	_buf.append(',');
	_buf.append("internalRef=");
	_buf.append(internalRef);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(internalRef);
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(internalRef);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "internalRef"); size_t szInternalRef = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "internalRef", szInternalRef, 500, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY(Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, tournamentId(std::move(_o.tournamentId))
	, server(std::move(_o.server))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY& Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY::operator=(Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		tournamentId = std::move(_o.tournamentId);
		server = std::move(_o.server);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	tournamentId = 0;
	server.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY::equals(const Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		tournamentId == _o.tournamentId &&
		server.equals(_o.server);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("tournamentId=");
		_buf.appendUint(tournamentId);
		_buf.append(',');
		_buf.append("server=");
		_buf.append(server);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeUINT32(tournamentId);
		_msg.composeString(server);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseUINT32(tournamentId);
		_parser.parseStringP(server);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 tournamentId; _parser.parseUINT32(tournamentId);
		AtfValidator::validateInt(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES::clear()
{
	tournId = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES::equals(const Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES& _o) const
{
	return tournId == _o.tournId;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_SIMILAR_SATELLITES).append(")");
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(tournId);
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tournId);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_SIMILAR_SATELLITES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    SatelliteTourn
//=================================================================

Lobby::cli::SatelliteTourn::SatelliteTourn()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::SatelliteTourn::SatelliteTourn(SatelliteTourn&& _o)
	: tournamentId(std::move(_o.tournamentId))
	, whenStart(std::move(_o.whenStart))
	, game(std::move(_o.game))
	, structure(std::move(_o.structure))
	, isHiLo(std::move(_o.isHiLo))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, currency(std::move(_o.currency))
	, scalePM(std::move(_o.scalePM))
	, buyIn(std::move(_o.buyIn))
	, rake(std::move(_o.rake))
	, knockout(std::move(_o.knockout))
	, fppBuyIn(std::move(_o.fppBuyIn))
	, admissionPrice(std::move(_o.admissionPrice))
	, admissionId(std::move(_o.admissionId))
	, status(std::move(_o.status))
	, statusBits(std::move(_o.statusBits))
	, tournFlags(std::move(_o.tournFlags))
	, tournFlags2(std::move(_o.tournFlags2))
	, servIntFlags(std::move(_o.servIntFlags))
	, maxPlayers(std::move(_o.maxPlayers))
	, players(std::move(_o.players))
	, server(std::move(_o.server))
	, serverObj(std::move(_o.serverObj))
{
}

Lobby::cli::SatelliteTourn& Lobby::cli::SatelliteTourn::operator=(SatelliteTourn&& _o)
{
	if(this != &_o)
	{
		tournamentId = std::move(_o.tournamentId);
		whenStart = std::move(_o.whenStart);
		game = std::move(_o.game);
		structure = std::move(_o.structure);
		isHiLo = std::move(_o.isHiLo);
		isPlayMoney = std::move(_o.isPlayMoney);
		currency = std::move(_o.currency);
		scalePM = std::move(_o.scalePM);
		buyIn = std::move(_o.buyIn);
		rake = std::move(_o.rake);
		knockout = std::move(_o.knockout);
		fppBuyIn = std::move(_o.fppBuyIn);
		admissionPrice = std::move(_o.admissionPrice);
		admissionId = std::move(_o.admissionId);
		status = std::move(_o.status);
		statusBits = std::move(_o.statusBits);
		tournFlags = std::move(_o.tournFlags);
		tournFlags2 = std::move(_o.tournFlags2);
		servIntFlags = std::move(_o.servIntFlags);
		maxPlayers = std::move(_o.maxPlayers);
		players = std::move(_o.players);
		server = std::move(_o.server);
		serverObj = std::move(_o.serverObj);
	}
	return *this;
}

#endif

void Lobby::cli::SatelliteTourn::clear()
{
	tournamentId = 0;
	whenStart.setNull();
	game = 0;
	structure = 0;
	isHiLo = 0;
	isPlayMoney = 0;
	currency.clear();
	scalePM = 0;
	buyIn = 0;
	rake = 0;
	knockout = 0;
	fppBuyIn = 0;
	admissionPrice = 0;
	admissionId.clear();
	status = 0;
	statusBits = 0;
	tournFlags = 0;
	tournFlags2 = 0;
	servIntFlags = 0;
	maxPlayers = 0;
	players = 0;
	server.clear();
	serverObj.clear();
}

bool Lobby::cli::SatelliteTourn::equals(const SatelliteTourn& _o) const
{
	return tournamentId == _o.tournamentId &&
		whenStart.equals(_o.whenStart) &&
		game == _o.game &&
		structure == _o.structure &&
		isHiLo == _o.isHiLo &&
		isPlayMoney == _o.isPlayMoney &&
		currency.equals(_o.currency) &&
		scalePM == _o.scalePM &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		knockout == _o.knockout &&
		fppBuyIn == _o.fppBuyIn &&
		admissionPrice == _o.admissionPrice &&
		admissionId.equals(_o.admissionId) &&
		status == _o.status &&
		statusBits == _o.statusBits &&
		tournFlags == _o.tournFlags &&
		tournFlags2 == _o.tournFlags2 &&
		servIntFlags == _o.servIntFlags &&
		maxPlayers == _o.maxPlayers &&
		players == _o.players &&
		server.equals(_o.server) &&
		serverObj.equals(_o.serverObj);
}

const char *Lobby::cli::SatelliteTourn::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournamentId=");
	_buf.appendUint(tournamentId);
	_buf.append(',');
	_buf.append("whenStart=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, whenStart);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendUint(buyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendUint(rake);
	_buf.append(',');
	_buf.append("knockout=");
	_buf.appendUint(knockout);
	_buf.append(',');
	_buf.append("fppBuyIn=");
	_buf.appendUint(fppBuyIn);
	_buf.append(',');
	_buf.append("admissionPrice=");
	_buf.appendUint64(admissionPrice);
	_buf.append(',');
	_buf.append("admissionId=");
	_buf.append(admissionId);
	_buf.append(',');
	_buf.append("status=");
	_buf.appendUint(status);
	_buf.append(',');
	_buf.append("statusBits=");
	_buf.appendUint(statusBits);
	_buf.append(',');
	_buf.append("tournFlags=");
	_buf.appendUint(tournFlags);
	_buf.append(',');
	_buf.append("tournFlags2=");
	_buf.appendUint64(tournFlags2);
	_buf.append(',');
	_buf.append("servIntFlags=");
	_buf.appendUint(servIntFlags);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendUint(maxPlayers);
	_buf.append(',');
	_buf.append("players=");
	_buf.appendUint(players);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("serverObj=");
	_buf.append(serverObj);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::SatelliteTourn::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(SatelliteTourn())) // not empty
	{
		_body.composeUINT32(tournamentId);
		_body.composeSrvTime(whenStart);
		_body.composeBYTE(game);
		_body.composeBYTE(structure);
		_body.composeBYTE(isHiLo);
		_body.composeBYTE(isPlayMoney);
		_body.composeString(currency);
		_body.composeUINT32(scalePM);
		_body.composeUINT32(buyIn);
		_body.composeUINT32(rake);
		_body.composeUINT32(knockout);
		_body.composeUINT32(fppBuyIn);
		_body.composeUINT64(admissionPrice);
		_body.composeString(admissionId);
		_body.composeUINT32(status);
		_body.composeUINT32(statusBits);
		_body.composeUINT32(tournFlags);
		_body.composeUINT64(tournFlags2);
		_body.composeUINT32(servIntFlags);
		_body.composeUINT32(maxPlayers);
		_body.composeUINT32(players);
		_body.composeString(server);
		_body.composeString(serverObj);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::cli::SatelliteTourn::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(tournamentId);
	_parser0.parseSrvTime(whenStart);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(structure);
	_parser0.parseBYTE(isHiLo);
	_parser0.parseBYTE(isPlayMoney);
	_parser0.parseStringP(currency);
	_parser0.parseUINT32(scalePM);
	_parser0.parseUINT32(buyIn);
	_parser0.parseUINT32(rake);
	_parser0.parseUINT32(knockout);
	_parser0.parseUINT32(fppBuyIn);
	_parser0.parseUINT64(admissionPrice);
	_parser0.parseStringP(admissionId);
	_parser0.parseUINT32(status);
	_parser0.parseUINT32(statusBits);
	_parser0.parseUINT32(tournFlags);
	_parser0.parseUINT64(tournFlags2);
	_parser0.parseUINT32(servIntFlags);
	_parser0.parseUINT32(maxPlayers);
	_parser0.parseUINT32(players);
	_parser0.parseStringP(server);
	_parser0.parseStringP(serverObj);
}

/*static*/ void Lobby::cli::SatelliteTourn::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 tournamentId; _parser0.parseUINT32(tournamentId);
	AtfValidator::validateInt(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
	SrvTime whenStart; _parser0.parseSrvTime(whenStart);
	AtfValidator::validateSrvDateTime(_descr, "whenStart", whenStart, _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser0.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser0.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser0.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT32 buyIn; _parser0.parseUINT32(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT32 rake; _parser0.parseUINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	UINT32 knockout; _parser0.parseUINT32(knockout);
	AtfValidator::validateInt(_descr, "knockout", knockout, _checker, __FILE__, __LINE__);
	UINT32 fppBuyIn; _parser0.parseUINT32(fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	UINT64 admissionPrice; _parser0.parseUINT64(admissionPrice);
	AtfValidator::validateUint(_descr, "admissionPrice", admissionPrice, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "admissionId"); size_t szAdmissionId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "admissionId", szAdmissionId, _checker, __FILE__, __LINE__);
	UINT32 status; _parser0.parseUINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	UINT32 statusBits; _parser0.parseUINT32(statusBits);
	AtfValidator::validateInt(_descr, "statusBits", statusBits, _checker, __FILE__, __LINE__);
	UINT32 tournFlags; _parser0.parseUINT32(tournFlags);
	AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
	UINT64 tournFlags2; _parser0.parseUINT64(tournFlags2);
	AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	UINT32 servIntFlags; _parser0.parseUINT32(servIntFlags);
	AtfValidator::validateInt(_descr, "servIntFlags", servIntFlags, _checker, __FILE__, __LINE__);
	UINT32 maxPlayers; _parser0.parseUINT32(maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	UINT32 players; _parser0.parseUINT32(players);
	AtfValidator::validateInt(_descr, "players", players, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "serverObj"); size_t szServerObj = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObj", szServerObj, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY(Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, satelliteTourns(std::move(_o.satelliteTourns))
{
}

Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY& Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY::operator=(Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		satelliteTourns = std::move(_o.satelliteTourns);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	satelliteTourns.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY::equals(const Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		satelliteTourns.equals(_o.satelliteTourns);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("satelliteTourns=");
		satelliteTourns.toTraceString(_buf);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		satelliteTourns.composeMsg(_msg);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		satelliteTourns.parseMsg(_parser);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szSatelliteTourns = ThinAtf::LAtfVector< SatelliteTourn, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("satelliteTourns"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "satelliteTourns", szSatelliteTourns, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_JOIN_SEATFINDER
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER::Protocol_MSG_LOBBY_JOIN_SEATFINDER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER::Protocol_MSG_LOBBY_JOIN_SEATFINDER(Protocol_MSG_LOBBY_JOIN_SEATFINDER&& _o)
	: seatFinderId(std::move(_o.seatFinderId))
	, buyIn(std::move(_o.buyIn))
	, password(std::move(_o.password))
	, autoRebuyOpt(std::move(_o.autoRebuyOpt))
	, autoRebuyBigBets(std::move(_o.autoRebuyBigBets))
	, fallUnderBigBets(std::move(_o.fallUnderBigBets))
	, fallUnderPercents(std::move(_o.fallUnderPercents))
{
}

Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER& Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER::operator=(Protocol_MSG_LOBBY_JOIN_SEATFINDER&& _o)
{
	if(this != &_o)
	{
		seatFinderId = std::move(_o.seatFinderId);
		buyIn = std::move(_o.buyIn);
		password = std::move(_o.password);
		autoRebuyOpt = std::move(_o.autoRebuyOpt);
		autoRebuyBigBets = std::move(_o.autoRebuyBigBets);
		fallUnderBigBets = std::move(_o.fallUnderBigBets);
		fallUnderPercents = std::move(_o.fallUnderPercents);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER::clear()
{
	seatFinderId = 0;
	buyIn = 0;
	password.clear();
	autoRebuyOpt = 0;
	autoRebuyBigBets = 0;
	fallUnderBigBets = 0;
	fallUnderPercents = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER::equals(const Protocol_MSG_LOBBY_JOIN_SEATFINDER& _o) const
{
	return seatFinderId == _o.seatFinderId &&
		buyIn == _o.buyIn &&
		password.equals(_o.password) &&
		autoRebuyOpt == _o.autoRebuyOpt &&
		autoRebuyBigBets == _o.autoRebuyBigBets &&
		fallUnderBigBets == _o.fallUnderBigBets &&
		fallUnderPercents == _o.fallUnderPercents;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_JOIN_SEATFINDER).append(")");
	_buf.append(',');
	_buf.append("seatFinderId=");
	_buf.appendUint(seatFinderId);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendInt(buyIn);
	_buf.append(',');
	_buf.append("password=");
	_buf.append(password);
	_buf.append(',');
	_buf.append("autoRebuyOpt=");
	_buf.appendInt(autoRebuyOpt);
	_buf.append(',');
	_buf.append("autoRebuyBigBets=");
	_buf.appendInt(autoRebuyBigBets);
	_buf.append(',');
	_buf.append("fallUnderBigBets=");
	_buf.appendInt(fallUnderBigBets);
	_buf.append(',');
	_buf.append("fallUnderPercents=");
	_buf.appendInt(fallUnderPercents);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(seatFinderId);
	_msg.composeINT32(buyIn);
	_msg.composeString(password);
	_msg.composeINT8(autoRebuyOpt);
	_msg.composeINT16(autoRebuyBigBets);
	_msg.composeINT16(fallUnderBigBets);
	_msg.composeINT16(fallUnderPercents);
}

void Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(seatFinderId);
	_parser.parseINT32(buyIn);
	_parser.parseStringP(password);
	_parser.parseINT8(autoRebuyOpt);
	_parser.parseINT16(autoRebuyBigBets);
	_parser.parseINT16(fallUnderBigBets);
	_parser.parseINT16(fallUnderPercents);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_JOIN_SEATFINDER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 seatFinderId; _parser.parseUINT32(seatFinderId);
	AtfValidator::validateInt(_descr, "seatFinderId", seatFinderId, _checker, __FILE__, __LINE__);
	INT32 buyIn; _parser.parseINT32(buyIn);
	AtfValidator::validateIntRange(_descr, "buyIn", buyIn, 0, 2000000000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "password"); size_t szPassword = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "password", szPassword, 1000, _checker, __FILE__, __LINE__);
	INT8 autoRebuyOpt; _parser.parseINT8(autoRebuyOpt);
	AtfValidator::validateIntRange(_descr, "autoRebuyOpt", autoRebuyOpt, _autoRebuyDisabled, _autoRebuyBigBets, _checker, __FILE__, __LINE__);
	INT16 autoRebuyBigBets; _parser.parseINT16(autoRebuyBigBets);
	AtfValidator::validateIntRange(_descr, "autoRebuyBigBets", autoRebuyBigBets, 0, 1000, _checker, __FILE__, __LINE__);
	INT16 fallUnderBigBets; _parser.parseINT16(fallUnderBigBets);
	AtfValidator::validateIntRange(_descr, "fallUnderBigBets", fallUnderBigBets, 0, 1000, _checker, __FILE__, __LINE__);
	INT16 fallUnderPercents; _parser.parseINT16(fallUnderPercents);
	AtfValidator::validateIntRange(_descr, "fallUnderPercents", fallUnderPercents, 0, 100, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY::Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY::Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY(Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, seatFinderId(std::move(_o.seatFinderId))
	, placeInList(std::move(_o.placeInList))
{
}

Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY& Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY::operator=(Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		seatFinderId = std::move(_o.seatFinderId);
		placeInList = std::move(_o.placeInList);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	seatFinderId = 0;
	placeInList = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY::equals(const Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		seatFinderId == _o.seatFinderId &&
		placeInList == _o.placeInList;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_JOIN_SEATFINDER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
		_buf.append(',');
		_buf.append("seatFinderId=");
		_buf.appendUint(seatFinderId);
	}
	else
	{
		_buf.append(',');
		_buf.append("seatFinderId=");
		_buf.appendUint(seatFinderId);
		_buf.append(',');
		_buf.append("placeInList=");
		_buf.appendInt(placeInList);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
		_msg.composeUINT32(seatFinderId);
	}
	else
	{
		_msg.composeUINT32(seatFinderId);
		_msg.composeINT32(placeInList);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
		_parser.parseUINT32(seatFinderId);
	}
	else
	{
		_parser.parseUINT32(seatFinderId);
		_parser.parseINT32(placeInList);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_JOIN_SEATFINDER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
		UINT32 seatFinderId; _parser.parseUINT32(seatFinderId);
		AtfValidator::validateInt(_descr, "seatFinderId", seatFinderId, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 seatFinderId; _parser.parseUINT32(seatFinderId);
		AtfValidator::validateInt(_descr, "seatFinderId", seatFinderId, _checker, __FILE__, __LINE__);
		INT32 placeInList; _parser.parseINT32(placeInList);
		AtfValidator::validateInt(_descr, "placeInList", placeInList, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_UNJOIN_SEATFINDER
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER::clear()
{
	seatFinderId = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER::equals(const Protocol_MSG_LOBBY_UNJOIN_SEATFINDER& _o) const
{
	return seatFinderId == _o.seatFinderId;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_UNJOIN_SEATFINDER).append(")");
	_buf.append(',');
	_buf.append("seatFinderId=");
	_buf.appendUint(seatFinderId);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(seatFinderId);
}

void Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(seatFinderId);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_UNJOIN_SEATFINDER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 seatFinderId; _parser.parseUINT32(seatFinderId);
	AtfValidator::validateInt(_descr, "seatFinderId", seatFinderId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY(Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, seatFinderId(std::move(_o.seatFinderId))
{
}

Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY& Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY::operator=(Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		seatFinderId = std::move(_o.seatFinderId);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	seatFinderId = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY::equals(const Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		seatFinderId == _o.seatFinderId;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_UNJOIN_SEATFINDER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
		_buf.append(',');
		_buf.append("seatFinderId=");
		_buf.appendUint(seatFinderId);
	}
	else
	{
		_buf.append(',');
		_buf.append("seatFinderId=");
		_buf.appendUint(seatFinderId);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
		_msg.composeUINT32(seatFinderId);
	}
	else
	{
		_msg.composeUINT32(seatFinderId);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
		_parser.parseUINT32(seatFinderId);
	}
	else
	{
		_parser.parseUINT32(seatFinderId);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_UNJOIN_SEATFINDER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
		UINT32 seatFinderId; _parser.parseUINT32(seatFinderId);
		AtfValidator::validateInt(_descr, "seatFinderId", seatFinderId, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 seatFinderId; _parser.parseUINT32(seatFinderId);
		AtfValidator::validateInt(_descr, "seatFinderId", seatFinderId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS::clear()
{
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS::equals(const Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS& _o) const
{
	return true;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_JOINED_SEATFINDERS).append(")");
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS::composeMsg(CommMsgBody& _msg) const
{
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_JOINED_SEATFINDERS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    SeatFinder
//=================================================================

Lobby::cli::SeatFinder::SeatFinder()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::SeatFinder::SeatFinder(SeatFinder&& _o)
	: seatFinderId(std::move(_o.seatFinderId))
	, placeInList(std::move(_o.placeInList))
	, game(std::move(_o.game))
	, structure(std::move(_o.structure))
	, isHiLo(std::move(_o.isHiLo))
	, isRealMoney(std::move(_o.isRealMoney))
	, currency(std::move(_o.currency))
	, loBet(std::move(_o.loBet))
	, hiBet(std::move(_o.hiBet))
{
}

Lobby::cli::SeatFinder& Lobby::cli::SeatFinder::operator=(SeatFinder&& _o)
{
	if(this != &_o)
	{
		seatFinderId = std::move(_o.seatFinderId);
		placeInList = std::move(_o.placeInList);
		game = std::move(_o.game);
		structure = std::move(_o.structure);
		isHiLo = std::move(_o.isHiLo);
		isRealMoney = std::move(_o.isRealMoney);
		currency = std::move(_o.currency);
		loBet = std::move(_o.loBet);
		hiBet = std::move(_o.hiBet);
	}
	return *this;
}

#endif

void Lobby::cli::SeatFinder::clear()
{
	seatFinderId = 0;
	placeInList = 0;
	game = 0;
	structure = 0;
	isHiLo = 0;
	isRealMoney = 0;
	currency.clear();
	loBet = 0;
	hiBet = 0;
}

bool Lobby::cli::SeatFinder::equals(const SeatFinder& _o) const
{
	return seatFinderId == _o.seatFinderId &&
		placeInList == _o.placeInList &&
		game == _o.game &&
		structure == _o.structure &&
		isHiLo == _o.isHiLo &&
		isRealMoney == _o.isRealMoney &&
		currency.equals(_o.currency) &&
		loBet == _o.loBet &&
		hiBet == _o.hiBet;
}

const char *Lobby::cli::SeatFinder::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("seatFinderId=");
	_buf.appendUint(seatFinderId);
	_buf.append(',');
	_buf.append("placeInList=");
	_buf.appendInt(placeInList);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("isRealMoney=");
	_buf.appendUint(isRealMoney);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("loBet=");
	_buf.appendInt(loBet);
	_buf.append(',');
	_buf.append("hiBet=");
	_buf.appendInt(hiBet);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::SeatFinder::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(seatFinderId);
	_msg.composeINT32(placeInList);
	_msg.composeBYTE(game);
	_msg.composeBYTE(structure);
	_msg.composeBYTE(isHiLo);
	_msg.composeBYTE(isRealMoney);
	_msg.composeString(currency);
	_msg.composeINT32(loBet);
	_msg.composeINT32(hiBet);
}

void Lobby::cli::SeatFinder::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(seatFinderId);
	_parser.parseINT32(placeInList);
	_parser.parseBYTE(game);
	_parser.parseBYTE(structure);
	_parser.parseBYTE(isHiLo);
	_parser.parseBYTE(isRealMoney);
	_parser.parseStringP(currency);
	_parser.parseINT32(loBet);
	_parser.parseINT32(hiBet);
}

/*static*/ void Lobby::cli::SeatFinder::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 seatFinderId; _parser.parseUINT32(seatFinderId);
	AtfValidator::validateInt(_descr, "seatFinderId", seatFinderId, _checker, __FILE__, __LINE__);
	INT32 placeInList; _parser.parseINT32(placeInList);
	AtfValidator::validateInt(_descr, "placeInList", placeInList, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE isRealMoney; _parser.parseBYTE(isRealMoney);
	AtfValidator::validateInt(_descr, "isRealMoney", isRealMoney, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT32 loBet; _parser.parseINT32(loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	INT32 hiBet; _parser.parseINT32(hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY(Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY&& _o)
	: seatFinders(std::move(_o.seatFinders))
{
}

Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY& Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY::operator=(Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY&& _o)
{
	if(this != &_o)
	{
		seatFinders = std::move(_o.seatFinders);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY::clear()
{
	seatFinders.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY::equals(const Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY& _o) const
{
	return seatFinders.equals(_o.seatFinders);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY).append(")");
	_buf.append(',');
	_buf.append("seatFinders=");
	seatFinders.toTraceString(_buf);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	seatFinders.composeMsg(_msg);
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY::parseMsg(CommMsgParser& _parser)
{
	seatFinders.parseMsg(_parser);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szSeatFinders = ThinAtf::LAtfVector< SeatFinder, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("seatFinders"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "seatFinders", szSeatFinders, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS::clear()
{
	seatFinderId = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS::equals(const Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS& _o) const
{
	return seatFinderId == _o.seatFinderId;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SEATFINDER_CHECK_CHIPS).append(")");
	_buf.append(',');
	_buf.append("seatFinderId=");
	_buf.appendUint(seatFinderId);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(seatFinderId);
}

void Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(seatFinderId);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SEATFINDER_CHECK_CHIPS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 seatFinderId; _parser.parseUINT32(seatFinderId);
	AtfValidator::validateInt(_descr, "seatFinderId", seatFinderId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    SeatFinderCli_MsgBodyStruct
//=================================================================

Lobby::cli::SeatFinderCli_MsgBodyStruct::SeatFinderCli_MsgBodyStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::SeatFinderCli_MsgBodyStruct::SeatFinderCli_MsgBodyStruct(SeatFinderCli_MsgBodyStruct&& _o)
	: id(std::move(_o.id))
	, currency(std::move(_o.currency))
	, isHiLo(std::move(_o.isHiLo))
	, loBet(std::move(_o.loBet))
	, hiBet(std::move(_o.hiBet))
	, cap(std::move(_o.cap))
	, game(std::move(_o.game))
	, limit(std::move(_o.limit))
	, minBuyIn(std::move(_o.minBuyIn))
	, maxBuyIn(std::move(_o.maxBuyIn))
	, ante(std::move(_o.ante))
	, isFast(std::move(_o.isFast))
	, maxPlayers(std::move(_o.maxPlayers))
	, chipsQuantum(std::move(_o.chipsQuantum))
	, scalePM(std::move(_o.scalePM))
	, tableStakes(std::move(_o.tableStakes))
	, variableAntes(std::move(_o.variableAntes))
{
}

Lobby::cli::SeatFinderCli_MsgBodyStruct& Lobby::cli::SeatFinderCli_MsgBodyStruct::operator=(SeatFinderCli_MsgBodyStruct&& _o)
{
	if(this != &_o)
	{
		id = std::move(_o.id);
		currency = std::move(_o.currency);
		isHiLo = std::move(_o.isHiLo);
		loBet = std::move(_o.loBet);
		hiBet = std::move(_o.hiBet);
		cap = std::move(_o.cap);
		game = std::move(_o.game);
		limit = std::move(_o.limit);
		minBuyIn = std::move(_o.minBuyIn);
		maxBuyIn = std::move(_o.maxBuyIn);
		ante = std::move(_o.ante);
		isFast = std::move(_o.isFast);
		maxPlayers = std::move(_o.maxPlayers);
		chipsQuantum = std::move(_o.chipsQuantum);
		scalePM = std::move(_o.scalePM);
		tableStakes = std::move(_o.tableStakes);
		variableAntes = std::move(_o.variableAntes);
	}
	return *this;
}

#endif

void Lobby::cli::SeatFinderCli_MsgBodyStruct::clear()
{
	id = 0;
	currency.clear();
	isHiLo = 0;
	loBet = 0;
	hiBet = 0;
	cap = 0;
	game = 0;
	limit = 0;
	minBuyIn = 0;
	maxBuyIn = 0;
	ante = 0;
	isFast = false;
	maxPlayers = 0;
	chipsQuantum = 0;
	scalePM = 0;
	tableStakes.clear();
	variableAntes.clear();
}

bool Lobby::cli::SeatFinderCli_MsgBodyStruct::equals(const SeatFinderCli_MsgBodyStruct& _o) const
{
	return id == _o.id &&
		currency.equals(_o.currency) &&
		isHiLo == _o.isHiLo &&
		loBet == _o.loBet &&
		hiBet == _o.hiBet &&
		cap == _o.cap &&
		game == _o.game &&
		limit == _o.limit &&
		minBuyIn == _o.minBuyIn &&
		maxBuyIn == _o.maxBuyIn &&
		ante == _o.ante &&
		isFast == _o.isFast &&
		maxPlayers == _o.maxPlayers &&
		chipsQuantum == _o.chipsQuantum &&
		scalePM == _o.scalePM &&
		tableStakes.equals(_o.tableStakes) &&
		variableAntes.equals(_o.variableAntes);
}

const char *Lobby::cli::SeatFinderCli_MsgBodyStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("id=");
	_buf.appendUint(id);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendInt(isHiLo);
	_buf.append(',');
	_buf.append("loBet=");
	_buf.appendInt(loBet);
	_buf.append(',');
	_buf.append("hiBet=");
	_buf.appendInt(hiBet);
	_buf.append(',');
	_buf.append("cap=");
	_buf.appendInt(cap);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendInt(game);
	_buf.append(',');
	_buf.append("limit=");
	_buf.appendInt(limit);
	_buf.append(',');
	_buf.append("minBuyIn=");
	_buf.appendInt(minBuyIn);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendInt(maxBuyIn);
	_buf.append(',');
	_buf.append("ante=");
	_buf.appendInt(ante);
	_buf.append(',');
	_buf.append("isFast=");
	_buf.appendUint(isFast);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendInt(maxPlayers);
	_buf.append(',');
	_buf.append("chipsQuantum=");
	_buf.appendInt(chipsQuantum);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendInt(scalePM);
	_buf.append(',');
	_buf.append("tableStakes=");
	tableStakes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("variableAntes=");
	variableAntes.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::SeatFinderCli_MsgBodyStruct::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(SeatFinderCli_MsgBodyStruct())) // not empty
	{
		_body.composeUINT32(id);
		_body.composeString(currency);
		_body.composeINT8(isHiLo);
		_body.composeINT32(loBet);
		_body.composeINT32(hiBet);
		_body.composeINT32(cap);
		_body.composeINT8(game);
		_body.composeINT8(limit);
		_body.composeINT32(minBuyIn);
		_body.composeINT32(maxBuyIn);
		_body.composeINT32(ante);
		_body.composeBOOL(isFast);
		_body.composeINT8(maxPlayers);
		_body.composeINT32(chipsQuantum);
		_body.composeINT32(scalePM);
		tableStakes.composeMsg(_body);
		variableAntes.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::cli::SeatFinderCli_MsgBodyStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(id);
	_parser0.parseStringP(currency);
	_parser0.parseINT8(isHiLo);
	_parser0.parseINT32(loBet);
	_parser0.parseINT32(hiBet);
	_parser0.parseINT32(cap);
	_parser0.parseINT8(game);
	_parser0.parseINT8(limit);
	_parser0.parseINT32(minBuyIn);
	_parser0.parseINT32(maxBuyIn);
	_parser0.parseINT32(ante);
	_parser0.parseBOOL(isFast);
	_parser0.parseINT8(maxPlayers);
	_parser0.parseINT32(chipsQuantum);
	_parser0.parseINT32(scalePM);
	if(_parser0.parseEnded()) return;
	tableStakes.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	variableAntes.parseMsg(_parser0);
}

/*static*/ void Lobby::cli::SeatFinderCli_MsgBodyStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 id; _parser0.parseUINT32(id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT8 isHiLo; _parser0.parseINT8(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	INT32 loBet; _parser0.parseINT32(loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	INT32 hiBet; _parser0.parseINT32(hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	INT32 cap; _parser0.parseINT32(cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	INT8 game; _parser0.parseINT8(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	INT8 limit; _parser0.parseINT8(limit);
	AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
	INT32 minBuyIn; _parser0.parseINT32(minBuyIn);
	AtfValidator::validateInt(_descr, "minBuyIn", minBuyIn, _checker, __FILE__, __LINE__);
	INT32 maxBuyIn; _parser0.parseINT32(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	INT32 ante; _parser0.parseINT32(ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	bool isFast; _parser0.parseBOOL(isFast);
	AtfValidator::validateInt(_descr, "isFast", isFast, _checker, __FILE__, __LINE__);
	INT8 maxPlayers; _parser0.parseINT8(maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	INT32 chipsQuantum; _parser0.parseINT32(chipsQuantum);
	AtfValidator::validateInt(_descr, "chipsQuantum", chipsQuantum, _checker, __FILE__, __LINE__);
	INT32 scalePM; _parser0.parseINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PString _descbuf;
	TableCommonThin::TableStakes::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tableStakes"), _fieldsWithUnparsedContent);
	if(_parser0.parseEnded()) return;
	int szVariableAntes = ThinAtf::LAtfVector< INT64, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("variableAntes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "variableAntes", szVariableAntes, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY(Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, availChips(std::move(_o.availChips))
	, defaultBuyIn(std::move(_o.defaultBuyIn))
	, seatFinderCli(std::move(_o.seatFinderCli))
	, userRollId(std::move(_o.userRollId))
	, clientServiceFlag(std::move(_o.clientServiceFlag))
	, playChips(std::move(_o.playChips))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY& Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY::operator=(Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		availChips = std::move(_o.availChips);
		defaultBuyIn = std::move(_o.defaultBuyIn);
		seatFinderCli = std::move(_o.seatFinderCli);
		userRollId = std::move(_o.userRollId);
		clientServiceFlag = std::move(_o.clientServiceFlag);
		playChips = std::move(_o.playChips);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	availChips = 0;
	defaultBuyIn = 0;
	seatFinderCli.clear();
	userRollId = 0;
	clientServiceFlag = 0;
	playChips = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY::equals(const Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		availChips == _o.availChips &&
		defaultBuyIn == _o.defaultBuyIn &&
		seatFinderCli.equals(_o.seatFinderCli) &&
		userRollId == _o.userRollId &&
		clientServiceFlag == _o.clientServiceFlag &&
		playChips == _o.playChips;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("availChips=");
		_buf.appendInt(availChips);
		_buf.append(',');
		_buf.append("defaultBuyIn=");
		_buf.appendInt(defaultBuyIn);
		_buf.append(',');
		_buf.append("seatFinderCli=");
		seatFinderCli.toTraceString(_buf);
		_buf.append(',');
		_buf.append("userRollId=");
		_buf.appendInt(userRollId);
		_buf.append(',');
		_buf.append("clientServiceFlag=");
		_buf.appendUint(clientServiceFlag);
		_buf.append(',');
		_buf.append("playChips=");
		_buf.appendInt64(playChips);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(availChips);
		_msg.composeINT32(defaultBuyIn);
		seatFinderCli.composeMsg(_msg);
		_msg.composeINT32(userRollId);
		_msg.composeBYTE(clientServiceFlag);
		_msg.composeINT64(playChips);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(availChips);
		_parser.parseINT32(defaultBuyIn);
		seatFinderCli.parseMsg(_parser);
		_parser.parseINT32(userRollId);
		_parser.parseBYTE(clientServiceFlag);
		_parser.parseINT64(playChips);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 availChips; _parser.parseINT32(availChips);
		AtfValidator::validateInt(_descr, "availChips", availChips, _checker, __FILE__, __LINE__);
		INT32 defaultBuyIn; _parser.parseINT32(defaultBuyIn);
		AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
		PString _descbuf;
		SeatFinderCli_MsgBodyStruct::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("seatFinderCli"), _fieldsWithUnparsedContent);
		INT32 userRollId; _parser.parseINT32(userRollId);
		AtfValidator::validateInt(_descr, "userRollId", userRollId, _checker, __FILE__, __LINE__);
		BYTE clientServiceFlag; _parser.parseBYTE(clientServiceFlag);
		AtfValidator::validateInt(_descr, "clientServiceFlag", clientServiceFlag, _checker, __FILE__, __LINE__);
		INT64 playChips; _parser.parseINT64(playChips);
		AtfValidator::validateInt(_descr, "playChips", playChips, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_UPDATE_DOB
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB::Protocol_MSG_LOBBY_UPDATE_DOB()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB::Protocol_MSG_LOBBY_UPDATE_DOB(Protocol_MSG_LOBBY_UPDATE_DOB&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, dob(std::move(_o.dob))
{
}

Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB& Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB::operator=(Protocol_MSG_LOBBY_UPDATE_DOB&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		dob = std::move(_o.dob);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB::clear()
{
	notUsedStr.clear();
	dob.setNull();
}

bool Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB::equals(const Protocol_MSG_LOBBY_UPDATE_DOB& _o) const
{
	return notUsedStr.equals(_o.notUsedStr) &&
		dob.equals(_o.dob);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_UPDATE_DOB).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("dob=");
	ThinAtf::AtfTempl<SrvDate>::ToTraceString(_buf, dob);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(notUsedStr);
	_msg.composeSrvDate(dob);
}

void Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseSrvDate(dob);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_UPDATE_DOB";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	SrvDate dob; _parser.parseSrvDate(dob);
	AtfValidator::validateSrvDateTime(_descr, "dob", dob, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_UPDATE_DOB_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB_REPLY::Protocol_MSG_LOBBY_UPDATE_DOB_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB_REPLY::Protocol_MSG_LOBBY_UPDATE_DOB_REPLY(Protocol_MSG_LOBBY_UPDATE_DOB_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB_REPLY& Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB_REPLY::operator=(Protocol_MSG_LOBBY_UPDATE_DOB_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB_REPLY::equals(const Protocol_MSG_LOBBY_UPDATE_DOB_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_UPDATE_DOB_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errDesc=");
	_buf.append(errDesc);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errDesc);
}

void Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(errDesc);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_UPDATE_DOB_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_TOURN
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN::Protocol_MSG_LOBBY_FIND_TOURN()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN::clear()
{
	id = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN::equals(const Protocol_MSG_LOBBY_FIND_TOURN& _o) const
{
	return id == _o.id;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_TOURN).append(")");
	_buf.append(',');
	_buf.append("id=");
	_buf.appendUint(id);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(id);
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(id);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TOURN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 id; _parser.parseUINT32(id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_TOURN_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REPLY::Protocol_MSG_LOBBY_FIND_TOURN_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REPLY::Protocol_MSG_LOBBY_FIND_TOURN_REPLY(Protocol_MSG_LOBBY_FIND_TOURN_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, tournamentId(std::move(_o.tournamentId))
	, server(std::move(_o.server))
	, tournFlags(std::move(_o.tournFlags))
	, tournFlags2(std::move(_o.tournFlags2))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REPLY& Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REPLY::operator=(Protocol_MSG_LOBBY_FIND_TOURN_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		tournamentId = std::move(_o.tournamentId);
		server = std::move(_o.server);
		tournFlags = std::move(_o.tournFlags);
		tournFlags2 = std::move(_o.tournFlags2);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	tournamentId = 0;
	server.clear();
	tournFlags = 0;
	tournFlags2 = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REPLY::equals(const Protocol_MSG_LOBBY_FIND_TOURN_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		tournamentId == _o.tournamentId &&
		server.equals(_o.server) &&
		tournFlags == _o.tournFlags &&
		tournFlags2 == _o.tournFlags2;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_TOURN_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("tournamentId=");
		_buf.appendUint(tournamentId);
		_buf.append(',');
		_buf.append("server=");
		_buf.append(server);
		_buf.append(',');
		_buf.append("tournFlags=");
		_buf.appendUint(tournFlags);
		_buf.append(',');
		_buf.append("tournFlags2=");
		_buf.appendUint64(tournFlags2);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(tournamentId);
		_msg.composeString(server);
		_msg.composeUINT32(tournFlags);
		_msg.composeUINT64(tournFlags2);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(tournamentId);
		_parser.parseStringP(server);
		_parser.parseUINT32(tournFlags);
		_parser.parseUINT64(tournFlags2);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TOURN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 tournamentId; _parser.parseUINT32(tournamentId);
		AtfValidator::validateInt(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
		UINT32 tournFlags; _parser.parseUINT32(tournFlags);
		AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
		UINT64 tournFlags2; _parser.parseUINT64(tournFlags2);
		AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_WEB_FIND_TOURN
//=================================================================

Lobby::cli::Protocol_MSG_WEB_FIND_TOURN::Protocol_MSG_WEB_FIND_TOURN()
{
	clear();
}

void Lobby::cli::Protocol_MSG_WEB_FIND_TOURN::clear()
{
	id = 0;
}

bool Lobby::cli::Protocol_MSG_WEB_FIND_TOURN::equals(const Protocol_MSG_WEB_FIND_TOURN& _o) const
{
	return id == _o.id;
}

const char *Lobby::cli::Protocol_MSG_WEB_FIND_TOURN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_WEB_FIND_TOURN).append(")");
	_buf.append(',');
	_buf.append("id=");
	_buf.appendUint(id);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_WEB_FIND_TOURN::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(id);
}

void Lobby::cli::Protocol_MSG_WEB_FIND_TOURN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(id);
}

/*static*/ void Lobby::cli::Protocol_MSG_WEB_FIND_TOURN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_WEB_FIND_TOURN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 id; _parser.parseUINT32(id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_WEB_FIND_TOURN_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_WEB_FIND_TOURN_REPLY::Protocol_MSG_WEB_FIND_TOURN_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_WEB_FIND_TOURN_REPLY::Protocol_MSG_WEB_FIND_TOURN_REPLY(Protocol_MSG_WEB_FIND_TOURN_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, tournamentId(std::move(_o.tournamentId))
	, server(std::move(_o.server))
	, tournFlags(std::move(_o.tournFlags))
	, tournFlags2(std::move(_o.tournFlags2))
{
}

Lobby::cli::Protocol_MSG_WEB_FIND_TOURN_REPLY& Lobby::cli::Protocol_MSG_WEB_FIND_TOURN_REPLY::operator=(Protocol_MSG_WEB_FIND_TOURN_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		tournamentId = std::move(_o.tournamentId);
		server = std::move(_o.server);
		tournFlags = std::move(_o.tournFlags);
		tournFlags2 = std::move(_o.tournFlags2);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_WEB_FIND_TOURN_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	tournamentId = 0;
	server.clear();
	tournFlags = 0;
	tournFlags2 = 0;
}

bool Lobby::cli::Protocol_MSG_WEB_FIND_TOURN_REPLY::equals(const Protocol_MSG_WEB_FIND_TOURN_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		tournamentId == _o.tournamentId &&
		server.equals(_o.server) &&
		tournFlags == _o.tournFlags &&
		tournFlags2 == _o.tournFlags2;
}

const char *Lobby::cli::Protocol_MSG_WEB_FIND_TOURN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_WEB_FIND_TOURN_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("tournamentId=");
		_buf.appendUint(tournamentId);
		_buf.append(',');
		_buf.append("server=");
		_buf.append(server);
		_buf.append(',');
		_buf.append("tournFlags=");
		_buf.appendUint(tournFlags);
		_buf.append(',');
		_buf.append("tournFlags2=");
		_buf.appendUint64(tournFlags2);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_WEB_FIND_TOURN_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(tournamentId);
		_msg.composeString(server);
		_msg.composeUINT32(tournFlags);
		_msg.composeUINT64(tournFlags2);
	}
}

void Lobby::cli::Protocol_MSG_WEB_FIND_TOURN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(tournamentId);
		_parser.parseStringP(server);
		_parser.parseUINT32(tournFlags);
		_parser.parseUINT64(tournFlags2);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_WEB_FIND_TOURN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_WEB_FIND_TOURN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 tournamentId; _parser.parseUINT32(tournamentId);
		AtfValidator::validateInt(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
		UINT32 tournFlags; _parser.parseUINT32(tournFlags);
		AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
		UINT64 tournFlags2; _parser.parseUINT64(tournFlags2);
		AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    Text
//=================================================================

Lobby::cli::Text::Text()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Text::Text(Text&& _o)
	: text1(std::move(_o.text1))
	, text2(std::move(_o.text2))
{
}

Lobby::cli::Text& Lobby::cli::Text::operator=(Text&& _o)
{
	if(this != &_o)
	{
		text1 = std::move(_o.text1);
		text2 = std::move(_o.text2);
	}
	return *this;
}

#endif

void Lobby::cli::Text::clear()
{
	text1.clear();
	text2.clear();
}

bool Lobby::cli::Text::equals(const Text& _o) const
{
	return text1.equals(_o.text1) &&
		text2.equals(_o.text2);
}

const char *Lobby::cli::Text::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("text1=");
	_buf.append(text1);
	_buf.append(',');
	_buf.append("text2=");
	_buf.append(text2);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::Text::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(text1);
	_msg.composeString(text2);
}

void Lobby::cli::Text::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(text1);
	_parser.parseStringP(text2);
}

/*static*/ void Lobby::cli::Text::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "text1"); size_t szText1 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "text1", szText1, 10000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "text2"); size_t szText2 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "text2", szText2, 10000, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    Name
//=================================================================

Lobby::cli::Name::Name()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Name::Name(Name&& _o)
	: name(std::move(_o.name))
{
}

Lobby::cli::Name& Lobby::cli::Name::operator=(Name&& _o)
{
	if(this != &_o)
	{
		name = std::move(_o.name);
	}
	return *this;
}

#endif

void Lobby::cli::Name::clear()
{
	name.clear();
}

bool Lobby::cli::Name::equals(const Name& _o) const
{
	return name.equals(_o.name);
}

const char *Lobby::cli::Name::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("name=");
	_buf.append(name);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::Name::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(name);
}

void Lobby::cli::Name::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(name);
}

/*static*/ void Lobby::cli::Name::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "name", szName, 10000, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_CHAT_COMPL
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_CHAT_COMPL::Protocol_MSG_LOBBY_CHAT_COMPL()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_CHAT_COMPL::Protocol_MSG_LOBBY_CHAT_COMPL(Protocol_MSG_LOBBY_CHAT_COMPL&& _o)
	: handId(std::move(_o.handId))
	, tableName(std::move(_o.tableName))
	, comment(std::move(_o.comment))
	, tableId32(std::move(_o.tableId32))
	, texts(std::move(_o.texts))
	, names(std::move(_o.names))
	, tournId(std::move(_o.tournId))
	, finalTableText(std::move(_o.finalTableText))
	, zoomReplayId(std::move(_o.zoomReplayId))
	, tableId(std::move(_o.tableId))
{
}

Lobby::cli::Protocol_MSG_LOBBY_CHAT_COMPL& Lobby::cli::Protocol_MSG_LOBBY_CHAT_COMPL::operator=(Protocol_MSG_LOBBY_CHAT_COMPL&& _o)
{
	if(this != &_o)
	{
		handId = std::move(_o.handId);
		tableName = std::move(_o.tableName);
		comment = std::move(_o.comment);
		tableId32 = std::move(_o.tableId32);
		texts = std::move(_o.texts);
		names = std::move(_o.names);
		tournId = std::move(_o.tournId);
		finalTableText = std::move(_o.finalTableText);
		zoomReplayId = std::move(_o.zoomReplayId);
		tableId = std::move(_o.tableId);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_CHAT_COMPL::clear()
{
	handId = 0;
	tableName.clear();
	comment.clear();
	tableId32 = 0;
	texts.clear();
	names.clear();
	tournId = 0;
	finalTableText.clear();
	zoomReplayId = 0;
	tableId = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_CHAT_COMPL::equals(const Protocol_MSG_LOBBY_CHAT_COMPL& _o) const
{
	return handId == _o.handId &&
		tableName.equals(_o.tableName) &&
		comment.equals(_o.comment) &&
		tableId32 == _o.tableId32 &&
		texts.equals(_o.texts) &&
		names.equals(_o.names) &&
		tournId == _o.tournId &&
		finalTableText.equals(_o.finalTableText) &&
		zoomReplayId == _o.zoomReplayId &&
		tableId == _o.tableId;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CHAT_COMPL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CHAT_COMPL).append(")");
	_buf.append(',');
	_buf.append("handId=");
	_buf.appendUint64(handId);
	_buf.append(',');
	_buf.append("tableName=");
	_buf.append(tableName);
	_buf.append(',');
	_buf.append("comment=");
	_buf.append(comment);
	_buf.append(',');
	_buf.append("tableId32=");
	_buf.appendUint(tableId32);
	_buf.append(',');
	_buf.append("texts=");
	texts.toTraceString(_buf);
	_buf.append(',');
	_buf.append("names=");
	names.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("finalTableText=");
	_buf.append(finalTableText);
	_buf.append(',');
	_buf.append("zoomReplayId=");
	_buf.appendUint(zoomReplayId);
	_buf.append(',');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_CHAT_COMPL::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT64(handId);
	_msg.composeString(tableName);
	_msg.composeString(comment);
	_msg.composeUINT32(tableId32);
	texts.composeMsg(_msg);
	names.composeMsg(_msg);
	_msg.composeUINT32(tournId);
	_msg.composeString(finalTableText);
	_msg.composeUINT32(zoomReplayId);
	_msg.composeUINT64(tableId);
}

void Lobby::cli::Protocol_MSG_LOBBY_CHAT_COMPL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(handId);
	_parser.parseStringP(tableName);
	_parser.parseStringP(comment);
	_parser.parseUINT32(tableId32);
	texts.parseMsg(_parser);
	names.parseMsg(_parser);
	_parser.parseUINT32(tournId);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(finalTableText);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(zoomReplayId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(tableId);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CHAT_COMPL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CHAT_COMPL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT64 handId; _parser.parseUINT64(handId);
	AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "tableName"); size_t szTableName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "tableName", szTableName, TABLE_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "comment"); size_t szComment = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "comment", szComment, 1000, _checker, __FILE__, __LINE__);
	UINT32 tableId32; _parser.parseUINT32(tableId32);
	AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTexts = ThinAtf::LAtfVector< Text, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("texts"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "texts", szTexts, 10000, _checker, __FILE__, __LINE__);
	int szNames = ThinAtf::LAtfVector< Name, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("names"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "names", szNames, 10000, _checker, __FILE__, __LINE__);
	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "finalTableText"); size_t szFinalTableText = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "finalTableText", szFinalTableText, 10000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 zoomReplayId; _parser.parseUINT32(zoomReplayId);
	AtfValidator::validateInt(_descr, "zoomReplayId", zoomReplayId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 tableId; _parser.parseUINT64(tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CLI_BOUNCED
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED::Protocol_MSG_LOBBY_CLI_BOUNCED()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED::Protocol_MSG_LOBBY_CLI_BOUNCED(Protocol_MSG_LOBBY_CLI_BOUNCED&& _o)
	: email(std::move(_o.email))
{
}

Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED& Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED::operator=(Protocol_MSG_LOBBY_CLI_BOUNCED&& _o)
{
	if(this != &_o)
	{
		email = std::move(_o.email);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED::clear()
{
	email.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED::equals(const Protocol_MSG_LOBBY_CLI_BOUNCED& _o) const
{
	return email.equals(_o.email);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CLI_BOUNCED).append(")");
	_buf.append(',');
	_buf.append("email=");
	_buf.append(email);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(email);
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(email);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLI_BOUNCED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
	AtfValidator::validateInt(_descr, "email", szEmail, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY::Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY::Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY(Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, reset(std::move(_o.reset))
	, sendValidationCode(std::move(_o.sendValidationCode))
{
}

Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY& Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY::operator=(Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		reset = std::move(_o.reset);
		sendValidationCode = std::move(_o.sendValidationCode);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY::clear()
{
	notUsedStr.clear();
	reset = 0;
	sendValidationCode = false;
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY::equals(const Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY& _o) const
{
	return notUsedStr.equals(_o.notUsedStr) &&
		reset == _o.reset &&
		sendValidationCode == _o.sendValidationCode;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CLI_BOUNCED_REPLY).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("reset=");
	_buf.appendUint(reset);
	_buf.append(',');
	_buf.append("sendValidationCode=");
	_buf.appendUint(sendValidationCode);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(notUsedStr);
	_msg.composeBYTE(reset);
	_msg.composeBOOL(sendValidationCode);
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseBYTE(reset);
	_parser.parseBOOL(sendValidationCode);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLI_BOUNCED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	BYTE reset; _parser.parseBYTE(reset);
	AtfValidator::validateIntMax(_descr, "reset", reset, 1, _checker, __FILE__, __LINE__);
	bool sendValidationCode; _parser.parseBOOL(sendValidationCode);
	AtfValidator::validateInt(_descr, "sendValidationCode", sendValidationCode, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CREATE_USERTOURN
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_CREATE_USERTOURN::Protocol_MSG_LOBBY_CREATE_USERTOURN()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_CREATE_USERTOURN::Protocol_MSG_LOBBY_CREATE_USERTOURN(Protocol_MSG_LOBBY_CREATE_USERTOURN&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, password(std::move(_o.password))
	, game(std::move(_o.game))
	, isHL(std::move(_o.isHL))
	, limit(std::move(_o.limit))
	, mon(std::move(_o.mon))
	, day(std::move(_o.day))
	, hour(std::move(_o.hour))
	, minute(std::move(_o.minute))
	, buyIn(std::move(_o.buyIn))
	, rake(std::move(_o.rake))
	, message(std::move(_o.message))
	, name(std::move(_o.name))
	, olymp(std::move(_o.olymp))
{
}

Lobby::cli::Protocol_MSG_LOBBY_CREATE_USERTOURN& Lobby::cli::Protocol_MSG_LOBBY_CREATE_USERTOURN::operator=(Protocol_MSG_LOBBY_CREATE_USERTOURN&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		password = std::move(_o.password);
		game = std::move(_o.game);
		isHL = std::move(_o.isHL);
		limit = std::move(_o.limit);
		mon = std::move(_o.mon);
		day = std::move(_o.day);
		hour = std::move(_o.hour);
		minute = std::move(_o.minute);
		buyIn = std::move(_o.buyIn);
		rake = std::move(_o.rake);
		message = std::move(_o.message);
		name = std::move(_o.name);
		olymp = std::move(_o.olymp);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_CREATE_USERTOURN::clear()
{
	notUsedStr.clear();
	password.clear();
	game = 0;
	isHL = 0;
	limit = 0;
	mon = 0;
	day = 0;
	hour = 0;
	minute = 0;
	buyIn = 0;
	rake = 0;
	message.clear();
	name.clear();
	olymp = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_CREATE_USERTOURN::equals(const Protocol_MSG_LOBBY_CREATE_USERTOURN& _o) const
{
	return notUsedStr.equals(_o.notUsedStr) &&
		password.equals(_o.password) &&
		game == _o.game &&
		isHL == _o.isHL &&
		limit == _o.limit &&
		mon == _o.mon &&
		day == _o.day &&
		hour == _o.hour &&
		minute == _o.minute &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		message.equals(_o.message) &&
		name.equals(_o.name) &&
		olymp == _o.olymp;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CREATE_USERTOURN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CREATE_USERTOURN).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("password=");
	_buf.append(password);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("isHL=");
	_buf.appendUint(isHL);
	_buf.append(',');
	_buf.append("limit=");
	_buf.appendUint(limit);
	_buf.append(',');
	_buf.append("mon=");
	_buf.appendUint(mon);
	_buf.append(',');
	_buf.append("day=");
	_buf.appendUint(day);
	_buf.append(',');
	_buf.append("hour=");
	_buf.appendUint(hour);
	_buf.append(',');
	_buf.append("minute=");
	_buf.appendUint(minute);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendInt(buyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendInt(rake);
	_buf.append(',');
	_buf.append("message=");
	_buf.append(message);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("olymp=");
	_buf.appendUint(olymp);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_CREATE_USERTOURN::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(notUsedStr);
	_msg.composeString(password);
	_msg.composeBYTE(game);
	_msg.composeBYTE(isHL);
	_msg.composeBYTE(limit);
	_msg.composeBYTE(mon);
	_msg.composeBYTE(day);
	_msg.composeBYTE(hour);
	_msg.composeBYTE(minute);
	_msg.composeINT32(buyIn);
	_msg.composeINT32(rake);
	_msg.composeString(message);
	_msg.composeString(name);
	_msg.composeBYTE(olymp);
}

void Lobby::cli::Protocol_MSG_LOBBY_CREATE_USERTOURN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseStringP(password);
	_parser.parseBYTE(game);
	_parser.parseBYTE(isHL);
	_parser.parseBYTE(limit);
	_parser.parseBYTE(mon);
	_parser.parseBYTE(day);
	_parser.parseBYTE(hour);
	_parser.parseBYTE(minute);
	_parser.parseINT32(buyIn);
	_parser.parseINT32(rake);
	_parser.parseStringP(message);
	_parser.parseStringP(name);
	_parser.parseBYTE(olymp);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CREATE_USERTOURN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CREATE_USERTOURN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "password"); size_t szPassword = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "password", szPassword, 1000, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateIntMax(_descr, "game", game, HandType_Last, _checker, __FILE__, __LINE__);
	BYTE isHL; _parser.parseBYTE(isHL);
	AtfValidator::validateIntMax(_descr, "isHL", isHL, 1, _checker, __FILE__, __LINE__);
	BYTE limit; _parser.parseBYTE(limit);
	AtfValidator::validateIntMax(_descr, "limit", limit, PotStruct_Last, _checker, __FILE__, __LINE__);
	BYTE mon; _parser.parseBYTE(mon);
	AtfValidator::validateIntMax(_descr, "mon", mon, 12, _checker, __FILE__, __LINE__);
	BYTE day; _parser.parseBYTE(day);
	AtfValidator::validateIntMax(_descr, "day", day, 31, _checker, __FILE__, __LINE__);
	BYTE hour; _parser.parseBYTE(hour);
	AtfValidator::validateIntMax(_descr, "hour", hour, 23, _checker, __FILE__, __LINE__);
	BYTE minute; _parser.parseBYTE(minute);
	AtfValidator::validateIntMax(_descr, "minute", minute, 59, _checker, __FILE__, __LINE__);
	INT32 buyIn; _parser.parseINT32(buyIn);
	AtfValidator::validateIntRange(_descr, "buyIn", buyIn, -2000000000, 20000000, _checker, __FILE__, __LINE__);
	INT32 rake; _parser.parseINT32(rake);
	AtfValidator::validateIntRange(_descr, "rake", rake, -2000000000, 20000000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "message"); size_t szMessage = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "message", szMessage, 1000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "name", szName, 200, _checker, __FILE__, __LINE__);
	BYTE olymp; _parser.parseBYTE(olymp);
	AtfValidator::validateIntMax(_descr, "olymp", olymp, 1, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    TournamentCreationError
//=================================================================

Lobby::cli::TournamentCreationError::TournamentCreationError()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::TournamentCreationError::TournamentCreationError(TournamentCreationError&& _o)
	: userId(std::move(_o.userId))
	, error_code(std::move(_o.error_code))
	, errDescr(std::move(_o.errDescr))
{
}

Lobby::cli::TournamentCreationError& Lobby::cli::TournamentCreationError::operator=(TournamentCreationError&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		error_code = std::move(_o.error_code);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void Lobby::cli::TournamentCreationError::clear()
{
	userId.clear();
	error_code = 0;
	errDescr.clear();
}

bool Lobby::cli::TournamentCreationError::equals(const TournamentCreationError& _o) const
{
	return userId.equals(_o.userId) &&
		error_code == _o.error_code &&
		errDescr.equals(_o.errDescr);
}

const char *Lobby::cli::TournamentCreationError::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("error_code=");
	_buf.appendUint(error_code);
	_buf.append(',');
	_buf.append("errDescr=");
	_buf.append(errDescr);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::TournamentCreationError::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeUINT32(error_code);
	_msg.composeString(errDescr);
}

void Lobby::cli::TournamentCreationError::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseUINT32(error_code);
	_parser.parseStringP(errDescr);
}

/*static*/ void Lobby::cli::TournamentCreationError::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	UINT32 error_code; _parser.parseUINT32(error_code);
	AtfValidator::validateInt(_descr, "error_code", error_code, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY::Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY::Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY(Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, tournId(std::move(_o.tournId))
	, timeLeft(std::move(_o.timeLeft))
	, errors(std::move(_o.errors))
	, warning(std::move(_o.warning))
	, restartWarning(std::move(_o.restartWarning))
{
}

Lobby::cli::Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY& Lobby::cli::Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY::operator=(Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		tournId = std::move(_o.tournId);
		timeLeft = std::move(_o.timeLeft);
		errors = std::move(_o.errors);
		warning = std::move(_o.warning);
		restartWarning = std::move(_o.restartWarning);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	tournId = 0;
	timeLeft = 0;
	errors.clear();
	warning.clear();
	restartWarning.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY::equals(const Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		tournId == _o.tournId &&
		timeLeft == _o.timeLeft &&
		errors.equals(_o.errors) &&
		warning.equals(_o.warning) &&
		restartWarning.equals(_o.restartWarning);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CREATE_TOURNAMENT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != 0 )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("tournId=");
		_buf.appendUint(tournId);
		_buf.append(',');
		_buf.append("timeLeft=");
		_buf.appendUint(timeLeft);
		_buf.append(',');
		_buf.append("errors=");
		errors.toTraceString(_buf);
		_buf.append(',');
		_buf.append("warning=");
		_buf.append(warning);
		_buf.append(',');
		_buf.append("restartWarning=");
		_buf.append(restartWarning);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode != 0 )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(tournId);
		_msg.composeUINT32(timeLeft);
		errors.composeMsg(_msg);
		_msg.composeString(warning);
		_msg.composeString(restartWarning);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != 0 )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(tournId);
		_parser.parseUINT32(timeLeft);
		errors.parseMsg(_parser);
		_parser.parseStringP(warning);
		_parser.parseStringP(restartWarning);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CREATE_TOURNAMENT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 tournId; _parser.parseUINT32(tournId);
		AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
		UINT32 timeLeft; _parser.parseUINT32(timeLeft);
		AtfValidator::validateInt(_descr, "timeLeft", timeLeft, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szErrors = ThinAtf::LAtfVector< TournamentCreationError, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("errors"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "errors", szErrors, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "warning"); size_t szWarning = strlen(_dummy);
		AtfValidator::validateInt(_descr, "warning", szWarning, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "restartWarning"); size_t szRestartWarning = strlen(_dummy);
		AtfValidator::validateInt(_descr, "restartWarning", szRestartWarning, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_REGISTER_TOURN_USER
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER::Protocol_MSG_LOBBY_REGISTER_TOURN_USER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER::Protocol_MSG_LOBBY_REGISTER_TOURN_USER(Protocol_MSG_LOBBY_REGISTER_TOURN_USER&& _o)
	: tournId(std::move(_o.tournId))
	, notUsedStr(std::move(_o.notUsedStr))
	, buyInRM(std::move(_o.buyInRM))
	, buyInPlay(std::move(_o.buyInPlay))
	, buyInFpp(std::move(_o.buyInFpp))
	, tournPwd(std::move(_o.tournPwd))
	, useTicket(std::move(_o.useTicket))
	, buyInT(std::move(_o.buyInT))
	, buyInW(std::move(_o.buyInW))
	, currencyContext(std::move(_o.currencyContext))
	, isoCode(std::move(_o.isoCode))
	, game(std::move(_o.game))
	, highLo(std::move(_o.highLo))
	, structure(std::move(_o.structure))
	, startTime(std::move(_o.startTime))
	, allowLateRegistration(std::move(_o.allowLateRegistration))
	, preferRegistrationIntoLateTarget(std::move(_o.preferRegistrationIntoLateTarget))
{
}

Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER& Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER::operator=(Protocol_MSG_LOBBY_REGISTER_TOURN_USER&& _o)
{
	if(this != &_o)
	{
		tournId = std::move(_o.tournId);
		notUsedStr = std::move(_o.notUsedStr);
		buyInRM = std::move(_o.buyInRM);
		buyInPlay = std::move(_o.buyInPlay);
		buyInFpp = std::move(_o.buyInFpp);
		tournPwd = std::move(_o.tournPwd);
		useTicket = std::move(_o.useTicket);
		buyInT = std::move(_o.buyInT);
		buyInW = std::move(_o.buyInW);
		currencyContext = std::move(_o.currencyContext);
		isoCode = std::move(_o.isoCode);
		game = std::move(_o.game);
		highLo = std::move(_o.highLo);
		structure = std::move(_o.structure);
		startTime = std::move(_o.startTime);
		allowLateRegistration = std::move(_o.allowLateRegistration);
		preferRegistrationIntoLateTarget = std::move(_o.preferRegistrationIntoLateTarget);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER::clear()
{
	tournId = 0;
	notUsedStr.clear();
	buyInRM = 0;
	buyInPlay = 0;
	buyInFpp = 0;
	tournPwd.clear();
	useTicket = 0;
	buyInT = 0;
	buyInW = 0;
	currencyContext.clear();
	isoCode.clear();
	game = 0;
	highLo = 0;
	structure = 0;
	startTime.setNull();
	allowLateRegistration = false;
	preferRegistrationIntoLateTarget = false;
}

bool Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER::equals(const Protocol_MSG_LOBBY_REGISTER_TOURN_USER& _o) const
{
	return tournId == _o.tournId &&
		notUsedStr.equals(_o.notUsedStr) &&
		buyInRM == _o.buyInRM &&
		buyInPlay == _o.buyInPlay &&
		buyInFpp == _o.buyInFpp &&
		tournPwd.equals(_o.tournPwd) &&
		useTicket == _o.useTicket &&
		buyInT == _o.buyInT &&
		buyInW == _o.buyInW &&
		currencyContext.equals(_o.currencyContext) &&
		isoCode.equals(_o.isoCode) &&
		game == _o.game &&
		highLo == _o.highLo &&
		structure == _o.structure &&
		startTime.equals(_o.startTime) &&
		allowLateRegistration == _o.allowLateRegistration &&
		preferRegistrationIntoLateTarget == _o.preferRegistrationIntoLateTarget;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_REGISTER_TOURN_USER).append(")");
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("buyInRM=");
	_buf.appendUint(buyInRM);
	_buf.append(',');
	_buf.append("buyInPlay=");
	_buf.appendUint(buyInPlay);
	_buf.append(',');
	_buf.append("buyInFpp=");
	_buf.appendUint(buyInFpp);
	_buf.append(',');
	_buf.append("tournPwd=");
	_buf.append(tournPwd);
	_buf.append(',');
	_buf.append("useTicket=");
	_buf.appendUint(useTicket);
	_buf.append(',');
	_buf.append("buyInT=");
	_buf.appendUint(buyInT);
	_buf.append(',');
	_buf.append("buyInW=");
	_buf.appendUint(buyInW);
	_buf.append(',');
	_buf.append("currencyContext=");
	currencyContext.toTraceString(_buf);
	_buf.append(',');
	_buf.append("isoCode=");
	_buf.append(isoCode);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("highLo=");
	_buf.appendUint(highLo);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("startTime=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, startTime);
	_buf.append(',');
	_buf.append("allowLateRegistration=");
	_buf.appendUint(allowLateRegistration);
	_buf.append(',');
	_buf.append("preferRegistrationIntoLateTarget=");
	_buf.appendUint(preferRegistrationIntoLateTarget);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(tournId);
	_msg.composeString(notUsedStr);
	_msg.composeUINT32(buyInRM);
	_msg.composeUINT32(buyInPlay);
	_msg.composeUINT32(buyInFpp);
	_msg.composeString(tournPwd);
	_msg.composeBYTE(useTicket);
	_msg.composeUINT32(buyInT);
	_msg.composeUINT32(buyInW);
	_msg.composeMsgBody(currencyContext);
	_msg.composeString(isoCode);
	_msg.composeBYTE(game);
	_msg.composeBYTE(highLo);
	_msg.composeBYTE(structure);
	_msg.composeSrvTime(startTime);
	_msg.composeBOOL(allowLateRegistration);
	_msg.composeBOOL(preferRegistrationIntoLateTarget);
}

void Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tournId);
	_parser.parseStringP(notUsedStr);
	_parser.parseUINT32(buyInRM);
	_parser.parseUINT32(buyInPlay);
	_parser.parseUINT32(buyInFpp);
	_parser.parseStringP(tournPwd);
	_parser.parseBYTE(useTicket);
	_parser.parseUINT32(buyInT);
	_parser.parseUINT32(buyInW);
	if(_parser.parseEnded()) return;
	_parser.parseMsgBody(currencyContext);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(isoCode);
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(game);
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(highLo);
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(structure);
	if(_parser.parseEnded()) return;
	_parser.parseSrvTime(startTime);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(allowLateRegistration);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(preferRegistrationIntoLateTarget);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_REGISTER_TOURN_USER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	UINT32 buyInRM; _parser.parseUINT32(buyInRM);
	AtfValidator::validateIntMax(_descr, "buyInRM", buyInRM, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 buyInPlay; _parser.parseUINT32(buyInPlay);
	AtfValidator::validateInt(_descr, "buyInPlay", buyInPlay, _checker, __FILE__, __LINE__);
	UINT32 buyInFpp; _parser.parseUINT32(buyInFpp);
	AtfValidator::validateIntMax(_descr, "buyInFpp", buyInFpp, 2000000000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "tournPwd"); size_t szTournPwd = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "tournPwd", szTournPwd, 1000, _checker, __FILE__, __LINE__);
	BYTE useTicket; _parser.parseBYTE(useTicket);
	AtfValidator::validateIntMax(_descr, "useTicket", useTicket, 1, _checker, __FILE__, __LINE__);
	UINT32 buyInT; _parser.parseUINT32(buyInT);
	AtfValidator::validateIntMax(_descr, "buyInT", buyInT, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 buyInW; _parser.parseUINT32(buyInW);
	AtfValidator::validateIntMax(_descr, "buyInW", buyInW, 0, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	size_t szCurrencyContext; _parser.skipMsgBody(szCurrencyContext);  /*currencyContext*/
	AtfValidator::validateIntMax(_descr, "currencyContext", szCurrencyContext, 10000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "isoCode"); size_t szIsoCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "isoCode", szIsoCode, 10, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	BYTE highLo; _parser.parseBYTE(highLo);
	AtfValidator::validateInt(_descr, "highLo", highLo, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	SrvTime startTime; _parser.parseSrvTime(startTime);
	AtfValidator::validateSrvDateTime(_descr, "startTime", startTime, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool allowLateRegistration; _parser.parseBOOL(allowLateRegistration);
	AtfValidator::validateInt(_descr, "allowLateRegistration", allowLateRegistration, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool preferRegistrationIntoLateTarget; _parser.parseBOOL(preferRegistrationIntoLateTarget);
	AtfValidator::validateInt(_descr, "preferRegistrationIntoLateTarget", preferRegistrationIntoLateTarget, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY::Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY::Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY(Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, allIn(std::move(_o.allIn))
	, text(std::move(_o.text))
	, tournId(std::move(_o.tournId))
	, seatAvail(std::move(_o.seatAvail))
	, srv(std::move(_o.srv))
	, socialToken(std::move(_o.socialToken))
	, clientNotification(std::move(_o.clientNotification))
{
}

Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY& Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY::operator=(Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		allIn = std::move(_o.allIn);
		text = std::move(_o.text);
		tournId = std::move(_o.tournId);
		seatAvail = std::move(_o.seatAvail);
		srv = std::move(_o.srv);
		socialToken = std::move(_o.socialToken);
		clientNotification = std::move(_o.clientNotification);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	allIn = 0;
	text.clear();
	tournId = 0;
	seatAvail = false;
	srv.clear();
	socialToken.clear();
	clientNotification.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY::equals(const Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		allIn == _o.allIn &&
		text.equals(_o.text) &&
		tournId == _o.tournId &&
		seatAvail == _o.seatAvail &&
		srv.equals(_o.srv) &&
		socialToken.equals(_o.socialToken) &&
		clientNotification.equals(_o.clientNotification);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_REGISTER_TOURN_USER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errDesc=");
	_buf.append(errDesc);
	if( !errCode || errCode == ALREADY_REGISTERED )
	{
		_buf.append(',');
		_buf.append("allIn=");
		_buf.appendInt(allIn);
		_buf.append(',');
		_buf.append("text=");
		_buf.append(text);
		_buf.append(',');
		_buf.append("tournId=");
		_buf.appendUint(tournId);
	}
	if( !errCode )
	{
		_buf.append(',');
		_buf.append("seatAvail=");
		_buf.appendUint(seatAvail);
		_buf.append(',');
		_buf.append("srv=");
		_buf.append(srv);
		_buf.append(',');
		_buf.append("socialToken=");
		_buf.append(socialToken);
		_buf.append(',');
		_buf.append("clientNotification=");
		_buf.append(clientNotification);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errDesc);
	if( !errCode || errCode == ALREADY_REGISTERED )
	{
		_msg.composeINT16(allIn);
		_msg.composeString(text);
		_msg.composeUINT32(tournId);
	}
	if( !errCode )
	{
		_msg.composeBOOL(seatAvail);
		_msg.composeString(srv);
		_msg.composeString(socialToken);
		_msg.composeString(clientNotification);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(errDesc);
	if( !errCode || errCode == ALREADY_REGISTERED )
	{
		_parser.parseINT16(allIn);
		_parser.parseStringP(text);
		_parser.parseUINT32(tournId);
	}
	if( !errCode )
	{
		_parser.parseBOOL(seatAvail);
		_parser.parseStringP(srv);
		_parser.parseStringP(socialToken);
		_parser.parseStringP(clientNotification);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_REGISTER_TOURN_USER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	if( !errCode || errCode == ALREADY_REGISTERED )
	{
		INT16 allIn; _parser.parseINT16(allIn);
		AtfValidator::validateInt(_descr, "allIn", allIn, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "text"); size_t szText = strlen(_dummy);
		AtfValidator::validateInt(_descr, "text", szText, _checker, __FILE__, __LINE__);
		UINT32 tournId; _parser.parseUINT32(tournId);
		AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	}
	if( !errCode )
	{
		bool seatAvail; _parser.parseBOOL(seatAvail);
		AtfValidator::validateInt(_descr, "seatAvail", seatAvail, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "srv"); size_t szSrv = strlen(_dummy);
		AtfValidator::validateInt(_descr, "srv", szSrv, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "socialToken"); size_t szSocialToken = strlen(_dummy);
		AtfValidator::validateInt(_descr, "socialToken", szSocialToken, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "clientNotification"); size_t szClientNotification = strlen(_dummy);
		AtfValidator::validateInt(_descr, "clientNotification", szClientNotification, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS::Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS::Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS(Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, setPriv(std::move(_o.setPriv))
{
}

Lobby::cli::Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS& Lobby::cli::Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS::operator=(Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		setPriv = std::move(_o.setPriv);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS::clear()
{
	notUsedStr.clear();
	setPriv = false;
}

bool Lobby::cli::Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS::equals(const Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS& _o) const
{
	return notUsedStr.equals(_o.notUsedStr) &&
		setPriv == _o.setPriv;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_PUBLISH_VIP_STATUS).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("setPriv=");
	_buf.appendUint(setPriv);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(notUsedStr);
	_msg.composeBOOL(setPriv);
}

void Lobby::cli::Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseBOOL(setPriv);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_PUBLISH_VIP_STATUS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	bool setPriv; _parser.parseBOOL(setPriv);
	AtfValidator::validateInt(_descr, "setPriv", setPriv, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_HIDE_MOBILE_ICON
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_HIDE_MOBILE_ICON::Protocol_MSG_LOBBY_HIDE_MOBILE_ICON()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_HIDE_MOBILE_ICON::clear()
{
	setPriv = false;
}

bool Lobby::cli::Protocol_MSG_LOBBY_HIDE_MOBILE_ICON::equals(const Protocol_MSG_LOBBY_HIDE_MOBILE_ICON& _o) const
{
	return setPriv == _o.setPriv;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_HIDE_MOBILE_ICON::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_HIDE_MOBILE_ICON).append(")");
	_buf.append(',');
	_buf.append("setPriv=");
	_buf.appendUint(setPriv);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_HIDE_MOBILE_ICON::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBOOL(setPriv);
}

void Lobby::cli::Protocol_MSG_LOBBY_HIDE_MOBILE_ICON::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(setPriv);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_HIDE_MOBILE_ICON::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_HIDE_MOBILE_ICON";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	bool setPriv; _parser.parseBOOL(setPriv);
	AtfValidator::validateInt(_descr, "setPriv", setPriv, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SET_TABLE_LIMITS2
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2(Protocol_MSG_LOBBY_SET_TABLE_LIMITS2&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, currency(std::move(_o.currency))
	, limit1(std::move(_o.limit1))
	, limitType1(std::move(_o.limitType1))
	, limit2(std::move(_o.limit2))
	, limitType2(std::move(_o.limitType2))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2& Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2::operator=(Protocol_MSG_LOBBY_SET_TABLE_LIMITS2&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		currency = std::move(_o.currency);
		limit1 = std::move(_o.limit1);
		limitType1 = std::move(_o.limitType1);
		limit2 = std::move(_o.limit2);
		limitType2 = std::move(_o.limitType2);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2::clear()
{
	notUsedStr.clear();
	currency.clear();
	limit1 = 0;
	limitType1 = 0;
	limit2 = 0;
	limitType2 = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2::equals(const Protocol_MSG_LOBBY_SET_TABLE_LIMITS2& _o) const
{
	return notUsedStr.equals(_o.notUsedStr) &&
		currency.equals(_o.currency) &&
		limit1 == _o.limit1 &&
		limitType1 == _o.limitType1 &&
		limit2 == _o.limit2 &&
		limitType2 == _o.limitType2;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SET_TABLE_LIMITS2).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("limit1=");
	_buf.appendInt(limit1);
	_buf.append(',');
	_buf.append("limitType1=");
	_buf.appendUint(limitType1);
	_buf.append(',');
	_buf.append("limit2=");
	_buf.appendInt(limit2);
	_buf.append(',');
	_buf.append("limitType2=");
	_buf.appendUint(limitType2);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(notUsedStr);
	_msg.composeString(currency);
	_msg.composeINT32(limit1);
	_msg.composeBYTE(limitType1);
	_msg.composeINT32(limit2);
	_msg.composeBYTE(limitType2);
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseStringP(currency);
	_parser.parseINT32(limit1);
	_parser.parseBYTE(limitType1);
	_parser.parseINT32(limit2);
	_parser.parseBYTE(limitType2);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_TABLE_LIMITS2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, 5, _checker, __FILE__, __LINE__);
	INT32 limit1; _parser.parseINT32(limit1);
	AtfValidator::validateIntMin(_descr, "limit1", limit1, -1, _checker, __FILE__, __LINE__);
	BYTE limitType1; _parser.parseBYTE(limitType1);
	AtfValidator::validateIntRange(_descr, "limitType1", limitType1, eTableLimitTypeAny, (numLimitTypes-1), _checker, __FILE__, __LINE__);
	INT32 limit2; _parser.parseINT32(limit2);
	AtfValidator::validateIntMin(_descr, "limit2", limit2, -1, _checker, __FILE__, __LINE__);
	BYTE limitType2; _parser.parseBYTE(limitType2);
	AtfValidator::validateIntRange(_descr, "limitType2", limitType2, eTableLimitTypeAny, (numLimitTypes-1), _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY(Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, limitType1(std::move(_o.limitType1))
	, errorCode1(std::move(_o.errorCode1))
	, errDescr1(std::move(_o.errDescr1))
	, effectiveNow1(std::move(_o.effectiveNow1))
	, limitType2(std::move(_o.limitType2))
	, errorCode2(std::move(_o.errorCode2))
	, errDescr2(std::move(_o.errDescr2))
	, effectiveNow2(std::move(_o.effectiveNow2))
	, limit(std::move(_o.limit))
	, waitingIncreaseLimitDays1(std::move(_o.waitingIncreaseLimitDays1))
	, waitingIncreaseLimitDays2(std::move(_o.waitingIncreaseLimitDays2))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY& Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY::operator=(Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		limitType1 = std::move(_o.limitType1);
		errorCode1 = std::move(_o.errorCode1);
		errDescr1 = std::move(_o.errDescr1);
		effectiveNow1 = std::move(_o.effectiveNow1);
		limitType2 = std::move(_o.limitType2);
		errorCode2 = std::move(_o.errorCode2);
		errDescr2 = std::move(_o.errDescr2);
		effectiveNow2 = std::move(_o.effectiveNow2);
		limit = std::move(_o.limit);
		waitingIncreaseLimitDays1 = std::move(_o.waitingIncreaseLimitDays1);
		waitingIncreaseLimitDays2 = std::move(_o.waitingIncreaseLimitDays2);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY::clear()
{
	errCode = 0;
	limitType1 = 0;
	errorCode1 = 0;
	errDescr1.clear();
	effectiveNow1 = false;
	limitType2 = 0;
	errorCode2 = 0;
	errDescr2.clear();
	effectiveNow2 = false;
	limit = 0;
	waitingIncreaseLimitDays1 = 0;
	waitingIncreaseLimitDays2 = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY::equals(const Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		limitType1 == _o.limitType1 &&
		errorCode1 == _o.errorCode1 &&
		errDescr1.equals(_o.errDescr1) &&
		effectiveNow1 == _o.effectiveNow1 &&
		limitType2 == _o.limitType2 &&
		errorCode2 == _o.errorCode2 &&
		errDescr2.equals(_o.errDescr2) &&
		effectiveNow2 == _o.effectiveNow2 &&
		limit == _o.limit &&
		waitingIncreaseLimitDays1 == _o.waitingIncreaseLimitDays1 &&
		waitingIncreaseLimitDays2 == _o.waitingIncreaseLimitDays2;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SET_TABLE_LIMITS2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("limitType1=");
	_buf.appendUint(limitType1);
	_buf.append(',');
	_buf.append("errorCode1=");
	_buf.appendInt(errorCode1);
	if(errorCode1)
	{
		_buf.append(',');
		_buf.append("errDescr1=");
		_buf.append(errDescr1);
	}
	else
	{
		_buf.append(',');
		_buf.append("effectiveNow1=");
		_buf.appendUint(effectiveNow1);
	}
	_buf.append(',');
	_buf.append("limitType2=");
	_buf.appendUint(limitType2);
	_buf.append(',');
	_buf.append("errorCode2=");
	_buf.appendInt(errorCode2);
	if(errorCode2)
	{
		_buf.append(',');
		_buf.append("errDescr2=");
		_buf.append(errDescr2);
	}
	else
	{
		_buf.append(',');
		_buf.append("effectiveNow2=");
		_buf.appendUint(effectiveNow2);
	}
	_buf.append(',');
	_buf.append("limit=");
	_buf.appendUint(limit);
	_buf.append(',');
	_buf.append("waitingIncreaseLimitDays1=");
	_buf.appendUint(waitingIncreaseLimitDays1);
	_buf.append(',');
	_buf.append("waitingIncreaseLimitDays2=");
	_buf.appendUint(waitingIncreaseLimitDays2);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	_msg.composeBYTE(limitType1);
	_msg.composeINT16(errorCode1);
	if(errorCode1)
	{
		_msg.composeString(errDescr1);
	}
	else
	{
		_msg.composeBOOL(effectiveNow1);
	}
	_msg.composeBYTE(limitType2);
	_msg.composeINT16(errorCode2);
	if(errorCode2)
	{
		_msg.composeString(errDescr2);
	}
	else
	{
		_msg.composeBOOL(effectiveNow2);
	}
	_msg.composeUINT32(limit);
	_msg.composeUINT32(waitingIncreaseLimitDays1);
	_msg.composeUINT32(waitingIncreaseLimitDays2);
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseBYTE(limitType1);
	_parser.parseINT16(errorCode1);
	if(errorCode1)
	{
		_parser.parseStringP(errDescr1);
	}
	else
	{
		_parser.parseBOOL(effectiveNow1);
	}
	_parser.parseBYTE(limitType2);
	_parser.parseINT16(errorCode2);
	if(errorCode2)
	{
		_parser.parseStringP(errDescr2);
	}
	else
	{
		_parser.parseBOOL(effectiveNow2);
	}
	_parser.parseUINT32(limit);
	_parser.parseUINT32(waitingIncreaseLimitDays1);
	_parser.parseUINT32(waitingIncreaseLimitDays2);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_TABLE_LIMITS2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errorCode1 = 0;
	INT16 errorCode2 = 0;
	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	BYTE limitType1; _parser.parseBYTE(limitType1);
	AtfValidator::validateInt(_descr, "limitType1", limitType1, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errorCode1);
	AtfValidator::validateInt(_descr, "errorCode1", errorCode1, _checker, __FILE__, __LINE__);
	if(errorCode1)
	{
		_parser.parseStringN(_dummy, 0, "errDescr1"); size_t szErrDescr1 = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr1", szErrDescr1, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool effectiveNow1; _parser.parseBOOL(effectiveNow1);
		AtfValidator::validateInt(_descr, "effectiveNow1", effectiveNow1, _checker, __FILE__, __LINE__);
	}
	BYTE limitType2; _parser.parseBYTE(limitType2);
	AtfValidator::validateInt(_descr, "limitType2", limitType2, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errorCode2);
	AtfValidator::validateInt(_descr, "errorCode2", errorCode2, _checker, __FILE__, __LINE__);
	if(errorCode2)
	{
		_parser.parseStringN(_dummy, 0, "errDescr2"); size_t szErrDescr2 = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr2", szErrDescr2, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool effectiveNow2; _parser.parseBOOL(effectiveNow2);
		AtfValidator::validateInt(_descr, "effectiveNow2", effectiveNow2, _checker, __FILE__, __LINE__);
	}
	UINT32 limit; _parser.parseUINT32(limit);
	AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
	UINT32 waitingIncreaseLimitDays1; _parser.parseUINT32(waitingIncreaseLimitDays1);
	AtfValidator::validateInt(_descr, "waitingIncreaseLimitDays1", waitingIncreaseLimitDays1, _checker, __FILE__, __LINE__);
	UINT32 waitingIncreaseLimitDays2; _parser.parseUINT32(waitingIncreaseLimitDays2);
	AtfValidator::validateInt(_descr, "waitingIncreaseLimitDays2", waitingIncreaseLimitDays2, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SET_TOURN_LIMITS
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS::Protocol_MSG_LOBBY_SET_TOURN_LIMITS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS::Protocol_MSG_LOBBY_SET_TOURN_LIMITS(Protocol_MSG_LOBBY_SET_TOURN_LIMITS&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, currency(std::move(_o.currency))
	, limit1(std::move(_o.limit1))
	, limitType1(std::move(_o.limitType1))
	, limit2(std::move(_o.limit2))
	, limitType2(std::move(_o.limitType2))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS& Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS::operator=(Protocol_MSG_LOBBY_SET_TOURN_LIMITS&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		currency = std::move(_o.currency);
		limit1 = std::move(_o.limit1);
		limitType1 = std::move(_o.limitType1);
		limit2 = std::move(_o.limit2);
		limitType2 = std::move(_o.limitType2);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS::clear()
{
	notUsedStr.clear();
	currency.clear();
	limit1 = 0;
	limitType1 = 0;
	limit2 = 0;
	limitType2 = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS::equals(const Protocol_MSG_LOBBY_SET_TOURN_LIMITS& _o) const
{
	return notUsedStr.equals(_o.notUsedStr) &&
		currency.equals(_o.currency) &&
		limit1 == _o.limit1 &&
		limitType1 == _o.limitType1 &&
		limit2 == _o.limit2 &&
		limitType2 == _o.limitType2;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SET_TOURN_LIMITS).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("limit1=");
	_buf.appendInt(limit1);
	_buf.append(',');
	_buf.append("limitType1=");
	_buf.appendUint(limitType1);
	_buf.append(',');
	_buf.append("limit2=");
	_buf.appendInt(limit2);
	_buf.append(',');
	_buf.append("limitType2=");
	_buf.appendUint(limitType2);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(notUsedStr);
	_msg.composeString(currency);
	_msg.composeINT32(limit1);
	_msg.composeBYTE(limitType1);
	_msg.composeINT32(limit2);
	_msg.composeBYTE(limitType2);
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseStringP(currency);
	_parser.parseINT32(limit1);
	_parser.parseBYTE(limitType1);
	_parser.parseINT32(limit2);
	_parser.parseBYTE(limitType2);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_TOURN_LIMITS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, 5, _checker, __FILE__, __LINE__);
	INT32 limit1; _parser.parseINT32(limit1);
	AtfValidator::validateIntMin(_descr, "limit1", limit1, -1, _checker, __FILE__, __LINE__);
	BYTE limitType1; _parser.parseBYTE(limitType1);
	AtfValidator::validateIntRange(_descr, "limitType1", limitType1, eTableLimitTypeAny, (numLimitTypes-1), _checker, __FILE__, __LINE__);
	INT32 limit2; _parser.parseINT32(limit2);
	AtfValidator::validateIntMin(_descr, "limit2", limit2, -1, _checker, __FILE__, __LINE__);
	BYTE limitType2; _parser.parseBYTE(limitType2);
	AtfValidator::validateIntRange(_descr, "limitType2", limitType2, eTableLimitTypeAny, (numLimitTypes-1), _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY::Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY::Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY(Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, limitType1(std::move(_o.limitType1))
	, errorCode1(std::move(_o.errorCode1))
	, errDescr1(std::move(_o.errDescr1))
	, effectiveNow1(std::move(_o.effectiveNow1))
	, limitType2(std::move(_o.limitType2))
	, errorCode2(std::move(_o.errorCode2))
	, errDescr2(std::move(_o.errDescr2))
	, effectiveNow2(std::move(_o.effectiveNow2))
	, limit(std::move(_o.limit))
	, waitingIncreaseLimitDays1(std::move(_o.waitingIncreaseLimitDays1))
	, waitingIncreaseLimitDays2(std::move(_o.waitingIncreaseLimitDays2))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY& Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY::operator=(Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		limitType1 = std::move(_o.limitType1);
		errorCode1 = std::move(_o.errorCode1);
		errDescr1 = std::move(_o.errDescr1);
		effectiveNow1 = std::move(_o.effectiveNow1);
		limitType2 = std::move(_o.limitType2);
		errorCode2 = std::move(_o.errorCode2);
		errDescr2 = std::move(_o.errDescr2);
		effectiveNow2 = std::move(_o.effectiveNow2);
		limit = std::move(_o.limit);
		waitingIncreaseLimitDays1 = std::move(_o.waitingIncreaseLimitDays1);
		waitingIncreaseLimitDays2 = std::move(_o.waitingIncreaseLimitDays2);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY::clear()
{
	errCode = 0;
	limitType1 = 0;
	errorCode1 = 0;
	errDescr1.clear();
	effectiveNow1 = false;
	limitType2 = 0;
	errorCode2 = 0;
	errDescr2.clear();
	effectiveNow2 = false;
	limit = 0;
	waitingIncreaseLimitDays1 = 0;
	waitingIncreaseLimitDays2 = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY::equals(const Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		limitType1 == _o.limitType1 &&
		errorCode1 == _o.errorCode1 &&
		errDescr1.equals(_o.errDescr1) &&
		effectiveNow1 == _o.effectiveNow1 &&
		limitType2 == _o.limitType2 &&
		errorCode2 == _o.errorCode2 &&
		errDescr2.equals(_o.errDescr2) &&
		effectiveNow2 == _o.effectiveNow2 &&
		limit == _o.limit &&
		waitingIncreaseLimitDays1 == _o.waitingIncreaseLimitDays1 &&
		waitingIncreaseLimitDays2 == _o.waitingIncreaseLimitDays2;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SET_TOURN_LIMITS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("limitType1=");
	_buf.appendUint(limitType1);
	_buf.append(',');
	_buf.append("errorCode1=");
	_buf.appendInt(errorCode1);
	if(errorCode1)
	{
		_buf.append(',');
		_buf.append("errDescr1=");
		_buf.append(errDescr1);
	}
	else
	{
		_buf.append(',');
		_buf.append("effectiveNow1=");
		_buf.appendUint(effectiveNow1);
	}
	_buf.append(',');
	_buf.append("limitType2=");
	_buf.appendUint(limitType2);
	_buf.append(',');
	_buf.append("errorCode2=");
	_buf.appendInt(errorCode2);
	if(errorCode2)
	{
		_buf.append(',');
		_buf.append("errDescr2=");
		_buf.append(errDescr2);
	}
	else
	{
		_buf.append(',');
		_buf.append("effectiveNow2=");
		_buf.appendUint(effectiveNow2);
	}
	_buf.append(',');
	_buf.append("limit=");
	_buf.appendUint(limit);
	_buf.append(',');
	_buf.append("waitingIncreaseLimitDays1=");
	_buf.appendUint(waitingIncreaseLimitDays1);
	_buf.append(',');
	_buf.append("waitingIncreaseLimitDays2=");
	_buf.appendUint(waitingIncreaseLimitDays2);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	_msg.composeBYTE(limitType1);
	_msg.composeINT16(errorCode1);
	if(errorCode1)
	{
		_msg.composeString(errDescr1);
	}
	else
	{
		_msg.composeBOOL(effectiveNow1);
	}
	_msg.composeBYTE(limitType2);
	_msg.composeINT16(errorCode2);
	if(errorCode2)
	{
		_msg.composeString(errDescr2);
	}
	else
	{
		_msg.composeBOOL(effectiveNow2);
	}
	_msg.composeUINT32(limit);
	_msg.composeUINT32(waitingIncreaseLimitDays1);
	_msg.composeUINT32(waitingIncreaseLimitDays2);
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseBYTE(limitType1);
	_parser.parseINT16(errorCode1);
	if(errorCode1)
	{
		_parser.parseStringP(errDescr1);
	}
	else
	{
		_parser.parseBOOL(effectiveNow1);
	}
	_parser.parseBYTE(limitType2);
	_parser.parseINT16(errorCode2);
	if(errorCode2)
	{
		_parser.parseStringP(errDescr2);
	}
	else
	{
		_parser.parseBOOL(effectiveNow2);
	}
	_parser.parseUINT32(limit);
	_parser.parseUINT32(waitingIncreaseLimitDays1);
	_parser.parseUINT32(waitingIncreaseLimitDays2);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_TOURN_LIMITS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errorCode1 = 0;
	INT16 errorCode2 = 0;
	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	BYTE limitType1; _parser.parseBYTE(limitType1);
	AtfValidator::validateInt(_descr, "limitType1", limitType1, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errorCode1);
	AtfValidator::validateInt(_descr, "errorCode1", errorCode1, _checker, __FILE__, __LINE__);
	if(errorCode1)
	{
		_parser.parseStringN(_dummy, 0, "errDescr1"); size_t szErrDescr1 = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr1", szErrDescr1, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool effectiveNow1; _parser.parseBOOL(effectiveNow1);
		AtfValidator::validateInt(_descr, "effectiveNow1", effectiveNow1, _checker, __FILE__, __LINE__);
	}
	BYTE limitType2; _parser.parseBYTE(limitType2);
	AtfValidator::validateInt(_descr, "limitType2", limitType2, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errorCode2);
	AtfValidator::validateInt(_descr, "errorCode2", errorCode2, _checker, __FILE__, __LINE__);
	if(errorCode2)
	{
		_parser.parseStringN(_dummy, 0, "errDescr2"); size_t szErrDescr2 = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr2", szErrDescr2, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool effectiveNow2; _parser.parseBOOL(effectiveNow2);
		AtfValidator::validateInt(_descr, "effectiveNow2", effectiveNow2, _checker, __FILE__, __LINE__);
	}
	UINT32 limit; _parser.parseUINT32(limit);
	AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
	UINT32 waitingIncreaseLimitDays1; _parser.parseUINT32(waitingIncreaseLimitDays1);
	AtfValidator::validateInt(_descr, "waitingIncreaseLimitDays1", waitingIncreaseLimitDays1, _checker, __FILE__, __LINE__);
	UINT32 waitingIncreaseLimitDays2; _parser.parseUINT32(waitingIncreaseLimitDays2);
	AtfValidator::validateInt(_descr, "waitingIncreaseLimitDays2", waitingIncreaseLimitDays2, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_IT_DOCUMENT
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT::Protocol_MSG_LOBBY_IT_DOCUMENT()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT::clear()
{
}

bool Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT::equals(const Protocol_MSG_LOBBY_IT_DOCUMENT& _o) const
{
	return true;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_IT_DOCUMENT).append(")");
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT::composeMsg(CommMsgBody& _msg) const
{
}

void Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_IT_DOCUMENT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY::Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY::Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY(Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, sqlErr(std::move(_o.sqlErr))
{
}

Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY& Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY::operator=(Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		sqlErr = std::move(_o.sqlErr);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY::clear()
{
	errCode = 0;
	sqlErr.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY::equals(const Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		sqlErr.equals(_o.sqlErr);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_IT_DOCUMENT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("sqlErr=");
	_buf.append(sqlErr);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(sqlErr);
}

void Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(sqlErr);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_IT_DOCUMENT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "sqlErr"); size_t szSqlErr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "sqlErr", szSqlErr, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT::Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT::Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT(Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT&& _o)
	: tournId(std::move(_o.tournId))
	, buyInRM(std::move(_o.buyInRM))
	, buyInPlay(std::move(_o.buyInPlay))
	, buyInFpp(std::move(_o.buyInFpp))
	, buyInT(std::move(_o.buyInT))
	, buyInW(std::move(_o.buyInW))
	, currencyContext(std::move(_o.currencyContext))
	, dummy32(std::move(_o.dummy32))
	, dummy64(std::move(_o.dummy64))
	, useTicket(std::move(_o.useTicket))
{
}

Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT& Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT::operator=(Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT&& _o)
{
	if(this != &_o)
	{
		tournId = std::move(_o.tournId);
		buyInRM = std::move(_o.buyInRM);
		buyInPlay = std::move(_o.buyInPlay);
		buyInFpp = std::move(_o.buyInFpp);
		buyInT = std::move(_o.buyInT);
		buyInW = std::move(_o.buyInW);
		currencyContext = std::move(_o.currencyContext);
		dummy32 = std::move(_o.dummy32);
		dummy64 = std::move(_o.dummy64);
		useTicket = std::move(_o.useTicket);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT::clear()
{
	tournId = 0;
	buyInRM = 0;
	buyInPlay = 0;
	buyInFpp = 0;
	buyInT = 0;
	buyInW = 0;
	currencyContext.clear();
	dummy32 = 0;
	dummy64 = 0;
	useTicket = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT::equals(const Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT& _o) const
{
	return tournId == _o.tournId &&
		buyInRM == _o.buyInRM &&
		buyInPlay == _o.buyInPlay &&
		buyInFpp == _o.buyInFpp &&
		buyInT == _o.buyInT &&
		buyInW == _o.buyInW &&
		currencyContext.equals(_o.currencyContext) &&
		dummy32 == _o.dummy32 &&
		dummy64 == _o.dummy64 &&
		useTicket == _o.useTicket;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CLI_REMATCH_ACCEPT).append(")");
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("buyInRM=");
	_buf.appendUint(buyInRM);
	_buf.append(',');
	_buf.append("buyInPlay=");
	_buf.appendUint(buyInPlay);
	_buf.append(',');
	_buf.append("buyInFpp=");
	_buf.appendUint(buyInFpp);
	_buf.append(',');
	_buf.append("buyInT=");
	_buf.appendUint(buyInT);
	_buf.append(',');
	_buf.append("buyInW=");
	_buf.appendUint(buyInW);
	_buf.append(',');
	_buf.append("currencyContext=");
	currencyContext.toTraceString(_buf);
	_buf.append(',');
	_buf.append("dummy32=");
	_buf.appendUint(dummy32);
	_buf.append(',');
	_buf.append("dummy64=");
	_buf.appendUint64(dummy64);
	_buf.append(',');
	_buf.append("useTicket=");
	_buf.appendUint(useTicket);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(tournId);
	_msg.composeUINT32(buyInRM);
	_msg.composeUINT32(buyInPlay);
	_msg.composeUINT32(buyInFpp);
	_msg.composeUINT32(buyInT);
	_msg.composeUINT32(buyInW);
	_msg.composeMsgBody(currencyContext);
	_msg.composeUINT32(dummy32);
	_msg.composeUINT64(dummy64);
	_msg.composeBYTE(useTicket);
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tournId);
	_parser.parseUINT32(buyInRM);
	_parser.parseUINT32(buyInPlay);
	_parser.parseUINT32(buyInFpp);
	_parser.parseUINT32(buyInT);
	_parser.parseUINT32(buyInW);
	_parser.parseMsgBody(currencyContext);
	_parser.parseUINT32(dummy32);
	_parser.parseUINT64(dummy64);
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(useTicket);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLI_REMATCH_ACCEPT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	UINT32 buyInRM; _parser.parseUINT32(buyInRM);
	AtfValidator::validateIntMax(_descr, "buyInRM", buyInRM, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 buyInPlay; _parser.parseUINT32(buyInPlay);
	AtfValidator::validateInt(_descr, "buyInPlay", buyInPlay, _checker, __FILE__, __LINE__);
	UINT32 buyInFpp; _parser.parseUINT32(buyInFpp);
	AtfValidator::validateIntMax(_descr, "buyInFpp", buyInFpp, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 buyInT; _parser.parseUINT32(buyInT);
	AtfValidator::validateIntMax(_descr, "buyInT", buyInT, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 buyInW; _parser.parseUINT32(buyInW);
	AtfValidator::validateIntMax(_descr, "buyInW", buyInW, 0, _checker, __FILE__, __LINE__);
	size_t szCurrencyContext; _parser.skipMsgBody(szCurrencyContext);  /*currencyContext*/
	AtfValidator::validateIntMax(_descr, "currencyContext", szCurrencyContext, 10000, _checker, __FILE__, __LINE__);
	UINT32 dummy32; _parser.parseUINT32(dummy32);
	AtfValidator::validateInt(_descr, "dummy32", dummy32, _checker, __FILE__, __LINE__);
	UINT64 dummy64; _parser.parseUINT64(dummy64);
	AtfValidator::validateUint(_descr, "dummy64", dummy64, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	BYTE useTicket; _parser.parseBYTE(useTicket);
	AtfValidator::validateIntMax(_descr, "useTicket", useTicket, 1, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CLI_REMATCH_DECLINE
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_DECLINE::Protocol_MSG_LOBBY_CLI_REMATCH_DECLINE()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_DECLINE::clear()
{
	tournId = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_DECLINE::equals(const Protocol_MSG_LOBBY_CLI_REMATCH_DECLINE& _o) const
{
	return tournId == _o.tournId;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_DECLINE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CLI_REMATCH_DECLINE).append(")");
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_DECLINE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(tournId);
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_DECLINE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tournId);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_DECLINE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLI_REMATCH_DECLINE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_MIGRATION_GET_INFO
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO::Protocol_MSG_LOBBY_MIGRATION_GET_INFO()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO::Protocol_MSG_LOBBY_MIGRATION_GET_INFO(Protocol_MSG_LOBBY_MIGRATION_GET_INFO&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, type(std::move(_o.type))
{
}

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO& Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO::operator=(Protocol_MSG_LOBBY_MIGRATION_GET_INFO&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		type = std::move(_o.type);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO::clear()
{
	notUsedStr.clear();
	type = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO::equals(const Protocol_MSG_LOBBY_MIGRATION_GET_INFO& _o) const
{
	return notUsedStr.equals(_o.notUsedStr) &&
		type == _o.type;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_MIGRATION_GET_INFO).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("type=");
	_buf.appendUint(type);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(notUsedStr);
	_msg.composeUINT32(type);
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseUINT32(type);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_MIGRATION_GET_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	UINT32 type; _parser.parseUINT32(type);
	AtfValidator::validateIntRange(_descr, "type", type, eMigrationTypeTransfer, eMigrationTypeLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY::Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY::Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY(Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, linkedUserId(std::move(_o.linkedUserId))
	, linkedUserCity(std::move(_o.linkedUserCity))
	, cashBalance(std::move(_o.cashBalance))
	, tBalance(std::move(_o.tBalance))
	, wBalance(std::move(_o.wBalance))
	, fppBalance(std::move(_o.fppBalance))
	, monthlyVpp(std::move(_o.monthlyVpp))
	, yearlyVpp(std::move(_o.yearlyVpp))
	, tickets(std::move(_o.tickets))
	, bonuses(std::move(_o.bonuses))
	, exchangeRate(std::move(_o.exchangeRate))
	, migrationType(std::move(_o.migrationType))
	, bonusEligible(std::move(_o.bonusEligible))
	, birthDate(std::move(_o.birthDate))
{
}

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY& Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY::operator=(Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		linkedUserId = std::move(_o.linkedUserId);
		linkedUserCity = std::move(_o.linkedUserCity);
		cashBalance = std::move(_o.cashBalance);
		tBalance = std::move(_o.tBalance);
		wBalance = std::move(_o.wBalance);
		fppBalance = std::move(_o.fppBalance);
		monthlyVpp = std::move(_o.monthlyVpp);
		yearlyVpp = std::move(_o.yearlyVpp);
		tickets = std::move(_o.tickets);
		bonuses = std::move(_o.bonuses);
		exchangeRate = std::move(_o.exchangeRate);
		migrationType = std::move(_o.migrationType);
		bonusEligible = std::move(_o.bonusEligible);
		birthDate = std::move(_o.birthDate);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	linkedUserId.clear();
	linkedUserCity.clear();
	cashBalance = 0;
	tBalance = 0;
	wBalance = 0;
	fppBalance = 0;
	monthlyVpp = 0;
	yearlyVpp = 0;
	tickets = 0;
	bonuses = 0;
	exchangeRate = 0;
	migrationType = 0;
	bonusEligible = false;
	birthDate.setNull();
}

bool Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY::equals(const Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		linkedUserId.equals(_o.linkedUserId) &&
		linkedUserCity.equals(_o.linkedUserCity) &&
		cashBalance == _o.cashBalance &&
		tBalance == _o.tBalance &&
		wBalance == _o.wBalance &&
		fppBalance == _o.fppBalance &&
		monthlyVpp == _o.monthlyVpp &&
		yearlyVpp == _o.yearlyVpp &&
		tickets == _o.tickets &&
		bonuses == _o.bonuses &&
		exchangeRate == _o.exchangeRate &&
		migrationType == _o.migrationType &&
		bonusEligible == _o.bonusEligible &&
		birthDate.equals(_o.birthDate);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_MIGRATION_GET_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("linkedUserId=");
		_buf.append(linkedUserId);
		_buf.append(',');
		_buf.append("linkedUserCity=");
		_buf.append(linkedUserCity);
		_buf.append(',');
		_buf.append("cashBalance=");
		_buf.appendInt(cashBalance);
		_buf.append(',');
		_buf.append("tBalance=");
		_buf.appendInt(tBalance);
		_buf.append(',');
		_buf.append("wBalance=");
		_buf.appendInt(wBalance);
		_buf.append(',');
		_buf.append("fppBalance=");
		_buf.appendInt(fppBalance);
		_buf.append(',');
		_buf.append("monthlyVpp=");
		_buf.appendInt(monthlyVpp);
		_buf.append(',');
		_buf.append("yearlyVpp=");
		_buf.appendInt(yearlyVpp);
		_buf.append(',');
		_buf.append("tickets=");
		_buf.appendInt(tickets);
		_buf.append(',');
		_buf.append("bonuses=");
		_buf.appendInt(bonuses);
		_buf.append(',');
		_buf.append("exchangeRate=");
		_buf.appendInt(exchangeRate);
		_buf.append(',');
		_buf.append("migrationType=");
		_buf.appendInt(migrationType);
		_buf.append(',');
		_buf.append("bonusEligible=");
		_buf.appendUint(bonusEligible);
		_buf.append(',');
		_buf.append("birthDate=");
		ThinAtf::AtfTempl<SrvDate>::ToTraceString(_buf, birthDate);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(linkedUserId);
		_msg.composeString(linkedUserCity);
		_msg.composeINT32(cashBalance);
		_msg.composeINT32(tBalance);
		_msg.composeINT32(wBalance);
		_msg.composeINT32(fppBalance);
		_msg.composeINT32(monthlyVpp);
		_msg.composeINT32(yearlyVpp);
		_msg.composeINT32(tickets);
		_msg.composeINT32(bonuses);
		_msg.composeINT32(exchangeRate);
		_msg.composeINT32(migrationType);
		_msg.composeBOOL(bonusEligible);
		_msg.composeSrvDate(birthDate);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(linkedUserId);
		_parser.parseStringP(linkedUserCity);
		_parser.parseINT32(cashBalance);
		_parser.parseINT32(tBalance);
		_parser.parseINT32(wBalance);
		_parser.parseINT32(fppBalance);
		_parser.parseINT32(monthlyVpp);
		_parser.parseINT32(yearlyVpp);
		_parser.parseINT32(tickets);
		_parser.parseINT32(bonuses);
		_parser.parseINT32(exchangeRate);
		_parser.parseINT32(migrationType);
		_parser.parseBOOL(bonusEligible);
		_parser.parseSrvDate(birthDate);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_MIGRATION_GET_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "linkedUserId"); size_t szLinkedUserId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "linkedUserId", szLinkedUserId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "linkedUserCity"); size_t szLinkedUserCity = strlen(_dummy);
		AtfValidator::validateInt(_descr, "linkedUserCity", szLinkedUserCity, _checker, __FILE__, __LINE__);
		INT32 cashBalance; _parser.parseINT32(cashBalance);
		AtfValidator::validateInt(_descr, "cashBalance", cashBalance, _checker, __FILE__, __LINE__);
		INT32 tBalance; _parser.parseINT32(tBalance);
		AtfValidator::validateInt(_descr, "tBalance", tBalance, _checker, __FILE__, __LINE__);
		INT32 wBalance; _parser.parseINT32(wBalance);
		AtfValidator::validateInt(_descr, "wBalance", wBalance, _checker, __FILE__, __LINE__);
		INT32 fppBalance; _parser.parseINT32(fppBalance);
		AtfValidator::validateInt(_descr, "fppBalance", fppBalance, _checker, __FILE__, __LINE__);
		INT32 monthlyVpp; _parser.parseINT32(monthlyVpp);
		AtfValidator::validateInt(_descr, "monthlyVpp", monthlyVpp, _checker, __FILE__, __LINE__);
		INT32 yearlyVpp; _parser.parseINT32(yearlyVpp);
		AtfValidator::validateInt(_descr, "yearlyVpp", yearlyVpp, _checker, __FILE__, __LINE__);
		INT32 tickets; _parser.parseINT32(tickets);
		AtfValidator::validateInt(_descr, "tickets", tickets, _checker, __FILE__, __LINE__);
		INT32 bonuses; _parser.parseINT32(bonuses);
		AtfValidator::validateInt(_descr, "bonuses", bonuses, _checker, __FILE__, __LINE__);
		INT32 exchangeRate; _parser.parseINT32(exchangeRate);
		AtfValidator::validateInt(_descr, "exchangeRate", exchangeRate, _checker, __FILE__, __LINE__);
		INT32 migrationType; _parser.parseINT32(migrationType);
		AtfValidator::validateInt(_descr, "migrationType", migrationType, _checker, __FILE__, __LINE__);
		bool bonusEligible; _parser.parseBOOL(bonusEligible);
		AtfValidator::validateInt(_descr, "bonusEligible", bonusEligible, _checker, __FILE__, __LINE__);
		SrvDate birthDate; _parser.parseSrvDate(birthDate);
		AtfValidator::validateSrvDateTime(_descr, "birthDate", birthDate, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_MIGRATION_LINK
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK::Protocol_MSG_LOBBY_MIGRATION_LINK()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK::Protocol_MSG_LOBBY_MIGRATION_LINK(Protocol_MSG_LOBBY_MIGRATION_LINK&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, type(std::move(_o.type))
	, linkedUser(std::move(_o.linkedUser))
	, dob(std::move(_o.dob))
{
}

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK& Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK::operator=(Protocol_MSG_LOBBY_MIGRATION_LINK&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		type = std::move(_o.type);
		linkedUser = std::move(_o.linkedUser);
		dob = std::move(_o.dob);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK::clear()
{
	notUsedStr.clear();
	type = 0;
	linkedUser.clear();
	dob.setNull();
}

bool Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK::equals(const Protocol_MSG_LOBBY_MIGRATION_LINK& _o) const
{
	return notUsedStr.equals(_o.notUsedStr) &&
		type == _o.type &&
		linkedUser.equals(_o.linkedUser) &&
		dob.equals(_o.dob);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_MIGRATION_LINK).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("type=");
	_buf.appendUint(type);
	_buf.append(',');
	_buf.append("linkedUser=");
	_buf.append(linkedUser);
	_buf.append(',');
	_buf.append("dob=");
	ThinAtf::AtfTempl<SrvDate>::ToTraceString(_buf, dob);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(notUsedStr);
	_msg.composeUINT32(type);
	_msg.composeString(linkedUser);
	_msg.composeSrvDate(dob);
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseUINT32(type);
	_parser.parseStringP(linkedUser);
	_parser.parseSrvDate(dob);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_MIGRATION_LINK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	UINT32 type; _parser.parseUINT32(type);
	AtfValidator::validateIntRange(_descr, "type", type, eMigrationTypeTransfer, eMigrationTypeLast, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "linkedUser"); size_t szLinkedUser = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "linkedUser", szLinkedUser, 20, _checker, __FILE__, __LINE__);
	SrvDate dob; _parser.parseSrvDate(dob);
	AtfValidator::validateSrvDateTime(_descr, "dob", dob, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY::Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY::Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY(Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, linkedUserId(std::move(_o.linkedUserId))
	, linkedUserCity(std::move(_o.linkedUserCity))
	, cashBalance(std::move(_o.cashBalance))
	, tBalance(std::move(_o.tBalance))
	, wBalance(std::move(_o.wBalance))
	, fppBalance(std::move(_o.fppBalance))
	, monthlyVpp(std::move(_o.monthlyVpp))
	, yearlyVpp(std::move(_o.yearlyVpp))
	, tickets(std::move(_o.tickets))
	, bonuses(std::move(_o.bonuses))
	, exchangeRate(std::move(_o.exchangeRate))
	, migrationType(std::move(_o.migrationType))
	, bonusEligible(std::move(_o.bonusEligible))
	, birthDate(std::move(_o.birthDate))
{
}

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY& Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY::operator=(Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		linkedUserId = std::move(_o.linkedUserId);
		linkedUserCity = std::move(_o.linkedUserCity);
		cashBalance = std::move(_o.cashBalance);
		tBalance = std::move(_o.tBalance);
		wBalance = std::move(_o.wBalance);
		fppBalance = std::move(_o.fppBalance);
		monthlyVpp = std::move(_o.monthlyVpp);
		yearlyVpp = std::move(_o.yearlyVpp);
		tickets = std::move(_o.tickets);
		bonuses = std::move(_o.bonuses);
		exchangeRate = std::move(_o.exchangeRate);
		migrationType = std::move(_o.migrationType);
		bonusEligible = std::move(_o.bonusEligible);
		birthDate = std::move(_o.birthDate);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	linkedUserId.clear();
	linkedUserCity.clear();
	cashBalance = 0;
	tBalance = 0;
	wBalance = 0;
	fppBalance = 0;
	monthlyVpp = 0;
	yearlyVpp = 0;
	tickets = 0;
	bonuses = 0;
	exchangeRate = 0;
	migrationType = 0;
	bonusEligible = false;
	birthDate.setNull();
}

bool Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY::equals(const Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		linkedUserId.equals(_o.linkedUserId) &&
		linkedUserCity.equals(_o.linkedUserCity) &&
		cashBalance == _o.cashBalance &&
		tBalance == _o.tBalance &&
		wBalance == _o.wBalance &&
		fppBalance == _o.fppBalance &&
		monthlyVpp == _o.monthlyVpp &&
		yearlyVpp == _o.yearlyVpp &&
		tickets == _o.tickets &&
		bonuses == _o.bonuses &&
		exchangeRate == _o.exchangeRate &&
		migrationType == _o.migrationType &&
		bonusEligible == _o.bonusEligible &&
		birthDate.equals(_o.birthDate);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_MIGRATION_LINK_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("linkedUserId=");
		_buf.append(linkedUserId);
		_buf.append(',');
		_buf.append("linkedUserCity=");
		_buf.append(linkedUserCity);
		_buf.append(',');
		_buf.append("cashBalance=");
		_buf.appendInt(cashBalance);
		_buf.append(',');
		_buf.append("tBalance=");
		_buf.appendInt(tBalance);
		_buf.append(',');
		_buf.append("wBalance=");
		_buf.appendInt(wBalance);
		_buf.append(',');
		_buf.append("fppBalance=");
		_buf.appendInt(fppBalance);
		_buf.append(',');
		_buf.append("monthlyVpp=");
		_buf.appendInt(monthlyVpp);
		_buf.append(',');
		_buf.append("yearlyVpp=");
		_buf.appendInt(yearlyVpp);
		_buf.append(',');
		_buf.append("tickets=");
		_buf.appendInt(tickets);
		_buf.append(',');
		_buf.append("bonuses=");
		_buf.appendInt(bonuses);
		_buf.append(',');
		_buf.append("exchangeRate=");
		_buf.appendInt(exchangeRate);
		_buf.append(',');
		_buf.append("migrationType=");
		_buf.appendInt(migrationType);
		_buf.append(',');
		_buf.append("bonusEligible=");
		_buf.appendUint(bonusEligible);
		_buf.append(',');
		_buf.append("birthDate=");
		ThinAtf::AtfTempl<SrvDate>::ToTraceString(_buf, birthDate);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(linkedUserId);
		_msg.composeString(linkedUserCity);
		_msg.composeINT32(cashBalance);
		_msg.composeINT32(tBalance);
		_msg.composeINT32(wBalance);
		_msg.composeINT32(fppBalance);
		_msg.composeINT32(monthlyVpp);
		_msg.composeINT32(yearlyVpp);
		_msg.composeINT32(tickets);
		_msg.composeINT32(bonuses);
		_msg.composeINT32(exchangeRate);
		_msg.composeINT32(migrationType);
		_msg.composeBOOL(bonusEligible);
		_msg.composeSrvDate(birthDate);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(linkedUserId);
		_parser.parseStringP(linkedUserCity);
		_parser.parseINT32(cashBalance);
		_parser.parseINT32(tBalance);
		_parser.parseINT32(wBalance);
		_parser.parseINT32(fppBalance);
		_parser.parseINT32(monthlyVpp);
		_parser.parseINT32(yearlyVpp);
		_parser.parseINT32(tickets);
		_parser.parseINT32(bonuses);
		_parser.parseINT32(exchangeRate);
		_parser.parseINT32(migrationType);
		_parser.parseBOOL(bonusEligible);
		_parser.parseSrvDate(birthDate);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_MIGRATION_LINK_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "linkedUserId"); size_t szLinkedUserId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "linkedUserId", szLinkedUserId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "linkedUserCity"); size_t szLinkedUserCity = strlen(_dummy);
		AtfValidator::validateInt(_descr, "linkedUserCity", szLinkedUserCity, _checker, __FILE__, __LINE__);
		INT32 cashBalance; _parser.parseINT32(cashBalance);
		AtfValidator::validateInt(_descr, "cashBalance", cashBalance, _checker, __FILE__, __LINE__);
		INT32 tBalance; _parser.parseINT32(tBalance);
		AtfValidator::validateInt(_descr, "tBalance", tBalance, _checker, __FILE__, __LINE__);
		INT32 wBalance; _parser.parseINT32(wBalance);
		AtfValidator::validateInt(_descr, "wBalance", wBalance, _checker, __FILE__, __LINE__);
		INT32 fppBalance; _parser.parseINT32(fppBalance);
		AtfValidator::validateInt(_descr, "fppBalance", fppBalance, _checker, __FILE__, __LINE__);
		INT32 monthlyVpp; _parser.parseINT32(monthlyVpp);
		AtfValidator::validateInt(_descr, "monthlyVpp", monthlyVpp, _checker, __FILE__, __LINE__);
		INT32 yearlyVpp; _parser.parseINT32(yearlyVpp);
		AtfValidator::validateInt(_descr, "yearlyVpp", yearlyVpp, _checker, __FILE__, __LINE__);
		INT32 tickets; _parser.parseINT32(tickets);
		AtfValidator::validateInt(_descr, "tickets", tickets, _checker, __FILE__, __LINE__);
		INT32 bonuses; _parser.parseINT32(bonuses);
		AtfValidator::validateInt(_descr, "bonuses", bonuses, _checker, __FILE__, __LINE__);
		INT32 exchangeRate; _parser.parseINT32(exchangeRate);
		AtfValidator::validateInt(_descr, "exchangeRate", exchangeRate, _checker, __FILE__, __LINE__);
		INT32 migrationType; _parser.parseINT32(migrationType);
		AtfValidator::validateInt(_descr, "migrationType", migrationType, _checker, __FILE__, __LINE__);
		bool bonusEligible; _parser.parseBOOL(bonusEligible);
		AtfValidator::validateInt(_descr, "bonusEligible", bonusEligible, _checker, __FILE__, __LINE__);
		SrvDate birthDate; _parser.parseSrvDate(birthDate);
		AtfValidator::validateSrvDateTime(_descr, "birthDate", birthDate, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_MIGRATION_TRANSFER
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER::Protocol_MSG_LOBBY_MIGRATION_TRANSFER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER::Protocol_MSG_LOBBY_MIGRATION_TRANSFER(Protocol_MSG_LOBBY_MIGRATION_TRANSFER&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, cashBalance(std::move(_o.cashBalance))
	, tBalance(std::move(_o.tBalance))
	, wBalance(std::move(_o.wBalance))
	, fppBalance(std::move(_o.fppBalance))
	, exchangeRate(std::move(_o.exchangeRate))
{
}

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER& Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER::operator=(Protocol_MSG_LOBBY_MIGRATION_TRANSFER&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		cashBalance = std::move(_o.cashBalance);
		tBalance = std::move(_o.tBalance);
		wBalance = std::move(_o.wBalance);
		fppBalance = std::move(_o.fppBalance);
		exchangeRate = std::move(_o.exchangeRate);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER::clear()
{
	notUsedStr.clear();
	cashBalance = 0;
	tBalance = 0;
	wBalance = 0;
	fppBalance = 0;
	exchangeRate = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER::equals(const Protocol_MSG_LOBBY_MIGRATION_TRANSFER& _o) const
{
	return notUsedStr.equals(_o.notUsedStr) &&
		cashBalance == _o.cashBalance &&
		tBalance == _o.tBalance &&
		wBalance == _o.wBalance &&
		fppBalance == _o.fppBalance &&
		exchangeRate == _o.exchangeRate;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_MIGRATION_TRANSFER).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("cashBalance=");
	_buf.appendUint(cashBalance);
	_buf.append(',');
	_buf.append("tBalance=");
	_buf.appendUint(tBalance);
	_buf.append(',');
	_buf.append("wBalance=");
	_buf.appendUint(wBalance);
	_buf.append(',');
	_buf.append("fppBalance=");
	_buf.appendUint(fppBalance);
	_buf.append(',');
	_buf.append("exchangeRate=");
	_buf.appendUint(exchangeRate);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(notUsedStr);
	_msg.composeUINT32(cashBalance);
	_msg.composeUINT32(tBalance);
	_msg.composeUINT32(wBalance);
	_msg.composeUINT32(fppBalance);
	_msg.composeUINT32(exchangeRate);
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseUINT32(cashBalance);
	_parser.parseUINT32(tBalance);
	_parser.parseUINT32(wBalance);
	_parser.parseUINT32(fppBalance);
	_parser.parseUINT32(exchangeRate);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_MIGRATION_TRANSFER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	UINT32 cashBalance; _parser.parseUINT32(cashBalance);
	AtfValidator::validateIntMax(_descr, "cashBalance", cashBalance, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	UINT32 tBalance; _parser.parseUINT32(tBalance);
	AtfValidator::validateIntMax(_descr, "tBalance", tBalance, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	UINT32 wBalance; _parser.parseUINT32(wBalance);
	AtfValidator::validateIntMax(_descr, "wBalance", wBalance, 0, _checker, __FILE__, __LINE__);
	UINT32 fppBalance; _parser.parseUINT32(fppBalance);
	AtfValidator::validateIntMax(_descr, "fppBalance", fppBalance, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	UINT32 exchangeRate; _parser.parseUINT32(exchangeRate);
	AtfValidator::validateInt(_descr, "exchangeRate", exchangeRate, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY::Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY::Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY(Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, cashAmtEuro(std::move(_o.cashAmtEuro))
	, fppAmt(std::move(_o.fppAmt))
	, linkedUserId(std::move(_o.linkedUserId))
	, city(std::move(_o.city))
{
}

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY& Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY::operator=(Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		cashAmtEuro = std::move(_o.cashAmtEuro);
		fppAmt = std::move(_o.fppAmt);
		linkedUserId = std::move(_o.linkedUserId);
		city = std::move(_o.city);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	cashAmtEuro = 0;
	fppAmt = 0;
	linkedUserId.clear();
	city.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY::equals(const Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		cashAmtEuro == _o.cashAmtEuro &&
		fppAmt == _o.fppAmt &&
		linkedUserId.equals(_o.linkedUserId) &&
		city.equals(_o.city);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_MIGRATION_TRANSFER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("cashAmtEuro=");
		_buf.appendInt(cashAmtEuro);
		_buf.append(',');
		_buf.append("fppAmt=");
		_buf.appendUint(fppAmt);
		_buf.append(',');
		_buf.append("linkedUserId=");
		_buf.append(linkedUserId);
		_buf.append(',');
		_buf.append("city=");
		_buf.append(city);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(cashAmtEuro);
		_msg.composeUINT32(fppAmt);
		_msg.composeString(linkedUserId);
		_msg.composeString(city);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(cashAmtEuro);
		_parser.parseUINT32(fppAmt);
		_parser.parseStringP(linkedUserId);
		_parser.parseStringP(city);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_MIGRATION_TRANSFER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 cashAmtEuro; _parser.parseINT32(cashAmtEuro);
		AtfValidator::validateInt(_descr, "cashAmtEuro", cashAmtEuro, _checker, __FILE__, __LINE__);
		UINT32 fppAmt; _parser.parseUINT32(fppAmt);
		AtfValidator::validateInt(_descr, "fppAmt", fppAmt, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "linkedUserId"); size_t szLinkedUserId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "linkedUserId", szLinkedUserId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
		AtfValidator::validateInt(_descr, "city", szCity, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_MIGRATION_CONVERT
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT::Protocol_MSG_LOBBY_MIGRATION_CONVERT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT::Protocol_MSG_LOBBY_MIGRATION_CONVERT(Protocol_MSG_LOBBY_MIGRATION_CONVERT&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, exchangeRate(std::move(_o.exchangeRate))
{
}

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT& Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT::operator=(Protocol_MSG_LOBBY_MIGRATION_CONVERT&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		exchangeRate = std::move(_o.exchangeRate);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT::clear()
{
	notUsedStr.clear();
	exchangeRate = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT::equals(const Protocol_MSG_LOBBY_MIGRATION_CONVERT& _o) const
{
	return notUsedStr.equals(_o.notUsedStr) &&
		exchangeRate == _o.exchangeRate;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_MIGRATION_CONVERT).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("exchangeRate=");
	_buf.appendUint(exchangeRate);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(notUsedStr);
	_msg.composeUINT32(exchangeRate);
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseUINT32(exchangeRate);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_MIGRATION_CONVERT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	UINT32 exchangeRate; _parser.parseUINT32(exchangeRate);
	AtfValidator::validateInt(_descr, "exchangeRate", exchangeRate, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY::Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY::Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY(Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY& Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY::operator=(Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY::equals(const Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_MIGRATION_CONVERT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_MIGRATION_CONVERT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SET_PROMO_IMAGE
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE::Protocol_MSG_LOBBY_SET_PROMO_IMAGE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE::Protocol_MSG_LOBBY_SET_PROMO_IMAGE(Protocol_MSG_LOBBY_SET_PROMO_IMAGE&& _o)
	: doSet(std::move(_o.doSet))
	, promoImageCode(std::move(_o.promoImageCode))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE& Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE::operator=(Protocol_MSG_LOBBY_SET_PROMO_IMAGE&& _o)
{
	if(this != &_o)
	{
		doSet = std::move(_o.doSet);
		promoImageCode = std::move(_o.promoImageCode);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE::clear()
{
	doSet = false;
	promoImageCode.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE::equals(const Protocol_MSG_LOBBY_SET_PROMO_IMAGE& _o) const
{
	return doSet == _o.doSet &&
		promoImageCode.equals(_o.promoImageCode);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SET_PROMO_IMAGE).append(")");
	_buf.append(',');
	_buf.append("doSet=");
	_buf.appendUint(doSet);
	_buf.append(',');
	_buf.append("promoImageCode=");
	_buf.append(promoImageCode);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBOOL(doSet);
	_msg.composeString(promoImageCode);
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(doSet);
	_parser.parseStringP(promoImageCode);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_PROMO_IMAGE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	bool doSet; _parser.parseBOOL(doSet);
	AtfValidator::validateInt(_descr, "doSet", doSet, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "promoImageCode"); size_t szPromoImageCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "promoImageCode", szPromoImageCode, 10000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY::Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY::Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY(Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY& Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY::operator=(Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY::equals(const Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SET_PROMO_IMAGE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_PROMO_IMAGE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_PROMO_IMAGE
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE::Protocol_MSG_LOBBY_GET_PROMO_IMAGE()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE::clear()
{
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE::equals(const Protocol_MSG_LOBBY_GET_PROMO_IMAGE& _o) const
{
	return true;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_PROMO_IMAGE).append(")");
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE::composeMsg(CommMsgBody& _msg) const
{
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_PROMO_IMAGE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY::Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY::Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY(Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, promoImageCode(std::move(_o.promoImageCode))
{
}

Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY& Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY::operator=(Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		promoImageCode = std::move(_o.promoImageCode);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	promoImageCode.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY::equals(const Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		promoImageCode.equals(_o.promoImageCode);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_PROMO_IMAGE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("promoImageCode=");
		_buf.append(promoImageCode);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(promoImageCode);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(promoImageCode);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_PROMO_IMAGE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "promoImageCode"); size_t szPromoImageCode = strlen(_dummy);
		AtfValidator::validateInt(_descr, "promoImageCode", szPromoImageCode, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FR_AVC_VALIDATE
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE::Protocol_MSG_LOBBY_FR_AVC_VALIDATE()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE::clear()
{
	avc = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE::equals(const Protocol_MSG_LOBBY_FR_AVC_VALIDATE& _o) const
{
	return avc == _o.avc;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FR_AVC_VALIDATE).append(")");
	_buf.append(',');
	_buf.append("avc=");
	_buf.appendUint(avc);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(avc);
}

void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(avc);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FR_AVC_VALIDATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 avc; _parser.parseUINT32(avc);
	AtfValidator::validateInt(_descr, "avc", avc, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY::Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY::Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY(Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, fullyValidated(std::move(_o.fullyValidated))
	, is1stTime(std::move(_o.is1stTime))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY& Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY::operator=(Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		fullyValidated = std::move(_o.fullyValidated);
		is1stTime = std::move(_o.is1stTime);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	fullyValidated = false;
	is1stTime = false;
}

bool Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY::equals(const Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		fullyValidated == _o.fullyValidated &&
		is1stTime == _o.is1stTime;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FR_AVC_VALIDATE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("fullyValidated=");
		_buf.appendUint(fullyValidated);
		_buf.append(',');
		_buf.append("is1stTime=");
		_buf.appendUint(is1stTime);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeBOOL(fullyValidated);
		_msg.composeBOOL(is1stTime);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseBOOL(fullyValidated);
		_parser.parseBOOL(is1stTime);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FR_AVC_VALIDATE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool fullyValidated; _parser.parseBOOL(fullyValidated);
		AtfValidator::validateInt(_descr, "fullyValidated", fullyValidated, _checker, __FILE__, __LINE__);
		bool is1stTime; _parser.parseBOOL(is1stTime);
		AtfValidator::validateInt(_descr, "is1stTime", is1stTime, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FR_AVC_RESEND
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND::Protocol_MSG_LOBBY_FR_AVC_RESEND()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND::clear()
{
}

bool Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND::equals(const Protocol_MSG_LOBBY_FR_AVC_RESEND& _o) const
{
	return true;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FR_AVC_RESEND).append(")");
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND::composeMsg(CommMsgBody& _msg) const
{
}

void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FR_AVC_RESEND";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY::Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY::Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY(Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY& Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY::operator=(Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY::equals(const Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FR_AVC_RESEND_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FR_AVC_RESEND_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP::Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP::Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP(Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, setPriv(std::move(_o.setPriv))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP& Lobby::cli::Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP::operator=(Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		setPriv = std::move(_o.setPriv);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP::clear()
{
	notUsedStr.clear();
	setPriv = false;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP::equals(const Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP& _o) const
{
	return notUsedStr.equals(_o.notUsedStr) &&
		setPriv == _o.setPriv;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("setPriv=");
	_buf.appendUint(setPriv);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(notUsedStr);
	_msg.composeBOOL(setPriv);
}

void Lobby::cli::Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseBOOL(setPriv);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	bool setPriv; _parser.parseBOOL(setPriv);
	AtfValidator::validateInt(_descr, "setPriv", setPriv, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CANCEL_RESERVED_SEAT
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_CANCEL_RESERVED_SEAT::Protocol_MSG_LOBBY_CANCEL_RESERVED_SEAT()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_CANCEL_RESERVED_SEAT::clear()
{
	tableId32 = 0;
	seat = 0;
	tableId = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_CANCEL_RESERVED_SEAT::equals(const Protocol_MSG_LOBBY_CANCEL_RESERVED_SEAT& _o) const
{
	return tableId32 == _o.tableId32 &&
		seat == _o.seat &&
		tableId == _o.tableId;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CANCEL_RESERVED_SEAT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CANCEL_RESERVED_SEAT).append(")");
	_buf.append(',');
	_buf.append("tableId32=");
	_buf.appendUint(tableId32);
	_buf.append(',');
	_buf.append("seat=");
	_buf.appendUint(seat);
	_buf.append(',');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_CANCEL_RESERVED_SEAT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(tableId32);
	_msg.composeBYTE(seat);
	_msg.composeUINT64(tableId);
}

void Lobby::cli::Protocol_MSG_LOBBY_CANCEL_RESERVED_SEAT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tableId32);
	_parser.parseBYTE(seat);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(tableId);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CANCEL_RESERVED_SEAT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CANCEL_RESERVED_SEAT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 tableId32; _parser.parseUINT32(tableId32);
	AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
	BYTE seat; _parser.parseBYTE(seat);
	AtfValidator::validateIntMax(_descr, "seat", seat, 10, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 tableId; _parser.parseUINT64(tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE::clear()
{
	tableId32 = 0;
	minPlayers = 0;
	clientReqId = 0;
	searchFlags = 0;
	currTableId = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE::equals(const Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE& _o) const
{
	return tableId32 == _o.tableId32 &&
		minPlayers == _o.minPlayers &&
		clientReqId == _o.clientReqId &&
		searchFlags == _o.searchFlags &&
		currTableId == _o.currTableId;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_SIMILAR_TABLE).append(")");
	_buf.append(',');
	_buf.append("tableId32=");
	_buf.appendUint(tableId32);
	_buf.append(',');
	_buf.append("minPlayers=");
	_buf.appendUint(minPlayers);
	_buf.append(',');
	_buf.append("clientReqId=");
	_buf.appendUint(clientReqId);
	_buf.append(',');
	_buf.append("searchFlags=");
	_buf.appendUint(searchFlags);
	_buf.append(',');
	_buf.append("currTableId=");
	_buf.appendUint64(currTableId);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(tableId32);
	_msg.composeBYTE(minPlayers);
	_msg.composeUINT32(clientReqId);
	_msg.composeUINT32(searchFlags);
	_msg.composeUINT64(currTableId);
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tableId32);
	_parser.parseBYTE(minPlayers);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(clientReqId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(searchFlags);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(currTableId);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_SIMILAR_TABLE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 tableId32; _parser.parseUINT32(tableId32);
	AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
	BYTE minPlayers; _parser.parseBYTE(minPlayers);
	AtfValidator::validateIntMax(_descr, "minPlayers", minPlayers, 10, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 clientReqId; _parser.parseUINT32(clientReqId);
	AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 searchFlags; _parser.parseUINT32(searchFlags);
	AtfValidator::validateIntRange(_descr, "searchFlags", searchFlags, eSeatManFlags_None, eSeatManFlags_Last, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 currTableId; _parser.parseUINT64(currTableId);
	AtfValidator::validateUint(_descr, "currTableId", currTableId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY(Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, clientReqId(std::move(_o.clientReqId))
	, searchFlags(std::move(_o.searchFlags))
	, server(std::move(_o.server))
	, tableId(std::move(_o.tableId))
	, seat(std::move(_o.seat))
	, useDecrSearch(std::move(_o.useDecrSearch))
	, numOfPlayersInDecrSearchTable(std::move(_o.numOfPlayersInDecrSearchTable))
	, waitingForSeatReservationTimeout(std::move(_o.waitingForSeatReservationTimeout))
	, isThereDealing(std::move(_o.isThereDealing))
	, tableId64(std::move(_o.tableId64))
	, serverObject(std::move(_o.serverObject))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY& Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY::operator=(Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		clientReqId = std::move(_o.clientReqId);
		searchFlags = std::move(_o.searchFlags);
		server = std::move(_o.server);
		tableId = std::move(_o.tableId);
		seat = std::move(_o.seat);
		useDecrSearch = std::move(_o.useDecrSearch);
		numOfPlayersInDecrSearchTable = std::move(_o.numOfPlayersInDecrSearchTable);
		waitingForSeatReservationTimeout = std::move(_o.waitingForSeatReservationTimeout);
		isThereDealing = std::move(_o.isThereDealing);
		tableId64 = std::move(_o.tableId64);
		serverObject = std::move(_o.serverObject);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	clientReqId = 0;
	searchFlags = 0;
	server.clear();
	tableId = 0;
	seat = 0;
	useDecrSearch = 0;
	numOfPlayersInDecrSearchTable = 0;
	waitingForSeatReservationTimeout = 0;
	isThereDealing = false;
	tableId64 = 0;
	serverObject.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY::equals(const Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		clientReqId == _o.clientReqId &&
		searchFlags == _o.searchFlags &&
		server.equals(_o.server) &&
		tableId == _o.tableId &&
		seat == _o.seat &&
		useDecrSearch == _o.useDecrSearch &&
		numOfPlayersInDecrSearchTable == _o.numOfPlayersInDecrSearchTable &&
		waitingForSeatReservationTimeout == _o.waitingForSeatReservationTimeout &&
		isThereDealing == _o.isThereDealing &&
		tableId64 == _o.tableId64 &&
		serverObject.equals(_o.serverObject);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
		_buf.append(',');
		_buf.append("clientReqId=");
		_buf.appendUint(clientReqId);
		_buf.append(',');
		_buf.append("searchFlags=");
		_buf.appendUint(searchFlags);
	}
	else
	{
		_buf.append(',');
		_buf.append("server=");
		_buf.append(server);
		_buf.append(',');
		_buf.append("tableId=");
		_buf.appendUint(tableId);
		_buf.append(',');
		_buf.append("seat=");
		_buf.appendUint(seat);
		_buf.append(',');
		_buf.append("clientReqId=");
		_buf.appendUint(clientReqId);
		_buf.append(',');
		_buf.append("useDecrSearch=");
		_buf.appendUint(useDecrSearch);
		_buf.append(',');
		_buf.append("numOfPlayersInDecrSearchTable=");
		_buf.appendUint(numOfPlayersInDecrSearchTable);
		_buf.append(',');
		_buf.append("waitingForSeatReservationTimeout=");
		_buf.appendUint(waitingForSeatReservationTimeout);
		_buf.append(',');
		_buf.append("isThereDealing=");
		_buf.appendUint(isThereDealing);
		_buf.append(',');
		_buf.append("tableId64=");
		_buf.appendUint64(tableId64);
		_buf.append(',');
		_buf.append("serverObject=");
		_buf.append(serverObject);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
		_msg.composeUINT32(clientReqId);
		_msg.composeUINT32(searchFlags);
	}
	else
	{
		_msg.composeString(server);
		_msg.composeUINT32(tableId);
		_msg.composeBYTE(seat);
		_msg.composeUINT32(clientReqId);
		_msg.composeUINT32(useDecrSearch);
		_msg.composeBYTE(numOfPlayersInDecrSearchTable);
		_msg.composeUINT16(waitingForSeatReservationTimeout);
		_msg.composeBOOL(isThereDealing);
		_msg.composeUINT64(tableId64);
		_msg.composeString(serverObject);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
		_parser.parseUINT32(clientReqId);
		_parser.parseUINT32(searchFlags);
	}
	else
	{
		_parser.parseStringP(server);
		_parser.parseUINT32(tableId);
		_parser.parseBYTE(seat);
		_parser.parseUINT32(clientReqId);
		_parser.parseUINT32(useDecrSearch);
		_parser.parseBYTE(numOfPlayersInDecrSearchTable);
		_parser.parseUINT16(waitingForSeatReservationTimeout);
		_parser.parseBOOL(isThereDealing);
		_parser.parseUINT64(tableId64);
		_parser.parseStringP(serverObject);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
		UINT32 clientReqId; _parser.parseUINT32(clientReqId);
		AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
		UINT32 searchFlags; _parser.parseUINT32(searchFlags);
		AtfValidator::validateInt(_descr, "searchFlags", searchFlags, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
		UINT32 tableId; _parser.parseUINT32(tableId);
		AtfValidator::validateInt(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
		BYTE seat; _parser.parseBYTE(seat);
		AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
		UINT32 clientReqId; _parser.parseUINT32(clientReqId);
		AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
		UINT32 useDecrSearch; _parser.parseUINT32(useDecrSearch);
		AtfValidator::validateInt(_descr, "useDecrSearch", useDecrSearch, _checker, __FILE__, __LINE__);
		BYTE numOfPlayersInDecrSearchTable; _parser.parseBYTE(numOfPlayersInDecrSearchTable);
		AtfValidator::validateInt(_descr, "numOfPlayersInDecrSearchTable", numOfPlayersInDecrSearchTable, _checker, __FILE__, __LINE__);
		UINT16 waitingForSeatReservationTimeout; _parser.parseUINT16(waitingForSeatReservationTimeout);
		AtfValidator::validateInt(_descr, "waitingForSeatReservationTimeout", waitingForSeatReservationTimeout, _checker, __FILE__, __LINE__);
		bool isThereDealing; _parser.parseBOOL(isThereDealing);
		AtfValidator::validateInt(_descr, "isThereDealing", isThereDealing, _checker, __FILE__, __LINE__);
		UINT64 tableId64; _parser.parseUINT64(tableId64);
		AtfValidator::validateUint(_descr, "tableId64", tableId64, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "serverObject"); size_t szServerObject = strlen(_dummy);
		AtfValidator::validateInt(_descr, "serverObject", szServerObject, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_STOP
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_STOP::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_STOP()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_STOP::clear()
{
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_STOP::equals(const Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_STOP& _o) const
{
	return true;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_STOP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_SIMILAR_TABLE_STOP).append(")");
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_STOP::composeMsg(CommMsgBody& _msg) const
{
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_STOP::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_STOP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_SIMILAR_TABLE_STOP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE::clear()
{
	typeId = 0;
	minPlayers = 0;
	clientReqId = 0;
	searchFlags = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE::equals(const Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE& _o) const
{
	return typeId == _o.typeId &&
		minPlayers == _o.minPlayers &&
		clientReqId == _o.clientReqId &&
		searchFlags == _o.searchFlags;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE).append(")");
	_buf.append(',');
	_buf.append("typeId=");
	_buf.appendUint(typeId);
	_buf.append(',');
	_buf.append("minPlayers=");
	_buf.appendUint(minPlayers);
	_buf.append(',');
	_buf.append("clientReqId=");
	_buf.appendUint(clientReqId);
	_buf.append(',');
	_buf.append("searchFlags=");
	_buf.appendUint(searchFlags);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(typeId);
	_msg.composeBYTE(minPlayers);
	_msg.composeUINT32(clientReqId);
	_msg.composeUINT32(searchFlags);
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(typeId);
	_parser.parseBYTE(minPlayers);
	_parser.parseUINT32(clientReqId);
	_parser.parseUINT32(searchFlags);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 typeId; _parser.parseUINT32(typeId);
	AtfValidator::validateInt(_descr, "typeId", typeId, _checker, __FILE__, __LINE__);
	BYTE minPlayers; _parser.parseBYTE(minPlayers);
	AtfValidator::validateIntMax(_descr, "minPlayers", minPlayers, 10, _checker, __FILE__, __LINE__);
	UINT32 clientReqId; _parser.parseUINT32(clientReqId);
	AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
	UINT32 searchFlags; _parser.parseUINT32(searchFlags);
	AtfValidator::validateIntRange(_descr, "searchFlags", searchFlags, eSeatManFlags_None, eSeatManFlags_Last, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::clear()
{
	typeId = 0;
	clientReqId = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::equals(const Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE& _o) const
{
	return typeId == _o.typeId &&
		clientReqId == _o.clientReqId;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_TABLE_TO_OBSERVE).append(")");
	_buf.append(',');
	_buf.append("typeId=");
	_buf.appendUint(typeId);
	_buf.append(',');
	_buf.append("clientReqId=");
	_buf.appendUint(clientReqId);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(typeId);
	_msg.composeUINT32(clientReqId);
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(typeId);
	_parser.parseUINT32(clientReqId);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TABLE_TO_OBSERVE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 typeId; _parser.parseUINT32(typeId);
	AtfValidator::validateInt(_descr, "typeId", typeId, _checker, __FILE__, __LINE__);
	UINT32 clientReqId; _parser.parseUINT32(clientReqId);
	AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY(Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, clientReqId(std::move(_o.clientReqId))
	, server(std::move(_o.server))
	, tableId(std::move(_o.tableId))
	, tableId64(std::move(_o.tableId64))
	, serverObject(std::move(_o.serverObject))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY& Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::operator=(Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		clientReqId = std::move(_o.clientReqId);
		server = std::move(_o.server);
		tableId = std::move(_o.tableId);
		tableId64 = std::move(_o.tableId64);
		serverObject = std::move(_o.serverObject);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	clientReqId = 0;
	server.clear();
	tableId = 0;
	tableId64 = 0;
	serverObject.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::equals(const Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		clientReqId == _o.clientReqId &&
		server.equals(_o.server) &&
		tableId == _o.tableId &&
		tableId64 == _o.tableId64 &&
		serverObject.equals(_o.serverObject);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
		_buf.append(',');
		_buf.append("clientReqId=");
		_buf.appendUint(clientReqId);
	}
	else
	{
		_buf.append(',');
		_buf.append("server=");
		_buf.append(server);
		_buf.append(',');
		_buf.append("tableId=");
		_buf.appendUint(tableId);
		_buf.append(',');
		_buf.append("clientReqId=");
		_buf.appendUint(clientReqId);
		_buf.append(',');
		_buf.append("tableId64=");
		_buf.appendUint64(tableId64);
		_buf.append(',');
		_buf.append("serverObject=");
		_buf.append(serverObject);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
		_msg.composeUINT32(clientReqId);
	}
	else
	{
		_msg.composeString(server);
		_msg.composeUINT32(tableId);
		_msg.composeUINT32(clientReqId);
		_msg.composeUINT64(tableId64);
		_msg.composeString(serverObject);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
		_parser.parseUINT32(clientReqId);
	}
	else
	{
		_parser.parseStringP(server);
		_parser.parseUINT32(tableId);
		_parser.parseUINT32(clientReqId);
		_parser.parseUINT64(tableId64);
		_parser.parseStringP(serverObject);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
		UINT32 clientReqId; _parser.parseUINT32(clientReqId);
		AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
		UINT32 tableId; _parser.parseUINT32(tableId);
		AtfValidator::validateInt(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
		UINT32 clientReqId; _parser.parseUINT32(clientReqId);
		AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
		UINT64 tableId64; _parser.parseUINT64(tableId64);
		AtfValidator::validateUint(_descr, "tableId64", tableId64, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "serverObject"); size_t szServerObject = strlen(_dummy);
		AtfValidator::validateInt(_descr, "serverObject", szServerObject, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    BuyInRange
//=================================================================

Lobby::cli::BuyInRange::BuyInRange()
{
	clear();
}

void Lobby::cli::BuyInRange::clear()
{
	bottomMin = 0;
	topMin = 0;
	bottomMax = 0;
	topMax = 0;
}

bool Lobby::cli::BuyInRange::equals(const BuyInRange& _o) const
{
	return bottomMin == _o.bottomMin &&
		topMin == _o.topMin &&
		bottomMax == _o.bottomMax &&
		topMax == _o.topMax;
}

const char *Lobby::cli::BuyInRange::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("bottomMin=");
	_buf.appendUint(bottomMin);
	_buf.append(',');
	_buf.append("topMin=");
	_buf.appendUint(topMin);
	_buf.append(',');
	_buf.append("bottomMax=");
	_buf.appendUint(bottomMax);
	_buf.append(',');
	_buf.append("topMax=");
	_buf.appendUint(topMax);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::BuyInRange::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT16(bottomMin);
	_msg.composeUINT16(topMin);
	_msg.composeUINT16(bottomMax);
	_msg.composeUINT16(topMax);
}

void Lobby::cli::BuyInRange::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT16(bottomMin);
	_parser.parseUINT16(topMin);
	_parser.parseUINT16(bottomMax);
	_parser.parseUINT16(topMax);
}

/*static*/ void Lobby::cli::BuyInRange::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT16 bottomMin; _parser.parseUINT16(bottomMin);
	AtfValidator::validateInt(_descr, "bottomMin", bottomMin, _checker, __FILE__, __LINE__);
	UINT16 topMin; _parser.parseUINT16(topMin);
	AtfValidator::validateInt(_descr, "topMin", topMin, _checker, __FILE__, __LINE__);
	UINT16 bottomMax; _parser.parseUINT16(bottomMax);
	AtfValidator::validateInt(_descr, "bottomMax", bottomMax, _checker, __FILE__, __LINE__);
	UINT16 topMax; _parser.parseUINT16(topMax);
	AtfValidator::validateInt(_descr, "topMax", topMax, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    BuyInRanges
//=================================================================

Lobby::cli::BuyInRanges::BuyInRanges()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::BuyInRanges::BuyInRanges(BuyInRanges&& _o)
	: isRevert(std::move(_o.isRevert))
	, buyInRanges(std::move(_o.buyInRanges))
{
}

Lobby::cli::BuyInRanges& Lobby::cli::BuyInRanges::operator=(BuyInRanges&& _o)
{
	if(this != &_o)
	{
		isRevert = std::move(_o.isRevert);
		buyInRanges = std::move(_o.buyInRanges);
	}
	return *this;
}

#endif

void Lobby::cli::BuyInRanges::clear()
{
	isRevert = false;
	buyInRanges.clear();
}

bool Lobby::cli::BuyInRanges::equals(const BuyInRanges& _o) const
{
	return isRevert == _o.isRevert &&
		buyInRanges.equals(_o.buyInRanges);
}

const char *Lobby::cli::BuyInRanges::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("isRevert=");
	_buf.appendUint(isRevert);
	_buf.append(',');
	_buf.append("buyInRanges=");
	buyInRanges.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::BuyInRanges::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBOOL(isRevert);
	buyInRanges.composeMsg(_msg);
}

void Lobby::cli::BuyInRanges::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(isRevert);
	buyInRanges.parseMsg(_parser);
}

/*static*/ void Lobby::cli::BuyInRanges::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	bool isRevert; _parser.parseBOOL(isRevert);
	AtfValidator::validateInt(_descr, "isRevert", isRevert, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szBuyInRanges = ThinAtf::LAtfVector< BuyInRange, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("buyInRanges"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "buyInRanges", szBuyInRanges, 10240, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    SeatManAdvSearchCriteria
//=================================================================

Lobby::cli::SeatManAdvSearchCriteria::SeatManAdvSearchCriteria()
{
	clear();
}

void Lobby::cli::SeatManAdvSearchCriteria::clear()
{
	minAvgPot = 0;
	minAvgStack = 0;
	minPlayersFlop = 0;
	minVpip = 0;
	minHandsHour = 0;
}

bool Lobby::cli::SeatManAdvSearchCriteria::equals(const SeatManAdvSearchCriteria& _o) const
{
	return minAvgPot == _o.minAvgPot &&
		minAvgStack == _o.minAvgStack &&
		minPlayersFlop == _o.minPlayersFlop &&
		minVpip == _o.minVpip &&
		minHandsHour == _o.minHandsHour;
}

const char *Lobby::cli::SeatManAdvSearchCriteria::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("minAvgPot=");
	_buf.appendUint(minAvgPot);
	_buf.append(',');
	_buf.append("minAvgStack=");
	_buf.appendUint(minAvgStack);
	_buf.append(',');
	_buf.append("minPlayersFlop=");
	_buf.appendUint(minPlayersFlop);
	_buf.append(',');
	_buf.append("minVpip=");
	_buf.appendUint(minVpip);
	_buf.append(',');
	_buf.append("minHandsHour=");
	_buf.appendUint(minHandsHour);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::SeatManAdvSearchCriteria::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(minAvgPot);
	_msg.composeUINT32(minAvgStack);
	_msg.composeBYTE(minPlayersFlop);
	_msg.composeBYTE(minVpip);
	_msg.composeUINT16(minHandsHour);
}

void Lobby::cli::SeatManAdvSearchCriteria::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(minAvgPot);
	_parser.parseUINT32(minAvgStack);
	_parser.parseBYTE(minPlayersFlop);
	_parser.parseBYTE(minVpip);
	_parser.parseUINT16(minHandsHour);
}

/*static*/ void Lobby::cli::SeatManAdvSearchCriteria::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 minAvgPot; _parser.parseUINT32(minAvgPot);
	AtfValidator::validateInt(_descr, "minAvgPot", minAvgPot, _checker, __FILE__, __LINE__);
	UINT32 minAvgStack; _parser.parseUINT32(minAvgStack);
	AtfValidator::validateInt(_descr, "minAvgStack", minAvgStack, _checker, __FILE__, __LINE__);
	BYTE minPlayersFlop; _parser.parseBYTE(minPlayersFlop);
	AtfValidator::validateInt(_descr, "minPlayersFlop", minPlayersFlop, _checker, __FILE__, __LINE__);
	BYTE minVpip; _parser.parseBYTE(minVpip);
	AtfValidator::validateInt(_descr, "minVpip", minVpip, _checker, __FILE__, __LINE__);
	UINT16 minHandsHour; _parser.parseUINT16(minHandsHour);
	AtfValidator::validateInt(_descr, "minHandsHour", minHandsHour, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE(Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE&& _o)
	: minPlayers(std::move(_o.minPlayers))
	, game(std::move(_o.game))
	, hiLo(std::move(_o.hiLo))
	, structure(std::move(_o.structure))
	, maxPlayersMin(std::move(_o.maxPlayersMin))
	, maxPlayersMax(std::move(_o.maxPlayersMax))
	, minLoBet32(std::move(_o.minLoBet32))
	, minHiBet32(std::move(_o.minHiBet32))
	, maxLoBet32(std::move(_o.maxLoBet32))
	, maxHiBet32(std::move(_o.maxHiBet32))
	, capOn(std::move(_o.capOn))
	, speedBM(std::move(_o.speedBM))
	, currencyBM(std::move(_o.currencyBM))
	, buyInRanges(std::move(_o.buyInRanges))
	, seatManAdvSearchCriteria(std::move(_o.seatManAdvSearchCriteria))
	, clientReqId(std::move(_o.clientReqId))
	, searchFlags(std::move(_o.searchFlags))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE& Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE::operator=(Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE&& _o)
{
	if(this != &_o)
	{
		minPlayers = std::move(_o.minPlayers);
		game = std::move(_o.game);
		hiLo = std::move(_o.hiLo);
		structure = std::move(_o.structure);
		maxPlayersMin = std::move(_o.maxPlayersMin);
		maxPlayersMax = std::move(_o.maxPlayersMax);
		minLoBet32 = std::move(_o.minLoBet32);
		minHiBet32 = std::move(_o.minHiBet32);
		maxLoBet32 = std::move(_o.maxLoBet32);
		maxHiBet32 = std::move(_o.maxHiBet32);
		capOn = std::move(_o.capOn);
		speedBM = std::move(_o.speedBM);
		currencyBM = std::move(_o.currencyBM);
		buyInRanges = std::move(_o.buyInRanges);
		seatManAdvSearchCriteria = std::move(_o.seatManAdvSearchCriteria);
		clientReqId = std::move(_o.clientReqId);
		searchFlags = std::move(_o.searchFlags);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE::clear()
{
	minPlayers = 0;
	game = 0;
	hiLo = 0;
	structure = 0;
	maxPlayersMin = 0;
	maxPlayersMax = 0;
	minLoBet32 = 0;
	minHiBet32 = 0;
	maxLoBet32 = 0;
	maxHiBet32 = 0;
	capOn = false;
	speedBM = 0;
	currencyBM = 0;
	buyInRanges.clear();
	seatManAdvSearchCriteria.clear();
	clientReqId = 0;
	searchFlags = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE::equals(const Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE& _o) const
{
	return minPlayers == _o.minPlayers &&
		game == _o.game &&
		hiLo == _o.hiLo &&
		structure == _o.structure &&
		maxPlayersMin == _o.maxPlayersMin &&
		maxPlayersMax == _o.maxPlayersMax &&
		minLoBet32 == _o.minLoBet32 &&
		minHiBet32 == _o.minHiBet32 &&
		maxLoBet32 == _o.maxLoBet32 &&
		maxHiBet32 == _o.maxHiBet32 &&
		capOn == _o.capOn &&
		speedBM == _o.speedBM &&
		currencyBM == _o.currencyBM &&
		buyInRanges.equals(_o.buyInRanges) &&
		seatManAdvSearchCriteria.equals(_o.seatManAdvSearchCriteria) &&
		clientReqId == _o.clientReqId &&
		searchFlags == _o.searchFlags;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_SEAT_MANAGER_TABLE).append(")");
	_buf.append(',');
	_buf.append("minPlayers=");
	_buf.appendUint(minPlayers);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("hiLo=");
	_buf.appendUint(hiLo);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("maxPlayersMin=");
	_buf.appendUint(maxPlayersMin);
	_buf.append(',');
	_buf.append("maxPlayersMax=");
	_buf.appendUint(maxPlayersMax);
	_buf.append(',');
	_buf.append("minLoBet32=");
	_buf.appendUint(minLoBet32);
	_buf.append(',');
	_buf.append("minHiBet32=");
	_buf.appendUint(minHiBet32);
	_buf.append(',');
	_buf.append("maxLoBet32=");
	_buf.appendUint(maxLoBet32);
	_buf.append(',');
	_buf.append("maxHiBet32=");
	_buf.appendUint(maxHiBet32);
	_buf.append(',');
	_buf.append("capOn=");
	_buf.appendUint(capOn);
	_buf.append(',');
	_buf.append("speedBM=");
	_buf.appendUint(speedBM);
	_buf.append(',');
	_buf.append("currencyBM=");
	_buf.appendUint(currencyBM);
	_buf.append(',');
	_buf.append("buyInRanges=");
	buyInRanges.toTraceString(_buf);
	_buf.append(',');
	_buf.append("seatManAdvSearchCriteria=");
	seatManAdvSearchCriteria.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clientReqId=");
	_buf.appendUint(clientReqId);
	_buf.append(',');
	_buf.append("searchFlags=");
	_buf.appendUint(searchFlags);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(minPlayers);
	_msg.composeBYTE(game);
	_msg.composeBYTE(hiLo);
	_msg.composeBYTE(structure);
	_msg.composeBYTE(maxPlayersMin);
	_msg.composeBYTE(maxPlayersMax);
	_msg.composeUINT32(minLoBet32);
	_msg.composeUINT32(minHiBet32);
	_msg.composeUINT32(maxLoBet32);
	_msg.composeUINT32(maxHiBet32);
	_msg.composeBOOL(capOn);
	_msg.composeBYTE(speedBM);
	_msg.composeUINT32(currencyBM);
	buyInRanges.composeMsg(_msg);
	seatManAdvSearchCriteria.composeMsg(_msg);
	_msg.composeUINT32(clientReqId);
	_msg.composeUINT32(searchFlags);
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(minPlayers);
	_parser.parseBYTE(game);
	_parser.parseBYTE(hiLo);
	_parser.parseBYTE(structure);
	_parser.parseBYTE(maxPlayersMin);
	_parser.parseBYTE(maxPlayersMax);
	_parser.parseUINT32(minLoBet32);
	_parser.parseUINT32(minHiBet32);
	_parser.parseUINT32(maxLoBet32);
	_parser.parseUINT32(maxHiBet32);
	_parser.parseBOOL(capOn);
	_parser.parseBYTE(speedBM);
	_parser.parseUINT32(currencyBM);
	buyInRanges.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	seatManAdvSearchCriteria.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(clientReqId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(searchFlags);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_SEAT_MANAGER_TABLE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE minPlayers; _parser.parseBYTE(minPlayers);
	AtfValidator::validateIntMax(_descr, "minPlayers", minPlayers, 10, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateIntRange(_descr, "game", game, 1, HandType_Last, _checker, __FILE__, __LINE__);
	BYTE hiLo; _parser.parseBYTE(hiLo);
	AtfValidator::validateIntMax(_descr, "hiLo", hiLo, 1, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateIntRange(_descr, "structure", structure, StructLimit, PotStruct_Last, _checker, __FILE__, __LINE__);
	BYTE maxPlayersMin; _parser.parseBYTE(maxPlayersMin);
	AtfValidator::validateIntRange(_descr, "maxPlayersMin", maxPlayersMin, 2, 1000000, _checker, __FILE__, __LINE__);
	BYTE maxPlayersMax; _parser.parseBYTE(maxPlayersMax);
	AtfValidator::validateIntRange(_descr, "maxPlayersMax", maxPlayersMax, 2, 1000000, _checker, __FILE__, __LINE__);
	UINT32 minLoBet32; _parser.parseUINT32(minLoBet32);
	AtfValidator::validateIntMax(_descr, "minLoBet32", minLoBet32, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 minHiBet32; _parser.parseUINT32(minHiBet32);
	AtfValidator::validateIntMax(_descr, "minHiBet32", minHiBet32, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 maxLoBet32; _parser.parseUINT32(maxLoBet32);
	AtfValidator::validateIntMax(_descr, "maxLoBet32", maxLoBet32, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 maxHiBet32; _parser.parseUINT32(maxHiBet32);
	AtfValidator::validateIntMax(_descr, "maxHiBet32", maxHiBet32, 2000000000, _checker, __FILE__, __LINE__);
	bool capOn; _parser.parseBOOL(capOn);
	AtfValidator::validateInt(_descr, "capOn", capOn, _checker, __FILE__, __LINE__);
	BYTE speedBM; _parser.parseBYTE(speedBM);
	AtfValidator::validateIntMax(_descr, "speedBM", speedBM, eSeatManSpeed_Last, _checker, __FILE__, __LINE__);
	UINT32 currencyBM; _parser.parseUINT32(currencyBM);
	AtfValidator::validateIntMax(_descr, "currencyBM", currencyBM, eSeatManCurrency_Last, _checker, __FILE__, __LINE__);
	PString _descbuf;
	BuyInRanges::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("buyInRanges"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	SeatManAdvSearchCriteria::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("seatManAdvSearchCriteria"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	UINT32 clientReqId; _parser.parseUINT32(clientReqId);
	AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 searchFlags; _parser.parseUINT32(searchFlags);
	AtfValidator::validateIntRange(_descr, "searchFlags", searchFlags, eSeatManFlags_None, eSeatManFlags_Last, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY(Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, clientReqId(std::move(_o.clientReqId))
	, searchFlags(std::move(_o.searchFlags))
	, server(std::move(_o.server))
	, tableId(std::move(_o.tableId))
	, seat(std::move(_o.seat))
	, useDecrSearch(std::move(_o.useDecrSearch))
	, numOfPlayersInDecrSearchTable(std::move(_o.numOfPlayersInDecrSearchTable))
	, waitingForSeatReservationTimeout(std::move(_o.waitingForSeatReservationTimeout))
	, isThereDealing(std::move(_o.isThereDealing))
	, tableId64(std::move(_o.tableId64))
	, serverObject(std::move(_o.serverObject))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY& Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY::operator=(Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		clientReqId = std::move(_o.clientReqId);
		searchFlags = std::move(_o.searchFlags);
		server = std::move(_o.server);
		tableId = std::move(_o.tableId);
		seat = std::move(_o.seat);
		useDecrSearch = std::move(_o.useDecrSearch);
		numOfPlayersInDecrSearchTable = std::move(_o.numOfPlayersInDecrSearchTable);
		waitingForSeatReservationTimeout = std::move(_o.waitingForSeatReservationTimeout);
		isThereDealing = std::move(_o.isThereDealing);
		tableId64 = std::move(_o.tableId64);
		serverObject = std::move(_o.serverObject);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	clientReqId = 0;
	searchFlags = 0;
	server.clear();
	tableId = 0;
	seat = 0;
	useDecrSearch = 0;
	numOfPlayersInDecrSearchTable = 0;
	waitingForSeatReservationTimeout = 0;
	isThereDealing = false;
	tableId64 = 0;
	serverObject.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY::equals(const Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		clientReqId == _o.clientReqId &&
		searchFlags == _o.searchFlags &&
		server.equals(_o.server) &&
		tableId == _o.tableId &&
		seat == _o.seat &&
		useDecrSearch == _o.useDecrSearch &&
		numOfPlayersInDecrSearchTable == _o.numOfPlayersInDecrSearchTable &&
		waitingForSeatReservationTimeout == _o.waitingForSeatReservationTimeout &&
		isThereDealing == _o.isThereDealing &&
		tableId64 == _o.tableId64 &&
		serverObject.equals(_o.serverObject);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
		_buf.append(',');
		_buf.append("clientReqId=");
		_buf.appendUint(clientReqId);
		_buf.append(',');
		_buf.append("searchFlags=");
		_buf.appendUint(searchFlags);
	}
	else
	{
		_buf.append(',');
		_buf.append("server=");
		_buf.append(server);
		_buf.append(',');
		_buf.append("tableId=");
		_buf.appendUint(tableId);
		_buf.append(',');
		_buf.append("seat=");
		_buf.appendUint(seat);
		_buf.append(',');
		_buf.append("clientReqId=");
		_buf.appendUint(clientReqId);
		_buf.append(',');
		_buf.append("useDecrSearch=");
		_buf.appendUint(useDecrSearch);
		_buf.append(',');
		_buf.append("numOfPlayersInDecrSearchTable=");
		_buf.appendUint(numOfPlayersInDecrSearchTable);
		_buf.append(',');
		_buf.append("waitingForSeatReservationTimeout=");
		_buf.appendUint(waitingForSeatReservationTimeout);
		_buf.append(',');
		_buf.append("isThereDealing=");
		_buf.appendUint(isThereDealing);
		_buf.append(',');
		_buf.append("tableId64=");
		_buf.appendUint64(tableId64);
		_buf.append(',');
		_buf.append("serverObject=");
		_buf.append(serverObject);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
		_msg.composeUINT32(clientReqId);
		_msg.composeUINT32(searchFlags);
	}
	else
	{
		_msg.composeString(server);
		_msg.composeUINT32(tableId);
		_msg.composeBYTE(seat);
		_msg.composeUINT32(clientReqId);
		_msg.composeUINT32(useDecrSearch);
		_msg.composeBYTE(numOfPlayersInDecrSearchTable);
		_msg.composeUINT16(waitingForSeatReservationTimeout);
		_msg.composeBOOL(isThereDealing);
		_msg.composeUINT64(tableId64);
		_msg.composeString(serverObject);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
		_parser.parseUINT32(clientReqId);
		_parser.parseUINT32(searchFlags);
	}
	else
	{
		_parser.parseStringP(server);
		_parser.parseUINT32(tableId);
		_parser.parseBYTE(seat);
		_parser.parseUINT32(clientReqId);
		_parser.parseUINT32(useDecrSearch);
		_parser.parseBYTE(numOfPlayersInDecrSearchTable);
		_parser.parseUINT16(waitingForSeatReservationTimeout);
		_parser.parseBOOL(isThereDealing);
		_parser.parseUINT64(tableId64);
		_parser.parseStringP(serverObject);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
		UINT32 clientReqId; _parser.parseUINT32(clientReqId);
		AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
		UINT32 searchFlags; _parser.parseUINT32(searchFlags);
		AtfValidator::validateInt(_descr, "searchFlags", searchFlags, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
		UINT32 tableId; _parser.parseUINT32(tableId);
		AtfValidator::validateInt(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
		BYTE seat; _parser.parseBYTE(seat);
		AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
		UINT32 clientReqId; _parser.parseUINT32(clientReqId);
		AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
		UINT32 useDecrSearch; _parser.parseUINT32(useDecrSearch);
		AtfValidator::validateInt(_descr, "useDecrSearch", useDecrSearch, _checker, __FILE__, __LINE__);
		BYTE numOfPlayersInDecrSearchTable; _parser.parseBYTE(numOfPlayersInDecrSearchTable);
		AtfValidator::validateInt(_descr, "numOfPlayersInDecrSearchTable", numOfPlayersInDecrSearchTable, _checker, __FILE__, __LINE__);
		UINT16 waitingForSeatReservationTimeout; _parser.parseUINT16(waitingForSeatReservationTimeout);
		AtfValidator::validateInt(_descr, "waitingForSeatReservationTimeout", waitingForSeatReservationTimeout, _checker, __FILE__, __LINE__);
		bool isThereDealing; _parser.parseBOOL(isThereDealing);
		AtfValidator::validateInt(_descr, "isThereDealing", isThereDealing, _checker, __FILE__, __LINE__);
		UINT64 tableId64; _parser.parseUINT64(tableId64);
		AtfValidator::validateUint(_descr, "tableId64", tableId64, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "serverObject"); size_t szServerObject = strlen(_dummy);
		AtfValidator::validateInt(_descr, "serverObject", szServerObject, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2(Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2&& _o)
	: minPlayers(std::move(_o.minPlayers))
	, game(std::move(_o.game))
	, hiLo(std::move(_o.hiLo))
	, structure(std::move(_o.structure))
	, maxPlayersMin(std::move(_o.maxPlayersMin))
	, maxPlayersMax(std::move(_o.maxPlayersMax))
	, minLoBet(std::move(_o.minLoBet))
	, minHiBet(std::move(_o.minHiBet))
	, maxLoBet(std::move(_o.maxLoBet))
	, maxHiBet(std::move(_o.maxHiBet))
	, capOn(std::move(_o.capOn))
	, speedBM(std::move(_o.speedBM))
	, currencyBM(std::move(_o.currencyBM))
	, buyInRanges(std::move(_o.buyInRanges))
	, seatManAdvSearchCriteria(std::move(_o.seatManAdvSearchCriteria))
	, clientReqId(std::move(_o.clientReqId))
	, searchFlags(std::move(_o.searchFlags))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2& Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2::operator=(Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2&& _o)
{
	if(this != &_o)
	{
		minPlayers = std::move(_o.minPlayers);
		game = std::move(_o.game);
		hiLo = std::move(_o.hiLo);
		structure = std::move(_o.structure);
		maxPlayersMin = std::move(_o.maxPlayersMin);
		maxPlayersMax = std::move(_o.maxPlayersMax);
		minLoBet = std::move(_o.minLoBet);
		minHiBet = std::move(_o.minHiBet);
		maxLoBet = std::move(_o.maxLoBet);
		maxHiBet = std::move(_o.maxHiBet);
		capOn = std::move(_o.capOn);
		speedBM = std::move(_o.speedBM);
		currencyBM = std::move(_o.currencyBM);
		buyInRanges = std::move(_o.buyInRanges);
		seatManAdvSearchCriteria = std::move(_o.seatManAdvSearchCriteria);
		clientReqId = std::move(_o.clientReqId);
		searchFlags = std::move(_o.searchFlags);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2::clear()
{
	minPlayers = 0;
	game = 0;
	hiLo = 0;
	structure = 0;
	maxPlayersMin = 0;
	maxPlayersMax = 0;
	minLoBet = 0;
	minHiBet = 0;
	maxLoBet = 0;
	maxHiBet = 0;
	capOn = false;
	speedBM = 0;
	currencyBM = 0;
	buyInRanges.clear();
	seatManAdvSearchCriteria.clear();
	clientReqId = 0;
	searchFlags = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2::equals(const Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2& _o) const
{
	return minPlayers == _o.minPlayers &&
		game == _o.game &&
		hiLo == _o.hiLo &&
		structure == _o.structure &&
		maxPlayersMin == _o.maxPlayersMin &&
		maxPlayersMax == _o.maxPlayersMax &&
		minLoBet == _o.minLoBet &&
		minHiBet == _o.minHiBet &&
		maxLoBet == _o.maxLoBet &&
		maxHiBet == _o.maxHiBet &&
		capOn == _o.capOn &&
		speedBM == _o.speedBM &&
		currencyBM == _o.currencyBM &&
		buyInRanges.equals(_o.buyInRanges) &&
		seatManAdvSearchCriteria.equals(_o.seatManAdvSearchCriteria) &&
		clientReqId == _o.clientReqId &&
		searchFlags == _o.searchFlags;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2).append(")");
	_buf.append(',');
	_buf.append("minPlayers=");
	_buf.appendUint(minPlayers);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("hiLo=");
	_buf.appendUint(hiLo);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("maxPlayersMin=");
	_buf.appendUint(maxPlayersMin);
	_buf.append(',');
	_buf.append("maxPlayersMax=");
	_buf.appendUint(maxPlayersMax);
	_buf.append(',');
	_buf.append("minLoBet=");
	_buf.appendInt64(minLoBet);
	_buf.append(',');
	_buf.append("minHiBet=");
	_buf.appendInt64(minHiBet);
	_buf.append(',');
	_buf.append("maxLoBet=");
	_buf.appendInt64(maxLoBet);
	_buf.append(',');
	_buf.append("maxHiBet=");
	_buf.appendInt64(maxHiBet);
	_buf.append(',');
	_buf.append("capOn=");
	_buf.appendUint(capOn);
	_buf.append(',');
	_buf.append("speedBM=");
	_buf.appendUint(speedBM);
	_buf.append(',');
	_buf.append("currencyBM=");
	_buf.appendUint(currencyBM);
	_buf.append(',');
	_buf.append("buyInRanges=");
	buyInRanges.toTraceString(_buf);
	_buf.append(',');
	_buf.append("seatManAdvSearchCriteria=");
	seatManAdvSearchCriteria.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clientReqId=");
	_buf.appendUint(clientReqId);
	_buf.append(',');
	_buf.append("searchFlags=");
	_buf.appendUint(searchFlags);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(minPlayers);
	_msg.composeBYTE(game);
	_msg.composeBYTE(hiLo);
	_msg.composeBYTE(structure);
	_msg.composeBYTE(maxPlayersMin);
	_msg.composeBYTE(maxPlayersMax);
	_msg.composeINT64(minLoBet);
	_msg.composeINT64(minHiBet);
	_msg.composeINT64(maxLoBet);
	_msg.composeINT64(maxHiBet);
	_msg.composeBOOL(capOn);
	_msg.composeBYTE(speedBM);
	_msg.composeUINT32(currencyBM);
	buyInRanges.composeMsg(_msg);
	seatManAdvSearchCriteria.composeMsg(_msg);
	_msg.composeUINT32(clientReqId);
	_msg.composeUINT32(searchFlags);
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(minPlayers);
	_parser.parseBYTE(game);
	_parser.parseBYTE(hiLo);
	_parser.parseBYTE(structure);
	_parser.parseBYTE(maxPlayersMin);
	_parser.parseBYTE(maxPlayersMax);
	_parser.parseINT64(minLoBet);
	_parser.parseINT64(minHiBet);
	_parser.parseINT64(maxLoBet);
	_parser.parseINT64(maxHiBet);
	_parser.parseBOOL(capOn);
	_parser.parseBYTE(speedBM);
	_parser.parseUINT32(currencyBM);
	buyInRanges.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	seatManAdvSearchCriteria.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(clientReqId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(searchFlags);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE minPlayers; _parser.parseBYTE(minPlayers);
	AtfValidator::validateIntMax(_descr, "minPlayers", minPlayers, 10, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateIntRange(_descr, "game", game, 1, HandType_Last, _checker, __FILE__, __LINE__);
	BYTE hiLo; _parser.parseBYTE(hiLo);
	AtfValidator::validateIntMax(_descr, "hiLo", hiLo, 1, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateIntRange(_descr, "structure", structure, 0, PotStruct_Last, _checker, __FILE__, __LINE__);
	BYTE maxPlayersMin; _parser.parseBYTE(maxPlayersMin);
	AtfValidator::validateIntRange(_descr, "maxPlayersMin", maxPlayersMin, 2, 1000000, _checker, __FILE__, __LINE__);
	BYTE maxPlayersMax; _parser.parseBYTE(maxPlayersMax);
	AtfValidator::validateIntRange(_descr, "maxPlayersMax", maxPlayersMax, 2, 1000000, _checker, __FILE__, __LINE__);
	INT64 minLoBet; _parser.parseINT64(minLoBet);
	AtfValidator::validateIntMax(_descr, "minLoBet", minLoBet, 2000000000, _checker, __FILE__, __LINE__);
	INT64 minHiBet; _parser.parseINT64(minHiBet);
	AtfValidator::validateIntMax(_descr, "minHiBet", minHiBet, 2000000000, _checker, __FILE__, __LINE__);
	INT64 maxLoBet; _parser.parseINT64(maxLoBet);
	AtfValidator::validateIntMax(_descr, "maxLoBet", maxLoBet, 2000000000, _checker, __FILE__, __LINE__);
	INT64 maxHiBet; _parser.parseINT64(maxHiBet);
	AtfValidator::validateIntMax(_descr, "maxHiBet", maxHiBet, 2000000000, _checker, __FILE__, __LINE__);
	bool capOn; _parser.parseBOOL(capOn);
	AtfValidator::validateInt(_descr, "capOn", capOn, _checker, __FILE__, __LINE__);
	BYTE speedBM; _parser.parseBYTE(speedBM);
	AtfValidator::validateIntMax(_descr, "speedBM", speedBM, (eSeatManSpeed_Last*2-1), _checker, __FILE__, __LINE__);
	UINT32 currencyBM; _parser.parseUINT32(currencyBM);
	AtfValidator::validateIntMax(_descr, "currencyBM", currencyBM, eSeatManCurrency_Last, _checker, __FILE__, __LINE__);
	PString _descbuf;
	BuyInRanges::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("buyInRanges"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	SeatManAdvSearchCriteria::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("seatManAdvSearchCriteria"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	UINT32 clientReqId; _parser.parseUINT32(clientReqId);
	AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 searchFlags; _parser.parseUINT32(searchFlags);
	AtfValidator::validateIntRange(_descr, "searchFlags", searchFlags, eSeatManFlags_None, eSeatManFlags_Last, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_BUYIN_LIMIT
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT::clear()
{
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT::equals(const Protocol_MSG_LOBBY_GET_BUYIN_LIMIT& _o) const
{
	return true;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_BUYIN_LIMIT).append(")");
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT::composeMsg(CommMsgBody& _msg) const
{
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_BUYIN_LIMIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY(Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, limit(std::move(_o.limit))
	, autoLimitHour(std::move(_o.autoLimitHour))
{
}

Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY& Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY::operator=(Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		limit = std::move(_o.limit);
		autoLimitHour = std::move(_o.autoLimitHour);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	limit = 0;
	autoLimitHour = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY::equals(const Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		limit == _o.limit &&
		autoLimitHour == _o.autoLimitHour;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_BUYIN_LIMIT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("limit=");
		_buf.appendInt(limit);
		_buf.append(',');
		_buf.append("autoLimitHour=");
		_buf.appendUint(autoLimitHour);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(limit);
		_msg.composeUINT32(autoLimitHour);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(limit);
		_parser.parseUINT32(autoLimitHour);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_BUYIN_LIMIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 limit; _parser.parseINT32(limit);
		AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
		UINT32 autoLimitHour; _parser.parseUINT32(autoLimitHour);
		AtfValidator::validateInt(_descr, "autoLimitHour", autoLimitHour, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SET_BUYIN_LIMIT
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT::clear()
{
	limit = 0;
	flags = 0;
	flagsEx = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT::equals(const Protocol_MSG_LOBBY_SET_BUYIN_LIMIT& _o) const
{
	return limit == _o.limit &&
		flags == _o.flags &&
		flagsEx == _o.flagsEx;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SET_BUYIN_LIMIT).append(")");
	_buf.append(',');
	_buf.append("limit=");
	_buf.appendInt(limit);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("flagsEx=");
	_buf.appendUint64(flagsEx);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(limit);
	_msg.composeUINT32(flags);
	_msg.composeUINT64(flagsEx);
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(limit);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(flags);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(flagsEx);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_BUYIN_LIMIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 limit; _parser.parseINT32(limit);
	AtfValidator::validateIntMin(_descr, "limit", limit, -1, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 flags; _parser.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 flagsEx; _parser.parseUINT64(flagsEx);
	AtfValidator::validateUint(_descr, "flagsEx", flagsEx, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY(Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, effectiveNow(std::move(_o.effectiveNow))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY& Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY::operator=(Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		effectiveNow = std::move(_o.effectiveNow);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	effectiveNow = false;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY::equals(const Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		effectiveNow == _o.effectiveNow;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SET_BUYIN_LIMIT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("effectiveNow=");
		_buf.appendUint(effectiveNow);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeBOOL(effectiveNow);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseBOOL(effectiveNow);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_BUYIN_LIMIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool effectiveNow; _parser.parseBOOL(effectiveNow);
		AtfValidator::validateInt(_descr, "effectiveNow", effectiveNow, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX::clear()
{
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX::equals(const Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX& _o) const
{
	return true;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_BUYIN_LIMIT_EX).append(")");
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX::composeMsg(CommMsgBody& _msg) const
{
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_BUYIN_LIMIT_EX";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    LimitEx
//=================================================================

Lobby::cli::LimitEx::LimitEx()
{
	clear();
}

void Lobby::cli::LimitEx::clear()
{
	limitType = 0;
	amount = 0;
}

bool Lobby::cli::LimitEx::equals(const LimitEx& _o) const
{
	return limitType == _o.limitType &&
		amount == _o.amount;
}

const char *Lobby::cli::LimitEx::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("limitType=");
	_buf.appendInt(limitType);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendInt(amount);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::LimitEx::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(LimitEx())) // not empty
	{
		_body.composeINT32(limitType);
		_body.composeINT32(amount);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::cli::LimitEx::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(limitType);
	_parser0.parseINT32(amount);
}

/*static*/ void Lobby::cli::LimitEx::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 limitType; _parser0.parseINT32(limitType);
	AtfValidator::validateIntRange(_descr, "limitType", limitType, 0, 1000, _checker, __FILE__, __LINE__);
	INT32 amount; _parser0.parseINT32(amount);
	AtfValidator::validateIntMin(_descr, "amount", amount, -1, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY(Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, limitEx(std::move(_o.limitEx))
{
}

Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY& Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY::operator=(Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		limitEx = std::move(_o.limitEx);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	limitEx.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY::equals(const Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		limitEx.equals(_o.limitEx);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("limitEx=");
		limitEx.toTraceString(_buf);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		limitEx.composeMsg(_msg);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		limitEx.parseMsg(_parser);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szLimitEx = ThinAtf::LAtfVector< LimitEx, 2 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("limitEx"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "limitEx", szLimitEx, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX(Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX&& _o)
	: limitEx(std::move(_o.limitEx))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX& Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX::operator=(Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX&& _o)
{
	if(this != &_o)
	{
		limitEx = std::move(_o.limitEx);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX::clear()
{
	limitEx.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX::equals(const Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX& _o) const
{
	return limitEx.equals(_o.limitEx);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SET_BUYIN_LIMIT_EX).append(")");
	_buf.append(',');
	_buf.append("limitEx=");
	limitEx.toTraceString(_buf);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX::composeMsg(CommMsgBody& _msg) const
{
	limitEx.composeMsg(_msg);
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX::parseMsg(CommMsgParser& _parser)
{
	limitEx.parseMsg(_parser);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_BUYIN_LIMIT_EX";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szLimitEx = ThinAtf::LAtfVector< LimitEx, 2 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("limitEx"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "limitEx", szLimitEx, 10000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    LimitExReply
//=================================================================

Lobby::cli::LimitExReply::LimitExReply()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::LimitExReply::LimitExReply(LimitExReply&& _o)
	: limitType(std::move(_o.limitType))
	, errCodeLimit(std::move(_o.errCodeLimit))
	, errMsg(std::move(_o.errMsg))
	, amount(std::move(_o.amount))
	, effectiveNow(std::move(_o.effectiveNow))
{
}

Lobby::cli::LimitExReply& Lobby::cli::LimitExReply::operator=(LimitExReply&& _o)
{
	if(this != &_o)
	{
		limitType = std::move(_o.limitType);
		errCodeLimit = std::move(_o.errCodeLimit);
		errMsg = std::move(_o.errMsg);
		amount = std::move(_o.amount);
		effectiveNow = std::move(_o.effectiveNow);
	}
	return *this;
}

#endif

void Lobby::cli::LimitExReply::clear()
{
	limitType = 0;
	errCodeLimit = 0;
	errMsg.clear();
	amount = 0;
	effectiveNow = false;
}

bool Lobby::cli::LimitExReply::equals(const LimitExReply& _o) const
{
	return limitType == _o.limitType &&
		errCodeLimit == _o.errCodeLimit &&
		errMsg.equals(_o.errMsg) &&
		amount == _o.amount &&
		effectiveNow == _o.effectiveNow;
}

const char *Lobby::cli::LimitExReply::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("limitType=");
	_buf.appendInt(limitType);
	_buf.append(',');
	_buf.append("errCodeLimit=");
	_buf.appendInt(errCodeLimit);
	if(errCodeLimit)
	{
		_buf.append(',');
		_buf.append("errMsg=");
		_buf.append(errMsg);
	}
	else
	{
		_buf.append(',');
		_buf.append("amount=");
		_buf.appendInt(amount);
		_buf.append(',');
		_buf.append("effectiveNow=");
		_buf.appendUint(effectiveNow);
	}
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::LimitExReply::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(LimitExReply())) // not empty
	{
		_body.composeINT32(limitType);
		_body.composeINT16(errCodeLimit);
		if(errCodeLimit)
		{
			_body.composeString(errMsg);
		}
		else
		{
			_body.composeINT32(amount);
			_body.composeBOOL(effectiveNow);
		}
	}

	_msg.composeMsgBody(_body);
}

void Lobby::cli::LimitExReply::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(limitType);
	_parser0.parseINT16(errCodeLimit);
	if(errCodeLimit)
	{
		_parser0.parseStringP(errMsg);
	}
	else
	{
		_parser0.parseINT32(amount);
		_parser0.parseBOOL(effectiveNow);
	}
}

/*static*/ void Lobby::cli::LimitExReply::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	INT16 errCodeLimit = 0;
	INT32 limitType; _parser0.parseINT32(limitType);
	AtfValidator::validateInt(_descr, "limitType", limitType, _checker, __FILE__, __LINE__);
	_parser0.parseINT16(errCodeLimit);
	AtfValidator::validateInt(_descr, "errCodeLimit", errCodeLimit, _checker, __FILE__, __LINE__);
	if(errCodeLimit)
	{
		_parser0.parseStringN(_dummy, 0, "errMsg"); size_t szErrMsg = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errMsg", szErrMsg, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 amount; _parser0.parseINT32(amount);
		AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
		bool effectiveNow; _parser0.parseBOOL(effectiveNow);
		AtfValidator::validateInt(_descr, "effectiveNow", effectiveNow, _checker, __FILE__, __LINE__);
	}
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY(Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, limitExReply(std::move(_o.limitExReply))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY& Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY::operator=(Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		limitExReply = std::move(_o.limitExReply);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	limitExReply.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY::equals(const Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		limitExReply.equals(_o.limitExReply);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("limitExReply=");
		limitExReply.toTraceString(_buf);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		limitExReply.composeMsg(_msg);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		limitExReply.parseMsg(_parser);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szLimitExReply = ThinAtf::LAtfVector< LimitExReply, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("limitExReply"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "limitExReply", szLimitExReply, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_HISTORY_REQUEST
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST::Protocol_MSG_LOBBY_HISTORY_REQUEST()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST::Protocol_MSG_LOBBY_HISTORY_REQUEST(Protocol_MSG_LOBBY_HISTORY_REQUEST&& _o)
	: notUsed(std::move(_o.notUsed))
	, type(std::move(_o.type))
	, numRequested(std::move(_o.numRequested))
	, handId(std::move(_o.handId))
	, handId64(std::move(_o.handId64))
	, locale(std::move(_o.locale))
{
}

Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST& Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST::operator=(Protocol_MSG_LOBBY_HISTORY_REQUEST&& _o)
{
	if(this != &_o)
	{
		notUsed = std::move(_o.notUsed);
		type = std::move(_o.type);
		numRequested = std::move(_o.numRequested);
		handId = std::move(_o.handId);
		handId64 = std::move(_o.handId64);
		locale = std::move(_o.locale);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST::clear()
{
	notUsed.clear();
	type = 0;
	numRequested = 0;
	handId = 0;
	handId64 = 0;
	locale = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST::equals(const Protocol_MSG_LOBBY_HISTORY_REQUEST& _o) const
{
	return notUsed.equals(_o.notUsed) &&
		type == _o.type &&
		numRequested == _o.numRequested &&
		handId == _o.handId &&
		handId64 == _o.handId64 &&
		locale == _o.locale;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_HISTORY_REQUEST).append(")");
	_buf.append(',');
	_buf.append("notUsed=");
	_buf.append(notUsed);
	_buf.append(',');
	_buf.append("type=");
	_buf.appendInt(type);
	if(type == HAND_HISTORY_LAST_HANDS)
	{
		_buf.append(',');
		_buf.append("numRequested=");
		_buf.appendUint(numRequested);
	}
	else if (type == HAND_HISTORY_LAST_SECONDS)
	{
		_buf.append(',');
		_buf.append("numRequested=");
		_buf.appendUint(numRequested);
	}
	else if (type == HAND_HISTORY_TOURNAMENT)
	{
		_buf.append(',');
		_buf.append("numRequested=");
		_buf.appendUint(numRequested);
	}
	else if (type == HAND_HISTORY_HAND_IDS)
	{
		_buf.append(',');
		_buf.append("numRequested=");
		_buf.appendUint(numRequested);
		_buf.append(',');
		_buf.append("handId=");
		_buf.appendUint(handId);
		_buf.append(',');
		_buf.append("handId64=");
		_buf.appendUint64(handId64);
	}
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(notUsed);
	_msg.composeINT8(type);
	if(type == HAND_HISTORY_LAST_HANDS)
	{
		_msg.composeUINT32(numRequested);
	}
	else if (type == HAND_HISTORY_LAST_SECONDS)
	{
		_msg.composeUINT32(numRequested);
	}
	else if (type == HAND_HISTORY_TOURNAMENT)
	{
		_msg.composeUINT32(numRequested);
	}
	else if (type == HAND_HISTORY_HAND_IDS)
	{
		_msg.composeUINT32(numRequested);
		_msg.composeUINT32(handId);
		_msg.composeUINT64(handId64);
	}
	_msg.composeUINT32(locale);
}

void Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsed);
	_parser.parseINT8(type);
	if(type == HAND_HISTORY_LAST_HANDS)
	{
		_parser.parseUINT32(numRequested);
	}
	else if (type == HAND_HISTORY_LAST_SECONDS)
	{
		_parser.parseUINT32(numRequested);
	}
	else if (type == HAND_HISTORY_TOURNAMENT)
	{
		_parser.parseUINT32(numRequested);
	}
	else if (type == HAND_HISTORY_HAND_IDS)
	{
		_parser.parseUINT32(numRequested);
		_parser.parseUINT32(handId);
		if(_parser.parseEnded()) return;
		_parser.parseUINT64(handId64);
	}
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(locale);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_HISTORY_REQUEST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT8 type = 0;
	_parser.parseStringN(_dummy, 0, "notUsed"); size_t szNotUsed = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsed", szNotUsed, 20, _checker, __FILE__, __LINE__);
	_parser.parseINT8(type);
	AtfValidator::validateIntRange(_descr, "type", type, HAND_HISTORY_LAST_HANDS, HAND_HISTORY_TOURNAMENT, _checker, __FILE__, __LINE__);
	if(type == HAND_HISTORY_LAST_HANDS)
	{
		UINT32 numRequested; _parser.parseUINT32(numRequested);
		AtfValidator::validateIntRange(_descr, "numRequested", numRequested, 1, MAX_HANDS_ALLOWED, _checker, __FILE__, __LINE__);
	}
	else if (type == HAND_HISTORY_LAST_SECONDS)
	{
		UINT32 numRequested; _parser.parseUINT32(numRequested);
		AtfValidator::validateIntRange(_descr, "numRequested", numRequested, 1, 604800, _checker, __FILE__, __LINE__);
	}
	else if (type == HAND_HISTORY_TOURNAMENT)
	{
		UINT32 numRequested; _parser.parseUINT32(numRequested);
		AtfValidator::validateInt(_descr, "numRequested", numRequested, _checker, __FILE__, __LINE__);
	}
	else if (type == HAND_HISTORY_HAND_IDS)
	{
		UINT32 numRequested; _parser.parseUINT32(numRequested);
		AtfValidator::validateIntRange(_descr, "numRequested", numRequested, 1, 1, _checker, __FILE__, __LINE__);
		UINT32 handId; _parser.parseUINT32(handId);
		AtfValidator::validateInt(_descr, "handId", handId, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		UINT64 handId64; _parser.parseUINT64(handId64);
		AtfValidator::validateUint(_descr, "handId64", handId64, _checker, __FILE__, __LINE__);
	}
	if(_parser.parseEnded()) return;
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntRange(_descr, "locale", locale, LOCALE_DEFAULT, MAX_LOCALES, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY::Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY::Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY(Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, email(std::move(_o.email))
{
}

Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY& Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY::operator=(Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		email = std::move(_o.email);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	email.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY::equals(const Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		email.equals(_o.email);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_HISTORY_REQUEST_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("email=");
		_buf.append(email);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(email);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(email);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_HISTORY_REQUEST_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
		AtfValidator::validateInt(_descr, "email", szEmail, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT(Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT&& _o)
	: notUsed(std::move(_o.notUsed))
	, unique(std::move(_o.unique))
{
}

Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT& Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT::operator=(Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT&& _o)
{
	if(this != &_o)
	{
		notUsed = std::move(_o.notUsed);
		unique = std::move(_o.unique);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT::clear()
{
	notUsed.clear();
	unique = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT::equals(const Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT& _o) const
{
	return notUsed.equals(_o.notUsed) &&
		unique == _o.unique;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_ACTIVATE_ACCOUNT).append(")");
	_buf.append(',');
	_buf.append("notUsed=");
	_buf.append(notUsed);
	_buf.append(',');
	_buf.append("unique=");
	_buf.appendUint(unique);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(notUsed);
	_msg.composeUINT32(unique);
}

void Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsed);
	_parser.parseUINT32(unique);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_ACTIVATE_ACCOUNT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsed"); size_t szNotUsed = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsed", szNotUsed, 20, _checker, __FILE__, __LINE__);
	UINT32 unique; _parser.parseUINT32(unique);
	AtfValidator::validateInt(_descr, "unique", unique, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY(Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, firstTimeActivation(std::move(_o.firstTimeActivation))
	, siteId(std::move(_o.siteId))
	, promoName(std::move(_o.promoName))
	, usePromoDeposit(std::move(_o.usePromoDeposit))
	, email(std::move(_o.email))
	, country(std::move(_o.country))
	, locale(std::move(_o.locale))
{
}

Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY& Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY::operator=(Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		firstTimeActivation = std::move(_o.firstTimeActivation);
		siteId = std::move(_o.siteId);
		promoName = std::move(_o.promoName);
		usePromoDeposit = std::move(_o.usePromoDeposit);
		email = std::move(_o.email);
		country = std::move(_o.country);
		locale = std::move(_o.locale);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	firstTimeActivation = false;
	siteId = 0;
	promoName.clear();
	usePromoDeposit = false;
	email.clear();
	country.clear();
	locale = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY::equals(const Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		firstTimeActivation == _o.firstTimeActivation &&
		siteId == _o.siteId &&
		promoName.equals(_o.promoName) &&
		usePromoDeposit == _o.usePromoDeposit &&
		email.equals(_o.email) &&
		country.equals(_o.country) &&
		locale == _o.locale;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("firstTimeActivation=");
		_buf.appendUint(firstTimeActivation);
		_buf.append(',');
		_buf.append("siteId=");
		_buf.appendUint(siteId);
		_buf.append(',');
		_buf.append("promoName=");
		_buf.append(promoName);
		_buf.append(',');
		_buf.append("usePromoDeposit=");
		_buf.appendUint(usePromoDeposit);
		_buf.append(',');
		_buf.append("email=");
		_buf.append(email);
		_buf.append(',');
		_buf.append("country=");
		_buf.append(country);
		_buf.append(',');
		_buf.append("locale=");
		_buf.appendUint(locale);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeBOOL(firstTimeActivation);
		_msg.composeUINT32(siteId);
		_msg.composeString(promoName);
		_msg.composeBOOL(usePromoDeposit);
		_msg.composeString(email);
		_msg.composeString(country);
		_msg.composeUINT32(locale);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseBOOL(firstTimeActivation);
		_parser.parseUINT32(siteId);
		_parser.parseStringP(promoName);
		_parser.parseBOOL(usePromoDeposit);
		_parser.parseStringP(email);
		_parser.parseStringP(country);
		_parser.parseUINT32(locale);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool firstTimeActivation; _parser.parseBOOL(firstTimeActivation);
		AtfValidator::validateInt(_descr, "firstTimeActivation", firstTimeActivation, _checker, __FILE__, __LINE__);
		UINT32 siteId; _parser.parseUINT32(siteId);
		AtfValidator::validateInt(_descr, "siteId", siteId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "promoName"); size_t szPromoName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "promoName", szPromoName, _checker, __FILE__, __LINE__);
		bool usePromoDeposit; _parser.parseBOOL(usePromoDeposit);
		AtfValidator::validateInt(_descr, "usePromoDeposit", usePromoDeposit, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
		AtfValidator::validateInt(_descr, "email", szEmail, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
		AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
		UINT32 locale; _parser.parseUINT32(locale);
		AtfValidator::validateInt(_descr, "locale", locale, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CANCEL_USERTOURN
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN::Protocol_MSG_LOBBY_CANCEL_USERTOURN()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN::Protocol_MSG_LOBBY_CANCEL_USERTOURN(Protocol_MSG_LOBBY_CANCEL_USERTOURN&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, tournId(std::move(_o.tournId))
{
}

Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN& Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN::operator=(Protocol_MSG_LOBBY_CANCEL_USERTOURN&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		tournId = std::move(_o.tournId);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN::clear()
{
	notUsedStr.clear();
	tournId = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN::equals(const Protocol_MSG_LOBBY_CANCEL_USERTOURN& _o) const
{
	return notUsedStr.equals(_o.notUsedStr) &&
		tournId == _o.tournId;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CANCEL_USERTOURN).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(notUsedStr);
	_msg.composeUINT32(tournId);
}

void Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseUINT32(tournId);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CANCEL_USERTOURN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY::Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY::Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY(Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY& Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY::operator=(Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY::equals(const Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CANCEL_USERTOURN_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errDescr=");
	_buf.append(errDescr);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errDescr);
}

void Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(errDescr);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CANCEL_USERTOURN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CLIENT_QUEST
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_CLIENT_QUEST::Protocol_MSG_LOBBY_CLIENT_QUEST()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_CLIENT_QUEST::Protocol_MSG_LOBBY_CLIENT_QUEST(Protocol_MSG_LOBBY_CLIENT_QUEST&& _o)
	: type(std::move(_o.type))
	, descr(std::move(_o.descr))
	, fpp(std::move(_o.fpp))
{
}

Lobby::cli::Protocol_MSG_LOBBY_CLIENT_QUEST& Lobby::cli::Protocol_MSG_LOBBY_CLIENT_QUEST::operator=(Protocol_MSG_LOBBY_CLIENT_QUEST&& _o)
{
	if(this != &_o)
	{
		type = std::move(_o.type);
		descr = std::move(_o.descr);
		fpp = std::move(_o.fpp);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_CLIENT_QUEST::clear()
{
	type = 0;
	descr.clear();
	fpp = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLIENT_QUEST::equals(const Protocol_MSG_LOBBY_CLIENT_QUEST& _o) const
{
	return type == _o.type &&
		descr.equals(_o.descr) &&
		fpp == _o.fpp;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLIENT_QUEST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CLIENT_QUEST).append(")");
	_buf.append(',');
	_buf.append("type=");
	_buf.appendUint(type);
	_buf.append(',');
	_buf.append("descr=");
	_buf.append(descr);
	_buf.append(',');
	_buf.append("fpp=");
	_buf.appendUint(fpp);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_CLIENT_QUEST::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(type);
	_msg.composeString(descr);
	_msg.composeUINT32(fpp);
}

void Lobby::cli::Protocol_MSG_LOBBY_CLIENT_QUEST::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(type);
	_parser.parseStringP(descr);
	_parser.parseUINT32(fpp);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CLIENT_QUEST::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLIENT_QUEST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 type; _parser.parseUINT32(type);
	AtfValidator::validateIntMax(_descr, "type", type, 1000000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "descr"); size_t szDescr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "descr", szDescr, 200, _checker, __FILE__, __LINE__);
	UINT32 fpp; _parser.parseUINT32(fpp);
	AtfValidator::validateIntMax(_descr, "fpp", fpp, 2000000000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_DONT_SHOW_WHERE
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE::Protocol_MSG_LOBBY_DONT_SHOW_WHERE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE::Protocol_MSG_LOBBY_DONT_SHOW_WHERE(Protocol_MSG_LOBBY_DONT_SHOW_WHERE&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, b(std::move(_o.b))
{
}

Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE& Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE::operator=(Protocol_MSG_LOBBY_DONT_SHOW_WHERE&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		b = std::move(_o.b);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE::clear()
{
	notUsedStr.clear();
	b = false;
}

bool Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE::equals(const Protocol_MSG_LOBBY_DONT_SHOW_WHERE& _o) const
{
	return notUsedStr.equals(_o.notUsedStr) &&
		b == _o.b;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_DONT_SHOW_WHERE).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("b=");
	_buf.appendUint(b);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(notUsedStr);
	_msg.composeBOOL(b);
}

void Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseBOOL(b);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_DONT_SHOW_WHERE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	bool b; _parser.parseBOOL(b);
	AtfValidator::validateInt(_descr, "b", b, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY::Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY::Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY(Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY&& _o)
	: err_code(std::move(_o.err_code))
	, errDescr(std::move(_o.errDescr))
	, dontShowWhere(std::move(_o.dontShowWhere))
{
}

Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY& Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY::operator=(Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY&& _o)
{
	if(this != &_o)
	{
		err_code = std::move(_o.err_code);
		errDescr = std::move(_o.errDescr);
		dontShowWhere = std::move(_o.dontShowWhere);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY::clear()
{
	err_code = 0;
	errDescr.clear();
	dontShowWhere = false;
}

bool Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY::equals(const Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY& _o) const
{
	return err_code == _o.err_code &&
		errDescr.equals(_o.errDescr) &&
		dontShowWhere == _o.dontShowWhere;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_DONT_SHOW_WHERE_REPLY).append(")");
	_buf.append(',');
	_buf.append("err_code=");
	_buf.appendInt(err_code);
	_buf.append(',');
	_buf.append("errDescr=");
	_buf.append(errDescr);
	_buf.append(',');
	_buf.append("dontShowWhere=");
	_buf.appendUint(dontShowWhere);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(err_code);
	_msg.composeString(errDescr);
	_msg.composeBOOL(dontShowWhere);
}

void Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(err_code);
	_parser.parseStringP(errDescr);
	_parser.parseBOOL(dontShowWhere);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_DONT_SHOW_WHERE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 err_code; _parser.parseINT16(err_code);
	AtfValidator::validateInt(_descr, "err_code", err_code, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	bool dontShowWhere; _parser.parseBOOL(dontShowWhere);
	AtfValidator::validateInt(_descr, "dontShowWhere", dontShowWhere, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO::Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO::Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO(Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, setPriv(std::move(_o.setPriv))
{
}

Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO& Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO::operator=(Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		setPriv = std::move(_o.setPriv);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO::clear()
{
	notUsedStr.clear();
	setPriv = false;
}

bool Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO::equals(const Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO& _o) const
{
	return notUsedStr.equals(_o.notUsedStr) &&
		setPriv == _o.setPriv;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_DONT_SHOW_PERSONAL_INFO).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("setPriv=");
	_buf.appendUint(setPriv);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(notUsedStr);
	_msg.composeBOOL(setPriv);
}

void Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseBOOL(setPriv);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_DONT_SHOW_PERSONAL_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	bool setPriv; _parser.parseBOOL(setPriv);
	AtfValidator::validateInt(_descr, "setPriv", setPriv, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS(Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, b(std::move(_o.b))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS& Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS::operator=(Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		b = std::move(_o.b);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS::clear()
{
	notUsedStr.clear();
	b = false;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS::equals(const Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS& _o) const
{
	return notUsedStr.equals(_o.notUsedStr) &&
		b == _o.b;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SET_TOURN_EMAIL_FLAGS).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("b=");
	_buf.appendUint(b);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(notUsedStr);
	_msg.composeBOOL(b);
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseBOOL(b);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_TOURN_EMAIL_FLAGS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	bool b; _parser.parseBOOL(b);
	AtfValidator::validateInt(_descr, "b", b, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY(Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY&& _o)
	: err_code(std::move(_o.err_code))
	, errDescr(std::move(_o.errDescr))
	, dontShowWhere(std::move(_o.dontShowWhere))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY& Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY::operator=(Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY&& _o)
{
	if(this != &_o)
	{
		err_code = std::move(_o.err_code);
		errDescr = std::move(_o.errDescr);
		dontShowWhere = std::move(_o.dontShowWhere);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY::clear()
{
	err_code = 0;
	errDescr.clear();
	dontShowWhere = false;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY::equals(const Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY& _o) const
{
	return err_code == _o.err_code &&
		errDescr.equals(_o.errDescr) &&
		dontShowWhere == _o.dontShowWhere;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY).append(")");
	_buf.append(',');
	_buf.append("err_code=");
	_buf.appendInt(err_code);
	_buf.append(',');
	_buf.append("errDescr=");
	_buf.append(errDescr);
	_buf.append(',');
	_buf.append("dontShowWhere=");
	_buf.appendUint(dontShowWhere);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(err_code);
	_msg.composeString(errDescr);
	_msg.composeBOOL(dontShowWhere);
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(err_code);
	_parser.parseStringP(errDescr);
	_parser.parseBOOL(dontShowWhere);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 err_code; _parser.parseINT16(err_code);
	AtfValidator::validateInt(_descr, "err_code", err_code, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	bool dontShowWhere; _parser.parseBOOL(dontShowWhere);
	AtfValidator::validateInt(_descr, "dontShowWhere", dontShowWhere, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    TournTicketInfoBody
//=================================================================

Lobby::cli::TournTicketInfoBody::TournTicketInfoBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::TournTicketInfoBody::TournTicketInfoBody(TournTicketInfoBody&& _o)
	: ticketId(std::move(_o.ticketId))
	, admissionCode(std::move(_o.admissionCode))
	, isMulti(std::move(_o.isMulti))
	, ticketTypeValue(std::move(_o.ticketTypeValue))
	, issued(std::move(_o.issued))
	, expDate(std::move(_o.expDate))
	, currency(std::move(_o.currency))
	, numTourns(std::move(_o.numTourns))
	, ticketTypeFlags(std::move(_o.ticketTypeFlags))
{
}

Lobby::cli::TournTicketInfoBody& Lobby::cli::TournTicketInfoBody::operator=(TournTicketInfoBody&& _o)
{
	if(this != &_o)
	{
		ticketId = std::move(_o.ticketId);
		admissionCode = std::move(_o.admissionCode);
		isMulti = std::move(_o.isMulti);
		ticketTypeValue = std::move(_o.ticketTypeValue);
		issued = std::move(_o.issued);
		expDate = std::move(_o.expDate);
		currency = std::move(_o.currency);
		numTourns = std::move(_o.numTourns);
		ticketTypeFlags = std::move(_o.ticketTypeFlags);
	}
	return *this;
}

#endif

void Lobby::cli::TournTicketInfoBody::clear()
{
	ticketId = 0;
	admissionCode.clear();
	isMulti = false;
	ticketTypeValue = 0;
	issued.setNull();
	expDate.setNull();
	currency.clear();
	numTourns = 0;
	ticketTypeFlags = 0;
}

bool Lobby::cli::TournTicketInfoBody::equals(const TournTicketInfoBody& _o) const
{
	return ticketId == _o.ticketId &&
		admissionCode.equals(_o.admissionCode) &&
		isMulti == _o.isMulti &&
		ticketTypeValue == _o.ticketTypeValue &&
		issued.equals(_o.issued) &&
		expDate.equals(_o.expDate) &&
		currency.equals(_o.currency) &&
		numTourns == _o.numTourns &&
		ticketTypeFlags == _o.ticketTypeFlags;
}

const char *Lobby::cli::TournTicketInfoBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("ticketId=");
	_buf.appendUint(ticketId);
	_buf.append(',');
	_buf.append("admissionCode=");
	_buf.append(admissionCode);
	_buf.append(',');
	_buf.append("isMulti=");
	_buf.appendUint(isMulti);
	_buf.append(',');
	_buf.append("ticketTypeValue=");
	_buf.appendUint(ticketTypeValue);
	_buf.append(',');
	_buf.append("issued=");
	ThinAtf::AtfTempl<CommSrvTime>::ToTraceString(_buf, issued);
	_buf.append(',');
	_buf.append("expDate=");
	ThinAtf::AtfTempl<CommSrvTime>::ToTraceString(_buf, expDate);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("numTourns=");
	_buf.appendInt(numTourns);
	_buf.append(',');
	_buf.append("ticketTypeFlags=");
	_buf.appendUint(ticketTypeFlags);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::TournTicketInfoBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(TournTicketInfoBody())) // not empty
	{
		_body.composeUINT32(ticketId);
		_body.composeString(admissionCode);
		_body.composeBOOL(isMulti);
		_body.composeUINT32(ticketTypeValue);
		_body.composeSrvTime(issued);
		_body.composeSrvTime(expDate);
		_body.composeString(currency);
		_body.composeINT32(numTourns);
		_body.composeUINT32(ticketTypeFlags);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::cli::TournTicketInfoBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(ticketId);
	_parser0.parseStringP(admissionCode);
	_parser0.parseBOOL(isMulti);
	_parser0.parseUINT32(ticketTypeValue);
	_parser0.parseSrvTime(issued);
	_parser0.parseSrvTime(expDate);
	_parser0.parseStringP(currency);
	_parser0.parseINT32(numTourns);
	_parser0.parseUINT32(ticketTypeFlags);
}

/*static*/ void Lobby::cli::TournTicketInfoBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 ticketId; _parser0.parseUINT32(ticketId);
	AtfValidator::validateInt(_descr, "ticketId", ticketId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "admissionCode"); size_t szAdmissionCode = strlen(_dummy);
	AtfValidator::validateInt(_descr, "admissionCode", szAdmissionCode, _checker, __FILE__, __LINE__);
	bool isMulti; _parser0.parseBOOL(isMulti);
	AtfValidator::validateInt(_descr, "isMulti", isMulti, _checker, __FILE__, __LINE__);
	UINT32 ticketTypeValue; _parser0.parseUINT32(ticketTypeValue);
	AtfValidator::validateInt(_descr, "ticketTypeValue", ticketTypeValue, _checker, __FILE__, __LINE__);
	CommSrvTime issued; _parser0.parseSrvTime(issued);
	AtfValidator::validateSrvDateTime(_descr, "issued", issued, _checker, __FILE__, __LINE__);
	CommSrvTime expDate; _parser0.parseSrvTime(expDate);
	AtfValidator::validateSrvDateTime(_descr, "expDate", expDate, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT32 numTourns; _parser0.parseINT32(numTourns);
	AtfValidator::validateInt(_descr, "numTourns", numTourns, _checker, __FILE__, __LINE__);
	UINT32 ticketTypeFlags; _parser0.parseUINT32(ticketTypeFlags);
	AtfValidator::validateInt(_descr, "ticketTypeFlags", ticketTypeFlags, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBY_USER_TOURNTICKETS2
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2::Protocol_MSG_LOBBY_USER_TOURNTICKETS2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2::Protocol_MSG_LOBBY_USER_TOURNTICKETS2(Protocol_MSG_LOBBY_USER_TOURNTICKETS2&& _o)
	: unusedStr(std::move(_o.unusedStr))
{
}

Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2& Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2::operator=(Protocol_MSG_LOBBY_USER_TOURNTICKETS2&& _o)
{
	if(this != &_o)
	{
		unusedStr = std::move(_o.unusedStr);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2::clear()
{
	unusedStr.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2::equals(const Protocol_MSG_LOBBY_USER_TOURNTICKETS2& _o) const
{
	return unusedStr.equals(_o.unusedStr);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_USER_TOURNTICKETS2).append(")");
	_buf.append(',');
	_buf.append("unusedStr=");
	_buf.append(unusedStr);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(unusedStr);
}

void Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseStringP(unusedStr);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_USER_TOURNTICKETS2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "unusedStr"); size_t szUnusedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "unusedStr", szUnusedStr, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY::Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY::Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY(Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, tickets(std::move(_o.tickets))
{
}

Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY& Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY::operator=(Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		tickets = std::move(_o.tickets);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	tickets.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY::equals(const Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		tickets.equals(_o.tickets);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_USER_TOURNTICKETS2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("tickets=");
		tickets.toTraceString(_buf);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		tickets.composeMsg(_msg);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		tickets.parseMsg(_parser);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_USER_TOURNTICKETS2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szTickets = ThinAtf::LAtfVector< TournTicketInfoBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tickets"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tickets", szTickets, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    SingleTournamentBody
//=================================================================

Lobby::cli::SingleTournamentBody::SingleTournamentBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::SingleTournamentBody::SingleTournamentBody(SingleTournamentBody&& _o)
	: tournamentId(std::move(_o.tournamentId))
	, status(std::move(_o.status))
	, tournFlags(std::move(_o.tournFlags))
	, whenStart(std::move(_o.whenStart))
	, entrants(std::move(_o.entrants))
	, minPlayers(std::move(_o.minPlayers))
	, buyIn(std::move(_o.buyIn))
	, game(std::move(_o.game))
	, isHiLo(std::move(_o.isHiLo))
	, structure(std::move(_o.structure))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, server(std::move(_o.server))
	, rake(std::move(_o.rake))
	, knockout(std::move(_o.knockout))
	, fppBuyIn(std::move(_o.fppBuyIn))
	, isRestricted(std::move(_o.isRestricted))
	, currency(std::move(_o.currency))
	, statusBits(std::move(_o.statusBits))
	, name(std::move(_o.name))
	, tournFlags2(std::move(_o.tournFlags2))
{
}

Lobby::cli::SingleTournamentBody& Lobby::cli::SingleTournamentBody::operator=(SingleTournamentBody&& _o)
{
	if(this != &_o)
	{
		tournamentId = std::move(_o.tournamentId);
		status = std::move(_o.status);
		tournFlags = std::move(_o.tournFlags);
		whenStart = std::move(_o.whenStart);
		entrants = std::move(_o.entrants);
		minPlayers = std::move(_o.minPlayers);
		buyIn = std::move(_o.buyIn);
		game = std::move(_o.game);
		isHiLo = std::move(_o.isHiLo);
		structure = std::move(_o.structure);
		isPlayMoney = std::move(_o.isPlayMoney);
		server = std::move(_o.server);
		rake = std::move(_o.rake);
		knockout = std::move(_o.knockout);
		fppBuyIn = std::move(_o.fppBuyIn);
		isRestricted = std::move(_o.isRestricted);
		currency = std::move(_o.currency);
		statusBits = std::move(_o.statusBits);
		name = std::move(_o.name);
		tournFlags2 = std::move(_o.tournFlags2);
	}
	return *this;
}

#endif

void Lobby::cli::SingleTournamentBody::clear()
{
	tournamentId = 0;
	status = 0;
	tournFlags = 0;
	whenStart.setNull();
	entrants = 0;
	minPlayers = 0;
	buyIn = 0;
	game = 0;
	isHiLo = 0;
	structure = 0;
	isPlayMoney = 0;
	server.clear();
	rake = 0;
	knockout = 0;
	fppBuyIn = 0;
	isRestricted = 0;
	currency.clear();
	statusBits = 0;
	name.clear();
	tournFlags2 = 0;
}

bool Lobby::cli::SingleTournamentBody::equals(const SingleTournamentBody& _o) const
{
	return tournamentId == _o.tournamentId &&
		status == _o.status &&
		tournFlags == _o.tournFlags &&
		whenStart.equals(_o.whenStart) &&
		entrants == _o.entrants &&
		minPlayers == _o.minPlayers &&
		buyIn == _o.buyIn &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		structure == _o.structure &&
		isPlayMoney == _o.isPlayMoney &&
		server.equals(_o.server) &&
		rake == _o.rake &&
		knockout == _o.knockout &&
		fppBuyIn == _o.fppBuyIn &&
		isRestricted == _o.isRestricted &&
		currency.equals(_o.currency) &&
		statusBits == _o.statusBits &&
		name.equals(_o.name) &&
		tournFlags2 == _o.tournFlags2;
}

const char *Lobby::cli::SingleTournamentBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournamentId=");
	_buf.appendUint(tournamentId);
	_buf.append(',');
	_buf.append("status=");
	_buf.appendUint(status);
	_buf.append(',');
	_buf.append("tournFlags=");
	_buf.appendUint(tournFlags);
	_buf.append(',');
	_buf.append("whenStart=");
	ThinAtf::AtfTempl<CommSrvTime>::ToTraceString(_buf, whenStart);
	_buf.append(',');
	_buf.append("entrants=");
	_buf.appendUint(entrants);
	_buf.append(',');
	_buf.append("minPlayers=");
	_buf.appendUint(minPlayers);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendUint(buyIn);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendUint(rake);
	_buf.append(',');
	_buf.append("knockout=");
	_buf.appendUint(knockout);
	_buf.append(',');
	_buf.append("fppBuyIn=");
	_buf.appendUint(fppBuyIn);
	_buf.append(',');
	_buf.append("isRestricted=");
	_buf.appendUint(isRestricted);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("statusBits=");
	_buf.appendUint(statusBits);
	_buf.append(',');
	_buf.append("name=");
	ThinAtf::AtfTempl<I18nPString>::ToTraceString(_buf, name);
	_buf.append(',');
	_buf.append("tournFlags2=");
	_buf.appendUint64(tournFlags2);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::SingleTournamentBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(SingleTournamentBody())) // not empty
	{
		_body.composeUINT32(tournamentId);
		_body.composeUINT32(status);
		_body.composeUINT32(tournFlags);
		_body.composeSrvTime(whenStart);
		_body.composeUINT32(entrants);
		_body.composeUINT32(minPlayers);
		_body.composeUINT32(buyIn);
		_body.composeBYTE(game);
		_body.composeBYTE(isHiLo);
		_body.composeBYTE(structure);
		_body.composeBYTE(isPlayMoney);
		_body.composeString(server);
		_body.composeUINT32(rake);
		_body.composeUINT32(knockout);
		_body.composeUINT32(fppBuyIn);
		_body.composeBYTE(isRestricted);
		_body.composeString(currency);
		_body.composeUINT32(statusBits);
		name.compose(_body);
		_body.composeUINT64(tournFlags2);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::cli::SingleTournamentBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(tournamentId);
	_parser0.parseUINT32(status);
	_parser0.parseUINT32(tournFlags);
	_parser0.parseSrvTime(whenStart);
	_parser0.parseUINT32(entrants);
	_parser0.parseUINT32(minPlayers);
	_parser0.parseUINT32(buyIn);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(isHiLo);
	_parser0.parseBYTE(structure);
	_parser0.parseBYTE(isPlayMoney);
	_parser0.parseStringP(server);
	_parser0.parseUINT32(rake);
	_parser0.parseUINT32(knockout);
	_parser0.parseUINT32(fppBuyIn);
	_parser0.parseBYTE(isRestricted);
	_parser0.parseStringP(currency);
	_parser0.parseUINT32(statusBits);
	name.parse(_parser0);
	_parser0.parseUINT64(tournFlags2);
}

/*static*/ void Lobby::cli::SingleTournamentBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 tournamentId; _parser0.parseUINT32(tournamentId);
	AtfValidator::validateInt(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
	UINT32 status; _parser0.parseUINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	UINT32 tournFlags; _parser0.parseUINT32(tournFlags);
	AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
	CommSrvTime whenStart; _parser0.parseSrvTime(whenStart);
	AtfValidator::validateSrvDateTime(_descr, "whenStart", whenStart, _checker, __FILE__, __LINE__);
	UINT32 entrants; _parser0.parseUINT32(entrants);
	AtfValidator::validateInt(_descr, "entrants", entrants, _checker, __FILE__, __LINE__);
	UINT32 minPlayers; _parser0.parseUINT32(minPlayers);
	AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
	UINT32 buyIn; _parser0.parseUINT32(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser0.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser0.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	UINT32 rake; _parser0.parseUINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	UINT32 knockout; _parser0.parseUINT32(knockout);
	AtfValidator::validateInt(_descr, "knockout", knockout, _checker, __FILE__, __LINE__);
	UINT32 fppBuyIn; _parser0.parseUINT32(fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	BYTE isRestricted; _parser0.parseBYTE(isRestricted);
	AtfValidator::validateInt(_descr, "isRestricted", isRestricted, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 statusBits; _parser0.parseUINT32(statusBits);
	AtfValidator::validateInt(_descr, "statusBits", statusBits, _checker, __FILE__, __LINE__);
	I18nPString name; name.parse(_parser0);
	UINT64 tournFlags2; _parser0.parseUINT64(tournFlags2);
	AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBY_TICKET_TOURNTIDS
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS::Protocol_MSG_LOBBY_TICKET_TOURNTIDS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS::Protocol_MSG_LOBBY_TICKET_TOURNTIDS(Protocol_MSG_LOBBY_TICKET_TOURNTIDS&& _o)
	: unusedStr(std::move(_o.unusedStr))
	, ticketId(std::move(_o.ticketId))
{
}

Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS& Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS::operator=(Protocol_MSG_LOBBY_TICKET_TOURNTIDS&& _o)
{
	if(this != &_o)
	{
		unusedStr = std::move(_o.unusedStr);
		ticketId = std::move(_o.ticketId);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS::clear()
{
	unusedStr.clear();
	ticketId = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS::equals(const Protocol_MSG_LOBBY_TICKET_TOURNTIDS& _o) const
{
	return unusedStr.equals(_o.unusedStr) &&
		ticketId == _o.ticketId;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_TICKET_TOURNTIDS).append(")");
	_buf.append(',');
	_buf.append("unusedStr=");
	_buf.append(unusedStr);
	_buf.append(',');
	_buf.append("ticketId=");
	_buf.appendUint(ticketId);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(unusedStr);
	_msg.composeUINT32(ticketId);
}

void Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseStringP(unusedStr);
	_parser.parseUINT32(ticketId);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TICKET_TOURNTIDS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "unusedStr"); size_t szUnusedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "unusedStr", szUnusedStr, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT32 ticketId; _parser.parseUINT32(ticketId);
	AtfValidator::validateInt(_descr, "ticketId", ticketId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY::Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY::Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY(Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, ticketId(std::move(_o.ticketId))
	, tournaments(std::move(_o.tournaments))
{
}

Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY& Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY::operator=(Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		ticketId = std::move(_o.ticketId);
		tournaments = std::move(_o.tournaments);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	ticketId = 0;
	tournaments.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY::equals(const Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		ticketId == _o.ticketId &&
		tournaments.equals(_o.tournaments);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_TICKET_TOURNTIDS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("ticketId=");
		_buf.appendUint(ticketId);
		_buf.append(',');
		_buf.append("tournaments=");
		tournaments.toTraceString(_buf);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(ticketId);
		tournaments.composeMsg(_msg);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(ticketId);
		tournaments.parseMsg(_parser);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TICKET_TOURNTIDS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 ticketId; _parser.parseUINT32(ticketId);
		AtfValidator::validateInt(_descr, "ticketId", ticketId, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szTournaments = ThinAtf::LAtfVector< SingleTournamentBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournaments"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tournaments", szTournaments, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    TeamOnlineBody
//=================================================================

Lobby::cli::TeamOnlineBody::TeamOnlineBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::TeamOnlineBody::TeamOnlineBody(TeamOnlineBody&& _o)
	: isPlay(std::move(_o.isPlay))
	, userId(std::move(_o.userId))
	, name(std::move(_o.name))
	, country(std::move(_o.country))
	, displayCountry(std::move(_o.displayCountry))
{
}

Lobby::cli::TeamOnlineBody& Lobby::cli::TeamOnlineBody::operator=(TeamOnlineBody&& _o)
{
	if(this != &_o)
	{
		isPlay = std::move(_o.isPlay);
		userId = std::move(_o.userId);
		name = std::move(_o.name);
		country = std::move(_o.country);
		displayCountry = std::move(_o.displayCountry);
	}
	return *this;
}

#endif

void Lobby::cli::TeamOnlineBody::clear()
{
	isPlay = false;
	userId.clear();
	name.clear();
	country.clear();
	displayCountry.clear();
}

bool Lobby::cli::TeamOnlineBody::equals(const TeamOnlineBody& _o) const
{
	return isPlay == _o.isPlay &&
		userId.equals(_o.userId) &&
		name.equals(_o.name) &&
		country.equals(_o.country) &&
		displayCountry.equals(_o.displayCountry);
}

const char *Lobby::cli::TeamOnlineBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("isPlay=");
	_buf.appendUint(isPlay);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("displayCountry=");
	_buf.append(displayCountry);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::TeamOnlineBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(TeamOnlineBody())) // not empty
	{
		_body.composeBOOL(isPlay);
		_body.composeString(userId);
		_body.composeString(name);
		_body.composeString(country);
		_body.composeString(displayCountry);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::cli::TeamOnlineBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(isPlay);
	_parser0.parseStringP(userId);
	_parser0.parseStringP(name);
	_parser0.parseStringP(country);
	_parser0.parseStringP(displayCountry);
}

/*static*/ void Lobby::cli::TeamOnlineBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	bool isPlay; _parser0.parseBOOL(isPlay);
	AtfValidator::validateInt(_descr, "isPlay", isPlay, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "displayCountry"); size_t szDisplayCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "displayCountry", szDisplayCountry, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE::clear()
{
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE::equals(const Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE& _o) const
{
	return true;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CLI_TEAM_PS_ONLINE).append(")");
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE::composeMsg(CommMsgBody& _msg) const
{
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLI_TEAM_PS_ONLINE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY(Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, teams(std::move(_o.teams))
{
}

Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY& Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY::operator=(Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		teams = std::move(_o.teams);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	teams.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY::equals(const Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		teams.equals(_o.teams);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("teams=");
		teams.toTraceString(_buf);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		teams.composeMsg(_msg);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		teams.parseMsg(_parser);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szTeams = ThinAtf::LAtfVector< TeamOnlineBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("teams"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "teams", szTeams, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_TIMEZONE_SET
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET::Protocol_MSG_LOBBY_TIMEZONE_SET()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET::Protocol_MSG_LOBBY_TIMEZONE_SET(Protocol_MSG_LOBBY_TIMEZONE_SET&& _o)
	: unusedStr(std::move(_o.unusedStr))
	, timezone(std::move(_o.timezone))
	, tzName(std::move(_o.tzName))
{
}

Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET& Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET::operator=(Protocol_MSG_LOBBY_TIMEZONE_SET&& _o)
{
	if(this != &_o)
	{
		unusedStr = std::move(_o.unusedStr);
		timezone = std::move(_o.timezone);
		tzName = std::move(_o.tzName);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET::clear()
{
	unusedStr.clear();
	timezone = 0;
	tzName.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET::equals(const Protocol_MSG_LOBBY_TIMEZONE_SET& _o) const
{
	return unusedStr.equals(_o.unusedStr) &&
		timezone == _o.timezone &&
		tzName.equals(_o.tzName);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_TIMEZONE_SET).append(")");
	_buf.append(',');
	_buf.append("unusedStr=");
	_buf.append(unusedStr);
	_buf.append(',');
	_buf.append("timezone=");
	_buf.appendUint(timezone);
	_buf.append(',');
	_buf.append("tzName=");
	_buf.append(tzName);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(unusedStr);
	_msg.composeUINT32(timezone);
	_msg.composeString(tzName);
}

void Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(unusedStr);
	_parser.parseUINT32(timezone);
	_parser.parseStringP(tzName);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TIMEZONE_SET";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "unusedStr"); size_t szUnusedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "unusedStr", szUnusedStr, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT32 timezone; _parser.parseUINT32(timezone);
	AtfValidator::validateIntRange(_descr, "timezone", timezone, eTzUTC, 65537, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "tzName"); size_t szTzName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "tzName", szTzName, 100, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY::Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY::Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY(Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, timeZone(std::move(_o.timeZone))
{
}

Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY& Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY::operator=(Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		timeZone = std::move(_o.timeZone);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	timeZone = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY::equals(const Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		timeZone == _o.timeZone;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_TIMEZONE_SET_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("timeZone=");
		_buf.appendUint(timeZone);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(timeZone);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(timeZone);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TIMEZONE_SET_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 timeZone; _parser.parseUINT32(timeZone);
		AtfValidator::validateInt(_descr, "timeZone", timeZone, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_EXCLUDE_PLAYER
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER::Protocol_MSG_LOBBY_EXCLUDE_PLAYER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER::Protocol_MSG_LOBBY_EXCLUDE_PLAYER(Protocol_MSG_LOBBY_EXCLUDE_PLAYER&& _o)
	: unusedStr(std::move(_o.unusedStr))
	, days(std::move(_o.days))
	, dummyFlags(std::move(_o.dummyFlags))
	, dummyFlags2(std::move(_o.dummyFlags2))
	, groupSelfExclusion(std::move(_o.groupSelfExclusion))
	, version(std::move(_o.version))
{
}

Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER& Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER::operator=(Protocol_MSG_LOBBY_EXCLUDE_PLAYER&& _o)
{
	if(this != &_o)
	{
		unusedStr = std::move(_o.unusedStr);
		days = std::move(_o.days);
		dummyFlags = std::move(_o.dummyFlags);
		dummyFlags2 = std::move(_o.dummyFlags2);
		groupSelfExclusion = std::move(_o.groupSelfExclusion);
		version = std::move(_o.version);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER::clear()
{
	unusedStr.clear();
	days = 0;
	dummyFlags = 0;
	dummyFlags2 = 0;
	groupSelfExclusion = false;
	version = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER::equals(const Protocol_MSG_LOBBY_EXCLUDE_PLAYER& _o) const
{
	return unusedStr.equals(_o.unusedStr) &&
		days == _o.days &&
		dummyFlags == _o.dummyFlags &&
		dummyFlags2 == _o.dummyFlags2 &&
		groupSelfExclusion == _o.groupSelfExclusion &&
		version == _o.version;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_EXCLUDE_PLAYER).append(")");
	_buf.append(',');
	_buf.append("unusedStr=");
	_buf.append(unusedStr);
	_buf.append(',');
	_buf.append("days=");
	_buf.appendInt(days);
	_buf.append(',');
	_buf.append("dummyFlags=");
	_buf.appendUint(dummyFlags);
	_buf.append(',');
	_buf.append("dummyFlags2=");
	_buf.appendUint64(dummyFlags2);
	_buf.append(',');
	_buf.append("groupSelfExclusion=");
	_buf.appendUint(groupSelfExclusion);
	_buf.append(',');
	_buf.append("version=");
	_buf.appendUint(version);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(unusedStr);
	_msg.composeINT32(days);
	_msg.composeUINT32(dummyFlags);
	_msg.composeUINT64(dummyFlags2);
	_msg.composeBOOL(groupSelfExclusion);
	_msg.composeBYTE(version);
}

void Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(unusedStr);
	_parser.parseINT32(days);
	_parser.parseUINT32(dummyFlags);
	_parser.parseUINT64(dummyFlags2);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(groupSelfExclusion);
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(version);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_EXCLUDE_PLAYER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "unusedStr"); size_t szUnusedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "unusedStr", szUnusedStr, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	INT32 days; _parser.parseINT32(days);
	AtfValidator::validateIntRange(_descr, "days", days, -12, 36500, _checker, __FILE__, __LINE__);
	UINT32 dummyFlags; _parser.parseUINT32(dummyFlags);
	AtfValidator::validateInt(_descr, "dummyFlags", dummyFlags, _checker, __FILE__, __LINE__);
	UINT64 dummyFlags2; _parser.parseUINT64(dummyFlags2);
	AtfValidator::validateUint(_descr, "dummyFlags2", dummyFlags2, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool groupSelfExclusion; _parser.parseBOOL(groupSelfExclusion);
	AtfValidator::validateInt(_descr, "groupSelfExclusion", groupSelfExclusion, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	BYTE version; _parser.parseBYTE(version);
	AtfValidator::validateInt(_descr, "version", version, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY::Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY::Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY(Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, days(std::move(_o.days))
	, until(std::move(_o.until))
	, requestedDays(std::move(_o.requestedDays))
	, seFlags(std::move(_o.seFlags))
{
}

Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY& Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY::operator=(Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		days = std::move(_o.days);
		until = std::move(_o.until);
		requestedDays = std::move(_o.requestedDays);
		seFlags = std::move(_o.seFlags);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	days = 0;
	until.setNull();
	requestedDays = 0;
	seFlags = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY::equals(const Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		days == _o.days &&
		until.equals(_o.until) &&
		requestedDays == _o.requestedDays &&
		seFlags == _o.seFlags;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_EXCLUDE_PLAYER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("days=");
		_buf.appendInt(days);
		_buf.append(',');
		_buf.append("until=");
		ThinAtf::AtfTempl<CommSrvTime>::ToTraceString(_buf, until);
		_buf.append(',');
		_buf.append("requestedDays=");
		_buf.appendInt(requestedDays);
		_buf.append(',');
		_buf.append("seFlags=");
		_buf.appendUint(seFlags);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(days);
		_msg.composeSrvTime(until);
		_msg.composeINT32(requestedDays);
		_msg.composeUINT32(seFlags);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(days);
		_parser.parseSrvTime(until);
		_parser.parseINT32(requestedDays);
		_parser.parseUINT32(seFlags);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_EXCLUDE_PLAYER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 days; _parser.parseINT32(days);
		AtfValidator::validateInt(_descr, "days", days, _checker, __FILE__, __LINE__);
		CommSrvTime until; _parser.parseSrvTime(until);
		AtfValidator::validateSrvDateTime(_descr, "until", until, _checker, __FILE__, __LINE__);
		INT32 requestedDays; _parser.parseINT32(requestedDays);
		AtfValidator::validateInt(_descr, "requestedDays", requestedDays, _checker, __FILE__, __LINE__);
		UINT32 seFlags; _parser.parseUINT32(seFlags);
		AtfValidator::validateInt(_descr, "seFlags", seFlags, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP(Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP&& _o)
	: unusedStr(std::move(_o.unusedStr))
	, pwd(std::move(_o.pwd))
	, language(std::move(_o.language))
{
}

Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP& Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP::operator=(Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP&& _o)
{
	if(this != &_o)
	{
		unusedStr = std::move(_o.unusedStr);
		pwd = std::move(_o.pwd);
		language = std::move(_o.language);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP::clear()
{
	unusedStr.clear();
	pwd.clear();
	language.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP::equals(const Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP& _o) const
{
	return unusedStr.equals(_o.unusedStr) &&
		pwd.equals(_o.pwd) &&
		language.equals(_o.language);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_INTELLIPOKER_SIGNUP).append(")");
	_buf.append(',');
	_buf.append("unusedStr=");
	_buf.append(unusedStr);
	_buf.append(',');
	_buf.append("pwd=");
	_buf.append(pwd);
	_buf.append(',');
	_buf.append("language=");
	_buf.append(language);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(unusedStr);
	_msg.composeString(pwd);
	_msg.composeString(language);
}

void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(unusedStr);
	_parser.parseStringP(pwd);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(language);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_INTELLIPOKER_SIGNUP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "unusedStr"); size_t szUnusedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "unusedStr", szUnusedStr, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "pwd"); size_t szPwd = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "pwd", szPwd, 100, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "language"); size_t szLanguage = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "language", szLanguage, 100, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY(Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, code(std::move(_o.code))
	, info(std::move(_o.info))
	, url(std::move(_o.url))
	, urlCaption(std::move(_o.urlCaption))
{
}

Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY& Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY::operator=(Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		code = std::move(_o.code);
		info = std::move(_o.info);
		url = std::move(_o.url);
		urlCaption = std::move(_o.urlCaption);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	code = 0;
	info.clear();
	url.clear();
	urlCaption.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY::equals(const Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		code == _o.code &&
		info.equals(_o.info) &&
		url.equals(_o.url) &&
		urlCaption.equals(_o.urlCaption);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("code=");
		_buf.appendUint(code);
		_buf.append(',');
		_buf.append("info=");
		_buf.append(info);
		_buf.append(',');
		_buf.append("url=");
		_buf.append(url);
		_buf.append(',');
		_buf.append("urlCaption=");
		_buf.append(urlCaption);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(code);
		_msg.composeString(info);
		_msg.composeString(url);
		_msg.composeString(urlCaption);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(code);
		_parser.parseStringP(info);
		_parser.parseStringP(url);
		_parser.parseStringP(urlCaption);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 code; _parser.parseUINT32(code);
		AtfValidator::validateInt(_descr, "code", code, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "info"); size_t szInfo = strlen(_dummy);
		AtfValidator::validateInt(_descr, "info", szInfo, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "url"); size_t szUrl = strlen(_dummy);
		AtfValidator::validateInt(_descr, "url", szUrl, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "urlCaption"); size_t szUrlCaption = strlen(_dummy);
		AtfValidator::validateInt(_descr, "urlCaption", szUrlCaption, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_INTELLIPOKER_PWD
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD::Protocol_MSG_LOBBY_INTELLIPOKER_PWD()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD::Protocol_MSG_LOBBY_INTELLIPOKER_PWD(Protocol_MSG_LOBBY_INTELLIPOKER_PWD&& _o)
	: unusedStr(std::move(_o.unusedStr))
	, pwd(std::move(_o.pwd))
{
}

Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD& Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD::operator=(Protocol_MSG_LOBBY_INTELLIPOKER_PWD&& _o)
{
	if(this != &_o)
	{
		unusedStr = std::move(_o.unusedStr);
		pwd = std::move(_o.pwd);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD::clear()
{
	unusedStr.clear();
	pwd.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD::equals(const Protocol_MSG_LOBBY_INTELLIPOKER_PWD& _o) const
{
	return unusedStr.equals(_o.unusedStr) &&
		pwd.equals(_o.pwd);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_INTELLIPOKER_PWD).append(")");
	_buf.append(',');
	_buf.append("unusedStr=");
	_buf.append(unusedStr);
	_buf.append(',');
	_buf.append("pwd=");
	_buf.append(pwd);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(unusedStr);
	_msg.composeString(pwd);
}

void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(unusedStr);
	_parser.parseStringP(pwd);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_INTELLIPOKER_PWD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "unusedStr"); size_t szUnusedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "unusedStr", szUnusedStr, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "pwd"); size_t szPwd = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "pwd", szPwd, 100, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY::Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY::Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY(Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, code(std::move(_o.code))
	, info(std::move(_o.info))
	, url(std::move(_o.url))
	, urlCaption(std::move(_o.urlCaption))
{
}

Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY& Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY::operator=(Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		code = std::move(_o.code);
		info = std::move(_o.info);
		url = std::move(_o.url);
		urlCaption = std::move(_o.urlCaption);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	code = 0;
	info.clear();
	url.clear();
	urlCaption.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY::equals(const Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		code == _o.code &&
		info.equals(_o.info) &&
		url.equals(_o.url) &&
		urlCaption.equals(_o.urlCaption);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_INTELLIPOKER_PWD_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("code=");
		_buf.appendUint(code);
		_buf.append(',');
		_buf.append("info=");
		_buf.append(info);
		_buf.append(',');
		_buf.append("url=");
		_buf.append(url);
		_buf.append(',');
		_buf.append("urlCaption=");
		_buf.append(urlCaption);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(code);
		_msg.composeString(info);
		_msg.composeString(url);
		_msg.composeString(urlCaption);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(code);
		_parser.parseStringP(info);
		_parser.parseStringP(url);
		_parser.parseStringP(urlCaption);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_INTELLIPOKER_PWD_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 code; _parser.parseUINT32(code);
		AtfValidator::validateInt(_descr, "code", code, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "info"); size_t szInfo = strlen(_dummy);
		AtfValidator::validateInt(_descr, "info", szInfo, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "url"); size_t szUrl = strlen(_dummy);
		AtfValidator::validateInt(_descr, "url", szUrl, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "urlCaption"); size_t szUrlCaption = strlen(_dummy);
		AtfValidator::validateInt(_descr, "urlCaption", szUrlCaption, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    ConsentBody
//=================================================================

Lobby::cli::ConsentBody::ConsentBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::ConsentBody::ConsentBody(ConsentBody&& _o)
	: id(std::move(_o.id))
	, status(std::move(_o.status))
	, empty(std::move(_o.empty))
	, empty2(std::move(_o.empty2))
{
}

Lobby::cli::ConsentBody& Lobby::cli::ConsentBody::operator=(ConsentBody&& _o)
{
	if(this != &_o)
	{
		id = std::move(_o.id);
		status = std::move(_o.status);
		empty = std::move(_o.empty);
		empty2 = std::move(_o.empty2);
	}
	return *this;
}

#endif

void Lobby::cli::ConsentBody::clear()
{
	id = 0;
	status = 0;
	empty.clear();
	empty2.clear();
}

bool Lobby::cli::ConsentBody::equals(const ConsentBody& _o) const
{
	return id == _o.id &&
		status == _o.status &&
		empty.equals(_o.empty) &&
		empty2.equals(_o.empty2);
}

const char *Lobby::cli::ConsentBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("id=");
	_buf.appendUint(id);
	_buf.append(',');
	_buf.append("status=");
	_buf.appendUint(status);
	_buf.append(',');
	_buf.append("empty=");
	_buf.append(empty);
	_buf.append(',');
	_buf.append("empty2=");
	_buf.append(empty2);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::ConsentBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(ConsentBody())) // not empty
	{
		_body.composeUINT32(id);
		_body.composeUINT32(status);
		_body.composeString(empty);
		_body.composeString(empty2);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::cli::ConsentBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(id);
	_parser0.parseUINT32(status);
	_parser0.parseStringP(empty);
	_parser0.parseStringP(empty2);
}

/*static*/ void Lobby::cli::ConsentBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 id; _parser0.parseUINT32(id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	UINT32 status; _parser0.parseUINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "empty"); size_t szEmpty = strlen(_dummy);
	AtfValidator::validateInt(_descr, "empty", szEmpty, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "empty2"); size_t szEmpty2 = strlen(_dummy);
	AtfValidator::validateInt(_descr, "empty2", szEmpty2, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_CONSENTS
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS::Protocol_MSG_LOBBY_GET_CONSENTS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS::Protocol_MSG_LOBBY_GET_CONSENTS(Protocol_MSG_LOBBY_GET_CONSENTS&& _o)
	: unusedStr(std::move(_o.unusedStr))
{
}

Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS& Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS::operator=(Protocol_MSG_LOBBY_GET_CONSENTS&& _o)
{
	if(this != &_o)
	{
		unusedStr = std::move(_o.unusedStr);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS::clear()
{
	unusedStr.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS::equals(const Protocol_MSG_LOBBY_GET_CONSENTS& _o) const
{
	return unusedStr.equals(_o.unusedStr);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_CONSENTS).append(")");
	_buf.append(',');
	_buf.append("unusedStr=");
	_buf.append(unusedStr);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(unusedStr);
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseStringP(unusedStr);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_CONSENTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "unusedStr"); size_t szUnusedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "unusedStr", szUnusedStr, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_CONSENTS_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS_REPLY::Protocol_MSG_LOBBY_GET_CONSENTS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS_REPLY::Protocol_MSG_LOBBY_GET_CONSENTS_REPLY(Protocol_MSG_LOBBY_GET_CONSENTS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, consents(std::move(_o.consents))
{
}

Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS_REPLY& Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS_REPLY::operator=(Protocol_MSG_LOBBY_GET_CONSENTS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		consents = std::move(_o.consents);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	consents.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS_REPLY::equals(const Protocol_MSG_LOBBY_GET_CONSENTS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		consents.equals(_o.consents);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_CONSENTS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("consents=");
		consents.toTraceString(_buf);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		consents.composeMsg(_msg);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		consents.parseMsg(_parser);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_CONSENTS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szConsents = ThinAtf::LAtfVector< ConsentBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("consents"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "consents", szConsents, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_USER_STATS
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_USER_STATS::Protocol_MSG_LOBBY_USER_STATS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_USER_STATS::Protocol_MSG_LOBBY_USER_STATS(Protocol_MSG_LOBBY_USER_STATS&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, numHands(std::move(_o.numHands))
{
}

Lobby::cli::Protocol_MSG_LOBBY_USER_STATS& Lobby::cli::Protocol_MSG_LOBBY_USER_STATS::operator=(Protocol_MSG_LOBBY_USER_STATS&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		numHands = std::move(_o.numHands);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_USER_STATS::clear()
{
	notUsedStr.clear();
	numHands = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_USER_STATS::equals(const Protocol_MSG_LOBBY_USER_STATS& _o) const
{
	return notUsedStr.equals(_o.notUsedStr) &&
		numHands == _o.numHands;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_USER_STATS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_USER_STATS).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("numHands=");
	_buf.appendInt(numHands);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_USER_STATS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(notUsedStr);
	_msg.composeINT32(numHands);
}

void Lobby::cli::Protocol_MSG_LOBBY_USER_STATS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseINT32(numHands);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_USER_STATS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_USER_STATS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	INT32 numHands; _parser.parseINT32(numHands);
	AtfValidator::validateIntRange(_descr, "numHands", numHands, 1, 2000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_USER_STATS_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_USER_STATS_REPLY::Protocol_MSG_LOBBY_USER_STATS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_USER_STATS_REPLY::Protocol_MSG_LOBBY_USER_STATS_REPLY(Protocol_MSG_LOBBY_USER_STATS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, email(std::move(_o.email))
{
}

Lobby::cli::Protocol_MSG_LOBBY_USER_STATS_REPLY& Lobby::cli::Protocol_MSG_LOBBY_USER_STATS_REPLY::operator=(Protocol_MSG_LOBBY_USER_STATS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		email = std::move(_o.email);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_USER_STATS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	email.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_USER_STATS_REPLY::equals(const Protocol_MSG_LOBBY_USER_STATS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		email.equals(_o.email);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_USER_STATS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_USER_STATS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("email=");
		_buf.append(email);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_USER_STATS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(email);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_USER_STATS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(email);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_USER_STATS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_USER_STATS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
		AtfValidator::validateInt(_descr, "email", szEmail, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_TOURN_STATS
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS::Protocol_MSG_LOBBY_TOURN_STATS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS::Protocol_MSG_LOBBY_TOURN_STATS(Protocol_MSG_LOBBY_TOURN_STATS&& _o)
	: requestType(std::move(_o.requestType))
	, notUsedStr(std::move(_o.notUsedStr))
	, tournIdOrCount(std::move(_o.tournIdOrCount))
{
}

Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS& Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS::operator=(Protocol_MSG_LOBBY_TOURN_STATS&& _o)
{
	if(this != &_o)
	{
		requestType = std::move(_o.requestType);
		notUsedStr = std::move(_o.notUsedStr);
		tournIdOrCount = std::move(_o.tournIdOrCount);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS::clear()
{
	requestType = 0;
	notUsedStr.clear();
	tournIdOrCount = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS::equals(const Protocol_MSG_LOBBY_TOURN_STATS& _o) const
{
	return requestType == _o.requestType &&
		notUsedStr.equals(_o.notUsedStr) &&
		tournIdOrCount == _o.tournIdOrCount;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_TOURN_STATS).append(")");
	_buf.append(',');
	_buf.append("requestType=");
	_buf.appendUint(requestType);
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("tournIdOrCount=");
	_buf.appendUint(tournIdOrCount);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(requestType);
	_msg.composeString(notUsedStr);
	_msg.composeUINT32(tournIdOrCount);
}

void Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(requestType);
	_parser.parseStringP(notUsedStr);
	_parser.parseUINT32(tournIdOrCount);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TOURN_STATS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE requestType; _parser.parseBYTE(requestType);
	AtfValidator::validateIntRange(_descr, "requestType", requestType, TOURN_STATS_TOURN_ID, TOURN_STATS_TOURN_ID_NOSTAT, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	UINT32 tournIdOrCount; _parser.parseUINT32(tournIdOrCount);
	AtfValidator::validateInt(_descr, "tournIdOrCount", tournIdOrCount, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_TOURN_STATS_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS_REPLY::Protocol_MSG_LOBBY_TOURN_STATS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS_REPLY::Protocol_MSG_LOBBY_TOURN_STATS_REPLY(Protocol_MSG_LOBBY_TOURN_STATS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, email(std::move(_o.email))
{
}

Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS_REPLY& Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS_REPLY::operator=(Protocol_MSG_LOBBY_TOURN_STATS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		email = std::move(_o.email);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	email.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS_REPLY::equals(const Protocol_MSG_LOBBY_TOURN_STATS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		email.equals(_o.email);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_TOURN_STATS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("email=");
		_buf.append(email);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(email);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(email);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TOURN_STATS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
		AtfValidator::validateInt(_descr, "email", szEmail, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_LOGOUT
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_LOGOUT::Protocol_MSG_LOBBY_LOGOUT()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_LOGOUT::clear()
{
	flags = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_LOGOUT::equals(const Protocol_MSG_LOBBY_LOGOUT& _o) const
{
	return flags == _o.flags;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_LOGOUT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_LOGOUT).append(")");
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_LOGOUT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(flags);
}

void Lobby::cli::Protocol_MSG_LOBBY_LOGOUT::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(flags);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_LOGOUT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_LOGOUT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(_parser.parseEnded()) return;
	UINT32 flags; _parser.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_LOGOUT_CONFIRM
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_LOGOUT_CONFIRM::Protocol_MSG_LOBBY_LOGOUT_CONFIRM()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_LOGOUT_CONFIRM::clear()
{
}

bool Lobby::cli::Protocol_MSG_LOBBY_LOGOUT_CONFIRM::equals(const Protocol_MSG_LOBBY_LOGOUT_CONFIRM& _o) const
{
	return true;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_LOGOUT_CONFIRM::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_LOGOUT_CONFIRM).append(")");
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_LOGOUT_CONFIRM::composeMsg(CommMsgBody& _msg) const
{
}

void Lobby::cli::Protocol_MSG_LOBBY_LOGOUT_CONFIRM::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_LOGOUT_CONFIRM::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_LOGOUT_CONFIRM";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_ADMIN_INFO
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO::Protocol_MSG_LOBBY_ADMIN_INFO()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO::Protocol_MSG_LOBBY_ADMIN_INFO(Protocol_MSG_LOBBY_ADMIN_INFO&& _o)
	: message(std::move(_o.message))
{
}

Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO& Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO::operator=(Protocol_MSG_LOBBY_ADMIN_INFO&& _o)
{
	if(this != &_o)
	{
		message = std::move(_o.message);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO::clear()
{
	message.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO::equals(const Protocol_MSG_LOBBY_ADMIN_INFO& _o) const
{
	return message.equals(_o.message);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_ADMIN_INFO).append(")");
	_buf.append(',');
	_buf.append("message=");
	_buf.append(message);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(message);
}

void Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(message);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_ADMIN_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "message"); size_t szMessage = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "message", szMessage, 10000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_ADMIN_INFO_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::clear()
{
}

bool Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::equals(const Protocol_MSG_LOBBY_ADMIN_INFO_REPLY& _o) const
{
	return true;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_ADMIN_INFO_REPLY).append(")");
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::composeMsg(CommMsgBody& _msg) const
{
}

void Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_ADMIN_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_TLB
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_TLB::Protocol_MSG_LOBBY_GET_TLB()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_GET_TLB::Protocol_MSG_LOBBY_GET_TLB(Protocol_MSG_LOBBY_GET_TLB&& _o)
	: notUsed(std::move(_o.notUsed))
	, dateFrom(std::move(_o.dateFrom))
	, dateTo(std::move(_o.dateTo))
{
}

Lobby::cli::Protocol_MSG_LOBBY_GET_TLB& Lobby::cli::Protocol_MSG_LOBBY_GET_TLB::operator=(Protocol_MSG_LOBBY_GET_TLB&& _o)
{
	if(this != &_o)
	{
		notUsed = std::move(_o.notUsed);
		dateFrom = std::move(_o.dateFrom);
		dateTo = std::move(_o.dateTo);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_GET_TLB::clear()
{
	notUsed.clear();
	dateFrom.setNull();
	dateTo.setNull();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_TLB::equals(const Protocol_MSG_LOBBY_GET_TLB& _o) const
{
	return notUsed.equals(_o.notUsed) &&
		dateFrom.equals(_o.dateFrom) &&
		dateTo.equals(_o.dateTo);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_TLB::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_TLB).append(")");
	_buf.append(',');
	_buf.append("notUsed=");
	_buf.append(notUsed);
	_buf.append(',');
	_buf.append("dateFrom=");
	ThinAtf::AtfTempl<SrvDate>::ToTraceString(_buf, dateFrom);
	_buf.append(',');
	_buf.append("dateTo=");
	ThinAtf::AtfTempl<SrvDate>::ToTraceString(_buf, dateTo);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_TLB::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(notUsed);
	_msg.composeSrvDate(dateFrom);
	_msg.composeSrvDate(dateTo);
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_TLB::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsed);
	_parser.parseSrvDate(dateFrom);
	_parser.parseSrvDate(dateTo);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_TLB::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_TLB";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsed"); size_t szNotUsed = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsed", szNotUsed, 20, _checker, __FILE__, __LINE__);
	SrvDate dateFrom; _parser.parseSrvDate(dateFrom);
	AtfValidator::validateSrvDateTime(_descr, "dateFrom", dateFrom, _checker, __FILE__, __LINE__);
	SrvDate dateTo; _parser.parseSrvDate(dateTo);
	AtfValidator::validateSrvDateTime(_descr, "dateTo", dateTo, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_TLB_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_TLB_REPLY::Protocol_MSG_LOBBY_GET_TLB_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_GET_TLB_REPLY::Protocol_MSG_LOBBY_GET_TLB_REPLY(Protocol_MSG_LOBBY_GET_TLB_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, email(std::move(_o.email))
{
}

Lobby::cli::Protocol_MSG_LOBBY_GET_TLB_REPLY& Lobby::cli::Protocol_MSG_LOBBY_GET_TLB_REPLY::operator=(Protocol_MSG_LOBBY_GET_TLB_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		email = std::move(_o.email);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_GET_TLB_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	email.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_TLB_REPLY::equals(const Protocol_MSG_LOBBY_GET_TLB_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		email.equals(_o.email);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_TLB_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_TLB_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("email=");
		_buf.append(email);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_TLB_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(email);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_TLB_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(email);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_TLB_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_TLB_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
		AtfValidator::validateInt(_descr, "email", szEmail, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_USER_PROPS
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS::Protocol_MSG_LOBBY_USER_PROPS()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS::clear()
{
}

bool Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS::equals(const Protocol_MSG_LOBBY_USER_PROPS& _o) const
{
	return true;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_USER_PROPS).append(")");
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS::composeMsg(CommMsgBody& _msg) const
{
}

void Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_USER_PROPS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    StellarBonus
//=================================================================

Lobby::cli::StellarBonus::StellarBonus()
{
	clear();
}

void Lobby::cli::StellarBonus::clear()
{
	vppThreshold = 0;
	amount = 0;
}

bool Lobby::cli::StellarBonus::equals(const StellarBonus& _o) const
{
	return vppThreshold == _o.vppThreshold &&
		amount == _o.amount;
}

const char *Lobby::cli::StellarBonus::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("vppThreshold=");
	_buf.appendUint(vppThreshold);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendUint(amount);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::StellarBonus::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(vppThreshold);
	_msg.composeUINT32(amount);
}

void Lobby::cli::StellarBonus::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(vppThreshold);
	_parser.parseUINT32(amount);
}

/*static*/ void Lobby::cli::StellarBonus::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 vppThreshold; _parser.parseUINT32(vppThreshold);
	AtfValidator::validateInt(_descr, "vppThreshold", vppThreshold, _checker, __FILE__, __LINE__);
	UINT32 amount; _parser.parseUINT32(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    MilestoneBonusOld
//=================================================================

Lobby::cli::MilestoneBonusOld::MilestoneBonusOld()
{
	clear();
}

void Lobby::cli::MilestoneBonusOld::clear()
{
	vppThreshold = 0;
}

bool Lobby::cli::MilestoneBonusOld::equals(const MilestoneBonusOld& _o) const
{
	return vppThreshold == _o.vppThreshold;
}

const char *Lobby::cli::MilestoneBonusOld::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("vppThreshold=");
	_buf.appendUint(vppThreshold);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::MilestoneBonusOld::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(vppThreshold);
}

void Lobby::cli::MilestoneBonusOld::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(vppThreshold);
}

/*static*/ void Lobby::cli::MilestoneBonusOld::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 vppThreshold; _parser.parseUINT32(vppThreshold);
	AtfValidator::validateInt(_descr, "vppThreshold", vppThreshold, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    MilestoneBonusNew
//=================================================================

Lobby::cli::MilestoneBonusNew::MilestoneBonusNew()
{
	clear();
}

void Lobby::cli::MilestoneBonusNew::clear()
{
	license = 0;
	vppThreshold = 0;
	amount = 0;
}

bool Lobby::cli::MilestoneBonusNew::equals(const MilestoneBonusNew& _o) const
{
	return license == _o.license &&
		vppThreshold == _o.vppThreshold &&
		amount == _o.amount;
}

const char *Lobby::cli::MilestoneBonusNew::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("license=");
	_buf.appendUint(license);
	_buf.append(',');
	_buf.append("vppThreshold=");
	_buf.appendUint(vppThreshold);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendUint(amount);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::MilestoneBonusNew::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(MilestoneBonusNew())) // not empty
	{
		CommMsgBody _body0;
		_body0.composeUINT32(license);
		_body0.composeUINT32(vppThreshold);
		_body0.composeUINT32(amount);
		_body.composeMsgBody(_body0);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::cli::MilestoneBonusNew::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	parseAnonymousMsgBody0(_parser0);
}

/*static*/ void Lobby::cli::MilestoneBonusNew::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	validateAnonymousMsgBody0(_parser0, _checker, _descr, _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void Lobby::cli::MilestoneBonusNew::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(license);
	_parser0.parseUINT32(vppThreshold);
	_parser0.parseUINT32(amount);
}

/*static*/ void Lobby::cli::MilestoneBonusNew::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 license; _parser0.parseUINT32(license);
	AtfValidator::validateInt(_descr, "license", license, _checker, __FILE__, __LINE__);
	UINT32 vppThreshold; _parser0.parseUINT32(vppThreshold);
	AtfValidator::validateInt(_descr, "vppThreshold", vppThreshold, _checker, __FILE__, __LINE__);
	UINT32 amount; _parser0.parseUINT32(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    VIPLevel
//=================================================================

Lobby::cli::VIPLevel::VIPLevel()
{
	clear();
}

void Lobby::cli::VIPLevel::clear()
{
	statusId = 0;
	minFpp = 0;
	fppBonusRate = 0;
	vipToKeepYearlyStatus = 0;
}

bool Lobby::cli::VIPLevel::equals(const VIPLevel& _o) const
{
	return statusId == _o.statusId &&
		minFpp == _o.minFpp &&
		fppBonusRate == _o.fppBonusRate &&
		vipToKeepYearlyStatus == _o.vipToKeepYearlyStatus;
}

const char *Lobby::cli::VIPLevel::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("statusId=");
	_buf.appendUint(statusId);
	_buf.append(',');
	_buf.append("minFpp=");
	_buf.appendUint(minFpp);
	_buf.append(',');
	_buf.append("fppBonusRate=");
	_buf.appendUint(fppBonusRate);
	_buf.append(',');
	_buf.append("vipToKeepYearlyStatus=");
	_buf.appendUint(vipToKeepYearlyStatus);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::VIPLevel::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(statusId);
	_msg.composeUINT32(minFpp);
	_msg.composeUINT32(fppBonusRate);
	_msg.composeUINT32(vipToKeepYearlyStatus);
}

void Lobby::cli::VIPLevel::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(statusId);
	_parser.parseUINT32(minFpp);
	_parser.parseUINT32(fppBonusRate);
	_parser.parseUINT32(vipToKeepYearlyStatus);
}

/*static*/ void Lobby::cli::VIPLevel::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 statusId; _parser.parseUINT32(statusId);
	AtfValidator::validateInt(_descr, "statusId", statusId, _checker, __FILE__, __LINE__);
	UINT32 minFpp; _parser.parseUINT32(minFpp);
	AtfValidator::validateInt(_descr, "minFpp", minFpp, _checker, __FILE__, __LINE__);
	UINT32 fppBonusRate; _parser.parseUINT32(fppBonusRate);
	AtfValidator::validateInt(_descr, "fppBonusRate", fppBonusRate, _checker, __FILE__, __LINE__);
	UINT32 vipToKeepYearlyStatus; _parser.parseUINT32(vipToKeepYearlyStatus);
	AtfValidator::validateInt(_descr, "vipToKeepYearlyStatus", vipToKeepYearlyStatus, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    RawVIPLevel
//=================================================================

Lobby::cli::RawVIPLevel::RawVIPLevel()
{
	clear();
}

void Lobby::cli::RawVIPLevel::clear()
{
	statusId = 0;
	type = 0;
	minFpp = 0;
	fppBonusRate = 0;
	vipToKeepYearlyStatus = 0;
	lastMonthForYearly = 0;
	missableMonthsYearly = 0;
}

bool Lobby::cli::RawVIPLevel::equals(const RawVIPLevel& _o) const
{
	return statusId == _o.statusId &&
		type == _o.type &&
		minFpp == _o.minFpp &&
		fppBonusRate == _o.fppBonusRate &&
		vipToKeepYearlyStatus == _o.vipToKeepYearlyStatus &&
		lastMonthForYearly == _o.lastMonthForYearly &&
		missableMonthsYearly == _o.missableMonthsYearly;
}

const char *Lobby::cli::RawVIPLevel::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("statusId=");
	_buf.appendUint(statusId);
	_buf.append(',');
	_buf.append("type=");
	_buf.appendUint(type);
	_buf.append(',');
	_buf.append("minFpp=");
	_buf.appendUint(minFpp);
	_buf.append(',');
	_buf.append("fppBonusRate=");
	_buf.appendUint(fppBonusRate);
	_buf.append(',');
	_buf.append("vipToKeepYearlyStatus=");
	_buf.appendUint(vipToKeepYearlyStatus);
	_buf.append(',');
	_buf.append("lastMonthForYearly=");
	_buf.appendUint(lastMonthForYearly);
	_buf.append(',');
	_buf.append("missableMonthsYearly=");
	_buf.appendUint(missableMonthsYearly);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::RawVIPLevel::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	_msg0.composeUINT32(statusId);
	_msg0.composeUINT32(type);
	_msg0.composeUINT32(minFpp);
	_msg0.composeUINT32(fppBonusRate);
	_msg0.composeUINT32(vipToKeepYearlyStatus);
	_msg0.composeUINT32(lastMonthForYearly);
	_msg0.composeUINT32(missableMonthsYearly);
	_msg.composeMsgBody(_msg0);
}

void Lobby::cli::RawVIPLevel::parseMsg(CommMsgParser& _parser)
{
	parseAnonymousMsgBody0(_parser);
}

/*static*/ void Lobby::cli::RawVIPLevel::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
}

void Lobby::cli::RawVIPLevel::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(statusId);
	_parser0.parseUINT32(type);
	_parser0.parseUINT32(minFpp);
	_parser0.parseUINT32(fppBonusRate);
	_parser0.parseUINT32(vipToKeepYearlyStatus);
	_parser0.parseUINT32(lastMonthForYearly);
	_parser0.parseUINT32(missableMonthsYearly);
}

/*static*/ void Lobby::cli::RawVIPLevel::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 statusId; _parser0.parseUINT32(statusId);
	AtfValidator::validateInt(_descr, "statusId", statusId, _checker, __FILE__, __LINE__);
	UINT32 type; _parser0.parseUINT32(type);
	AtfValidator::validateInt(_descr, "type", type, _checker, __FILE__, __LINE__);
	UINT32 minFpp; _parser0.parseUINT32(minFpp);
	AtfValidator::validateInt(_descr, "minFpp", minFpp, _checker, __FILE__, __LINE__);
	UINT32 fppBonusRate; _parser0.parseUINT32(fppBonusRate);
	AtfValidator::validateInt(_descr, "fppBonusRate", fppBonusRate, _checker, __FILE__, __LINE__);
	UINT32 vipToKeepYearlyStatus; _parser0.parseUINT32(vipToKeepYearlyStatus);
	AtfValidator::validateInt(_descr, "vipToKeepYearlyStatus", vipToKeepYearlyStatus, _checker, __FILE__, __LINE__);
	UINT32 lastMonthForYearly; _parser0.parseUINT32(lastMonthForYearly);
	AtfValidator::validateInt(_descr, "lastMonthForYearly", lastMonthForYearly, _checker, __FILE__, __LINE__);
	UINT32 missableMonthsYearly; _parser0.parseUINT32(missableMonthsYearly);
	AtfValidator::validateInt(_descr, "missableMonthsYearly", missableMonthsYearly, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CountryData
//=================================================================

Lobby::cli::CountryData::CountryData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::CountryData::CountryData(CountryData&& _o)
	: country(std::move(_o.country))
	, prefixes(std::move(_o.prefixes))
{
}

Lobby::cli::CountryData& Lobby::cli::CountryData::operator=(CountryData&& _o)
{
	if(this != &_o)
	{
		country = std::move(_o.country);
		prefixes = std::move(_o.prefixes);
	}
	return *this;
}

#endif

void Lobby::cli::CountryData::clear()
{
	country.clear();
	prefixes.clear();
}

bool Lobby::cli::CountryData::equals(const CountryData& _o) const
{
	return country.equals(_o.country) &&
		prefixes.equals(_o.prefixes);
}

const char *Lobby::cli::CountryData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("prefixes=");
	prefixes.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::CountryData::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(country);
	prefixes.composeMsg(_msg);
}

void Lobby::cli::CountryData::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(country);
	prefixes.parseMsg(_parser);
}

/*static*/ void Lobby::cli::CountryData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szPrefixes = ThinAtf::LAtfVector< PString, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("prefixes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "prefixes", szPrefixes, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    CountriesMsgBody
//=================================================================

Lobby::cli::CountriesMsgBody::CountriesMsgBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::CountriesMsgBody::CountriesMsgBody(CountriesMsgBody&& _o)
	: countries(std::move(_o.countries))
{
}

Lobby::cli::CountriesMsgBody& Lobby::cli::CountriesMsgBody::operator=(CountriesMsgBody&& _o)
{
	if(this != &_o)
	{
		countries = std::move(_o.countries);
	}
	return *this;
}

#endif

void Lobby::cli::CountriesMsgBody::clear()
{
	countries.clear();
}

bool Lobby::cli::CountriesMsgBody::equals(const CountriesMsgBody& _o) const
{
	return countries.equals(_o.countries);
}

const char *Lobby::cli::CountriesMsgBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("countries=");
	countries.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::CountriesMsgBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CountriesMsgBody())) // not empty
	{
		countries.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::cli::CountriesMsgBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	countries.parseMsg(_parser0);
}

/*static*/ void Lobby::cli::CountriesMsgBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szCountries = ThinAtf::LAtfVector< CountryData, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("countries"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "countries", szCountries, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ClientFeatureVisibility
//=================================================================

Lobby::cli::ClientFeatureVisibility::ClientFeatureVisibility()
{
	clear();
}

void Lobby::cli::ClientFeatureVisibility::clear()
{
	clientFeatureVisibilityOnMask = 0;
	clientFeatureVisibilityOffMask = 0;
	clientFeatureVisibilityOnMask2 = 0;
	clientFeatureVisibilityOffMask2 = 0;
}

bool Lobby::cli::ClientFeatureVisibility::equals(const ClientFeatureVisibility& _o) const
{
	return clientFeatureVisibilityOnMask == _o.clientFeatureVisibilityOnMask &&
		clientFeatureVisibilityOffMask == _o.clientFeatureVisibilityOffMask &&
		clientFeatureVisibilityOnMask2 == _o.clientFeatureVisibilityOnMask2 &&
		clientFeatureVisibilityOffMask2 == _o.clientFeatureVisibilityOffMask2;
}

const char *Lobby::cli::ClientFeatureVisibility::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("clientFeatureVisibilityOnMask=");
	_buf.appendUint64(clientFeatureVisibilityOnMask);
	_buf.append(',');
	_buf.append("clientFeatureVisibilityOffMask=");
	_buf.appendUint64(clientFeatureVisibilityOffMask);
	_buf.append(',');
	_buf.append("clientFeatureVisibilityOnMask2=");
	_buf.appendUint64(clientFeatureVisibilityOnMask2);
	_buf.append(',');
	_buf.append("clientFeatureVisibilityOffMask2=");
	_buf.appendUint64(clientFeatureVisibilityOffMask2);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::ClientFeatureVisibility::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(ClientFeatureVisibility())) // not empty
	{
		_body.composeUINT64(clientFeatureVisibilityOnMask);
		_body.composeUINT64(clientFeatureVisibilityOffMask);
		_body.composeUINT64(clientFeatureVisibilityOnMask2);
		_body.composeUINT64(clientFeatureVisibilityOffMask2);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::cli::ClientFeatureVisibility::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT64(clientFeatureVisibilityOnMask);
	_parser0.parseUINT64(clientFeatureVisibilityOffMask);
	_parser0.parseUINT64(clientFeatureVisibilityOnMask2);
	_parser0.parseUINT64(clientFeatureVisibilityOffMask2);
}

/*static*/ void Lobby::cli::ClientFeatureVisibility::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT64 clientFeatureVisibilityOnMask; _parser0.parseUINT64(clientFeatureVisibilityOnMask);
	AtfValidator::validateUint(_descr, "clientFeatureVisibilityOnMask", clientFeatureVisibilityOnMask, _checker, __FILE__, __LINE__);
	UINT64 clientFeatureVisibilityOffMask; _parser0.parseUINT64(clientFeatureVisibilityOffMask);
	AtfValidator::validateUint(_descr, "clientFeatureVisibilityOffMask", clientFeatureVisibilityOffMask, _checker, __FILE__, __LINE__);
	UINT64 clientFeatureVisibilityOnMask2; _parser0.parseUINT64(clientFeatureVisibilityOnMask2);
	AtfValidator::validateUint(_descr, "clientFeatureVisibilityOnMask2", clientFeatureVisibilityOnMask2, _checker, __FILE__, __LINE__);
	UINT64 clientFeatureVisibilityOffMask2; _parser0.parseUINT64(clientFeatureVisibilityOffMask2);
	AtfValidator::validateUint(_descr, "clientFeatureVisibilityOffMask2", clientFeatureVisibilityOffMask2, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    HallOfFameLevel
//=================================================================

Lobby::cli::HallOfFameLevel::HallOfFameLevel()
{
	clear();
}

void Lobby::cli::HallOfFameLevel::clear()
{
	levelId = 0;
	ltVppThreshold = 0;
	flags = 0;
}

bool Lobby::cli::HallOfFameLevel::equals(const HallOfFameLevel& _o) const
{
	return levelId == _o.levelId &&
		ltVppThreshold == _o.ltVppThreshold &&
		flags == _o.flags;
}

const char *Lobby::cli::HallOfFameLevel::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("levelId=");
	_buf.appendUint(levelId);
	_buf.append(',');
	_buf.append("ltVppThreshold=");
	_buf.appendUint(ltVppThreshold);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::HallOfFameLevel::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(levelId);
	_msg.composeUINT32(ltVppThreshold);
	_msg.composeBYTE(flags);
}

void Lobby::cli::HallOfFameLevel::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(levelId);
	_parser.parseUINT32(ltVppThreshold);
	_parser.parseBYTE(flags);
}

/*static*/ void Lobby::cli::HallOfFameLevel::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 levelId; _parser.parseUINT32(levelId);
	AtfValidator::validateInt(_descr, "levelId", levelId, _checker, __FILE__, __LINE__);
	UINT32 ltVppThreshold; _parser.parseUINT32(ltVppThreshold);
	AtfValidator::validateInt(_descr, "ltVppThreshold", ltVppThreshold, _checker, __FILE__, __LINE__);
	BYTE flags; _parser.parseBYTE(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    HallOfFameLevels
//=================================================================

Lobby::cli::HallOfFameLevels::HallOfFameLevels()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::HallOfFameLevels::HallOfFameLevels(HallOfFameLevels&& _o)
	: levels(std::move(_o.levels))
{
}

Lobby::cli::HallOfFameLevels& Lobby::cli::HallOfFameLevels::operator=(HallOfFameLevels&& _o)
{
	if(this != &_o)
	{
		levels = std::move(_o.levels);
	}
	return *this;
}

#endif

void Lobby::cli::HallOfFameLevels::clear()
{
	levels.clear();
}

bool Lobby::cli::HallOfFameLevels::equals(const HallOfFameLevels& _o) const
{
	return levels.equals(_o.levels);
}

const char *Lobby::cli::HallOfFameLevels::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("levels=");
	levels.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::HallOfFameLevels::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(HallOfFameLevels())) // not empty
	{
		levels.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::cli::HallOfFameLevels::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	levels.parseMsg(_parser0);
}

/*static*/ void Lobby::cli::HallOfFameLevels::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szLevels = ThinAtf::LAtfVector< HallOfFameLevel, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("levels"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "levels", szLevels, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBY_USER_PROPS_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS_REPLY::Protocol_MSG_LOBBY_USER_PROPS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS_REPLY::Protocol_MSG_LOBBY_USER_PROPS_REPLY(Protocol_MSG_LOBBY_USER_PROPS_REPLY&& _o)
	: privs(std::move(_o.privs))
	, flags(std::move(_o.flags))
	, locale(std::move(_o.locale))
	, country(std::move(_o.country))
	, emLocale(std::move(_o.emLocale))
	, privs2(std::move(_o.privs2))
	, vipStatus(std::move(_o.vipStatus))
	, timeZone(std::move(_o.timeZone))
	, origUserIntId(std::move(_o.origUserIntId))
	, userIntId(std::move(_o.userIntId))
	, flags2(std::move(_o.flags2))
	, vppCounter1(std::move(_o.vppCounter1))
	, vppCounter2(std::move(_o.vppCounter2))
	, stellarBonuses(std::move(_o.stellarBonuses))
	, uiStatsAllowed(std::move(_o.uiStatsAllowed))
	, rmTransersAllowed(std::move(_o.rmTransersAllowed))
	, obsolete(std::move(_o.obsolete))
	, findSimilarTableFlag(std::move(_o.findSimilarTableFlag))
	, milestoneBonusesOld(std::move(_o.milestoneBonusesOld))
	, vipLevels(std::move(_o.vipLevels))
	, hgEnabled(std::move(_o.hgEnabled))
	, cppCountr3(std::move(_o.cppCountr3))
	, fastDepositEnabled(std::move(_o.fastDepositEnabled))
	, countries(std::move(_o.countries))
	, handSharingEnabledForSiteAndBrand(std::move(_o.handSharingEnabledForSiteAndBrand))
	, itAccVerificationOpen(std::move(_o.itAccVerificationOpen))
	, allowSmsValidationForNewInstallId(std::move(_o.allowSmsValidationForNewInstallId))
	, userWebId(std::move(_o.userWebId))
	, rawVIPLevels(std::move(_o.rawVIPLevels))
	, chatModeratorRestrictions(std::move(_o.chatModeratorRestrictions))
	, milestoneBonusesNew(std::move(_o.milestoneBonusesNew))
	, allowSmsPwdReset(std::move(_o.allowSmsPwdReset))
	, hallOfFameLevels(std::move(_o.hallOfFameLevels))
	, lifetimeFpp(std::move(_o.lifetimeFpp))
	, otherFlags(std::move(_o.otherFlags))
	, clientFeatureVisibility(std::move(_o.clientFeatureVisibility))
	, privs3(std::move(_o.privs3))
	, registered(std::move(_o.registered))
	, state(std::move(_o.state))
	, licenseId(std::move(_o.licenseId))
{
}

Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS_REPLY& Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS_REPLY::operator=(Protocol_MSG_LOBBY_USER_PROPS_REPLY&& _o)
{
	if(this != &_o)
	{
		privs = std::move(_o.privs);
		flags = std::move(_o.flags);
		locale = std::move(_o.locale);
		country = std::move(_o.country);
		emLocale = std::move(_o.emLocale);
		privs2 = std::move(_o.privs2);
		vipStatus = std::move(_o.vipStatus);
		timeZone = std::move(_o.timeZone);
		origUserIntId = std::move(_o.origUserIntId);
		userIntId = std::move(_o.userIntId);
		flags2 = std::move(_o.flags2);
		vppCounter1 = std::move(_o.vppCounter1);
		vppCounter2 = std::move(_o.vppCounter2);
		stellarBonuses = std::move(_o.stellarBonuses);
		uiStatsAllowed = std::move(_o.uiStatsAllowed);
		rmTransersAllowed = std::move(_o.rmTransersAllowed);
		obsolete = std::move(_o.obsolete);
		findSimilarTableFlag = std::move(_o.findSimilarTableFlag);
		milestoneBonusesOld = std::move(_o.milestoneBonusesOld);
		vipLevels = std::move(_o.vipLevels);
		hgEnabled = std::move(_o.hgEnabled);
		cppCountr3 = std::move(_o.cppCountr3);
		fastDepositEnabled = std::move(_o.fastDepositEnabled);
		countries = std::move(_o.countries);
		handSharingEnabledForSiteAndBrand = std::move(_o.handSharingEnabledForSiteAndBrand);
		itAccVerificationOpen = std::move(_o.itAccVerificationOpen);
		allowSmsValidationForNewInstallId = std::move(_o.allowSmsValidationForNewInstallId);
		userWebId = std::move(_o.userWebId);
		rawVIPLevels = std::move(_o.rawVIPLevels);
		chatModeratorRestrictions = std::move(_o.chatModeratorRestrictions);
		milestoneBonusesNew = std::move(_o.milestoneBonusesNew);
		allowSmsPwdReset = std::move(_o.allowSmsPwdReset);
		hallOfFameLevels = std::move(_o.hallOfFameLevels);
		lifetimeFpp = std::move(_o.lifetimeFpp);
		otherFlags = std::move(_o.otherFlags);
		clientFeatureVisibility = std::move(_o.clientFeatureVisibility);
		privs3 = std::move(_o.privs3);
		registered = std::move(_o.registered);
		state = std::move(_o.state);
		licenseId = std::move(_o.licenseId);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS_REPLY::clear()
{
	privs = 0;
	flags = 0;
	locale = 0;
	country.clear();
	emLocale = 0;
	privs2 = 0;
	vipStatus = 0;
	timeZone = 0;
	origUserIntId = 0;
	userIntId = 0;
	flags2 = 0;
	vppCounter1 = 0;
	vppCounter2 = 0;
	stellarBonuses.clear();
	uiStatsAllowed = false;
	rmTransersAllowed = false;
	obsolete = 0;
	findSimilarTableFlag = 0;
	milestoneBonusesOld.clear();
	vipLevels.clear();
	hgEnabled = false;
	cppCountr3 = 0;
	fastDepositEnabled = false;
	countries.clear();
	handSharingEnabledForSiteAndBrand = false;
	itAccVerificationOpen = false;
	allowSmsValidationForNewInstallId = false;
	userWebId.clear();
	rawVIPLevels.clear();
	chatModeratorRestrictions = 0;
	milestoneBonusesNew.clear();
	allowSmsPwdReset = false;
	hallOfFameLevels.clear();
	lifetimeFpp = 0;
	otherFlags = 0;
	clientFeatureVisibility.clear();
	privs3 = 0;
	registered.setNull();
	state.clear();
	licenseId = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS_REPLY::equals(const Protocol_MSG_LOBBY_USER_PROPS_REPLY& _o) const
{
	return privs == _o.privs &&
		flags == _o.flags &&
		locale == _o.locale &&
		country.equals(_o.country) &&
		emLocale == _o.emLocale &&
		privs2 == _o.privs2 &&
		vipStatus == _o.vipStatus &&
		timeZone == _o.timeZone &&
		origUserIntId == _o.origUserIntId &&
		userIntId == _o.userIntId &&
		flags2 == _o.flags2 &&
		vppCounter1 == _o.vppCounter1 &&
		vppCounter2 == _o.vppCounter2 &&
		stellarBonuses.equals(_o.stellarBonuses) &&
		uiStatsAllowed == _o.uiStatsAllowed &&
		rmTransersAllowed == _o.rmTransersAllowed &&
		obsolete == _o.obsolete &&
		findSimilarTableFlag == _o.findSimilarTableFlag &&
		milestoneBonusesOld.equals(_o.milestoneBonusesOld) &&
		vipLevels.equals(_o.vipLevels) &&
		hgEnabled == _o.hgEnabled &&
		cppCountr3 == _o.cppCountr3 &&
		fastDepositEnabled == _o.fastDepositEnabled &&
		countries.equals(_o.countries) &&
		handSharingEnabledForSiteAndBrand == _o.handSharingEnabledForSiteAndBrand &&
		itAccVerificationOpen == _o.itAccVerificationOpen &&
		allowSmsValidationForNewInstallId == _o.allowSmsValidationForNewInstallId &&
		userWebId.equals(_o.userWebId) &&
		rawVIPLevels.equals(_o.rawVIPLevels) &&
		chatModeratorRestrictions == _o.chatModeratorRestrictions &&
		milestoneBonusesNew.equals(_o.milestoneBonusesNew) &&
		allowSmsPwdReset == _o.allowSmsPwdReset &&
		hallOfFameLevels.equals(_o.hallOfFameLevels) &&
		lifetimeFpp == _o.lifetimeFpp &&
		otherFlags == _o.otherFlags &&
		clientFeatureVisibility.equals(_o.clientFeatureVisibility) &&
		privs3 == _o.privs3 &&
		registered.equals(_o.registered) &&
		state.equals(_o.state) &&
		licenseId == _o.licenseId;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_USER_PROPS_REPLY).append(")");
	_buf.append(',');
	_buf.append("privs=");
	_buf.appendUint(privs);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("emLocale=");
	_buf.appendUint(emLocale);
	_buf.append(',');
	_buf.append("privs2=");
	_buf.appendUint64(privs2);
	_buf.append(',');
	_buf.append("vipStatus=");
	_buf.appendUint(vipStatus);
	_buf.append(',');
	_buf.append("timeZone=");
	_buf.appendUint(timeZone);
	_buf.append(',');
	_buf.append("origUserIntId=");
	_buf.appendUint(origUserIntId);
	_buf.append(',');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	_buf.append(',');
	_buf.append("flags2=");
	_buf.appendUint64(flags2);
	_buf.append(',');
	_buf.append("vppCounter1=");
	_buf.appendUint(vppCounter1);
	_buf.append(',');
	_buf.append("vppCounter2=");
	_buf.appendUint(vppCounter2);
	_buf.append(',');
	_buf.append("stellarBonuses=");
	stellarBonuses.toTraceString(_buf);
	_buf.append(',');
	_buf.append("uiStatsAllowed=");
	_buf.appendUint(uiStatsAllowed);
	_buf.append(',');
	_buf.append("rmTransersAllowed=");
	_buf.appendUint(rmTransersAllowed);
	_buf.append(',');
	_buf.append("obsolete=");
	_buf.appendUint(obsolete);
	_buf.append(',');
	_buf.append("findSimilarTableFlag=");
	_buf.appendUint(findSimilarTableFlag);
	_buf.append(',');
	_buf.append("milestoneBonusesOld=");
	milestoneBonusesOld.toTraceString(_buf);
	_buf.append(',');
	_buf.append("vipLevels=");
	vipLevels.toTraceString(_buf);
	_buf.append(',');
	_buf.append("hgEnabled=");
	_buf.appendUint(hgEnabled);
	_buf.append(',');
	_buf.append("cppCountr3=");
	_buf.appendUint(cppCountr3);
	_buf.append(',');
	_buf.append("fastDepositEnabled=");
	_buf.appendUint(fastDepositEnabled);
	_buf.append(',');
	_buf.append("countries=");
	countries.toTraceString(_buf);
	_buf.append(',');
	_buf.append("handSharingEnabledForSiteAndBrand=");
	_buf.appendUint(handSharingEnabledForSiteAndBrand);
	_buf.append(',');
	_buf.append("itAccVerificationOpen=");
	_buf.appendUint(itAccVerificationOpen);
	_buf.append(',');
	_buf.append("allowSmsValidationForNewInstallId=");
	_buf.appendUint(allowSmsValidationForNewInstallId);
	_buf.append(',');
	_buf.append("userWebId=");
	_buf.append(userWebId);
	_buf.append(',');
	_buf.append("rawVIPLevels=");
	rawVIPLevels.toTraceString(_buf);
	_buf.append(',');
	_buf.append("chatModeratorRestrictions=");
	_buf.appendUint(chatModeratorRestrictions);
	_buf.append(',');
	_buf.append("milestoneBonusesNew=");
	milestoneBonusesNew.toTraceString(_buf);
	_buf.append(',');
	_buf.append("allowSmsPwdReset=");
	_buf.appendUint(allowSmsPwdReset);
	_buf.append(',');
	_buf.append("hallOfFameLevels=");
	hallOfFameLevels.toTraceString(_buf);
	_buf.append(',');
	_buf.append("lifetimeFpp=");
	_buf.appendUint(lifetimeFpp);
	_buf.append(',');
	_buf.append("otherFlags=");
	_buf.appendUint(otherFlags);
	_buf.append(',');
	_buf.append("clientFeatureVisibility=");
	clientFeatureVisibility.toTraceString(_buf);
	_buf.append(',');
	_buf.append("privs3=");
	_buf.appendUint64(privs3);
	_buf.append(',');
	_buf.append("registered=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, registered);
	_buf.append(',');
	_buf.append("state=");
	_buf.append(state);
	_buf.append(',');
	_buf.append("licenseId=");
	_buf.appendUint(licenseId);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(privs);
	_msg.composeUINT32(flags);
	_msg.composeUINT32(locale);
	_msg.composeString(country);
	_msg.composeUINT32(emLocale);
	_msg.composeUINT64(privs2);
	_msg.composeUINT32(vipStatus);
	_msg.composeUINT32(timeZone);
	_msg.composeUINT32(origUserIntId);
	_msg.composeUINT32(userIntId);
	_msg.composeUINT64(flags2);
	_msg.composeUINT32(vppCounter1);
	_msg.composeUINT32(vppCounter2);
	stellarBonuses.composeMsg(_msg);
	_msg.composeBOOL(uiStatsAllowed);
	_msg.composeBOOL(rmTransersAllowed);
	_msg.composeUINT32(obsolete);
	_msg.composeBYTE(findSimilarTableFlag);
	milestoneBonusesOld.composeMsg(_msg);
	vipLevels.composeMsg(_msg);
	_msg.composeBOOL(hgEnabled);
	_msg.composeUINT32(cppCountr3);
	_msg.composeBOOL(fastDepositEnabled);
	countries.composeMsg(_msg);
	_msg.composeBOOL(handSharingEnabledForSiteAndBrand);
	_msg.composeBOOL(itAccVerificationOpen);
	_msg.composeBOOL(allowSmsValidationForNewInstallId);
	_msg.composeString(userWebId);
	rawVIPLevels.composeMsg(_msg);
	_msg.composeUINT32(chatModeratorRestrictions);
	milestoneBonusesNew.composeMsg(_msg);
	_msg.composeBOOL(allowSmsPwdReset);
	hallOfFameLevels.composeMsg(_msg);
	_msg.composeUINT32(lifetimeFpp);
	_msg.composeUINT32(otherFlags);
	clientFeatureVisibility.composeMsg(_msg);
	_msg.composeUINT64(privs3);
	_msg.composeSrvTime(registered);
	_msg.composeString(state);
	_msg.composeUINT32(licenseId);
}

void Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(privs);
	_parser.parseUINT32(flags);
	_parser.parseUINT32(locale);
	_parser.parseStringP(country);
	_parser.parseUINT32(emLocale);
	_parser.parseUINT64(privs2);
	_parser.parseUINT32(vipStatus);
	_parser.parseUINT32(timeZone);
	_parser.parseUINT32(origUserIntId);
	_parser.parseUINT32(userIntId);
	_parser.parseUINT64(flags2);
	_parser.parseUINT32(vppCounter1);
	_parser.parseUINT32(vppCounter2);
	stellarBonuses.parseMsg(_parser);
	_parser.parseBOOL(uiStatsAllowed);
	_parser.parseBOOL(rmTransersAllowed);
	_parser.parseUINT32(obsolete);
	_parser.parseBYTE(findSimilarTableFlag);
	milestoneBonusesOld.parseMsg(_parser);
	vipLevels.parseMsg(_parser);
	_parser.parseBOOL(hgEnabled);
	_parser.parseUINT32(cppCountr3);
	_parser.parseBOOL(fastDepositEnabled);
	countries.parseMsg(_parser);
	_parser.parseBOOL(handSharingEnabledForSiteAndBrand);
	_parser.parseBOOL(itAccVerificationOpen);
	_parser.parseBOOL(allowSmsValidationForNewInstallId);
	_parser.parseStringP(userWebId);
	rawVIPLevels.parseMsg(_parser);
	_parser.parseUINT32(chatModeratorRestrictions);
	milestoneBonusesNew.parseMsg(_parser);
	_parser.parseBOOL(allowSmsPwdReset);
	hallOfFameLevels.parseMsg(_parser);
	_parser.parseUINT32(lifetimeFpp);
	_parser.parseUINT32(otherFlags);
	clientFeatureVisibility.parseMsg(_parser);
	_parser.parseUINT64(privs3);
	_parser.parseSrvTime(registered);
	_parser.parseStringP(state);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(licenseId);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_USER_PROPS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 privs; _parser.parseUINT32(privs);
	AtfValidator::validateInt(_descr, "privs", privs, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateInt(_descr, "locale", locale, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	UINT32 emLocale; _parser.parseUINT32(emLocale);
	AtfValidator::validateInt(_descr, "emLocale", emLocale, _checker, __FILE__, __LINE__);
	UINT64 privs2; _parser.parseUINT64(privs2);
	AtfValidator::validateUint(_descr, "privs2", privs2, _checker, __FILE__, __LINE__);
	UINT32 vipStatus; _parser.parseUINT32(vipStatus);
	AtfValidator::validateInt(_descr, "vipStatus", vipStatus, _checker, __FILE__, __LINE__);
	UINT32 timeZone; _parser.parseUINT32(timeZone);
	AtfValidator::validateInt(_descr, "timeZone", timeZone, _checker, __FILE__, __LINE__);
	UINT32 origUserIntId; _parser.parseUINT32(origUserIntId);
	AtfValidator::validateInt(_descr, "origUserIntId", origUserIntId, _checker, __FILE__, __LINE__);
	UINT32 userIntId; _parser.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	UINT64 flags2; _parser.parseUINT64(flags2);
	AtfValidator::validateUint(_descr, "flags2", flags2, _checker, __FILE__, __LINE__);
	UINT32 vppCounter1; _parser.parseUINT32(vppCounter1);
	AtfValidator::validateInt(_descr, "vppCounter1", vppCounter1, _checker, __FILE__, __LINE__);
	UINT32 vppCounter2; _parser.parseUINT32(vppCounter2);
	AtfValidator::validateInt(_descr, "vppCounter2", vppCounter2, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szStellarBonuses = ThinAtf::LAtfVector< StellarBonus, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("stellarBonuses"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "stellarBonuses", szStellarBonuses, _checker, __FILE__, __LINE__);
	bool uiStatsAllowed; _parser.parseBOOL(uiStatsAllowed);
	AtfValidator::validateInt(_descr, "uiStatsAllowed", uiStatsAllowed, _checker, __FILE__, __LINE__);
	bool rmTransersAllowed; _parser.parseBOOL(rmTransersAllowed);
	AtfValidator::validateInt(_descr, "rmTransersAllowed", rmTransersAllowed, _checker, __FILE__, __LINE__);
	UINT32 obsolete; _parser.parseUINT32(obsolete);
	AtfValidator::validateInt(_descr, "obsolete", obsolete, _checker, __FILE__, __LINE__);
	BYTE findSimilarTableFlag; _parser.parseBYTE(findSimilarTableFlag);
	AtfValidator::validateInt(_descr, "findSimilarTableFlag", findSimilarTableFlag, _checker, __FILE__, __LINE__);
	int szMilestoneBonusesOld = ThinAtf::LAtfVector< MilestoneBonusOld, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("milestoneBonusesOld"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "milestoneBonusesOld", szMilestoneBonusesOld, _checker, __FILE__, __LINE__);
	int szVipLevels = ThinAtf::LAtfVector< VIPLevel, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("vipLevels"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "vipLevels", szVipLevels, _checker, __FILE__, __LINE__);
	bool hgEnabled; _parser.parseBOOL(hgEnabled);
	AtfValidator::validateInt(_descr, "hgEnabled", hgEnabled, _checker, __FILE__, __LINE__);
	UINT32 cppCountr3; _parser.parseUINT32(cppCountr3);
	AtfValidator::validateInt(_descr, "cppCountr3", cppCountr3, _checker, __FILE__, __LINE__);
	bool fastDepositEnabled; _parser.parseBOOL(fastDepositEnabled);
	AtfValidator::validateInt(_descr, "fastDepositEnabled", fastDepositEnabled, _checker, __FILE__, __LINE__);
	CountriesMsgBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("countries"), _fieldsWithUnparsedContent);
	bool handSharingEnabledForSiteAndBrand; _parser.parseBOOL(handSharingEnabledForSiteAndBrand);
	AtfValidator::validateInt(_descr, "handSharingEnabledForSiteAndBrand", handSharingEnabledForSiteAndBrand, _checker, __FILE__, __LINE__);
	bool itAccVerificationOpen; _parser.parseBOOL(itAccVerificationOpen);
	AtfValidator::validateInt(_descr, "itAccVerificationOpen", itAccVerificationOpen, _checker, __FILE__, __LINE__);
	bool allowSmsValidationForNewInstallId; _parser.parseBOOL(allowSmsValidationForNewInstallId);
	AtfValidator::validateInt(_descr, "allowSmsValidationForNewInstallId", allowSmsValidationForNewInstallId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userWebId"); size_t szUserWebId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userWebId", szUserWebId, _checker, __FILE__, __LINE__);
	int szRawVIPLevels = ThinAtf::LAtfVector< RawVIPLevel, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("rawVIPLevels"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "rawVIPLevels", szRawVIPLevels, _checker, __FILE__, __LINE__);
	UINT32 chatModeratorRestrictions; _parser.parseUINT32(chatModeratorRestrictions);
	AtfValidator::validateInt(_descr, "chatModeratorRestrictions", chatModeratorRestrictions, _checker, __FILE__, __LINE__);
	int szMilestoneBonusesNew = ThinAtf::LAtfVector< MilestoneBonusNew, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("milestoneBonusesNew"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "milestoneBonusesNew", szMilestoneBonusesNew, _checker, __FILE__, __LINE__);
	bool allowSmsPwdReset; _parser.parseBOOL(allowSmsPwdReset);
	AtfValidator::validateInt(_descr, "allowSmsPwdReset", allowSmsPwdReset, _checker, __FILE__, __LINE__);
	HallOfFameLevels::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("hallOfFameLevels"), _fieldsWithUnparsedContent);
	UINT32 lifetimeFpp; _parser.parseUINT32(lifetimeFpp);
	AtfValidator::validateInt(_descr, "lifetimeFpp", lifetimeFpp, _checker, __FILE__, __LINE__);
	UINT32 otherFlags; _parser.parseUINT32(otherFlags);
	AtfValidator::validateInt(_descr, "otherFlags", otherFlags, _checker, __FILE__, __LINE__);
	ClientFeatureVisibility::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientFeatureVisibility"), _fieldsWithUnparsedContent);
	UINT64 privs3; _parser.parseUINT64(privs3);
	AtfValidator::validateUint(_descr, "privs3", privs3, _checker, __FILE__, __LINE__);
	SrvTime registered; _parser.parseSrvTime(registered);
	AtfValidator::validateSrvDateTime(_descr, "registered", registered, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "state"); size_t szState = strlen(_dummy);
	AtfValidator::validateInt(_descr, "state", szState, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 licenseId; _parser.parseUINT32(licenseId);
	AtfValidator::validateInt(_descr, "licenseId", licenseId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    TournInfo
//=================================================================

Lobby::cli::TournInfo::TournInfo()
{
	clear();
}

void Lobby::cli::TournInfo::clear()
{
	startTime.setNull();
	tournId = 0;
	buyIn = 0;
	fppBuyIn = 0;
	rake = 0;
	game = 0;
	isHiLo = 0;
	structure = 0;
	isPlayMoney = 0;
	isSitAndGo = 0;
	isRunning = 0;
}

bool Lobby::cli::TournInfo::equals(const TournInfo& _o) const
{
	return startTime.equals(_o.startTime) &&
		tournId == _o.tournId &&
		buyIn == _o.buyIn &&
		fppBuyIn == _o.fppBuyIn &&
		rake == _o.rake &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		structure == _o.structure &&
		isPlayMoney == _o.isPlayMoney &&
		isSitAndGo == _o.isSitAndGo &&
		isRunning == _o.isRunning;
}

const char *Lobby::cli::TournInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("startTime=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, startTime);
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendUint(buyIn);
	_buf.append(',');
	_buf.append("fppBuyIn=");
	_buf.appendUint(fppBuyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendUint(rake);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("isSitAndGo=");
	_buf.appendUint(isSitAndGo);
	_buf.append(',');
	_buf.append("isRunning=");
	_buf.appendUint(isRunning);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::TournInfo::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeSrvTime(startTime);
	_msg.composeUINT32(tournId);
	_msg.composeUINT32(buyIn);
	_msg.composeUINT32(fppBuyIn);
	_msg.composeUINT32(rake);
	_msg.composeBYTE(game);
	_msg.composeBYTE(isHiLo);
	_msg.composeBYTE(structure);
	_msg.composeBYTE(isPlayMoney);
	_msg.composeBYTE(isSitAndGo);
	_msg.composeBYTE(isRunning);
}

void Lobby::cli::TournInfo::parseMsg(CommMsgParser& _parser)
{
	_parser.parseSrvTime(startTime);
	_parser.parseUINT32(tournId);
	_parser.parseUINT32(buyIn);
	_parser.parseUINT32(fppBuyIn);
	_parser.parseUINT32(rake);
	_parser.parseBYTE(game);
	_parser.parseBYTE(isHiLo);
	_parser.parseBYTE(structure);
	_parser.parseBYTE(isPlayMoney);
	_parser.parseBYTE(isSitAndGo);
	_parser.parseBYTE(isRunning);
}

/*static*/ void Lobby::cli::TournInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	SrvTime startTime; _parser.parseSrvTime(startTime);
	AtfValidator::validateSrvDateTime(_descr, "startTime", startTime, _checker, __FILE__, __LINE__);
	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	UINT32 buyIn; _parser.parseUINT32(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT32 fppBuyIn; _parser.parseUINT32(fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	UINT32 rake; _parser.parseUINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	BYTE isSitAndGo; _parser.parseBYTE(isSitAndGo);
	AtfValidator::validateInt(_descr, "isSitAndGo", isSitAndGo, _checker, __FILE__, __LINE__);
	BYTE isRunning; _parser.parseBYTE(isRunning);
	AtfValidator::validateInt(_descr, "isRunning", isRunning, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_TOURN_REG
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG::Protocol_MSG_LOBBY_FIND_TOURN_REG()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG::Protocol_MSG_LOBBY_FIND_TOURN_REG(Protocol_MSG_LOBBY_FIND_TOURN_REG&& _o)
	: notUsed(std::move(_o.notUsed))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG& Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG::operator=(Protocol_MSG_LOBBY_FIND_TOURN_REG&& _o)
{
	if(this != &_o)
	{
		notUsed = std::move(_o.notUsed);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG::clear()
{
	notUsed.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG::equals(const Protocol_MSG_LOBBY_FIND_TOURN_REG& _o) const
{
	return notUsed.equals(_o.notUsed);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_TOURN_REG).append(")");
	_buf.append(',');
	_buf.append("notUsed=");
	_buf.append(notUsed);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(notUsed);
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsed);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TOURN_REG";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsed"); size_t szNotUsed = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsed", szNotUsed, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY::Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY::Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY(Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, tournInfo(std::move(_o.tournInfo))
	, serverName(std::move(_o.serverName))
	, currency(std::move(_o.currency))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY& Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY::operator=(Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		tournInfo = std::move(_o.tournInfo);
		serverName = std::move(_o.serverName);
		currency = std::move(_o.currency);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY::clear()
{
	errCode = 0;
	tournInfo.clear();
	serverName.clear();
	currency.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY::equals(const Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY& _o) const
{
	return errCode == _o.errCode &&
		tournInfo.equals(_o.tournInfo) &&
		serverName.equals(_o.serverName) &&
		currency.equals(_o.currency);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_TOURN_REG_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("tournInfo=");
	tournInfo.toTraceString(_buf);
	_buf.append(',');
	_buf.append("serverName=");
	serverName.toTraceString(_buf);
	_buf.append(',');
	_buf.append("currency=");
	currency.toTraceString(_buf);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	tournInfo.composeMsg(_msg);
	serverName.composeMsg(_msg);
	currency.composeMsg(_msg);
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	tournInfo.parseMsg(_parser);
	serverName.parseMsg(_parser);
	currency.parseMsg(_parser);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TOURN_REG_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTournInfo = ThinAtf::LAtfVector< TournInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournInfo"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tournInfo", szTournInfo, _checker, __FILE__, __LINE__);
	int szServerName = ThinAtf::LAtfVector< PString, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("serverName"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "serverName", szServerName, _checker, __FILE__, __LINE__);
	int szCurrency = ThinAtf::LAtfVector< PString, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("currency"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    TournInfo2
//=================================================================

Lobby::cli::TournInfo2::TournInfo2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::TournInfo2::TournInfo2(TournInfo2&& _o)
	: tournInfo(std::move(_o.tournInfo))
	, serverAddress(std::move(_o.serverAddress))
	, currency(std::move(_o.currency))
	, clubId(std::move(_o.clubId))
	, scalePm(std::move(_o.scalePm))
	, flags2(std::move(_o.flags2))
{
}

Lobby::cli::TournInfo2& Lobby::cli::TournInfo2::operator=(TournInfo2&& _o)
{
	if(this != &_o)
	{
		tournInfo = std::move(_o.tournInfo);
		serverAddress = std::move(_o.serverAddress);
		currency = std::move(_o.currency);
		clubId = std::move(_o.clubId);
		scalePm = std::move(_o.scalePm);
		flags2 = std::move(_o.flags2);
	}
	return *this;
}

#endif

void Lobby::cli::TournInfo2::clear()
{
	tournInfo.clear();
	serverAddress.clear();
	currency.clear();
	clubId = 0;
	scalePm = 0;
	flags2 = 0;
}

bool Lobby::cli::TournInfo2::equals(const TournInfo2& _o) const
{
	return tournInfo.equals(_o.tournInfo) &&
		serverAddress.equals(_o.serverAddress) &&
		currency.equals(_o.currency) &&
		clubId == _o.clubId &&
		scalePm == _o.scalePm &&
		flags2 == _o.flags2;
}

const char *Lobby::cli::TournInfo2::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournInfo=");
	tournInfo.toTraceString(_buf);
	_buf.append(',');
	_buf.append("serverAddress=");
	_buf.append(serverAddress);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("scalePm=");
	_buf.appendUint(scalePm);
	_buf.append(',');
	_buf.append("flags2=");
	_buf.appendUint64(flags2);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::TournInfo2::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(TournInfo2())) // not empty
	{
		CommMsgBody _body0;
		tournInfo.composeMsg(_body0);
		_body0.composeString(serverAddress);
		_body0.composeString(currency);
		_body0.composeUINT32(clubId);
		_body.composeMsgBody(_body0);
		_body.composeUINT32(scalePm);
		_body.composeUINT64(flags2);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::cli::TournInfo2::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	parseAnonymousMsgBody0(_parser0);
	_parser0.parseUINT32(scalePm);
	_parser0.parseUINT64(flags2);
}

/*static*/ void Lobby::cli::TournInfo2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	validateAnonymousMsgBody0(_parser0, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 scalePm; _parser0.parseUINT32(scalePm);
	AtfValidator::validateInt(_descr, "scalePm", scalePm, _checker, __FILE__, __LINE__);
	UINT64 flags2; _parser0.parseUINT64(flags2);
	AtfValidator::validateUint(_descr, "flags2", flags2, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void Lobby::cli::TournInfo2::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	tournInfo.parseMsg(_parser0);
	_parser0.parseStringP(serverAddress);
	_parser0.parseStringP(currency);
	_parser0.parseUINT32(clubId);
}

/*static*/ void Lobby::cli::TournInfo2::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	PString _descbuf;
	TournInfo::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tournInfo"), _fieldsWithUnparsedContent);
	_parser0.parseStringN(_dummy, 0, "serverAddress"); size_t szServerAddress = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverAddress", szServerAddress, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 clubId; _parser0.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_TOURN_REG2
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2::Protocol_MSG_LOBBY_FIND_TOURN_REG2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2::Protocol_MSG_LOBBY_FIND_TOURN_REG2(Protocol_MSG_LOBBY_FIND_TOURN_REG2&& _o)
	: notUsed(std::move(_o.notUsed))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2& Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2::operator=(Protocol_MSG_LOBBY_FIND_TOURN_REG2&& _o)
{
	if(this != &_o)
	{
		notUsed = std::move(_o.notUsed);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2::clear()
{
	notUsed.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2::equals(const Protocol_MSG_LOBBY_FIND_TOURN_REG2& _o) const
{
	return notUsed.equals(_o.notUsed);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_TOURN_REG2).append(")");
	_buf.append(',');
	_buf.append("notUsed=");
	_buf.append(notUsed);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(notUsed);
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsed);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TOURN_REG2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsed"); size_t szNotUsed = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsed", szNotUsed, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY::Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY::Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY(Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, tournInfo(std::move(_o.tournInfo))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY& Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY::operator=(Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		tournInfo = std::move(_o.tournInfo);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY::clear()
{
	errCode = 0;
	tournInfo.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY::equals(const Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		tournInfo.equals(_o.tournInfo);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_TOURN_REG2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("tournInfo=");
	tournInfo.toTraceString(_buf);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	tournInfo.composeMsg(_msg);
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	tournInfo.parseMsg(_parser);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TOURN_REG2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTournInfo = ThinAtf::LAtfVector< TournInfo2, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournInfo"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tournInfo", szTournInfo, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_WAIT
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT::Protocol_MSG_LOBBY_FIND_WAIT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT::Protocol_MSG_LOBBY_FIND_WAIT(Protocol_MSG_LOBBY_FIND_WAIT&& _o)
	: notUsed(std::move(_o.notUsed))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT& Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT::operator=(Protocol_MSG_LOBBY_FIND_WAIT&& _o)
{
	if(this != &_o)
	{
		notUsed = std::move(_o.notUsed);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT::clear()
{
	notUsed.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT::equals(const Protocol_MSG_LOBBY_FIND_WAIT& _o) const
{
	return notUsed.equals(_o.notUsed);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_WAIT).append(")");
	_buf.append(',');
	_buf.append("notUsed=");
	_buf.append(notUsed);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(notUsed);
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsed);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_WAIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsed"); size_t szNotUsed = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsed", szNotUsed, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    TableInfo
//=================================================================

Lobby::cli::TableInfo::TableInfo()
{
	clear();
}

void Lobby::cli::TableInfo::clear()
{
	tableId = 0;
	order = 0;
}

bool Lobby::cli::TableInfo::equals(const TableInfo& _o) const
{
	return tableId == _o.tableId &&
		order == _o.order;
}

const char *Lobby::cli::TableInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tableId=");
	_buf.appendUint(tableId);
	_buf.append(',');
	_buf.append("order=");
	_buf.appendUint(order);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::TableInfo::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(tableId);
	_msg.composeUINT32(order);
}

void Lobby::cli::TableInfo::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tableId);
	_parser.parseUINT32(order);
}

/*static*/ void Lobby::cli::TableInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 tableId; _parser.parseUINT32(tableId);
	AtfValidator::validateInt(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	UINT32 order; _parser.parseUINT32(order);
	AtfValidator::validateInt(_descr, "order", order, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    ServerInfo
//=================================================================

Lobby::cli::ServerInfo::ServerInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::ServerInfo::ServerInfo(ServerInfo&& _o)
	: serverName(std::move(_o.serverName))
	, serverObject(std::move(_o.serverObject))
{
}

Lobby::cli::ServerInfo& Lobby::cli::ServerInfo::operator=(ServerInfo&& _o)
{
	if(this != &_o)
	{
		serverName = std::move(_o.serverName);
		serverObject = std::move(_o.serverObject);
	}
	return *this;
}

#endif

void Lobby::cli::ServerInfo::clear()
{
	serverName.clear();
	serverObject.clear();
}

bool Lobby::cli::ServerInfo::equals(const ServerInfo& _o) const
{
	return serverName.equals(_o.serverName) &&
		serverObject.equals(_o.serverObject);
}

const char *Lobby::cli::ServerInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("serverName=");
	_buf.append(serverName);
	_buf.append(',');
	_buf.append("serverObject=");
	_buf.append(serverObject);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::ServerInfo::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(serverName);
	_msg.composeString(serverObject);
}

void Lobby::cli::ServerInfo::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(serverName);
	_parser.parseStringP(serverObject);
}

/*static*/ void Lobby::cli::ServerInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "serverName"); size_t szServerName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverName", szServerName, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "serverObject"); size_t szServerObject = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObject", szServerObject, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_WAIT_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT_REPLY::Protocol_MSG_LOBBY_FIND_WAIT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT_REPLY::Protocol_MSG_LOBBY_FIND_WAIT_REPLY(Protocol_MSG_LOBBY_FIND_WAIT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, tables(std::move(_o.tables))
	, servers(std::move(_o.servers))
	, totals(std::move(_o.totals))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT_REPLY& Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT_REPLY::operator=(Protocol_MSG_LOBBY_FIND_WAIT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		tables = std::move(_o.tables);
		servers = std::move(_o.servers);
		totals = std::move(_o.totals);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT_REPLY::clear()
{
	errCode = 0;
	tables.clear();
	servers.clear();
	totals.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT_REPLY::equals(const Protocol_MSG_LOBBY_FIND_WAIT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		tables.equals(_o.tables) &&
		servers.equals(_o.servers) &&
		totals.equals(_o.totals);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_WAIT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("tables=");
	tables.toTraceString(_buf);
	_buf.append(',');
	_buf.append("servers=");
	servers.toTraceString(_buf);
	_buf.append(',');
	_buf.append("totals=");
	totals.toTraceString(_buf);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	tables.composeMsg(_msg);
	servers.composeMsg(_msg);
	totals.composeMsg(_msg);
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	tables.parseMsg(_parser);
	servers.parseMsg(_parser);
	totals.parseMsg(_parser);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_WAIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTables = ThinAtf::LAtfVector< TableInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tables"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tables", szTables, _checker, __FILE__, __LINE__);
	int szServers = ThinAtf::LAtfVector< ServerInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("servers"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "servers", szServers, _checker, __FILE__, __LINE__);
	int szTotals = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("totals"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "totals", szTotals, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    LeaderPoints
//=================================================================

Lobby::cli::LeaderPoints::LeaderPoints()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::LeaderPoints::LeaderPoints(LeaderPoints&& _o)
	: player(std::move(_o.player))
	, points(std::move(_o.points))
{
}

Lobby::cli::LeaderPoints& Lobby::cli::LeaderPoints::operator=(LeaderPoints&& _o)
{
	if(this != &_o)
	{
		player = std::move(_o.player);
		points = std::move(_o.points);
	}
	return *this;
}

#endif

void Lobby::cli::LeaderPoints::clear()
{
	player.clear();
	points = 0;
}

bool Lobby::cli::LeaderPoints::equals(const LeaderPoints& _o) const
{
	return player.equals(_o.player) &&
		points == _o.points;
}

const char *Lobby::cli::LeaderPoints::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("player=");
	_buf.append(player);
	_buf.append(',');
	_buf.append("points=");
	_buf.appendUint(points);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::LeaderPoints::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(player);
	_msg.composeUINT32(points);
}

void Lobby::cli::LeaderPoints::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(player);
	_parser.parseUINT32(points);
}

/*static*/ void Lobby::cli::LeaderPoints::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "player"); size_t szPlayer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "player", szPlayer, _checker, __FILE__, __LINE__);
	UINT32 points; _parser.parseUINT32(points);
	AtfValidator::validateInt(_descr, "points", points, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TlbVector
//=================================================================

Lobby::cli::TlbVector::TlbVector()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::TlbVector::TlbVector(TlbVector&& _o)
	: lastTimestamp(std::move(_o.lastTimestamp))
	, tlbType(std::move(_o.tlbType))
	, timeFrom(std::move(_o.timeFrom))
	, timeTo(std::move(_o.timeTo))
	, leaderPoints(std::move(_o.leaderPoints))
	, userPlace(std::move(_o.userPlace))
	, userPoints(std::move(_o.userPoints))
{
}

Lobby::cli::TlbVector& Lobby::cli::TlbVector::operator=(TlbVector&& _o)
{
	if(this != &_o)
	{
		lastTimestamp = std::move(_o.lastTimestamp);
		tlbType = std::move(_o.tlbType);
		timeFrom = std::move(_o.timeFrom);
		timeTo = std::move(_o.timeTo);
		leaderPoints = std::move(_o.leaderPoints);
		userPlace = std::move(_o.userPlace);
		userPoints = std::move(_o.userPoints);
	}
	return *this;
}

#endif

void Lobby::cli::TlbVector::clear()
{
	lastTimestamp.clear();
	tlbType = 0;
	timeFrom.setNull();
	timeTo.setNull();
	leaderPoints.clear();
	userPlace = 0;
	userPoints = 0;
}

bool Lobby::cli::TlbVector::equals(const TlbVector& _o) const
{
	return lastTimestamp.equals(_o.lastTimestamp) &&
		tlbType == _o.tlbType &&
		timeFrom.equals(_o.timeFrom) &&
		timeTo.equals(_o.timeTo) &&
		leaderPoints.equals(_o.leaderPoints) &&
		userPlace == _o.userPlace &&
		userPoints == _o.userPoints;
}

const char *Lobby::cli::TlbVector::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("lastTimestamp=");
	_buf.append(lastTimestamp);
	_buf.append(',');
	_buf.append("tlbType=");
	_buf.appendUint(tlbType);
	_buf.append(',');
	_buf.append("timeFrom=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, timeFrom);
	_buf.append(',');
	_buf.append("timeTo=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, timeTo);
	_buf.append(',');
	_buf.append("leaderPoints=");
	leaderPoints.toTraceString(_buf);
	_buf.append(',');
	_buf.append("userPlace=");
	_buf.appendUint(userPlace);
	_buf.append(',');
	_buf.append("userPoints=");
	_buf.appendUint(userPoints);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::TlbVector::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(lastTimestamp);
	_msg.composeBYTE(tlbType);
	_msg.composeSrvTime(timeFrom);
	_msg.composeSrvTime(timeTo);
	leaderPoints.composeMsg(_msg);
	_msg.composeUINT32(userPlace);
	_msg.composeUINT32(userPoints);
}

void Lobby::cli::TlbVector::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(lastTimestamp);
	_parser.parseBYTE(tlbType);
	_parser.parseSrvTime(timeFrom);
	_parser.parseSrvTime(timeTo);
	leaderPoints.parseMsg(_parser);
	_parser.parseUINT32(userPlace);
	_parser.parseUINT32(userPoints);
}

/*static*/ void Lobby::cli::TlbVector::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "lastTimestamp"); size_t szLastTimestamp = strlen(_dummy);
	AtfValidator::validateInt(_descr, "lastTimestamp", szLastTimestamp, _checker, __FILE__, __LINE__);
	BYTE tlbType; _parser.parseBYTE(tlbType);
	AtfValidator::validateInt(_descr, "tlbType", tlbType, _checker, __FILE__, __LINE__);
	SrvTime timeFrom; _parser.parseSrvTime(timeFrom);
	AtfValidator::validateSrvDateTime(_descr, "timeFrom", timeFrom, _checker, __FILE__, __LINE__);
	SrvTime timeTo; _parser.parseSrvTime(timeTo);
	AtfValidator::validateSrvDateTime(_descr, "timeTo", timeTo, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szLeaderPoints = ThinAtf::LAtfVector< LeaderPoints, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("leaderPoints"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "leaderPoints", szLeaderPoints, _checker, __FILE__, __LINE__);
	UINT32 userPlace; _parser.parseUINT32(userPlace);
	AtfValidator::validateInt(_descr, "userPlace", userPlace, _checker, __FILE__, __LINE__);
	UINT32 userPoints; _parser.parseUINT32(userPoints);
	AtfValidator::validateInt(_descr, "userPoints", userPoints, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2(Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2&& _o)
	: notUsed(std::move(_o.notUsed))
	, tlbListType(std::move(_o.tlbListType))
	, uniqueIdStr(std::move(_o.uniqueIdStr))
{
}

Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2& Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2::operator=(Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2&& _o)
{
	if(this != &_o)
	{
		notUsed = std::move(_o.notUsed);
		tlbListType = std::move(_o.tlbListType);
		uniqueIdStr = std::move(_o.uniqueIdStr);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2::clear()
{
	notUsed.clear();
	tlbListType = 0;
	uniqueIdStr.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2::equals(const Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2& _o) const
{
	return notUsed.equals(_o.notUsed) &&
		tlbListType == _o.tlbListType &&
		uniqueIdStr.equals(_o.uniqueIdStr);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CLI_GET_TLB_STANDIDNS2).append(")");
	_buf.append(',');
	_buf.append("notUsed=");
	_buf.append(notUsed);
	_buf.append(',');
	_buf.append("tlbListType=");
	_buf.appendUint(tlbListType);
	_buf.append(',');
	_buf.append("uniqueIdStr=");
	_buf.append(uniqueIdStr);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(notUsed);
	_msg.composeBYTE(tlbListType);
	_msg.composeString(uniqueIdStr);
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsed);
	_parser.parseBYTE(tlbListType);
	_parser.parseStringP(uniqueIdStr);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLI_GET_TLB_STANDIDNS2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsed"); size_t szNotUsed = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsed", szNotUsed, 20, _checker, __FILE__, __LINE__);
	BYTE tlbListType; _parser.parseBYTE(tlbListType);
	AtfValidator::validateIntRange(_descr, "tlbListType", tlbListType, eTlbYear, TlbStandingsListType_last, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "uniqueIdStr"); size_t szUniqueIdStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "uniqueIdStr", szUniqueIdStr, 30, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY(Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, tableVector(std::move(_o.tableVector))
	, lastUpdated(std::move(_o.lastUpdated))
{
}

Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY& Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY::operator=(Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		tableVector = std::move(_o.tableVector);
		lastUpdated = std::move(_o.lastUpdated);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	tableVector.clear();
	lastUpdated.setNull();
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY::equals(const Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		tableVector.equals(_o.tableVector) &&
		lastUpdated.equals(_o.lastUpdated);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("tableVector=");
		tableVector.toTraceString(_buf);
		_buf.append(',');
		_buf.append("lastUpdated=");
		ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, lastUpdated);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		tableVector.composeMsg(_msg);
		_msg.composeSrvTime(lastUpdated);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		tableVector.parseMsg(_parser);
		_parser.parseSrvTime(lastUpdated);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		TlbVector::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableVector"), _fieldsWithUnparsedContent);
		SrvTime lastUpdated; _parser.parseSrvTime(lastUpdated);
		AtfValidator::validateSrvDateTime(_descr, "lastUpdated", lastUpdated, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    PlayerTableData
//=================================================================

Lobby::cli::PlayerTableData::PlayerTableData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::PlayerTableData::PlayerTableData(PlayerTableData&& _o)
	: serverAddress(std::move(_o.serverAddress))
	, serverInstance(std::move(_o.serverInstance))
	, tableIdOld(std::move(_o.tableIdOld))
	, tableName(std::move(_o.tableName))
	, tableSpecialSuffix(std::move(_o.tableSpecialSuffix))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, loBet(std::move(_o.loBet))
	, hiBet(std::move(_o.hiBet))
	, game(std::move(_o.game))
	, structure(std::move(_o.structure))
	, isHiLo(std::move(_o.isHiLo))
	, currency(std::move(_o.currency))
	, scalePm(std::move(_o.scalePm))
	, tableId(std::move(_o.tableId))
	, maxPlayers(std::move(_o.maxPlayers))
{
}

Lobby::cli::PlayerTableData& Lobby::cli::PlayerTableData::operator=(PlayerTableData&& _o)
{
	if(this != &_o)
	{
		serverAddress = std::move(_o.serverAddress);
		serverInstance = std::move(_o.serverInstance);
		tableIdOld = std::move(_o.tableIdOld);
		tableName = std::move(_o.tableName);
		tableSpecialSuffix = std::move(_o.tableSpecialSuffix);
		isPlayMoney = std::move(_o.isPlayMoney);
		loBet = std::move(_o.loBet);
		hiBet = std::move(_o.hiBet);
		game = std::move(_o.game);
		structure = std::move(_o.structure);
		isHiLo = std::move(_o.isHiLo);
		currency = std::move(_o.currency);
		scalePm = std::move(_o.scalePm);
		tableId = std::move(_o.tableId);
		maxPlayers = std::move(_o.maxPlayers);
	}
	return *this;
}

#endif

void Lobby::cli::PlayerTableData::clear()
{
	serverAddress.clear();
	serverInstance.clear();
	tableIdOld = 0;
	tableName.clear();
	tableSpecialSuffix.clear();
	isPlayMoney = false;
	loBet = 0;
	hiBet = 0;
	game = 0;
	structure = 0;
	isHiLo = false;
	currency.clear();
	scalePm = 0;
	tableId = 0;
	maxPlayers = 0;
}

bool Lobby::cli::PlayerTableData::equals(const PlayerTableData& _o) const
{
	return serverAddress.equals(_o.serverAddress) &&
		serverInstance.equals(_o.serverInstance) &&
		tableIdOld == _o.tableIdOld &&
		tableName.equals(_o.tableName) &&
		tableSpecialSuffix.equals(_o.tableSpecialSuffix) &&
		isPlayMoney == _o.isPlayMoney &&
		loBet == _o.loBet &&
		hiBet == _o.hiBet &&
		game == _o.game &&
		structure == _o.structure &&
		isHiLo == _o.isHiLo &&
		currency.equals(_o.currency) &&
		scalePm == _o.scalePm &&
		tableId == _o.tableId &&
		maxPlayers == _o.maxPlayers;
}

const char *Lobby::cli::PlayerTableData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("serverAddress=");
	_buf.append(serverAddress);
	_buf.append(',');
	_buf.append("serverInstance=");
	_buf.append(serverInstance);
	_buf.append(',');
	_buf.append("tableIdOld=");
	_buf.appendUint(tableIdOld);
	_buf.append(',');
	_buf.append("tableName=");
	_buf.append(tableName);
	_buf.append(',');
	_buf.append("tableSpecialSuffix=");
	_buf.append(tableSpecialSuffix);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("loBet=");
	_buf.appendUint(loBet);
	_buf.append(',');
	_buf.append("hiBet=");
	_buf.appendUint(hiBet);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("scalePm=");
	_buf.appendUint(scalePm);
	_buf.append(',');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendUint(maxPlayers);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::PlayerTableData::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(serverAddress);
	_msg.composeString(serverInstance);
	_msg.composeUINT32(tableIdOld);
	_msg.composeString(tableName);
	_msg.composeString(tableSpecialSuffix);
	_msg.composeBOOL(isPlayMoney);
	_msg.composeUINT32(loBet);
	_msg.composeUINT32(hiBet);
	_msg.composeBYTE(game);
	_msg.composeBYTE(structure);
	_msg.composeBOOL(isHiLo);
	_msg.composeString(currency);
	_msg.composeUINT32(scalePm);
	_msg.composeUINT64(tableId);
	_msg.composeBYTE(maxPlayers);
}

void Lobby::cli::PlayerTableData::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(serverAddress);
	_parser.parseStringP(serverInstance);
	_parser.parseUINT32(tableIdOld);
	_parser.parseStringP(tableName);
	_parser.parseStringP(tableSpecialSuffix);
	_parser.parseBOOL(isPlayMoney);
	_parser.parseUINT32(loBet);
	_parser.parseUINT32(hiBet);
	_parser.parseBYTE(game);
	_parser.parseBYTE(structure);
	_parser.parseBOOL(isHiLo);
	_parser.parseStringP(currency);
	_parser.parseUINT32(scalePm);
	_parser.parseUINT64(tableId);
	_parser.parseBYTE(maxPlayers);
}

/*static*/ void Lobby::cli::PlayerTableData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "serverAddress"); size_t szServerAddress = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverAddress", szServerAddress, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "serverInstance"); size_t szServerInstance = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverInstance", szServerInstance, _checker, __FILE__, __LINE__);
	UINT32 tableIdOld; _parser.parseUINT32(tableIdOld);
	AtfValidator::validateInt(_descr, "tableIdOld", tableIdOld, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "tableName"); size_t szTableName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tableName", szTableName, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "tableSpecialSuffix"); size_t szTableSpecialSuffix = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tableSpecialSuffix", szTableSpecialSuffix, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 loBet; _parser.parseUINT32(loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	UINT32 hiBet; _parser.parseUINT32(hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	bool isHiLo; _parser.parseBOOL(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 scalePm; _parser.parseUINT32(scalePm);
	AtfValidator::validateInt(_descr, "scalePm", scalePm, _checker, __FILE__, __LINE__);
	UINT64 tableId; _parser.parseUINT64(tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	BYTE maxPlayers; _parser.parseBYTE(maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    PlayerTournData
//=================================================================

Lobby::cli::PlayerTournData::PlayerTournData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::PlayerTournData::PlayerTournData(PlayerTournData&& _o)
	: serverAddress(std::move(_o.serverAddress))
	, tournId(std::move(_o.tournId))
	, isSitAndGo(std::move(_o.isSitAndGo))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, buyIn(std::move(_o.buyIn))
	, rake(std::move(_o.rake))
	, fppBuyIn(std::move(_o.fppBuyIn))
	, game(std::move(_o.game))
	, structure(std::move(_o.structure))
	, isHiLo(std::move(_o.isHiLo))
	, status(std::move(_o.status))
	, currency(std::move(_o.currency))
	, scalePm(std::move(_o.scalePm))
	, needAdmission(std::move(_o.needAdmission))
	, admissionPrice(std::move(_o.admissionPrice))
	, isPrivate(std::move(_o.isPrivate))
{
}

Lobby::cli::PlayerTournData& Lobby::cli::PlayerTournData::operator=(PlayerTournData&& _o)
{
	if(this != &_o)
	{
		serverAddress = std::move(_o.serverAddress);
		tournId = std::move(_o.tournId);
		isSitAndGo = std::move(_o.isSitAndGo);
		isPlayMoney = std::move(_o.isPlayMoney);
		buyIn = std::move(_o.buyIn);
		rake = std::move(_o.rake);
		fppBuyIn = std::move(_o.fppBuyIn);
		game = std::move(_o.game);
		structure = std::move(_o.structure);
		isHiLo = std::move(_o.isHiLo);
		status = std::move(_o.status);
		currency = std::move(_o.currency);
		scalePm = std::move(_o.scalePm);
		needAdmission = std::move(_o.needAdmission);
		admissionPrice = std::move(_o.admissionPrice);
		isPrivate = std::move(_o.isPrivate);
	}
	return *this;
}

#endif

void Lobby::cli::PlayerTournData::clear()
{
	serverAddress.clear();
	tournId = 0;
	isSitAndGo = false;
	isPlayMoney = false;
	buyIn = 0;
	rake = 0;
	fppBuyIn = 0;
	game = 0;
	structure = 0;
	isHiLo = false;
	status = 0;
	currency.clear();
	scalePm = 0;
	needAdmission = false;
	admissionPrice = 0;
	isPrivate = false;
}

bool Lobby::cli::PlayerTournData::equals(const PlayerTournData& _o) const
{
	return serverAddress.equals(_o.serverAddress) &&
		tournId == _o.tournId &&
		isSitAndGo == _o.isSitAndGo &&
		isPlayMoney == _o.isPlayMoney &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		fppBuyIn == _o.fppBuyIn &&
		game == _o.game &&
		structure == _o.structure &&
		isHiLo == _o.isHiLo &&
		status == _o.status &&
		currency.equals(_o.currency) &&
		scalePm == _o.scalePm &&
		needAdmission == _o.needAdmission &&
		admissionPrice == _o.admissionPrice &&
		isPrivate == _o.isPrivate;
}

const char *Lobby::cli::PlayerTournData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("serverAddress=");
	_buf.append(serverAddress);
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("isSitAndGo=");
	_buf.appendUint(isSitAndGo);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendUint(buyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendUint(rake);
	_buf.append(',');
	_buf.append("fppBuyIn=");
	_buf.appendUint(fppBuyIn);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("status=");
	_buf.appendUint(status);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("scalePm=");
	_buf.appendUint(scalePm);
	_buf.append(',');
	_buf.append("needAdmission=");
	_buf.appendUint(needAdmission);
	_buf.append(',');
	_buf.append("admissionPrice=");
	_buf.appendInt64(admissionPrice);
	_buf.append(',');
	_buf.append("isPrivate=");
	_buf.appendUint(isPrivate);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::PlayerTournData::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(serverAddress);
	_msg.composeUINT32(tournId);
	_msg.composeBOOL(isSitAndGo);
	_msg.composeBOOL(isPlayMoney);
	_msg.composeUINT32(buyIn);
	_msg.composeUINT32(rake);
	_msg.composeUINT32(fppBuyIn);
	_msg.composeBYTE(game);
	_msg.composeBYTE(structure);
	_msg.composeBOOL(isHiLo);
	_msg.composeUINT32(status);
	_msg.composeString(currency);
	_msg.composeUINT32(scalePm);
	_msg.composeBOOL(needAdmission);
	_msg.composeINT64(admissionPrice);
	_msg.composeBOOL(isPrivate);
}

void Lobby::cli::PlayerTournData::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(serverAddress);
	_parser.parseUINT32(tournId);
	_parser.parseBOOL(isSitAndGo);
	_parser.parseBOOL(isPlayMoney);
	_parser.parseUINT32(buyIn);
	_parser.parseUINT32(rake);
	_parser.parseUINT32(fppBuyIn);
	_parser.parseBYTE(game);
	_parser.parseBYTE(structure);
	_parser.parseBOOL(isHiLo);
	_parser.parseUINT32(status);
	_parser.parseStringP(currency);
	_parser.parseUINT32(scalePm);
	_parser.parseBOOL(needAdmission);
	_parser.parseINT64(admissionPrice);
	_parser.parseBOOL(isPrivate);
}

/*static*/ void Lobby::cli::PlayerTournData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "serverAddress"); size_t szServerAddress = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverAddress", szServerAddress, _checker, __FILE__, __LINE__);
	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	bool isSitAndGo; _parser.parseBOOL(isSitAndGo);
	AtfValidator::validateInt(_descr, "isSitAndGo", isSitAndGo, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 buyIn; _parser.parseUINT32(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT32 rake; _parser.parseUINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	UINT32 fppBuyIn; _parser.parseUINT32(fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	bool isHiLo; _parser.parseBOOL(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	UINT32 status; _parser.parseUINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 scalePm; _parser.parseUINT32(scalePm);
	AtfValidator::validateInt(_descr, "scalePm", scalePm, _checker, __FILE__, __LINE__);
	bool needAdmission; _parser.parseBOOL(needAdmission);
	AtfValidator::validateInt(_descr, "needAdmission", needAdmission, _checker, __FILE__, __LINE__);
	INT64 admissionPrice; _parser.parseINT64(admissionPrice);
	AtfValidator::validateInt(_descr, "admissionPrice", admissionPrice, _checker, __FILE__, __LINE__);
	bool isPrivate; _parser.parseBOOL(isPrivate);
	AtfValidator::validateInt(_descr, "isPrivate", isPrivate, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    PlayerBlitzData
//=================================================================

Lobby::cli::PlayerBlitzData::PlayerBlitzData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::PlayerBlitzData::PlayerBlitzData(PlayerBlitzData&& _o)
	: serverAddress(std::move(_o.serverAddress))
	, serverInstance(std::move(_o.serverInstance))
	, blitzId(std::move(_o.blitzId))
	, blitzName(std::move(_o.blitzName))
	, blitzSpecialSuffix(std::move(_o.blitzSpecialSuffix))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, loBet(std::move(_o.loBet))
	, hiBet(std::move(_o.hiBet))
	, game(std::move(_o.game))
	, structure(std::move(_o.structure))
	, isHiLo(std::move(_o.isHiLo))
	, currency(std::move(_o.currency))
	, scalePm(std::move(_o.scalePm))
{
}

Lobby::cli::PlayerBlitzData& Lobby::cli::PlayerBlitzData::operator=(PlayerBlitzData&& _o)
{
	if(this != &_o)
	{
		serverAddress = std::move(_o.serverAddress);
		serverInstance = std::move(_o.serverInstance);
		blitzId = std::move(_o.blitzId);
		blitzName = std::move(_o.blitzName);
		blitzSpecialSuffix = std::move(_o.blitzSpecialSuffix);
		isPlayMoney = std::move(_o.isPlayMoney);
		loBet = std::move(_o.loBet);
		hiBet = std::move(_o.hiBet);
		game = std::move(_o.game);
		structure = std::move(_o.structure);
		isHiLo = std::move(_o.isHiLo);
		currency = std::move(_o.currency);
		scalePm = std::move(_o.scalePm);
	}
	return *this;
}

#endif

void Lobby::cli::PlayerBlitzData::clear()
{
	serverAddress.clear();
	serverInstance.clear();
	blitzId = 0;
	blitzName.clear();
	blitzSpecialSuffix.clear();
	isPlayMoney = false;
	loBet = 0;
	hiBet = 0;
	game = 0;
	structure = 0;
	isHiLo = false;
	currency.clear();
	scalePm = 0;
}

bool Lobby::cli::PlayerBlitzData::equals(const PlayerBlitzData& _o) const
{
	return serverAddress.equals(_o.serverAddress) &&
		serverInstance.equals(_o.serverInstance) &&
		blitzId == _o.blitzId &&
		blitzName.equals(_o.blitzName) &&
		blitzSpecialSuffix.equals(_o.blitzSpecialSuffix) &&
		isPlayMoney == _o.isPlayMoney &&
		loBet == _o.loBet &&
		hiBet == _o.hiBet &&
		game == _o.game &&
		structure == _o.structure &&
		isHiLo == _o.isHiLo &&
		currency.equals(_o.currency) &&
		scalePm == _o.scalePm;
}

const char *Lobby::cli::PlayerBlitzData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("serverAddress=");
	_buf.append(serverAddress);
	_buf.append(',');
	_buf.append("serverInstance=");
	_buf.append(serverInstance);
	_buf.append(',');
	_buf.append("blitzId=");
	_buf.appendUint(blitzId);
	_buf.append(',');
	_buf.append("blitzName=");
	_buf.append(blitzName);
	_buf.append(',');
	_buf.append("blitzSpecialSuffix=");
	_buf.append(blitzSpecialSuffix);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("loBet=");
	_buf.appendUint(loBet);
	_buf.append(',');
	_buf.append("hiBet=");
	_buf.appendUint(hiBet);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("scalePm=");
	_buf.appendUint(scalePm);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::PlayerBlitzData::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(serverAddress);
	_msg.composeString(serverInstance);
	_msg.composeUINT32(blitzId);
	_msg.composeString(blitzName);
	_msg.composeString(blitzSpecialSuffix);
	_msg.composeBOOL(isPlayMoney);
	_msg.composeUINT32(loBet);
	_msg.composeUINT32(hiBet);
	_msg.composeBYTE(game);
	_msg.composeBYTE(structure);
	_msg.composeBOOL(isHiLo);
	_msg.composeString(currency);
	_msg.composeUINT32(scalePm);
}

void Lobby::cli::PlayerBlitzData::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(serverAddress);
	_parser.parseStringP(serverInstance);
	_parser.parseUINT32(blitzId);
	_parser.parseStringP(blitzName);
	_parser.parseStringP(blitzSpecialSuffix);
	_parser.parseBOOL(isPlayMoney);
	_parser.parseUINT32(loBet);
	_parser.parseUINT32(hiBet);
	_parser.parseBYTE(game);
	_parser.parseBYTE(structure);
	_parser.parseBOOL(isHiLo);
	_parser.parseStringP(currency);
	_parser.parseUINT32(scalePm);
}

/*static*/ void Lobby::cli::PlayerBlitzData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "serverAddress"); size_t szServerAddress = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverAddress", szServerAddress, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "serverInstance"); size_t szServerInstance = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverInstance", szServerInstance, _checker, __FILE__, __LINE__);
	UINT32 blitzId; _parser.parseUINT32(blitzId);
	AtfValidator::validateInt(_descr, "blitzId", blitzId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "blitzName"); size_t szBlitzName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "blitzName", szBlitzName, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "blitzSpecialSuffix"); size_t szBlitzSpecialSuffix = strlen(_dummy);
	AtfValidator::validateInt(_descr, "blitzSpecialSuffix", szBlitzSpecialSuffix, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 loBet; _parser.parseUINT32(loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	UINT32 hiBet; _parser.parseUINT32(hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	bool isHiLo; _parser.parseBOOL(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 scalePm; _parser.parseUINT32(scalePm);
	AtfValidator::validateInt(_descr, "scalePm", scalePm, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_PLAYER2
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2::Protocol_MSG_LOBBY_FIND_PLAYER2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2::Protocol_MSG_LOBBY_FIND_PLAYER2(Protocol_MSG_LOBBY_FIND_PLAYER2&& _o)
	: notUsed(std::move(_o.notUsed))
	, playerName(std::move(_o.playerName))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2& Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2::operator=(Protocol_MSG_LOBBY_FIND_PLAYER2&& _o)
{
	if(this != &_o)
	{
		notUsed = std::move(_o.notUsed);
		playerName = std::move(_o.playerName);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2::clear()
{
	notUsed.clear();
	playerName.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2::equals(const Protocol_MSG_LOBBY_FIND_PLAYER2& _o) const
{
	return notUsed.equals(_o.notUsed) &&
		playerName.equals(_o.playerName);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_PLAYER2).append(")");
	_buf.append(',');
	_buf.append("notUsed=");
	_buf.append(notUsed);
	_buf.append(',');
	_buf.append("playerName=");
	_buf.append(playerName);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(notUsed);
	_msg.composeString(playerName);
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsed);
	_parser.parseStringP(playerName);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_PLAYER2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsed"); size_t szNotUsed = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsed", szNotUsed, 20, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "playerName"); size_t szPlayerName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "playerName", szPlayerName, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY::Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY::Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY(Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY&& _o)
	: playerName(std::move(_o.playerName))
	, playerTables(std::move(_o.playerTables))
	, playerTourns(std::move(_o.playerTourns))
	, playerBlitz(std::move(_o.playerBlitz))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY& Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY::operator=(Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY&& _o)
{
	if(this != &_o)
	{
		playerName = std::move(_o.playerName);
		playerTables = std::move(_o.playerTables);
		playerTourns = std::move(_o.playerTourns);
		playerBlitz = std::move(_o.playerBlitz);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY::clear()
{
	playerName.clear();
	playerTables.clear();
	playerTourns.clear();
	playerBlitz.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY::equals(const Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY& _o) const
{
	return playerName.equals(_o.playerName) &&
		playerTables.equals(_o.playerTables) &&
		playerTourns.equals(_o.playerTourns) &&
		playerBlitz.equals(_o.playerBlitz);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_PLAYER2_REPLY).append(")");
	_buf.append(',');
	_buf.append("playerName=");
	_buf.append(playerName);
	_buf.append(',');
	_buf.append("playerTables=");
	playerTables.toTraceString(_buf);
	_buf.append(',');
	_buf.append("playerTourns=");
	playerTourns.toTraceString(_buf);
	_buf.append(',');
	_buf.append("playerBlitz=");
	playerBlitz.toTraceString(_buf);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(playerName);
	playerTables.composeMsg(_msg);
	playerTourns.composeMsg(_msg);
	playerBlitz.composeMsg(_msg);
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(playerName);
	playerTables.parseMsg(_parser);
	playerTourns.parseMsg(_parser);
	playerBlitz.parseMsg(_parser);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_PLAYER2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "playerName"); size_t szPlayerName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "playerName", szPlayerName, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szPlayerTables = ThinAtf::LAtfVector< PlayerTableData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("playerTables"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "playerTables", szPlayerTables, _checker, __FILE__, __LINE__);
	int szPlayerTourns = ThinAtf::LAtfVector< PlayerTournData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("playerTourns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "playerTourns", szPlayerTourns, _checker, __FILE__, __LINE__);
	int szPlayerBlitz = ThinAtf::LAtfVector< PlayerBlitzData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("playerBlitz"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "playerBlitz", szPlayerBlitz, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_PLAYER3
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3::Protocol_MSG_LOBBY_FIND_PLAYER3()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3::Protocol_MSG_LOBBY_FIND_PLAYER3(Protocol_MSG_LOBBY_FIND_PLAYER3&& _o)
	: playerName(std::move(_o.playerName))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3& Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3::operator=(Protocol_MSG_LOBBY_FIND_PLAYER3&& _o)
{
	if(this != &_o)
	{
		playerName = std::move(_o.playerName);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3::clear()
{
	playerName.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3::equals(const Protocol_MSG_LOBBY_FIND_PLAYER3& _o) const
{
	return playerName.equals(_o.playerName);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_PLAYER3).append(")");
	_buf.append(',');
	_buf.append("playerName=");
	_buf.append(playerName);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(playerName);
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(playerName);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_PLAYER3";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "playerName"); size_t szPlayerName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "playerName", szPlayerName, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY::Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY::Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY(Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, playerName(std::move(_o.playerName))
	, playerTables(std::move(_o.playerTables))
	, playerTourns(std::move(_o.playerTourns))
	, playerBlitz(std::move(_o.playerBlitz))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY& Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY::operator=(Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		playerName = std::move(_o.playerName);
		playerTables = std::move(_o.playerTables);
		playerTourns = std::move(_o.playerTourns);
		playerBlitz = std::move(_o.playerBlitz);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	playerName.clear();
	playerTables.clear();
	playerTourns.clear();
	playerBlitz.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY::equals(const Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		playerName.equals(_o.playerName) &&
		playerTables.equals(_o.playerTables) &&
		playerTourns.equals(_o.playerTourns) &&
		playerBlitz.equals(_o.playerBlitz);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_PLAYER3_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("playerName=");
		_buf.append(playerName);
		_buf.append(',');
		_buf.append("playerTables=");
		playerTables.toTraceString(_buf);
		_buf.append(',');
		_buf.append("playerTourns=");
		playerTourns.toTraceString(_buf);
		_buf.append(',');
		_buf.append("playerBlitz=");
		playerBlitz.toTraceString(_buf);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(playerName);
		playerTables.composeMsg(_msg);
		playerTourns.composeMsg(_msg);
		playerBlitz.composeMsg(_msg);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(playerName);
		playerTables.parseMsg(_parser);
		playerTourns.parseMsg(_parser);
		playerBlitz.parseMsg(_parser);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_PLAYER3_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "playerName"); size_t szPlayerName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "playerName", szPlayerName, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szPlayerTables = ThinAtf::LAtfVector< PlayerTableData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("playerTables"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "playerTables", szPlayerTables, _checker, __FILE__, __LINE__);
		int szPlayerTourns = ThinAtf::LAtfVector< PlayerTournData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("playerTourns"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "playerTourns", szPlayerTourns, _checker, __FILE__, __LINE__);
		int szPlayerBlitz = ThinAtf::LAtfVector< PlayerBlitzData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("playerBlitz"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "playerBlitz", szPlayerBlitz, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_WEB_FIND_PLAYER2
//=================================================================

Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2::Protocol_MSG_WEB_FIND_PLAYER2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2::Protocol_MSG_WEB_FIND_PLAYER2(Protocol_MSG_WEB_FIND_PLAYER2&& _o)
	: notUsed(std::move(_o.notUsed))
	, playerName(std::move(_o.playerName))
{
}

Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2& Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2::operator=(Protocol_MSG_WEB_FIND_PLAYER2&& _o)
{
	if(this != &_o)
	{
		notUsed = std::move(_o.notUsed);
		playerName = std::move(_o.playerName);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2::clear()
{
	notUsed.clear();
	playerName.clear();
}

bool Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2::equals(const Protocol_MSG_WEB_FIND_PLAYER2& _o) const
{
	return notUsed.equals(_o.notUsed) &&
		playerName.equals(_o.playerName);
}

const char *Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_WEB_FIND_PLAYER2).append(")");
	_buf.append(',');
	_buf.append("notUsed=");
	_buf.append(notUsed);
	_buf.append(',');
	_buf.append("playerName=");
	_buf.append(playerName);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(notUsed);
	_msg.composeString(playerName);
}

void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsed);
	_parser.parseStringP(playerName);
}

/*static*/ void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_WEB_FIND_PLAYER2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsed"); size_t szNotUsed = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsed", szNotUsed, 20, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "playerName"); size_t szPlayerName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "playerName", szPlayerName, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_WEB_FIND_PLAYER2_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2_REPLY::Protocol_MSG_WEB_FIND_PLAYER2_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2_REPLY::Protocol_MSG_WEB_FIND_PLAYER2_REPLY(Protocol_MSG_WEB_FIND_PLAYER2_REPLY&& _o)
	: playerName(std::move(_o.playerName))
	, playerTables(std::move(_o.playerTables))
	, playerTourns(std::move(_o.playerTourns))
	, playerBlitz(std::move(_o.playerBlitz))
{
}

Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2_REPLY& Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2_REPLY::operator=(Protocol_MSG_WEB_FIND_PLAYER2_REPLY&& _o)
{
	if(this != &_o)
	{
		playerName = std::move(_o.playerName);
		playerTables = std::move(_o.playerTables);
		playerTourns = std::move(_o.playerTourns);
		playerBlitz = std::move(_o.playerBlitz);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2_REPLY::clear()
{
	playerName.clear();
	playerTables.clear();
	playerTourns.clear();
	playerBlitz.clear();
}

bool Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2_REPLY::equals(const Protocol_MSG_WEB_FIND_PLAYER2_REPLY& _o) const
{
	return playerName.equals(_o.playerName) &&
		playerTables.equals(_o.playerTables) &&
		playerTourns.equals(_o.playerTourns) &&
		playerBlitz.equals(_o.playerBlitz);
}

const char *Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_WEB_FIND_PLAYER2_REPLY).append(")");
	_buf.append(',');
	_buf.append("playerName=");
	_buf.append(playerName);
	_buf.append(',');
	_buf.append("playerTables=");
	playerTables.toTraceString(_buf);
	_buf.append(',');
	_buf.append("playerTourns=");
	playerTourns.toTraceString(_buf);
	_buf.append(',');
	_buf.append("playerBlitz=");
	playerBlitz.toTraceString(_buf);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(playerName);
	playerTables.composeMsg(_msg);
	playerTourns.composeMsg(_msg);
	playerBlitz.composeMsg(_msg);
}

void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(playerName);
	playerTables.parseMsg(_parser);
	playerTourns.parseMsg(_parser);
	playerBlitz.parseMsg(_parser);
}

/*static*/ void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_WEB_FIND_PLAYER2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "playerName"); size_t szPlayerName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "playerName", szPlayerName, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szPlayerTables = ThinAtf::LAtfVector< PlayerTableData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("playerTables"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "playerTables", szPlayerTables, _checker, __FILE__, __LINE__);
	int szPlayerTourns = ThinAtf::LAtfVector< PlayerTournData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("playerTourns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "playerTourns", szPlayerTourns, _checker, __FILE__, __LINE__);
	int szPlayerBlitz = ThinAtf::LAtfVector< PlayerBlitzData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("playerBlitz"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "playerBlitz", szPlayerBlitz, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_WEB_FIND_PLAYER3
//=================================================================

Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3::Protocol_MSG_WEB_FIND_PLAYER3()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3::Protocol_MSG_WEB_FIND_PLAYER3(Protocol_MSG_WEB_FIND_PLAYER3&& _o)
	: playerName(std::move(_o.playerName))
{
}

Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3& Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3::operator=(Protocol_MSG_WEB_FIND_PLAYER3&& _o)
{
	if(this != &_o)
	{
		playerName = std::move(_o.playerName);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3::clear()
{
	playerName.clear();
}

bool Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3::equals(const Protocol_MSG_WEB_FIND_PLAYER3& _o) const
{
	return playerName.equals(_o.playerName);
}

const char *Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_WEB_FIND_PLAYER3).append(")");
	_buf.append(',');
	_buf.append("playerName=");
	_buf.append(playerName);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(playerName);
}

void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(playerName);
}

/*static*/ void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_WEB_FIND_PLAYER3";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "playerName"); size_t szPlayerName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "playerName", szPlayerName, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_WEB_FIND_PLAYER3_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3_REPLY::Protocol_MSG_WEB_FIND_PLAYER3_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3_REPLY::Protocol_MSG_WEB_FIND_PLAYER3_REPLY(Protocol_MSG_WEB_FIND_PLAYER3_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, playerName(std::move(_o.playerName))
	, playerTables(std::move(_o.playerTables))
	, playerTourns(std::move(_o.playerTourns))
	, playerBlitz(std::move(_o.playerBlitz))
{
}

Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3_REPLY& Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3_REPLY::operator=(Protocol_MSG_WEB_FIND_PLAYER3_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		playerName = std::move(_o.playerName);
		playerTables = std::move(_o.playerTables);
		playerTourns = std::move(_o.playerTourns);
		playerBlitz = std::move(_o.playerBlitz);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	playerName.clear();
	playerTables.clear();
	playerTourns.clear();
	playerBlitz.clear();
}

bool Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3_REPLY::equals(const Protocol_MSG_WEB_FIND_PLAYER3_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		playerName.equals(_o.playerName) &&
		playerTables.equals(_o.playerTables) &&
		playerTourns.equals(_o.playerTourns) &&
		playerBlitz.equals(_o.playerBlitz);
}

const char *Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_WEB_FIND_PLAYER3_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("playerName=");
		_buf.append(playerName);
		_buf.append(',');
		_buf.append("playerTables=");
		playerTables.toTraceString(_buf);
		_buf.append(',');
		_buf.append("playerTourns=");
		playerTourns.toTraceString(_buf);
		_buf.append(',');
		_buf.append("playerBlitz=");
		playerBlitz.toTraceString(_buf);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(playerName);
		playerTables.composeMsg(_msg);
		playerTourns.composeMsg(_msg);
		playerBlitz.composeMsg(_msg);
	}
}

void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(playerName);
		playerTables.parseMsg(_parser);
		playerTourns.parseMsg(_parser);
		playerBlitz.parseMsg(_parser);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_WEB_FIND_PLAYER3_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "playerName"); size_t szPlayerName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "playerName", szPlayerName, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szPlayerTables = ThinAtf::LAtfVector< PlayerTableData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("playerTables"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "playerTables", szPlayerTables, _checker, __FILE__, __LINE__);
		int szPlayerTourns = ThinAtf::LAtfVector< PlayerTournData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("playerTourns"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "playerTourns", szPlayerTourns, _checker, __FILE__, __LINE__);
		int szPlayerBlitz = ThinAtf::LAtfVector< PlayerBlitzData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("playerBlitz"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "playerBlitz", szPlayerBlitz, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    Reacquisition
//=================================================================

Lobby::cli::Reacquisition::Reacquisition()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Reacquisition::Reacquisition(Reacquisition&& _o)
	: ticketId(std::move(_o.ticketId))
	, when(std::move(_o.when))
	, reacquisition(std::move(_o.reacquisition))
	, cost(std::move(_o.cost))
{
}

Lobby::cli::Reacquisition& Lobby::cli::Reacquisition::operator=(Reacquisition&& _o)
{
	if(this != &_o)
	{
		ticketId = std::move(_o.ticketId);
		when = std::move(_o.when);
		reacquisition = std::move(_o.reacquisition);
		cost = std::move(_o.cost);
	}
	return *this;
}

#endif

void Lobby::cli::Reacquisition::clear()
{
	ticketId.clear();
	when.setNull();
	reacquisition = 0;
	cost = 0;
}

bool Lobby::cli::Reacquisition::equals(const Reacquisition& _o) const
{
	return ticketId.equals(_o.ticketId) &&
		when.equals(_o.when) &&
		reacquisition == _o.reacquisition &&
		cost == _o.cost;
}

const char *Lobby::cli::Reacquisition::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("ticketId=");
	_buf.append(ticketId);
	_buf.append(',');
	_buf.append("when=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, when);
	_buf.append(',');
	_buf.append("reacquisition=");
	_buf.appendUint(reacquisition);
	_buf.append(',');
	_buf.append("cost=");
	_buf.appendUint(cost);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::Reacquisition::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(Reacquisition())) // not empty
	{
		_body.composeString(ticketId);
		_body.composeSrvTime(when);
		_body.composeUINT32(reacquisition);
		_body.composeUINT32(cost);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::cli::Reacquisition::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(ticketId);
	_parser0.parseSrvTime(when);
	_parser0.parseUINT32(reacquisition);
	_parser0.parseUINT32(cost);
}

/*static*/ void Lobby::cli::Reacquisition::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "ticketId"); size_t szTicketId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "ticketId", szTicketId, _checker, __FILE__, __LINE__);
	SrvTime when; _parser0.parseSrvTime(when);
	AtfValidator::validateSrvDateTime(_descr, "when", when, _checker, __FILE__, __LINE__);
	UINT32 reacquisition; _parser0.parseUINT32(reacquisition);
	AtfValidator::validateInt(_descr, "reacquisition", reacquisition, _checker, __FILE__, __LINE__);
	UINT32 cost; _parser0.parseUINT32(cost);
	AtfValidator::validateInt(_descr, "cost", cost, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ITTournData
//=================================================================

Lobby::cli::ITTournData::ITTournData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::ITTournData::ITTournData(ITTournData&& _o)
	: itId(std::move(_o.itId))
	, ticketId(std::move(_o.ticketId))
	, cost(std::move(_o.cost))
	, status(std::move(_o.status))
	, reacquisitions(std::move(_o.reacquisitions))
{
}

Lobby::cli::ITTournData& Lobby::cli::ITTournData::operator=(ITTournData&& _o)
{
	if(this != &_o)
	{
		itId = std::move(_o.itId);
		ticketId = std::move(_o.ticketId);
		cost = std::move(_o.cost);
		status = std::move(_o.status);
		reacquisitions = std::move(_o.reacquisitions);
	}
	return *this;
}

#endif

void Lobby::cli::ITTournData::clear()
{
	itId.clear();
	ticketId.clear();
	cost = 0;
	status = 0;
	reacquisitions.clear();
}

bool Lobby::cli::ITTournData::equals(const ITTournData& _o) const
{
	return itId.equals(_o.itId) &&
		ticketId.equals(_o.ticketId) &&
		cost == _o.cost &&
		status == _o.status &&
		reacquisitions.equals(_o.reacquisitions);
}

const char *Lobby::cli::ITTournData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("itId=");
	_buf.append(itId);
	_buf.append(',');
	_buf.append("ticketId=");
	_buf.append(ticketId);
	_buf.append(',');
	_buf.append("cost=");
	_buf.appendUint(cost);
	_buf.append(',');
	_buf.append("status=");
	_buf.appendUint(status);
	_buf.append(',');
	_buf.append("reacquisitions=");
	reacquisitions.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::ITTournData::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(ITTournData())) // not empty
	{
		_body.composeString(itId);
		_body.composeString(ticketId);
		_body.composeUINT32(cost);
		_body.composeUINT32(status);
		reacquisitions.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::cli::ITTournData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(itId);
	_parser0.parseStringP(ticketId);
	_parser0.parseUINT32(cost);
	_parser0.parseUINT32(status);
	reacquisitions.parseMsg(_parser0);
}

/*static*/ void Lobby::cli::ITTournData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "itId"); size_t szItId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "itId", szItId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "ticketId"); size_t szTicketId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "ticketId", szTicketId, _checker, __FILE__, __LINE__);
	UINT32 cost; _parser0.parseUINT32(cost);
	AtfValidator::validateInt(_descr, "cost", cost, _checker, __FILE__, __LINE__);
	UINT32 status; _parser0.parseUINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szReacquisitions = ThinAtf::LAtfVector< Reacquisition, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("reacquisitions"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "reacquisitions", szReacquisitions, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ITTournVectorData
//=================================================================

Lobby::cli::ITTournVectorData::ITTournVectorData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::ITTournVectorData::ITTournVectorData(ITTournVectorData&& _o)
	: tournId(std::move(_o.tournId))
	, tournData(std::move(_o.tournData))
{
}

Lobby::cli::ITTournVectorData& Lobby::cli::ITTournVectorData::operator=(ITTournVectorData&& _o)
{
	if(this != &_o)
	{
		tournId = std::move(_o.tournId);
		tournData = std::move(_o.tournData);
	}
	return *this;
}

#endif

void Lobby::cli::ITTournVectorData::clear()
{
	tournId = 0;
	tournData.clear();
}

bool Lobby::cli::ITTournVectorData::equals(const ITTournVectorData& _o) const
{
	return tournId == _o.tournId &&
		tournData.equals(_o.tournData);
}

const char *Lobby::cli::ITTournVectorData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("tournData=");
	tournData.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::ITTournVectorData::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(tournId);
	tournData.composeMsg(_msg);
}

void Lobby::cli::ITTournVectorData::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tournId);
	tournData.parseMsg(_parser);
}

/*static*/ void Lobby::cli::ITTournVectorData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	ITTournData::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournData"), _fieldsWithUnparsedContent);
}

//=================================================================
//                    ITAddOn
//=================================================================

Lobby::cli::ITAddOn::ITAddOn()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::ITAddOn::ITAddOn(ITAddOn&& _o)
	: ticketId(std::move(_o.ticketId))
	, when(std::move(_o.when))
	, reacquisition(std::move(_o.reacquisition))
	, addOn(std::move(_o.addOn))
{
}

Lobby::cli::ITAddOn& Lobby::cli::ITAddOn::operator=(ITAddOn&& _o)
{
	if(this != &_o)
	{
		ticketId = std::move(_o.ticketId);
		when = std::move(_o.when);
		reacquisition = std::move(_o.reacquisition);
		addOn = std::move(_o.addOn);
	}
	return *this;
}

#endif

void Lobby::cli::ITAddOn::clear()
{
	ticketId.clear();
	when.setNull();
	reacquisition = 0;
	addOn = 0;
}

bool Lobby::cli::ITAddOn::equals(const ITAddOn& _o) const
{
	return ticketId.equals(_o.ticketId) &&
		when.equals(_o.when) &&
		reacquisition == _o.reacquisition &&
		addOn == _o.addOn;
}

const char *Lobby::cli::ITAddOn::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("ticketId=");
	_buf.append(ticketId);
	_buf.append(',');
	_buf.append("when=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, when);
	_buf.append(',');
	_buf.append("reacquisition=");
	_buf.appendUint(reacquisition);
	_buf.append(',');
	_buf.append("addOn=");
	_buf.appendUint(addOn);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::ITAddOn::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(ITAddOn())) // not empty
	{
		_body.composeString(ticketId);
		_body.composeSrvTime(when);
		_body.composeUINT32(reacquisition);
		_body.composeUINT32(addOn);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::cli::ITAddOn::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(ticketId);
	_parser0.parseSrvTime(when);
	_parser0.parseUINT32(reacquisition);
	_parser0.parseUINT32(addOn);
}

/*static*/ void Lobby::cli::ITAddOn::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "ticketId"); size_t szTicketId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "ticketId", szTicketId, _checker, __FILE__, __LINE__);
	SrvTime when; _parser0.parseSrvTime(when);
	AtfValidator::validateSrvDateTime(_descr, "when", when, _checker, __FILE__, __LINE__);
	UINT32 reacquisition; _parser0.parseUINT32(reacquisition);
	AtfValidator::validateInt(_descr, "reacquisition", reacquisition, _checker, __FILE__, __LINE__);
	UINT32 addOn; _parser0.parseUINT32(addOn);
	AtfValidator::validateInt(_descr, "addOn", addOn, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ITTableData
//=================================================================

Lobby::cli::ITTableData::ITTableData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::ITTableData::ITTableData(ITTableData&& _o)
	: addOns(std::move(_o.addOns))
	, tableId(std::move(_o.tableId))
{
}

Lobby::cli::ITTableData& Lobby::cli::ITTableData::operator=(ITTableData&& _o)
{
	if(this != &_o)
	{
		addOns = std::move(_o.addOns);
		tableId = std::move(_o.tableId);
	}
	return *this;
}

#endif

void Lobby::cli::ITTableData::clear()
{
	addOns.clear();
	tableId = 0;
}

bool Lobby::cli::ITTableData::equals(const ITTableData& _o) const
{
	return addOns.equals(_o.addOns) &&
		tableId == _o.tableId;
}

const char *Lobby::cli::ITTableData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("addOns=");
	addOns.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::ITTableData::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(ITTableData())) // not empty
	{
		addOns.composeMsg(_body);
		_body.composeUINT64(tableId);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::cli::ITTableData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	addOns.parseMsg(_parser0);
	_parser0.parseUINT64(tableId);
}

/*static*/ void Lobby::cli::ITTableData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szAddOns = ThinAtf::LAtfVector< ITAddOn, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("addOns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "addOns", szAddOns, _checker, __FILE__, __LINE__);
	UINT64 tableId; _parser0.parseUINT64(tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ITTableVectorData
//=================================================================

Lobby::cli::ITTableVectorData::ITTableVectorData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::ITTableVectorData::ITTableVectorData(ITTableVectorData&& _o)
	: tableId(std::move(_o.tableId))
	, tableData(std::move(_o.tableData))
{
}

Lobby::cli::ITTableVectorData& Lobby::cli::ITTableVectorData::operator=(ITTableVectorData&& _o)
{
	if(this != &_o)
	{
		tableId = std::move(_o.tableId);
		tableData = std::move(_o.tableData);
	}
	return *this;
}

#endif

void Lobby::cli::ITTableVectorData::clear()
{
	tableId = 0;
	tableData.clear();
}

bool Lobby::cli::ITTableVectorData::equals(const ITTableVectorData& _o) const
{
	return tableId == _o.tableId &&
		tableData.equals(_o.tableData);
}

const char *Lobby::cli::ITTableVectorData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tableId=");
	_buf.appendUint(tableId);
	_buf.append(',');
	_buf.append("tableData=");
	tableData.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::ITTableVectorData::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(tableId);
	tableData.composeMsg(_msg);
}

void Lobby::cli::ITTableVectorData::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tableId);
	tableData.parseMsg(_parser);
}

/*static*/ void Lobby::cli::ITTableVectorData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 tableId; _parser.parseUINT32(tableId);
	AtfValidator::validateInt(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	ITTableData::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableData"), _fieldsWithUnparsedContent);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_TOURN_REG_IT
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT(Protocol_MSG_LOBBY_FIND_TOURN_REG_IT&& _o)
	: notUsed(std::move(_o.notUsed))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT& Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT::operator=(Protocol_MSG_LOBBY_FIND_TOURN_REG_IT&& _o)
{
	if(this != &_o)
	{
		notUsed = std::move(_o.notUsed);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT::clear()
{
	notUsed.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT::equals(const Protocol_MSG_LOBBY_FIND_TOURN_REG_IT& _o) const
{
	return notUsed.equals(_o.notUsed);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_TOURN_REG_IT).append(")");
	_buf.append(',');
	_buf.append("notUsed=");
	_buf.append(notUsed);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(notUsed);
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsed);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TOURN_REG_IT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsed"); size_t szNotUsed = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsed", szNotUsed, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY(Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, tournVectorData(std::move(_o.tournVectorData))
	, tableVectorData(std::move(_o.tableVectorData))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY& Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY::operator=(Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		tournVectorData = std::move(_o.tournVectorData);
		tableVectorData = std::move(_o.tableVectorData);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	tournVectorData.clear();
	tableVectorData.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY::equals(const Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		tournVectorData.equals(_o.tournVectorData) &&
		tableVectorData.equals(_o.tableVectorData);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_TOURN_REG_IT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("tournVectorData=");
		tournVectorData.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tableVectorData=");
		tableVectorData.toTraceString(_buf);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		tournVectorData.composeMsg(_msg);
		tableVectorData.composeMsg(_msg);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		tournVectorData.parseMsg(_parser);
		tableVectorData.parseMsg(_parser);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TOURN_REG_IT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szTournVectorData = ThinAtf::LAtfVector< ITTournVectorData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournVectorData"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tournVectorData", szTournVectorData, _checker, __FILE__, __LINE__);
		int szTableVectorData = ThinAtf::LAtfVector< ITTableVectorData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableVectorData"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tableVectorData", szTableVectorData, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_TOURN_IT
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT::Protocol_MSG_LOBBY_FIND_TOURN_IT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT::Protocol_MSG_LOBBY_FIND_TOURN_IT(Protocol_MSG_LOBBY_FIND_TOURN_IT&& _o)
	: notUsed(std::move(_o.notUsed))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT& Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT::operator=(Protocol_MSG_LOBBY_FIND_TOURN_IT&& _o)
{
	if(this != &_o)
	{
		notUsed = std::move(_o.notUsed);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT::clear()
{
	notUsed.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT::equals(const Protocol_MSG_LOBBY_FIND_TOURN_IT& _o) const
{
	return notUsed.equals(_o.notUsed);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_TOURN_IT).append(")");
	_buf.append(',');
	_buf.append("notUsed=");
	_buf.append(notUsed);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(notUsed);
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsed);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TOURN_IT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsed"); size_t szNotUsed = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsed", szNotUsed, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY::Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY::Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY(Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, tournVectorData(std::move(_o.tournVectorData))
	, tableVectorData(std::move(_o.tableVectorData))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY& Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY::operator=(Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		tournVectorData = std::move(_o.tournVectorData);
		tableVectorData = std::move(_o.tableVectorData);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	tournVectorData.clear();
	tableVectorData.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY::equals(const Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		tournVectorData.equals(_o.tournVectorData) &&
		tableVectorData.equals(_o.tableVectorData);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_TOURN_IT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("tournVectorData=");
		tournVectorData.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tableVectorData=");
		tableVectorData.toTraceString(_buf);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		tournVectorData.composeMsg(_msg);
		tableVectorData.composeMsg(_msg);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		tournVectorData.parseMsg(_parser);
		tableVectorData.parseMsg(_parser);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TOURN_IT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szTournVectorData = ThinAtf::LAtfVector< ITTournVectorData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournVectorData"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tournVectorData", szTournVectorData, _checker, __FILE__, __LINE__);
		int szTableVectorData = ThinAtf::LAtfVector< ITTableVectorData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableVectorData"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tableVectorData", szTableVectorData, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_VALIDATE_MOBILE
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE::Protocol_MSG_LOBBY_VALIDATE_MOBILE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE::Protocol_MSG_LOBBY_VALIDATE_MOBILE(Protocol_MSG_LOBBY_VALIDATE_MOBILE&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, unique(std::move(_o.unique))
{
}

Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE& Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE::operator=(Protocol_MSG_LOBBY_VALIDATE_MOBILE&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		unique = std::move(_o.unique);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE::clear()
{
	notUsedStr.clear();
	unique = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE::equals(const Protocol_MSG_LOBBY_VALIDATE_MOBILE& _o) const
{
	return notUsedStr.equals(_o.notUsedStr) &&
		unique == _o.unique;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_VALIDATE_MOBILE).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("unique=");
	_buf.appendUint(unique);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(notUsedStr);
	_msg.composeUINT32(unique);
}

void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseUINT32(unique);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_VALIDATE_MOBILE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	UINT32 unique; _parser.parseUINT32(unique);
	AtfValidator::validateInt(_descr, "unique", unique, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY::Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY::Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY(Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY& Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY::operator=(Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY::equals(const Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_VALIDATE_MOBILE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_VALIDATE_MOBILE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR(Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR&& _o)
	: originalError(std::move(_o.originalError))
{
}

Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR& Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR::operator=(Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR&& _o)
{
	if(this != &_o)
	{
		originalError = std::move(_o.originalError);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR::clear()
{
	originalError.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR::equals(const Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR& _o) const
{
	return originalError.equals(_o.originalError);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_SELFEXCLUDED_STR).append(")");
	_buf.append(',');
	_buf.append("originalError=");
	_buf.append(originalError);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(originalError);
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseStringP(originalError);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_SELFEXCLUDED_STR";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "originalError"); size_t szOriginalError = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "originalError", szOriginalError, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY(Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY& Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY::operator=(Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY::equals(const Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errDesc=");
	_buf.append(errDesc);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errDesc);
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(errDesc);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL::clear()
{
	validationCode = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL::equals(const Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL& _o) const
{
	return validationCode == _o.validationCode;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_VALIDATE_NEWINSTALL).append(")");
	_buf.append(',');
	_buf.append("validationCode=");
	_buf.appendUint(validationCode);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(validationCode);
}

void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(validationCode);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_VALIDATE_NEWINSTALL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 validationCode; _parser.parseUINT32(validationCode);
	AtfValidator::validateInt(_descr, "validationCode", validationCode, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY(Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY& Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY::operator=(Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY::equals(const Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE::clear()
{
}

bool Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE::equals(const Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE& _o) const
{
	return true;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE).append(")");
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE::composeMsg(CommMsgBody& _msg) const
{
}

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY(Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY& Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY::operator=(Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY::equals(const Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    UserProperties
//=================================================================

Lobby::cli::UserProperties::UserProperties()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::UserProperties::UserProperties(UserProperties&& _o)
	: propType(std::move(_o.propType))
	, propInt(std::move(_o.propInt))
	, propStr(std::move(_o.propStr))
	, when(std::move(_o.when))
{
}

Lobby::cli::UserProperties& Lobby::cli::UserProperties::operator=(UserProperties&& _o)
{
	if(this != &_o)
	{
		propType = std::move(_o.propType);
		propInt = std::move(_o.propInt);
		propStr = std::move(_o.propStr);
		when = std::move(_o.when);
	}
	return *this;
}

#endif

void Lobby::cli::UserProperties::clear()
{
	propType = 0;
	propInt = 0;
	propStr.clear();
	when.setNull();
}

bool Lobby::cli::UserProperties::equals(const UserProperties& _o) const
{
	return propType == _o.propType &&
		propInt == _o.propInt &&
		propStr.equals(_o.propStr) &&
		when.equals(_o.when);
}

const char *Lobby::cli::UserProperties::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("propType=");
	_buf.appendInt(propType);
	_buf.append(',');
	_buf.append("propInt=");
	_buf.appendInt(propInt);
	_buf.append(',');
	_buf.append("propStr=");
	_buf.append(propStr);
	_buf.append(',');
	_buf.append("when=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, when);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::UserProperties::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(propType);
	_msg.composeINT32(propInt);
	_msg.composeString(propStr);
	_msg.composeSrvTime(when);
}

void Lobby::cli::UserProperties::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(propType);
	_parser.parseINT32(propInt);
	_parser.parseStringP(propStr);
	_parser.parseSrvTime(when);
}

/*static*/ void Lobby::cli::UserProperties::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	INT32 propType; _parser.parseINT32(propType);
	AtfValidator::validateInt(_descr, "propType", propType, _checker, __FILE__, __LINE__);
	INT32 propInt; _parser.parseINT32(propInt);
	AtfValidator::validateInt(_descr, "propInt", propInt, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "propStr"); size_t szPropStr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "propStr", szPropStr, _checker, __FILE__, __LINE__);
	SrvTime when; _parser.parseSrvTime(when);
	AtfValidator::validateSrvDateTime(_descr, "when", when, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    PhoneValidationInfo
//=================================================================

Lobby::cli::PhoneValidationInfo::PhoneValidationInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::PhoneValidationInfo::PhoneValidationInfo(PhoneValidationInfo&& _o)
	: validation(std::move(_o.validation))
	, countryCode(std::move(_o.countryCode))
	, verifiedNumber(std::move(_o.verifiedNumber))
	, dialingInfo(std::move(_o.dialingInfo))
	, phone(std::move(_o.phone))
{
}

Lobby::cli::PhoneValidationInfo& Lobby::cli::PhoneValidationInfo::operator=(PhoneValidationInfo&& _o)
{
	if(this != &_o)
	{
		validation = std::move(_o.validation);
		countryCode = std::move(_o.countryCode);
		verifiedNumber = std::move(_o.verifiedNumber);
		dialingInfo = std::move(_o.dialingInfo);
		phone = std::move(_o.phone);
	}
	return *this;
}

#endif

void Lobby::cli::PhoneValidationInfo::clear()
{
	validation = 0;
	countryCode.clear();
	verifiedNumber.clear();
	dialingInfo.clear();
	phone.clear();
}

bool Lobby::cli::PhoneValidationInfo::equals(const PhoneValidationInfo& _o) const
{
	return validation == _o.validation &&
		countryCode.equals(_o.countryCode) &&
		verifiedNumber.equals(_o.verifiedNumber) &&
		dialingInfo.equals(_o.dialingInfo) &&
		phone.equals(_o.phone);
}

const char *Lobby::cli::PhoneValidationInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("validation=");
	_buf.appendUint(validation);
	_buf.append(',');
	_buf.append("countryCode=");
	_buf.append(countryCode);
	_buf.append(',');
	_buf.append("verifiedNumber=");
	_buf.append(verifiedNumber);
	_buf.append(',');
	_buf.append("dialingInfo=");
	_buf.append(dialingInfo);
	_buf.append(',');
	_buf.append("phone=");
	_buf.append(phone);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::cli::PhoneValidationInfo::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(PhoneValidationInfo())) // not empty
	{
		_body.composeBYTE(validation);
		_body.composeString(countryCode);
		_body.composeString(verifiedNumber);
		_body.composeString(dialingInfo);
		_body.composeString(phone);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::cli::PhoneValidationInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(validation);
	_parser0.parseStringP(countryCode);
	_parser0.parseStringP(verifiedNumber);
	_parser0.parseStringP(dialingInfo);
	_parser0.parseStringP(phone);
}

/*static*/ void Lobby::cli::PhoneValidationInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	BYTE validation; _parser0.parseBYTE(validation);
	AtfValidator::validateInt(_descr, "validation", validation, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "countryCode"); size_t szCountryCode = strlen(_dummy);
	AtfValidator::validateInt(_descr, "countryCode", szCountryCode, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "verifiedNumber"); size_t szVerifiedNumber = strlen(_dummy);
	AtfValidator::validateInt(_descr, "verifiedNumber", szVerifiedNumber, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "dialingInfo"); size_t szDialingInfo = strlen(_dummy);
	AtfValidator::validateInt(_descr, "dialingInfo", szDialingInfo, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "phone"); size_t szPhone = strlen(_dummy);
	AtfValidator::validateInt(_descr, "phone", szPhone, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_USER_INFO
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO::Protocol_MSG_LOBBY_GET_USER_INFO()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO::Protocol_MSG_LOBBY_GET_USER_INFO(Protocol_MSG_LOBBY_GET_USER_INFO&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, needImage(std::move(_o.needImage))
	, needPwdUpdate(std::move(_o.needPwdUpdate))
{
}

Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO& Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO::operator=(Protocol_MSG_LOBBY_GET_USER_INFO&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		needImage = std::move(_o.needImage);
		needPwdUpdate = std::move(_o.needPwdUpdate);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO::clear()
{
	notUsedStr.clear();
	needImage = false;
	needPwdUpdate = false;
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO::equals(const Protocol_MSG_LOBBY_GET_USER_INFO& _o) const
{
	return notUsedStr.equals(_o.notUsedStr) &&
		needImage == _o.needImage &&
		needPwdUpdate == _o.needPwdUpdate;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_USER_INFO).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("needImage=");
	_buf.appendUint(needImage);
	_buf.append(',');
	_buf.append("needPwdUpdate=");
	_buf.appendUint(needPwdUpdate);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(notUsedStr);
	_msg.composeBOOL(needImage);
	_msg.composeBOOL(needPwdUpdate);
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(needImage);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(needPwdUpdate);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_USER_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool needImage; _parser.parseBOOL(needImage);
	AtfValidator::validateInt(_descr, "needImage", needImage, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool needPwdUpdate; _parser.parseBOOL(needPwdUpdate);
	AtfValidator::validateInt(_descr, "needPwdUpdate", needPwdUpdate, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_USER_INFO_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO_REPLY::Protocol_MSG_LOBBY_GET_USER_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO_REPLY::Protocol_MSG_LOBBY_GET_USER_INFO_REPLY(Protocol_MSG_LOBBY_GET_USER_INFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, fullName1(std::move(_o.fullName1))
	, fullName2(std::move(_o.fullName2))
	, fullName3(std::move(_o.fullName3))
	, fullName4(std::move(_o.fullName4))
	, fullName5(std::move(_o.fullName5))
	, fullName6(std::move(_o.fullName6))
	, fullName7(std::move(_o.fullName7))
	, fullName8(std::move(_o.fullName8))
	, imgData(std::move(_o.imgData))
	, priv1(std::move(_o.priv1))
	, priv2(std::move(_o.priv2))
	, priv3(std::move(_o.priv3))
	, priv4(std::move(_o.priv4))
	, priv5(std::move(_o.priv5))
	, priv6(std::move(_o.priv6))
	, priv7(std::move(_o.priv7))
	, dob(std::move(_o.dob))
	, phoneNum(std::move(_o.phoneNum))
	, phoneValidation(std::move(_o.phoneValidation))
	, firstName(std::move(_o.firstName))
	, onlyLastName(std::move(_o.onlyLastName))
	, fiscalCode(std::move(_o.fiscalCode))
	, userProps(std::move(_o.userProps))
	, flags2(std::move(_o.flags2))
	, imgId(std::move(_o.imgId))
	, sex(std::move(_o.sex))
	, mobile(std::move(_o.mobile))
	, addressStateLocked(std::move(_o.addressStateLocked))
	, registered(std::move(_o.registered))
	, mobilePhoneValidation(std::move(_o.mobilePhoneValidation))
	, promoImgCode(std::move(_o.promoImgCode))
	, pwdUpdateTime(std::move(_o.pwdUpdateTime))
	, privileges3(std::move(_o.privileges3))
	, missedMonths(std::move(_o.missedMonths))
	, vipStatusUntil(std::move(_o.vipStatusUntil))
	, missableMonthsYearly(std::move(_o.missableMonthsYearly))
	, gameAvatars(std::move(_o.gameAvatars))
{
}

Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO_REPLY& Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO_REPLY::operator=(Protocol_MSG_LOBBY_GET_USER_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		fullName1 = std::move(_o.fullName1);
		fullName2 = std::move(_o.fullName2);
		fullName3 = std::move(_o.fullName3);
		fullName4 = std::move(_o.fullName4);
		fullName5 = std::move(_o.fullName5);
		fullName6 = std::move(_o.fullName6);
		fullName7 = std::move(_o.fullName7);
		fullName8 = std::move(_o.fullName8);
		imgData = std::move(_o.imgData);
		priv1 = std::move(_o.priv1);
		priv2 = std::move(_o.priv2);
		priv3 = std::move(_o.priv3);
		priv4 = std::move(_o.priv4);
		priv5 = std::move(_o.priv5);
		priv6 = std::move(_o.priv6);
		priv7 = std::move(_o.priv7);
		dob = std::move(_o.dob);
		phoneNum = std::move(_o.phoneNum);
		phoneValidation = std::move(_o.phoneValidation);
		firstName = std::move(_o.firstName);
		onlyLastName = std::move(_o.onlyLastName);
		fiscalCode = std::move(_o.fiscalCode);
		userProps = std::move(_o.userProps);
		flags2 = std::move(_o.flags2);
		imgId = std::move(_o.imgId);
		sex = std::move(_o.sex);
		mobile = std::move(_o.mobile);
		addressStateLocked = std::move(_o.addressStateLocked);
		registered = std::move(_o.registered);
		mobilePhoneValidation = std::move(_o.mobilePhoneValidation);
		promoImgCode = std::move(_o.promoImgCode);
		pwdUpdateTime = std::move(_o.pwdUpdateTime);
		privileges3 = std::move(_o.privileges3);
		missedMonths = std::move(_o.missedMonths);
		vipStatusUntil = std::move(_o.vipStatusUntil);
		missableMonthsYearly = std::move(_o.missableMonthsYearly);
		gameAvatars = std::move(_o.gameAvatars);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	fullName1.clear();
	fullName2.clear();
	fullName3.clear();
	fullName4.clear();
	fullName5.clear();
	fullName6.clear();
	fullName7.clear();
	fullName8.clear();
	imgData.clear();
	priv1 = 0;
	priv2 = 0;
	priv3 = 0;
	priv4 = 0;
	priv5 = 0;
	priv6 = 0;
	priv7 = 0;
	dob.setNull();
	phoneNum.clear();
	phoneValidation.clear();
	firstName.clear();
	onlyLastName.clear();
	fiscalCode.clear();
	userProps.clear();
	flags2 = 0;
	imgId = 0;
	sex.clear();
	mobile.clear();
	addressStateLocked = false;
	registered.setNull();
	mobilePhoneValidation.clear();
	promoImgCode.clear();
	pwdUpdateTime = 0;
	privileges3 = 0;
	missedMonths = 0;
	vipStatusUntil.setNull();
	missableMonthsYearly = 0;
	gameAvatars.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO_REPLY::equals(const Protocol_MSG_LOBBY_GET_USER_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		fullName1.equals(_o.fullName1) &&
		fullName2.equals(_o.fullName2) &&
		fullName3.equals(_o.fullName3) &&
		fullName4.equals(_o.fullName4) &&
		fullName5.equals(_o.fullName5) &&
		fullName6.equals(_o.fullName6) &&
		fullName7.equals(_o.fullName7) &&
		fullName8.equals(_o.fullName8) &&
		imgData.size() == _o.imgData.size() && memcmp(imgData.ptr(), _o.imgData.ptr(), imgData.size()) == 0 &&
		priv1 == _o.priv1 &&
		priv2 == _o.priv2 &&
		priv3 == _o.priv3 &&
		priv4 == _o.priv4 &&
		priv5 == _o.priv5 &&
		priv6 == _o.priv6 &&
		priv7 == _o.priv7 &&
		dob.equals(_o.dob) &&
		phoneNum.equals(_o.phoneNum) &&
		phoneValidation.equals(_o.phoneValidation) &&
		firstName.equals(_o.firstName) &&
		onlyLastName.equals(_o.onlyLastName) &&
		fiscalCode.equals(_o.fiscalCode) &&
		userProps.equals(_o.userProps) &&
		flags2 == _o.flags2 &&
		imgId == _o.imgId &&
		sex.equals(_o.sex) &&
		mobile.equals(_o.mobile) &&
		addressStateLocked == _o.addressStateLocked &&
		registered.equals(_o.registered) &&
		mobilePhoneValidation.equals(_o.mobilePhoneValidation) &&
		promoImgCode.equals(_o.promoImgCode) &&
		pwdUpdateTime == _o.pwdUpdateTime &&
		privileges3 == _o.privileges3 &&
		missedMonths == _o.missedMonths &&
		vipStatusUntil.equals(_o.vipStatusUntil) &&
		missableMonthsYearly == _o.missableMonthsYearly &&
		gameAvatars.equals(_o.gameAvatars);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_USER_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("fullName1=");
		_buf.append(fullName1);
		_buf.append(',');
		_buf.append("fullName2=");
		_buf.append(fullName2);
		_buf.append(',');
		_buf.append("fullName3=");
		_buf.append(fullName3);
		_buf.append(',');
		_buf.append("fullName4=");
		_buf.append(fullName4);
		_buf.append(',');
		_buf.append("fullName5=");
		_buf.append(fullName5);
		_buf.append(',');
		_buf.append("fullName6=");
		_buf.append(fullName6);
		_buf.append(',');
		_buf.append("fullName7=");
		_buf.append(fullName7);
		_buf.append(',');
		_buf.append("fullName8=");
		_buf.append(fullName8);
		_buf.append(',');
		_buf.append("imgData=");
		ThinAtf::AtfTempl<PBlock>::ToTraceString(_buf, imgData);
		_buf.append(',');
		_buf.append("priv1=");
		_buf.appendUint(priv1);
		_buf.append(',');
		_buf.append("priv2=");
		_buf.appendUint(priv2);
		_buf.append(',');
		_buf.append("priv3=");
		_buf.appendUint(priv3);
		_buf.append(',');
		_buf.append("priv4=");
		_buf.appendUint(priv4);
		_buf.append(',');
		_buf.append("priv5=");
		_buf.appendUint(priv5);
		_buf.append(',');
		_buf.append("priv6=");
		_buf.appendUint(priv6);
		_buf.append(',');
		_buf.append("priv7=");
		_buf.appendUint(priv7);
		_buf.append(',');
		_buf.append("dob=");
		ThinAtf::AtfTempl<SrvDate>::ToTraceString(_buf, dob);
		_buf.append(',');
		_buf.append("phoneNum=");
		_buf.append(phoneNum);
		_buf.append(',');
		_buf.append("phoneValidation=");
		phoneValidation.toTraceString(_buf);
		_buf.append(',');
		_buf.append("firstName=");
		_buf.append(firstName);
		_buf.append(',');
		_buf.append("onlyLastName=");
		_buf.append(onlyLastName);
		_buf.append(',');
		_buf.append("fiscalCode=");
		_buf.append(fiscalCode);
		_buf.append(',');
		_buf.append("userProps=");
		userProps.toTraceString(_buf);
		_buf.append(',');
		_buf.append("flags2=");
		_buf.appendUint64(flags2);
		_buf.append(',');
		_buf.append("imgId=");
		_buf.appendUint(imgId);
		_buf.append(',');
		_buf.append("sex=");
		_buf.append(sex);
		_buf.append(',');
		_buf.append("mobile=");
		_buf.append(mobile);
		_buf.append(',');
		_buf.append("addressStateLocked=");
		_buf.appendUint(addressStateLocked);
		_buf.append(',');
		_buf.append("registered=");
		ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, registered);
		_buf.append(',');
		_buf.append("mobilePhoneValidation=");
		mobilePhoneValidation.toTraceString(_buf);
		_buf.append(',');
		_buf.append("promoImgCode=");
		_buf.append(promoImgCode);
		_buf.append(',');
		_buf.append("pwdUpdateTime=");
		_buf.appendUint(pwdUpdateTime);
		_buf.append(',');
		_buf.append("privileges3=");
		_buf.appendUint64(privileges3);
		_buf.append(',');
		_buf.append("missedMonths=");
		_buf.appendInt(missedMonths);
		_buf.append(',');
		_buf.append("vipStatusUntil=");
		ThinAtf::AtfTempl<SrvDate>::ToTraceString(_buf, vipStatusUntil);
		_buf.append(',');
		_buf.append("missableMonthsYearly=");
		_buf.appendInt(missableMonthsYearly);
		_buf.append(',');
		_buf.append("gameAvatars=");
		gameAvatars.toTraceString(_buf);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(fullName1);
		_msg.composeString(fullName2);
		_msg.composeString(fullName3);
		_msg.composeString(fullName4);
		_msg.composeString(fullName5);
		_msg.composeString(fullName6);
		_msg.composeString(fullName7);
		_msg.composeString(fullName8);
		_msg._composeVarBlock(imgData.ptr(), imgData.size());
		_msg.composeUINT32(priv1);
		_msg.composeUINT32(priv2);
		_msg.composeUINT32(priv3);
		_msg.composeUINT32(priv4);
		_msg.composeUINT32(priv5);
		_msg.composeUINT32(priv6);
		_msg.composeUINT32(priv7);
		_msg.composeSrvDate(dob);
		_msg.composeString(phoneNum);
		phoneValidation.composeMsg(_msg);
		_msg.composeString(firstName);
		_msg.composeString(onlyLastName);
		_msg.composeString(fiscalCode);
		userProps.composeMsg(_msg);
		_msg.composeUINT64(flags2);
		_msg.composeUINT32(imgId);
		_msg.composeString(sex);
		_msg.composeString(mobile);
		_msg.composeBOOL(addressStateLocked);
		_msg.composeSrvTime(registered);
		mobilePhoneValidation.composeMsg(_msg);
		_msg.composeString(promoImgCode);
		_msg.composeUINT32(pwdUpdateTime);
		_msg.composeUINT64(privileges3);
		_msg.composeINT8(missedMonths);
		_msg.composeSrvDate(vipStatusUntil);
		_msg.composeINT8(missableMonthsYearly);
		gameAvatars.composeMsg(_msg);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(fullName1);
		_parser.parseStringP(fullName2);
		_parser.parseStringP(fullName3);
		_parser.parseStringP(fullName4);
		_parser.parseStringP(fullName5);
		_parser.parseStringP(fullName6);
		_parser.parseStringP(fullName7);
		_parser.parseStringP(fullName8);
		_parser.parsePBlock(imgData);
		_parser.parseUINT32(priv1);
		_parser.parseUINT32(priv2);
		_parser.parseUINT32(priv3);
		_parser.parseUINT32(priv4);
		_parser.parseUINT32(priv5);
		_parser.parseUINT32(priv6);
		_parser.parseUINT32(priv7);
		_parser.parseSrvDate(dob);
		_parser.parseStringP(phoneNum);
		phoneValidation.parseMsg(_parser);
		_parser.parseStringP(firstName);
		_parser.parseStringP(onlyLastName);
		_parser.parseStringP(fiscalCode);
		userProps.parseMsg(_parser);
		_parser.parseUINT64(flags2);
		_parser.parseUINT32(imgId);
		_parser.parseStringP(sex);
		_parser.parseStringP(mobile);
		_parser.parseBOOL(addressStateLocked);
		_parser.parseSrvTime(registered);
		mobilePhoneValidation.parseMsg(_parser);
		_parser.parseStringP(promoImgCode);
		_parser.parseUINT32(pwdUpdateTime);
		_parser.parseUINT64(privileges3);
		_parser.parseINT8(missedMonths);
		_parser.parseSrvDate(vipStatusUntil);
		_parser.parseINT8(missableMonthsYearly);
		gameAvatars.parseMsg(_parser);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_USER_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "fullName1"); size_t szFullName1 = strlen(_dummy);
		AtfValidator::validateInt(_descr, "fullName1", szFullName1, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "fullName2"); size_t szFullName2 = strlen(_dummy);
		AtfValidator::validateInt(_descr, "fullName2", szFullName2, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "fullName3"); size_t szFullName3 = strlen(_dummy);
		AtfValidator::validateInt(_descr, "fullName3", szFullName3, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "fullName4"); size_t szFullName4 = strlen(_dummy);
		AtfValidator::validateInt(_descr, "fullName4", szFullName4, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "fullName5"); size_t szFullName5 = strlen(_dummy);
		AtfValidator::validateInt(_descr, "fullName5", szFullName5, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "fullName6"); size_t szFullName6 = strlen(_dummy);
		AtfValidator::validateInt(_descr, "fullName6", szFullName6, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "fullName7"); size_t szFullName7 = strlen(_dummy);
		AtfValidator::validateInt(_descr, "fullName7", szFullName7, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "fullName8"); size_t szFullName8 = strlen(_dummy);
		AtfValidator::validateInt(_descr, "fullName8", szFullName8, _checker, __FILE__, __LINE__);
		const BYTE* imgData; size_t szImgData; _parser._parseVarBlock(imgData, szImgData);  /*imgData*/
		AtfValidator::validateInt(_descr, "imgData", szImgData, _checker, __FILE__, __LINE__);
		UINT32 priv1; _parser.parseUINT32(priv1);
		AtfValidator::validateInt(_descr, "priv1", priv1, _checker, __FILE__, __LINE__);
		UINT32 priv2; _parser.parseUINT32(priv2);
		AtfValidator::validateInt(_descr, "priv2", priv2, _checker, __FILE__, __LINE__);
		UINT32 priv3; _parser.parseUINT32(priv3);
		AtfValidator::validateInt(_descr, "priv3", priv3, _checker, __FILE__, __LINE__);
		UINT32 priv4; _parser.parseUINT32(priv4);
		AtfValidator::validateInt(_descr, "priv4", priv4, _checker, __FILE__, __LINE__);
		UINT32 priv5; _parser.parseUINT32(priv5);
		AtfValidator::validateInt(_descr, "priv5", priv5, _checker, __FILE__, __LINE__);
		UINT32 priv6; _parser.parseUINT32(priv6);
		AtfValidator::validateInt(_descr, "priv6", priv6, _checker, __FILE__, __LINE__);
		UINT32 priv7; _parser.parseUINT32(priv7);
		AtfValidator::validateInt(_descr, "priv7", priv7, _checker, __FILE__, __LINE__);
		SrvDate dob; _parser.parseSrvDate(dob);
		AtfValidator::validateSrvDateTime(_descr, "dob", dob, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "phoneNum"); size_t szPhoneNum = strlen(_dummy);
		AtfValidator::validateInt(_descr, "phoneNum", szPhoneNum, _checker, __FILE__, __LINE__);
		PString _descbuf;
		PhoneValidationInfo::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("phoneValidation"), _fieldsWithUnparsedContent);
		_parser.parseStringN(_dummy, 0, "firstName"); size_t szFirstName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "firstName", szFirstName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "onlyLastName"); size_t szOnlyLastName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "onlyLastName", szOnlyLastName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "fiscalCode"); size_t szFiscalCode = strlen(_dummy);
		AtfValidator::validateInt(_descr, "fiscalCode", szFiscalCode, _checker, __FILE__, __LINE__);
		int szUserProps = ThinAtf::LAtfVector< UserProperties, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("userProps"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "userProps", szUserProps, _checker, __FILE__, __LINE__);
		UINT64 flags2; _parser.parseUINT64(flags2);
		AtfValidator::validateUint(_descr, "flags2", flags2, _checker, __FILE__, __LINE__);
		UINT32 imgId; _parser.parseUINT32(imgId);
		AtfValidator::validateInt(_descr, "imgId", imgId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "sex"); size_t szSex = strlen(_dummy);
		AtfValidator::validateInt(_descr, "sex", szSex, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "mobile"); size_t szMobile = strlen(_dummy);
		AtfValidator::validateInt(_descr, "mobile", szMobile, _checker, __FILE__, __LINE__);
		bool addressStateLocked; _parser.parseBOOL(addressStateLocked);
		AtfValidator::validateInt(_descr, "addressStateLocked", addressStateLocked, _checker, __FILE__, __LINE__);
		SrvTime registered; _parser.parseSrvTime(registered);
		AtfValidator::validateSrvDateTime(_descr, "registered", registered, _checker, __FILE__, __LINE__);
		PhoneValidationInfo::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("mobilePhoneValidation"), _fieldsWithUnparsedContent);
		_parser.parseStringN(_dummy, 0, "promoImgCode"); size_t szPromoImgCode = strlen(_dummy);
		AtfValidator::validateInt(_descr, "promoImgCode", szPromoImgCode, _checker, __FILE__, __LINE__);
		UINT32 pwdUpdateTime; _parser.parseUINT32(pwdUpdateTime);
		AtfValidator::validateInt(_descr, "pwdUpdateTime", pwdUpdateTime, _checker, __FILE__, __LINE__);
		UINT64 privileges3; _parser.parseUINT64(privileges3);
		AtfValidator::validateUint(_descr, "privileges3", privileges3, _checker, __FILE__, __LINE__);
		INT8 missedMonths; _parser.parseINT8(missedMonths);
		AtfValidator::validateInt(_descr, "missedMonths", missedMonths, _checker, __FILE__, __LINE__);
		SrvDate vipStatusUntil; _parser.parseSrvDate(vipStatusUntil);
		AtfValidator::validateSrvDateTime(_descr, "vipStatusUntil", vipStatusUntil, _checker, __FILE__, __LINE__);
		INT8 missableMonthsYearly; _parser.parseINT8(missableMonthsYearly);
		AtfValidator::validateInt(_descr, "missableMonthsYearly", missableMonthsYearly, _checker, __FILE__, __LINE__);
		int szGameAvatars = ThinAtf::LAtfVector< BrandProtThin::AvatarImg, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("gameAvatars"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "gameAvatars", szGameAvatars, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_WAITING_LIST
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST::Protocol_MSG_LOBBY_WAITING_LIST()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST::Protocol_MSG_LOBBY_WAITING_LIST(Protocol_MSG_LOBBY_WAITING_LIST&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, listType(std::move(_o.listType))
	, tableId32(std::move(_o.tableId32))
	, tableId64(std::move(_o.tableId64))
{
}

Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST& Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST::operator=(Protocol_MSG_LOBBY_WAITING_LIST&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		listType = std::move(_o.listType);
		tableId32 = std::move(_o.tableId32);
		tableId64 = std::move(_o.tableId64);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST::clear()
{
	notUsedStr.clear();
	listType = 0;
	tableId32 = 0;
	tableId64 = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST::equals(const Protocol_MSG_LOBBY_WAITING_LIST& _o) const
{
	return notUsedStr.equals(_o.notUsedStr) &&
		listType == _o.listType &&
		tableId32 == _o.tableId32 &&
		tableId64 == _o.tableId64;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_WAITING_LIST).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("listType=");
	_buf.appendUint(listType);
	_buf.append(',');
	_buf.append("tableId32=");
	_buf.appendUint(tableId32);
	_buf.append(',');
	_buf.append("tableId64=");
	_buf.appendUint64(tableId64);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(notUsedStr);
	_msg.composeBYTE(listType);
	_msg.composeUINT32(tableId32);
	_msg.composeUINT64(tableId64);
}

void Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseBYTE(listType);
	_parser.parseUINT32(tableId32);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(tableId64);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_WAITING_LIST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	BYTE listType; _parser.parseBYTE(listType);
	AtfValidator::validateInt(_descr, "listType", listType, _checker, __FILE__, __LINE__);
	UINT32 tableId32; _parser.parseUINT32(tableId32);
	AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 tableId64; _parser.parseUINT64(tableId64);
	AtfValidator::validateUint(_descr, "tableId64", tableId64, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_WAITING_LIST_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST_REPLY::Protocol_MSG_LOBBY_WAITING_LIST_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST_REPLY::Protocol_MSG_LOBBY_WAITING_LIST_REPLY(Protocol_MSG_LOBBY_WAITING_LIST_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, tableId32(std::move(_o.tableId32))
	, tableId64(std::move(_o.tableId64))
{
}

Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST_REPLY& Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST_REPLY::operator=(Protocol_MSG_LOBBY_WAITING_LIST_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		tableId32 = std::move(_o.tableId32);
		tableId64 = std::move(_o.tableId64);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	tableId32 = 0;
	tableId64 = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST_REPLY::equals(const Protocol_MSG_LOBBY_WAITING_LIST_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		tableId32 == _o.tableId32 &&
		tableId64 == _o.tableId64;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_WAITING_LIST_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("tableId32=");
		_buf.appendUint(tableId32);
		_buf.append(',');
		_buf.append("tableId64=");
		_buf.appendUint64(tableId64);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(tableId32);
		_msg.composeUINT64(tableId64);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(tableId32);
		_parser.parseUINT64(tableId64);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_WAITING_LIST_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 tableId32; _parser.parseUINT32(tableId32);
		AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
		UINT64 tableId64; _parser.parseUINT64(tableId64);
		AtfValidator::validateUint(_descr, "tableId64", tableId64, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_LIST_REMOVE
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_LIST_REMOVE::Protocol_MSG_LOBBY_LIST_REMOVE()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_LIST_REMOVE::clear()
{
}

bool Lobby::cli::Protocol_MSG_LOBBY_LIST_REMOVE::equals(const Protocol_MSG_LOBBY_LIST_REMOVE& _o) const
{
	return true;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_LIST_REMOVE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_LIST_REMOVE).append(")");
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_LIST_REMOVE::composeMsg(CommMsgBody& _msg) const
{
}

void Lobby::cli::Protocol_MSG_LOBBY_LIST_REMOVE::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_LIST_REMOVE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_LIST_REMOVE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_LEAVE_WAITING_LIST
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST(Protocol_MSG_LOBBY_LEAVE_WAITING_LIST&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, listType(std::move(_o.listType))
	, tableId32(std::move(_o.tableId32))
	, tableId64(std::move(_o.tableId64))
{
}

Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST& Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST::operator=(Protocol_MSG_LOBBY_LEAVE_WAITING_LIST&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		listType = std::move(_o.listType);
		tableId32 = std::move(_o.tableId32);
		tableId64 = std::move(_o.tableId64);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST::clear()
{
	notUsedStr.clear();
	listType = 0;
	tableId32 = 0;
	tableId64 = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST::equals(const Protocol_MSG_LOBBY_LEAVE_WAITING_LIST& _o) const
{
	return notUsedStr.equals(_o.notUsedStr) &&
		listType == _o.listType &&
		tableId32 == _o.tableId32 &&
		tableId64 == _o.tableId64;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_LEAVE_WAITING_LIST).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("listType=");
	_buf.appendUint(listType);
	_buf.append(',');
	_buf.append("tableId32=");
	_buf.appendUint(tableId32);
	_buf.append(',');
	_buf.append("tableId64=");
	_buf.appendUint64(tableId64);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(notUsedStr);
	_msg.composeBYTE(listType);
	_msg.composeUINT32(tableId32);
	_msg.composeUINT64(tableId64);
}

void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseBYTE(listType);
	_parser.parseUINT32(tableId32);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(tableId64);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_LEAVE_WAITING_LIST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	BYTE listType; _parser.parseBYTE(listType);
	AtfValidator::validateInt(_descr, "listType", listType, _checker, __FILE__, __LINE__);
	UINT32 tableId32; _parser.parseUINT32(tableId32);
	AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 tableId64; _parser.parseUINT64(tableId64);
	AtfValidator::validateUint(_descr, "tableId64", tableId64, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY(Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, tableId32(std::move(_o.tableId32))
	, tableId(std::move(_o.tableId))
{
}

Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY& Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY::operator=(Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		tableId32 = std::move(_o.tableId32);
		tableId = std::move(_o.tableId);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	tableId32 = 0;
	tableId = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY::equals(const Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		tableId32 == _o.tableId32 &&
		tableId == _o.tableId;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_LEAVE_WAITING_LIST_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("tableId32=");
		_buf.appendUint(tableId32);
		_buf.append(',');
		_buf.append("tableId=");
		_buf.appendUint64(tableId);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(tableId32);
		_msg.composeUINT64(tableId);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(tableId32);
		_parser.parseUINT64(tableId);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_LEAVE_WAITING_LIST_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 tableId32; _parser.parseUINT32(tableId32);
		AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
		UINT64 tableId; _parser.parseUINT64(tableId);
		AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS::clear()
{
	flags = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS::equals(const Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS& _o) const
{
	return flags == _o.flags;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_LEAVE_ALL_WAITING_LISTS).append(")");
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendInt(flags);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(flags);
}

void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseINT32(flags);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_LEAVE_ALL_WAITING_LISTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(_parser.parseEnded()) return;
	INT32 flags; _parser.parseINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY(Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, numTables(std::move(_o.numTables))
	, flags(std::move(_o.flags))
{
}

Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY& Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY::operator=(Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		numTables = std::move(_o.numTables);
		flags = std::move(_o.flags);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	numTables = 0;
	flags = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY::equals(const Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		numTables == _o.numTables &&
		flags == _o.flags;
}

const char *Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("numTables=");
		_buf.appendUint(numTables);
		_buf.append(',');
		_buf.append("flags=");
		_buf.appendUint(flags);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(numTables);
		_msg.composeUINT32(flags);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(numTables);
		_parser.parseUINT32(flags);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 numTables; _parser.parseUINT32(numTables);
		AtfValidator::validateInt(_descr, "numTables", numTables, _checker, __FILE__, __LINE__);
		UINT32 flags; _parser.parseUINT32(flags);
		AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_WAITING_INVITED_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_WAITING_INVITED_REPLY::Protocol_MSG_WAITING_INVITED_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_WAITING_INVITED_REPLY::Protocol_MSG_WAITING_INVITED_REPLY(Protocol_MSG_WAITING_INVITED_REPLY&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, tableId32(std::move(_o.tableId32))
	, answer(std::move(_o.answer))
	, leaveLists(std::move(_o.leaveLists))
	, tableId64(std::move(_o.tableId64))
{
}

Lobby::cli::Protocol_MSG_WAITING_INVITED_REPLY& Lobby::cli::Protocol_MSG_WAITING_INVITED_REPLY::operator=(Protocol_MSG_WAITING_INVITED_REPLY&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		tableId32 = std::move(_o.tableId32);
		answer = std::move(_o.answer);
		leaveLists = std::move(_o.leaveLists);
		tableId64 = std::move(_o.tableId64);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_WAITING_INVITED_REPLY::clear()
{
	notUsedStr.clear();
	tableId32 = 0;
	answer = 0;
	leaveLists = false;
	tableId64 = 0;
}

bool Lobby::cli::Protocol_MSG_WAITING_INVITED_REPLY::equals(const Protocol_MSG_WAITING_INVITED_REPLY& _o) const
{
	return notUsedStr.equals(_o.notUsedStr) &&
		tableId32 == _o.tableId32 &&
		answer == _o.answer &&
		leaveLists == _o.leaveLists &&
		tableId64 == _o.tableId64;
}

const char *Lobby::cli::Protocol_MSG_WAITING_INVITED_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_WAITING_INVITED_REPLY).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("tableId32=");
	_buf.appendUint(tableId32);
	_buf.append(',');
	_buf.append("answer=");
	_buf.appendUint(answer);
	_buf.append(',');
	_buf.append("leaveLists=");
	_buf.appendUint(leaveLists);
	_buf.append(',');
	_buf.append("tableId64=");
	_buf.appendUint64(tableId64);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_WAITING_INVITED_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(notUsedStr);
	_msg.composeUINT32(tableId32);
	_msg.composeBYTE(answer);
	_msg.composeBOOL(leaveLists);
	_msg.composeUINT64(tableId64);
}

void Lobby::cli::Protocol_MSG_WAITING_INVITED_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseUINT32(tableId32);
	_parser.parseBYTE(answer);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(leaveLists);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(tableId64);
}

/*static*/ void Lobby::cli::Protocol_MSG_WAITING_INVITED_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_WAITING_INVITED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	UINT32 tableId32; _parser.parseUINT32(tableId32);
	AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
	BYTE answer; _parser.parseBYTE(answer);
	AtfValidator::validateIntMax(_descr, "answer", answer, 1, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool leaveLists; _parser.parseBOOL(leaveLists);
	AtfValidator::validateInt(_descr, "leaveLists", leaveLists, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 tableId64; _parser.parseUINT64(tableId64);
	AtfValidator::validateUint(_descr, "tableId64", tableId64, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CLIENT_ERROR
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR::Protocol_MSG_LOBBY_CLIENT_ERROR()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR::Protocol_MSG_LOBBY_CLIENT_ERROR(Protocol_MSG_LOBBY_CLIENT_ERROR&& _o)
	: userId(std::move(_o.userId))
	, info(std::move(_o.info))
{
}

Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR& Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR::operator=(Protocol_MSG_LOBBY_CLIENT_ERROR&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		info = std::move(_o.info);
	}
	return *this;
}

#endif

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR::clear()
{
	userId.clear();
	info.clear();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR::equals(const Protocol_MSG_LOBBY_CLIENT_ERROR& _o) const
{
	return userId.equals(_o.userId) &&
		info.equals(_o.info);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CLIENT_ERROR).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("info=");
	_buf.append(info);
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeString(info);
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseStringP(info);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLIENT_ERROR";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, 20, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "info"); size_t szInfo = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "info", szInfo, 100000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CLIENT_ERROR_REPLY
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR_REPLY::Protocol_MSG_LOBBY_CLIENT_ERROR_REPLY()
{
	clear();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR_REPLY::clear()
{
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR_REPLY::equals(const Protocol_MSG_LOBBY_CLIENT_ERROR_REPLY& _o) const
{
	return true;
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CLIENT_ERROR_REPLY).append(")");
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR_REPLY::composeMsg(CommMsgBody& _msg) const
{
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR_REPLY::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLIENT_ERROR_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_REPORT_INSTALL
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_REPORT_INSTALL::Protocol_MSG_LOBBY_REPORT_INSTALL()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::lobby_unauth::Protocol_MSG_LOBBY_REPORT_INSTALL::Protocol_MSG_LOBBY_REPORT_INSTALL(Protocol_MSG_LOBBY_REPORT_INSTALL&& _o)
	: installId(std::move(_o.installId))
	, wuid(std::move(_o.wuid))
	, promo(std::move(_o.promo))
	, whenStr(std::move(_o.whenStr))
	, siteId(std::move(_o.siteId))
	, platformId(std::move(_o.platformId))
	, extraData(std::move(_o.extraData))
{
}

Lobby::lobby_unauth::Protocol_MSG_LOBBY_REPORT_INSTALL& Lobby::lobby_unauth::Protocol_MSG_LOBBY_REPORT_INSTALL::operator=(Protocol_MSG_LOBBY_REPORT_INSTALL&& _o)
{
	if(this != &_o)
	{
		installId = std::move(_o.installId);
		wuid = std::move(_o.wuid);
		promo = std::move(_o.promo);
		whenStr = std::move(_o.whenStr);
		siteId = std::move(_o.siteId);
		platformId = std::move(_o.platformId);
		extraData = std::move(_o.extraData);
	}
	return *this;
}

#endif

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_REPORT_INSTALL::clear()
{
	installId.clear();
	wuid.clear();
	promo.clear();
	whenStr.clear();
	siteId = 0;
	platformId = 0;
	extraData.clear();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_REPORT_INSTALL::equals(const Protocol_MSG_LOBBY_REPORT_INSTALL& _o) const
{
	return installId.equals(_o.installId) &&
		wuid.equals(_o.wuid) &&
		promo.equals(_o.promo) &&
		whenStr.equals(_o.whenStr) &&
		siteId == _o.siteId &&
		platformId == _o.platformId &&
		extraData.equals(_o.extraData);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_REPORT_INSTALL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_REPORT_INSTALL).append(")");
	_buf.append(',');
	_buf.append("installId=");
	_buf.append(installId);
	_buf.append(',');
	_buf.append("wuid=");
	_buf.append(wuid);
	_buf.append(',');
	_buf.append("promo=");
	_buf.append(promo);
	_buf.append(',');
	_buf.append("whenStr=");
	_buf.append(whenStr);
	_buf.append(',');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("platformId=");
	_buf.appendUint(platformId);
	_buf.append(',');
	_buf.append("extraData=");
	extraData.toTraceString(_buf);
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_REPORT_INSTALL::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(installId);
	_msg.composeString(wuid);
	_msg.composeString(promo);
	_msg.composeString(whenStr);
	_msg.composeUINT32(siteId);
	_msg.composeUINT32(platformId);
	extraData.composeMsg(_msg);
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_REPORT_INSTALL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(installId);
	_parser.parseStringP(wuid);
	_parser.parseStringP(promo);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(whenStr);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(siteId);
	_parser.parseUINT32(platformId);
	if(_parser.parseEnded()) return;
	extraData.parseMsg(_parser);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_REPORT_INSTALL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_REPORT_INSTALL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "installId"); size_t szInstallId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "installId", szInstallId, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "wuid"); size_t szWuid = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "wuid", szWuid, 1000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "promo"); size_t szPromo = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "promo", szPromo, 1000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "whenStr"); size_t szWhenStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "whenStr", szWhenStr, 100, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 siteId; _parser.parseUINT32(siteId);
	AtfValidator::validateIntMax(_descr, "siteId", siteId, PokerStars_Last, _checker, __FILE__, __LINE__);
	UINT32 platformId; _parser.parseUINT32(platformId);
	AtfValidator::validateIntMax(_descr, "platformId", platformId, Client_Last, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PString _descbuf;
	CommonThin::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("extraData"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_PROMO_COUNTRY
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY::Protocol_MSG_LOBBY_PROMO_COUNTRY()
{
	clear();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY::clear()
{
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY::equals(const Protocol_MSG_LOBBY_PROMO_COUNTRY& _o) const
{
	return true;
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_PROMO_COUNTRY).append(")");
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY::composeMsg(CommMsgBody& _msg) const
{
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_PROMO_COUNTRY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_PROMO_COUNTRY_REPLY
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY_REPLY::Protocol_MSG_LOBBY_PROMO_COUNTRY_REPLY()
{
	clear();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY_REPLY::clear()
{
	uint32Val = 0;
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY_REPLY::equals(const Protocol_MSG_LOBBY_PROMO_COUNTRY_REPLY& _o) const
{
	return uint32Val == _o.uint32Val;
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_PROMO_COUNTRY_REPLY).append(")");
	_buf.append(',');
	_buf.append("uint32Val=");
	_buf.appendUint(uint32Val);
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(uint32Val);
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(uint32Val);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_PROMO_COUNTRY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 uint32Val; _parser.parseUINT32(uint32Val);
	AtfValidator::validateInt(_descr, "uint32Val", uint32Val, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN()
{
	clear();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN::clear()
{
	id = 0;
	locale = 0;
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN::equals(const Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN& _o) const
{
	return id == _o.id &&
		locale == _o.locale;
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_SATELLITES_TO_TOURN).append(")");
	_buf.append(',');
	_buf.append("id=");
	_buf.appendUint(id);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(id);
	_msg.composeUINT32(locale);
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(id);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(locale);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_SATELLITES_TO_TOURN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 id; _parser.parseUINT32(id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    SatelliteStruct
//=================================================================

Lobby::lobby_unauth::SatelliteStruct::SatelliteStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::lobby_unauth::SatelliteStruct::SatelliteStruct(SatelliteStruct&& _o)
	: tournamentId(std::move(_o.tournamentId))
	, server(std::move(_o.server))
	, serverObj(std::move(_o.serverObj))
	, publisherName(std::move(_o.publisherName))
	, whenStart(std::move(_o.whenStart))
	, buyIn(std::move(_o.buyIn))
	, rake(std::move(_o.rake))
	, fppBuyIn(std::move(_o.fppBuyIn))
	, isRestricted(std::move(_o.isRestricted))
	, isPwdProtected(std::move(_o.isPwdProtected))
	, localeStr(std::move(_o.localeStr))
	, admissionId(std::move(_o.admissionId))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, satelliteTarget(std::move(_o.satelliteTarget))
	, minPlayers(std::move(_o.minPlayers))
	, tournFlags(std::move(_o.tournFlags))
	, game(std::move(_o.game))
	, isHiLo(std::move(_o.isHiLo))
	, structure(std::move(_o.structure))
	, tournMask(std::move(_o.tournMask))
	, tournSites(std::move(_o.tournSites))
	, whenStartEncode(std::move(_o.whenStartEncode))
	, tournMask2(std::move(_o.tournMask2))
	, status(std::move(_o.status))
	, entrants(std::move(_o.entrants))
{
}

Lobby::lobby_unauth::SatelliteStruct& Lobby::lobby_unauth::SatelliteStruct::operator=(SatelliteStruct&& _o)
{
	if(this != &_o)
	{
		tournamentId = std::move(_o.tournamentId);
		server = std::move(_o.server);
		serverObj = std::move(_o.serverObj);
		publisherName = std::move(_o.publisherName);
		whenStart = std::move(_o.whenStart);
		buyIn = std::move(_o.buyIn);
		rake = std::move(_o.rake);
		fppBuyIn = std::move(_o.fppBuyIn);
		isRestricted = std::move(_o.isRestricted);
		isPwdProtected = std::move(_o.isPwdProtected);
		localeStr = std::move(_o.localeStr);
		admissionId = std::move(_o.admissionId);
		isPlayMoney = std::move(_o.isPlayMoney);
		satelliteTarget = std::move(_o.satelliteTarget);
		minPlayers = std::move(_o.minPlayers);
		tournFlags = std::move(_o.tournFlags);
		game = std::move(_o.game);
		isHiLo = std::move(_o.isHiLo);
		structure = std::move(_o.structure);
		tournMask = std::move(_o.tournMask);
		tournSites = std::move(_o.tournSites);
		whenStartEncode = std::move(_o.whenStartEncode);
		tournMask2 = std::move(_o.tournMask2);
		status = std::move(_o.status);
		entrants = std::move(_o.entrants);
	}
	return *this;
}

#endif

void Lobby::lobby_unauth::SatelliteStruct::clear()
{
	tournamentId = 0;
	server.clear();
	serverObj.clear();
	publisherName.clear();
	whenStart.setNull();
	buyIn = 0;
	rake = 0;
	fppBuyIn = 0;
	isRestricted = 0;
	isPwdProtected = 0;
	localeStr.clear();
	admissionId.clear();
	isPlayMoney = 0;
	satelliteTarget = 0;
	minPlayers = 0;
	tournFlags = 0;
	game = 0;
	isHiLo = 0;
	structure = 0;
	tournMask = 0;
	tournSites = 0;
	whenStartEncode = 0;
	tournMask2 = 0;
	status = 0;
	entrants = 0;
}

bool Lobby::lobby_unauth::SatelliteStruct::equals(const SatelliteStruct& _o) const
{
	return tournamentId == _o.tournamentId &&
		server.equals(_o.server) &&
		serverObj.equals(_o.serverObj) &&
		publisherName.equals(_o.publisherName) &&
		whenStart.equals(_o.whenStart) &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		fppBuyIn == _o.fppBuyIn &&
		isRestricted == _o.isRestricted &&
		isPwdProtected == _o.isPwdProtected &&
		localeStr.equals(_o.localeStr) &&
		admissionId.equals(_o.admissionId) &&
		isPlayMoney == _o.isPlayMoney &&
		satelliteTarget == _o.satelliteTarget &&
		minPlayers == _o.minPlayers &&
		tournFlags == _o.tournFlags &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		structure == _o.structure &&
		tournMask == _o.tournMask &&
		tournSites == _o.tournSites &&
		whenStartEncode == _o.whenStartEncode &&
		tournMask2 == _o.tournMask2 &&
		status == _o.status &&
		entrants == _o.entrants;
}

const char *Lobby::lobby_unauth::SatelliteStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournamentId=");
	_buf.appendUint(tournamentId);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("serverObj=");
	_buf.append(serverObj);
	_buf.append(',');
	_buf.append("publisherName=");
	_buf.append(publisherName);
	_buf.append(',');
	_buf.append("whenStart=");
	ThinAtf::AtfTempl<CommSrvTime>::ToTraceString(_buf, whenStart);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendUint(buyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendUint(rake);
	_buf.append(',');
	_buf.append("fppBuyIn=");
	_buf.appendUint(fppBuyIn);
	_buf.append(',');
	_buf.append("isRestricted=");
	_buf.appendUint(isRestricted);
	_buf.append(',');
	_buf.append("isPwdProtected=");
	_buf.appendUint(isPwdProtected);
	_buf.append(',');
	_buf.append("localeStr=");
	_buf.append(localeStr);
	_buf.append(',');
	_buf.append("admissionId=");
	_buf.append(admissionId);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("satelliteTarget=");
	_buf.appendUint(satelliteTarget);
	_buf.append(',');
	_buf.append("minPlayers=");
	_buf.appendUint(minPlayers);
	_buf.append(',');
	_buf.append("tournFlags=");
	_buf.appendUint(tournFlags);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("tournMask=");
	_buf.appendUint(tournMask);
	_buf.append(',');
	_buf.append("tournSites=");
	_buf.appendUint(tournSites);
	_buf.append(',');
	_buf.append("whenStartEncode=");
	_buf.appendUint(whenStartEncode);
	_buf.append(',');
	_buf.append("tournMask2=");
	_buf.appendUint(tournMask2);
	_buf.append(',');
	_buf.append("status=");
	_buf.appendUint(status);
	_buf.append(',');
	_buf.append("entrants=");
	_buf.appendUint(entrants);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::lobby_unauth::SatelliteStruct::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(tournamentId);
	_msg.composeString(server);
	_msg.composeString(serverObj);
	_msg.composeString(publisherName);
	_msg.composeSrvTime(whenStart);
	_msg.composeUINT32(buyIn);
	_msg.composeUINT32(rake);
	_msg.composeUINT32(fppBuyIn);
	_msg.composeBYTE(isRestricted);
	_msg.composeBYTE(isPwdProtected);
	_msg.composeString(localeStr);
	_msg.composeString(admissionId);
	_msg.composeBYTE(isPlayMoney);
	_msg.composeUINT32(satelliteTarget);
	_msg.composeUINT32(minPlayers);
	_msg.composeUINT32(tournFlags);
	_msg.composeBYTE(game);
	_msg.composeBYTE(isHiLo);
	_msg.composeBYTE(structure);
	_msg.composeUINT32(tournMask);
	_msg.composeUINT32(tournSites);
	_msg.composeUINT32(whenStartEncode);
	_msg.composeUINT32(tournMask2);
	_msg.composeUINT32(status);
	_msg.composeUINT32(entrants);
}

void Lobby::lobby_unauth::SatelliteStruct::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tournamentId);
	_parser.parseStringP(server);
	_parser.parseStringP(serverObj);
	_parser.parseStringP(publisherName);
	_parser.parseSrvTime(whenStart);
	_parser.parseUINT32(buyIn);
	_parser.parseUINT32(rake);
	_parser.parseUINT32(fppBuyIn);
	_parser.parseBYTE(isRestricted);
	_parser.parseBYTE(isPwdProtected);
	_parser.parseStringP(localeStr);
	_parser.parseStringP(admissionId);
	_parser.parseBYTE(isPlayMoney);
	_parser.parseUINT32(satelliteTarget);
	_parser.parseUINT32(minPlayers);
	_parser.parseUINT32(tournFlags);
	_parser.parseBYTE(game);
	_parser.parseBYTE(isHiLo);
	_parser.parseBYTE(structure);
	_parser.parseUINT32(tournMask);
	_parser.parseUINT32(tournSites);
	_parser.parseUINT32(whenStartEncode);
	_parser.parseUINT32(tournMask2);
	_parser.parseUINT32(status);
	_parser.parseUINT32(entrants);
}

/*static*/ void Lobby::lobby_unauth::SatelliteStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 tournamentId; _parser.parseUINT32(tournamentId);
	AtfValidator::validateInt(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "serverObj"); size_t szServerObj = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObj", szServerObj, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "publisherName"); size_t szPublisherName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "publisherName", szPublisherName, _checker, __FILE__, __LINE__);
	CommSrvTime whenStart; _parser.parseSrvTime(whenStart);
	AtfValidator::validateSrvDateTime(_descr, "whenStart", whenStart, _checker, __FILE__, __LINE__);
	UINT32 buyIn; _parser.parseUINT32(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT32 rake; _parser.parseUINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	UINT32 fppBuyIn; _parser.parseUINT32(fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	BYTE isRestricted; _parser.parseBYTE(isRestricted);
	AtfValidator::validateInt(_descr, "isRestricted", isRestricted, _checker, __FILE__, __LINE__);
	BYTE isPwdProtected; _parser.parseBYTE(isPwdProtected);
	AtfValidator::validateInt(_descr, "isPwdProtected", isPwdProtected, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "localeStr"); size_t szLocaleStr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "localeStr", szLocaleStr, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "admissionId"); size_t szAdmissionId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "admissionId", szAdmissionId, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 satelliteTarget; _parser.parseUINT32(satelliteTarget);
	AtfValidator::validateInt(_descr, "satelliteTarget", satelliteTarget, _checker, __FILE__, __LINE__);
	UINT32 minPlayers; _parser.parseUINT32(minPlayers);
	AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
	UINT32 tournFlags; _parser.parseUINT32(tournFlags);
	AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	UINT32 tournMask; _parser.parseUINT32(tournMask);
	AtfValidator::validateInt(_descr, "tournMask", tournMask, _checker, __FILE__, __LINE__);
	UINT32 tournSites; _parser.parseUINT32(tournSites);
	AtfValidator::validateInt(_descr, "tournSites", tournSites, _checker, __FILE__, __LINE__);
	UINT32 whenStartEncode; _parser.parseUINT32(whenStartEncode);
	AtfValidator::validateInt(_descr, "whenStartEncode", whenStartEncode, _checker, __FILE__, __LINE__);
	UINT32 tournMask2; _parser.parseUINT32(tournMask2);
	AtfValidator::validateInt(_descr, "tournMask2", tournMask2, _checker, __FILE__, __LINE__);
	UINT32 status; _parser.parseUINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	UINT32 entrants; _parser.parseUINT32(entrants);
	AtfValidator::validateInt(_descr, "entrants", entrants, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY(Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY&& _o)
	: id(std::move(_o.id))
	, satellites(std::move(_o.satellites))
{
}

Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY& Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY::operator=(Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY&& _o)
{
	if(this != &_o)
	{
		id = std::move(_o.id);
		satellites = std::move(_o.satellites);
	}
	return *this;
}

#endif

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY::clear()
{
	id = 0;
	satellites.clear();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY::equals(const Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY& _o) const
{
	return id == _o.id &&
		satellites.equals(_o.satellites);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY).append(")");
	_buf.append(',');
	_buf.append("id=");
	_buf.appendUint(id);
	_buf.append(',');
	_buf.append("satellites=");
	satellites.toTraceString(_buf);
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(id);
	satellites.composeMsg(_msg);
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(id);
	satellites.parseMsg(_parser);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 id; _parser.parseUINT32(id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szSatellites = ThinAtf::LAtfVector< SatelliteStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("satellites"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "satellites", szSatellites, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX()
{
	clear();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX::clear()
{
	id = 0;
	locale = 0;
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX::equals(const Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX& _o) const
{
	return id == _o.id &&
		locale == _o.locale;
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX).append(")");
	_buf.append(',');
	_buf.append("id=");
	_buf.appendUint(id);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(id);
	_msg.composeUINT32(locale);
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(id);
	_parser.parseUINT32(locale);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 id; _parser.parseUINT32(id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    SatelliteStructEx
//=================================================================

Lobby::lobby_unauth::SatelliteStructEx::SatelliteStructEx()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::lobby_unauth::SatelliteStructEx::SatelliteStructEx(SatelliteStructEx&& _o)
	: tournamentId(std::move(_o.tournamentId))
	, server(std::move(_o.server))
	, serverObj(std::move(_o.serverObj))
	, publisherName(std::move(_o.publisherName))
	, whenStart(std::move(_o.whenStart))
	, buyIn(std::move(_o.buyIn))
	, rake(std::move(_o.rake))
	, fppBuyIn(std::move(_o.fppBuyIn))
	, isRestricted(std::move(_o.isRestricted))
	, isPwdProtected(std::move(_o.isPwdProtected))
	, localeStr(std::move(_o.localeStr))
	, admissionId(std::move(_o.admissionId))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, satelliteTarget(std::move(_o.satelliteTarget))
	, minPlayers(std::move(_o.minPlayers))
	, tournFlags(std::move(_o.tournFlags))
	, game(std::move(_o.game))
	, isHiLo(std::move(_o.isHiLo))
	, structure(std::move(_o.structure))
	, tournMask(std::move(_o.tournMask))
	, tournSites(std::move(_o.tournSites))
	, whenStartEncode(std::move(_o.whenStartEncode))
	, tournMask2(std::move(_o.tournMask2))
	, status(std::move(_o.status))
	, entrants(std::move(_o.entrants))
{
}

Lobby::lobby_unauth::SatelliteStructEx& Lobby::lobby_unauth::SatelliteStructEx::operator=(SatelliteStructEx&& _o)
{
	if(this != &_o)
	{
		tournamentId = std::move(_o.tournamentId);
		server = std::move(_o.server);
		serverObj = std::move(_o.serverObj);
		publisherName = std::move(_o.publisherName);
		whenStart = std::move(_o.whenStart);
		buyIn = std::move(_o.buyIn);
		rake = std::move(_o.rake);
		fppBuyIn = std::move(_o.fppBuyIn);
		isRestricted = std::move(_o.isRestricted);
		isPwdProtected = std::move(_o.isPwdProtected);
		localeStr = std::move(_o.localeStr);
		admissionId = std::move(_o.admissionId);
		isPlayMoney = std::move(_o.isPlayMoney);
		satelliteTarget = std::move(_o.satelliteTarget);
		minPlayers = std::move(_o.minPlayers);
		tournFlags = std::move(_o.tournFlags);
		game = std::move(_o.game);
		isHiLo = std::move(_o.isHiLo);
		structure = std::move(_o.structure);
		tournMask = std::move(_o.tournMask);
		tournSites = std::move(_o.tournSites);
		whenStartEncode = std::move(_o.whenStartEncode);
		tournMask2 = std::move(_o.tournMask2);
		status = std::move(_o.status);
		entrants = std::move(_o.entrants);
	}
	return *this;
}

#endif

void Lobby::lobby_unauth::SatelliteStructEx::clear()
{
	tournamentId = 0;
	server.clear();
	serverObj.clear();
	publisherName.clear();
	whenStart.setNull();
	buyIn = 0;
	rake = 0;
	fppBuyIn = 0;
	isRestricted = 0;
	isPwdProtected = 0;
	localeStr.clear();
	admissionId.clear();
	isPlayMoney = 0;
	satelliteTarget = 0;
	minPlayers = 0;
	tournFlags = 0;
	game = 0;
	isHiLo = 0;
	structure = 0;
	tournMask = 0;
	tournSites.clear();
	whenStartEncode = 0;
	tournMask2 = 0;
	status = 0;
	entrants = 0;
}

bool Lobby::lobby_unauth::SatelliteStructEx::equals(const SatelliteStructEx& _o) const
{
	return tournamentId == _o.tournamentId &&
		server.equals(_o.server) &&
		serverObj.equals(_o.serverObj) &&
		publisherName.equals(_o.publisherName) &&
		whenStart.equals(_o.whenStart) &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		fppBuyIn == _o.fppBuyIn &&
		isRestricted == _o.isRestricted &&
		isPwdProtected == _o.isPwdProtected &&
		localeStr.equals(_o.localeStr) &&
		admissionId.equals(_o.admissionId) &&
		isPlayMoney == _o.isPlayMoney &&
		satelliteTarget == _o.satelliteTarget &&
		minPlayers == _o.minPlayers &&
		tournFlags == _o.tournFlags &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		structure == _o.structure &&
		tournMask == _o.tournMask &&
		tournSites.equals(_o.tournSites) &&
		whenStartEncode == _o.whenStartEncode &&
		tournMask2 == _o.tournMask2 &&
		status == _o.status &&
		entrants == _o.entrants;
}

const char *Lobby::lobby_unauth::SatelliteStructEx::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournamentId=");
	_buf.appendUint(tournamentId);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("serverObj=");
	_buf.append(serverObj);
	_buf.append(',');
	_buf.append("publisherName=");
	_buf.append(publisherName);
	_buf.append(',');
	_buf.append("whenStart=");
	ThinAtf::AtfTempl<CommSrvTime>::ToTraceString(_buf, whenStart);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendUint(buyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendUint(rake);
	_buf.append(',');
	_buf.append("fppBuyIn=");
	_buf.appendUint(fppBuyIn);
	_buf.append(',');
	_buf.append("isRestricted=");
	_buf.appendUint(isRestricted);
	_buf.append(',');
	_buf.append("isPwdProtected=");
	_buf.appendUint(isPwdProtected);
	_buf.append(',');
	_buf.append("localeStr=");
	_buf.append(localeStr);
	_buf.append(',');
	_buf.append("admissionId=");
	_buf.append(admissionId);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("satelliteTarget=");
	_buf.appendUint(satelliteTarget);
	_buf.append(',');
	_buf.append("minPlayers=");
	_buf.appendUint(minPlayers);
	_buf.append(',');
	_buf.append("tournFlags=");
	_buf.appendUint(tournFlags);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("tournMask=");
	_buf.appendUint(tournMask);
	_buf.append(',');
	_buf.append("tournSites=");
	tournSites.toTraceString(_buf);
	_buf.append(',');
	_buf.append("whenStartEncode=");
	_buf.appendUint(whenStartEncode);
	_buf.append(',');
	_buf.append("tournMask2=");
	_buf.appendUint(tournMask2);
	_buf.append(',');
	_buf.append("status=");
	_buf.appendUint(status);
	_buf.append(',');
	_buf.append("entrants=");
	_buf.appendUint(entrants);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::lobby_unauth::SatelliteStructEx::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(SatelliteStructEx())) // not empty
	{
		_body.composeUINT32(tournamentId);
		_body.composeString(server);
		_body.composeString(serverObj);
		_body.composeString(publisherName);
		_body.composeSrvTime(whenStart);
		_body.composeUINT32(buyIn);
		_body.composeUINT32(rake);
		_body.composeUINT32(fppBuyIn);
		_body.composeBYTE(isRestricted);
		_body.composeBYTE(isPwdProtected);
		_body.composeString(localeStr);
		_body.composeString(admissionId);
		_body.composeBYTE(isPlayMoney);
		_body.composeUINT32(satelliteTarget);
		_body.composeUINT32(minPlayers);
		_body.composeUINT32(tournFlags);
		_body.composeBYTE(game);
		_body.composeBYTE(isHiLo);
		_body.composeBYTE(structure);
		_body.composeUINT32(tournMask);
		tournSites.composeMsg(_body);
		_body.composeUINT32(whenStartEncode);
		_body.composeUINT32(tournMask2);
		_body.composeUINT32(status);
		_body.composeUINT32(entrants);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::lobby_unauth::SatelliteStructEx::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(tournamentId);
	_parser0.parseStringP(server);
	_parser0.parseStringP(serverObj);
	_parser0.parseStringP(publisherName);
	_parser0.parseSrvTime(whenStart);
	_parser0.parseUINT32(buyIn);
	_parser0.parseUINT32(rake);
	_parser0.parseUINT32(fppBuyIn);
	_parser0.parseBYTE(isRestricted);
	_parser0.parseBYTE(isPwdProtected);
	_parser0.parseStringP(localeStr);
	_parser0.parseStringP(admissionId);
	_parser0.parseBYTE(isPlayMoney);
	_parser0.parseUINT32(satelliteTarget);
	_parser0.parseUINT32(minPlayers);
	_parser0.parseUINT32(tournFlags);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(isHiLo);
	_parser0.parseBYTE(structure);
	_parser0.parseUINT32(tournMask);
	tournSites.parseMsg(_parser0);
	_parser0.parseUINT32(whenStartEncode);
	_parser0.parseUINT32(tournMask2);
	_parser0.parseUINT32(status);
	_parser0.parseUINT32(entrants);
}

/*static*/ void Lobby::lobby_unauth::SatelliteStructEx::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 tournamentId; _parser0.parseUINT32(tournamentId);
	AtfValidator::validateInt(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "serverObj"); size_t szServerObj = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObj", szServerObj, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "publisherName"); size_t szPublisherName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "publisherName", szPublisherName, _checker, __FILE__, __LINE__);
	CommSrvTime whenStart; _parser0.parseSrvTime(whenStart);
	AtfValidator::validateSrvDateTime(_descr, "whenStart", whenStart, _checker, __FILE__, __LINE__);
	UINT32 buyIn; _parser0.parseUINT32(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT32 rake; _parser0.parseUINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	UINT32 fppBuyIn; _parser0.parseUINT32(fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	BYTE isRestricted; _parser0.parseBYTE(isRestricted);
	AtfValidator::validateInt(_descr, "isRestricted", isRestricted, _checker, __FILE__, __LINE__);
	BYTE isPwdProtected; _parser0.parseBYTE(isPwdProtected);
	AtfValidator::validateInt(_descr, "isPwdProtected", isPwdProtected, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "localeStr"); size_t szLocaleStr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "localeStr", szLocaleStr, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "admissionId"); size_t szAdmissionId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "admissionId", szAdmissionId, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser0.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 satelliteTarget; _parser0.parseUINT32(satelliteTarget);
	AtfValidator::validateInt(_descr, "satelliteTarget", satelliteTarget, _checker, __FILE__, __LINE__);
	UINT32 minPlayers; _parser0.parseUINT32(minPlayers);
	AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
	UINT32 tournFlags; _parser0.parseUINT32(tournFlags);
	AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser0.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	UINT32 tournMask; _parser0.parseUINT32(tournMask);
	AtfValidator::validateInt(_descr, "tournMask", tournMask, _checker, __FILE__, __LINE__);
	PString _descbuf;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tournSites"), _fieldsWithUnparsedContent);
	UINT32 whenStartEncode; _parser0.parseUINT32(whenStartEncode);
	AtfValidator::validateInt(_descr, "whenStartEncode", whenStartEncode, _checker, __FILE__, __LINE__);
	UINT32 tournMask2; _parser0.parseUINT32(tournMask2);
	AtfValidator::validateInt(_descr, "tournMask2", tournMask2, _checker, __FILE__, __LINE__);
	UINT32 status; _parser0.parseUINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	UINT32 entrants; _parser0.parseUINT32(entrants);
	AtfValidator::validateInt(_descr, "entrants", entrants, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY(Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY&& _o)
	: id(std::move(_o.id))
	, satellites(std::move(_o.satellites))
{
}

Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY& Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY::operator=(Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY&& _o)
{
	if(this != &_o)
	{
		id = std::move(_o.id);
		satellites = std::move(_o.satellites);
	}
	return *this;
}

#endif

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY::clear()
{
	id = 0;
	satellites.clear();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY::equals(const Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY& _o) const
{
	return id == _o.id &&
		satellites.equals(_o.satellites);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY).append(")");
	_buf.append(',');
	_buf.append("id=");
	_buf.appendUint(id);
	_buf.append(',');
	_buf.append("satellites=");
	satellites.toTraceString(_buf);
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(id);
	satellites.composeMsg(_msg);
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(id);
	satellites.parseMsg(_parser);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 id; _parser.parseUINT32(id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szSatellites = ThinAtf::LAtfVector< SatelliteStructEx, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("satellites"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "satellites", szSatellites, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_TABLE_BY_ID
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID::Protocol_MSG_LOBBY_GET_TABLE_BY_ID()
{
	clear();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID::clear()
{
	tableId32 = 0;
	tournId = 0;
	tableId = tableId32;
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID::equals(const Protocol_MSG_LOBBY_GET_TABLE_BY_ID& _o) const
{
	return tableId32 == _o.tableId32 &&
		tournId == _o.tournId &&
		tableId == _o.tableId;
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_TABLE_BY_ID).append(")");
	_buf.append(',');
	_buf.append("tableId32=");
	_buf.appendUint(tableId32);
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(tableId32);
	_msg.composeUINT32(tournId);
	_msg.composeUINT64(tableId);
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tableId32);
	_parser.parseUINT32(tournId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(tableId);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_TABLE_BY_ID";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 tableId32; _parser.parseUINT32(tableId32);
	AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 tableId; _parser.parseUINT64(tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY::Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY::Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY(Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, server(std::move(_o.server))
	, serverObj(std::move(_o.serverObj))
{
}

Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY& Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY::operator=(Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		server = std::move(_o.server);
		serverObj = std::move(_o.serverObj);
	}
	return *this;
}

#endif

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	server.clear();
	serverObj.clear();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY::equals(const Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		server.equals(_o.server) &&
		serverObj.equals(_o.serverObj);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_TABLE_BY_ID_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("server=");
		_buf.append(server);
		_buf.append(',');
		_buf.append("serverObj=");
		_buf.append(serverObj);
	}
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(server);
		_msg.composeString(serverObj);
	}
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(server);
		_parser.parseStringP(serverObj);
	}
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_TABLE_BY_ID_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "serverObj"); size_t szServerObj = strlen(_dummy);
		AtfValidator::validateInt(_descr, "serverObj", szServerObj, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_CAPTCHA
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA::Protocol_MSG_LOBBY_GET_CAPTCHA()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA::Protocol_MSG_LOBBY_GET_CAPTCHA(Protocol_MSG_LOBBY_GET_CAPTCHA&& _o)
	: userId(std::move(_o.userId))
{
}

Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA& Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA::operator=(Protocol_MSG_LOBBY_GET_CAPTCHA&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
	}
	return *this;
}

#endif

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA::clear()
{
	userId.clear();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA::equals(const Protocol_MSG_LOBBY_GET_CAPTCHA& _o) const
{
	return userId.equals(_o.userId);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_CAPTCHA).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_CAPTCHA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY::Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY::Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY(Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, image(std::move(_o.image))
	, checksum(std::move(_o.checksum))
{
}

Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY& Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY::operator=(Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		image = std::move(_o.image);
		checksum = std::move(_o.checksum);
	}
	return *this;
}

#endif

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	image.clear();
	checksum.clear();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY::equals(const Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		image.size() == _o.image.size() && memcmp(image.ptr(), _o.image.ptr(), image.size()) == 0 &&
		checksum.size() == _o.checksum.size() && memcmp(checksum.ptr(), _o.checksum.ptr(), checksum.size()) == 0;
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_CAPTCHA_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("image=");
		ThinAtf::AtfTempl<PBlock>::ToTraceString(_buf, image);
		_buf.append(',');
		_buf.append("checksum=");
		ThinAtf::AtfTempl<PBlock>::ToTraceString(_buf, checksum);
	}
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg._composeVarBlock(image.ptr(), image.size());
		_msg._composeVarBlock(checksum.ptr(), checksum.size());
	}
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parsePBlock(image);
		_parser.parsePBlock(checksum);
	}
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_CAPTCHA_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		const BYTE* image; size_t szImage; _parser._parseVarBlock(image, szImage);  /*image*/
		AtfValidator::validateInt(_descr, "image", szImage, _checker, __FILE__, __LINE__);
		const BYTE* checksum; size_t szChecksum; _parser._parseVarBlock(checksum, szChecksum);  /*checksum*/
		AtfValidator::validateInt(_descr, "checksum", szChecksum, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CHALLENGE_QUESTION
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::Protocol_MSG_LOBBY_CHALLENGE_QUESTION()
{
	clear();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::clear()
{
	locale = 0;
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::equals(const Protocol_MSG_LOBBY_CHALLENGE_QUESTION& _o) const
{
	return locale == _o.locale;
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CHALLENGE_QUESTION).append(")");
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(locale);
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(locale);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CHALLENGE_QUESTION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    ChallengeQuestion
//=================================================================

Lobby::lobby_unauth::ChallengeQuestion::ChallengeQuestion()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::lobby_unauth::ChallengeQuestion::ChallengeQuestion(ChallengeQuestion&& _o)
	: id(std::move(_o.id))
	, txt(std::move(_o.txt))
{
}

Lobby::lobby_unauth::ChallengeQuestion& Lobby::lobby_unauth::ChallengeQuestion::operator=(ChallengeQuestion&& _o)
{
	if(this != &_o)
	{
		id = std::move(_o.id);
		txt = std::move(_o.txt);
	}
	return *this;
}

#endif

void Lobby::lobby_unauth::ChallengeQuestion::clear()
{
	id = 0;
	txt.clear();
}

bool Lobby::lobby_unauth::ChallengeQuestion::equals(const ChallengeQuestion& _o) const
{
	return id == _o.id &&
		txt.equals(_o.txt);
}

const char *Lobby::lobby_unauth::ChallengeQuestion::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("id=");
	_buf.appendUint(id);
	_buf.append(',');
	_buf.append("txt=");
	_buf.append(txt);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::lobby_unauth::ChallengeQuestion::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(id);
	_msg.composeString(txt);
}

void Lobby::lobby_unauth::ChallengeQuestion::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(id);
	_parser.parseStringP(txt);
}

/*static*/ void Lobby::lobby_unauth::ChallengeQuestion::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 id; _parser.parseUINT32(id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "txt"); size_t szTxt = strlen(_dummy);
	AtfValidator::validateInt(_descr, "txt", szTxt, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY(Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, challenges(std::move(_o.challenges))
{
}

Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY& Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::operator=(Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		challenges = std::move(_o.challenges);
	}
	return *this;
}

#endif

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	challenges.clear();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::equals(const Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		challenges.equals(_o.challenges);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CHALLENGE_QUESTION_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("challenges=");
		challenges.toTraceString(_buf);
	}
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		challenges.composeMsg(_msg);
	}
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		challenges.parseMsg(_parser);
	}
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CHALLENGE_QUESTION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szChallenges = ThinAtf::LAtfVector< ChallengeQuestion, 2 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("challenges"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "challenges", szChallenges, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_UPDATE_BY_LICENSE
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE()
{
	clear();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE::clear()
{
	platform = 0;
	license = 0;
	site = 0;
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE::equals(const Protocol_MSG_LOBBY_UPDATE_BY_LICENSE& _o) const
{
	return platform == _o.platform &&
		license == _o.license &&
		site == _o.site;
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_UPDATE_BY_LICENSE).append(")");
	_buf.append(',');
	_buf.append("platform=");
	_buf.appendUint(platform);
	_buf.append(',');
	_buf.append("license=");
	_buf.appendUint(license);
	_buf.append(',');
	_buf.append("site=");
	_buf.appendUint(site);
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(platform);
	_msg.composeUINT32(license);
	_msg.composeUINT32(site);
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(platform);
	_parser.parseUINT32(license);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(site);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_UPDATE_BY_LICENSE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 platform; _parser.parseUINT32(platform);
	AtfValidator::validateIntMax(_descr, "platform", platform, Client_Last, _checker, __FILE__, __LINE__);
	UINT32 license; _parser.parseUINT32(license);
	AtfValidator::validateIntMax(_descr, "license", license, eLicenceLast, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 site; _parser.parseUINT32(site);
	AtfValidator::validateIntMax(_descr, "site", site, PokerStars_Last, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY(Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, updateFolder(std::move(_o.updateFolder))
{
}

Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY& Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY::operator=(Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		updateFolder = std::move(_o.updateFolder);
	}
	return *this;
}

#endif

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	updateFolder.clear();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY::equals(const Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		updateFolder.equals(_o.updateFolder);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_UPDATE_BY_LICENSE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("updateFolder=");
		_buf.append(updateFolder);
	}
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeString(updateFolder);
	}
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseStringP(updateFolder);
	}
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_UPDATE_BY_LICENSE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "updateFolder"); size_t szUpdateFolder = strlen(_dummy);
		AtfValidator::validateInt(_descr, "updateFolder", szUpdateFolder, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE()
{
	clear();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::clear()
{
	typeId = 0;
	clientReqId = 0;
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::equals(const Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE& _o) const
{
	return typeId == _o.typeId &&
		clientReqId == _o.clientReqId;
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_TABLE_TO_OBSERVE).append(")");
	_buf.append(',');
	_buf.append("typeId=");
	_buf.appendUint(typeId);
	_buf.append(',');
	_buf.append("clientReqId=");
	_buf.appendUint(clientReqId);
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(typeId);
	_msg.composeUINT32(clientReqId);
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(typeId);
	_parser.parseUINT32(clientReqId);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TABLE_TO_OBSERVE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 typeId; _parser.parseUINT32(typeId);
	AtfValidator::validateInt(_descr, "typeId", typeId, _checker, __FILE__, __LINE__);
	UINT32 clientReqId; _parser.parseUINT32(clientReqId);
	AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY(Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, clientReqId(std::move(_o.clientReqId))
	, server(std::move(_o.server))
	, tableId(std::move(_o.tableId))
	, tableId64(std::move(_o.tableId64))
	, serverObject(std::move(_o.serverObject))
{
}

Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY& Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::operator=(Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		clientReqId = std::move(_o.clientReqId);
		server = std::move(_o.server);
		tableId = std::move(_o.tableId);
		tableId64 = std::move(_o.tableId64);
		serverObject = std::move(_o.serverObject);
	}
	return *this;
}

#endif

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	clientReqId = 0;
	server.clear();
	tableId = 0;
	tableId64 = 0;
	serverObject.clear();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::equals(const Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		clientReqId == _o.clientReqId &&
		server.equals(_o.server) &&
		tableId == _o.tableId &&
		tableId64 == _o.tableId64 &&
		serverObject.equals(_o.serverObject);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
		_buf.append(',');
		_buf.append("clientReqId=");
		_buf.appendUint(clientReqId);
	}
	else
	{
		_buf.append(',');
		_buf.append("server=");
		_buf.append(server);
		_buf.append(',');
		_buf.append("tableId=");
		_buf.appendUint(tableId);
		_buf.append(',');
		_buf.append("clientReqId=");
		_buf.appendUint(clientReqId);
		_buf.append(',');
		_buf.append("tableId64=");
		_buf.appendUint64(tableId64);
		_buf.append(',');
		_buf.append("serverObject=");
		_buf.append(serverObject);
	}
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
		_msg.composeUINT32(clientReqId);
	}
	else
	{
		_msg.composeString(server);
		_msg.composeUINT32(tableId);
		_msg.composeUINT32(clientReqId);
		_msg.composeUINT64(tableId64);
		_msg.composeString(serverObject);
	}
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
		_parser.parseUINT32(clientReqId);
	}
	else
	{
		_parser.parseStringP(server);
		_parser.parseUINT32(tableId);
		_parser.parseUINT32(clientReqId);
		_parser.parseUINT64(tableId64);
		_parser.parseStringP(serverObject);
	}
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
		UINT32 clientReqId; _parser.parseUINT32(clientReqId);
		AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
		UINT32 tableId; _parser.parseUINT32(tableId);
		AtfValidator::validateInt(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
		UINT32 clientReqId; _parser.parseUINT32(clientReqId);
		AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
		UINT64 tableId64; _parser.parseUINT64(tableId64);
		AtfValidator::validateUint(_descr, "tableId64", tableId64, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "serverObject"); size_t szServerObject = strlen(_dummy);
		AtfValidator::validateInt(_descr, "serverObject", szServerObject, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    Publication
//=================================================================

Lobby::lobby_unauth::Publication::Publication()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::lobby_unauth::Publication::Publication(Publication&& _o)
	: name(std::move(_o.name))
{
}

Lobby::lobby_unauth::Publication& Lobby::lobby_unauth::Publication::operator=(Publication&& _o)
{
	if(this != &_o)
	{
		name = std::move(_o.name);
	}
	return *this;
}

#endif

void Lobby::lobby_unauth::Publication::clear()
{
	name.clear();
}

bool Lobby::lobby_unauth::Publication::equals(const Publication& _o) const
{
	return name.equals(_o.name);
}

const char *Lobby::lobby_unauth::Publication::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("name=");
	_buf.append(name);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::lobby_unauth::Publication::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(name);
}

void Lobby::lobby_unauth::Publication::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(name);
}

/*static*/ void Lobby::lobby_unauth::Publication::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "name", szName, 1000, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_CHECK_PUBLICATIONS
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS(Protocol_MSG_LOBBY_CHECK_PUBLICATIONS&& _o)
	: publications(std::move(_o.publications))
{
}

Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS& Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::operator=(Protocol_MSG_LOBBY_CHECK_PUBLICATIONS&& _o)
{
	if(this != &_o)
	{
		publications = std::move(_o.publications);
	}
	return *this;
}

#endif

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::clear()
{
	publications.clear();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::equals(const Protocol_MSG_LOBBY_CHECK_PUBLICATIONS& _o) const
{
	return publications.equals(_o.publications);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CHECK_PUBLICATIONS).append(")");
	_buf.append(',');
	_buf.append("publications=");
	publications.toTraceString(_buf);
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::composeMsg(CommMsgBody& _msg) const
{
	publications.composeMsg(_msg);
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	publications.parseMsg(_parser);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CHECK_PUBLICATIONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(_parser.parseEnded()) return;
	PString _descbuf;
	int szPublications = ThinAtf::LAtfVector< Publication, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("publications"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "publications", szPublications, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY(Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY&& _o)
	: publicationExist(std::move(_o.publicationExist))
{
}

Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY& Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::operator=(Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY&& _o)
{
	if(this != &_o)
	{
		publicationExist = std::move(_o.publicationExist);
	}
	return *this;
}

#endif

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::clear()
{
	publicationExist.clear();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::equals(const Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY& _o) const
{
	return publicationExist.equals(_o.publicationExist);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CHECK_PUBLICATIONS_REPLY).append(")");
	_buf.append(',');
	_buf.append("publicationExist=");
	publicationExist.toTraceString(_buf);
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	publicationExist.composeMsg(_msg);
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::parseMsg(CommMsgParser& _parser)
{
	publicationExist.parseMsg(_parser);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CHECK_PUBLICATIONS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szPublicationExist = ThinAtf::LAtfVector< bool, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("publicationExist"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "publicationExist", szPublicationExist, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    GameConnectInfo
//=================================================================

Lobby::Personalization::GameConnectInfo::GameConnectInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::Personalization::GameConnectInfo::GameConnectInfo(GameConnectInfo&& _o)
	: gameId(std::move(_o.gameId))
	, server(std::move(_o.server))
	, serverObject(std::move(_o.serverObject))
	, scriptId(std::move(_o.scriptId))
	, category(std::move(_o.category))
	, shouldOpen(std::move(_o.shouldOpen))
{
}

Lobby::Personalization::GameConnectInfo& Lobby::Personalization::GameConnectInfo::operator=(GameConnectInfo&& _o)
{
	if(this != &_o)
	{
		gameId = std::move(_o.gameId);
		server = std::move(_o.server);
		serverObject = std::move(_o.serverObject);
		scriptId = std::move(_o.scriptId);
		category = std::move(_o.category);
		shouldOpen = std::move(_o.shouldOpen);
	}
	return *this;
}

#endif

void Lobby::Personalization::GameConnectInfo::clear()
{
	gameId = 0;
	server.clear();
	serverObject.clear();
	scriptId = 0;
	category = 0;
	shouldOpen = false;
}

bool Lobby::Personalization::GameConnectInfo::equals(const GameConnectInfo& _o) const
{
	return gameId == _o.gameId &&
		server.equals(_o.server) &&
		serverObject.equals(_o.serverObject) &&
		scriptId == _o.scriptId &&
		category == _o.category &&
		shouldOpen == _o.shouldOpen;
}

const char *Lobby::Personalization::GameConnectInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("gameId=");
	_buf.appendUint64(gameId);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("serverObject=");
	_buf.append(serverObject);
	_buf.append(',');
	_buf.append("scriptId=");
	_buf.appendUint(scriptId);
	_buf.append(',');
	_buf.append("category=");
	_buf.appendUint(category);
	_buf.append(',');
	_buf.append("shouldOpen=");
	_buf.appendUint(shouldOpen);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::Personalization::GameConnectInfo::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(GameConnectInfo())) // not empty
	{
		_body.composeUINT64(gameId);
		_body.composeString(server);
		_body.composeString(serverObject);
		_body.composeUINT32(scriptId);
		_body.composeUINT32(category);
		_body.composeBOOL(shouldOpen);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::Personalization::GameConnectInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT64(gameId);
	_parser0.parseStringP(server);
	_parser0.parseStringP(serverObject);
	_parser0.parseUINT32(scriptId);
	_parser0.parseUINT32(category);
	_parser0.parseBOOL(shouldOpen);
}

/*static*/ void Lobby::Personalization::GameConnectInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT64 gameId; _parser0.parseUINT64(gameId);
	AtfValidator::validateUint(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "serverObject"); size_t szServerObject = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObject", szServerObject, _checker, __FILE__, __LINE__);
	UINT32 scriptId; _parser0.parseUINT32(scriptId);
	AtfValidator::validateInt(_descr, "scriptId", scriptId, _checker, __FILE__, __LINE__);
	UINT32 category; _parser0.parseUINT32(category);
	AtfValidator::validateInt(_descr, "category", category, _checker, __FILE__, __LINE__);
	bool shouldOpen; _parser0.parseBOOL(shouldOpen);
	AtfValidator::validateInt(_descr, "shouldOpen", shouldOpen, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBY_PS_USER_AT
//=================================================================

Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT::Protocol_MSG_LOBBY_PS_USER_AT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT::Protocol_MSG_LOBBY_PS_USER_AT(Protocol_MSG_LOBBY_PS_USER_AT&& _o)
	: userId(std::move(_o.userId))
{
}

Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT& Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT::operator=(Protocol_MSG_LOBBY_PS_USER_AT&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
	}
	return *this;
}

#endif

void Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT::clear()
{
	userId.clear();
}

bool Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT::equals(const Protocol_MSG_LOBBY_PS_USER_AT& _o) const
{
	return userId.equals(_o.userId);
}

const char *Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_PS_USER_AT).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	return _buf.c_str();
}

void Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
}

void Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
}

/*static*/ void Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_PS_USER_AT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, 200, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_PS_USER_AT_REPLY
//=================================================================

Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT_REPLY::Protocol_MSG_LOBBY_PS_USER_AT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT_REPLY::Protocol_MSG_LOBBY_PS_USER_AT_REPLY(Protocol_MSG_LOBBY_PS_USER_AT_REPLY&& _o)
	: tableConnInfo(std::move(_o.tableConnInfo))
	, tournConnInfo(std::move(_o.tournConnInfo))
	, blitzTournConnInfo(std::move(_o.blitzTournConnInfo))
	, blitzConnInfo(std::move(_o.blitzConnInfo))
{
}

Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT_REPLY& Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT_REPLY::operator=(Protocol_MSG_LOBBY_PS_USER_AT_REPLY&& _o)
{
	if(this != &_o)
	{
		tableConnInfo = std::move(_o.tableConnInfo);
		tournConnInfo = std::move(_o.tournConnInfo);
		blitzTournConnInfo = std::move(_o.blitzTournConnInfo);
		blitzConnInfo = std::move(_o.blitzConnInfo);
	}
	return *this;
}

#endif

void Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT_REPLY::clear()
{
	tableConnInfo.clear();
	tournConnInfo.clear();
	blitzTournConnInfo.clear();
	blitzConnInfo.clear();
}

bool Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT_REPLY::equals(const Protocol_MSG_LOBBY_PS_USER_AT_REPLY& _o) const
{
	return tableConnInfo.equals(_o.tableConnInfo) &&
		tournConnInfo.equals(_o.tournConnInfo) &&
		blitzTournConnInfo.equals(_o.blitzTournConnInfo) &&
		blitzConnInfo.equals(_o.blitzConnInfo);
}

const char *Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_PS_USER_AT_REPLY).append(")");
	_buf.append(',');
	_buf.append("tableConnInfo=");
	tableConnInfo.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tournConnInfo=");
	tournConnInfo.toTraceString(_buf);
	_buf.append(',');
	_buf.append("blitzTournConnInfo=");
	blitzTournConnInfo.toTraceString(_buf);
	_buf.append(',');
	_buf.append("blitzConnInfo=");
	blitzConnInfo.toTraceString(_buf);
	return _buf.c_str();
}

void Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	tableConnInfo.composeMsg(_msg);
	tournConnInfo.composeMsg(_msg);
	blitzTournConnInfo.composeMsg(_msg);
	blitzConnInfo.composeMsg(_msg);
}

void Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT_REPLY::parseMsg(CommMsgParser& _parser)
{
	tableConnInfo.parseMsg(_parser);
	tournConnInfo.parseMsg(_parser);
	blitzTournConnInfo.parseMsg(_parser);
	blitzConnInfo.parseMsg(_parser);
}

/*static*/ void Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_PS_USER_AT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTableConnInfo = ThinAtf::LAtfVector< GameConnectInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableConnInfo"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tableConnInfo", szTableConnInfo, _checker, __FILE__, __LINE__);
	int szTournConnInfo = ThinAtf::LAtfVector< GameConnectInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournConnInfo"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tournConnInfo", szTournConnInfo, _checker, __FILE__, __LINE__);
	int szBlitzTournConnInfo = ThinAtf::LAtfVector< GameConnectInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("blitzTournConnInfo"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "blitzTournConnInfo", szBlitzTournConnInfo, _checker, __FILE__, __LINE__);
	int szBlitzConnInfo = ThinAtf::LAtfVector< GameConnectInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("blitzConnInfo"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "blitzConnInfo", szBlitzConnInfo, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    TableStaticDataStruct
//=================================================================

Lobby::Personalization::TableStaticDataStruct::TableStaticDataStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::Personalization::TableStaticDataStruct::TableStaticDataStruct(TableStaticDataStruct&& _o)
	: tableId(std::move(_o.tableId))
	, name(std::move(_o.name))
	, serverAddress(std::move(_o.serverAddress))
	, serverInstance(std::move(_o.serverInstance))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, game(std::move(_o.game))
	, isHiLo(std::move(_o.isHiLo))
	, maxPlayers(std::move(_o.maxPlayers))
	, tableFlags(std::move(_o.tableFlags))
	, tableInstanceFlags(std::move(_o.tableInstanceFlags))
	, chatLang(std::move(_o.chatLang))
	, structure(std::move(_o.structure))
	, loBet(std::move(_o.loBet))
	, hiBet(std::move(_o.hiBet))
	, ante(std::move(_o.ante))
	, cap(std::move(_o.cap))
	, specialName(std::move(_o.specialName))
	, currency(std::move(_o.currency))
	, minChipsLimit(std::move(_o.minChipsLimit))
	, maxBuyIn(std::move(_o.maxBuyIn))
	, icon(std::move(_o.icon))
	, filter(std::move(_o.filter))
	, countryRestrictionInverted(std::move(_o.countryRestrictionInverted))
	, restrictedCountries(std::move(_o.restrictedCountries))
	, scalePM(std::move(_o.scalePM))
	, defaultBuyIn(std::move(_o.defaultBuyIn))
	, tableFlags2(std::move(_o.tableFlags2))
	, brandMask(std::move(_o.brandMask))
	, poolBlockMinHands(std::move(_o.poolBlockMinHands))
	, tableTypeId(std::move(_o.tableTypeId))
	, tableStakes(std::move(_o.tableStakes))
	, variableAntes(std::move(_o.variableAntes))
	, visibilityMaskEx(std::move(_o.visibilityMaskEx))
{
}

Lobby::Personalization::TableStaticDataStruct& Lobby::Personalization::TableStaticDataStruct::operator=(TableStaticDataStruct&& _o)
{
	if(this != &_o)
	{
		tableId = std::move(_o.tableId);
		name = std::move(_o.name);
		serverAddress = std::move(_o.serverAddress);
		serverInstance = std::move(_o.serverInstance);
		isPlayMoney = std::move(_o.isPlayMoney);
		game = std::move(_o.game);
		isHiLo = std::move(_o.isHiLo);
		maxPlayers = std::move(_o.maxPlayers);
		tableFlags = std::move(_o.tableFlags);
		tableInstanceFlags = std::move(_o.tableInstanceFlags);
		chatLang = std::move(_o.chatLang);
		structure = std::move(_o.structure);
		loBet = std::move(_o.loBet);
		hiBet = std::move(_o.hiBet);
		ante = std::move(_o.ante);
		cap = std::move(_o.cap);
		specialName = std::move(_o.specialName);
		currency = std::move(_o.currency);
		minChipsLimit = std::move(_o.minChipsLimit);
		maxBuyIn = std::move(_o.maxBuyIn);
		icon = std::move(_o.icon);
		filter = std::move(_o.filter);
		countryRestrictionInverted = std::move(_o.countryRestrictionInverted);
		restrictedCountries = std::move(_o.restrictedCountries);
		scalePM = std::move(_o.scalePM);
		defaultBuyIn = std::move(_o.defaultBuyIn);
		tableFlags2 = std::move(_o.tableFlags2);
		brandMask = std::move(_o.brandMask);
		poolBlockMinHands = std::move(_o.poolBlockMinHands);
		tableTypeId = std::move(_o.tableTypeId);
		tableStakes = std::move(_o.tableStakes);
		variableAntes = std::move(_o.variableAntes);
		visibilityMaskEx = std::move(_o.visibilityMaskEx);
	}
	return *this;
}

#endif

void Lobby::Personalization::TableStaticDataStruct::clear()
{
	tableId = 0;
	name.clear();
	serverAddress.clear();
	serverInstance.clear();
	isPlayMoney = 0;
	game = 0;
	isHiLo = 0;
	maxPlayers = 0;
	tableFlags = 0;
	tableInstanceFlags = 0;
	chatLang = 0;
	structure = 0;
	loBet = 0;
	hiBet = 0;
	ante = 0;
	cap = 0;
	specialName.clear();
	currency.clear();
	minChipsLimit = 0;
	maxBuyIn = 0;
	icon = 0;
	filter = 0;
	countryRestrictionInverted = false;
	restrictedCountries.clear();
	scalePM = 0;
	defaultBuyIn = 0;
	tableFlags2 = 0;
	brandMask = 0;
	poolBlockMinHands = 0;
	tableTypeId = 0;
	tableStakes.clear();
	variableAntes.clear();
	visibilityMaskEx.clear();
}

bool Lobby::Personalization::TableStaticDataStruct::equals(const TableStaticDataStruct& _o) const
{
	return tableId == _o.tableId &&
		name.equals(_o.name) &&
		serverAddress.equals(_o.serverAddress) &&
		serverInstance.equals(_o.serverInstance) &&
		isPlayMoney == _o.isPlayMoney &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		maxPlayers == _o.maxPlayers &&
		tableFlags == _o.tableFlags &&
		tableInstanceFlags == _o.tableInstanceFlags &&
		chatLang == _o.chatLang &&
		structure == _o.structure &&
		loBet == _o.loBet &&
		hiBet == _o.hiBet &&
		ante == _o.ante &&
		cap == _o.cap &&
		specialName.equals(_o.specialName) &&
		currency.equals(_o.currency) &&
		minChipsLimit == _o.minChipsLimit &&
		maxBuyIn == _o.maxBuyIn &&
		icon == _o.icon &&
		filter == _o.filter &&
		countryRestrictionInverted == _o.countryRestrictionInverted &&
		restrictedCountries.equals(_o.restrictedCountries) &&
		scalePM == _o.scalePM &&
		defaultBuyIn == _o.defaultBuyIn &&
		tableFlags2 == _o.tableFlags2 &&
		brandMask == _o.brandMask &&
		poolBlockMinHands == _o.poolBlockMinHands &&
		tableTypeId == _o.tableTypeId &&
		tableStakes.equals(_o.tableStakes) &&
		variableAntes.equals(_o.variableAntes) &&
		visibilityMaskEx.equals(_o.visibilityMaskEx);
}

const char *Lobby::Personalization::TableStaticDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("serverAddress=");
	_buf.append(serverAddress);
	_buf.append(',');
	_buf.append("serverInstance=");
	_buf.append(serverInstance);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendUint(maxPlayers);
	_buf.append(',');
	_buf.append("tableFlags=");
	_buf.appendUint(tableFlags);
	_buf.append(',');
	_buf.append("tableInstanceFlags=");
	_buf.appendUint(tableInstanceFlags);
	_buf.append(',');
	_buf.append("chatLang=");
	_buf.appendUint(chatLang);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("loBet=");
	_buf.appendUint(loBet);
	_buf.append(',');
	_buf.append("hiBet=");
	_buf.appendUint(hiBet);
	_buf.append(',');
	_buf.append("ante=");
	_buf.appendUint(ante);
	_buf.append(',');
	_buf.append("cap=");
	_buf.appendUint(cap);
	_buf.append(',');
	_buf.append("specialName=");
	_buf.append(specialName);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("minChipsLimit=");
	_buf.appendUint(minChipsLimit);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendUint(maxBuyIn);
	_buf.append(',');
	_buf.append("icon=");
	_buf.appendUint(icon);
	_buf.append(',');
	_buf.append("filter=");
	_buf.appendUint(filter);
	_buf.append(',');
	_buf.append("countryRestrictionInverted=");
	_buf.appendUint(countryRestrictionInverted);
	_buf.append(',');
	_buf.append("restrictedCountries=");
	restrictedCountries.toTraceString(_buf);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("defaultBuyIn=");
	_buf.appendUint(defaultBuyIn);
	_buf.append(',');
	_buf.append("tableFlags2=");
	_buf.appendUint64(tableFlags2);
	_buf.append(',');
	_buf.append("brandMask=");
	_buf.appendUint(brandMask);
	_buf.append(',');
	_buf.append("poolBlockMinHands=");
	_buf.appendInt(poolBlockMinHands);
	_buf.append(',');
	_buf.append("tableTypeId=");
	_buf.appendUint(tableTypeId);
	_buf.append(',');
	_buf.append("tableStakes=");
	tableStakes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("variableAntes=");
	variableAntes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("visibilityMaskEx=");
	visibilityMaskEx.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::Personalization::TableStaticDataStruct::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT64(tableId);
	_msg.composeString(name);
	_msg.composeString(serverAddress);
	_msg.composeString(serverInstance);
	_msg.composeBYTE(isPlayMoney);
	_msg.composeBYTE(game);
	_msg.composeBYTE(isHiLo);
	_msg.composeBYTE(maxPlayers);
	_msg.composeUINT32(tableFlags);
	_msg.composeUINT32(tableInstanceFlags);
	_msg.composeUINT16(chatLang);
	_msg.composeBYTE(structure);
	_msg.composeUINT32(loBet);
	_msg.composeUINT32(hiBet);
	_msg.composeUINT32(ante);
	_msg.composeUINT32(cap);
	_msg.composeString(specialName);
	_msg.composeString(currency);
	_msg.composeUINT32(minChipsLimit);
	_msg.composeUINT32(maxBuyIn);
	_msg.composeBYTE(icon);
	_msg.composeBYTE(filter);
	_msg.composeBOOL(countryRestrictionInverted);
	restrictedCountries.composeMsg(_msg);
	_msg.composeUINT32(scalePM);
	_msg.composeUINT32(defaultBuyIn);
	_msg.composeUINT64(tableFlags2);
	_msg.composeUINT32(brandMask);
	_msg.composeINT32(poolBlockMinHands);
	_msg.composeUINT32(tableTypeId);
	tableStakes.composeMsg(_msg);
	variableAntes.composeMsg(_msg);
	visibilityMaskEx.composeMsg(_msg);
}

void Lobby::Personalization::TableStaticDataStruct::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(tableId);
	_parser.parseStringP(name);
	_parser.parseStringP(serverAddress);
	_parser.parseStringP(serverInstance);
	_parser.parseBYTE(isPlayMoney);
	_parser.parseBYTE(game);
	_parser.parseBYTE(isHiLo);
	_parser.parseBYTE(maxPlayers);
	_parser.parseUINT32(tableFlags);
	_parser.parseUINT32(tableInstanceFlags);
	_parser.parseUINT16(chatLang);
	_parser.parseBYTE(structure);
	_parser.parseUINT32(loBet);
	_parser.parseUINT32(hiBet);
	_parser.parseUINT32(ante);
	_parser.parseUINT32(cap);
	_parser.parseStringP(specialName);
	_parser.parseStringP(currency);
	_parser.parseUINT32(minChipsLimit);
	_parser.parseUINT32(maxBuyIn);
	_parser.parseBYTE(icon);
	_parser.parseBYTE(filter);
	_parser.parseBOOL(countryRestrictionInverted);
	restrictedCountries.parseMsg(_parser);
	_parser.parseUINT32(scalePM);
	_parser.parseUINT32(defaultBuyIn);
	_parser.parseUINT64(tableFlags2);
	_parser.parseUINT32(brandMask);
	_parser.parseINT32(poolBlockMinHands);
	_parser.parseUINT32(tableTypeId);
	tableStakes.parseMsg(_parser);
	variableAntes.parseMsg(_parser);
	visibilityMaskEx.parseMsg(_parser);
}

/*static*/ void Lobby::Personalization::TableStaticDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT64 tableId; _parser.parseUINT64(tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "serverAddress"); size_t szServerAddress = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverAddress", szServerAddress, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "serverInstance"); size_t szServerInstance = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverInstance", szServerInstance, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE maxPlayers; _parser.parseBYTE(maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	UINT32 tableFlags; _parser.parseUINT32(tableFlags);
	AtfValidator::validateInt(_descr, "tableFlags", tableFlags, _checker, __FILE__, __LINE__);
	UINT32 tableInstanceFlags; _parser.parseUINT32(tableInstanceFlags);
	AtfValidator::validateInt(_descr, "tableInstanceFlags", tableInstanceFlags, _checker, __FILE__, __LINE__);
	UINT16 chatLang; _parser.parseUINT16(chatLang);
	AtfValidator::validateInt(_descr, "chatLang", chatLang, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	UINT32 loBet; _parser.parseUINT32(loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	UINT32 hiBet; _parser.parseUINT32(hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	UINT32 ante; _parser.parseUINT32(ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	UINT32 cap; _parser.parseUINT32(cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "specialName"); size_t szSpecialName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "specialName", szSpecialName, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 minChipsLimit; _parser.parseUINT32(minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	UINT32 maxBuyIn; _parser.parseUINT32(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	BYTE icon; _parser.parseBYTE(icon);
	AtfValidator::validateInt(_descr, "icon", icon, _checker, __FILE__, __LINE__);
	BYTE filter; _parser.parseBYTE(filter);
	AtfValidator::validateInt(_descr, "filter", filter, _checker, __FILE__, __LINE__);
	bool countryRestrictionInverted; _parser.parseBOOL(countryRestrictionInverted);
	AtfValidator::validateInt(_descr, "countryRestrictionInverted", countryRestrictionInverted, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szRestrictedCountries = ThinAtf::LAtfVector< PString, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("restrictedCountries"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "restrictedCountries", szRestrictedCountries, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT32 defaultBuyIn; _parser.parseUINT32(defaultBuyIn);
	AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	UINT64 tableFlags2; _parser.parseUINT64(tableFlags2);
	AtfValidator::validateUint(_descr, "tableFlags2", tableFlags2, _checker, __FILE__, __LINE__);
	UINT32 brandMask; _parser.parseUINT32(brandMask);
	AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
	INT32 poolBlockMinHands; _parser.parseINT32(poolBlockMinHands);
	AtfValidator::validateInt(_descr, "poolBlockMinHands", poolBlockMinHands, _checker, __FILE__, __LINE__);
	UINT32 tableTypeId; _parser.parseUINT32(tableTypeId);
	AtfValidator::validateInt(_descr, "tableTypeId", tableTypeId, _checker, __FILE__, __LINE__);
	TableCommonThin::TableStakes::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableStakes"), _fieldsWithUnparsedContent);
	int szVariableAntes = ThinAtf::LAtfVector< INT64, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("variableAntes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "variableAntes", szVariableAntes, _checker, __FILE__, __LINE__);
	PSiteMask::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("visibilityMaskEx"), _fieldsWithUnparsedContent);
}

//=================================================================
//                    TableData
//=================================================================

Lobby::Personalization::TableData::TableData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::Personalization::TableData::TableData(TableData&& _o)
	: staticData(std::move(_o.staticData))
{
}

Lobby::Personalization::TableData& Lobby::Personalization::TableData::operator=(TableData&& _o)
{
	if(this != &_o)
	{
		staticData = std::move(_o.staticData);
	}
	return *this;
}

#endif

void Lobby::Personalization::TableData::clear()
{
	staticData.clear();
}

bool Lobby::Personalization::TableData::equals(const TableData& _o) const
{
	return staticData.equals(_o.staticData);
}

const char *Lobby::Personalization::TableData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("staticData=");
	staticData.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void Lobby::Personalization::TableData::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(TableData())) // not empty
	{
		staticData.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::Personalization::TableData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	staticData.parseMsg(_parser0);
}

/*static*/ void Lobby::Personalization::TableData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	TableStaticDataStruct::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("staticData"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS
//=================================================================

Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS(Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS&& _o)
	: tableIds(std::move(_o.tableIds))
{
}

Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS& Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS::operator=(Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS&& _o)
{
	if(this != &_o)
	{
		tableIds = std::move(_o.tableIds);
	}
	return *this;
}

#endif

void Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS::clear()
{
	tableIds.clear();
}

bool Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS::equals(const Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS& _o) const
{
	return tableIds.equals(_o.tableIds);
}

const char *Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS).append(")");
	_buf.append(',');
	_buf.append("tableIds=");
	tableIds.toTraceString(_buf);
	return _buf.c_str();
}

void Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS::composeMsg(CommMsgBody& _msg) const
{
	tableIds.composeMsg(_msg);
}

void Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS::parseMsg(CommMsgParser& _parser)
{
	tableIds.parseMsg(_parser);
}

/*static*/ void Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTableIds = ThinAtf::LAtfVector< UINT64, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableIds"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tableIds", szTableIds, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY
//=================================================================

Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY(Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, tables(std::move(_o.tables))
{
}

Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY& Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY::operator=(Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		tables = std::move(_o.tables);
	}
	return *this;
}

#endif

void Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	tables.clear();
}

bool Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY::equals(const Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		tables.equals(_o.tables);
}

const char *Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("tables=");
		tables.toTraceString(_buf);
	}
	return _buf.c_str();
}

void Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		tables.composeMsg(_msg);
	}
}

void Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		tables.parseMsg(_parser);
	}
}

/*static*/ void Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szTables = ThinAtf::LAtfVector< TableData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tables"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tables", szTables, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ bool Lobby::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "Personalization"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS: Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY: Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_PS_USER_AT: Personalization::Protocol_MSG_LOBBY_PS_USER_AT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_PS_USER_AT_REPLY: Personalization::Protocol_MSG_LOBBY_PS_USER_AT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_CLI_LOBBY_CONFIRM_POPUP: cli::Protocol_MSG_CLI_LOBBY_CONFIRM_POPUP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CLI_LOBBY_FIND_QUICKSTART_SNG: cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2: cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY: cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3: cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY: cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY: cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_ACTIVATE_ACCOUNT: cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY: cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_ADMIN_INFO: cli::Protocol_MSG_LOBBY_ADMIN_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_ADMIN_INFO_REPLY: cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_BE_AVC_RESEND: cli::Protocol_MSG_LOBBY_BE_AVC_RESEND::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_BE_AVC_RESEND_REPLY: cli::Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_BE_AVC_VALIDATE: cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_BE_AVC_VALIDATE_REPLY: cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CANCEL_RESERVED_SEAT: cli::Protocol_MSG_LOBBY_CANCEL_RESERVED_SEAT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CANCEL_USERTOURN: cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CANCEL_USERTOURN_REPLY: cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CHALLENGE_QUESTION: cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CHALLENGE_QUESTION_REPLY: cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CHAT_COMPL: cli::Protocol_MSG_LOBBY_CHAT_COMPL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLIENT_CURR_CONV_OPT: cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY: cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLIENT_QUEST: cli::Protocol_MSG_LOBBY_CLIENT_QUEST::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLI_BOUNCED: cli::Protocol_MSG_LOBBY_CLI_BOUNCED::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLI_BOUNCED_REPLY: cli::Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLI_GET_TLB_STANDIDNS2: cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY: cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLI_REMATCH_ACCEPT: cli::Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLI_REMATCH_DECLINE: cli::Protocol_MSG_LOBBY_CLI_REMATCH_DECLINE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLI_TEAM_PS_ONLINE: cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY: cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CREATE_TOURNAMENT_REPLY: cli::Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CREATE_USERTOURN: cli::Protocol_MSG_LOBBY_CREATE_USERTOURN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_DISABLE_SNG_AUTO_UNREG: cli::Protocol_MSG_LOBBY_DISABLE_SNG_AUTO_UNREG::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_DONT_SHOW_PERSONAL_INFO: cli::Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_DONT_SHOW_WHERE: cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_DONT_SHOW_WHERE_REPLY: cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_EXCLUDE_PLAYER: cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_EXCLUDE_PLAYER_REPLY: cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_PLAYER2: cli::Protocol_MSG_LOBBY_FIND_PLAYER2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_PLAYER2_REPLY: cli::Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_PLAYER3: cli::Protocol_MSG_LOBBY_FIND_PLAYER3::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_PLAYER3_REPLY: cli::Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF: cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY: cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_SEAT_MANAGER_TABLE: cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2: cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY: cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_SIMILAR_TABLE: cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE: cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY: cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_SIMILAR_TABLE_STOP: cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_STOP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TABLE_TO_OBSERVE: cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY: cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TOURN: cli::Protocol_MSG_LOBBY_FIND_TOURN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TOURN_IT: cli::Protocol_MSG_LOBBY_FIND_TOURN_IT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TOURN_IT_REPLY: cli::Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TOURN_REG: cli::Protocol_MSG_LOBBY_FIND_TOURN_REG::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TOURN_REG2: cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TOURN_REG2_REPLY: cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TOURN_REG_IT: cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TOURN_REG_IT_REPLY: cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TOURN_REG_REPLY: cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TOURN_REPLY: cli::Protocol_MSG_LOBBY_FIND_TOURN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_WAIT: cli::Protocol_MSG_LOBBY_FIND_WAIT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_WAIT_REPLY: cli::Protocol_MSG_LOBBY_FIND_WAIT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FR_AVC_RESEND: cli::Protocol_MSG_LOBBY_FR_AVC_RESEND::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FR_AVC_RESEND_REPLY: cli::Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FR_AVC_VALIDATE: cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FR_AVC_VALIDATE_REPLY: cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_BUYIN_LIMIT: cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_BUYIN_LIMIT_EX: cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY: cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_BUYIN_LIMIT_REPLY: cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_CLIENT_OPTIONS: cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY: cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_CONSENTS: cli::Protocol_MSG_LOBBY_GET_CONSENTS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_CONSENTS_REPLY: cli::Protocol_MSG_LOBBY_GET_CONSENTS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT: cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY: cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_JOINED_SEATFINDERS: cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY: cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_PLAYING_TIME_LIMIT: cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY: cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_PROMO_IMAGE: cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_PROMO_IMAGE_REPLY: cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_SELFEXCLUDED_STR: cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY: cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_SIMILAR_SATELLITES: cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY: cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_TLB: cli::Protocol_MSG_LOBBY_GET_TLB::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_TLB_REPLY: cli::Protocol_MSG_LOBBY_GET_TLB_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_USER_CAPS: cli::Protocol_MSG_LOBBY_GET_USER_CAPS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_USER_CAPS_REPLY: cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_USER_INFO: cli::Protocol_MSG_LOBBY_GET_USER_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_USER_INFO_REPLY: cli::Protocol_MSG_LOBBY_GET_USER_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_HIDE_MOBILE_ICON: cli::Protocol_MSG_LOBBY_HIDE_MOBILE_ICON::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_HISTORY_REQUEST: cli::Protocol_MSG_LOBBY_HISTORY_REQUEST::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_HISTORY_REQUEST_REPLY: cli::Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_INIT_NETVERIFY_SESSION: cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY: cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_INTELLIPOKER_PWD: cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_INTELLIPOKER_PWD_REPLY: cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_INTELLIPOKER_SIGNUP: cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY: cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_IP_CHECK: cli::Protocol_MSG_LOBBY_IP_CHECK::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_IT_DOCUMENT: cli::Protocol_MSG_LOBBY_IT_DOCUMENT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_IT_DOCUMENT_REPLY: cli::Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_JOIN_SEATFINDER: cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_JOIN_SEATFINDER_REPLY: cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_LEAVE_ALL_WAITING_LISTS: cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY: cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_LEAVE_WAITING_LIST: cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_LEAVE_WAITING_LIST_REPLY: cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_LIST_REMOVE: cli::Protocol_MSG_LOBBY_LIST_REMOVE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_LOGOUT: cli::Protocol_MSG_LOBBY_LOGOUT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_LOGOUT_CONFIRM: cli::Protocol_MSG_LOBBY_LOGOUT_CONFIRM::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_MIGRATION_CONVERT: cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_MIGRATION_CONVERT_REPLY: cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_MIGRATION_GET_INFO: cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_MIGRATION_GET_INFO_REPLY: cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_MIGRATION_LINK: cli::Protocol_MSG_LOBBY_MIGRATION_LINK::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_MIGRATION_LINK_REPLY: cli::Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_MIGRATION_TRANSFER: cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_MIGRATION_TRANSFER_REPLY: cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_PLAYING_HISTORY_AUDIT: cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY: cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_PUBLISH_VIP_STATUS: cli::Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_REGISTER_TOURN_USER: cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_REGISTER_TOURN_USER_REPLY: cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_REPORT_FIRST_LOGIN: cli::Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_RESEND_ACTIVATION_EMAIL: cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY: cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_RESEND_MOBILE_VALIDATION: cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY: cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE: cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY: cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT: cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY: cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SEATFINDER_CHECK_CHIPS: cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY: cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_BUYIN_LIMIT: cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_BUYIN_LIMIT_EX: cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY: cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_BUYIN_LIMIT_REPLY: cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_CLIENT_OPTIONS: cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY: cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_PLAYING_TIME_LIMIT: cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY: cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_PROMO_IMAGE: cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_PROMO_IMAGE_REPLY: cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_TABLE_LIMITS2: cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_TABLE_LIMITS2_REPLY: cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_TOURN_EMAIL_FLAGS: cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY: cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_TOURN_LIMITS: cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_TOURN_LIMITS_REPLY: cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP: cli::Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SOCIAL_SHARE_HAND: cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY: cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SUBMIT_STARCODE: cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SUBMIT_STARCODE_REPLY: cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_TARGET_NEWS_DESKTOP: cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_TARGET_NEWS_MOBILE: cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_TICKET_TOURNTIDS: cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_TICKET_TOURNTIDS_REPLY: cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_TIMEZONE_SET: cli::Protocol_MSG_LOBBY_TIMEZONE_SET::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_TIMEZONE_SET_REPLY: cli::Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_TOURN_STATS: cli::Protocol_MSG_LOBBY_TOURN_STATS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_TOURN_STATS_REPLY: cli::Protocol_MSG_LOBBY_TOURN_STATS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_UNJOIN_SEATFINDER: cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_UNJOIN_SEATFINDER_REPLY: cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_UPDATE_DOB: cli::Protocol_MSG_LOBBY_UPDATE_DOB::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_UPDATE_DOB_REPLY: cli::Protocol_MSG_LOBBY_UPDATE_DOB_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_USER_PROPS: cli::Protocol_MSG_LOBBY_USER_PROPS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_USER_PROPS_REPLY: cli::Protocol_MSG_LOBBY_USER_PROPS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_USER_STATS: cli::Protocol_MSG_LOBBY_USER_STATS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_USER_STATS_REPLY: cli::Protocol_MSG_LOBBY_USER_STATS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_USER_TOURNTICKETS2: cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_USER_TOURNTICKETS2_REPLY: cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_VALIDATE_MOBILE: cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_VALIDATE_MOBILE_REPLY: cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_VALIDATE_NEWINSTALL: cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY: cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_WAITING_LIST: cli::Protocol_MSG_LOBBY_WAITING_LIST::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_WAITING_LIST_REPLY: cli::Protocol_MSG_LOBBY_WAITING_LIST_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_WAIT_ON_TABLES: cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_WAIT_ON_TABLES_REPLY: cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_WAITING_INVITED_REPLY: cli::Protocol_MSG_WAITING_INVITED_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_WEB_FIND_PLAYER2: cli::Protocol_MSG_WEB_FIND_PLAYER2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_WEB_FIND_PLAYER2_REPLY: cli::Protocol_MSG_WEB_FIND_PLAYER2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_WEB_FIND_PLAYER3: cli::Protocol_MSG_WEB_FIND_PLAYER3::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_WEB_FIND_PLAYER3_REPLY: cli::Protocol_MSG_WEB_FIND_PLAYER3_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_WEB_FIND_TOURN: cli::Protocol_MSG_WEB_FIND_TOURN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_WEB_FIND_TOURN_REPLY: cli::Protocol_MSG_WEB_FIND_TOURN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "lobby_unauth"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_CHALLENGE_QUESTION: lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CHALLENGE_QUESTION_REPLY: lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CHECK_PUBLICATIONS: lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CHECK_PUBLICATIONS_REPLY: lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLIENT_ERROR: lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLIENT_ERROR_REPLY: lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TABLE_TO_OBSERVE: lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY: lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_CAPTCHA: lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_CAPTCHA_REPLY: lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_SATELLITES_TO_TOURN: lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX: lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY: lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY: lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_TABLE_BY_ID: lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_TABLE_BY_ID_REPLY: lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_PROMO_COUNTRY: lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_PROMO_COUNTRY_REPLY: lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_REPORT_INSTALL: lobby_unauth::Protocol_MSG_LOBBY_REPORT_INSTALL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_UPDATE_BY_LICENSE: lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_UPDATE_BY_LICENSE_REPLY: lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

