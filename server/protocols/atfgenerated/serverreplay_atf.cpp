/**
 * serverreplay_atf.cpp
 *
 * This file was auto-generated from serverreplay_atf.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: serverreplay_atf.txt
 */
 
#include "serverreplay_atf.h"

//=================================================================
//                Protocol_MSG_TABLE_LOGIN
//=================================================================

ServerReplay::cli::Protocol_MSG_TABLE_LOGIN::Protocol_MSG_TABLE_LOGIN()
{
	clear();
}

void ServerReplay::cli::Protocol_MSG_TABLE_LOGIN::clear()
{
	user.clear();
	clientSiteId = 0;
	notShowWhenAllIn = false;
	sitOutNextHand = false;
	useAllInitStacks = false;
}

bool ServerReplay::cli::Protocol_MSG_TABLE_LOGIN::equals(const Protocol_MSG_TABLE_LOGIN& _o) const
{
	return Atf::atfPStringEquals(user, _o.user) &&
		clientSiteId == _o.clientSiteId &&
		notShowWhenAllIn == _o.notShowWhenAllIn &&
		sitOutNextHand == _o.sitOutNextHand &&
		useAllInitStacks == _o.useAllInitStacks;
}

bool ServerReplay::cli::Protocol_MSG_TABLE_LOGIN::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_LOGIN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_LOGIN*)_other));
}

const char *ServerReplay::cli::Protocol_MSG_TABLE_LOGIN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_LOGIN).append(")");
	_buf.append(',');
	_buf.append("user=");
	_buf.append(user);
	_buf.append(',');
	_buf.append("clientSiteId=");
	_buf.appendUint(clientSiteId);
	_buf.append(',');
	_buf.append("notShowWhenAllIn=");
	_buf.appendUint(notShowWhenAllIn);
	_buf.append(',');
	_buf.append("sitOutNextHand=");
	_buf.appendUint(sitOutNextHand);
	_buf.append(',');
	_buf.append("useAllInitStacks=");
	_buf.appendUint(useAllInitStacks);
	return _buf.c_str();
}

const char *ServerReplay::cli::Protocol_MSG_TABLE_LOGIN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ServerReplay::cli::Protocol_MSG_TABLE_LOGIN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_LOGIN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("user", user, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientSiteId", clientSiteId, _buf);
	Atf::XmlElement::encodeAsXmlElement("notShowWhenAllIn", notShowWhenAllIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("sitOutNextHand", sitOutNextHand, _buf);
	Atf::XmlElement::encodeAsXmlElement("useAllInitStacks", useAllInitStacks, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ServerReplay::cli::Protocol_MSG_TABLE_LOGIN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("user"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, user)) return false;
			}
			else if (_element.equals("clientSiteId"))
			{
				clientSiteId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("notShowWhenAllIn"))
			{
				notShowWhenAllIn = (*_value.ptr() == '1');
			}
			else if (_element.equals("sitOutNextHand"))
			{
				sitOutNextHand = (*_value.ptr() == '1');
			}
			else if (_element.equals("useAllInitStacks"))
			{
				useAllInitStacks = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ServerReplay::cli::Protocol_MSG_TABLE_LOGIN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(user);
	_msg.composeUINT32(clientSiteId);
	_msg.composeBOOL(notShowWhenAllIn);
	_msg.composeBOOL(sitOutNextHand);
	_msg.composeBOOL(useAllInitStacks);
}

void ServerReplay::cli::Protocol_MSG_TABLE_LOGIN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(user);
	_parser.parseUINT32(clientSiteId);
	_parser.parseBOOL(notShowWhenAllIn);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(sitOutNextHand);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(useAllInitStacks);
}

const char *ServerReplay::cli::Protocol_MSG_TABLE_LOGIN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("user", user);
	_jsonstr.compose("clientSiteId", clientSiteId);
	_jsonstr.compose("notShowWhenAllIn", notShowWhenAllIn);
	_jsonstr.compose("sitOutNextHand", sitOutNextHand);
	_jsonstr.compose("useAllInitStacks", useAllInitStacks);
	return _buf.c_str();
}

void ServerReplay::cli::Protocol_MSG_TABLE_LOGIN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("user", user);
	_jparser.parseByNameThrow("clientSiteId", clientSiteId);
	_jparser.parseByNameThrow("notShowWhenAllIn", notShowWhenAllIn);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("sitOutNextHand", sitOutNextHand);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("useAllInitStacks", useAllInitStacks);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_TABLE_LOGIN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_LOGIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString user; _jparser.validateByNameThrow("user", user);
	AtfValidator::validateIntMax(_descr, "user", user.length(), 20, _checker, __FILE__, __LINE__);
	UINT32 clientSiteId; _jparser.validateByNameThrow("clientSiteId", clientSiteId);
	AtfValidator::validateIntMax(_descr, "clientSiteId", clientSiteId, PokerStars_Last, _checker, __FILE__, __LINE__);
	bool notShowWhenAllIn; _jparser.validateByNameThrow("notShowWhenAllIn", notShowWhenAllIn);
	AtfValidator::validateInt(_descr, "notShowWhenAllIn", notShowWhenAllIn, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool sitOutNextHand; _jparser.validateByNameThrow("sitOutNextHand", sitOutNextHand);
	AtfValidator::validateInt(_descr, "sitOutNextHand", sitOutNextHand, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool useAllInitStacks; _jparser.validateByNameThrow("useAllInitStacks", useAllInitStacks);
	AtfValidator::validateInt(_descr, "useAllInitStacks", useAllInitStacks, _checker, __FILE__, __LINE__);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_TABLE_LOGIN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_LOGIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "user"); size_t szUser = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "user", szUser, 20, _checker, __FILE__, __LINE__);
	UINT32 clientSiteId; _parser.parseUINT32(clientSiteId);
	AtfValidator::validateIntMax(_descr, "clientSiteId", clientSiteId, PokerStars_Last, _checker, __FILE__, __LINE__);
	bool notShowWhenAllIn; _parser.parseBOOL(notShowWhenAllIn);
	AtfValidator::validateInt(_descr, "notShowWhenAllIn", notShowWhenAllIn, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool sitOutNextHand; _parser.parseBOOL(sitOutNextHand);
	AtfValidator::validateInt(_descr, "sitOutNextHand", sitOutNextHand, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool useAllInitStacks; _parser.parseBOOL(useAllInitStacks);
	AtfValidator::validateInt(_descr, "useAllInitStacks", useAllInitStacks, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_LOGIN_REPLY
//=================================================================

ServerReplay::cli::Protocol_MSG_TABLE_LOGIN_REPLY::Protocol_MSG_TABLE_LOGIN_REPLY()
{
	clear();
}

void ServerReplay::cli::Protocol_MSG_TABLE_LOGIN_REPLY::clear()
{
	errCode = 0;
	errStr.clear();
	seat = 0;
	sittingOut = 0;
	clientIP.clear();
	privilege = 0;
	clientMsg_txtEx.clear();
	autoRebuyOptions = 0;
	autoRebuyBigBets = 0;
	autoRebuyFallUnderBigBets = 0;
	autoRebuyFallUnderPercents = 0;
	playerRITFavored = false;
	campingPreventionEnabled = false;
	isTableDealingHands = false;
	campingCountingDownSec = 0;
}

bool ServerReplay::cli::Protocol_MSG_TABLE_LOGIN_REPLY::equals(const Protocol_MSG_TABLE_LOGIN_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr) &&
		seat == _o.seat &&
		sittingOut == _o.sittingOut &&
		privilege == _o.privilege &&
		clientMsg_txtEx.equals(_o.clientMsg_txtEx) &&
		autoRebuyOptions == _o.autoRebuyOptions &&
		autoRebuyBigBets == _o.autoRebuyBigBets &&
		autoRebuyFallUnderBigBets == _o.autoRebuyFallUnderBigBets &&
		autoRebuyFallUnderPercents == _o.autoRebuyFallUnderPercents &&
		playerRITFavored == _o.playerRITFavored &&
		campingPreventionEnabled == _o.campingPreventionEnabled &&
		isTableDealingHands == _o.isTableDealingHands &&
		campingCountingDownSec == _o.campingCountingDownSec;
}

bool ServerReplay::cli::Protocol_MSG_TABLE_LOGIN_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_LOGIN_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_LOGIN_REPLY*)_other));
}

const char *ServerReplay::cli::Protocol_MSG_TABLE_LOGIN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_LOGIN_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendUint(errCode);
	_buf.append(',');
	_buf.append("errStr=");
	_buf.append(errStr);
	_buf.append(',');
	_buf.append("seat=");
	_buf.appendInt(seat);
	_buf.append(',');
	_buf.append("sittingOut=");
	_buf.appendUint(sittingOut);
	_buf.append(',');
	_buf.append("clientIP=");
	_buf.append(clientIP);
	_buf.append(',');
	_buf.append("privilege=");
	_buf.appendUint(privilege);
	_buf.append(',');
	_buf.append("clientMsg_txtEx=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(clientMsg_txtEx, _buf); _buf.append('}');
	_buf.append(',');
	_buf.append("autoRebuyOptions=");
	_buf.appendInt(autoRebuyOptions);
	_buf.append(',');
	_buf.append("autoRebuyBigBets=");
	_buf.appendUint(autoRebuyBigBets);
	_buf.append(',');
	_buf.append("autoRebuyFallUnderBigBets=");
	_buf.appendUint(autoRebuyFallUnderBigBets);
	_buf.append(',');
	_buf.append("autoRebuyFallUnderPercents=");
	_buf.appendUint(autoRebuyFallUnderPercents);
	_buf.append(',');
	_buf.append("playerRITFavored=");
	_buf.appendUint(playerRITFavored);
	_buf.append(',');
	_buf.append("campingPreventionEnabled=");
	_buf.appendUint(campingPreventionEnabled);
	_buf.append(',');
	_buf.append("isTableDealingHands=");
	_buf.appendUint(isTableDealingHands);
	_buf.append(',');
	_buf.append("campingCountingDownSec=");
	_buf.appendUint(campingCountingDownSec);
	return _buf.c_str();
}

const char *ServerReplay::cli::Protocol_MSG_TABLE_LOGIN_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ServerReplay::cli::Protocol_MSG_TABLE_LOGIN_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_LOGIN_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("seat", seat, _buf);
	Atf::XmlElement::encodeAsXmlElement("sittingOut", sittingOut, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientIP", clientIP, _buf);
	Atf::XmlElement::encodeAsXmlElement("privilege", privilege, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientMsg_txtEx", clientMsg_txtEx, _buf);
	Atf::XmlElement::encodeAsXmlElement("autoRebuyOptions", autoRebuyOptions, _buf);
	Atf::XmlElement::encodeAsXmlElement("autoRebuyBigBets", autoRebuyBigBets, _buf);
	Atf::XmlElement::encodeAsXmlElement("autoRebuyFallUnderBigBets", autoRebuyFallUnderBigBets, _buf);
	Atf::XmlElement::encodeAsXmlElement("autoRebuyFallUnderPercents", autoRebuyFallUnderPercents, _buf);
	Atf::XmlElement::encodeAsXmlElement("playerRITFavored", playerRITFavored, _buf);
	Atf::XmlElement::encodeAsXmlElement("campingPreventionEnabled", campingPreventionEnabled, _buf);
	Atf::XmlElement::encodeAsXmlElement("isTableDealingHands", isTableDealingHands, _buf);
	Atf::XmlElement::encodeAsXmlElement("campingCountingDownSec", campingCountingDownSec, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ServerReplay::cli::Protocol_MSG_TABLE_LOGIN_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else if (_element.equals("seat"))
			{
				seat = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("sittingOut"))
			{
				sittingOut = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientIP"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, clientIP)) return false;
			}
			else if (_element.equals("privilege"))
			{
				privilege = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientMsg_txtEx"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, clientMsg_txtEx)) return false;
			}
			else if (_element.equals("autoRebuyOptions"))
			{
				autoRebuyOptions = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("autoRebuyBigBets"))
			{
				autoRebuyBigBets = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("autoRebuyFallUnderBigBets"))
			{
				autoRebuyFallUnderBigBets = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("autoRebuyFallUnderPercents"))
			{
				autoRebuyFallUnderPercents = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("playerRITFavored"))
			{
				playerRITFavored = (*_value.ptr() == '1');
			}
			else if (_element.equals("campingPreventionEnabled"))
			{
				campingPreventionEnabled = (*_value.ptr() == '1');
			}
			else if (_element.equals("isTableDealingHands"))
			{
				isTableDealingHands = (*_value.ptr() == '1');
			}
			else if (_element.equals("campingCountingDownSec"))
			{
				campingCountingDownSec = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ServerReplay::cli::Protocol_MSG_TABLE_LOGIN_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(errCode);
	_msg.composeString(errStr);
	_msg.composeINT8(seat);
	_msg.composeBYTE(sittingOut);
	_msg.composeString(clientIP);
	_msg.composeUINT32(privilege);
	_msg.composeMsgBody(clientMsg_txtEx);
	_msg.composeINT8(autoRebuyOptions);
	_msg.composeUINT16(autoRebuyBigBets);
	_msg.composeUINT16(autoRebuyFallUnderBigBets);
	_msg.composeUINT16(autoRebuyFallUnderPercents);
	_msg.composeBOOL(playerRITFavored);
	_msg.composeBOOL(campingPreventionEnabled);
	_msg.composeBOOL(isTableDealingHands);
	_msg.composeUINT16(campingCountingDownSec);
}

void ServerReplay::cli::Protocol_MSG_TABLE_LOGIN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(errCode);
	_parser.parseStringP(errStr);
	_parser.parseINT8(seat);
	_parser.parseBYTE(sittingOut);
	_parser.parseStringP(clientIP);
	_parser.parseUINT32(privilege);
	_parser.parseMsgBody(clientMsg_txtEx);
	_parser.parseINT8(autoRebuyOptions);
	_parser.parseUINT16(autoRebuyBigBets);
	_parser.parseUINT16(autoRebuyFallUnderBigBets);
	_parser.parseUINT16(autoRebuyFallUnderPercents);
	_parser.parseBOOL(playerRITFavored);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(campingPreventionEnabled);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(isTableDealingHands);
	if(_parser.parseEnded()) return;
	_parser.parseUINT16(campingCountingDownSec);
}

const char *ServerReplay::cli::Protocol_MSG_TABLE_LOGIN_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errStr", errStr);
	_jsonstr.compose("seat", seat);
	_jsonstr.compose("sittingOut", sittingOut);
	_jsonstr.compose("clientIP", clientIP);
	_jsonstr.compose("privilege", privilege);
	_jsonstr.compose("clientMsg_txtEx", clientMsg_txtEx);
	_jsonstr.compose("autoRebuyOptions", autoRebuyOptions);
	_jsonstr.compose("autoRebuyBigBets", autoRebuyBigBets);
	_jsonstr.compose("autoRebuyFallUnderBigBets", autoRebuyFallUnderBigBets);
	_jsonstr.compose("autoRebuyFallUnderPercents", autoRebuyFallUnderPercents);
	_jsonstr.compose("playerRITFavored", playerRITFavored);
	_jsonstr.compose("campingPreventionEnabled", campingPreventionEnabled);
	_jsonstr.compose("isTableDealingHands", isTableDealingHands);
	_jsonstr.compose("campingCountingDownSec", campingCountingDownSec);
	return _buf.c_str();
}

void ServerReplay::cli::Protocol_MSG_TABLE_LOGIN_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errStr", errStr);
	_jparser.parseByNameThrow("seat", seat);
	_jparser.parseByNameThrow("sittingOut", sittingOut);
	_jparser.parseByNameThrow("clientIP", clientIP);
	_jparser.parseByNameThrow("privilege", privilege);
	_jparser.parseByNameThrow("clientMsg_txtEx", clientMsg_txtEx);
	_jparser.parseByNameThrow("autoRebuyOptions", autoRebuyOptions);
	_jparser.parseByNameThrow("autoRebuyBigBets", autoRebuyBigBets);
	_jparser.parseByNameThrow("autoRebuyFallUnderBigBets", autoRebuyFallUnderBigBets);
	_jparser.parseByNameThrow("autoRebuyFallUnderPercents", autoRebuyFallUnderPercents);
	_jparser.parseByNameThrow("playerRITFavored", playerRITFavored);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("campingPreventionEnabled", campingPreventionEnabled);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("isTableDealingHands", isTableDealingHands);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("campingCountingDownSec", campingCountingDownSec);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_TABLE_LOGIN_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_LOGIN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString errStr; _jparser.validateByNameThrow("errStr", errStr);
	AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	INT8 seat; _jparser.validateByNameThrow("seat", seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	BYTE sittingOut; _jparser.validateByNameThrow("sittingOut", sittingOut);
	AtfValidator::validateInt(_descr, "sittingOut", sittingOut, _checker, __FILE__, __LINE__);
	PString clientIP; _jparser.validateByNameThrow("clientIP", clientIP);
	AtfValidator::validateInt(_descr, "clientIP", clientIP.length(), _checker, __FILE__, __LINE__);
	UINT32 privilege; _jparser.validateByNameThrow("privilege", privilege);
	AtfValidator::validateInt(_descr, "privilege", privilege, _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody clientMsg_txtEx; _jparser.validateByNameThrow("clientMsg_txtEx", clientMsg_txtEx);
	AtfValidator::validateInt(_descr, "clientMsg_txtEx", clientMsg_txtEx._size(), _checker, __FILE__, __LINE__);
	INT8 autoRebuyOptions; _jparser.validateByNameThrow("autoRebuyOptions", autoRebuyOptions);
	AtfValidator::validateInt(_descr, "autoRebuyOptions", autoRebuyOptions, _checker, __FILE__, __LINE__);
	UINT16 autoRebuyBigBets; _jparser.validateByNameThrow("autoRebuyBigBets", autoRebuyBigBets);
	AtfValidator::validateInt(_descr, "autoRebuyBigBets", autoRebuyBigBets, _checker, __FILE__, __LINE__);
	UINT16 autoRebuyFallUnderBigBets; _jparser.validateByNameThrow("autoRebuyFallUnderBigBets", autoRebuyFallUnderBigBets);
	AtfValidator::validateInt(_descr, "autoRebuyFallUnderBigBets", autoRebuyFallUnderBigBets, _checker, __FILE__, __LINE__);
	UINT16 autoRebuyFallUnderPercents; _jparser.validateByNameThrow("autoRebuyFallUnderPercents", autoRebuyFallUnderPercents);
	AtfValidator::validateInt(_descr, "autoRebuyFallUnderPercents", autoRebuyFallUnderPercents, _checker, __FILE__, __LINE__);
	bool playerRITFavored; _jparser.validateByNameThrow("playerRITFavored", playerRITFavored);
	AtfValidator::validateInt(_descr, "playerRITFavored", playerRITFavored, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool campingPreventionEnabled; _jparser.validateByNameThrow("campingPreventionEnabled", campingPreventionEnabled);
	AtfValidator::validateInt(_descr, "campingPreventionEnabled", campingPreventionEnabled, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool isTableDealingHands; _jparser.validateByNameThrow("isTableDealingHands", isTableDealingHands);
	AtfValidator::validateInt(_descr, "isTableDealingHands", isTableDealingHands, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT16 campingCountingDownSec; _jparser.validateByNameThrow("campingCountingDownSec", campingCountingDownSec);
	AtfValidator::validateInt(_descr, "campingCountingDownSec", campingCountingDownSec, _checker, __FILE__, __LINE__);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_TABLE_LOGIN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_LOGIN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE errCode; _parser.parseBYTE(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	INT8 seat; _parser.parseINT8(seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	BYTE sittingOut; _parser.parseBYTE(sittingOut);
	AtfValidator::validateInt(_descr, "sittingOut", sittingOut, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "clientIP"); size_t szClientIP = strlen(_dummy);
	AtfValidator::validateInt(_descr, "clientIP", szClientIP, _checker, __FILE__, __LINE__);
	UINT32 privilege; _parser.parseUINT32(privilege);
	AtfValidator::validateInt(_descr, "privilege", privilege, _checker, __FILE__, __LINE__);
	size_t szClientMsg_txtEx; _parser.skipMsgBody(szClientMsg_txtEx);  /*clientMsg_txtEx*/
	AtfValidator::validateInt(_descr, "clientMsg_txtEx", szClientMsg_txtEx, _checker, __FILE__, __LINE__);
	INT8 autoRebuyOptions; _parser.parseINT8(autoRebuyOptions);
	AtfValidator::validateInt(_descr, "autoRebuyOptions", autoRebuyOptions, _checker, __FILE__, __LINE__);
	UINT16 autoRebuyBigBets; _parser.parseUINT16(autoRebuyBigBets);
	AtfValidator::validateInt(_descr, "autoRebuyBigBets", autoRebuyBigBets, _checker, __FILE__, __LINE__);
	UINT16 autoRebuyFallUnderBigBets; _parser.parseUINT16(autoRebuyFallUnderBigBets);
	AtfValidator::validateInt(_descr, "autoRebuyFallUnderBigBets", autoRebuyFallUnderBigBets, _checker, __FILE__, __LINE__);
	UINT16 autoRebuyFallUnderPercents; _parser.parseUINT16(autoRebuyFallUnderPercents);
	AtfValidator::validateInt(_descr, "autoRebuyFallUnderPercents", autoRebuyFallUnderPercents, _checker, __FILE__, __LINE__);
	bool playerRITFavored; _parser.parseBOOL(playerRITFavored);
	AtfValidator::validateInt(_descr, "playerRITFavored", playerRITFavored, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool campingPreventionEnabled; _parser.parseBOOL(campingPreventionEnabled);
	AtfValidator::validateInt(_descr, "campingPreventionEnabled", campingPreventionEnabled, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool isTableDealingHands; _parser.parseBOOL(isTableDealingHands);
	AtfValidator::validateInt(_descr, "isTableDealingHands", isTableDealingHands, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT16 campingCountingDownSec; _parser.parseUINT16(campingCountingDownSec);
	AtfValidator::validateInt(_descr, "campingCountingDownSec", campingCountingDownSec, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_CHAT
//=================================================================

ServerReplay::cli::Protocol_MSG_TABLE_CHAT::Protocol_MSG_TABLE_CHAT()
{
	clear();
}

void ServerReplay::cli::Protocol_MSG_TABLE_CHAT::clear()
{
	chat.clear();
}

bool ServerReplay::cli::Protocol_MSG_TABLE_CHAT::equals(const Protocol_MSG_TABLE_CHAT& _o) const
{
	return Atf::atfPStringEquals(chat, _o.chat);
}

bool ServerReplay::cli::Protocol_MSG_TABLE_CHAT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_CHAT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_CHAT*)_other));
}

const char *ServerReplay::cli::Protocol_MSG_TABLE_CHAT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_CHAT).append(")");
	_buf.append(',');
	_buf.append("chat=");
	_buf.append(chat);
	return _buf.c_str();
}

const char *ServerReplay::cli::Protocol_MSG_TABLE_CHAT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ServerReplay::cli::Protocol_MSG_TABLE_CHAT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_CHAT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("chat", chat, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ServerReplay::cli::Protocol_MSG_TABLE_CHAT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("chat"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, chat)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ServerReplay::cli::Protocol_MSG_TABLE_CHAT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(chat);
}

void ServerReplay::cli::Protocol_MSG_TABLE_CHAT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(chat);
}

const char *ServerReplay::cli::Protocol_MSG_TABLE_CHAT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("chat", chat);
	return _buf.c_str();
}

void ServerReplay::cli::Protocol_MSG_TABLE_CHAT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("chat", chat);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_TABLE_CHAT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_CHAT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString chat; _jparser.validateByNameThrow("chat", chat);
	AtfValidator::validateIntMax(_descr, "chat", chat.length(), MAX_CHAT_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_TABLE_CHAT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_CHAT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "chat"); size_t szChat = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "chat", szChat, MAX_CHAT_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_CHAT2
//=================================================================

ServerReplay::cli::Protocol_MSG_TABLE_CHAT2::Protocol_MSG_TABLE_CHAT2()
{
	clear();
}

void ServerReplay::cli::Protocol_MSG_TABLE_CHAT2::clear()
{
	chat.clear();
}

bool ServerReplay::cli::Protocol_MSG_TABLE_CHAT2::equals(const Protocol_MSG_TABLE_CHAT2& _o) const
{
	return Atf::atfPStringEquals(chat, _o.chat);
}

bool ServerReplay::cli::Protocol_MSG_TABLE_CHAT2::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_CHAT2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_CHAT2*)_other));
}

const char *ServerReplay::cli::Protocol_MSG_TABLE_CHAT2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_CHAT2).append(")");
	_buf.append(',');
	_buf.append("chat=");
	_buf.append(chat);
	return _buf.c_str();
}

const char *ServerReplay::cli::Protocol_MSG_TABLE_CHAT2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ServerReplay::cli::Protocol_MSG_TABLE_CHAT2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_CHAT2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("chat", chat, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ServerReplay::cli::Protocol_MSG_TABLE_CHAT2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("chat"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, chat)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ServerReplay::cli::Protocol_MSG_TABLE_CHAT2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(chat);
}

void ServerReplay::cli::Protocol_MSG_TABLE_CHAT2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(chat);
}

const char *ServerReplay::cli::Protocol_MSG_TABLE_CHAT2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("chat", chat);
	return _buf.c_str();
}

void ServerReplay::cli::Protocol_MSG_TABLE_CHAT2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("chat", chat);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_TABLE_CHAT2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_CHAT2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString chat; _jparser.validateByNameThrow("chat", chat);
	AtfValidator::validateIntMax(_descr, "chat", chat.length(), MAX_CHAT_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_TABLE_CHAT2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_CHAT2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "chat"); size_t szChat = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "chat", szChat, MAX_CHAT_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_CHAT2_REPLY
//=================================================================

ServerReplay::cli::Protocol_MSG_TABLE_CHAT2_REPLY::Protocol_MSG_TABLE_CHAT2_REPLY()
{
	clear();
}

void ServerReplay::cli::Protocol_MSG_TABLE_CHAT2_REPLY::clear()
{
	errCode = 0;
	errMsgBody.clear();
	chatMsg.clear();
}

bool ServerReplay::cli::Protocol_MSG_TABLE_CHAT2_REPLY::equals(const Protocol_MSG_TABLE_CHAT2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errMsgBody.equals(_o.errMsgBody) &&
		Atf::atfPStringEquals(chatMsg, _o.chatMsg);
}

bool ServerReplay::cli::Protocol_MSG_TABLE_CHAT2_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_CHAT2_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_CHAT2_REPLY*)_other));
}

const char *ServerReplay::cli::Protocol_MSG_TABLE_CHAT2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_CHAT2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendUint(errCode);
	_buf.append(',');
	_buf.append("errMsgBody=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(errMsgBody, _buf); _buf.append('}');
	_buf.append(',');
	_buf.append("chatMsg=");
	_buf.append(chatMsg);
	return _buf.c_str();
}

const char *ServerReplay::cli::Protocol_MSG_TABLE_CHAT2_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ServerReplay::cli::Protocol_MSG_TABLE_CHAT2_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_CHAT2_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errMsgBody", errMsgBody, _buf);
	Atf::XmlElement::encodeAsXmlElement("chatMsg", chatMsg, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ServerReplay::cli::Protocol_MSG_TABLE_CHAT2_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errMsgBody"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, errMsgBody)) return false;
			}
			else if (_element.equals("chatMsg"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, chatMsg)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ServerReplay::cli::Protocol_MSG_TABLE_CHAT2_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT16(errCode);
	_msg.composeMsgBody(errMsgBody);
	_msg.composeString(chatMsg);
}

void ServerReplay::cli::Protocol_MSG_TABLE_CHAT2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT16(errCode);
	_parser.parseMsgBody(errMsgBody);
	_parser.parseStringP(chatMsg);
}

const char *ServerReplay::cli::Protocol_MSG_TABLE_CHAT2_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errMsgBody", errMsgBody);
	_jsonstr.compose("chatMsg", chatMsg);
	return _buf.c_str();
}

void ServerReplay::cli::Protocol_MSG_TABLE_CHAT2_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errMsgBody", errMsgBody);
	_jparser.parseByNameThrow("chatMsg", chatMsg);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_TABLE_CHAT2_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_CHAT2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody errMsgBody; _jparser.validateByNameThrow("errMsgBody", errMsgBody);
	AtfValidator::validateInt(_descr, "errMsgBody", errMsgBody._size(), _checker, __FILE__, __LINE__);
	PString chatMsg; _jparser.validateByNameThrow("chatMsg", chatMsg);
	AtfValidator::validateInt(_descr, "chatMsg", chatMsg.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_TABLE_CHAT2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_CHAT2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT16 errCode; _parser.parseUINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	size_t szErrMsgBody; _parser.skipMsgBody(szErrMsgBody);  /*errMsgBody*/
	AtfValidator::validateInt(_descr, "errMsgBody", szErrMsgBody, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "chatMsg"); size_t szChatMsg = strlen(_dummy);
	AtfValidator::validateInt(_descr, "chatMsg", szChatMsg, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REPLAY_PAUSE
//=================================================================

ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE::Protocol_MSG_REPLAY_PAUSE()
{
	clear();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE::clear()
{
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE::equals(const Protocol_MSG_REPLAY_PAUSE& _o) const
{
	return true;
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REPLAY_PAUSE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REPLAY_PAUSE*)_other));
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REPLAY_PAUSE).append(")");
	return _buf.c_str();
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REPLAY_PAUSE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE::parseMsg(CommMsgParser& _parser)
{
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_PAUSE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_PAUSE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REPLAY_PAUSE_REPLY
//=================================================================

ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_REPLY::Protocol_MSG_REPLAY_PAUSE_REPLY()
{
	clear();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_REPLY::clear()
{
	errCode = 0;
	errMsg.clear();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_REPLY::equals(const Protocol_MSG_REPLAY_PAUSE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errMsg, _o.errMsg);
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REPLAY_PAUSE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REPLAY_PAUSE_REPLY*)_other));
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REPLAY_PAUSE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendUint(errCode);
	_buf.append(',');
	_buf.append("errMsg=");
	_buf.append(errMsg);
	return _buf.c_str();
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REPLAY_PAUSE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errMsg", errMsg, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errMsg"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errMsg)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT16(errCode);
	_msg.composeString(errMsg);
}

void ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT16(errCode);
	_parser.parseStringP(errMsg);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errMsg", errMsg);
	return _buf.c_str();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errMsg", errMsg);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_PAUSE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString errMsg; _jparser.validateByNameThrow("errMsg", errMsg);
	AtfValidator::validateInt(_descr, "errMsg", errMsg.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_PAUSE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT16 errCode; _parser.parseUINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errMsg"); size_t szErrMsg = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errMsg", szErrMsg, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REPLAY_RESUME
//=================================================================

ServerReplay::cli::Protocol_MSG_REPLAY_RESUME::Protocol_MSG_REPLAY_RESUME()
{
	clear();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_RESUME::clear()
{
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_RESUME::equals(const Protocol_MSG_REPLAY_RESUME& _o) const
{
	return true;
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_RESUME::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REPLAY_RESUME != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REPLAY_RESUME*)_other));
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_RESUME::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REPLAY_RESUME).append(")");
	return _buf.c_str();
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_RESUME::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_RESUME::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REPLAY_RESUME).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_RESUME::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ServerReplay::cli::Protocol_MSG_REPLAY_RESUME::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void ServerReplay::cli::Protocol_MSG_REPLAY_RESUME::parseMsg(CommMsgParser& _parser)
{
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_RESUME::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_RESUME::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_RESUME::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_RESUME";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_RESUME::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_RESUME";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REPLAY_RESUME_REPLY
//=================================================================

ServerReplay::cli::Protocol_MSG_REPLAY_RESUME_REPLY::Protocol_MSG_REPLAY_RESUME_REPLY()
{
	clear();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_RESUME_REPLY::clear()
{
	errCode = 0;
	errMsg.clear();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_RESUME_REPLY::equals(const Protocol_MSG_REPLAY_RESUME_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errMsg, _o.errMsg);
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_RESUME_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REPLAY_RESUME_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REPLAY_RESUME_REPLY*)_other));
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_RESUME_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REPLAY_RESUME_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendUint(errCode);
	_buf.append(',');
	_buf.append("errMsg=");
	_buf.append(errMsg);
	return _buf.c_str();
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_RESUME_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_RESUME_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REPLAY_RESUME_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errMsg", errMsg, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_RESUME_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errMsg"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errMsg)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ServerReplay::cli::Protocol_MSG_REPLAY_RESUME_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT16(errCode);
	_msg.composeString(errMsg);
}

void ServerReplay::cli::Protocol_MSG_REPLAY_RESUME_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT16(errCode);
	_parser.parseStringP(errMsg);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_RESUME_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errMsg", errMsg);
	return _buf.c_str();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_RESUME_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errMsg", errMsg);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_RESUME_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_RESUME_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString errMsg; _jparser.validateByNameThrow("errMsg", errMsg);
	AtfValidator::validateInt(_descr, "errMsg", errMsg.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_RESUME_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_RESUME_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT16 errCode; _parser.parseUINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errMsg"); size_t szErrMsg = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errMsg", szErrMsg, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REPLAY_NEXT_HAND
//=================================================================

ServerReplay::cli::Protocol_MSG_REPLAY_NEXT_HAND::Protocol_MSG_REPLAY_NEXT_HAND()
{
	clear();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_NEXT_HAND::clear()
{
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_NEXT_HAND::equals(const Protocol_MSG_REPLAY_NEXT_HAND& _o) const
{
	return true;
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_NEXT_HAND::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REPLAY_NEXT_HAND != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REPLAY_NEXT_HAND*)_other));
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_NEXT_HAND::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REPLAY_NEXT_HAND).append(")");
	return _buf.c_str();
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_NEXT_HAND::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_NEXT_HAND::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REPLAY_NEXT_HAND).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_NEXT_HAND::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ServerReplay::cli::Protocol_MSG_REPLAY_NEXT_HAND::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void ServerReplay::cli::Protocol_MSG_REPLAY_NEXT_HAND::parseMsg(CommMsgParser& _parser)
{
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_NEXT_HAND::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_NEXT_HAND::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_NEXT_HAND::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_NEXT_HAND";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_NEXT_HAND::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_NEXT_HAND";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REPLAY_NEXT_HAND_REPLY
//=================================================================

ServerReplay::cli::Protocol_MSG_REPLAY_NEXT_HAND_REPLY::Protocol_MSG_REPLAY_NEXT_HAND_REPLY()
{
	clear();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_NEXT_HAND_REPLY::clear()
{
	errCode = 0;
	errMsg.clear();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_NEXT_HAND_REPLY::equals(const Protocol_MSG_REPLAY_NEXT_HAND_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errMsg, _o.errMsg);
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_NEXT_HAND_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REPLAY_NEXT_HAND_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REPLAY_NEXT_HAND_REPLY*)_other));
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_NEXT_HAND_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REPLAY_NEXT_HAND_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendUint(errCode);
	_buf.append(',');
	_buf.append("errMsg=");
	_buf.append(errMsg);
	return _buf.c_str();
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_NEXT_HAND_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_NEXT_HAND_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REPLAY_NEXT_HAND_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errMsg", errMsg, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_NEXT_HAND_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errMsg"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errMsg)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ServerReplay::cli::Protocol_MSG_REPLAY_NEXT_HAND_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT16(errCode);
	_msg.composeString(errMsg);
}

void ServerReplay::cli::Protocol_MSG_REPLAY_NEXT_HAND_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT16(errCode);
	_parser.parseStringP(errMsg);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_NEXT_HAND_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errMsg", errMsg);
	return _buf.c_str();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_NEXT_HAND_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errMsg", errMsg);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_NEXT_HAND_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_NEXT_HAND_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString errMsg; _jparser.validateByNameThrow("errMsg", errMsg);
	AtfValidator::validateInt(_descr, "errMsg", errMsg.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_NEXT_HAND_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_NEXT_HAND_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT16 errCode; _parser.parseUINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errMsg"); size_t szErrMsg = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errMsg", szErrMsg, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REPLAY_PREV_HAND
//=================================================================

ServerReplay::cli::Protocol_MSG_REPLAY_PREV_HAND::Protocol_MSG_REPLAY_PREV_HAND()
{
	clear();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_PREV_HAND::clear()
{
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_PREV_HAND::equals(const Protocol_MSG_REPLAY_PREV_HAND& _o) const
{
	return true;
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_PREV_HAND::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REPLAY_PREV_HAND != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REPLAY_PREV_HAND*)_other));
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_PREV_HAND::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REPLAY_PREV_HAND).append(")");
	return _buf.c_str();
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_PREV_HAND::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_PREV_HAND::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REPLAY_PREV_HAND).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_PREV_HAND::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ServerReplay::cli::Protocol_MSG_REPLAY_PREV_HAND::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void ServerReplay::cli::Protocol_MSG_REPLAY_PREV_HAND::parseMsg(CommMsgParser& _parser)
{
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_PREV_HAND::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_PREV_HAND::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_PREV_HAND::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_PREV_HAND";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_PREV_HAND::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_PREV_HAND";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REPLAY_PREV_HAND_REPLY
//=================================================================

ServerReplay::cli::Protocol_MSG_REPLAY_PREV_HAND_REPLY::Protocol_MSG_REPLAY_PREV_HAND_REPLY()
{
	clear();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_PREV_HAND_REPLY::clear()
{
	errCode = 0;
	errMsg.clear();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_PREV_HAND_REPLY::equals(const Protocol_MSG_REPLAY_PREV_HAND_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errMsg, _o.errMsg);
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_PREV_HAND_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REPLAY_PREV_HAND_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REPLAY_PREV_HAND_REPLY*)_other));
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_PREV_HAND_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REPLAY_PREV_HAND_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendUint(errCode);
	_buf.append(',');
	_buf.append("errMsg=");
	_buf.append(errMsg);
	return _buf.c_str();
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_PREV_HAND_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_PREV_HAND_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REPLAY_PREV_HAND_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errMsg", errMsg, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_PREV_HAND_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errMsg"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errMsg)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ServerReplay::cli::Protocol_MSG_REPLAY_PREV_HAND_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT16(errCode);
	_msg.composeString(errMsg);
}

void ServerReplay::cli::Protocol_MSG_REPLAY_PREV_HAND_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT16(errCode);
	_parser.parseStringP(errMsg);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_PREV_HAND_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errMsg", errMsg);
	return _buf.c_str();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_PREV_HAND_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errMsg", errMsg);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_PREV_HAND_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_PREV_HAND_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString errMsg; _jparser.validateByNameThrow("errMsg", errMsg);
	AtfValidator::validateInt(_descr, "errMsg", errMsg.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_PREV_HAND_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_PREV_HAND_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT16 errCode; _parser.parseUINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errMsg"); size_t szErrMsg = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errMsg", szErrMsg, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REPLAY_HANDS_QUANTITY
//=================================================================

ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY::Protocol_MSG_REPLAY_HANDS_QUANTITY()
{
	clear();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY::clear()
{
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY::equals(const Protocol_MSG_REPLAY_HANDS_QUANTITY& _o) const
{
	return true;
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REPLAY_HANDS_QUANTITY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REPLAY_HANDS_QUANTITY*)_other));
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REPLAY_HANDS_QUANTITY).append(")");
	return _buf.c_str();
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REPLAY_HANDS_QUANTITY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY::parseMsg(CommMsgParser& _parser)
{
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_HANDS_QUANTITY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_HANDS_QUANTITY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REPLAY_HANDS_QUANTITY_REPLY
//=================================================================

ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_REPLY::Protocol_MSG_REPLAY_HANDS_QUANTITY_REPLY()
{
	clear();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_REPLY::clear()
{
	errCode = 0;
	errMsg.clear();
	quantity = 0;
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_REPLY::equals(const Protocol_MSG_REPLAY_HANDS_QUANTITY_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errMsg, _o.errMsg) &&
		quantity == _o.quantity;
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REPLAY_HANDS_QUANTITY_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REPLAY_HANDS_QUANTITY_REPLY*)_other));
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REPLAY_HANDS_QUANTITY_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendUint(errCode);
	_buf.append(',');
	_buf.append("errMsg=");
	_buf.append(errMsg);
	_buf.append(',');
	_buf.append("quantity=");
	_buf.appendUint(quantity);
	return _buf.c_str();
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REPLAY_HANDS_QUANTITY_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errMsg", errMsg, _buf);
	Atf::XmlElement::encodeAsXmlElement("quantity", quantity, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errMsg"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errMsg)) return false;
			}
			else if (_element.equals("quantity"))
			{
				quantity = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT16(errCode);
	_msg.composeString(errMsg);
	_msg.composeUINT32(quantity);
}

void ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT16(errCode);
	_parser.parseStringP(errMsg);
	_parser.parseUINT32(quantity);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errMsg", errMsg);
	_jsonstr.compose("quantity", quantity);
	return _buf.c_str();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errMsg", errMsg);
	_jparser.parseByNameThrow("quantity", quantity);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_HANDS_QUANTITY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString errMsg; _jparser.validateByNameThrow("errMsg", errMsg);
	AtfValidator::validateInt(_descr, "errMsg", errMsg.length(), _checker, __FILE__, __LINE__);
	UINT32 quantity; _jparser.validateByNameThrow("quantity", quantity);
	AtfValidator::validateInt(_descr, "quantity", quantity, _checker, __FILE__, __LINE__);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_HANDS_QUANTITY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT16 errCode; _parser.parseUINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errMsg"); size_t szErrMsg = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errMsg", szErrMsg, _checker, __FILE__, __LINE__);
	UINT32 quantity; _parser.parseUINT32(quantity);
	AtfValidator::validateInt(_descr, "quantity", quantity, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REPLAY_CURR_HAND_INFO
//=================================================================

ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO::Protocol_MSG_REPLAY_CURR_HAND_INFO()
{
	clear();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO::clear()
{
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO::equals(const Protocol_MSG_REPLAY_CURR_HAND_INFO& _o) const
{
	return true;
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REPLAY_CURR_HAND_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REPLAY_CURR_HAND_INFO*)_other));
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REPLAY_CURR_HAND_INFO).append(")");
	return _buf.c_str();
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REPLAY_CURR_HAND_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO::parseMsg(CommMsgParser& _parser)
{
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_CURR_HAND_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_CURR_HAND_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REPLAY_CURR_HAND_INFO_REPLY
//=================================================================

ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_REPLY::Protocol_MSG_REPLAY_CURR_HAND_INFO_REPLY()
{
	clear();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_REPLY::clear()
{
	errCode = 0;
	errMsg.clear();
	result = 0;
	currentItemResult = 0;
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_REPLY::equals(const Protocol_MSG_REPLAY_CURR_HAND_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errMsg, _o.errMsg) &&
		result == _o.result &&
		currentItemResult == _o.currentItemResult;
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REPLAY_CURR_HAND_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REPLAY_CURR_HAND_INFO_REPLY*)_other));
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REPLAY_CURR_HAND_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendUint(errCode);
	_buf.append(',');
	_buf.append("errMsg=");
	_buf.append(errMsg);
	_buf.append(',');
	_buf.append("result=");
	_buf.appendUint(result);
	_buf.append(',');
	_buf.append("currentItemResult=");
	_buf.appendUint(currentItemResult);
	return _buf.c_str();
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REPLAY_CURR_HAND_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errMsg", errMsg, _buf);
	Atf::XmlElement::encodeAsXmlElement("result", result, _buf);
	Atf::XmlElement::encodeAsXmlElement("currentItemResult", currentItemResult, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errMsg"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errMsg)) return false;
			}
			else if (_element.equals("result"))
			{
				result = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currentItemResult"))
			{
				currentItemResult = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT16(errCode);
	_msg.composeString(errMsg);
	_msg.composeUINT32(result);
	_msg.composeUINT32(currentItemResult);
}

void ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT16(errCode);
	_parser.parseStringP(errMsg);
	_parser.parseUINT32(result);
	_parser.parseUINT32(currentItemResult);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errMsg", errMsg);
	_jsonstr.compose("result", result);
	_jsonstr.compose("currentItemResult", currentItemResult);
	return _buf.c_str();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errMsg", errMsg);
	_jparser.parseByNameThrow("result", result);
	_jparser.parseByNameThrow("currentItemResult", currentItemResult);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_CURR_HAND_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString errMsg; _jparser.validateByNameThrow("errMsg", errMsg);
	AtfValidator::validateInt(_descr, "errMsg", errMsg.length(), _checker, __FILE__, __LINE__);
	UINT32 result; _jparser.validateByNameThrow("result", result);
	AtfValidator::validateInt(_descr, "result", result, _checker, __FILE__, __LINE__);
	UINT32 currentItemResult; _jparser.validateByNameThrow("currentItemResult", currentItemResult);
	AtfValidator::validateInt(_descr, "currentItemResult", currentItemResult, _checker, __FILE__, __LINE__);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_CURR_HAND_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT16 errCode; _parser.parseUINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errMsg"); size_t szErrMsg = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errMsg", szErrMsg, _checker, __FILE__, __LINE__);
	UINT32 result; _parser.parseUINT32(result);
	AtfValidator::validateInt(_descr, "result", result, _checker, __FILE__, __LINE__);
	UINT32 currentItemResult; _parser.parseUINT32(currentItemResult);
	AtfValidator::validateInt(_descr, "currentItemResult", currentItemResult, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REPLAY_GOTO_I_TH_HAND
//=================================================================

ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND::Protocol_MSG_REPLAY_GOTO_I_TH_HAND()
{
	clear();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND::clear()
{
	handNumber = 0;
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND::equals(const Protocol_MSG_REPLAY_GOTO_I_TH_HAND& _o) const
{
	return handNumber == _o.handNumber;
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REPLAY_GOTO_I_TH_HAND != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REPLAY_GOTO_I_TH_HAND*)_other));
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REPLAY_GOTO_I_TH_HAND).append(")");
	_buf.append(',');
	_buf.append("handNumber=");
	_buf.appendUint(handNumber);
	return _buf.c_str();
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REPLAY_GOTO_I_TH_HAND).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("handNumber", handNumber, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("handNumber"))
			{
				handNumber = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(handNumber);
}

void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(handNumber);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("handNumber", handNumber);
	return _buf.c_str();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("handNumber", handNumber);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_GOTO_I_TH_HAND";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 handNumber; _jparser.validateByNameThrow("handNumber", handNumber);
	AtfValidator::validateInt(_descr, "handNumber", handNumber, _checker, __FILE__, __LINE__);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_GOTO_I_TH_HAND";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 handNumber; _parser.parseUINT32(handNumber);
	AtfValidator::validateInt(_descr, "handNumber", handNumber, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REPLAY_GOTO_I_TH_HAND_REPLY
//=================================================================

ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_REPLY::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_REPLY()
{
	clear();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_REPLY::clear()
{
	errCode = 0;
	errMsg.clear();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_REPLY::equals(const Protocol_MSG_REPLAY_GOTO_I_TH_HAND_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errMsg, _o.errMsg);
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REPLAY_GOTO_I_TH_HAND_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REPLAY_GOTO_I_TH_HAND_REPLY*)_other));
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REPLAY_GOTO_I_TH_HAND_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendUint(errCode);
	_buf.append(',');
	_buf.append("errMsg=");
	_buf.append(errMsg);
	return _buf.c_str();
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REPLAY_GOTO_I_TH_HAND_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errMsg", errMsg, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errMsg"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errMsg)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT16(errCode);
	_msg.composeString(errMsg);
}

void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT16(errCode);
	_parser.parseStringP(errMsg);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errMsg", errMsg);
	return _buf.c_str();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errMsg", errMsg);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_GOTO_I_TH_HAND_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString errMsg; _jparser.validateByNameThrow("errMsg", errMsg);
	AtfValidator::validateInt(_descr, "errMsg", errMsg.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_GOTO_I_TH_HAND_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT16 errCode; _parser.parseUINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errMsg"); size_t szErrMsg = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errMsg", szErrMsg, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REPLAY_HAND_IDS
//=================================================================

ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS::Protocol_MSG_REPLAY_HAND_IDS()
{
	clear();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS::clear()
{
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS::equals(const Protocol_MSG_REPLAY_HAND_IDS& _o) const
{
	return true;
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REPLAY_HAND_IDS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REPLAY_HAND_IDS*)_other));
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REPLAY_HAND_IDS).append(")");
	return _buf.c_str();
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REPLAY_HAND_IDS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS::parseMsg(CommMsgParser& _parser)
{
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_HAND_IDS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_HAND_IDS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REPLAY_HAND_IDS_REPLY
//=================================================================

ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_REPLY::Protocol_MSG_REPLAY_HAND_IDS_REPLY()
{
	clear();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_REPLY::clear()
{
	errCode = 0;
	errMsg.clear();
	results.clear();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_REPLY::equals(const Protocol_MSG_REPLAY_HAND_IDS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errMsg, _o.errMsg) &&
		results.equals(_o.results);
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REPLAY_HAND_IDS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REPLAY_HAND_IDS_REPLY*)_other));
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REPLAY_HAND_IDS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendUint(errCode);
	_buf.append(',');
	_buf.append("errMsg=");
	_buf.append(errMsg);
	_buf.append(',');
	_buf.append("results=");
	results.toTraceString(_buf);
	return _buf.c_str();
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REPLAY_HAND_IDS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errMsg", errMsg, _buf);
	results.toXmlString("results", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errMsg"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errMsg)) return false;
			}
			else if (_element.equals("results"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, results)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT16(errCode);
	_msg.composeString(errMsg);
	results.composeMsg(_msg, _ignoreJSON);
}

void ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT16(errCode);
	_parser.parseStringP(errMsg);
	results.parseMsg(_parser);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errMsg", errMsg);
	_jsonstr.compose("results", results);
	return _buf.c_str();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errMsg", errMsg);
	_jparser.parseByNameThrow("results", results);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_HAND_IDS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString errMsg; _jparser.validateByNameThrow("errMsg", errMsg);
	AtfValidator::validateInt(_descr, "errMsg", errMsg.length(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT32 > results; _jparser.validateByNameThrow("results", results);
	AtfValidator::validateInt(_descr, "results", results.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_HAND_IDS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT16 errCode; _parser.parseUINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errMsg"); size_t szErrMsg = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errMsg", szErrMsg, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szResults = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("results"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "results", szResults, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REPLAY_GOTO_HAND_ID
//=================================================================

ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID::Protocol_MSG_REPLAY_GOTO_HAND_ID()
{
	clear();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID::clear()
{
	handId = 0;
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID::equals(const Protocol_MSG_REPLAY_GOTO_HAND_ID& _o) const
{
	return handId == _o.handId;
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REPLAY_GOTO_HAND_ID != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REPLAY_GOTO_HAND_ID*)_other));
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REPLAY_GOTO_HAND_ID).append(")");
	_buf.append(',');
	_buf.append("handId=");
	_buf.appendUint(handId);
	return _buf.c_str();
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REPLAY_GOTO_HAND_ID).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("handId", handId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("handId"))
			{
				handId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(handId);
}

void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(handId);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("handId", handId);
	return _buf.c_str();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("handId", handId);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_GOTO_HAND_ID";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 handId; _jparser.validateByNameThrow("handId", handId);
	AtfValidator::validateInt(_descr, "handId", handId, _checker, __FILE__, __LINE__);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_GOTO_HAND_ID";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 handId; _parser.parseUINT32(handId);
	AtfValidator::validateInt(_descr, "handId", handId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REPLAY_GOTO_HAND_ID_REPLY
//=================================================================

ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_REPLY::Protocol_MSG_REPLAY_GOTO_HAND_ID_REPLY()
{
	clear();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_REPLY::clear()
{
	errCode = 0;
	errMsg.clear();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_REPLY::equals(const Protocol_MSG_REPLAY_GOTO_HAND_ID_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errMsg, _o.errMsg);
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REPLAY_GOTO_HAND_ID_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REPLAY_GOTO_HAND_ID_REPLY*)_other));
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REPLAY_GOTO_HAND_ID_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendUint(errCode);
	_buf.append(',');
	_buf.append("errMsg=");
	_buf.append(errMsg);
	return _buf.c_str();
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REPLAY_GOTO_HAND_ID_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errMsg", errMsg, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errMsg"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errMsg)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT16(errCode);
	_msg.composeString(errMsg);
}

void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT16(errCode);
	_parser.parseStringP(errMsg);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errMsg", errMsg);
	return _buf.c_str();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errMsg", errMsg);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_GOTO_HAND_ID_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString errMsg; _jparser.validateByNameThrow("errMsg", errMsg);
	AtfValidator::validateInt(_descr, "errMsg", errMsg.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_GOTO_HAND_ID_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT16 errCode; _parser.parseUINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errMsg"); size_t szErrMsg = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errMsg", szErrMsg, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REPLAY_PAUSE_AFTER_HAND
//=================================================================

ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_AFTER_HAND::Protocol_MSG_REPLAY_PAUSE_AFTER_HAND()
{
	clear();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_AFTER_HAND::clear()
{
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_AFTER_HAND::equals(const Protocol_MSG_REPLAY_PAUSE_AFTER_HAND& _o) const
{
	return true;
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_AFTER_HAND::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REPLAY_PAUSE_AFTER_HAND != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REPLAY_PAUSE_AFTER_HAND*)_other));
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_AFTER_HAND::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REPLAY_PAUSE_AFTER_HAND).append(")");
	return _buf.c_str();
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_AFTER_HAND::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_AFTER_HAND::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REPLAY_PAUSE_AFTER_HAND).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_AFTER_HAND::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_AFTER_HAND::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_AFTER_HAND::parseMsg(CommMsgParser& _parser)
{
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_AFTER_HAND::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_AFTER_HAND::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_AFTER_HAND::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_PAUSE_AFTER_HAND";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_AFTER_HAND::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_PAUSE_AFTER_HAND";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REPLAY_PAUSE_AFTER_HAND_REPLY
//=================================================================

ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_AFTER_HAND_REPLY::Protocol_MSG_REPLAY_PAUSE_AFTER_HAND_REPLY()
{
	clear();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_AFTER_HAND_REPLY::clear()
{
	errCode = 0;
	errMsg.clear();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_AFTER_HAND_REPLY::equals(const Protocol_MSG_REPLAY_PAUSE_AFTER_HAND_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errMsg, _o.errMsg);
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_AFTER_HAND_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REPLAY_PAUSE_AFTER_HAND_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REPLAY_PAUSE_AFTER_HAND_REPLY*)_other));
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_AFTER_HAND_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REPLAY_PAUSE_AFTER_HAND_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendUint(errCode);
	_buf.append(',');
	_buf.append("errMsg=");
	_buf.append(errMsg);
	return _buf.c_str();
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_AFTER_HAND_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_AFTER_HAND_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REPLAY_PAUSE_AFTER_HAND_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errMsg", errMsg, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_AFTER_HAND_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errMsg"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errMsg)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_AFTER_HAND_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT16(errCode);
	_msg.composeString(errMsg);
}

void ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_AFTER_HAND_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT16(errCode);
	_parser.parseStringP(errMsg);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_AFTER_HAND_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errMsg", errMsg);
	return _buf.c_str();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_AFTER_HAND_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errMsg", errMsg);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_AFTER_HAND_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_PAUSE_AFTER_HAND_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString errMsg; _jparser.validateByNameThrow("errMsg", errMsg);
	AtfValidator::validateInt(_descr, "errMsg", errMsg.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_PAUSE_AFTER_HAND_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_PAUSE_AFTER_HAND_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT16 errCode; _parser.parseUINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errMsg"); size_t szErrMsg = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errMsg", szErrMsg, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REPLAY_HAND_IDS_64
//=================================================================

ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_64::Protocol_MSG_REPLAY_HAND_IDS_64()
{
	clear();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_64::clear()
{
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_64::equals(const Protocol_MSG_REPLAY_HAND_IDS_64& _o) const
{
	return true;
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_64::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REPLAY_HAND_IDS_64 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REPLAY_HAND_IDS_64*)_other));
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_64::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REPLAY_HAND_IDS_64).append(")");
	return _buf.c_str();
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_64::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_64::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REPLAY_HAND_IDS_64).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_64::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_64::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_64::parseMsg(CommMsgParser& _parser)
{
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_64::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_64::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_64::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_HAND_IDS_64";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_64::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_HAND_IDS_64";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REPLAY_HAND_IDS_64_REPLY
//=================================================================

ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_64_REPLY::Protocol_MSG_REPLAY_HAND_IDS_64_REPLY()
{
	clear();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_64_REPLY::clear()
{
	errCode = 0;
	errMsg.clear();
	results.clear();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_64_REPLY::equals(const Protocol_MSG_REPLAY_HAND_IDS_64_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errMsg, _o.errMsg) &&
		results.equals(_o.results);
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_64_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REPLAY_HAND_IDS_64_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REPLAY_HAND_IDS_64_REPLY*)_other));
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_64_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REPLAY_HAND_IDS_64_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendUint(errCode);
	_buf.append(',');
	_buf.append("errMsg=");
	_buf.append(errMsg);
	_buf.append(',');
	_buf.append("results=");
	results.toTraceString(_buf);
	return _buf.c_str();
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_64_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_64_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REPLAY_HAND_IDS_64_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errMsg", errMsg, _buf);
	results.toXmlString("results", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_64_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errMsg"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errMsg)) return false;
			}
			else if (_element.equals("results"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT64, 4 > >::FromXmlString(_value, results)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_64_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT16(errCode);
	_msg.composeString(errMsg);
	results.composeMsg(_msg, _ignoreJSON);
}

void ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_64_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT16(errCode);
	_parser.parseStringP(errMsg);
	results.parseMsg(_parser);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_64_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errMsg", errMsg);
	_jsonstr.compose("results", results);
	return _buf.c_str();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_64_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errMsg", errMsg);
	_jparser.parseByNameThrow("results", results);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_64_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_HAND_IDS_64_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString errMsg; _jparser.validateByNameThrow("errMsg", errMsg);
	AtfValidator::validateInt(_descr, "errMsg", errMsg.length(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT64 > results; _jparser.validateByNameThrow("results", results);
	AtfValidator::validateInt(_descr, "results", results.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_HAND_IDS_64_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_HAND_IDS_64_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT16 errCode; _parser.parseUINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errMsg"); size_t szErrMsg = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errMsg", szErrMsg, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szResults = Atf::LAtfVector< UINT64, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("results"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "results", szResults, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REPLAY_CURR_HAND_INFO_64
//=================================================================

ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_64::Protocol_MSG_REPLAY_CURR_HAND_INFO_64()
{
	clear();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_64::clear()
{
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_64::equals(const Protocol_MSG_REPLAY_CURR_HAND_INFO_64& _o) const
{
	return true;
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_64::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REPLAY_CURR_HAND_INFO_64 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REPLAY_CURR_HAND_INFO_64*)_other));
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_64::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REPLAY_CURR_HAND_INFO_64).append(")");
	return _buf.c_str();
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_64::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_64::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REPLAY_CURR_HAND_INFO_64).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_64::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_64::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_64::parseMsg(CommMsgParser& _parser)
{
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_64::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_64::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_64::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_CURR_HAND_INFO_64";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_64::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_CURR_HAND_INFO_64";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REPLAY_CURR_HAND_INFO_64_REPLY
//=================================================================

ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_64_REPLY::Protocol_MSG_REPLAY_CURR_HAND_INFO_64_REPLY()
{
	clear();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_64_REPLY::clear()
{
	errCode = 0;
	errMsg.clear();
	result = 0;
	currentItemResult = 0;
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_64_REPLY::equals(const Protocol_MSG_REPLAY_CURR_HAND_INFO_64_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errMsg, _o.errMsg) &&
		result == _o.result &&
		currentItemResult == _o.currentItemResult;
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_64_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REPLAY_CURR_HAND_INFO_64_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REPLAY_CURR_HAND_INFO_64_REPLY*)_other));
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_64_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REPLAY_CURR_HAND_INFO_64_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendUint(errCode);
	_buf.append(',');
	_buf.append("errMsg=");
	_buf.append(errMsg);
	_buf.append(',');
	_buf.append("result=");
	_buf.appendUint64(result);
	_buf.append(',');
	_buf.append("currentItemResult=");
	_buf.appendUint64(currentItemResult);
	return _buf.c_str();
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_64_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_64_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REPLAY_CURR_HAND_INFO_64_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errMsg", errMsg, _buf);
	Atf::XmlElement::encodeAsXmlElement("result", result, _buf);
	Atf::XmlElement::encodeAsXmlElement("currentItemResult", currentItemResult, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_64_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errMsg"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errMsg)) return false;
			}
			else if (_element.equals("result"))
			{
				result = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currentItemResult"))
			{
				currentItemResult = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_64_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT16(errCode);
	_msg.composeString(errMsg);
	_msg.composeUINT64(result);
	_msg.composeUINT64(currentItemResult);
}

void ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_64_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT16(errCode);
	_parser.parseStringP(errMsg);
	_parser.parseUINT64(result);
	_parser.parseUINT64(currentItemResult);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_64_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errMsg", errMsg);
	_jsonstr.compose("result", result);
	_jsonstr.compose("currentItemResult", currentItemResult);
	return _buf.c_str();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_64_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errMsg", errMsg);
	_jparser.parseByNameThrow("result", result);
	_jparser.parseByNameThrow("currentItemResult", currentItemResult);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_64_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_CURR_HAND_INFO_64_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString errMsg; _jparser.validateByNameThrow("errMsg", errMsg);
	AtfValidator::validateInt(_descr, "errMsg", errMsg.length(), _checker, __FILE__, __LINE__);
	UINT64 result; _jparser.validateByNameThrow("result", result);
	AtfValidator::validateUint(_descr, "result", result, _checker, __FILE__, __LINE__);
	UINT64 currentItemResult; _jparser.validateByNameThrow("currentItemResult", currentItemResult);
	AtfValidator::validateUint(_descr, "currentItemResult", currentItemResult, _checker, __FILE__, __LINE__);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_64_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_CURR_HAND_INFO_64_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT16 errCode; _parser.parseUINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errMsg"); size_t szErrMsg = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errMsg", szErrMsg, _checker, __FILE__, __LINE__);
	UINT64 result; _parser.parseUINT64(result);
	AtfValidator::validateUint(_descr, "result", result, _checker, __FILE__, __LINE__);
	UINT64 currentItemResult; _parser.parseUINT64(currentItemResult);
	AtfValidator::validateUint(_descr, "currentItemResult", currentItemResult, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REPLAY_GOTO_HAND_ID_64
//=================================================================

ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_64::Protocol_MSG_REPLAY_GOTO_HAND_ID_64()
{
	clear();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_64::clear()
{
	handId = 0;
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_64::equals(const Protocol_MSG_REPLAY_GOTO_HAND_ID_64& _o) const
{
	return handId == _o.handId;
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_64::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REPLAY_GOTO_HAND_ID_64 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REPLAY_GOTO_HAND_ID_64*)_other));
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_64::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REPLAY_GOTO_HAND_ID_64).append(")");
	_buf.append(',');
	_buf.append("handId=");
	_buf.appendUint64(handId);
	return _buf.c_str();
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_64::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_64::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REPLAY_GOTO_HAND_ID_64).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("handId", handId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_64::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("handId"))
			{
				handId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_64::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(handId);
}

void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_64::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(handId);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_64::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("handId", handId);
	return _buf.c_str();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_64::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("handId", handId);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_64::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_GOTO_HAND_ID_64";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT64 handId; _jparser.validateByNameThrow("handId", handId);
	AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_64::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_GOTO_HAND_ID_64";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT64 handId; _parser.parseUINT64(handId);
	AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REPLAY_GOTO_HAND_ID_64_REPLY
//=================================================================

ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_64_REPLY::Protocol_MSG_REPLAY_GOTO_HAND_ID_64_REPLY()
{
	clear();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_64_REPLY::clear()
{
	errCode = 0;
	errMsg.clear();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_64_REPLY::equals(const Protocol_MSG_REPLAY_GOTO_HAND_ID_64_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errMsg, _o.errMsg);
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_64_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REPLAY_GOTO_HAND_ID_64_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REPLAY_GOTO_HAND_ID_64_REPLY*)_other));
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_64_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REPLAY_GOTO_HAND_ID_64_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendUint(errCode);
	_buf.append(',');
	_buf.append("errMsg=");
	_buf.append(errMsg);
	return _buf.c_str();
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_64_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_64_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REPLAY_GOTO_HAND_ID_64_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errMsg", errMsg, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_64_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errMsg"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errMsg)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_64_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT16(errCode);
	_msg.composeString(errMsg);
}

void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_64_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT16(errCode);
	_parser.parseStringP(errMsg);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_64_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errMsg", errMsg);
	return _buf.c_str();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_64_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errMsg", errMsg);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_64_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_GOTO_HAND_ID_64_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString errMsg; _jparser.validateByNameThrow("errMsg", errMsg);
	AtfValidator::validateInt(_descr, "errMsg", errMsg.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_64_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_GOTO_HAND_ID_64_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT16 errCode; _parser.parseUINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errMsg"); size_t szErrMsg = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errMsg", szErrMsg, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REPLAY_HANDS_QUANTITY_64
//=================================================================

ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_64::Protocol_MSG_REPLAY_HANDS_QUANTITY_64()
{
	clear();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_64::clear()
{
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_64::equals(const Protocol_MSG_REPLAY_HANDS_QUANTITY_64& _o) const
{
	return true;
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_64::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REPLAY_HANDS_QUANTITY_64 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REPLAY_HANDS_QUANTITY_64*)_other));
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_64::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REPLAY_HANDS_QUANTITY_64).append(")");
	return _buf.c_str();
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_64::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_64::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REPLAY_HANDS_QUANTITY_64).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_64::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_64::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_64::parseMsg(CommMsgParser& _parser)
{
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_64::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_64::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_64::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_HANDS_QUANTITY_64";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_64::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_HANDS_QUANTITY_64";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REPLAY_HANDS_QUANTITY_64_REPLY
//=================================================================

ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_64_REPLY::Protocol_MSG_REPLAY_HANDS_QUANTITY_64_REPLY()
{
	clear();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_64_REPLY::clear()
{
	errCode = 0;
	errMsg.clear();
	quantity = 0;
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_64_REPLY::equals(const Protocol_MSG_REPLAY_HANDS_QUANTITY_64_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errMsg, _o.errMsg) &&
		quantity == _o.quantity;
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_64_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REPLAY_HANDS_QUANTITY_64_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REPLAY_HANDS_QUANTITY_64_REPLY*)_other));
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_64_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REPLAY_HANDS_QUANTITY_64_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendUint(errCode);
	_buf.append(',');
	_buf.append("errMsg=");
	_buf.append(errMsg);
	_buf.append(',');
	_buf.append("quantity=");
	_buf.appendUint(quantity);
	return _buf.c_str();
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_64_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_64_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REPLAY_HANDS_QUANTITY_64_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errMsg", errMsg, _buf);
	Atf::XmlElement::encodeAsXmlElement("quantity", quantity, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_64_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errMsg"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errMsg)) return false;
			}
			else if (_element.equals("quantity"))
			{
				quantity = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_64_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT16(errCode);
	_msg.composeString(errMsg);
	_msg.composeUINT32(quantity);
}

void ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_64_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT16(errCode);
	_parser.parseStringP(errMsg);
	_parser.parseUINT32(quantity);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_64_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errMsg", errMsg);
	_jsonstr.compose("quantity", quantity);
	return _buf.c_str();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_64_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errMsg", errMsg);
	_jparser.parseByNameThrow("quantity", quantity);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_64_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_HANDS_QUANTITY_64_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString errMsg; _jparser.validateByNameThrow("errMsg", errMsg);
	AtfValidator::validateInt(_descr, "errMsg", errMsg.length(), _checker, __FILE__, __LINE__);
	UINT32 quantity; _jparser.validateByNameThrow("quantity", quantity);
	AtfValidator::validateInt(_descr, "quantity", quantity, _checker, __FILE__, __LINE__);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_64_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_HANDS_QUANTITY_64_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT16 errCode; _parser.parseUINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errMsg"); size_t szErrMsg = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errMsg", szErrMsg, _checker, __FILE__, __LINE__);
	UINT32 quantity; _parser.parseUINT32(quantity);
	AtfValidator::validateInt(_descr, "quantity", quantity, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64
//=================================================================

ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64()
{
	clear();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64::clear()
{
	handNumber = 0;
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64::equals(const Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64& _o) const
{
	return handNumber == _o.handNumber;
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REPLAY_GOTO_I_TH_HAND_64 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64*)_other));
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REPLAY_GOTO_I_TH_HAND_64).append(")");
	_buf.append(',');
	_buf.append("handNumber=");
	_buf.appendUint64(handNumber);
	return _buf.c_str();
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REPLAY_GOTO_I_TH_HAND_64).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("handNumber", handNumber, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("handNumber"))
			{
				handNumber = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(handNumber);
}

void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(handNumber);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("handNumber", handNumber);
	return _buf.c_str();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("handNumber", handNumber);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_GOTO_I_TH_HAND_64";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT64 handNumber; _jparser.validateByNameThrow("handNumber", handNumber);
	AtfValidator::validateUint(_descr, "handNumber", handNumber, _checker, __FILE__, __LINE__);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_GOTO_I_TH_HAND_64";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT64 handNumber; _parser.parseUINT64(handNumber);
	AtfValidator::validateUint(_descr, "handNumber", handNumber, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64_REPLY
//=================================================================

ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64_REPLY::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64_REPLY()
{
	clear();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64_REPLY::clear()
{
	errCode = 0;
	errMsg.clear();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64_REPLY::equals(const Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errMsg, _o.errMsg);
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REPLAY_GOTO_I_TH_HAND_64_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64_REPLY*)_other));
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REPLAY_GOTO_I_TH_HAND_64_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendUint(errCode);
	_buf.append(',');
	_buf.append("errMsg=");
	_buf.append(errMsg);
	return _buf.c_str();
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REPLAY_GOTO_I_TH_HAND_64_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errMsg", errMsg, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errMsg"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errMsg)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT16(errCode);
	_msg.composeString(errMsg);
}

void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT16(errCode);
	_parser.parseStringP(errMsg);
}

const char *ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errMsg", errMsg);
	return _buf.c_str();
}

void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errMsg", errMsg);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_GOTO_I_TH_HAND_64_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString errMsg; _jparser.validateByNameThrow("errMsg", errMsg);
	AtfValidator::validateInt(_descr, "errMsg", errMsg.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void ServerReplay::cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REPLAY_GOTO_I_TH_HAND_64_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT16 errCode; _parser.parseUINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errMsg"); size_t szErrMsg = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errMsg", szErrMsg, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ Atf::MessageProtocol* ServerReplay::ProtocolFactory::createMessageProtocolObject(const char *_nameSpace, UINT32 _msgId)
{
	Atf::MessageProtocol *_obj = NULL;

	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_REPLAY_CURR_HAND_INFO: _obj = new cli::Protocol_MSG_REPLAY_CURR_HAND_INFO(); break;
			case MSG_REPLAY_CURR_HAND_INFO_64: _obj = new cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_64(); break;
			case MSG_REPLAY_CURR_HAND_INFO_64_REPLY: _obj = new cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_64_REPLY(); break;
			case MSG_REPLAY_CURR_HAND_INFO_REPLY: _obj = new cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_REPLY(); break;
			case MSG_REPLAY_GOTO_HAND_ID: _obj = new cli::Protocol_MSG_REPLAY_GOTO_HAND_ID(); break;
			case MSG_REPLAY_GOTO_HAND_ID_64: _obj = new cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_64(); break;
			case MSG_REPLAY_GOTO_HAND_ID_64_REPLY: _obj = new cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_64_REPLY(); break;
			case MSG_REPLAY_GOTO_HAND_ID_REPLY: _obj = new cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_REPLY(); break;
			case MSG_REPLAY_GOTO_I_TH_HAND: _obj = new cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND(); break;
			case MSG_REPLAY_GOTO_I_TH_HAND_64: _obj = new cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64(); break;
			case MSG_REPLAY_GOTO_I_TH_HAND_64_REPLY: _obj = new cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64_REPLY(); break;
			case MSG_REPLAY_GOTO_I_TH_HAND_REPLY: _obj = new cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_REPLY(); break;
			case MSG_REPLAY_HANDS_QUANTITY: _obj = new cli::Protocol_MSG_REPLAY_HANDS_QUANTITY(); break;
			case MSG_REPLAY_HANDS_QUANTITY_64: _obj = new cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_64(); break;
			case MSG_REPLAY_HANDS_QUANTITY_64_REPLY: _obj = new cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_64_REPLY(); break;
			case MSG_REPLAY_HANDS_QUANTITY_REPLY: _obj = new cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_REPLY(); break;
			case MSG_REPLAY_HAND_IDS: _obj = new cli::Protocol_MSG_REPLAY_HAND_IDS(); break;
			case MSG_REPLAY_HAND_IDS_64: _obj = new cli::Protocol_MSG_REPLAY_HAND_IDS_64(); break;
			case MSG_REPLAY_HAND_IDS_64_REPLY: _obj = new cli::Protocol_MSG_REPLAY_HAND_IDS_64_REPLY(); break;
			case MSG_REPLAY_HAND_IDS_REPLY: _obj = new cli::Protocol_MSG_REPLAY_HAND_IDS_REPLY(); break;
			case MSG_REPLAY_NEXT_HAND: _obj = new cli::Protocol_MSG_REPLAY_NEXT_HAND(); break;
			case MSG_REPLAY_NEXT_HAND_REPLY: _obj = new cli::Protocol_MSG_REPLAY_NEXT_HAND_REPLY(); break;
			case MSG_REPLAY_PAUSE: _obj = new cli::Protocol_MSG_REPLAY_PAUSE(); break;
			case MSG_REPLAY_PAUSE_AFTER_HAND: _obj = new cli::Protocol_MSG_REPLAY_PAUSE_AFTER_HAND(); break;
			case MSG_REPLAY_PAUSE_AFTER_HAND_REPLY: _obj = new cli::Protocol_MSG_REPLAY_PAUSE_AFTER_HAND_REPLY(); break;
			case MSG_REPLAY_PAUSE_REPLY: _obj = new cli::Protocol_MSG_REPLAY_PAUSE_REPLY(); break;
			case MSG_REPLAY_PREV_HAND: _obj = new cli::Protocol_MSG_REPLAY_PREV_HAND(); break;
			case MSG_REPLAY_PREV_HAND_REPLY: _obj = new cli::Protocol_MSG_REPLAY_PREV_HAND_REPLY(); break;
			case MSG_REPLAY_RESUME: _obj = new cli::Protocol_MSG_REPLAY_RESUME(); break;
			case MSG_REPLAY_RESUME_REPLY: _obj = new cli::Protocol_MSG_REPLAY_RESUME_REPLY(); break;
			case MSG_TABLE_CHAT: _obj = new cli::Protocol_MSG_TABLE_CHAT(); break;
			case MSG_TABLE_CHAT2: _obj = new cli::Protocol_MSG_TABLE_CHAT2(); break;
			case MSG_TABLE_CHAT2_REPLY: _obj = new cli::Protocol_MSG_TABLE_CHAT2_REPLY(); break;
			case MSG_TABLE_LOGIN: _obj = new cli::Protocol_MSG_TABLE_LOGIN(); break;
			case MSG_TABLE_LOGIN_REPLY: _obj = new cli::Protocol_MSG_TABLE_LOGIN_REPLY(); break;
		}
	}
	
	return _obj;
}

/* static */ bool ServerReplay::ProtocolFactory::validateProtocolMessageFromJSONString(const char *_nameSpace, UINT32 _msgId, const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_REPLAY_CURR_HAND_INFO: cli::Protocol_MSG_REPLAY_CURR_HAND_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_CURR_HAND_INFO_64: cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_64::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_CURR_HAND_INFO_64_REPLY: cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_64_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_CURR_HAND_INFO_REPLY: cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_GOTO_HAND_ID: cli::Protocol_MSG_REPLAY_GOTO_HAND_ID::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_GOTO_HAND_ID_64: cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_64::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_GOTO_HAND_ID_64_REPLY: cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_64_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_GOTO_HAND_ID_REPLY: cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_GOTO_I_TH_HAND: cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_GOTO_I_TH_HAND_64: cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_GOTO_I_TH_HAND_64_REPLY: cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_GOTO_I_TH_HAND_REPLY: cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_HANDS_QUANTITY: cli::Protocol_MSG_REPLAY_HANDS_QUANTITY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_HANDS_QUANTITY_64: cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_64::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_HANDS_QUANTITY_64_REPLY: cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_64_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_HANDS_QUANTITY_REPLY: cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_HAND_IDS: cli::Protocol_MSG_REPLAY_HAND_IDS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_HAND_IDS_64: cli::Protocol_MSG_REPLAY_HAND_IDS_64::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_HAND_IDS_64_REPLY: cli::Protocol_MSG_REPLAY_HAND_IDS_64_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_HAND_IDS_REPLY: cli::Protocol_MSG_REPLAY_HAND_IDS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_NEXT_HAND: cli::Protocol_MSG_REPLAY_NEXT_HAND::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_NEXT_HAND_REPLY: cli::Protocol_MSG_REPLAY_NEXT_HAND_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_PAUSE: cli::Protocol_MSG_REPLAY_PAUSE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_PAUSE_AFTER_HAND: cli::Protocol_MSG_REPLAY_PAUSE_AFTER_HAND::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_PAUSE_AFTER_HAND_REPLY: cli::Protocol_MSG_REPLAY_PAUSE_AFTER_HAND_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_PAUSE_REPLY: cli::Protocol_MSG_REPLAY_PAUSE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_PREV_HAND: cli::Protocol_MSG_REPLAY_PREV_HAND::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_PREV_HAND_REPLY: cli::Protocol_MSG_REPLAY_PREV_HAND_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_RESUME: cli::Protocol_MSG_REPLAY_RESUME::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_RESUME_REPLY: cli::Protocol_MSG_REPLAY_RESUME_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_CHAT: cli::Protocol_MSG_TABLE_CHAT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_CHAT2: cli::Protocol_MSG_TABLE_CHAT2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_CHAT2_REPLY: cli::Protocol_MSG_TABLE_CHAT2_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_LOGIN: cli::Protocol_MSG_TABLE_LOGIN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_LOGIN_REPLY: cli::Protocol_MSG_TABLE_LOGIN_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

/* static */ bool ServerReplay::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_REPLAY_CURR_HAND_INFO: cli::Protocol_MSG_REPLAY_CURR_HAND_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_CURR_HAND_INFO_64: cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_64::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_CURR_HAND_INFO_64_REPLY: cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_64_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_CURR_HAND_INFO_REPLY: cli::Protocol_MSG_REPLAY_CURR_HAND_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_GOTO_HAND_ID: cli::Protocol_MSG_REPLAY_GOTO_HAND_ID::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_GOTO_HAND_ID_64: cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_64::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_GOTO_HAND_ID_64_REPLY: cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_64_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_GOTO_HAND_ID_REPLY: cli::Protocol_MSG_REPLAY_GOTO_HAND_ID_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_GOTO_I_TH_HAND: cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_GOTO_I_TH_HAND_64: cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_GOTO_I_TH_HAND_64_REPLY: cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_64_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_GOTO_I_TH_HAND_REPLY: cli::Protocol_MSG_REPLAY_GOTO_I_TH_HAND_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_HANDS_QUANTITY: cli::Protocol_MSG_REPLAY_HANDS_QUANTITY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_HANDS_QUANTITY_64: cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_64::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_HANDS_QUANTITY_64_REPLY: cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_64_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_HANDS_QUANTITY_REPLY: cli::Protocol_MSG_REPLAY_HANDS_QUANTITY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_HAND_IDS: cli::Protocol_MSG_REPLAY_HAND_IDS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_HAND_IDS_64: cli::Protocol_MSG_REPLAY_HAND_IDS_64::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_HAND_IDS_64_REPLY: cli::Protocol_MSG_REPLAY_HAND_IDS_64_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_HAND_IDS_REPLY: cli::Protocol_MSG_REPLAY_HAND_IDS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_NEXT_HAND: cli::Protocol_MSG_REPLAY_NEXT_HAND::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_NEXT_HAND_REPLY: cli::Protocol_MSG_REPLAY_NEXT_HAND_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_PAUSE: cli::Protocol_MSG_REPLAY_PAUSE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_PAUSE_AFTER_HAND: cli::Protocol_MSG_REPLAY_PAUSE_AFTER_HAND::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_PAUSE_AFTER_HAND_REPLY: cli::Protocol_MSG_REPLAY_PAUSE_AFTER_HAND_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_PAUSE_REPLY: cli::Protocol_MSG_REPLAY_PAUSE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_PREV_HAND: cli::Protocol_MSG_REPLAY_PREV_HAND::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_PREV_HAND_REPLY: cli::Protocol_MSG_REPLAY_PREV_HAND_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_RESUME: cli::Protocol_MSG_REPLAY_RESUME::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REPLAY_RESUME_REPLY: cli::Protocol_MSG_REPLAY_RESUME_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_CHAT: cli::Protocol_MSG_TABLE_CHAT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_CHAT2: cli::Protocol_MSG_TABLE_CHAT2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_CHAT2_REPLY: cli::Protocol_MSG_TABLE_CHAT2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_LOGIN: cli::Protocol_MSG_TABLE_LOGIN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_LOGIN_REPLY: cli::Protocol_MSG_TABLE_LOGIN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

