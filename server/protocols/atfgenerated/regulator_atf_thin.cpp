/**
 * regulator_atf_thin.cpp
 *
 * This file was auto-generated from regulator_atf.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor -thin regulator_atf.txt
 */
 
#include "regulator_atf_thin.h"

//=================================================================
//                    ResetPwdMessageStruct
//=================================================================

regulator::common_structs::ResetPwdMessageStruct::ResetPwdMessageStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::common_structs::ResetPwdMessageStruct::ResetPwdMessageStruct(ResetPwdMessageStruct&& _o)
	: user(std::move(_o.user))
	, zip(std::move(_o.zip))
	, addr(std::move(_o.addr))
	, email(std::move(_o.email))
	, useChallengeQuestions(std::move(_o.useChallengeQuestions))
	, answer1(std::move(_o.answer1))
	, answer2(std::move(_o.answer2))
	, ssn4(std::move(_o.ssn4))
{
}

regulator::common_structs::ResetPwdMessageStruct& regulator::common_structs::ResetPwdMessageStruct::operator=(ResetPwdMessageStruct&& _o)
{
	if(this != &_o)
	{
		user = std::move(_o.user);
		zip = std::move(_o.zip);
		addr = std::move(_o.addr);
		email = std::move(_o.email);
		useChallengeQuestions = std::move(_o.useChallengeQuestions);
		answer1 = std::move(_o.answer1);
		answer2 = std::move(_o.answer2);
		ssn4 = std::move(_o.ssn4);
	}
	return *this;
}

#endif

void regulator::common_structs::ResetPwdMessageStruct::clear()
{
	user.clear();
	zip.clear();
	addr.clear();
	email.clear();
	useChallengeQuestions = false;
	answer1.clear();
	answer2.clear();
	ssn4.clear();
}

bool regulator::common_structs::ResetPwdMessageStruct::equals(const ResetPwdMessageStruct& _o) const
{
	return user.equals(_o.user) &&
		zip.equals(_o.zip) &&
		addr.equals(_o.addr) &&
		email.equals(_o.email) &&
		useChallengeQuestions == _o.useChallengeQuestions &&
		answer1.equals(_o.answer1) &&
		answer2.equals(_o.answer2) &&
		ssn4.equals(_o.ssn4);
}

const char *regulator::common_structs::ResetPwdMessageStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("user=");
	_buf.append(user);
	_buf.append(',');
	_buf.append("zip=");
	_buf.append(zip);
	_buf.append(',');
	_buf.append("addr=");
	_buf.append(addr);
	_buf.append(',');
	_buf.append("email=");
	_buf.append(email);
	_buf.append(',');
	_buf.append("useChallengeQuestions=");
	_buf.appendUint(useChallengeQuestions);
	_buf.append(',');
	_buf.append("answer1=");
	_buf.append(answer1);
	_buf.append(',');
	_buf.append("answer2=");
	_buf.append(answer2);
	_buf.append(',');
	_buf.append("ssn4=");
	_buf.append(ssn4);
	_buf.append('}');
	return _buf.c_str();
}

void regulator::common_structs::ResetPwdMessageStruct::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(user);
	_msg.composeString(zip);
	_msg.composeString(addr);
	_msg.composeString(email);
	_msg.composeBOOL(useChallengeQuestions);
	_msg.composeString(answer1);
	_msg.composeString(answer2);
	_msg.composeString(ssn4);
}

void regulator::common_structs::ResetPwdMessageStruct::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(user);
	_parser.parseStringP(zip);
	_parser.parseStringP(addr);
	_parser.parseStringP(email);
	_parser.parseBOOL(useChallengeQuestions);
	_parser.parseStringP(answer1);
	_parser.parseStringP(answer2);
	_parser.parseStringP(ssn4);
}

/*static*/ void regulator::common_structs::ResetPwdMessageStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "user"); size_t szUser = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "user", szUser, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "zip"); size_t szZip = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "zip", szZip, 100000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "addr"); size_t szAddr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "addr", szAddr, 100000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "email", szEmail, USER_EMAIL_LEN, _checker, __FILE__, __LINE__);
	bool useChallengeQuestions; _parser.parseBOOL(useChallengeQuestions);
	AtfValidator::validateInt(_descr, "useChallengeQuestions", useChallengeQuestions, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "answer1"); size_t szAnswer1 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "answer1", szAnswer1, 10000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "answer2"); size_t szAnswer2 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "answer2", szAnswer2, 10000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "ssn4"); size_t szSsn4 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "ssn4", szSsn4, SSN_4_LEN, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    ChallengeQuestion
//=================================================================

regulator::common_structs::ChallengeQuestion::ChallengeQuestion()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::common_structs::ChallengeQuestion::ChallengeQuestion(ChallengeQuestion&& _o)
	: id(std::move(_o.id))
	, txt(std::move(_o.txt))
{
}

regulator::common_structs::ChallengeQuestion& regulator::common_structs::ChallengeQuestion::operator=(ChallengeQuestion&& _o)
{
	if(this != &_o)
	{
		id = std::move(_o.id);
		txt = std::move(_o.txt);
	}
	return *this;
}

#endif

void regulator::common_structs::ChallengeQuestion::clear()
{
	id = 0;
	txt.clear();
}

bool regulator::common_structs::ChallengeQuestion::equals(const ChallengeQuestion& _o) const
{
	return id == _o.id &&
		txt.equals(_o.txt);
}

const char *regulator::common_structs::ChallengeQuestion::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("id=");
	_buf.appendUint(id);
	_buf.append(',');
	_buf.append("txt=");
	_buf.append(txt);
	_buf.append('}');
	return _buf.c_str();
}

void regulator::common_structs::ChallengeQuestion::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(id);
	_msg.composeString(txt);
}

void regulator::common_structs::ChallengeQuestion::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(id);
	_parser.parseStringP(txt);
}

/*static*/ void regulator::common_structs::ChallengeQuestion::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 id; _parser.parseUINT32(id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "txt"); size_t szTxt = strlen(_dummy);
	AtfValidator::validateInt(_descr, "txt", szTxt, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    LobbyNameAvailableStruct
//=================================================================

regulator::common_structs::LobbyNameAvailableStruct::LobbyNameAvailableStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::common_structs::LobbyNameAvailableStruct::LobbyNameAvailableStruct(LobbyNameAvailableStruct&& _o)
	: userId(std::move(_o.userId))
	, localeId(std::move(_o.localeId))
{
}

regulator::common_structs::LobbyNameAvailableStruct& regulator::common_structs::LobbyNameAvailableStruct::operator=(LobbyNameAvailableStruct&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		localeId = std::move(_o.localeId);
	}
	return *this;
}

#endif

void regulator::common_structs::LobbyNameAvailableStruct::clear()
{
	userId.clear();
	localeId = 0;
}

bool regulator::common_structs::LobbyNameAvailableStruct::equals(const LobbyNameAvailableStruct& _o) const
{
	return userId.equals(_o.userId) &&
		localeId == _o.localeId;
}

const char *regulator::common_structs::LobbyNameAvailableStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("localeId=");
	_buf.appendUint(localeId);
	_buf.append('}');
	return _buf.c_str();
}

void regulator::common_structs::LobbyNameAvailableStruct::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeUINT32(localeId);
}

void regulator::common_structs::LobbyNameAvailableStruct::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseUINT32(localeId);
}

/*static*/ void regulator::common_structs::LobbyNameAvailableStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, 100, _checker, __FILE__, __LINE__);
	UINT32 localeId; _parser.parseUINT32(localeId);
	AtfValidator::validateIntMax(_descr, "localeId", localeId, MAX_LOCALES, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    LobbyNameAvailableReplyStruct
//=================================================================

regulator::common_structs::LobbyNameAvailableReplyStruct::LobbyNameAvailableReplyStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::common_structs::LobbyNameAvailableReplyStruct::LobbyNameAvailableReplyStruct(LobbyNameAvailableReplyStruct&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, userId_(std::move(_o.userId_))
	, suggestedIds(std::move(_o.suggestedIds))
{
}

regulator::common_structs::LobbyNameAvailableReplyStruct& regulator::common_structs::LobbyNameAvailableReplyStruct::operator=(LobbyNameAvailableReplyStruct&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		userId_ = std::move(_o.userId_);
		suggestedIds = std::move(_o.suggestedIds);
	}
	return *this;
}

#endif

void regulator::common_structs::LobbyNameAvailableReplyStruct::clear()
{
	errCode = 0;
	errDescr.clear();
	userId_.clear();
	suggestedIds.clear();
}

bool regulator::common_structs::LobbyNameAvailableReplyStruct::equals(const LobbyNameAvailableReplyStruct& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		userId_.equals(_o.userId_) &&
		suggestedIds.equals(_o.suggestedIds);
}

const char *regulator::common_structs::LobbyNameAvailableReplyStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("userId_=");
		_buf.append(userId_);
		_buf.append(',');
		_buf.append("suggestedIds=");
		suggestedIds.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void regulator::common_structs::LobbyNameAvailableReplyStruct::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(userId_);
		suggestedIds.composeMsg(_msg);
	}
}

void regulator::common_structs::LobbyNameAvailableReplyStruct::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(userId_);
		suggestedIds.parseMsg(_parser);
	}
}

/*static*/ void regulator::common_structs::LobbyNameAvailableReplyStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "userId_"); size_t szUserId_ = strlen(_dummy);
		AtfValidator::validateInt(_descr, "userId_", szUserId_, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szSuggestedIds = ThinAtf::LAtfVector< PString, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("suggestedIds"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "suggestedIds", szSuggestedIds, _checker, __FILE__, __LINE__);
	}
}

//=================================================================
//                    EmailAttachmentStruct
//=================================================================

regulator::common_structs::EmailAttachmentStruct::EmailAttachmentStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::common_structs::EmailAttachmentStruct::EmailAttachmentStruct(EmailAttachmentStruct&& _o)
	: attName(std::move(_o.attName))
	, attBody(std::move(_o.attBody))
{
}

regulator::common_structs::EmailAttachmentStruct& regulator::common_structs::EmailAttachmentStruct::operator=(EmailAttachmentStruct&& _o)
{
	if(this != &_o)
	{
		attName = std::move(_o.attName);
		attBody = std::move(_o.attBody);
	}
	return *this;
}

#endif

void regulator::common_structs::EmailAttachmentStruct::clear()
{
	attName.clear();
	attBody.clear();
}

bool regulator::common_structs::EmailAttachmentStruct::equals(const EmailAttachmentStruct& _o) const
{
	return attName.equals(_o.attName) &&
		attBody.size() == _o.attBody.size() && memcmp(attBody.ptr(), _o.attBody.ptr(), attBody.size()) == 0;
}

const char *regulator::common_structs::EmailAttachmentStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("attName=");
	_buf.append(attName);
	_buf.append(',');
	_buf.append("attBody=");
	ThinAtf::AtfTempl<PBlock>::ToTraceString(_buf, attBody);
	_buf.append('}');
	return _buf.c_str();
}

void regulator::common_structs::EmailAttachmentStruct::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(attName);
	_msg._composeVarBlock(attBody.ptr(), attBody.size());
}

void regulator::common_structs::EmailAttachmentStruct::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(attName);
	_parser.parsePBlock(attBody);
}

/*static*/ void regulator::common_structs::EmailAttachmentStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "attName"); size_t szAttName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "attName", szAttName, 10000, _checker, __FILE__, __LINE__);
	const BYTE* attBody; size_t szAttBody; _parser._parseVarBlock(attBody, szAttBody);  /*attBody*/
	AtfValidator::validateIntMax(_descr, "attBody", szAttBody, 10000000, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    EmailAttachmentVec
//=================================================================

regulator::common_structs::EmailAttachmentVec::EmailAttachmentVec()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::common_structs::EmailAttachmentVec::EmailAttachmentVec(EmailAttachmentVec&& _o)
	: attachments(std::move(_o.attachments))
{
}

regulator::common_structs::EmailAttachmentVec& regulator::common_structs::EmailAttachmentVec::operator=(EmailAttachmentVec&& _o)
{
	if(this != &_o)
	{
		attachments = std::move(_o.attachments);
	}
	return *this;
}

#endif

void regulator::common_structs::EmailAttachmentVec::clear()
{
	attachments.clear();
}

bool regulator::common_structs::EmailAttachmentVec::equals(const EmailAttachmentVec& _o) const
{
	return attachments.equals(_o.attachments);
}

const char *regulator::common_structs::EmailAttachmentVec::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("attachments=");
	attachments.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void regulator::common_structs::EmailAttachmentVec::composeMsg(CommMsgBody& _msg) const
{
	attachments.composeMsg(_msg);
}

void regulator::common_structs::EmailAttachmentVec::parseMsg(CommMsgParser& _parser)
{
	attachments.parseMsg(_parser);
}

/*static*/ void regulator::common_structs::EmailAttachmentVec::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szAttachments = ThinAtf::LAtfVector< EmailAttachmentStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("attachments"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "attachments", szAttachments, 10000, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    EmailAttachmentPart
//=================================================================

regulator::common_structs::EmailAttachmentPart::EmailAttachmentPart()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::common_structs::EmailAttachmentPart::EmailAttachmentPart(EmailAttachmentPart&& _o)
	: clientVersion(std::move(_o.clientVersion))
	, clientOsInfo(std::move(_o.clientOsInfo))
	, attachments(std::move(_o.attachments))
{
}

regulator::common_structs::EmailAttachmentPart& regulator::common_structs::EmailAttachmentPart::operator=(EmailAttachmentPart&& _o)
{
	if(this != &_o)
	{
		clientVersion = std::move(_o.clientVersion);
		clientOsInfo = std::move(_o.clientOsInfo);
		attachments = std::move(_o.attachments);
	}
	return *this;
}

#endif

void regulator::common_structs::EmailAttachmentPart::clear()
{
	clientVersion.clear();
	clientOsInfo.clear();
	attachments.clear();
}

bool regulator::common_structs::EmailAttachmentPart::equals(const EmailAttachmentPart& _o) const
{
	return clientVersion.equals(_o.clientVersion) &&
		clientOsInfo.equals(_o.clientOsInfo) &&
		attachments.equals(_o.attachments);
}

const char *regulator::common_structs::EmailAttachmentPart::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("clientVersion=");
	_buf.append(clientVersion);
	_buf.append(',');
	_buf.append("clientOsInfo=");
	_buf.append(clientOsInfo);
	_buf.append(',');
	_buf.append("attachments=");
	attachments.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void regulator::common_structs::EmailAttachmentPart::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(clientVersion);
	_msg.composeString(clientOsInfo);
	attachments.composeMsg(_msg);
}

void regulator::common_structs::EmailAttachmentPart::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(clientVersion);
	_parser.parseStringP(clientOsInfo);
	if(_parser.parseEnded()) return;
	attachments.parseMsg(_parser);
}

/*static*/ void regulator::common_structs::EmailAttachmentPart::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "clientVersion"); size_t szClientVersion = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "clientVersion", szClientVersion, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "clientOsInfo"); size_t szClientOsInfo = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "clientOsInfo", szClientOsInfo, 100, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PString _descbuf;
	EmailAttachmentVec::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("attachments"), _fieldsWithUnparsedContent);
}

//=================================================================
//                    LobbyClientToSupportEmailStruct
//=================================================================

regulator::common_structs::LobbyClientToSupportEmailStruct::LobbyClientToSupportEmailStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::common_structs::LobbyClientToSupportEmailStruct::LobbyClientToSupportEmailStruct(LobbyClientToSupportEmailStruct&& _o)
	: userId(std::move(_o.userId))
	, category(std::move(_o.category))
	, subCategory(std::move(_o.subCategory))
	, subject(std::move(_o.subject))
	, body(std::move(_o.body))
	, attPart(std::move(_o.attPart))
{
}

regulator::common_structs::LobbyClientToSupportEmailStruct& regulator::common_structs::LobbyClientToSupportEmailStruct::operator=(LobbyClientToSupportEmailStruct&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		category = std::move(_o.category);
		subCategory = std::move(_o.subCategory);
		subject = std::move(_o.subject);
		body = std::move(_o.body);
		attPart = std::move(_o.attPart);
	}
	return *this;
}

#endif

void regulator::common_structs::LobbyClientToSupportEmailStruct::clear()
{
	userId.clear();
	category = 0;
	subCategory = 0;
	subject.clear();
	body.clear();
	attPart.clear();
}

bool regulator::common_structs::LobbyClientToSupportEmailStruct::equals(const LobbyClientToSupportEmailStruct& _o) const
{
	return userId.equals(_o.userId) &&
		category == _o.category &&
		subCategory == _o.subCategory &&
		subject.equals(_o.subject) &&
		body.equals(_o.body) &&
		attPart.equals(_o.attPart);
}

const char *regulator::common_structs::LobbyClientToSupportEmailStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("category=");
	_buf.appendUint(category);
	_buf.append(',');
	_buf.append("subCategory=");
	_buf.appendUint(subCategory);
	_buf.append(',');
	_buf.append("subject=");
	_buf.append(subject);
	_buf.append(',');
	_buf.append("body=");
	_buf.append(body);
	_buf.append(',');
	_buf.append("attPart=");
	attPart.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void regulator::common_structs::LobbyClientToSupportEmailStruct::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeUINT32(category);
	_msg.composeUINT32(subCategory);
	_msg.composeString(subject);
	_msg.composeString(body);
	attPart.composeMsg(_msg);
}

void regulator::common_structs::LobbyClientToSupportEmailStruct::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseUINT32(category);
	_parser.parseUINT32(subCategory);
	_parser.parseStringP(subject);
	_parser.parseStringP(body);
	if(_parser.parseEnded()) return;
	attPart.parseMsg(_parser);
}

/*static*/ void regulator::common_structs::LobbyClientToSupportEmailStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT32 category; _parser.parseUINT32(category);
	AtfValidator::validateIntRange(_descr, "category", category, eClientEmailCategory_None, eClientEmailCategory_Last, _checker, __FILE__, __LINE__);
	UINT32 subCategory; _parser.parseUINT32(subCategory);
	AtfValidator::validateInt(_descr, "subCategory", subCategory, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "subject"); size_t szSubject = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "subject", szSubject, EMAIL_SUBJ_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "body"); size_t szBody = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "body", szBody, 10000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PString _descbuf;
	EmailAttachmentPart::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("attPart"), _fieldsWithUnparsedContent);
}

//=================================================================
//                    LobbyClientToSupportEmailReplyStruct
//=================================================================

regulator::common_structs::LobbyClientToSupportEmailReplyStruct::LobbyClientToSupportEmailReplyStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::common_structs::LobbyClientToSupportEmailReplyStruct::LobbyClientToSupportEmailReplyStruct(LobbyClientToSupportEmailReplyStruct&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

regulator::common_structs::LobbyClientToSupportEmailReplyStruct& regulator::common_structs::LobbyClientToSupportEmailReplyStruct::operator=(LobbyClientToSupportEmailReplyStruct&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void regulator::common_structs::LobbyClientToSupportEmailReplyStruct::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::common_structs::LobbyClientToSupportEmailReplyStruct::equals(const LobbyClientToSupportEmailReplyStruct& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *regulator::common_structs::LobbyClientToSupportEmailReplyStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	_buf.append('}');
	return _buf.c_str();
}

void regulator::common_structs::LobbyClientToSupportEmailReplyStruct::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void regulator::common_structs::LobbyClientToSupportEmailReplyStruct::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void regulator::common_structs::LobbyClientToSupportEmailReplyStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
}

//=================================================================
//                    ChallengeAnswer
//=================================================================

regulator::common_structs::ChallengeAnswer::ChallengeAnswer()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::common_structs::ChallengeAnswer::ChallengeAnswer(ChallengeAnswer&& _o)
	: answer(std::move(_o.answer))
{
}

regulator::common_structs::ChallengeAnswer& regulator::common_structs::ChallengeAnswer::operator=(ChallengeAnswer&& _o)
{
	if(this != &_o)
	{
		answer = std::move(_o.answer);
	}
	return *this;
}

#endif

void regulator::common_structs::ChallengeAnswer::clear()
{
	answer.clear();
}

bool regulator::common_structs::ChallengeAnswer::equals(const ChallengeAnswer& _o) const
{
	return answer.equals(_o.answer);
}

const char *regulator::common_structs::ChallengeAnswer::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("answer=");
	_buf.append(answer);
	_buf.append('}');
	return _buf.c_str();
}

void regulator::common_structs::ChallengeAnswer::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(answer);
}

void regulator::common_structs::ChallengeAnswer::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(answer);
}

/*static*/ void regulator::common_structs::ChallengeAnswer::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "answer"); size_t szAnswer = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "answer", szAnswer, 10000, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    UserProfile
//=================================================================

regulator::common_structs::UserProfile::UserProfile()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::common_structs::UserProfile::UserProfile(UserProfile&& _o)
	: firstName(std::move(_o.firstName))
	, lastName(std::move(_o.lastName))
	, sex(std::move(_o.sex))
	, addr_1(std::move(_o.addr_1))
	, citymaxlen(std::move(_o.citymaxlen))
	, state(std::move(_o.state))
	, country(std::move(_o.country))
	, zipCode(std::move(_o.zipCode))
	, birthDate(std::move(_o.birthDate))
	, birthCity(std::move(_o.birthCity))
	, birthState(std::move(_o.birthState))
	, birthCountry(std::move(_o.birthCountry))
	, phone(std::move(_o.phone))
	, mobile(std::move(_o.mobile))
	, email(std::move(_o.email))
	, fiscalCode(std::move(_o.fiscalCode))
	, documentType(std::move(_o.documentType))
	, documentNumber(std::move(_o.documentNumber))
	, documentIssueDate(std::move(_o.documentIssueDate))
	, documentPlaceOfIssue(std::move(_o.documentPlaceOfIssue))
	, documentIssuingAuthority(std::move(_o.documentIssuingAuthority))
	, flags(std::move(_o.flags))
	, flags2(std::move(_o.flags2))
	, profession(std::move(_o.profession))
{
}

regulator::common_structs::UserProfile& regulator::common_structs::UserProfile::operator=(UserProfile&& _o)
{
	if(this != &_o)
	{
		firstName = std::move(_o.firstName);
		lastName = std::move(_o.lastName);
		sex = std::move(_o.sex);
		addr_1 = std::move(_o.addr_1);
		citymaxlen = std::move(_o.citymaxlen);
		state = std::move(_o.state);
		country = std::move(_o.country);
		zipCode = std::move(_o.zipCode);
		birthDate = std::move(_o.birthDate);
		birthCity = std::move(_o.birthCity);
		birthState = std::move(_o.birthState);
		birthCountry = std::move(_o.birthCountry);
		phone = std::move(_o.phone);
		mobile = std::move(_o.mobile);
		email = std::move(_o.email);
		fiscalCode = std::move(_o.fiscalCode);
		documentType = std::move(_o.documentType);
		documentNumber = std::move(_o.documentNumber);
		documentIssueDate = std::move(_o.documentIssueDate);
		documentPlaceOfIssue = std::move(_o.documentPlaceOfIssue);
		documentIssuingAuthority = std::move(_o.documentIssuingAuthority);
		flags = std::move(_o.flags);
		flags2 = std::move(_o.flags2);
		profession = std::move(_o.profession);
	}
	return *this;
}

#endif

void regulator::common_structs::UserProfile::clear()
{
	firstName.clear();
	lastName.clear();
	sex.clear();
	addr_1.clear();
	citymaxlen.clear();
	state.clear();
	country.clear();
	zipCode.clear();
	birthDate.setNull();
	birthCity.clear();
	birthState.clear();
	birthCountry.clear();
	phone.clear();
	mobile.clear();
	email.clear();
	fiscalCode.clear();
	documentType = 0;
	documentNumber.clear();
	documentIssueDate.setNull();
	documentPlaceOfIssue.clear();
	documentIssuingAuthority = 0;
	flags = 0;
	flags2 = 0;
	profession.clear();
}

bool regulator::common_structs::UserProfile::equals(const UserProfile& _o) const
{
	return firstName.equals(_o.firstName) &&
		lastName.equals(_o.lastName) &&
		sex.equals(_o.sex) &&
		addr_1.equals(_o.addr_1) &&
		citymaxlen.equals(_o.citymaxlen) &&
		state.equals(_o.state) &&
		country.equals(_o.country) &&
		zipCode.equals(_o.zipCode) &&
		birthDate.equals(_o.birthDate) &&
		birthCity.equals(_o.birthCity) &&
		birthState.equals(_o.birthState) &&
		birthCountry.equals(_o.birthCountry) &&
		phone.equals(_o.phone) &&
		mobile.equals(_o.mobile) &&
		email.equals(_o.email) &&
		fiscalCode.equals(_o.fiscalCode) &&
		documentType == _o.documentType &&
		documentNumber.equals(_o.documentNumber) &&
		documentIssueDate.equals(_o.documentIssueDate) &&
		documentPlaceOfIssue.equals(_o.documentPlaceOfIssue) &&
		documentIssuingAuthority == _o.documentIssuingAuthority &&
		flags == _o.flags &&
		flags2 == _o.flags2 &&
		profession.equals(_o.profession);
}

const char *regulator::common_structs::UserProfile::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("firstName=");
	_buf.append(firstName);
	_buf.append(',');
	_buf.append("lastName=");
	_buf.append(lastName);
	_buf.append(',');
	_buf.append("sex=");
	_buf.append(sex);
	_buf.append(',');
	_buf.append("addr_1=");
	_buf.append(addr_1);
	_buf.append(',');
	_buf.append("citymaxlen=");
	_buf.append(citymaxlen);
	_buf.append(',');
	_buf.append("state=");
	_buf.append(state);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("zipCode=");
	_buf.append(zipCode);
	_buf.append(',');
	_buf.append("birthDate=");
	ThinAtf::AtfTempl<CommSrvDate>::ToTraceString(_buf, birthDate);
	_buf.append(',');
	_buf.append("birthCity=");
	_buf.append(birthCity);
	_buf.append(',');
	_buf.append("birthState=");
	_buf.append(birthState);
	_buf.append(',');
	_buf.append("birthCountry=");
	_buf.append(birthCountry);
	_buf.append(',');
	_buf.append("phone=");
	_buf.append(phone);
	_buf.append(',');
	_buf.append("mobile=");
	_buf.append(mobile);
	_buf.append(',');
	_buf.append("email=");
	_buf.append(email);
	_buf.append(',');
	_buf.append("fiscalCode=");
	_buf.append(fiscalCode);
	_buf.append(',');
	_buf.append("documentType=");
	_buf.appendUint(documentType);
	_buf.append(',');
	_buf.append("documentNumber=");
	_buf.append(documentNumber);
	_buf.append(',');
	_buf.append("documentIssueDate=");
	ThinAtf::AtfTempl<CommSrvDate>::ToTraceString(_buf, documentIssueDate);
	_buf.append(',');
	_buf.append("documentPlaceOfIssue=");
	_buf.append(documentPlaceOfIssue);
	_buf.append(',');
	_buf.append("documentIssuingAuthority=");
	_buf.appendUint(documentIssuingAuthority);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("flags2=");
	_buf.appendUint64(flags2);
	_buf.append(',');
	_buf.append("profession=");
	_buf.append(profession);
	_buf.append('}');
	return _buf.c_str();
}

void regulator::common_structs::UserProfile::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(firstName);
	_msg.composeString(lastName);
	_msg.composeString(sex);
	_msg.composeString(addr_1);
	_msg.composeString(citymaxlen);
	_msg.composeString(state);
	_msg.composeString(country);
	_msg.composeString(zipCode);
	_msg.composeSrvDate(birthDate);
	_msg.composeString(birthCity);
	_msg.composeString(birthState);
	_msg.composeString(birthCountry);
	_msg.composeString(phone);
	_msg.composeString(mobile);
	_msg.composeString(email);
	_msg.composeString(fiscalCode);
	_msg.composeUINT32(documentType);
	_msg.composeString(documentNumber);
	_msg.composeSrvDate(documentIssueDate);
	_msg.composeString(documentPlaceOfIssue);
	_msg.composeUINT32(documentIssuingAuthority);
	_msg.composeUINT32(flags);
	_msg.composeUINT64(flags2);
	_msg.composeString(profession);
}

void regulator::common_structs::UserProfile::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(firstName);
	_parser.parseStringP(lastName);
	_parser.parseStringP(sex);
	_parser.parseStringP(addr_1);
	_parser.parseStringP(citymaxlen);
	_parser.parseStringP(state);
	_parser.parseStringP(country);
	_parser.parseStringP(zipCode);
	_parser.parseSrvDate(birthDate);
	_parser.parseStringP(birthCity);
	_parser.parseStringP(birthState);
	_parser.parseStringP(birthCountry);
	_parser.parseStringP(phone);
	_parser.parseStringP(mobile);
	_parser.parseStringP(email);
	_parser.parseStringP(fiscalCode);
	_parser.parseUINT32(documentType);
	_parser.parseStringP(documentNumber);
	_parser.parseSrvDate(documentIssueDate);
	_parser.parseStringP(documentPlaceOfIssue);
	_parser.parseUINT32(documentIssuingAuthority);
	_parser.parseUINT32(flags);
	_parser.parseUINT64(flags2);
	_parser.parseStringP(profession);
}

/*static*/ void regulator::common_structs::UserProfile::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "firstName"); size_t szFirstName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "firstName", szFirstName, USER_FIRST_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "lastName"); size_t szLastName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "lastName", szLastName, USER_LAST_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "sex"); size_t szSex = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "sex", szSex, USER_SEX_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "addr_1"); size_t szAddr_1 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "addr_1", szAddr_1, USER_ADDR_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "citymaxlen"); size_t szCitymaxlen = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "citymaxlen", szCitymaxlen, USER_CITY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "state"); size_t szState = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "state", szState, USER_STATE_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, USER_COUNTRY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "zipCode"); size_t szZipCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "zipCode", szZipCode, USER_ZIP_LEN, _checker, __FILE__, __LINE__);
	CommSrvDate birthDate; _parser.parseSrvDate(birthDate);
	AtfValidator::validateSrvDateTime(_descr, "birthDate", birthDate, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "birthCity"); size_t szBirthCity = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "birthCity", szBirthCity, USER_CITY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "birthState"); size_t szBirthState = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "birthState", szBirthState, USER_STATE_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "birthCountry"); size_t szBirthCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "birthCountry", szBirthCountry, USER_COUNTRY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "phone"); size_t szPhone = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "phone", szPhone, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "mobile"); size_t szMobile = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "mobile", szMobile, USER_MOBILE_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "email", szEmail, USER_EMAIL_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "fiscalCode"); size_t szFiscalCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "fiscalCode", szFiscalCode, USER_FISCAL_CODE_LEN, _checker, __FILE__, __LINE__);
	UINT32 documentType; _parser.parseUINT32(documentType);
	AtfValidator::validateInt(_descr, "documentType", documentType, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "documentNumber"); size_t szDocumentNumber = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "documentNumber", szDocumentNumber, 100, _checker, __FILE__, __LINE__);
	CommSrvDate documentIssueDate; _parser.parseSrvDate(documentIssueDate);
	AtfValidator::validateSrvDateTime(_descr, "documentIssueDate", documentIssueDate, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "documentPlaceOfIssue"); size_t szDocumentPlaceOfIssue = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "documentPlaceOfIssue", szDocumentPlaceOfIssue, 300, _checker, __FILE__, __LINE__);
	UINT32 documentIssuingAuthority; _parser.parseUINT32(documentIssuingAuthority);
	AtfValidator::validateIntMax(_descr, "documentIssuingAuthority", documentIssuingAuthority, 100, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser.parseUINT32(flags);
	AtfValidator::validateIntRange(_descr, "flags", flags, 0, ((UINT32(1)<<(userFlagsLastUsedBit+UINT32(1)))-UINT32(1)), _checker, __FILE__, __LINE__);
	UINT64 flags2; _parser.parseUINT64(flags2);
	AtfValidator::validateUintRange(_descr, "flags2", flags2, 0, ((ONE64<<(userFlags2LastUsedBit+ONE64))-ONE64), _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "profession"); size_t szProfession = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "profession", szProfession, 100, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    UserUpdateElement
//=================================================================

regulator::common_structs::UserUpdateElement::UserUpdateElement()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::common_structs::UserUpdateElement::UserUpdateElement(UserUpdateElement&& _o)
	: updateType(std::move(_o.updateType))
	, addr_1(std::move(_o.addr_1))
	, addr_2(std::move(_o.addr_2))
	, city(std::move(_o.city))
	, state(std::move(_o.state))
	, country(std::move(_o.country))
	, zipCode(std::move(_o.zipCode))
	, email(std::move(_o.email))
	, autoValidateEmail(std::move(_o.autoValidateEmail))
	, pwd(std::move(_o.pwd))
	, imageType(std::move(_o.imageType))
	, imgData(std::move(_o.imgData))
	, fullName(std::move(_o.fullName))
	, phone(std::move(_o.phone))
	, firstName(std::move(_o.firstName))
	, lastName(std::move(_o.lastName))
	, fiscalCode(std::move(_o.fiscalCode))
	, encrFiscalCode(std::move(_o.encrFiscalCode))
	, properties(std::move(_o.properties))
	, birthDate(std::move(_o.birthDate))
	, imageId(std::move(_o.imageId))
	, currentImageId(std::move(_o.currentImageId))
	, isCurrentImageFromGallery(std::move(_o.isCurrentImageFromGallery))
	, isGalleryImage(std::move(_o.isGalleryImage))
	, adminIntId(std::move(_o.adminIntId))
	, adminId(std::move(_o.adminId))
	, sex(std::move(_o.sex))
	, mobile(std::move(_o.mobile))
	, verificationCertificate(std::move(_o.verificationCertificate))
	, verificationSignedData(std::move(_o.verificationSignedData))
	, mailListIn(std::move(_o.mailListIn))
	, mailListPokerIn(std::move(_o.mailListPokerIn))
	, mailListCasinoIn(std::move(_o.mailListCasinoIn))
	, mailListSportsIn(std::move(_o.mailListSportsIn))
	, mailListSportsLiveAlertIn(std::move(_o.mailListSportsLiveAlertIn))
	, profile(std::move(_o.profile))
	, realMoneyOkSet(std::move(_o.realMoneyOkSet))
	, comment(std::move(_o.comment))
	, weeklyDepositLimit(std::move(_o.weeklyDepositLimit))
	, buyInLimit(std::move(_o.buyInLimit))
	, isBuyInLimitValid(std::move(_o.isBuyInLimitValid))
	, sportsAccumulatedLimit(std::move(_o.sportsAccumulatedLimit))
	, allowSMSPwdReset(std::move(_o.allowSMSPwdReset))
	, smsMarketingFlagValue(std::move(_o.smsMarketingFlagValue))
	, answer1(std::move(_o.answer1))
	, answer2(std::move(_o.answer2))
	, ssn4(std::move(_o.ssn4))
	, booleanActions(std::move(_o.booleanActions))
	, optinLeaderBoard(std::move(_o.optinLeaderBoard))
	, appLoginId(std::move(_o.appLoginId))
	, brandId(std::move(_o.brandId))
	, requestCtx(std::move(_o.requestCtx))
	, dummy_makeATFdefinitionForThisUpdateType(std::move(_o.dummy_makeATFdefinitionForThisUpdateType))
{
}

regulator::common_structs::UserUpdateElement& regulator::common_structs::UserUpdateElement::operator=(UserUpdateElement&& _o)
{
	if(this != &_o)
	{
		updateType = std::move(_o.updateType);
		addr_1 = std::move(_o.addr_1);
		addr_2 = std::move(_o.addr_2);
		city = std::move(_o.city);
		state = std::move(_o.state);
		country = std::move(_o.country);
		zipCode = std::move(_o.zipCode);
		email = std::move(_o.email);
		autoValidateEmail = std::move(_o.autoValidateEmail);
		pwd = std::move(_o.pwd);
		imageType = std::move(_o.imageType);
		imgData = std::move(_o.imgData);
		fullName = std::move(_o.fullName);
		phone = std::move(_o.phone);
		firstName = std::move(_o.firstName);
		lastName = std::move(_o.lastName);
		fiscalCode = std::move(_o.fiscalCode);
		encrFiscalCode = std::move(_o.encrFiscalCode);
		properties = std::move(_o.properties);
		birthDate = std::move(_o.birthDate);
		imageId = std::move(_o.imageId);
		currentImageId = std::move(_o.currentImageId);
		isCurrentImageFromGallery = std::move(_o.isCurrentImageFromGallery);
		isGalleryImage = std::move(_o.isGalleryImage);
		adminIntId = std::move(_o.adminIntId);
		adminId = std::move(_o.adminId);
		sex = std::move(_o.sex);
		mobile = std::move(_o.mobile);
		verificationCertificate = std::move(_o.verificationCertificate);
		verificationSignedData = std::move(_o.verificationSignedData);
		mailListIn = std::move(_o.mailListIn);
		mailListPokerIn = std::move(_o.mailListPokerIn);
		mailListCasinoIn = std::move(_o.mailListCasinoIn);
		mailListSportsIn = std::move(_o.mailListSportsIn);
		mailListSportsLiveAlertIn = std::move(_o.mailListSportsLiveAlertIn);
		profile = std::move(_o.profile);
		realMoneyOkSet = std::move(_o.realMoneyOkSet);
		comment = std::move(_o.comment);
		weeklyDepositLimit = std::move(_o.weeklyDepositLimit);
		buyInLimit = std::move(_o.buyInLimit);
		isBuyInLimitValid = std::move(_o.isBuyInLimitValid);
		sportsAccumulatedLimit = std::move(_o.sportsAccumulatedLimit);
		allowSMSPwdReset = std::move(_o.allowSMSPwdReset);
		smsMarketingFlagValue = std::move(_o.smsMarketingFlagValue);
		answer1 = std::move(_o.answer1);
		answer2 = std::move(_o.answer2);
		ssn4 = std::move(_o.ssn4);
		booleanActions = std::move(_o.booleanActions);
		optinLeaderBoard = std::move(_o.optinLeaderBoard);
		appLoginId = std::move(_o.appLoginId);
		brandId = std::move(_o.brandId);
		requestCtx = std::move(_o.requestCtx);
		dummy_makeATFdefinitionForThisUpdateType = std::move(_o.dummy_makeATFdefinitionForThisUpdateType);
	}
	return *this;
}

#endif

void regulator::common_structs::UserUpdateElement::clear()
{
	updateType = 0;
	addr_1.clear();
	addr_2.clear();
	city.clear();
	state.clear();
	country.clear();
	zipCode.clear();
	email.clear();
	autoValidateEmail = false;
	pwd.clear();
	imageType = 0;
	imgData.clear();
	fullName.clear();
	phone.clear();
	firstName.clear();
	lastName.clear();
	fiscalCode.clear();
	encrFiscalCode.clear();
	properties.clear();
	birthDate.setNull();
	imageId = 0;
	currentImageId = 0;
	isCurrentImageFromGallery = false;
	isGalleryImage = false;
	adminIntId = 0;
	adminId.clear();
	sex.clear();
	mobile.clear();
	verificationCertificate.clear();
	verificationSignedData.clear();
	mailListIn = false;
	mailListPokerIn = false;
	mailListCasinoIn = false;
	mailListSportsIn = false;
	mailListSportsLiveAlertIn = false;
	profile.clear();
	realMoneyOkSet = false;
	comment.clear();
	weeklyDepositLimit = 0;
	buyInLimit = 0;
	isBuyInLimitValid = false;
	sportsAccumulatedLimit = NO_TABLE_LIMIT_MARKER;
	allowSMSPwdReset = false;
	smsMarketingFlagValue = false;
	answer1.clear();
	answer2.clear();
	ssn4.clear();
	booleanActions = 0;
	optinLeaderBoard = false;
	appLoginId = 0;
	brandId = 0;
	requestCtx = 0;
	dummy_makeATFdefinitionForThisUpdateType.clear();
}

bool regulator::common_structs::UserUpdateElement::equals(const UserUpdateElement& _o) const
{
	return updateType == _o.updateType &&
		addr_1.equals(_o.addr_1) &&
		addr_2.equals(_o.addr_2) &&
		city.equals(_o.city) &&
		state.equals(_o.state) &&
		country.equals(_o.country) &&
		zipCode.equals(_o.zipCode) &&
		email.equals(_o.email) &&
		autoValidateEmail == _o.autoValidateEmail &&
		pwd.equals(_o.pwd) &&
		imageType == _o.imageType &&
		imgData.size() == _o.imgData.size() && memcmp(imgData.ptr(), _o.imgData.ptr(), imgData.size()) == 0 &&
		fullName.equals(_o.fullName) &&
		phone.equals(_o.phone) &&
		firstName.equals(_o.firstName) &&
		lastName.equals(_o.lastName) &&
		fiscalCode.equals(_o.fiscalCode) &&
		encrFiscalCode.equals(_o.encrFiscalCode) &&
		properties.equals(_o.properties) &&
		birthDate.equals(_o.birthDate) &&
		imageId == _o.imageId &&
		currentImageId == _o.currentImageId &&
		isCurrentImageFromGallery == _o.isCurrentImageFromGallery &&
		isGalleryImage == _o.isGalleryImage &&
		adminIntId == _o.adminIntId &&
		adminId.equals(_o.adminId) &&
		sex.equals(_o.sex) &&
		mobile.equals(_o.mobile) &&
		verificationCertificate.equals(_o.verificationCertificate) &&
		verificationSignedData.equals(_o.verificationSignedData) &&
		mailListIn == _o.mailListIn &&
		mailListPokerIn == _o.mailListPokerIn &&
		mailListCasinoIn == _o.mailListCasinoIn &&
		mailListSportsIn == _o.mailListSportsIn &&
		mailListSportsLiveAlertIn == _o.mailListSportsLiveAlertIn &&
		profile.equals(_o.profile) &&
		realMoneyOkSet == _o.realMoneyOkSet &&
		comment.equals(_o.comment) &&
		weeklyDepositLimit == _o.weeklyDepositLimit &&
		buyInLimit == _o.buyInLimit &&
		isBuyInLimitValid == _o.isBuyInLimitValid &&
		sportsAccumulatedLimit == _o.sportsAccumulatedLimit &&
		allowSMSPwdReset == _o.allowSMSPwdReset &&
		smsMarketingFlagValue == _o.smsMarketingFlagValue &&
		answer1.equals(_o.answer1) &&
		answer2.equals(_o.answer2) &&
		ssn4.equals(_o.ssn4) &&
		booleanActions == _o.booleanActions &&
		optinLeaderBoard == _o.optinLeaderBoard &&
		appLoginId == _o.appLoginId &&
		brandId == _o.brandId &&
		requestCtx == _o.requestCtx &&
		dummy_makeATFdefinitionForThisUpdateType.equals(_o.dummy_makeATFdefinitionForThisUpdateType);
}

const char *regulator::common_structs::UserUpdateElement::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("updateType=");
	_buf.appendUint(updateType);
	if (updateType == eUserUpdateTypeAddress)
	{
		_buf.append(',');
		_buf.append("addr_1=");
		_buf.append(addr_1);
		_buf.append(',');
		_buf.append("addr_2=");
		_buf.append(addr_2);
		_buf.append(',');
		_buf.append("city=");
		_buf.append(city);
		_buf.append(',');
		_buf.append("state=");
		_buf.append(state);
		_buf.append(',');
		_buf.append("country=");
		_buf.append(country);
		_buf.append(',');
		_buf.append("zipCode=");
		_buf.append(zipCode);
	}
	else if (updateType == eUserUpdateTypeEmail)
	{
		_buf.append(',');
		_buf.append("email=");
		_buf.append(email);
		_buf.append(',');
		_buf.append("autoValidateEmail=");
		_buf.appendUint(autoValidateEmail);
	}
	else if (updateType == eUserUpdateTypePassword)
	{
		_buf.append(',');
		_buf.append("pwd=");
		_buf.append(pwd);
	}
	else if (updateType == eUserUpdateTypeImage)
	{
		_buf.append(',');
		_buf.append("imageType=");
		_buf.appendUint(imageType);
		_buf.append(',');
		_buf.append("imgData=");
		ThinAtf::AtfTempl<PBlock>::ToTraceString(_buf, imgData);
	}
	else if (updateType == eUserUpdateTypeFullName)
	{
		_buf.append(',');
		_buf.append("fullName=");
		_buf.append(fullName);
	}
	else if (updateType == eUserUpdateTypePhone)
	{
		_buf.append(',');
		_buf.append("phone=");
		_buf.append(phone);
	}
	else if (updateType == eUserUpdateTypeRealMoney)
	{
		_buf.append(',');
	}
	else if (updateType == eUserUpdateTypeFirstNameLastName)
	{
		_buf.append(',');
		_buf.append("firstName=");
		_buf.append(firstName);
		_buf.append(',');
		_buf.append("lastName=");
		_buf.append(lastName);
	}
	else if (updateType == eUserUpdateTypeFiscalCode)
	{
		_buf.append(',');
		_buf.append("fiscalCode=");
		_buf.append(fiscalCode);
	}
	else if (updateType == eUserUpdateTypeEncrFiscalCode)
	{
		_buf.append(',');
		_buf.append("encrFiscalCode=");
		_buf.append(encrFiscalCode);
	}
	else if (updateType == eUserUpdateTypeProperties)
	{
		_buf.append(',');
		_buf.append("properties=");
		properties.toTraceString(_buf);
	}
	else if (updateType == eUserUpdateTypeBirthday)
	{
		_buf.append(',');
		_buf.append("birthDate=");
		ThinAtf::AtfTempl<CommSrvDate>::ToTraceString(_buf, birthDate);
	}
	else if (updateType == eUserUpdateTypeImageId)
	{
		_buf.append(',');
		_buf.append("imageId=");
		_buf.appendUint(imageId);
		_buf.append(',');
		_buf.append("currentImageId=");
		_buf.appendUint(currentImageId);
		_buf.append(',');
		_buf.append("isCurrentImageFromGallery=");
		_buf.appendUint(isCurrentImageFromGallery);
	}
	else if (updateType == eUserUpdateTypeSwitchImageId)
	{
		_buf.append(',');
		_buf.append("imageId=");
		_buf.appendUint(imageId);
		_buf.append(',');
		_buf.append("isGalleryImage=");
		_buf.appendUint(isGalleryImage);
		_buf.append(',');
		_buf.append("currentImageId=");
		_buf.appendUint(currentImageId);
		_buf.append(',');
		_buf.append("isCurrentImageFromGallery=");
		_buf.appendUint(isCurrentImageFromGallery);
		_buf.append(',');
		_buf.append("adminIntId=");
		_buf.appendUint(adminIntId);
		_buf.append(',');
		_buf.append("adminId=");
		_buf.append(adminId);
	}
	else if (updateType == eUserUpdateTypeSex)
	{
		_buf.append(',');
		_buf.append("sex=");
		_buf.append(sex);
	}
	else if (updateType == eUserUpdateTypeMobile)
	{
		_buf.append(',');
		_buf.append("mobile=");
		_buf.append(mobile);
	}
	else if (updateType == eUserUpdateTypeEstoniaValidation)
	{
		_buf.append(',');
		_buf.append("verificationCertificate=");
		_buf.append(verificationCertificate);
		_buf.append(',');
		_buf.append("verificationSignedData=");
		_buf.append(verificationSignedData);
	}
	else if (updateType == eUserUpdateTypeMailList)
	{
		_buf.append(',');
		_buf.append("mailListIn=");
		_buf.appendUint(mailListIn);
	}
	else if (updateType == eUserUpdateTypeMailListNew)
	{
		_buf.append(',');
		_buf.append("mailListPokerIn=");
		_buf.appendUint(mailListPokerIn);
		_buf.append(',');
		_buf.append("mailListCasinoIn=");
		_buf.appendUint(mailListCasinoIn);
		_buf.append(',');
		_buf.append("mailListSportsIn=");
		_buf.appendUint(mailListSportsIn);
		_buf.append(',');
		_buf.append("mailListSportsLiveAlertIn=");
		_buf.appendUint(mailListSportsLiveAlertIn);
	}
	else if (updateType == eUserUpdateTypeExternalValidation)
	{
		_buf.append(',');
		_buf.append("profile=");
		profile.toTraceString(_buf);
	}
	else if (updateType == eUserUpdateTypeRealMoneyOkFlag)
	{
		_buf.append(',');
		_buf.append("realMoneyOkSet=");
		_buf.appendUint(realMoneyOkSet);
		_buf.append(',');
		_buf.append("comment=");
		_buf.append(comment);
	}
	else if (updateType == eUserUpdateTypeSetLimits)
	{
		_buf.append(',');
		_buf.append("weeklyDepositLimit=");
		_buf.appendInt(weeklyDepositLimit);
		_buf.append(',');
		_buf.append("buyInLimit=");
		_buf.appendInt(buyInLimit);
		_buf.append(',');
		_buf.append("isBuyInLimitValid=");
		_buf.appendUint(isBuyInLimitValid);
		_buf.append(',');
		_buf.append("sportsAccumulatedLimit=");
		_buf.appendInt(sportsAccumulatedLimit);
	}
	else if (updateType == eUserUpdateTypeSMSPwdReset)
	{
		_buf.append(',');
		_buf.append("allowSMSPwdReset=");
		_buf.appendUint(allowSMSPwdReset);
	}
	else if (updateType == eUserUpdateTypeSmsMarketingFlag)
	{
		_buf.append(',');
		_buf.append("smsMarketingFlagValue=");
		_buf.appendUint(smsMarketingFlagValue);
	}
	else if (updateType == eUserUpdateTypePwdStrongAuth)
	{
		_buf.append(',');
		_buf.append("answer1=");
		_buf.append(answer1);
		_buf.append(',');
		_buf.append("answer2=");
		_buf.append(answer2);
		_buf.append(',');
		_buf.append("ssn4=");
		_buf.append(ssn4);
	}
	else if (updateType == eUserUpdateTypeBooleanActions)
	{
		_buf.append(',');
		_buf.append("booleanActions=");
		_buf.appendUint(booleanActions);
	}
	else if (updateType == eUserUpdateTypeLeaderBoard)
	{
		_buf.append(',');
		_buf.append("optinLeaderBoard=");
		_buf.appendUint(optinLeaderBoard);
	}
	else if (updateType == eUserUpdateTypeInternalServerNonUpdInfo)
	{
		_buf.append(',');
		_buf.append("appLoginId=");
		_buf.appendUint64(appLoginId);
		_buf.append(',');
		_buf.append("brandId=");
		_buf.appendUint(brandId);
		_buf.append(',');
		_buf.append("adminIntId=");
		_buf.appendUint(adminIntId);
		_buf.append(',');
		_buf.append("adminId=");
		_buf.append(adminId);
	}
	else if (updateType == eUserUpdateTypeAgeVerification)
	{
		_buf.append(',');
		_buf.append("requestCtx=");
		_buf.appendInt(requestCtx);
	}
	else
	{
		_buf.append(',');
		_buf.append("dummy_makeATFdefinitionForThisUpdateType=");
		dummy_makeATFdefinitionForThisUpdateType.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void regulator::common_structs::UserUpdateElement::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(updateType);
	if (updateType == eUserUpdateTypeAddress)
	{
		CommMsgBody _msg0;
		_msg0.composeString(addr_1);
		_msg0.composeString(addr_2);
		_msg0.composeString(city);
		_msg0.composeString(state);
		_msg0.composeString(country);
		_msg0.composeString(zipCode);
		_msg.composeMsgBody(_msg0);
	}
	else if (updateType == eUserUpdateTypeEmail)
	{
		CommMsgBody _msg1;
		_msg1.composeString(email);
		_msg1.composeBOOL(autoValidateEmail);
		_msg.composeMsgBody(_msg1);
	}
	else if (updateType == eUserUpdateTypePassword)
	{
		CommMsgBody _msg2;
		_msg2.composeString(pwd);
		_msg.composeMsgBody(_msg2);
	}
	else if (updateType == eUserUpdateTypeImage)
	{
		CommMsgBody _msg3;
		_msg3.composeBYTE(imageType);
		_msg3._composeVarBlock(imgData.ptr(), imgData.size());
		_msg.composeMsgBody(_msg3);
	}
	else if (updateType == eUserUpdateTypeFullName)
	{
		CommMsgBody _msg4;
		_msg4.composeString(fullName);
		_msg.composeMsgBody(_msg4);
	}
	else if (updateType == eUserUpdateTypePhone)
	{
		CommMsgBody _msg5;
		_msg5.composeString(phone);
		_msg.composeMsgBody(_msg5);
	}
	else if (updateType == eUserUpdateTypeRealMoney)
	{
		CommMsgBody _msg6;
		_msg.composeMsgBody(_msg6);
	}
	else if (updateType == eUserUpdateTypeFirstNameLastName)
	{
		CommMsgBody _msg7;
		_msg7.composeString(firstName);
		_msg7.composeString(lastName);
		_msg.composeMsgBody(_msg7);
	}
	else if (updateType == eUserUpdateTypeFiscalCode)
	{
		CommMsgBody _msg8;
		_msg8.composeString(fiscalCode);
		_msg.composeMsgBody(_msg8);
	}
	else if (updateType == eUserUpdateTypeEncrFiscalCode)
	{
		CommMsgBody _msg9;
		_msg9.composeString(encrFiscalCode);
		_msg.composeMsgBody(_msg9);
	}
	else if (updateType == eUserUpdateTypeProperties)
	{
		CommMsgBody _msg90;
		properties.composeMsg(_msg90);
		_msg.composeMsgBody(_msg90);
	}
	else if (updateType == eUserUpdateTypeBirthday)
	{
		CommMsgBody _msg91;
		_msg91.composeSrvDate(birthDate);
		_msg.composeMsgBody(_msg91);
	}
	else if (updateType == eUserUpdateTypeImageId)
	{
		CommMsgBody _msg92;
		_msg92.composeUINT32(imageId);
		_msg92.composeUINT32(currentImageId);
		_msg92.composeBOOL(isCurrentImageFromGallery);
		_msg.composeMsgBody(_msg92);
	}
	else if (updateType == eUserUpdateTypeSwitchImageId)
	{
		CommMsgBody _msg93;
		_msg93.composeUINT32(imageId);
		_msg93.composeBOOL(isGalleryImage);
		_msg93.composeUINT32(currentImageId);
		_msg93.composeBOOL(isCurrentImageFromGallery);
		_msg93.composeUINT32(adminIntId);
		_msg93.composeString(adminId);
		_msg.composeMsgBody(_msg93);
	}
	else if (updateType == eUserUpdateTypeSex)
	{
		CommMsgBody _msg94;
		_msg94.composeString(sex);
		_msg.composeMsgBody(_msg94);
	}
	else if (updateType == eUserUpdateTypeMobile)
	{
		CommMsgBody _msg95;
		_msg95.composeString(mobile);
		_msg.composeMsgBody(_msg95);
	}
	else if (updateType == eUserUpdateTypeEstoniaValidation)
	{
		CommMsgBody _msg96;
		_msg96.composeString(verificationCertificate);
		_msg96.composeString(verificationSignedData);
		_msg.composeMsgBody(_msg96);
	}
	else if (updateType == eUserUpdateTypeMailList)
	{
		CommMsgBody _msg97;
		_msg97.composeBOOL(mailListIn);
		_msg.composeMsgBody(_msg97);
	}
	else if (updateType == eUserUpdateTypeMailListNew)
	{
		CommMsgBody _msg98;
		_msg98.composeBOOL(mailListPokerIn);
		_msg98.composeBOOL(mailListCasinoIn);
		_msg98.composeBOOL(mailListSportsIn);
		_msg98.composeBOOL(mailListSportsLiveAlertIn);
		_msg.composeMsgBody(_msg98);
	}
	else if (updateType == eUserUpdateTypeExternalValidation)
	{
		CommMsgBody _msg99;
		profile.composeMsg(_msg99);
		_msg.composeMsgBody(_msg99);
	}
	else if (updateType == eUserUpdateTypeRealMoneyOkFlag)
	{
		CommMsgBody _msg990;
		_msg990.composeBOOL(realMoneyOkSet);
		_msg990.composeString(comment);
		_msg.composeMsgBody(_msg990);
	}
	else if (updateType == eUserUpdateTypeSetLimits)
	{
		CommMsgBody _msg991;
		_msg991.composeINT32(weeklyDepositLimit);
		_msg991.composeINT32(buyInLimit);
		_msg991.composeBOOL(isBuyInLimitValid);
		_msg991.composeINT32(sportsAccumulatedLimit);
		_msg.composeMsgBody(_msg991);
	}
	else if (updateType == eUserUpdateTypeSMSPwdReset)
	{
		CommMsgBody _msg992;
		_msg992.composeBOOL(allowSMSPwdReset);
		_msg.composeMsgBody(_msg992);
	}
	else if (updateType == eUserUpdateTypeSmsMarketingFlag)
	{
		CommMsgBody _msg993;
		_msg993.composeBOOL(smsMarketingFlagValue);
		_msg.composeMsgBody(_msg993);
	}
	else if (updateType == eUserUpdateTypePwdStrongAuth)
	{
		CommMsgBody _msg994;
		_msg994.composeString(answer1);
		_msg994.composeString(answer2);
		_msg994.composeString(ssn4);
		_msg.composeMsgBody(_msg994);
	}
	else if (updateType == eUserUpdateTypeBooleanActions)
	{
		CommMsgBody _msg995;
		_msg995.composeUINT32(booleanActions);
		_msg.composeMsgBody(_msg995);
	}
	else if (updateType == eUserUpdateTypeLeaderBoard)
	{
		CommMsgBody _msg996;
		_msg996.composeBOOL(optinLeaderBoard);
		_msg.composeMsgBody(_msg996);
	}
	else if (updateType == eUserUpdateTypeInternalServerNonUpdInfo)
	{
		CommMsgBody _msg997;
		_msg997.composeUINT64(appLoginId);
		_msg997.composeUINT32(brandId);
		_msg997.composeUINT32(adminIntId);
		_msg997.composeString(adminId);
		_msg.composeMsgBody(_msg997);
	}
	else if (updateType == eUserUpdateTypeAgeVerification)
	{
		CommMsgBody _msg998;
		_msg998.composeINT32(requestCtx);
		_msg.composeMsgBody(_msg998);
	}
	else
	{
		_msg.composeMsgBody(dummy_makeATFdefinitionForThisUpdateType);
	}
}

void regulator::common_structs::UserUpdateElement::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(updateType);
	if (updateType == eUserUpdateTypeAddress)
	{
		parseAnonymousMsgBody0(_parser);
	}
	else if (updateType == eUserUpdateTypeEmail)
	{
		parseAnonymousMsgBody1(_parser);
	}
	else if (updateType == eUserUpdateTypePassword)
	{
		parseAnonymousMsgBody2(_parser);
	}
	else if (updateType == eUserUpdateTypeImage)
	{
		parseAnonymousMsgBody3(_parser);
	}
	else if (updateType == eUserUpdateTypeFullName)
	{
		parseAnonymousMsgBody4(_parser);
	}
	else if (updateType == eUserUpdateTypePhone)
	{
		parseAnonymousMsgBody5(_parser);
	}
	else if (updateType == eUserUpdateTypeRealMoney)
	{
		parseAnonymousMsgBody6(_parser);
	}
	else if (updateType == eUserUpdateTypeFirstNameLastName)
	{
		parseAnonymousMsgBody7(_parser);
	}
	else if (updateType == eUserUpdateTypeFiscalCode)
	{
		parseAnonymousMsgBody8(_parser);
	}
	else if (updateType == eUserUpdateTypeEncrFiscalCode)
	{
		parseAnonymousMsgBody9(_parser);
	}
	else if (updateType == eUserUpdateTypeProperties)
	{
		parseAnonymousMsgBody10(_parser);
	}
	else if (updateType == eUserUpdateTypeBirthday)
	{
		parseAnonymousMsgBody11(_parser);
	}
	else if (updateType == eUserUpdateTypeImageId)
	{
		parseAnonymousMsgBody12(_parser);
	}
	else if (updateType == eUserUpdateTypeSwitchImageId)
	{
		parseAnonymousMsgBody13(_parser);
	}
	else if (updateType == eUserUpdateTypeSex)
	{
		parseAnonymousMsgBody14(_parser);
	}
	else if (updateType == eUserUpdateTypeMobile)
	{
		parseAnonymousMsgBody15(_parser);
	}
	else if (updateType == eUserUpdateTypeEstoniaValidation)
	{
		parseAnonymousMsgBody16(_parser);
	}
	else if (updateType == eUserUpdateTypeMailList)
	{
		parseAnonymousMsgBody17(_parser);
	}
	else if (updateType == eUserUpdateTypeMailListNew)
	{
		parseAnonymousMsgBody18(_parser);
	}
	else if (updateType == eUserUpdateTypeExternalValidation)
	{
		parseAnonymousMsgBody19(_parser);
	}
	else if (updateType == eUserUpdateTypeRealMoneyOkFlag)
	{
		parseAnonymousMsgBody20(_parser);
	}
	else if (updateType == eUserUpdateTypeSetLimits)
	{
		parseAnonymousMsgBody21(_parser);
	}
	else if (updateType == eUserUpdateTypeSMSPwdReset)
	{
		parseAnonymousMsgBody22(_parser);
	}
	else if (updateType == eUserUpdateTypeSmsMarketingFlag)
	{
		parseAnonymousMsgBody23(_parser);
	}
	else if (updateType == eUserUpdateTypePwdStrongAuth)
	{
		parseAnonymousMsgBody24(_parser);
	}
	else if (updateType == eUserUpdateTypeBooleanActions)
	{
		parseAnonymousMsgBody25(_parser);
	}
	else if (updateType == eUserUpdateTypeLeaderBoard)
	{
		parseAnonymousMsgBody26(_parser);
	}
	else if (updateType == eUserUpdateTypeInternalServerNonUpdInfo)
	{
		parseAnonymousMsgBody27(_parser);
	}
	else if (updateType == eUserUpdateTypeAgeVerification)
	{
		parseAnonymousMsgBody28(_parser);
	}
	else
	{
		_parser.parseMsgBody(dummy_makeATFdefinitionForThisUpdateType);
	}
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 updateType = 0;
	_parser.parseUINT32(updateType);
	AtfValidator::validateIntRange(_descr, "updateType", updateType, eUserUpdateTypeUndefined, eUserUpdateTypeLast, _checker, __FILE__, __LINE__);
	if (updateType == eUserUpdateTypeAddress)
	{
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeEmail)
	{
		validateAnonymousMsgBody1(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypePassword)
	{
		validateAnonymousMsgBody2(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeImage)
	{
		validateAnonymousMsgBody3(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeFullName)
	{
		validateAnonymousMsgBody4(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypePhone)
	{
		validateAnonymousMsgBody5(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeRealMoney)
	{
		validateAnonymousMsgBody6(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeFirstNameLastName)
	{
		validateAnonymousMsgBody7(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeFiscalCode)
	{
		validateAnonymousMsgBody8(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeEncrFiscalCode)
	{
		validateAnonymousMsgBody9(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeProperties)
	{
		validateAnonymousMsgBody10(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeBirthday)
	{
		validateAnonymousMsgBody11(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeImageId)
	{
		validateAnonymousMsgBody12(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeSwitchImageId)
	{
		validateAnonymousMsgBody13(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeSex)
	{
		validateAnonymousMsgBody14(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeMobile)
	{
		validateAnonymousMsgBody15(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeEstoniaValidation)
	{
		validateAnonymousMsgBody16(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeMailList)
	{
		validateAnonymousMsgBody17(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeMailListNew)
	{
		validateAnonymousMsgBody18(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeExternalValidation)
	{
		validateAnonymousMsgBody19(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeRealMoneyOkFlag)
	{
		validateAnonymousMsgBody20(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeSetLimits)
	{
		validateAnonymousMsgBody21(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeSMSPwdReset)
	{
		validateAnonymousMsgBody22(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeSmsMarketingFlag)
	{
		validateAnonymousMsgBody23(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypePwdStrongAuth)
	{
		validateAnonymousMsgBody24(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeBooleanActions)
	{
		validateAnonymousMsgBody25(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeLeaderBoard)
	{
		validateAnonymousMsgBody26(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeInternalServerNonUpdInfo)
	{
		validateAnonymousMsgBody27(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (updateType == eUserUpdateTypeAgeVerification)
	{
		validateAnonymousMsgBody28(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else
	{
		size_t szDummy_makeATFdefinitionForThisUpdateType; _parser.skipMsgBody(szDummy_makeATFdefinitionForThisUpdateType);  /*dummy_makeATFdefinitionForThisUpdateType*/
		AtfValidator::validateIntMax(_descr, "dummy_makeATFdefinitionForThisUpdateType", szDummy_makeATFdefinitionForThisUpdateType, 0, _checker, __FILE__, __LINE__);
	}
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(addr_1);
	_parser0.parseStringP(addr_2);
	_parser0.parseStringP(city);
	_parser0.parseStringP(state);
	_parser0.parseStringP(country);
	_parser0.parseStringP(zipCode);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "addr_1"); size_t szAddr_1 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "addr_1", szAddr_1, USER_ADDR_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "addr_2"); size_t szAddr_2 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "addr_2", szAddr_2, USER_ADDR2_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "city", szCity, USER_CITY_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "state"); size_t szState = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "state", szState, USER_STATE_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, USER_COUNTRY_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "zipCode"); size_t szZipCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "zipCode", szZipCode, USER_ZIP_LEN, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody1(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(email);
	if(_parser0.parseEnded()) return;
	_parser0.parseBOOL(autoValidateEmail);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody1(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "email", szEmail, USER_EMAIL_LEN, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	bool autoValidateEmail; _parser0.parseBOOL(autoValidateEmail);
	AtfValidator::validateInt(_descr, "autoValidateEmail", autoValidateEmail, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody2(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(pwd);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody2(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "pwd"); size_t szPwd = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "pwd", szPwd, USER_PWD_LEN, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody3(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(imageType);
	_parser0.parsePBlock(imgData);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody3(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	BYTE imageType; _parser0.parseBYTE(imageType);
	{ const BYTE imageType_enum[] = { IMAGE_TYPE_NONE, IMAGE_TYPE_PRIVATE }; AtfValidator::validateEnum(_descr, "imageType", imageType, imageType_enum, _checker, __FILE__, __LINE__); }
	const BYTE* imgData; size_t szImgData; _parser0._parseVarBlock(imgData, szImgData);  /*imgData*/
	AtfValidator::validateIntMax(_descr, "imgData", szImgData, IMAGE_LEN, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody4(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(fullName);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody4(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "fullName"); size_t szFullName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "fullName", szFullName, USER_FULLNAME_LEN, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody5(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(phone);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody5(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "phone"); size_t szPhone = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "phone", szPhone, 100, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody6(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody6(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody7(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(firstName);
	_parser0.parseStringP(lastName);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody7(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "firstName"); size_t szFirstName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "firstName", szFirstName, USER_FIRST_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "lastName"); size_t szLastName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "lastName", szLastName, USER_LAST_NAME_LEN, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody8(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(fiscalCode);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody8(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "fiscalCode"); size_t szFiscalCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "fiscalCode", szFiscalCode, USER_FISCAL_CODE_LEN, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody9(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(encrFiscalCode);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody9(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "encrFiscalCode"); size_t szEncrFiscalCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "encrFiscalCode", szEncrFiscalCode, 4000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody10(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	properties.parseMsg(_parser0);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody10(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szProperties = ThinAtf::LAtfVector< CommonThin::AtfShared::UserPropertyLegacy, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("properties"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "properties", szProperties, 2000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody11(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseSrvDate(birthDate);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody11(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	CommSrvDate birthDate; _parser0.parseSrvDate(birthDate);
	AtfValidator::validateSrvDateTime(_descr, "birthDate", birthDate, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody12(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(imageId);
	_parser0.parseUINT32(currentImageId);
	_parser0.parseBOOL(isCurrentImageFromGallery);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody12(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 imageId; _parser0.parseUINT32(imageId);
	AtfValidator::validateInt(_descr, "imageId", imageId, _checker, __FILE__, __LINE__);
	UINT32 currentImageId; _parser0.parseUINT32(currentImageId);
	AtfValidator::validateInt(_descr, "currentImageId", currentImageId, _checker, __FILE__, __LINE__);
	bool isCurrentImageFromGallery; _parser0.parseBOOL(isCurrentImageFromGallery);
	AtfValidator::validateInt(_descr, "isCurrentImageFromGallery", isCurrentImageFromGallery, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody13(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(imageId);
	_parser0.parseBOOL(isGalleryImage);
	_parser0.parseUINT32(currentImageId);
	_parser0.parseBOOL(isCurrentImageFromGallery);
	_parser0.parseUINT32(adminIntId);
	_parser0.parseStringP(adminId);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody13(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 imageId; _parser0.parseUINT32(imageId);
	AtfValidator::validateInt(_descr, "imageId", imageId, _checker, __FILE__, __LINE__);
	bool isGalleryImage; _parser0.parseBOOL(isGalleryImage);
	AtfValidator::validateInt(_descr, "isGalleryImage", isGalleryImage, _checker, __FILE__, __LINE__);
	UINT32 currentImageId; _parser0.parseUINT32(currentImageId);
	AtfValidator::validateInt(_descr, "currentImageId", currentImageId, _checker, __FILE__, __LINE__);
	bool isCurrentImageFromGallery; _parser0.parseBOOL(isCurrentImageFromGallery);
	AtfValidator::validateInt(_descr, "isCurrentImageFromGallery", isCurrentImageFromGallery, _checker, __FILE__, __LINE__);
	UINT32 adminIntId; _parser0.parseUINT32(adminIntId);
	AtfValidator::validateInt(_descr, "adminIntId", adminIntId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "adminId"); size_t szAdminId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "adminId", szAdminId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody14(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(sex);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody14(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "sex"); size_t szSex = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "sex", szSex, USER_SEX_LEN, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody15(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(mobile);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody15(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "mobile"); size_t szMobile = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "mobile", szMobile, 100, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody16(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(verificationCertificate);
	_parser0.parseStringP(verificationSignedData);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody16(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "verificationCertificate"); size_t szVerificationCertificate = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "verificationCertificate", szVerificationCertificate, 2000, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "verificationSignedData"); size_t szVerificationSignedData = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "verificationSignedData", szVerificationSignedData, 2000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody17(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(mailListIn);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody17(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	bool mailListIn; _parser0.parseBOOL(mailListIn);
	AtfValidator::validateInt(_descr, "mailListIn", mailListIn, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody18(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(mailListPokerIn);
	_parser0.parseBOOL(mailListCasinoIn);
	_parser0.parseBOOL(mailListSportsIn);
	if(_parser0.parseEnded()) return;
	_parser0.parseBOOL(mailListSportsLiveAlertIn);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody18(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	bool mailListPokerIn; _parser0.parseBOOL(mailListPokerIn);
	AtfValidator::validateInt(_descr, "mailListPokerIn", mailListPokerIn, _checker, __FILE__, __LINE__);
	bool mailListCasinoIn; _parser0.parseBOOL(mailListCasinoIn);
	AtfValidator::validateInt(_descr, "mailListCasinoIn", mailListCasinoIn, _checker, __FILE__, __LINE__);
	bool mailListSportsIn; _parser0.parseBOOL(mailListSportsIn);
	AtfValidator::validateInt(_descr, "mailListSportsIn", mailListSportsIn, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	bool mailListSportsLiveAlertIn; _parser0.parseBOOL(mailListSportsLiveAlertIn);
	AtfValidator::validateInt(_descr, "mailListSportsLiveAlertIn", mailListSportsLiveAlertIn, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody19(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	profile.parseMsg(_parser0);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody19(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	UserProfile::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("profile"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody20(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(realMoneyOkSet);
	_parser0.parseStringP(comment);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody20(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	bool realMoneyOkSet; _parser0.parseBOOL(realMoneyOkSet);
	AtfValidator::validateInt(_descr, "realMoneyOkSet", realMoneyOkSet, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "comment"); size_t szComment = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "comment", szComment, 1000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody21(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(weeklyDepositLimit);
	_parser0.parseINT32(buyInLimit);
	_parser0.parseBOOL(isBuyInLimitValid);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT32(sportsAccumulatedLimit);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody21(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 weeklyDepositLimit; _parser0.parseINT32(weeklyDepositLimit);
	AtfValidator::validateIntRange(_descr, "weeklyDepositLimit", weeklyDepositLimit, -1, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	INT32 buyInLimit; _parser0.parseINT32(buyInLimit);
	AtfValidator::validateIntRange(_descr, "buyInLimit", buyInLimit, -1, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	bool isBuyInLimitValid; _parser0.parseBOOL(isBuyInLimitValid);
	AtfValidator::validateInt(_descr, "isBuyInLimitValid", isBuyInLimitValid, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT32 sportsAccumulatedLimit; _parser0.parseINT32(sportsAccumulatedLimit);
	AtfValidator::validateInt(_descr, "sportsAccumulatedLimit", sportsAccumulatedLimit, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody22(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(allowSMSPwdReset);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody22(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	bool allowSMSPwdReset; _parser0.parseBOOL(allowSMSPwdReset);
	AtfValidator::validateInt(_descr, "allowSMSPwdReset", allowSMSPwdReset, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody23(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(smsMarketingFlagValue);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody23(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	bool smsMarketingFlagValue; _parser0.parseBOOL(smsMarketingFlagValue);
	AtfValidator::validateInt(_descr, "smsMarketingFlagValue", smsMarketingFlagValue, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody24(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(answer1);
	_parser0.parseStringP(answer2);
	_parser0.parseStringP(ssn4);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody24(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "answer1"); size_t szAnswer1 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "answer1", szAnswer1, 1000, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "answer2"); size_t szAnswer2 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "answer2", szAnswer2, 1000, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "ssn4"); size_t szSsn4 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "ssn4", szSsn4, SSN_4_LEN, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody25(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(booleanActions);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody25(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 booleanActions; _parser0.parseUINT32(booleanActions);
	AtfValidator::validateInt(_descr, "booleanActions", booleanActions, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody26(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(optinLeaderBoard);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody26(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	bool optinLeaderBoard; _parser0.parseBOOL(optinLeaderBoard);
	AtfValidator::validateInt(_descr, "optinLeaderBoard", optinLeaderBoard, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody27(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseUINT64(appLoginId);
	_parser0.parseUINT32(brandId);
	_parser0.parseUINT32(adminIntId);
	_parser0.parseStringP(adminId);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody27(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT64 appLoginId; _parser0.parseUINT64(appLoginId);
	AtfValidator::validateUint(_descr, "appLoginId", appLoginId, _checker, __FILE__, __LINE__);
	UINT32 brandId; _parser0.parseUINT32(brandId);
	AtfValidator::validateIntRange(_descr, "brandId", brandId, BrandType_None, BrandType_Last, _checker, __FILE__, __LINE__);
	UINT32 adminIntId; _parser0.parseUINT32(adminIntId);
	AtfValidator::validateInt(_descr, "adminIntId", adminIntId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "adminId"); size_t szAdminId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "adminId", szAdminId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::common_structs::UserUpdateElement::parseAnonymousMsgBody28(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(requestCtx);
}

/*static*/ void regulator::common_structs::UserUpdateElement::validateAnonymousMsgBody28(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 requestCtx; _parser0.parseINT32(requestCtx);
	AtfValidator::validateInt(_descr, "requestCtx", requestCtx, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    UserUpdateValidationResult
//=================================================================

regulator::common_structs::UserUpdateValidationResult::UserUpdateValidationResult()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::common_structs::UserUpdateValidationResult::UserUpdateValidationResult(UserUpdateValidationResult&& _o)
	: updateType(std::move(_o.updateType))
	, errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

regulator::common_structs::UserUpdateValidationResult& regulator::common_structs::UserUpdateValidationResult::operator=(UserUpdateValidationResult&& _o)
{
	if(this != &_o)
	{
		updateType = std::move(_o.updateType);
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void regulator::common_structs::UserUpdateValidationResult::clear()
{
	updateType = 0;
	errCode = 0;
	errDescr.clear();
}

bool regulator::common_structs::UserUpdateValidationResult::equals(const UserUpdateValidationResult& _o) const
{
	return updateType == _o.updateType &&
		errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *regulator::common_structs::UserUpdateValidationResult::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("updateType=");
	_buf.appendInt(updateType);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errDescr=");
	_buf.append(errDescr);
	_buf.append('}');
	return _buf.c_str();
}

void regulator::common_structs::UserUpdateValidationResult::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(updateType);
	_msg.composeINT16(errCode);
	_msg.composeString(errDescr);
}

void regulator::common_structs::UserUpdateValidationResult::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(updateType);
	_parser.parseINT16(errCode);
	_parser.parseStringP(errDescr);
}

/*static*/ void regulator::common_structs::UserUpdateValidationResult::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	INT32 updateType; _parser.parseINT32(updateType);
	AtfValidator::validateInt(_descr, "updateType", updateType, _checker, __FILE__, __LINE__);
	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    SwissUrlParamString
//=================================================================

regulator::common_structs::SwissUrlParamString::SwissUrlParamString()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::common_structs::SwissUrlParamString::SwissUrlParamString(SwissUrlParamString&& _o)
	: param(std::move(_o.param))
{
}

regulator::common_structs::SwissUrlParamString& regulator::common_structs::SwissUrlParamString::operator=(SwissUrlParamString&& _o)
{
	if(this != &_o)
	{
		param = std::move(_o.param);
	}
	return *this;
}

#endif

void regulator::common_structs::SwissUrlParamString::clear()
{
	param.clear();
}

bool regulator::common_structs::SwissUrlParamString::equals(const SwissUrlParamString& _o) const
{
	return param.equals(_o.param);
}

const char *regulator::common_structs::SwissUrlParamString::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("param=");
	_buf.append(param);
	_buf.append('}');
	return _buf.c_str();
}

void regulator::common_structs::SwissUrlParamString::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(param);
}

void regulator::common_structs::SwissUrlParamString::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(param);
}

/*static*/ void regulator::common_structs::SwissUrlParamString::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "param"); size_t szParam = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "param", szParam, 256, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    SwissUrlRequest
//=================================================================

regulator::common_structs::SwissUrlRequest::SwissUrlRequest()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::common_structs::SwissUrlRequest::SwissUrlRequest(SwissUrlRequest&& _o)
	: locale(std::move(_o.locale))
	, urlType(std::move(_o.urlType))
	, params(std::move(_o.params))
{
}

regulator::common_structs::SwissUrlRequest& regulator::common_structs::SwissUrlRequest::operator=(SwissUrlRequest&& _o)
{
	if(this != &_o)
	{
		locale = std::move(_o.locale);
		urlType = std::move(_o.urlType);
		params = std::move(_o.params);
	}
	return *this;
}

#endif

void regulator::common_structs::SwissUrlRequest::clear()
{
	locale = 0;
	urlType = 0;
	params.clear();
}

bool regulator::common_structs::SwissUrlRequest::equals(const SwissUrlRequest& _o) const
{
	return locale == _o.locale &&
		urlType == _o.urlType &&
		params.equals(_o.params);
}

const char *regulator::common_structs::SwissUrlRequest::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("urlType=");
	_buf.appendUint(urlType);
	_buf.append(',');
	_buf.append("params=");
	_buf.append("...");
	_buf.append('}');
	return _buf.c_str();
}

void regulator::common_structs::SwissUrlRequest::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(locale);
	_msg.composeUINT32(urlType);
	params.composeMsg(_msg);
}

void regulator::common_structs::SwissUrlRequest::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(locale);
	_parser.parseUINT32(urlType);
	params.parseMsg(_parser);
}

/*static*/ void regulator::common_structs::SwissUrlRequest::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateInt(_descr, "locale", locale, _checker, __FILE__, __LINE__);
	UINT32 urlType; _parser.parseUINT32(urlType);
	AtfValidator::validateInt(_descr, "urlType", urlType, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szParams = ThinAtf::LAtfVector< SwissUrlParamString, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("params"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "params", szParams, 8, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_UPDATE_USER2
//=================================================================

regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2::Protocol_MSG_LOBBY_UPDATE_USER2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2::Protocol_MSG_LOBBY_UPDATE_USER2(Protocol_MSG_LOBBY_UPDATE_USER2&& _o)
	: userId_ignore(std::move(_o.userId_ignore))
	, elements(std::move(_o.elements))
	, flags_ingore(std::move(_o.flags_ingore))
	, flags2_ignore(std::move(_o.flags2_ignore))
{
}

regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2& regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2::operator=(Protocol_MSG_LOBBY_UPDATE_USER2&& _o)
{
	if(this != &_o)
	{
		userId_ignore = std::move(_o.userId_ignore);
		elements = std::move(_o.elements);
		flags_ingore = std::move(_o.flags_ingore);
		flags2_ignore = std::move(_o.flags2_ignore);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2::clear()
{
	userId_ignore.clear();
	elements.clear();
	flags_ingore = 0;
	flags2_ignore = 0;
}

bool regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2::equals(const Protocol_MSG_LOBBY_UPDATE_USER2& _o) const
{
	return userId_ignore.equals(_o.userId_ignore) &&
		elements.equals(_o.elements) &&
		flags_ingore == _o.flags_ingore &&
		flags2_ignore == _o.flags2_ignore;
}

const char *regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_UPDATE_USER2).append(")");
	_buf.append(',');
	_buf.append("userId_ignore=");
	_buf.append(userId_ignore);
	_buf.append(',');
	_buf.append("elements=");
	elements.toTraceString(_buf);
	_buf.append(',');
	_buf.append("flags_ingore=");
	_buf.appendUint(flags_ingore);
	_buf.append(',');
	_buf.append("flags2_ignore=");
	_buf.appendUint64(flags2_ignore);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId_ignore);
	elements.composeMsg(_msg);
	_msg.composeUINT32(flags_ingore);
	_msg.composeUINT64(flags2_ignore);
}

void regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId_ignore);
	elements.parseMsg(_parser);
	_parser.parseUINT32(flags_ingore);
	_parser.parseUINT64(flags2_ignore);
}

/*static*/ void regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_UPDATE_USER2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId_ignore"); size_t szUserId_ignore = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId_ignore", szUserId_ignore, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szElements = ThinAtf::LAtfVector< common_structs::UserUpdateElement, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("elements"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "elements", szElements, 1000, _checker, __FILE__, __LINE__);
	UINT32 flags_ingore; _parser.parseUINT32(flags_ingore);
	AtfValidator::validateInt(_descr, "flags_ingore", flags_ingore, _checker, __FILE__, __LINE__);
	UINT64 flags2_ignore; _parser.parseUINT64(flags2_ignore);
	AtfValidator::validateUint(_descr, "flags2_ignore", flags2_ignore, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_UPDATE_USER2_REPLY
//=================================================================

regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2_REPLY::Protocol_MSG_LOBBY_UPDATE_USER2_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2_REPLY::Protocol_MSG_LOBBY_UPDATE_USER2_REPLY(Protocol_MSG_LOBBY_UPDATE_USER2_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, frArjelUserHash(std::move(_o.frArjelUserHash))
	, doReconnect(std::move(_o.doReconnect))
	, emailAutoValidated(std::move(_o.emailAutoValidated))
	, specificContext(std::move(_o.specificContext))
{
}

regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2_REPLY& regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2_REPLY::operator=(Protocol_MSG_LOBBY_UPDATE_USER2_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		frArjelUserHash = std::move(_o.frArjelUserHash);
		doReconnect = std::move(_o.doReconnect);
		emailAutoValidated = std::move(_o.emailAutoValidated);
		specificContext = std::move(_o.specificContext);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	frArjelUserHash.clear();
	doReconnect = false;
	emailAutoValidated = false;
	specificContext.clear();
}

bool regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2_REPLY::equals(const Protocol_MSG_LOBBY_UPDATE_USER2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		frArjelUserHash.equals(_o.frArjelUserHash) &&
		doReconnect == _o.doReconnect &&
		emailAutoValidated == _o.emailAutoValidated &&
		specificContext.equals(_o.specificContext);
}

const char *regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_UPDATE_USER2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("frArjelUserHash=");
		_buf.append(frArjelUserHash);
		_buf.append(',');
		_buf.append("doReconnect=");
		_buf.appendUint(doReconnect);
		_buf.append(',');
		_buf.append("emailAutoValidated=");
		_buf.appendUint(emailAutoValidated);
		_buf.append(',');
		_buf.append("specificContext=");
		specificContext.toTraceString(_buf);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(frArjelUserHash);
		_msg.composeBOOL(doReconnect);
		_msg.composeBOOL(emailAutoValidated);
		_msg.composeMsgBody(specificContext);
	}
}

void regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(frArjelUserHash);
		_parser.parseBOOL(doReconnect);
		_parser.parseBOOL(emailAutoValidated);
		if(_parser.parseEnded()) return;
		_parser.parseMsgBody(specificContext);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_LOBBY_UPDATE_USER2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_UPDATE_USER2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "frArjelUserHash"); size_t szFrArjelUserHash = strlen(_dummy);
		AtfValidator::validateInt(_descr, "frArjelUserHash", szFrArjelUserHash, _checker, __FILE__, __LINE__);
		bool doReconnect; _parser.parseBOOL(doReconnect);
		AtfValidator::validateInt(_descr, "doReconnect", doReconnect, _checker, __FILE__, __LINE__);
		bool emailAutoValidated; _parser.parseBOOL(emailAutoValidated);
		AtfValidator::validateInt(_descr, "emailAutoValidated", emailAutoValidated, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		size_t szSpecificContext; _parser.skipMsgBody(szSpecificContext);  /*specificContext*/
		AtfValidator::validateInt(_descr, "specificContext", szSpecificContext, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE
//=================================================================

regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE(Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE&& _o)
	: fiscalCode(std::move(_o.fiscalCode))
{
}

regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE& regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE::operator=(Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE&& _o)
{
	if(this != &_o)
	{
		fiscalCode = std::move(_o.fiscalCode);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE::clear()
{
	fiscalCode.clear();
}

bool regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE::equals(const Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE& _o) const
{
	return fiscalCode.equals(_o.fiscalCode);
}

const char *regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_LOOKUP_FISCAL_CODE).append(")");
	_buf.append(',');
	_buf.append("fiscalCode=");
	_buf.append(fiscalCode);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(fiscalCode);
}

void regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(fiscalCode);
}

/*static*/ void regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_LOOKUP_FISCAL_CODE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "fiscalCode"); size_t szFiscalCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "fiscalCode", szFiscalCode, 32, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    FiscalCodeCountry
//=================================================================

regulator::cli::FiscalCodeCountry::FiscalCodeCountry()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::FiscalCodeCountry::FiscalCodeCountry(FiscalCodeCountry&& _o)
	: code(std::move(_o.code))
	, country(std::move(_o.country))
{
}

regulator::cli::FiscalCodeCountry& regulator::cli::FiscalCodeCountry::operator=(FiscalCodeCountry&& _o)
{
	if(this != &_o)
	{
		code = std::move(_o.code);
		country = std::move(_o.country);
	}
	return *this;
}

#endif

void regulator::cli::FiscalCodeCountry::clear()
{
	code.clear();
	country.clear();
}

bool regulator::cli::FiscalCodeCountry::equals(const FiscalCodeCountry& _o) const
{
	return code.equals(_o.code) &&
		country.equals(_o.country);
}

const char *regulator::cli::FiscalCodeCountry::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("code=");
	_buf.append(code);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append('}');
	return _buf.c_str();
}

void regulator::cli::FiscalCodeCountry::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(FiscalCodeCountry())) // not empty
	{
		_body.composeString(code);
		_body.composeString(country);
	}

	_msg.composeMsgBody(_body);
}

void regulator::cli::FiscalCodeCountry::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(code);
	_parser0.parseStringP(country);
}

/*static*/ void regulator::cli::FiscalCodeCountry::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "code"); size_t szCode = strlen(_dummy);
	AtfValidator::validateInt(_descr, "code", szCode, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    FiscalCodeCity
//=================================================================

regulator::cli::FiscalCodeCity::FiscalCodeCity()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::FiscalCodeCity::FiscalCodeCity(FiscalCodeCity&& _o)
	: province(std::move(_o.province))
	, city(std::move(_o.city))
{
}

regulator::cli::FiscalCodeCity& regulator::cli::FiscalCodeCity::operator=(FiscalCodeCity&& _o)
{
	if(this != &_o)
	{
		province = std::move(_o.province);
		city = std::move(_o.city);
	}
	return *this;
}

#endif

void regulator::cli::FiscalCodeCity::clear()
{
	province.clear();
	city.clear();
}

bool regulator::cli::FiscalCodeCity::equals(const FiscalCodeCity& _o) const
{
	return province.equals(_o.province) &&
		city.equals(_o.city);
}

const char *regulator::cli::FiscalCodeCity::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("province=");
	_buf.append(province);
	_buf.append(',');
	_buf.append("city=");
	_buf.append(city);
	_buf.append('}');
	return _buf.c_str();
}

void regulator::cli::FiscalCodeCity::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(FiscalCodeCity())) // not empty
	{
		_body.composeString(province);
		_body.composeString(city);
	}

	_msg.composeMsgBody(_body);
}

void regulator::cli::FiscalCodeCity::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(province);
	_parser0.parseStringP(city);
}

/*static*/ void regulator::cli::FiscalCodeCity::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "province"); size_t szProvince = strlen(_dummy);
	AtfValidator::validateInt(_descr, "province", szProvince, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
	AtfValidator::validateInt(_descr, "city", szCity, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY
//=================================================================

regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY(Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, cities(std::move(_o.cities))
	, countries(std::move(_o.countries))
{
}

regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY& regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY::operator=(Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		cities = std::move(_o.cities);
		countries = std::move(_o.countries);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	cities.clear();
	countries.clear();
}

bool regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY::equals(const Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		cities.equals(_o.cities) &&
		countries.equals(_o.countries);
}

const char *regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("cities=");
		cities.toTraceString(_buf);
		_buf.append(',');
		_buf.append("countries=");
		countries.toTraceString(_buf);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		cities.composeMsg(_msg);
		countries.composeMsg(_msg);
	}
}

void regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		cities.parseMsg(_parser);
		countries.parseMsg(_parser);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szCities = ThinAtf::LAtfVector< FiscalCodeCity, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cities"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "cities", szCities, _checker, __FILE__, __LINE__);
		int szCountries = ThinAtf::LAtfVector< FiscalCodeCountry, 2 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("countries"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "countries", szCountries, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE(Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE&& _o)
	: unusedUserIntId(std::move(_o.unusedUserIntId))
	, unusedUserId(std::move(_o.unusedUserId))
	, fiscalCode(std::move(_o.fiscalCode))
{
}

regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE& regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE::operator=(Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE&& _o)
{
	if(this != &_o)
	{
		unusedUserIntId = std::move(_o.unusedUserIntId);
		unusedUserId = std::move(_o.unusedUserId);
		fiscalCode = std::move(_o.fiscalCode);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE::clear()
{
	unusedUserIntId = 0;
	unusedUserId.clear();
	fiscalCode.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE::equals(const Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE& _o) const
{
	return unusedUserIntId == _o.unusedUserIntId &&
		unusedUserId.equals(_o.unusedUserId) &&
		fiscalCode.equals(_o.fiscalCode);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE).append(")");
	_buf.append(',');
	_buf.append("unusedUserIntId=");
	_buf.appendUint(unusedUserIntId);
	_buf.append(',');
	_buf.append("unusedUserId=");
	_buf.append(unusedUserId);
	_buf.append(',');
	_buf.append("fiscalCode=");
	_buf.append(fiscalCode);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(unusedUserIntId);
	_msg.composeString(unusedUserId);
	_msg.composeString(fiscalCode);
}

void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(unusedUserIntId);
	_parser.parseStringP(unusedUserId);
	_parser.parseStringP(fiscalCode);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 unusedUserIntId; _parser.parseUINT32(unusedUserIntId);
	AtfValidator::validateInt(_descr, "unusedUserIntId", unusedUserIntId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "unusedUserId"); size_t szUnusedUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "unusedUserId", szUnusedUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "fiscalCode"); size_t szFiscalCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "fiscalCode", szFiscalCode, 32, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY(Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY& regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY::operator=(Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY::equals(const Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDesc);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDesc);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_USER_GET_INFO
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO::Protocol_MSG_REGULATOR_USER_GET_INFO()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO::Protocol_MSG_REGULATOR_USER_GET_INFO(Protocol_MSG_REGULATOR_USER_GET_INFO&& _o)
	: clientVersionInfo(std::move(_o.clientVersionInfo))
	, requestFlags(std::move(_o.requestFlags))
{
}

regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO& regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO::operator=(Protocol_MSG_REGULATOR_USER_GET_INFO&& _o)
{
	if(this != &_o)
	{
		clientVersionInfo = std::move(_o.clientVersionInfo);
		requestFlags = std::move(_o.requestFlags);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO::clear()
{
	clientVersionInfo.clear();
	requestFlags = 0;
}

bool regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO::equals(const Protocol_MSG_REGULATOR_USER_GET_INFO& _o) const
{
	return clientVersionInfo.equals(_o.clientVersionInfo) &&
		requestFlags == _o.requestFlags;
}

const char *regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_USER_GET_INFO).append(")");
	_buf.append(',');
	_buf.append("clVer=");
	_buf.append(clientVersionInfo);
	_buf.append(',');
	_buf.append("f=");
	_buf.appendUint(requestFlags);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(clientVersionInfo);
	_msg.composeUINT32(requestFlags);
}

void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(clientVersionInfo);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(requestFlags);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_USER_GET_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "clientVersionInfo"); size_t szClientVersionInfo = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "clientVersionInfo", szClientVersionInfo, 1000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 requestFlags; _parser.parseUINT32(requestFlags);
	AtfValidator::validateInt(_descr, "requestFlags", requestFlags, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    UserInfoCurrencyAccountBody
//=================================================================

regulator::cli::UserInfoCurrencyAccountBody::UserInfoCurrencyAccountBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::UserInfoCurrencyAccountBody::UserInfoCurrencyAccountBody(UserInfoCurrencyAccountBody&& _o)
	: currency(std::move(_o.currency))
	, chips(std::move(_o.chips))
	, tChips(std::move(_o.tChips))
{
}

regulator::cli::UserInfoCurrencyAccountBody& regulator::cli::UserInfoCurrencyAccountBody::operator=(UserInfoCurrencyAccountBody&& _o)
{
	if(this != &_o)
	{
		currency = std::move(_o.currency);
		chips = std::move(_o.chips);
		tChips = std::move(_o.tChips);
	}
	return *this;
}

#endif

void regulator::cli::UserInfoCurrencyAccountBody::clear()
{
	currency.clear();
	chips = 0;
	tChips = 0;
}

bool regulator::cli::UserInfoCurrencyAccountBody::equals(const UserInfoCurrencyAccountBody& _o) const
{
	return currency.equals(_o.currency) &&
		chips == _o.chips &&
		tChips == _o.tChips;
}

const char *regulator::cli::UserInfoCurrencyAccountBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("chips=");
	_buf.appendInt64(chips);
	_buf.append(',');
	_buf.append("tChips=");
	_buf.appendInt64(tChips);
	_buf.append('}');
	return _buf.c_str();
}

void regulator::cli::UserInfoCurrencyAccountBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(UserInfoCurrencyAccountBody())) // not empty
	{
		_body.composeString(currency);
		_body.composeINT64(chips);
		_body.composeINT64(tChips);
	}

	_msg.composeMsgBody(_body);
}

void regulator::cli::UserInfoCurrencyAccountBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(currency);
	_parser0.parseINT64(chips);
	_parser0.parseINT64(tChips);
}

/*static*/ void regulator::cli::UserInfoCurrencyAccountBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT64 chips; _parser0.parseINT64(chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	INT64 tChips; _parser0.parseINT64(tChips);
	AtfValidator::validateInt(_descr, "tChips", tChips, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    UserInfoCommonBody
//=================================================================

regulator::cli::UserInfoCommonBody::UserInfoCommonBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::UserInfoCommonBody::UserInfoCommonBody(UserInfoCommonBody&& _o)
	: userOptions(std::move(_o.userOptions))
	, flags(std::move(_o.flags))
	, flags2(std::move(_o.flags2))
	, privileges(std::move(_o.privileges))
	, privileges2(std::move(_o.privileges2))
	, registered(std::move(_o.registered))
	, firstDeposit(std::move(_o.firstDeposit))
	, privileges3(std::move(_o.privileges3))
	, userWebId(std::move(_o.userWebId))
	, licenseId(std::move(_o.licenseId))
	, country(std::move(_o.country))
	, locale(std::move(_o.locale))
	, balances(std::move(_o.balances))
	, userId(std::move(_o.userId))
	, fppAmountCents(std::move(_o.fppAmountCents))
	, playChips(std::move(_o.playChips))
	, imageId(std::move(_o.imageId))
	, email(std::move(_o.email))
	, phone(std::move(_o.phone))
	, mobile(std::move(_o.mobile))
	, sex(std::move(_o.sex))
	, addr1(std::move(_o.addr1))
	, addr2(std::move(_o.addr2))
	, city(std::move(_o.city))
	, state(std::move(_o.state))
	, zipCode(std::move(_o.zipCode))
	, timezone(std::move(_o.timezone))
	, firstName(std::move(_o.firstName))
	, lastName(std::move(_o.lastName))
	, fullName(std::move(_o.fullName))
	, flags3(std::move(_o.flags3))
	, userProperies(std::move(_o.userProperies))
	, emLocale(std::move(_o.emLocale))
{
}

regulator::cli::UserInfoCommonBody& regulator::cli::UserInfoCommonBody::operator=(UserInfoCommonBody&& _o)
{
	if(this != &_o)
	{
		userOptions = std::move(_o.userOptions);
		flags = std::move(_o.flags);
		flags2 = std::move(_o.flags2);
		privileges = std::move(_o.privileges);
		privileges2 = std::move(_o.privileges2);
		registered = std::move(_o.registered);
		firstDeposit = std::move(_o.firstDeposit);
		privileges3 = std::move(_o.privileges3);
		userWebId = std::move(_o.userWebId);
		licenseId = std::move(_o.licenseId);
		country = std::move(_o.country);
		locale = std::move(_o.locale);
		balances = std::move(_o.balances);
		userId = std::move(_o.userId);
		fppAmountCents = std::move(_o.fppAmountCents);
		playChips = std::move(_o.playChips);
		imageId = std::move(_o.imageId);
		email = std::move(_o.email);
		phone = std::move(_o.phone);
		mobile = std::move(_o.mobile);
		sex = std::move(_o.sex);
		addr1 = std::move(_o.addr1);
		addr2 = std::move(_o.addr2);
		city = std::move(_o.city);
		state = std::move(_o.state);
		zipCode = std::move(_o.zipCode);
		timezone = std::move(_o.timezone);
		firstName = std::move(_o.firstName);
		lastName = std::move(_o.lastName);
		fullName = std::move(_o.fullName);
		flags3 = std::move(_o.flags3);
		userProperies = std::move(_o.userProperies);
		emLocale = std::move(_o.emLocale);
	}
	return *this;
}

#endif

void regulator::cli::UserInfoCommonBody::clear()
{
	userOptions = 0;
	flags = 0;
	flags2 = 0;
	privileges = 0;
	privileges2 = 0;
	registered.setNull();
	firstDeposit.setNull();
	privileges3 = 0;
	userWebId.clear();
	licenseId = 0;
	country.clear();
	locale = 0;
	balances.clear();
	userId.clear();
	fppAmountCents = 0;
	playChips = 0;
	imageId = 0;
	email.clear();
	phone.clear();
	mobile.clear();
	sex.clear();
	addr1.clear();
	addr2.clear();
	city.clear();
	state.clear();
	zipCode.clear();
	timezone = 0;
	firstName.clear();
	lastName.clear();
	fullName.clear();
	flags3 = 0;
	userProperies.clear();
	emLocale = 0;
}

bool regulator::cli::UserInfoCommonBody::equals(const UserInfoCommonBody& _o) const
{
	return userOptions == _o.userOptions &&
		flags == _o.flags &&
		flags2 == _o.flags2 &&
		privileges == _o.privileges &&
		privileges2 == _o.privileges2 &&
		registered.equals(_o.registered) &&
		firstDeposit.equals(_o.firstDeposit) &&
		privileges3 == _o.privileges3 &&
		userWebId.equals(_o.userWebId) &&
		licenseId == _o.licenseId &&
		country.equals(_o.country) &&
		locale == _o.locale &&
		balances.equals(_o.balances) &&
		userId.equals(_o.userId) &&
		fppAmountCents == _o.fppAmountCents &&
		playChips == _o.playChips &&
		imageId == _o.imageId &&
		email.equals(_o.email) &&
		phone.equals(_o.phone) &&
		mobile.equals(_o.mobile) &&
		sex.equals(_o.sex) &&
		addr1.equals(_o.addr1) &&
		addr2.equals(_o.addr2) &&
		city.equals(_o.city) &&
		state.equals(_o.state) &&
		zipCode.equals(_o.zipCode) &&
		timezone == _o.timezone &&
		firstName.equals(_o.firstName) &&
		lastName.equals(_o.lastName) &&
		fullName.equals(_o.fullName) &&
		flags3 == _o.flags3 &&
		userProperies.equals(_o.userProperies) &&
		emLocale == _o.emLocale;
}

const char *regulator::cli::UserInfoCommonBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userOptions=");
	_buf.appendUint(userOptions);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("flags2=");
	_buf.appendUint64(flags2);
	_buf.append(',');
	_buf.append("privileges=");
	_buf.appendUint(privileges);
	_buf.append(',');
	_buf.append("privileges2=");
	_buf.appendUint64(privileges2);
	_buf.append(',');
	_buf.append("registered=");
	ThinAtf::AtfTempl<CommSrvTime>::ToTraceString(_buf, registered);
	_buf.append(',');
	_buf.append("firstDeposit=");
	ThinAtf::AtfTempl<CommSrvTime>::ToTraceString(_buf, firstDeposit);
	_buf.append(',');
	_buf.append("privileges3=");
	_buf.appendUint64(privileges3);
	_buf.append(',');
	_buf.append("userWebId=");
	_buf.append(userWebId);
	_buf.append(',');
	_buf.append("licenseId=");
	_buf.appendInt(licenseId);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendInt(locale);
	_buf.append(',');
	_buf.append("balances=");
	balances.toTraceString(_buf);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("fppAmountCents=");
	_buf.appendInt64(fppAmountCents);
	_buf.append(',');
	_buf.append("playChips=");
	_buf.appendInt64(playChips);
	_buf.append(',');
	_buf.append("imageId=");
	_buf.appendUint(imageId);
	_buf.append(',');
	_buf.append("email=");
	_buf.append(email);
	_buf.append(',');
	_buf.append("phone=");
	_buf.append(phone);
	_buf.append(',');
	_buf.append("mobile=");
	_buf.append(mobile);
	_buf.append(',');
	_buf.append("sex=");
	_buf.append(sex);
	_buf.append(',');
	_buf.append("addr1=");
	_buf.append(addr1);
	_buf.append(',');
	_buf.append("addr2=");
	_buf.append(addr2);
	_buf.append(',');
	_buf.append("city=");
	_buf.append(city);
	_buf.append(',');
	_buf.append("state=");
	_buf.append(state);
	_buf.append(',');
	_buf.append("zipCode=");
	_buf.append(zipCode);
	_buf.append(',');
	_buf.append("timezone=");
	_buf.appendUint(timezone);
	_buf.append(',');
	_buf.append("firstName=");
	_buf.append(firstName);
	_buf.append(',');
	_buf.append("lastName=");
	_buf.append(lastName);
	_buf.append(',');
	_buf.append("fullName=");
	_buf.append(fullName);
	_buf.append(',');
	_buf.append("flags3=");
	_buf.appendUint64(flags3);
	_buf.append(',');
	_buf.append("userProperies=");
	userProperies.toTraceString(_buf);
	_buf.append(',');
	_buf.append("emLocale=");
	_buf.appendInt(emLocale);
	_buf.append('}');
	return _buf.c_str();
}

void regulator::cli::UserInfoCommonBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(UserInfoCommonBody())) // not empty
	{
		_body.composeUINT32(userOptions);
		_body.composeUINT32(flags);
		_body.composeUINT64(flags2);
		_body.composeUINT32(privileges);
		_body.composeUINT64(privileges2);
		_body.composeSrvTime(registered);
		_body.composeSrvTime(firstDeposit);
		_body.composeUINT64(privileges3);
		_body.composeString(userWebId);
		_body.composeINT32(licenseId);
		_body.composeString(country);
		_body.composeINT32(locale);
		balances.composeMsg(_body);
		_body.composeString(userId);
		_body.composeINT64(fppAmountCents);
		_body.composeINT64(playChips);
		_body.composeUINT32(imageId);
		_body.composeString(email);
		_body.composeString(phone);
		_body.composeString(mobile);
		_body.composeString(sex);
		_body.composeString(addr1);
		_body.composeString(addr2);
		_body.composeString(city);
		_body.composeString(state);
		_body.composeString(zipCode);
		_body.composeUINT32(timezone);
		_body.composeString(firstName);
		_body.composeString(lastName);
		_body.composeString(fullName);
		_body.composeUINT64(flags3);
		userProperies.composeMsg(_body);
		_body.composeINT32(emLocale);
	}

	_msg.composeMsgBody(_body);
}

void regulator::cli::UserInfoCommonBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(userOptions);
	_parser0.parseUINT32(flags);
	_parser0.parseUINT64(flags2);
	_parser0.parseUINT32(privileges);
	_parser0.parseUINT64(privileges2);
	_parser0.parseSrvTime(registered);
	_parser0.parseSrvTime(firstDeposit);
	_parser0.parseUINT64(privileges3);
	_parser0.parseStringP(userWebId);
	_parser0.parseINT32(licenseId);
	_parser0.parseStringP(country);
	_parser0.parseINT32(locale);
	balances.parseMsg(_parser0);
	_parser0.parseStringP(userId);
	_parser0.parseINT64(fppAmountCents);
	_parser0.parseINT64(playChips);
	_parser0.parseUINT32(imageId);
	_parser0.parseStringP(email);
	_parser0.parseStringP(phone);
	_parser0.parseStringP(mobile);
	_parser0.parseStringP(sex);
	_parser0.parseStringP(addr1);
	_parser0.parseStringP(addr2);
	_parser0.parseStringP(city);
	_parser0.parseStringP(state);
	_parser0.parseStringP(zipCode);
	_parser0.parseUINT32(timezone);
	_parser0.parseStringP(firstName);
	_parser0.parseStringP(lastName);
	_parser0.parseStringP(fullName);
	_parser0.parseUINT64(flags3);
	userProperies.parseMsg(_parser0);
	_parser0.parseINT32(emLocale);
}

/*static*/ void regulator::cli::UserInfoCommonBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 userOptions; _parser0.parseUINT32(userOptions);
	AtfValidator::validateInt(_descr, "userOptions", userOptions, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser0.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT64 flags2; _parser0.parseUINT64(flags2);
	AtfValidator::validateUint(_descr, "flags2", flags2, _checker, __FILE__, __LINE__);
	UINT32 privileges; _parser0.parseUINT32(privileges);
	AtfValidator::validateInt(_descr, "privileges", privileges, _checker, __FILE__, __LINE__);
	UINT64 privileges2; _parser0.parseUINT64(privileges2);
	AtfValidator::validateUint(_descr, "privileges2", privileges2, _checker, __FILE__, __LINE__);
	CommSrvTime registered; _parser0.parseSrvTime(registered);
	AtfValidator::validateSrvDateTime(_descr, "registered", registered, _checker, __FILE__, __LINE__);
	CommSrvTime firstDeposit; _parser0.parseSrvTime(firstDeposit);
	AtfValidator::validateSrvDateTime(_descr, "firstDeposit", firstDeposit, _checker, __FILE__, __LINE__);
	UINT64 privileges3; _parser0.parseUINT64(privileges3);
	AtfValidator::validateUint(_descr, "privileges3", privileges3, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "userWebId"); size_t szUserWebId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userWebId", szUserWebId, _checker, __FILE__, __LINE__);
	INT32 licenseId; _parser0.parseINT32(licenseId);
	AtfValidator::validateInt(_descr, "licenseId", licenseId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	INT32 locale; _parser0.parseINT32(locale);
	AtfValidator::validateInt(_descr, "locale", locale, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szBalances = ThinAtf::LAtfVector< UserInfoCurrencyAccountBody, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("balances"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "balances", szBalances, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	INT64 fppAmountCents; _parser0.parseINT64(fppAmountCents);
	AtfValidator::validateInt(_descr, "fppAmountCents", fppAmountCents, _checker, __FILE__, __LINE__);
	INT64 playChips; _parser0.parseINT64(playChips);
	AtfValidator::validateInt(_descr, "playChips", playChips, _checker, __FILE__, __LINE__);
	UINT32 imageId; _parser0.parseUINT32(imageId);
	AtfValidator::validateInt(_descr, "imageId", imageId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
	AtfValidator::validateInt(_descr, "email", szEmail, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "phone"); size_t szPhone = strlen(_dummy);
	AtfValidator::validateInt(_descr, "phone", szPhone, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "mobile"); size_t szMobile = strlen(_dummy);
	AtfValidator::validateInt(_descr, "mobile", szMobile, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "sex"); size_t szSex = strlen(_dummy);
	AtfValidator::validateInt(_descr, "sex", szSex, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "addr1"); size_t szAddr1 = strlen(_dummy);
	AtfValidator::validateInt(_descr, "addr1", szAddr1, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "addr2"); size_t szAddr2 = strlen(_dummy);
	AtfValidator::validateInt(_descr, "addr2", szAddr2, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
	AtfValidator::validateInt(_descr, "city", szCity, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "state"); size_t szState = strlen(_dummy);
	AtfValidator::validateInt(_descr, "state", szState, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "zipCode"); size_t szZipCode = strlen(_dummy);
	AtfValidator::validateInt(_descr, "zipCode", szZipCode, _checker, __FILE__, __LINE__);
	UINT32 timezone; _parser0.parseUINT32(timezone);
	AtfValidator::validateInt(_descr, "timezone", timezone, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "firstName"); size_t szFirstName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "firstName", szFirstName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "lastName"); size_t szLastName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "lastName", szLastName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "fullName"); size_t szFullName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "fullName", szFullName, _checker, __FILE__, __LINE__);
	UINT64 flags3; _parser0.parseUINT64(flags3);
	AtfValidator::validateUint(_descr, "flags3", flags3, _checker, __FILE__, __LINE__);
	int szUserProperies = ThinAtf::LAtfVector< CommonThin::AtfShared::UserPropertyBody, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("userProperies"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "userProperies", szUserProperies, _checker, __FILE__, __LINE__);
	INT32 emLocale; _parser0.parseINT32(emLocale);
	AtfValidator::validateInt(_descr, "emLocale", emLocale, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    UserInfoRegulatorAction
//=================================================================

regulator::cli::UserInfoRegulatorAction::UserInfoRegulatorAction()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::UserInfoRegulatorAction::UserInfoRegulatorAction(UserInfoRegulatorAction&& _o)
	: actionRequest(std::move(_o.actionRequest))
	, specificBody(std::move(_o.specificBody))
{
}

regulator::cli::UserInfoRegulatorAction& regulator::cli::UserInfoRegulatorAction::operator=(UserInfoRegulatorAction&& _o)
{
	if(this != &_o)
	{
		actionRequest = std::move(_o.actionRequest);
		specificBody = std::move(_o.specificBody);
	}
	return *this;
}

#endif

void regulator::cli::UserInfoRegulatorAction::clear()
{
	actionRequest = 0;
	specificBody.clear();
}

bool regulator::cli::UserInfoRegulatorAction::equals(const UserInfoRegulatorAction& _o) const
{
	return actionRequest == _o.actionRequest &&
		specificBody.equals(_o.specificBody);
}

const char *regulator::cli::UserInfoRegulatorAction::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("actionRequest=");
	_buf.appendUint(actionRequest);
	_buf.append(',');
	_buf.append("specificBody=");
	specificBody.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void regulator::cli::UserInfoRegulatorAction::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(actionRequest);
	_msg.composeMsgBody(specificBody);
}

void regulator::cli::UserInfoRegulatorAction::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(actionRequest);
	_parser.parseMsgBody(specificBody);
}

/*static*/ void regulator::cli::UserInfoRegulatorAction::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 actionRequest; _parser.parseUINT32(actionRequest);
	AtfValidator::validateInt(_descr, "actionRequest", actionRequest, _checker, __FILE__, __LINE__);
	size_t szSpecificBody; _parser.skipMsgBody(szSpecificBody);  /*specificBody*/
	AtfValidator::validateInt(_descr, "specificBody", szSpecificBody, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    UserInfoRegulatorNotification
//=================================================================

regulator::cli::UserInfoRegulatorNotification::UserInfoRegulatorNotification()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::UserInfoRegulatorNotification::UserInfoRegulatorNotification(UserInfoRegulatorNotification&& _o)
	: notificationType(std::move(_o.notificationType))
	, specificBody(std::move(_o.specificBody))
{
}

regulator::cli::UserInfoRegulatorNotification& regulator::cli::UserInfoRegulatorNotification::operator=(UserInfoRegulatorNotification&& _o)
{
	if(this != &_o)
	{
		notificationType = std::move(_o.notificationType);
		specificBody = std::move(_o.specificBody);
	}
	return *this;
}

#endif

void regulator::cli::UserInfoRegulatorNotification::clear()
{
	notificationType = 0;
	specificBody.clear();
}

bool regulator::cli::UserInfoRegulatorNotification::equals(const UserInfoRegulatorNotification& _o) const
{
	return notificationType == _o.notificationType &&
		specificBody.equals(_o.specificBody);
}

const char *regulator::cli::UserInfoRegulatorNotification::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("notificationType=");
	_buf.appendUint(notificationType);
	_buf.append(',');
	_buf.append("specificBody=");
	specificBody.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void regulator::cli::UserInfoRegulatorNotification::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(notificationType);
	_msg.composeMsgBody(specificBody);
}

void regulator::cli::UserInfoRegulatorNotification::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(notificationType);
	_parser.parseMsgBody(specificBody);
}

/*static*/ void regulator::cli::UserInfoRegulatorNotification::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 notificationType; _parser.parseUINT32(notificationType);
	AtfValidator::validateInt(_descr, "notificationType", notificationType, _checker, __FILE__, __LINE__);
	size_t szSpecificBody; _parser.skipMsgBody(szSpecificBody);  /*specificBody*/
	AtfValidator::validateInt(_descr, "specificBody", szSpecificBody, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY::Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY::Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY(Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, commonBody(std::move(_o.commonBody))
	, regulatorActions(std::move(_o.regulatorActions))
	, regulatorNotifications(std::move(_o.regulatorNotifications))
{
}

regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY& regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY::operator=(Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		commonBody = std::move(_o.commonBody);
		regulatorActions = std::move(_o.regulatorActions);
		regulatorNotifications = std::move(_o.regulatorNotifications);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	commonBody.clear();
	regulatorActions.clear();
	regulatorNotifications.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY::equals(const Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		commonBody.equals(_o.commonBody) &&
		regulatorActions.equals(_o.regulatorActions) &&
		regulatorNotifications.equals(_o.regulatorNotifications);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_USER_GET_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("commonBody=");
		commonBody.toTraceString(_buf);
		_buf.append(',');
		_buf.append("regulatorActions=");
		regulatorActions.toTraceString(_buf);
		_buf.append(',');
		_buf.append("regulatorNotifications=");
		regulatorNotifications.toTraceString(_buf);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		commonBody.composeMsg(_msg);
		regulatorActions.composeMsg(_msg);
		CommMsgBody _msg0;
		regulatorNotifications.composeMsg(_msg0);
		_msg.composeMsgBody(_msg0);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		commonBody.parseMsg(_parser);
		regulatorActions.parseMsg(_parser);
		parseAnonymousMsgBody0(_parser);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_USER_GET_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		UserInfoCommonBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("commonBody"), _fieldsWithUnparsedContent);
		int szRegulatorActions = ThinAtf::LAtfVector< UserInfoRegulatorAction, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("regulatorActions"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "regulatorActions", szRegulatorActions, _checker, __FILE__, __LINE__);
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	regulatorNotifications.parseMsg(_parser0);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szRegulatorNotifications = ThinAtf::LAtfVector< UserInfoRegulatorNotification, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("regulatorNotifications"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "regulatorNotifications", szRegulatorNotifications, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS(Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS&& _o)
	: clientVersionInfo(std::move(_o.clientVersionInfo))
{
}

regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS& regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS::operator=(Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS&& _o)
{
	if(this != &_o)
	{
		clientVersionInfo = std::move(_o.clientVersionInfo);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS::clear()
{
	clientVersionInfo.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS::equals(const Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS& _o) const
{
	return clientVersionInfo.equals(_o.clientVersionInfo);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS).append(")");
	_buf.append(',');
	_buf.append("clientVersionInfo=");
	_buf.append(clientVersionInfo);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(clientVersionInfo);
}

void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(clientVersionInfo);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "clientVersionInfo"); size_t szClientVersionInfo = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "clientVersionInfo", szClientVersionInfo, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY(Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, commonBody(std::move(_o.commonBody))
	, regulatorActions_alwaysEmpty(std::move(_o.regulatorActions_alwaysEmpty))
	, regulatorNotifications_alwaysEmpty(std::move(_o.regulatorNotifications_alwaysEmpty))
{
}

regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY& regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY::operator=(Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		commonBody = std::move(_o.commonBody);
		regulatorActions_alwaysEmpty = std::move(_o.regulatorActions_alwaysEmpty);
		regulatorNotifications_alwaysEmpty = std::move(_o.regulatorNotifications_alwaysEmpty);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	commonBody.clear();
	regulatorActions_alwaysEmpty.clear();
	regulatorNotifications_alwaysEmpty.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY::equals(const Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		commonBody.equals(_o.commonBody) &&
		regulatorActions_alwaysEmpty.equals(_o.regulatorActions_alwaysEmpty) &&
		regulatorNotifications_alwaysEmpty.equals(_o.regulatorNotifications_alwaysEmpty);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("commonBody=");
		commonBody.toTraceString(_buf);
		_buf.append(',');
		_buf.append("regulatorActions_alwaysEmpty=");
		regulatorActions_alwaysEmpty.toTraceString(_buf);
		_buf.append(',');
		_buf.append("regulatorNotifications_alwaysEmpty=");
		regulatorNotifications_alwaysEmpty.toTraceString(_buf);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		commonBody.composeMsg(_msg);
		regulatorActions_alwaysEmpty.composeMsg(_msg);
		CommMsgBody _msg0;
		regulatorNotifications_alwaysEmpty.composeMsg(_msg0);
		_msg.composeMsgBody(_msg0);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		commonBody.parseMsg(_parser);
		regulatorActions_alwaysEmpty.parseMsg(_parser);
		parseAnonymousMsgBody0(_parser);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		UserInfoCommonBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("commonBody"), _fieldsWithUnparsedContent);
		int szRegulatorActions_alwaysEmpty = ThinAtf::LAtfVector< UserInfoRegulatorAction, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("regulatorActions_alwaysEmpty"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "regulatorActions_alwaysEmpty", szRegulatorActions_alwaysEmpty, _checker, __FILE__, __LINE__);
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	regulatorNotifications_alwaysEmpty.parseMsg(_parser0);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szRegulatorNotifications_alwaysEmpty = ThinAtf::LAtfVector< UserInfoRegulatorNotification, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("regulatorNotifications_alwaysEmpty"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "regulatorNotifications_alwaysEmpty", szRegulatorNotifications_alwaysEmpty, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_REGULATOR_MIGRATION_GET_INFO
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO::clear()
{
}

bool regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO::equals(const Protocol_MSG_REGULATOR_MIGRATION_GET_INFO& _o) const
{
	return true;
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_MIGRATION_GET_INFO).append(")");
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO::composeMsg(CommMsgBody& _msg) const
{
}

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_MIGRATION_GET_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_MIGRATION_GET_INFO_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO_REPLY::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO_REPLY::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO_REPLY(Protocol_MSG_REGULATOR_MIGRATION_GET_INFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO_REPLY& regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO_REPLY::operator=(Protocol_MSG_REGULATOR_MIGRATION_GET_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO_REPLY::equals(const Protocol_MSG_REGULATOR_MIGRATION_GET_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_MIGRATION_GET_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_MIGRATION_GET_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_MIGRATION_PERFORM
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM::Protocol_MSG_REGULATOR_MIGRATION_PERFORM()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM::clear()
{
	migrFlags = 0;
	migrSiteId = 0;
}

bool regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM::equals(const Protocol_MSG_REGULATOR_MIGRATION_PERFORM& _o) const
{
	return migrFlags == _o.migrFlags &&
		migrSiteId == _o.migrSiteId;
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_MIGRATION_PERFORM).append(")");
	_buf.append(',');
	_buf.append("migrFlags=");
	_buf.appendUint(migrFlags);
	_buf.append(',');
	_buf.append("migrSiteId=");
	_buf.appendUint(migrSiteId);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(migrFlags);
	_msg.composeUINT32(migrSiteId);
}

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(migrFlags);
	_parser.parseUINT32(migrSiteId);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_MIGRATION_PERFORM";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 migrFlags; _parser.parseUINT32(migrFlags);
	AtfValidator::validateIntMax(_descr, "migrFlags", migrFlags, ((UINT32(eMigrationFlagLast)<<1)-UINT32(1)), _checker, __FILE__, __LINE__);
	UINT32 migrSiteId; _parser.parseUINT32(migrSiteId);
	AtfValidator::validateIntRange(_descr, "migrSiteId", migrSiteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_MIGRATION_PERFORM_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM_REPLY::Protocol_MSG_REGULATOR_MIGRATION_PERFORM_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM_REPLY::Protocol_MSG_REGULATOR_MIGRATION_PERFORM_REPLY(Protocol_MSG_REGULATOR_MIGRATION_PERFORM_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM_REPLY& regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM_REPLY::operator=(Protocol_MSG_REGULATOR_MIGRATION_PERFORM_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM_REPLY::equals(const Protocol_MSG_REGULATOR_MIGRATION_PERFORM_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_MIGRATION_PERFORM_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errDescr=");
	_buf.append(errDescr);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errDescr);
}

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(errDescr);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_MIGRATION_PERFORM_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY::clear()
{
	migrFlags = 0;
	migrSiteId = 0;
}

bool regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY::equals(const Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY& _o) const
{
	return migrFlags == _o.migrFlags &&
		migrSiteId == _o.migrSiteId;
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_MIGRATION_CHECK_ONLY).append(")");
	_buf.append(',');
	_buf.append("migrFlags=");
	_buf.appendUint(migrFlags);
	_buf.append(',');
	_buf.append("migrSiteId=");
	_buf.appendUint(migrSiteId);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(migrFlags);
	_msg.composeUINT32(migrSiteId);
}

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(migrFlags);
	_parser.parseUINT32(migrSiteId);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_MIGRATION_CHECK_ONLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 migrFlags; _parser.parseUINT32(migrFlags);
	AtfValidator::validateIntMax(_descr, "migrFlags", migrFlags, ((UINT32(eMigrationCheckFlagLast)<<1)-UINT32(1)), _checker, __FILE__, __LINE__);
	UINT32 migrSiteId; _parser.parseUINT32(migrSiteId);
	AtfValidator::validateIntRange(_descr, "migrSiteId", migrSiteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    RegulatorMigrCheckOnlyReplyStruct
//=================================================================

regulator::cli::RegulatorMigrCheckOnlyReplyStruct::RegulatorMigrCheckOnlyReplyStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::RegulatorMigrCheckOnlyReplyStruct::RegulatorMigrCheckOnlyReplyStruct(RegulatorMigrCheckOnlyReplyStruct&& _o)
	: targetLicenceId(std::move(_o.targetLicenceId))
	, migrToken(std::move(_o.migrToken))
{
}

regulator::cli::RegulatorMigrCheckOnlyReplyStruct& regulator::cli::RegulatorMigrCheckOnlyReplyStruct::operator=(RegulatorMigrCheckOnlyReplyStruct&& _o)
{
	if(this != &_o)
	{
		targetLicenceId = std::move(_o.targetLicenceId);
		migrToken = std::move(_o.migrToken);
	}
	return *this;
}

#endif

void regulator::cli::RegulatorMigrCheckOnlyReplyStruct::clear()
{
	targetLicenceId = 0;
	migrToken.clear();
}

bool regulator::cli::RegulatorMigrCheckOnlyReplyStruct::equals(const RegulatorMigrCheckOnlyReplyStruct& _o) const
{
	return targetLicenceId == _o.targetLicenceId &&
		migrToken.equals(_o.migrToken);
}

const char *regulator::cli::RegulatorMigrCheckOnlyReplyStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("targetLicenceId=");
	_buf.appendUint(targetLicenceId);
	if (targetLicenceId == eLicenceCH)
	{
		_buf.append(',');
		_buf.append("migrToken=");
		_buf.append(migrToken);
	}
	_buf.append('}');
	return _buf.c_str();
}

void regulator::cli::RegulatorMigrCheckOnlyReplyStruct::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(targetLicenceId);
	if (targetLicenceId == eLicenceCH)
	{
		CommMsgBody _msg0;
		_msg0.composeString(migrToken);
		_msg.composeMsgBody(_msg0);
	}
}

void regulator::cli::RegulatorMigrCheckOnlyReplyStruct::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(targetLicenceId);
	if (targetLicenceId == eLicenceCH)
	{
		parseAnonymousMsgBody0(_parser);
	}
}

/*static*/ void regulator::cli::RegulatorMigrCheckOnlyReplyStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 targetLicenceId = 0;
	_parser.parseUINT32(targetLicenceId);
	{ const UINT32 targetLicenceId_enum[] = {
				eLicenceCH, 
			}; AtfValidator::validateEnum(_descr, "targetLicenceId", targetLicenceId, targetLicenceId_enum, _checker, __FILE__, __LINE__); }
	if (targetLicenceId == eLicenceCH)
	{
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
}

void regulator::cli::RegulatorMigrCheckOnlyReplyStruct::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(migrToken);
}

/*static*/ void regulator::cli::RegulatorMigrCheckOnlyReplyStruct::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "migrToken"); size_t szMigrToken = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "migrToken", szMigrToken, 24, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY(Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, replyStruct(std::move(_o.replyStruct))
{
}

regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY& regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY::operator=(Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		replyStruct = std::move(_o.replyStruct);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	replyStruct.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY::equals(const Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		replyStruct.equals(_o.replyStruct);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("replyStruct=");
		replyStruct.toTraceString(_buf);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		replyStruct.composeMsg(_msg);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		replyStruct.parseMsg(_parser);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		RegulatorMigrCheckOnlyReplyStruct::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("replyStruct"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR::clear()
{
}

bool regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR::equals(const Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR& _o) const
{
	return true;
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR).append(")");
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR::composeMsg(CommMsgBody& _msg) const
{
}

void regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY(Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY& regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY::operator=(Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY::equals(const Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED::clear()
{
	mailList = false;
	useMailList = false;
}

bool regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED::equals(const Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED& _o) const
{
	return mailList == _o.mailList &&
		useMailList == _o.useMailList;
}

const char *regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_EULA_TERMS_SIGNED).append(")");
	_buf.append(',');
	_buf.append("mailList=");
	_buf.appendUint(mailList);
	_buf.append(',');
	_buf.append("useMailList=");
	_buf.appendUint(useMailList);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBOOL(mailList);
	_msg.composeBOOL(useMailList);
}

void regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(mailList);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(useMailList);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_EULA_TERMS_SIGNED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(_parser.parseEnded()) return;
	bool mailList; _parser.parseBOOL(mailList);
	AtfValidator::validateInt(_descr, "mailList", mailList, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool useMailList; _parser.parseBOOL(useMailList);
	AtfValidator::validateInt(_descr, "useMailList", useMailList, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY(Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY& regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY::operator=(Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY::equals(const Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT
//=================================================================

regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT(Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT&& _o)
	: bankName(std::move(_o.bankName))
	, accountNumberDecrypted(std::move(_o.accountNumberDecrypted))
	, bankCountry(std::move(_o.bankCountry))
{
}

regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT& regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::operator=(Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT&& _o)
{
	if(this != &_o)
	{
		bankName = std::move(_o.bankName);
		accountNumberDecrypted = std::move(_o.accountNumberDecrypted);
		bankCountry = std::move(_o.bankCountry);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::clear()
{
	bankName.clear();
	accountNumberDecrypted.clear();
	bankCountry.clear();
}

bool regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::equals(const Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT& _o) const
{
	return bankName.equals(_o.bankName) &&
		accountNumberDecrypted.equals(_o.accountNumberDecrypted) &&
		bankCountry.equals(_o.bankCountry);
}

const char *regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_RMF_BANKACCOUNT).append(")");
	_buf.append(',');
	_buf.append("bankName=");
	_buf.append(bankName);
	_buf.append(',');
	_buf.append("accountNumberDecrypted=");
	_buf.append(accountNumberDecrypted);
	_buf.append(',');
	_buf.append("bankCountry=");
	_buf.append(bankCountry);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(bankName);
	_msg.composeString(accountNumberDecrypted);
	_msg.composeString(bankCountry);
}

void regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(bankName);
	_parser.parseStringP(accountNumberDecrypted);
	_parser.parseStringP(bankCountry);
}

/*static*/ void regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_RMF_BANKACCOUNT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "bankName"); size_t szBankName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bankName", szBankName, 1000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "accountNumberDecrypted"); size_t szAccountNumberDecrypted = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "accountNumberDecrypted", szAccountNumberDecrypted, 1000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "bankCountry"); size_t szBankCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "bankCountry", szBankCountry, 100, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY
//=================================================================

regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY(Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, reference(std::move(_o.reference))
	, isValid(std::move(_o.isValid))
	, realMoneyOk(std::move(_o.realMoneyOk))
	, accountNumberDecrypted(std::move(_o.accountNumberDecrypted))
{
}

regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY& regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::operator=(Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		reference = std::move(_o.reference);
		isValid = std::move(_o.isValid);
		realMoneyOk = std::move(_o.realMoneyOk);
		accountNumberDecrypted = std::move(_o.accountNumberDecrypted);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	reference.clear();
	isValid = false;
	realMoneyOk = 0;
	accountNumberDecrypted.clear();
}

bool regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::equals(const Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		reference.equals(_o.reference) &&
		isValid == _o.isValid &&
		realMoneyOk == _o.realMoneyOk &&
		accountNumberDecrypted.equals(_o.accountNumberDecrypted);
}

const char *regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("reference=");
		_buf.append(reference);
		_buf.append(',');
		_buf.append("isValid=");
		_buf.appendUint(isValid);
		_buf.append(',');
		_buf.append("realMoneyOk=");
		_buf.appendUint(realMoneyOk);
		_buf.append(',');
		_buf.append("accountNumberDecrypted=");
		_buf.append(accountNumberDecrypted);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(reference);
		_msg.composeBOOL(isValid);
		CommMsgBody _msg0;
		_msg0.composeBYTE(realMoneyOk);
		_msg0.composeString(accountNumberDecrypted);
		_msg.composeMsgBody(_msg0);
	}
}

void regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(reference);
		_parser.parseBOOL(isValid);
		parseAnonymousMsgBody0(_parser);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "reference"); size_t szReference = strlen(_dummy);
		AtfValidator::validateInt(_descr, "reference", szReference, _checker, __FILE__, __LINE__);
		bool isValid; _parser.parseBOOL(isValid);
		AtfValidator::validateInt(_descr, "isValid", isValid, _checker, __FILE__, __LINE__);
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(realMoneyOk);
	_parser0.parseStringP(accountNumberDecrypted);
}

/*static*/ void regulator::cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	BYTE realMoneyOk; _parser0.parseBYTE(realMoneyOk);
	AtfValidator::validateIntRange(_descr, "realMoneyOk", realMoneyOk, 0, 1, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "accountNumberDecrypted"); size_t szAccountNumberDecrypted = strlen(_dummy);
	AtfValidator::validateInt(_descr, "accountNumberDecrypted", szAccountNumberDecrypted, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS::clear()
{
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS::equals(const Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS& _o) const
{
	return true;
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_LAST_LOGIN_DETAILS).append(")");
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS::composeMsg(CommMsgBody& _msg) const
{
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_LAST_LOGIN_DETAILS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    LoginDetailsClientTournBody
//=================================================================

regulator::cli::LoginDetailsClientTournBody::LoginDetailsClientTournBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::LoginDetailsClientTournBody::LoginDetailsClientTournBody(LoginDetailsClientTournBody&& _o)
	: tournId(std::move(_o.tournId))
	, tournName(std::move(_o.tournName))
	, isPublished(std::move(_o.isPublished))
{
}

regulator::cli::LoginDetailsClientTournBody& regulator::cli::LoginDetailsClientTournBody::operator=(LoginDetailsClientTournBody&& _o)
{
	if(this != &_o)
	{
		tournId = std::move(_o.tournId);
		tournName = std::move(_o.tournName);
		isPublished = std::move(_o.isPublished);
	}
	return *this;
}

#endif

void regulator::cli::LoginDetailsClientTournBody::clear()
{
	tournId = 0;
	tournName.clear();
	isPublished = false;
}

bool regulator::cli::LoginDetailsClientTournBody::equals(const LoginDetailsClientTournBody& _o) const
{
	return tournId == _o.tournId &&
		tournName.equals(_o.tournName) &&
		isPublished == _o.isPublished;
}

const char *regulator::cli::LoginDetailsClientTournBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("tournName=");
	_buf.append(tournName);
	_buf.append(',');
	_buf.append("isPublished=");
	_buf.appendUint(isPublished);
	_buf.append('}');
	return _buf.c_str();
}

void regulator::cli::LoginDetailsClientTournBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(LoginDetailsClientTournBody())) // not empty
	{
		_body.composeUINT32(tournId);
		_body.composeString(tournName);
		_body.composeBOOL(isPublished);
	}

	_msg.composeMsgBody(_body);
}

void regulator::cli::LoginDetailsClientTournBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(tournId);
	_parser0.parseStringP(tournName);
	_parser0.parseBOOL(isPublished);
}

/*static*/ void regulator::cli::LoginDetailsClientTournBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 tournId; _parser0.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "tournName"); size_t szTournName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tournName", szTournName, _checker, __FILE__, __LINE__);
	bool isPublished; _parser0.parseBOOL(isPublished);
	AtfValidator::validateInt(_descr, "isPublished", isPublished, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    LoginDetailsBody
//=================================================================

regulator::cli::LoginDetailsBody::LoginDetailsBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::LoginDetailsBody::LoginDetailsBody(LoginDetailsBody&& _o)
	: lastLogoutIp(std::move(_o.lastLogoutIp))
{
}

regulator::cli::LoginDetailsBody& regulator::cli::LoginDetailsBody::operator=(LoginDetailsBody&& _o)
{
	if(this != &_o)
	{
		lastLogoutIp = std::move(_o.lastLogoutIp);
	}
	return *this;
}

#endif

void regulator::cli::LoginDetailsBody::clear()
{
	lastLogoutIp.clear();
}

bool regulator::cli::LoginDetailsBody::equals(const LoginDetailsBody& _o) const
{
	return lastLogoutIp.equals(_o.lastLogoutIp);
}

const char *regulator::cli::LoginDetailsBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("lastLogoutIp=");
	_buf.append(lastLogoutIp);
	_buf.append('}');
	return _buf.c_str();
}

void regulator::cli::LoginDetailsBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(LoginDetailsBody())) // not empty
	{
		_body.composeString(lastLogoutIp);
	}

	_msg.composeMsgBody(_body);
}

void regulator::cli::LoginDetailsBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(lastLogoutIp);
}

/*static*/ void regulator::cli::LoginDetailsBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "lastLogoutIp"); size_t szLastLogoutIp = strlen(_dummy);
	AtfValidator::validateInt(_descr, "lastLogoutIp", szLastLogoutIp, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY(Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, lastLoginTime(std::move(_o.lastLoginTime))
	, loginDetails(std::move(_o.loginDetails))
	, isFirstLoginSession(std::move(_o.isFirstLoginSession))
{
}

regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY& regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY::operator=(Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		lastLoginTime = std::move(_o.lastLoginTime);
		loginDetails = std::move(_o.loginDetails);
		isFirstLoginSession = std::move(_o.isFirstLoginSession);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	lastLoginTime.setNull();
	loginDetails.clear();
	isFirstLoginSession = false;
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY::equals(const Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		lastLoginTime.equals(_o.lastLoginTime) &&
		loginDetails.equals(_o.loginDetails) &&
		isFirstLoginSession == _o.isFirstLoginSession;
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("lastLoginTime=");
		ThinAtf::AtfTempl<CommSrvTime>::ToTraceString(_buf, lastLoginTime);
		_buf.append(',');
		_buf.append("loginDetails=");
		loginDetails.toTraceString(_buf);
		_buf.append(',');
		_buf.append("isFirstLoginSession=");
		_buf.appendUint(isFirstLoginSession);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeSrvTime(lastLoginTime);
		loginDetails.composeMsg(_msg);
		_msg.composeBOOL(isFirstLoginSession);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseSrvTime(lastLoginTime);
		loginDetails.parseMsg(_parser);
		_parser.parseBOOL(isFirstLoginSession);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		CommSrvTime lastLoginTime; _parser.parseSrvTime(lastLoginTime);
		AtfValidator::validateSrvDateTime(_descr, "lastLoginTime", lastLoginTime, _checker, __FILE__, __LINE__);
		PString _descbuf;
		LoginDetailsBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("loginDetails"), _fieldsWithUnparsedContent);
		bool isFirstLoginSession; _parser.parseBOOL(isFirstLoginSession);
		AtfValidator::validateInt(_descr, "isFirstLoginSession", isFirstLoginSession, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_USER_WINNINGS
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS::Protocol_MSG_REGULATOR_GET_USER_WINNINGS()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS::clear()
{
	loginTime.setNull();
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS::equals(const Protocol_MSG_REGULATOR_GET_USER_WINNINGS& _o) const
{
	return loginTime.equals(_o.loginTime);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_USER_WINNINGS).append(")");
	_buf.append(',');
	_buf.append("loginTime=");
	ThinAtf::AtfTempl<CommSrvTime>::ToTraceString(_buf, loginTime);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeSrvTime(loginTime);
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseSrvTime(loginTime);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_USER_WINNINGS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	CommSrvTime loginTime; _parser.parseSrvTime(loginTime);
	AtfValidator::validateSrvDateTime(_descr, "loginTime", loginTime, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_USER_WINNINGS_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS_REPLY::Protocol_MSG_REGULATOR_GET_USER_WINNINGS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS_REPLY::Protocol_MSG_REGULATOR_GET_USER_WINNINGS_REPLY(Protocol_MSG_REGULATOR_GET_USER_WINNINGS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, totalPlayed(std::move(_o.totalPlayed))
	, totalWon(std::move(_o.totalWon))
{
}

regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS_REPLY& regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS_REPLY::operator=(Protocol_MSG_REGULATOR_GET_USER_WINNINGS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		totalPlayed = std::move(_o.totalPlayed);
		totalWon = std::move(_o.totalWon);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	totalPlayed = 0;
	totalWon = 0;
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS_REPLY::equals(const Protocol_MSG_REGULATOR_GET_USER_WINNINGS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		totalPlayed == _o.totalPlayed &&
		totalWon == _o.totalWon;
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_USER_WINNINGS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("totalPlayed=");
		_buf.appendInt64(totalPlayed);
		_buf.append(',');
		_buf.append("totalWon=");
		_buf.appendInt64(totalWon);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT64(totalPlayed);
		_msg.composeINT64(totalWon);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT64(totalPlayed);
		_parser.parseINT64(totalWon);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_USER_WINNINGS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT64 totalPlayed; _parser.parseINT64(totalPlayed);
		AtfValidator::validateInt(_descr, "totalPlayed", totalPlayed, _checker, __FILE__, __LINE__);
		INT64 totalWon; _parser.parseINT64(totalWon);
		AtfValidator::validateInt(_descr, "totalWon", totalWon, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::clear()
{
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::equals(const Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE& _o) const
{
	return true;
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_FACEBOOK_LINK_CODE).append(")");
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::composeMsg(CommMsgBody& _msg) const
{
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_FACEBOOK_LINK_CODE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY(Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, facebookLinkCode(std::move(_o.facebookLinkCode))
{
}

regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY& regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::operator=(Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		facebookLinkCode = std::move(_o.facebookLinkCode);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	facebookLinkCode = 0;
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::equals(const Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		facebookLinkCode == _o.facebookLinkCode;
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("facebookLinkCode=");
		_buf.appendUint(facebookLinkCode);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(facebookLinkCode);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(facebookLinkCode);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 facebookLinkCode; _parser.parseUINT32(facebookLinkCode);
		AtfValidator::validateInt(_descr, "facebookLinkCode", facebookLinkCode, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE::clear()
{
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE::equals(const Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE& _o) const
{
	return true;
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_FTP_PAIRING_CODE).append(")");
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE::composeMsg(CommMsgBody& _msg) const
{
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_FTP_PAIRING_CODE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY(Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY& regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY::operator=(Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY::equals(const Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY
//=================================================================

regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY(Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY&& _o)
	: userIdNotUsed(std::move(_o.userIdNotUsed))
{
}

regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY& regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::operator=(Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY&& _o)
{
	if(this != &_o)
	{
		userIdNotUsed = std::move(_o.userIdNotUsed);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::clear()
{
	userIdNotUsed.clear();
}

bool regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::equals(const Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY& _o) const
{
	return userIdNotUsed.equals(_o.userIdNotUsed);
}

const char *regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SUPPORT_EMAIL_READY).append(")");
	_buf.append(',');
	_buf.append("userIdNotUsed=");
	_buf.append(userIdNotUsed);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userIdNotUsed);
}

void regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseStringP(userIdNotUsed);
}

/*static*/ void regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SUPPORT_EMAIL_READY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "userIdNotUsed"); size_t szUserIdNotUsed = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userIdNotUsed", szUserIdNotUsed, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY
//=================================================================

regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY(Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY& regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::operator=(Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::equals(const Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL
//=================================================================

regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL(Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL&& _o)
	: body(std::move(_o.body))
{
}

regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL& regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::operator=(Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL&& _o)
{
	if(this != &_o)
	{
		body = std::move(_o.body);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::clear()
{
	body.clear();
}

bool regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::equals(const Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL& _o) const
{
	return body.equals(_o.body);
}

const char *regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL).append(")");
	_buf.append(',');
	_buf.append("body=");
	body.toTraceString(_buf);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::composeMsg(CommMsgBody& _msg) const
{
	body.composeMsg(_msg);
}

void regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::parseMsg(CommMsgParser& _parser)
{
	body.parseMsg(_parser);
}

/*static*/ void regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	common_structs::LobbyClientToSupportEmailStruct::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("body"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY
//=================================================================

regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY(Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY&& _o)
	: replyBody(std::move(_o.replyBody))
{
}

regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY& regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::operator=(Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY&& _o)
{
	if(this != &_o)
	{
		replyBody = std::move(_o.replyBody);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::clear()
{
	replyBody.clear();
}

bool regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::equals(const Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY& _o) const
{
	return replyBody.equals(_o.replyBody);
}

const char *regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY).append(")");
	_buf.append(',');
	_buf.append("replyBody=");
	replyBody.toTraceString(_buf);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::composeMsg(CommMsgBody& _msg) const
{
	replyBody.composeMsg(_msg);
}

void regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::parseMsg(CommMsgParser& _parser)
{
	replyBody.parseMsg(_parser);
}

/*static*/ void regulator::cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	common_structs::LobbyClientToSupportEmailReplyStruct::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("replyBody"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    NjDepositLimitActionBody
//=================================================================

regulator::cli::NjDepositLimitActionBody::NjDepositLimitActionBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::NjDepositLimitActionBody::NjDepositLimitActionBody(NjDepositLimitActionBody&& _o)
	: limitType(std::move(_o.limitType))
	, limitId(std::move(_o.limitId))
	, isApprove(std::move(_o.isApprove))
	, prevLimit(std::move(_o.prevLimit))
	, limit(std::move(_o.limit))
	, currency(std::move(_o.currency))
{
}

regulator::cli::NjDepositLimitActionBody& regulator::cli::NjDepositLimitActionBody::operator=(NjDepositLimitActionBody&& _o)
{
	if(this != &_o)
	{
		limitType = std::move(_o.limitType);
		limitId = std::move(_o.limitId);
		isApprove = std::move(_o.isApprove);
		prevLimit = std::move(_o.prevLimit);
		limit = std::move(_o.limit);
		currency = std::move(_o.currency);
	}
	return *this;
}

#endif

void regulator::cli::NjDepositLimitActionBody::clear()
{
	limitType = 0;
	limitId = 0;
	isApprove = false;
	prevLimit = 0;
	limit = 0;
	currency.clear();
}

bool regulator::cli::NjDepositLimitActionBody::equals(const NjDepositLimitActionBody& _o) const
{
	return limitType == _o.limitType &&
		limitId == _o.limitId &&
		isApprove == _o.isApprove &&
		prevLimit == _o.prevLimit &&
		limit == _o.limit &&
		currency.equals(_o.currency);
}

const char *regulator::cli::NjDepositLimitActionBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("limitType=");
	_buf.appendUint(limitType);
	_buf.append(',');
	_buf.append("limitId=");
	_buf.appendUint(limitId);
	_buf.append(',');
	_buf.append("isApprove=");
	_buf.appendUint(isApprove);
	_buf.append(',');
	_buf.append("prevLimit=");
	_buf.appendInt(prevLimit);
	_buf.append(',');
	_buf.append("limit=");
	_buf.appendInt(limit);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append('}');
	return _buf.c_str();
}

void regulator::cli::NjDepositLimitActionBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(NjDepositLimitActionBody())) // not empty
	{
		_body.composeUINT32(limitType);
		_body.composeUINT32(limitId);
		_body.composeBOOL(isApprove);
		_body.composeINT32(prevLimit);
		_body.composeINT32(limit);
		_body.composeString(currency);
	}

	_msg.composeMsgBody(_body);
}

void regulator::cli::NjDepositLimitActionBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(limitType);
	_parser0.parseUINT32(limitId);
	_parser0.parseBOOL(isApprove);
	_parser0.parseINT32(prevLimit);
	_parser0.parseINT32(limit);
	_parser0.parseStringP(currency);
}

/*static*/ void regulator::cli::NjDepositLimitActionBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 limitType; _parser0.parseUINT32(limitType);
	{ const UINT32 limitType_enum[] = {eDailyDepositLimit, eWeeklyDepositLimit, eMonthlyDepositLimit}; AtfValidator::validateEnum(_descr, "limitType", limitType, limitType_enum, _checker, __FILE__, __LINE__); }
	UINT32 limitId; _parser0.parseUINT32(limitId);
	AtfValidator::validateInt(_descr, "limitId", limitId, _checker, __FILE__, __LINE__);
	bool isApprove; _parser0.parseBOOL(isApprove);
	AtfValidator::validateInt(_descr, "isApprove", isApprove, _checker, __FILE__, __LINE__);
	INT32 prevLimit; _parser0.parseINT32(prevLimit);
	AtfValidator::validateIntRange(_descr, "prevLimit", prevLimit, -1, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	INT32 limit; _parser0.parseINT32(limit);
	AtfValidator::validateIntRange(_descr, "limit", limit, -1, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    NjGameLimitActionBody
//=================================================================

regulator::cli::NjGameLimitActionBody::NjGameLimitActionBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::NjGameLimitActionBody::NjGameLimitActionBody(NjGameLimitActionBody&& _o)
	: limitType(std::move(_o.limitType))
	, limitId(std::move(_o.limitId))
	, isApprove(std::move(_o.isApprove))
	, prevLimit(std::move(_o.prevLimit))
	, limit(std::move(_o.limit))
	, currency(std::move(_o.currency))
{
}

regulator::cli::NjGameLimitActionBody& regulator::cli::NjGameLimitActionBody::operator=(NjGameLimitActionBody&& _o)
{
	if(this != &_o)
	{
		limitType = std::move(_o.limitType);
		limitId = std::move(_o.limitId);
		isApprove = std::move(_o.isApprove);
		prevLimit = std::move(_o.prevLimit);
		limit = std::move(_o.limit);
		currency = std::move(_o.currency);
	}
	return *this;
}

#endif

void regulator::cli::NjGameLimitActionBody::clear()
{
	limitType = 0;
	limitId = 0;
	isApprove = false;
	prevLimit = 0;
	limit = 0;
	currency.clear();
}

bool regulator::cli::NjGameLimitActionBody::equals(const NjGameLimitActionBody& _o) const
{
	return limitType == _o.limitType &&
		limitId == _o.limitId &&
		isApprove == _o.isApprove &&
		prevLimit == _o.prevLimit &&
		limit == _o.limit &&
		currency.equals(_o.currency);
}

const char *regulator::cli::NjGameLimitActionBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("limitType=");
	_buf.appendUint(limitType);
	_buf.append(',');
	_buf.append("limitId=");
	_buf.appendUint(limitId);
	_buf.append(',');
	_buf.append("isApprove=");
	_buf.appendUint(isApprove);
	_buf.append(',');
	_buf.append("prevLimit=");
	_buf.appendInt(prevLimit);
	_buf.append(',');
	_buf.append("limit=");
	_buf.appendInt(limit);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append('}');
	return _buf.c_str();
}

void regulator::cli::NjGameLimitActionBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(NjGameLimitActionBody())) // not empty
	{
		_body.composeUINT32(limitType);
		_body.composeUINT32(limitId);
		_body.composeBOOL(isApprove);
		_body.composeINT32(prevLimit);
		_body.composeINT32(limit);
		_body.composeString(currency);
	}

	_msg.composeMsgBody(_body);
}

void regulator::cli::NjGameLimitActionBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(limitType);
	_parser0.parseUINT32(limitId);
	_parser0.parseBOOL(isApprove);
	_parser0.parseINT32(prevLimit);
	_parser0.parseINT32(limit);
	_parser0.parseStringP(currency);
}

/*static*/ void regulator::cli::NjGameLimitActionBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 limitType; _parser0.parseUINT32(limitType);
	AtfValidator::validateIntRange(_descr, "limitType", limitType, eTableLimitTypeAny, (numLimitTypes-1), _checker, __FILE__, __LINE__);
	UINT32 limitId; _parser0.parseUINT32(limitId);
	AtfValidator::validateInt(_descr, "limitId", limitId, _checker, __FILE__, __LINE__);
	bool isApprove; _parser0.parseBOOL(isApprove);
	AtfValidator::validateInt(_descr, "isApprove", isApprove, _checker, __FILE__, __LINE__);
	INT32 prevLimit; _parser0.parseINT32(prevLimit);
	AtfValidator::validateIntRange(_descr, "prevLimit", prevLimit, -1, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	INT32 limit; _parser0.parseINT32(limit);
	AtfValidator::validateIntRange(_descr, "limit", limit, -1, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    UserDepositLimitsBody
//=================================================================

regulator::cli::UserDepositLimitsBody::UserDepositLimitsBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::UserDepositLimitsBody::UserDepositLimitsBody(UserDepositLimitsBody&& _o)
	: limits(std::move(_o.limits))
{
}

regulator::cli::UserDepositLimitsBody& regulator::cli::UserDepositLimitsBody::operator=(UserDepositLimitsBody&& _o)
{
	if(this != &_o)
	{
		limits = std::move(_o.limits);
	}
	return *this;
}

#endif

void regulator::cli::UserDepositLimitsBody::clear()
{
	limits.clear();
}

bool regulator::cli::UserDepositLimitsBody::equals(const UserDepositLimitsBody& _o) const
{
	return limits.equals(_o.limits);
}

const char *regulator::cli::UserDepositLimitsBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("limits=");
	limits.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void regulator::cli::UserDepositLimitsBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(UserDepositLimitsBody())) // not empty
	{
		limits.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void regulator::cli::UserDepositLimitsBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	if(_parser0.parseEnded()) return;
	limits.parseMsg(_parser0);
}

/*static*/ void regulator::cli::UserDepositLimitsBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.parseEnded()) return;
	PString _descbuf;
	int szLimits = ThinAtf::LAtfVector< NjDepositLimitActionBody, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("limits"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "limits", szLimits, 1000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    UserGameLimitsBody
//=================================================================

regulator::cli::UserGameLimitsBody::UserGameLimitsBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::UserGameLimitsBody::UserGameLimitsBody(UserGameLimitsBody&& _o)
	: limits(std::move(_o.limits))
{
}

regulator::cli::UserGameLimitsBody& regulator::cli::UserGameLimitsBody::operator=(UserGameLimitsBody&& _o)
{
	if(this != &_o)
	{
		limits = std::move(_o.limits);
	}
	return *this;
}

#endif

void regulator::cli::UserGameLimitsBody::clear()
{
	limits.clear();
}

bool regulator::cli::UserGameLimitsBody::equals(const UserGameLimitsBody& _o) const
{
	return limits.equals(_o.limits);
}

const char *regulator::cli::UserGameLimitsBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("limits=");
	limits.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void regulator::cli::UserGameLimitsBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(UserGameLimitsBody())) // not empty
	{
		limits.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void regulator::cli::UserGameLimitsBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	if(_parser0.parseEnded()) return;
	limits.parseMsg(_parser0);
}

/*static*/ void regulator::cli::UserGameLimitsBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.parseEnded()) return;
	PString _descbuf;
	int szLimits = ThinAtf::LAtfVector< NjGameLimitActionBody, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("limits"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "limits", szLimits, 1000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS(Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS&& _o)
	: depositLimits(std::move(_o.depositLimits))
	, gameLimits(std::move(_o.gameLimits))
{
}

regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS& regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS::operator=(Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS&& _o)
{
	if(this != &_o)
	{
		depositLimits = std::move(_o.depositLimits);
		gameLimits = std::move(_o.gameLimits);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS::clear()
{
	depositLimits.clear();
	gameLimits.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS::equals(const Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS& _o) const
{
	return depositLimits.equals(_o.depositLimits) &&
		gameLimits.equals(_o.gameLimits);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CONFIRMED_USER_LIMITS).append(")");
	_buf.append(',');
	_buf.append("depositLimits=");
	depositLimits.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameLimits=");
	gameLimits.toTraceString(_buf);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS::composeMsg(CommMsgBody& _msg) const
{
	depositLimits.composeMsg(_msg);
	gameLimits.composeMsg(_msg);
}

void regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS::parseMsg(CommMsgParser& _parser)
{
	depositLimits.parseMsg(_parser);
	gameLimits.parseMsg(_parser);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CONFIRMED_USER_LIMITS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	UserDepositLimitsBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("depositLimits"), _fieldsWithUnparsedContent);
	UserGameLimitsBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("gameLimits"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    UserDepositLimitsResultBody
//=================================================================

regulator::cli::UserDepositLimitsResultBody::UserDepositLimitsResultBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::UserDepositLimitsResultBody::UserDepositLimitsResultBody(UserDepositLimitsResultBody&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, limits(std::move(_o.limits))
{
}

regulator::cli::UserDepositLimitsResultBody& regulator::cli::UserDepositLimitsResultBody::operator=(UserDepositLimitsResultBody&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		limits = std::move(_o.limits);
	}
	return *this;
}

#endif

void regulator::cli::UserDepositLimitsResultBody::clear()
{
	errCode = 0;
	errDescr.clear();
	limits.clear();
}

bool regulator::cli::UserDepositLimitsResultBody::equals(const UserDepositLimitsResultBody& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		limits.equals(_o.limits);
}

const char *regulator::cli::UserDepositLimitsResultBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("limits=");
		limits.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void regulator::cli::UserDepositLimitsResultBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(UserDepositLimitsResultBody())) // not empty
	{
		_body.composeINT16(errCode);
		if (errCode)
		{
			_body.composeString(errDescr);
		}
		else
		{
			limits.composeMsg(_body);
		}
	}

	_msg.composeMsgBody(_body);
}

void regulator::cli::UserDepositLimitsResultBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT16(errCode);
	if (errCode)
	{
		_parser0.parseStringP(errDescr);
	}
	else
	{
		limits.parseMsg(_parser0);
	}
}

/*static*/ void regulator::cli::UserDepositLimitsResultBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	INT16 errCode = 0;
	_parser0.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser0.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		UserDepositLimitsBody::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("limits"), _fieldsWithUnparsedContent);
	}
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    UserGameLimitsResultBody
//=================================================================

regulator::cli::UserGameLimitsResultBody::UserGameLimitsResultBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::UserGameLimitsResultBody::UserGameLimitsResultBody(UserGameLimitsResultBody&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, limits(std::move(_o.limits))
{
}

regulator::cli::UserGameLimitsResultBody& regulator::cli::UserGameLimitsResultBody::operator=(UserGameLimitsResultBody&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		limits = std::move(_o.limits);
	}
	return *this;
}

#endif

void regulator::cli::UserGameLimitsResultBody::clear()
{
	errCode = 0;
	errDescr.clear();
	limits.clear();
}

bool regulator::cli::UserGameLimitsResultBody::equals(const UserGameLimitsResultBody& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		limits.equals(_o.limits);
}

const char *regulator::cli::UserGameLimitsResultBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("limits=");
		limits.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void regulator::cli::UserGameLimitsResultBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(UserGameLimitsResultBody())) // not empty
	{
		_body.composeINT16(errCode);
		if (errCode)
		{
			_body.composeString(errDescr);
		}
		else
		{
			limits.composeMsg(_body);
		}
	}

	_msg.composeMsgBody(_body);
}

void regulator::cli::UserGameLimitsResultBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT16(errCode);
	if (errCode)
	{
		_parser0.parseStringP(errDescr);
	}
	else
	{
		limits.parseMsg(_parser0);
	}
}

/*static*/ void regulator::cli::UserGameLimitsResultBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	INT16 errCode = 0;
	_parser0.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser0.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		UserGameLimitsBody::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("limits"), _fieldsWithUnparsedContent);
	}
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY(Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY&& _o)
	: depositLimits(std::move(_o.depositLimits))
	, gameLimits(std::move(_o.gameLimits))
{
}

regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY& regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY::operator=(Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY&& _o)
{
	if(this != &_o)
	{
		depositLimits = std::move(_o.depositLimits);
		gameLimits = std::move(_o.gameLimits);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY::clear()
{
	depositLimits.clear();
	gameLimits.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY::equals(const Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY& _o) const
{
	return depositLimits.equals(_o.depositLimits) &&
		gameLimits.equals(_o.gameLimits);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY).append(")");
	_buf.append(',');
	_buf.append("depositLimits=");
	depositLimits.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameLimits=");
	gameLimits.toTraceString(_buf);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	depositLimits.composeMsg(_msg);
	gameLimits.composeMsg(_msg);
}

void regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY::parseMsg(CommMsgParser& _parser)
{
	depositLimits.parseMsg(_parser);
	gameLimits.parseMsg(_parser);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	UserDepositLimitsResultBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("depositLimits"), _fieldsWithUnparsedContent);
	UserGameLimitsResultBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("gameLimits"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CHALLENGE_QUESTION
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION::clear()
{
	locale = 0;
}

bool regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION::equals(const Protocol_MSG_REGULATOR_CHALLENGE_QUESTION& _o) const
{
	return locale == _o.locale;
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CHALLENGE_QUESTION).append(")");
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(locale);
}

void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(locale);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CHALLENGE_QUESTION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_REPLY::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_REPLY::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_REPLY(Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, challengeQuestions(std::move(_o.challengeQuestions))
{
}

regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_REPLY& regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_REPLY::operator=(Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		challengeQuestions = std::move(_o.challengeQuestions);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	challengeQuestions.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_REPLY::equals(const Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		challengeQuestions.equals(_o.challengeQuestions);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CHALLENGE_QUESTION_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("challengeQuestions=");
		challengeQuestions.toTraceString(_buf);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		challengeQuestions.composeMsg(_msg);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		challengeQuestions.parseMsg(_parser);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CHALLENGE_QUESTION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szChallengeQuestions = ThinAtf::LAtfVector< common_structs::ChallengeQuestion, 2 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("challengeQuestions"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "challengeQuestions", szChallengeQuestions, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED
//=================================================================

regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED()
{
	clear();
}

void regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED::clear()
{
}

bool regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED::equals(const Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED& _o) const
{
	return true;
}

const char *regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED).append(")");
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED::composeMsg(CommMsgBody& _msg) const
{
}

void regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY
//=================================================================

regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY(Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY& regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY::operator=(Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY::equals(const Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER::clear()
{
}

bool regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER::equals(const Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER& _o) const
{
	return true;
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CLIENT_FTPLAUNCHER).append(")");
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER::composeMsg(CommMsgBody& _msg) const
{
}

void regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CLIENT_FTPLAUNCHER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY(Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY& regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY::operator=(Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY::equals(const Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SET_PROMO_CODE
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE::Protocol_MSG_REGULATOR_SET_PROMO_CODE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE::Protocol_MSG_REGULATOR_SET_PROMO_CODE(Protocol_MSG_REGULATOR_SET_PROMO_CODE&& _o)
	: promoCode(std::move(_o.promoCode))
{
}

regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE& regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE::operator=(Protocol_MSG_REGULATOR_SET_PROMO_CODE&& _o)
{
	if(this != &_o)
	{
		promoCode = std::move(_o.promoCode);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE::clear()
{
	promoCode.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE::equals(const Protocol_MSG_REGULATOR_SET_PROMO_CODE& _o) const
{
	return promoCode.equals(_o.promoCode);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SET_PROMO_CODE).append(")");
	_buf.append(',');
	_buf.append("promoCode=");
	_buf.append(promoCode);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(promoCode);
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(promoCode);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_PROMO_CODE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "promoCode"); size_t szPromoCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "promoCode", szPromoCode, 10000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SET_PROMO_CODE_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE_REPLY::Protocol_MSG_REGULATOR_SET_PROMO_CODE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE_REPLY::Protocol_MSG_REGULATOR_SET_PROMO_CODE_REPLY(Protocol_MSG_REGULATOR_SET_PROMO_CODE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE_REPLY& regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE_REPLY::operator=(Protocol_MSG_REGULATOR_SET_PROMO_CODE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE_REPLY::equals(const Protocol_MSG_REGULATOR_SET_PROMO_CODE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SET_PROMO_CODE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_PROMO_CODE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SET_PWD_REMINDER
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER::Protocol_MSG_REGULATOR_SET_PWD_REMINDER()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER::clear()
{
	remind = false;
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER::equals(const Protocol_MSG_REGULATOR_SET_PWD_REMINDER& _o) const
{
	return remind == _o.remind;
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SET_PWD_REMINDER).append(")");
	_buf.append(',');
	_buf.append("remind=");
	_buf.appendUint(remind);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBOOL(remind);
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(remind);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_PWD_REMINDER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	bool remind; _parser.parseBOOL(remind);
	AtfValidator::validateInt(_descr, "remind", remind, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SET_PWD_REMINDER_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER_REPLY::Protocol_MSG_REGULATOR_SET_PWD_REMINDER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER_REPLY::Protocol_MSG_REGULATOR_SET_PWD_REMINDER_REPLY(Protocol_MSG_REGULATOR_SET_PWD_REMINDER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER_REPLY& regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER_REPLY::operator=(Protocol_MSG_REGULATOR_SET_PWD_REMINDER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER_REPLY::equals(const Protocol_MSG_REGULATOR_SET_PWD_REMINDER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SET_PWD_REMINDER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_PWD_REMINDER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS(Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS&& _o)
	: answers(std::move(_o.answers))
{
}

regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS& regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS::operator=(Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS&& _o)
{
	if(this != &_o)
	{
		answers = std::move(_o.answers);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS::clear()
{
	answers.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS::equals(const Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS& _o) const
{
	return answers.equals(_o.answers);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS).append(")");
	_buf.append(',');
	_buf.append("answers=");
	answers.toTraceString(_buf);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS::composeMsg(CommMsgBody& _msg) const
{
	answers.composeMsg(_msg);
}

void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS::parseMsg(CommMsgParser& _parser)
{
	answers.parseMsg(_parser);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szAnswers = ThinAtf::LAtfVector< common_structs::ChallengeAnswer, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("answers"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntRange(_descr, "answers", szAnswers, CHALLENGE_ANSWERS_SIZE, CHALLENGE_ANSWERS_SIZE, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY(Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, match(std::move(_o.match))
	, allowMoreAttempts(std::move(_o.allowMoreAttempts))
{
}

regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY& regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY::operator=(Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		match = std::move(_o.match);
		allowMoreAttempts = std::move(_o.allowMoreAttempts);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	match = false;
	allowMoreAttempts = false;
}

bool regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY::equals(const Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		match == _o.match &&
		allowMoreAttempts == _o.allowMoreAttempts;
}

const char *regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("match=");
		_buf.appendUint(match);
		_buf.append(',');
		_buf.append("allowMoreAttempts=");
		_buf.appendUint(allowMoreAttempts);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeBOOL(match);
		_msg.composeBOOL(allowMoreAttempts);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseBOOL(match);
		_parser.parseBOOL(allowMoreAttempts);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool match; _parser.parseBOOL(match);
		AtfValidator::validateInt(_descr, "match", match, _checker, __FILE__, __LINE__);
		bool allowMoreAttempts; _parser.parseBOOL(allowMoreAttempts);
		AtfValidator::validateInt(_descr, "allowMoreAttempts", allowMoreAttempts, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS::clear()
{
}

bool regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS::equals(const Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS& _o) const
{
	return true;
}

const char *regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS).append(")");
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS::composeMsg(CommMsgBody& _msg) const
{
}

void regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY(Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY& regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY::operator=(Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY::equals(const Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER::clear()
{
	remind = true;
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER::equals(const Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER& _o) const
{
	return remind == _o.remind;
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER).append(")");
	_buf.append(',');
	_buf.append("remind=");
	_buf.appendUint(remind);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBOOL(remind);
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(remind);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(_parser.parseEnded()) return;
	bool remind; _parser.parseBOOL(remind);
	AtfValidator::validateInt(_descr, "remind", remind, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY(Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY& regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY::operator=(Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY::equals(const Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED::clear()
{
}

bool regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED::equals(const Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED& _o) const
{
	return true;
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED).append(")");
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED::composeMsg(CommMsgBody& _msg) const
{
}

void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY(Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY& regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY::operator=(Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY::equals(const Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_MATCH_ZIP_CODE
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE(Protocol_MSG_REGULATOR_MATCH_ZIP_CODE&& _o)
	: streetNum(std::move(_o.streetNum))
	, zipCode(std::move(_o.zipCode))
	, countryCode(std::move(_o.countryCode))
{
}

regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE& regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE::operator=(Protocol_MSG_REGULATOR_MATCH_ZIP_CODE&& _o)
{
	if(this != &_o)
	{
		streetNum = std::move(_o.streetNum);
		zipCode = std::move(_o.zipCode);
		countryCode = std::move(_o.countryCode);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE::clear()
{
	streetNum.clear();
	zipCode.clear();
	countryCode.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE::equals(const Protocol_MSG_REGULATOR_MATCH_ZIP_CODE& _o) const
{
	return streetNum.equals(_o.streetNum) &&
		zipCode.equals(_o.zipCode) &&
		countryCode.equals(_o.countryCode);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_MATCH_ZIP_CODE).append(")");
	_buf.append(',');
	_buf.append("streetNum=");
	_buf.append(streetNum);
	_buf.append(',');
	_buf.append("zipCode=");
	_buf.append(zipCode);
	_buf.append(',');
	_buf.append("countryCode=");
	_buf.append(countryCode);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(streetNum);
	_msg.composeString(zipCode);
	_msg.composeString(countryCode);
}

void regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(streetNum);
	_parser.parseStringP(zipCode);
	_parser.parseStringP(countryCode);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_MATCH_ZIP_CODE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "streetNum"); size_t szStreetNum = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "streetNum", szStreetNum, USER_ADDR_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "zipCode"); size_t szZipCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "zipCode", szZipCode, USER_ZIP_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "countryCode"); size_t szCountryCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "countryCode", szCountryCode, COUNTRY_CODE_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    Address
//=================================================================

regulator::cli::Address::Address()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Address::Address(Address&& _o)
	: address(std::move(_o.address))
	, city(std::move(_o.city))
	, state(std::move(_o.state))
	, zip(std::move(_o.zip))
	, country(std::move(_o.country))
{
}

regulator::cli::Address& regulator::cli::Address::operator=(Address&& _o)
{
	if(this != &_o)
	{
		address = std::move(_o.address);
		city = std::move(_o.city);
		state = std::move(_o.state);
		zip = std::move(_o.zip);
		country = std::move(_o.country);
	}
	return *this;
}

#endif

void regulator::cli::Address::clear()
{
	address.clear();
	city.clear();
	state.clear();
	zip.clear();
	country.clear();
}

bool regulator::cli::Address::equals(const Address& _o) const
{
	return address.equals(_o.address) &&
		city.equals(_o.city) &&
		state.equals(_o.state) &&
		zip.equals(_o.zip) &&
		country.equals(_o.country);
}

const char *regulator::cli::Address::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("address=");
	_buf.append(address);
	_buf.append(',');
	_buf.append("city=");
	_buf.append(city);
	_buf.append(',');
	_buf.append("state=");
	_buf.append(state);
	_buf.append(',');
	_buf.append("zip=");
	_buf.append(zip);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append('}');
	return _buf.c_str();
}

void regulator::cli::Address::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(Address())) // not empty
	{
		_body.composeString(address);
		_body.composeString(city);
		_body.composeString(state);
		_body.composeString(zip);
		_body.composeString(country);
	}

	_msg.composeMsgBody(_body);
}

void regulator::cli::Address::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(address);
	_parser0.parseStringP(city);
	_parser0.parseStringP(state);
	_parser0.parseStringP(zip);
	_parser0.parseStringP(country);
}

/*static*/ void regulator::cli::Address::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "address"); size_t szAddress = strlen(_dummy);
	AtfValidator::validateInt(_descr, "address", szAddress, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
	AtfValidator::validateInt(_descr, "city", szCity, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "state"); size_t szState = strlen(_dummy);
	AtfValidator::validateInt(_descr, "state", szState, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "zip"); size_t szZip = strlen(_dummy);
	AtfValidator::validateInt(_descr, "zip", szZip, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_REGULATOR_MATCH_ZIP_CODE_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE_REPLY::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE_REPLY::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE_REPLY(Protocol_MSG_REGULATOR_MATCH_ZIP_CODE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, addresses(std::move(_o.addresses))
{
}

regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE_REPLY& regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE_REPLY::operator=(Protocol_MSG_REGULATOR_MATCH_ZIP_CODE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		addresses = std::move(_o.addresses);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	addresses.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE_REPLY::equals(const Protocol_MSG_REGULATOR_MATCH_ZIP_CODE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		addresses.equals(_o.addresses);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_MATCH_ZIP_CODE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("addresses=");
		addresses.toTraceString(_buf);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		addresses.composeMsg(_msg);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		addresses.parseMsg(_parser);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_MATCH_ZIP_CODE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szAddresses = ThinAtf::LAtfVector< Address, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("addresses"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "addresses", szAddresses, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG(Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG&& _o)
	: setNotRemove(std::move(_o.setNotRemove))
	, userId(std::move(_o.userId))
	, comment(std::move(_o.comment))
{
}

regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG& regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG::operator=(Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG&& _o)
{
	if(this != &_o)
	{
		setNotRemove = std::move(_o.setNotRemove);
		userId = std::move(_o.userId);
		comment = std::move(_o.comment);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG::clear()
{
	setNotRemove = false;
	userId.clear();
	comment.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG::equals(const Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG& _o) const
{
	return setNotRemove == _o.setNotRemove &&
		userId.equals(_o.userId) &&
		comment.equals(_o.comment);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG).append(")");
	_buf.append(',');
	_buf.append("setNotRemove=");
	_buf.appendUint(setNotRemove);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("comment=");
	_buf.append(comment);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBOOL(setNotRemove);
	_msg.composeString(userId);
	_msg.composeString(comment);
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(setNotRemove);
	_parser.parseStringP(userId);
	_parser.parseStringP(comment);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	bool setNotRemove; _parser.parseBOOL(setNotRemove);
	AtfValidator::validateInt(_descr, "setNotRemove", setNotRemove, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "comment"); size_t szComment = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "comment", szComment, USER_COMMENTS_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY(Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY& regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY::operator=(Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY::equals(const Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_RESET_PWD
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD::Protocol_MSG_REGULATOR_RESET_PWD()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD::Protocol_MSG_REGULATOR_RESET_PWD(Protocol_MSG_REGULATOR_RESET_PWD&& _o)
	: resetPwd(std::move(_o.resetPwd))
{
}

regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD& regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD::operator=(Protocol_MSG_REGULATOR_RESET_PWD&& _o)
{
	if(this != &_o)
	{
		resetPwd = std::move(_o.resetPwd);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD::clear()
{
	resetPwd.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD::equals(const Protocol_MSG_REGULATOR_RESET_PWD& _o) const
{
	return resetPwd.equals(_o.resetPwd);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_RESET_PWD).append(")");
	_buf.append(',');
	_buf.append("resetPwd=");
	resetPwd.toTraceString(_buf);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD::composeMsg(CommMsgBody& _msg) const
{
	resetPwd.composeMsg(_msg);
}

void regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD::parseMsg(CommMsgParser& _parser)
{
	resetPwd.parseMsg(_parser);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_RESET_PWD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	common_structs::ResetPwdMessageStruct::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("resetPwd"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_RESET_PWD_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::Protocol_MSG_REGULATOR_RESET_PWD_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::Protocol_MSG_REGULATOR_RESET_PWD_REPLY(Protocol_MSG_REGULATOR_RESET_PWD_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD_REPLY& regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::operator=(Protocol_MSG_REGULATOR_RESET_PWD_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::equals(const Protocol_MSG_REGULATOR_RESET_PWD_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_RESET_PWD_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_RESET_PWD_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_CONFIG_INFO
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO::Protocol_MSG_REGULATOR_GET_CONFIG_INFO()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO::clear()
{
	configInfoMask = 0;
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO::equals(const Protocol_MSG_REGULATOR_GET_CONFIG_INFO& _o) const
{
	return configInfoMask == _o.configInfoMask;
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_CONFIG_INFO).append(")");
	_buf.append(',');
	_buf.append("configInfoMask=");
	_buf.appendUint(configInfoMask);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(configInfoMask);
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(configInfoMask);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_CONFIG_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 configInfoMask; _parser.parseUINT32(configInfoMask);
	AtfValidator::validateIntMax(_descr, "configInfoMask", configInfoMask, 3, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    RegulatorConfigInfo
//=================================================================

regulator::cli::RegulatorConfigInfo::RegulatorConfigInfo()
{
	clear();
}

void regulator::cli::RegulatorConfigInfo::clear()
{
	configInfoType = 0;
	showAddressLookup = false;
	addressLookupRMFtypesMask = 0;
	deshMaxAgeVerifyAttempts = 0;
}

bool regulator::cli::RegulatorConfigInfo::equals(const RegulatorConfigInfo& _o) const
{
	return configInfoType == _o.configInfoType &&
		showAddressLookup == _o.showAddressLookup &&
		addressLookupRMFtypesMask == _o.addressLookupRMFtypesMask &&
		deshMaxAgeVerifyAttempts == _o.deshMaxAgeVerifyAttempts;
}

const char *regulator::cli::RegulatorConfigInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("configInfoType=");
	_buf.appendUint(configInfoType);
	if (configInfoType == eRegulatorConfigInfoType_AddressLookup)
	{
		_buf.append(',');
		_buf.append("showAddressLookup=");
		_buf.appendUint(showAddressLookup);
		_buf.append(',');
		_buf.append("addressLookupRMFtypesMask=");
		_buf.appendUint(addressLookupRMFtypesMask);
	}
	if (configInfoType == eRegulatorConfigInfoType_AgeVerifyAttempts)
	{
		_buf.append(',');
		_buf.append("deshMaxAgeVerifyAttempts=");
		_buf.appendInt(deshMaxAgeVerifyAttempts);
	}
	_buf.append('}');
	return _buf.c_str();
}

void regulator::cli::RegulatorConfigInfo::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(configInfoType);
	if (configInfoType == eRegulatorConfigInfoType_AddressLookup)
	{
		CommMsgBody _msg0;
		_msg0.composeBOOL(showAddressLookup);
		_msg0.composeUINT32(addressLookupRMFtypesMask);
		_msg.composeMsgBody(_msg0);
	}
	if (configInfoType == eRegulatorConfigInfoType_AgeVerifyAttempts)
	{
		CommMsgBody _msg1;
		_msg1.composeINT32(deshMaxAgeVerifyAttempts);
		_msg.composeMsgBody(_msg1);
	}
}

void regulator::cli::RegulatorConfigInfo::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(configInfoType);
	if (configInfoType == eRegulatorConfigInfoType_AddressLookup)
	{
		parseAnonymousMsgBody0(_parser);
	}
	if (configInfoType == eRegulatorConfigInfoType_AgeVerifyAttempts)
	{
		parseAnonymousMsgBody1(_parser);
	}
}

/*static*/ void regulator::cli::RegulatorConfigInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 configInfoType = 0;
	_parser.parseUINT32(configInfoType);
	AtfValidator::validateIntRange(_descr, "configInfoType", configInfoType, eRegulatorConfigInfoType_None, eRegulatorConfigInfoType_AgeVerifyAttempts, _checker, __FILE__, __LINE__);
	if (configInfoType == eRegulatorConfigInfoType_AddressLookup)
	{
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	if (configInfoType == eRegulatorConfigInfoType_AgeVerifyAttempts)
	{
		validateAnonymousMsgBody1(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
}

void regulator::cli::RegulatorConfigInfo::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(showAddressLookup);
	_parser0.parseUINT32(addressLookupRMFtypesMask);
}

/*static*/ void regulator::cli::RegulatorConfigInfo::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	bool showAddressLookup; _parser0.parseBOOL(showAddressLookup);
	AtfValidator::validateInt(_descr, "showAddressLookup", showAddressLookup, _checker, __FILE__, __LINE__);
	UINT32 addressLookupRMFtypesMask; _parser0.parseUINT32(addressLookupRMFtypesMask);
	AtfValidator::validateInt(_descr, "addressLookupRMFtypesMask", addressLookupRMFtypesMask, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void regulator::cli::RegulatorConfigInfo::parseAnonymousMsgBody1(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(deshMaxAgeVerifyAttempts);
}

/*static*/ void regulator::cli::RegulatorConfigInfo::validateAnonymousMsgBody1(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 deshMaxAgeVerifyAttempts; _parser0.parseINT32(deshMaxAgeVerifyAttempts);
	AtfValidator::validateInt(_descr, "deshMaxAgeVerifyAttempts", deshMaxAgeVerifyAttempts, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_CONFIG_INFO_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO_REPLY::Protocol_MSG_REGULATOR_GET_CONFIG_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO_REPLY::Protocol_MSG_REGULATOR_GET_CONFIG_INFO_REPLY(Protocol_MSG_REGULATOR_GET_CONFIG_INFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, configInfoData(std::move(_o.configInfoData))
{
}

regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO_REPLY& regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO_REPLY::operator=(Protocol_MSG_REGULATOR_GET_CONFIG_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		configInfoData = std::move(_o.configInfoData);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	configInfoData.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO_REPLY::equals(const Protocol_MSG_REGULATOR_GET_CONFIG_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		configInfoData.equals(_o.configInfoData);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_CONFIG_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("configInfoData=");
		configInfoData.toTraceString(_buf);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		configInfoData.composeMsg(_msg);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		configInfoData.parseMsg(_parser);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_CONFIG_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szConfigInfoData = ThinAtf::LAtfVector< RegulatorConfigInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("configInfoData"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "configInfoData", szConfigInfoData, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG(Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG&& _o)
	: setNotRemove(std::move(_o.setNotRemove))
	, userId(std::move(_o.userId))
	, comment(std::move(_o.comment))
{
}

regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG& regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG::operator=(Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG&& _o)
{
	if(this != &_o)
	{
		setNotRemove = std::move(_o.setNotRemove);
		userId = std::move(_o.userId);
		comment = std::move(_o.comment);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG::clear()
{
	setNotRemove = false;
	userId.clear();
	comment.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG::equals(const Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG& _o) const
{
	return setNotRemove == _o.setNotRemove &&
		userId.equals(_o.userId) &&
		comment.equals(_o.comment);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SET_RATE_MOBILE_FLAG).append(")");
	_buf.append(',');
	_buf.append("setNotRemove=");
	_buf.appendUint(setNotRemove);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("comment=");
	_buf.append(comment);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBOOL(setNotRemove);
	_msg.composeString(userId);
	_msg.composeString(comment);
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(setNotRemove);
	_parser.parseStringP(userId);
	_parser.parseStringP(comment);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_RATE_MOBILE_FLAG";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	bool setNotRemove; _parser.parseBOOL(setNotRemove);
	AtfValidator::validateInt(_descr, "setNotRemove", setNotRemove, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, 0, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "comment"); size_t szComment = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "comment", szComment, 0, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY(Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY& regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY::operator=(Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY::equals(const Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SAVE_CONSENT
//=================================================================

regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT::Protocol_MSG_LOBBY_SAVE_CONSENT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT::Protocol_MSG_LOBBY_SAVE_CONSENT(Protocol_MSG_LOBBY_SAVE_CONSENT&& _o)
	: userId(std::move(_o.userId))
	, consentId(std::move(_o.consentId))
	, status(std::move(_o.status))
{
}

regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT& regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT::operator=(Protocol_MSG_LOBBY_SAVE_CONSENT&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		consentId = std::move(_o.consentId);
		status = std::move(_o.status);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT::clear()
{
	userId.clear();
	consentId = 0;
	status = 0;
}

bool regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT::equals(const Protocol_MSG_LOBBY_SAVE_CONSENT& _o) const
{
	return userId.equals(_o.userId) &&
		consentId == _o.consentId &&
		status == _o.status;
}

const char *regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SAVE_CONSENT).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("consentId=");
	_buf.appendUint(consentId);
	_buf.append(',');
	_buf.append("status=");
	_buf.appendUint(status);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeUINT32(consentId);
	_msg.composeUINT32(status);
}

void regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseUINT32(consentId);
	_parser.parseUINT32(status);
}

/*static*/ void regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SAVE_CONSENT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT32 consentId; _parser.parseUINT32(consentId);
	AtfValidator::validateInt(_descr, "consentId", consentId, _checker, __FILE__, __LINE__);
	UINT32 status; _parser.parseUINT32(status);
	AtfValidator::validateIntRange(_descr, "status", status, 1, 2, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SAVE_CONSENT_REPLY
//=================================================================

regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT_REPLY::Protocol_MSG_LOBBY_SAVE_CONSENT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT_REPLY::Protocol_MSG_LOBBY_SAVE_CONSENT_REPLY(Protocol_MSG_LOBBY_SAVE_CONSENT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT_REPLY& regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT_REPLY::operator=(Protocol_MSG_LOBBY_SAVE_CONSENT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT_REPLY::equals(const Protocol_MSG_LOBBY_SAVE_CONSENT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SAVE_CONSENT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_LOBBY_SAVE_CONSENT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SAVE_CONSENT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM(Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM&& _o)
	: playerix(std::move(_o.playerix))
	, userIntId(std::move(_o.userIntId))
	, ftToken(std::move(_o.ftToken))
	, conversionType(std::move(_o.conversionType))
{
}

regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM& regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM::operator=(Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM&& _o)
{
	if(this != &_o)
	{
		playerix = std::move(_o.playerix);
		userIntId = std::move(_o.userIntId);
		ftToken = std::move(_o.ftToken);
		conversionType = std::move(_o.conversionType);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM::clear()
{
	playerix = 0;
	userIntId = 0;
	ftToken.clear();
	conversionType = 0;
}

bool regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM::equals(const Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM& _o) const
{
	return playerix == _o.playerix &&
		userIntId == _o.userIntId &&
		ftToken.equals(_o.ftToken) &&
		conversionType == _o.conversionType;
}

const char *regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM).append(")");
	_buf.append(',');
	_buf.append("playerix=");
	_buf.appendUint(playerix);
	_buf.append(',');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	_buf.append(',');
	_buf.append("ftToken=");
	_buf.append(ftToken);
	_buf.append(',');
	_buf.append("conversionType=");
	_buf.appendInt(conversionType);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(playerix);
	_msg.composeUINT32(userIntId);
	_msg.composeString(ftToken);
	_msg.composeINT32(conversionType);
}

void regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(playerix);
	_parser.parseUINT32(userIntId);
	_parser.parseStringP(ftToken);
	_parser.parseINT32(conversionType);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 playerix; _parser.parseUINT32(playerix);
	AtfValidator::validateInt(_descr, "playerix", playerix, _checker, __FILE__, __LINE__);
	UINT32 userIntId; _parser.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "ftToken"); size_t szFtToken = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "ftToken", szFtToken, 10000, _checker, __FILE__, __LINE__);
	INT32 conversionType; _parser.parseINT32(conversionType);
	AtfValidator::validateIntRange(_descr, "conversionType", conversionType, eFullTiltConversionType_Unknown, eFullTiltConversionType_Last, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY(Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, isRmPlayer(std::move(_o.isRmPlayer))
{
}

regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY& regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY::operator=(Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		isRmPlayer = std::move(_o.isRmPlayer);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	isRmPlayer = false;
}

bool regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY::equals(const Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		isRmPlayer == _o.isRmPlayer;
}

const char *regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("isRmPlayer=");
		_buf.appendUint(isRmPlayer);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeBOOL(isRmPlayer);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseBOOL(isRmPlayer);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool isRmPlayer; _parser.parseBOOL(isRmPlayer);
		AtfValidator::validateInt(_descr, "isRmPlayer", isRmPlayer, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS::clear()
{
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS::equals(const Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS& _o) const
{
	return true;
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_USER_SESSION_WINNINGS).append(")");
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS::composeMsg(CommMsgBody& _msg) const
{
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_USER_SESSION_WINNINGS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY(Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, isLastSession(std::move(_o.isLastSession))
	, sessionStartTime(std::move(_o.sessionStartTime))
	, sessionEndTime(std::move(_o.sessionEndTime))
	, wager(std::move(_o.wager))
	, winLoss(std::move(_o.winLoss))
{
}

regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY& regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY::operator=(Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		isLastSession = std::move(_o.isLastSession);
		sessionStartTime = std::move(_o.sessionStartTime);
		sessionEndTime = std::move(_o.sessionEndTime);
		wager = std::move(_o.wager);
		winLoss = std::move(_o.winLoss);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	isLastSession = false;
	sessionStartTime.setNull();
	sessionEndTime.setNull();
	wager = 0;
	winLoss = 0;
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY::equals(const Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		isLastSession == _o.isLastSession &&
		sessionStartTime.equals(_o.sessionStartTime) &&
		sessionEndTime.equals(_o.sessionEndTime) &&
		wager == _o.wager &&
		winLoss == _o.winLoss;
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("isLastSession=");
		_buf.appendUint(isLastSession);
		_buf.append(',');
		_buf.append("sessionStartTime=");
		ThinAtf::AtfTempl<CommSrvTime>::ToTraceString(_buf, sessionStartTime);
		_buf.append(',');
		_buf.append("sessionEndTime=");
		ThinAtf::AtfTempl<CommSrvTime>::ToTraceString(_buf, sessionEndTime);
		_buf.append(',');
		_buf.append("wager=");
		_buf.appendInt64(wager);
		_buf.append(',');
		_buf.append("winLoss=");
		_buf.appendInt64(winLoss);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeBOOL(isLastSession);
		_msg.composeSrvTime(sessionStartTime);
		_msg.composeSrvTime(sessionEndTime);
		_msg.composeINT64(wager);
		_msg.composeINT64(winLoss);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseBOOL(isLastSession);
		_parser.parseSrvTime(sessionStartTime);
		_parser.parseSrvTime(sessionEndTime);
		_parser.parseINT64(wager);
		_parser.parseINT64(winLoss);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool isLastSession; _parser.parseBOOL(isLastSession);
		AtfValidator::validateInt(_descr, "isLastSession", isLastSession, _checker, __FILE__, __LINE__);
		CommSrvTime sessionStartTime; _parser.parseSrvTime(sessionStartTime);
		AtfValidator::validateSrvDateTime(_descr, "sessionStartTime", sessionStartTime, _checker, __FILE__, __LINE__);
		CommSrvTime sessionEndTime; _parser.parseSrvTime(sessionEndTime);
		AtfValidator::validateSrvDateTime(_descr, "sessionEndTime", sessionEndTime, _checker, __FILE__, __LINE__);
		INT64 wager; _parser.parseINT64(wager);
		AtfValidator::validateInt(_descr, "wager", wager, _checker, __FILE__, __LINE__);
		INT64 winLoss; _parser.parseINT64(winLoss);
		AtfValidator::validateInt(_descr, "winLoss", winLoss, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE(Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE&& _o)
	: userId_ignore(std::move(_o.userId_ignore))
	, elements(std::move(_o.elements))
	, locale(std::move(_o.locale))
{
}

regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE& regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::operator=(Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE&& _o)
{
	if(this != &_o)
	{
		userId_ignore = std::move(_o.userId_ignore);
		elements = std::move(_o.elements);
		locale = std::move(_o.locale);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::clear()
{
	userId_ignore.clear();
	elements.clear();
	locale = 0;
}

bool regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::equals(const Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE& _o) const
{
	return userId_ignore.equals(_o.userId_ignore) &&
		elements.equals(_o.elements) &&
		locale == _o.locale;
}

const char *regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_VALIDATE_USER_UPDATE).append(")");
	_buf.append(',');
	_buf.append("userId_ignore=");
	_buf.append(userId_ignore);
	_buf.append(',');
	_buf.append("elements=");
	elements.toTraceString(_buf);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId_ignore);
	elements.composeMsg(_msg);
	_msg.composeUINT32(locale);
}

void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId_ignore);
	elements.parseMsg(_parser);
	_parser.parseUINT32(locale);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_VALIDATE_USER_UPDATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId_ignore"); size_t szUserId_ignore = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId_ignore", szUserId_ignore, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szElements = ThinAtf::LAtfVector< common_structs::UserUpdateElement, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("elements"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "elements", szElements, 1000, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY(Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, validationResults(std::move(_o.validationResults))
{
}

regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY& regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::operator=(Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		validationResults = std::move(_o.validationResults);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	validationResults.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::equals(const Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		validationResults.equals(_o.validationResults);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("validationResults=");
		validationResults.toTraceString(_buf);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		validationResults.composeMsg(_msg);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		validationResults.parseMsg(_parser);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szValidationResults = ThinAtf::LAtfVector< common_structs::UserUpdateValidationResult, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("validationResults"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "validationResults", szValidationResults, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION::clear()
{
	action = 0;
}

bool regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION::equals(const Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION& _o) const
{
	return action == _o.action;
}

const char *regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION).append(")");
	_buf.append(',');
	_buf.append("action=");
	_buf.appendInt(action);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(action);
}

void regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(action);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 action; _parser.parseINT32(action);
	AtfValidator::validateInt(_descr, "action", action, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY(Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY& regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY::operator=(Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY::equals(const Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE(Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE&& _o)
	: document(std::move(_o.document))
	, docType(std::move(_o.docType))
	, country(std::move(_o.country))
{
}

regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE& regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE::operator=(Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE&& _o)
{
	if(this != &_o)
	{
		document = std::move(_o.document);
		docType = std::move(_o.docType);
		country = std::move(_o.country);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE::clear()
{
	document.clear();
	docType = 0;
	country.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE::equals(const Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE& _o) const
{
	return document.equals(_o.document) &&
		docType == _o.docType &&
		country.equals(_o.country);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE).append(")");
	_buf.append(',');
	_buf.append("document=");
	_buf.append(document);
	_buf.append(',');
	_buf.append("docType=");
	_buf.appendInt(docType);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(document);
	_msg.composeINT32(docType);
	_msg.composeString(country);
}

void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(document);
	_parser.parseINT32(docType);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(country);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "document"); size_t szDocument = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "document", szDocument, 10000, _checker, __FILE__, __LINE__);
	INT32 docType; _parser.parseINT32(docType);
	AtfValidator::validateIntMax(_descr, "docType", docType, 100, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, COUNTRY_CODE_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY(Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY& regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY::operator=(Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY::equals(const Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SE_BANKID_VERIFY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY(Protocol_MSG_REGULATOR_SE_BANKID_VERIFY&& _o)
	: personalNumber(std::move(_o.personalNumber))
	, mobileBankIdOnly(std::move(_o.mobileBankIdOnly))
{
}

regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY& regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY::operator=(Protocol_MSG_REGULATOR_SE_BANKID_VERIFY&& _o)
{
	if(this != &_o)
	{
		personalNumber = std::move(_o.personalNumber);
		mobileBankIdOnly = std::move(_o.mobileBankIdOnly);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY::clear()
{
	personalNumber.clear();
	mobileBankIdOnly = false;
}

bool regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY::equals(const Protocol_MSG_REGULATOR_SE_BANKID_VERIFY& _o) const
{
	return personalNumber.equals(_o.personalNumber) &&
		mobileBankIdOnly == _o.mobileBankIdOnly;
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SE_BANKID_VERIFY).append(")");
	_buf.append(',');
	_buf.append("personalNumber=");
	_buf.append(personalNumber);
	_buf.append(',');
	_buf.append("mobileBankIdOnly=");
	_buf.appendUint(mobileBankIdOnly);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(personalNumber);
	_msg.composeBOOL(mobileBankIdOnly);
}

void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(personalNumber);
	_parser.parseBOOL(mobileBankIdOnly);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SE_BANKID_VERIFY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "personalNumber"); size_t szPersonalNumber = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "personalNumber", szPersonalNumber, 12, _checker, __FILE__, __LINE__);
	bool mobileBankIdOnly; _parser.parseBOOL(mobileBankIdOnly);
	AtfValidator::validateInt(_descr, "mobileBankIdOnly", mobileBankIdOnly, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SE_BANKID_VERIFY_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY_REPLY::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY_REPLY::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY_REPLY(Protocol_MSG_REGULATOR_SE_BANKID_VERIFY_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, status(std::move(_o.status))
	, replyDetails(std::move(_o.replyDetails))
{
}

regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY_REPLY& regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY_REPLY::operator=(Protocol_MSG_REGULATOR_SE_BANKID_VERIFY_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		status = std::move(_o.status);
		replyDetails = std::move(_o.replyDetails);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	status = 0;
	replyDetails.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY_REPLY::equals(const Protocol_MSG_REGULATOR_SE_BANKID_VERIFY_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		status == _o.status &&
		replyDetails.equals(_o.replyDetails);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SE_BANKID_VERIFY_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("status=");
		_buf.appendInt(status);
		_buf.append(',');
		_buf.append("replyDetails=");
		replyDetails.toTraceString(_buf);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(status);
		_msg.composeMsgBody(replyDetails);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(status);
		_parser.parseMsgBody(replyDetails);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SE_BANKID_VERIFY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 status; _parser.parseINT32(status);
		AtfValidator::validateIntRange(_descr, "status", status, 0, 2, _checker, __FILE__, __LINE__);
		size_t szReplyDetails; _parser.skipMsgBody(szReplyDetails);  /*replyDetails*/
		AtfValidator::validateInt(_descr, "replyDetails", szReplyDetails, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SE_BANKID_COLLECT
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT::clear()
{
	orderId = 0;
	bankIdClientStartedAutomatically = false;
}

bool regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT::equals(const Protocol_MSG_REGULATOR_SE_BANKID_COLLECT& _o) const
{
	return orderId == _o.orderId &&
		bankIdClientStartedAutomatically == _o.bankIdClientStartedAutomatically;
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SE_BANKID_COLLECT).append(")");
	_buf.append(',');
	_buf.append("orderId=");
	_buf.appendInt(orderId);
	_buf.append(',');
	_buf.append("bankIdClientStartedAutomatically=");
	_buf.appendUint(bankIdClientStartedAutomatically);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(orderId);
	_msg.composeBOOL(bankIdClientStartedAutomatically);
}

void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(orderId);
	_parser.parseBOOL(bankIdClientStartedAutomatically);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SE_BANKID_COLLECT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 orderId; _parser.parseINT32(orderId);
	AtfValidator::validateIntMin(_descr, "orderId", orderId, 1, _checker, __FILE__, __LINE__);
	bool bankIdClientStartedAutomatically; _parser.parseBOOL(bankIdClientStartedAutomatically);
	AtfValidator::validateInt(_descr, "bankIdClientStartedAutomatically", bankIdClientStartedAutomatically, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SE_BANKID_COLLECT_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT_REPLY::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT_REPLY::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT_REPLY(Protocol_MSG_REGULATOR_SE_BANKID_COLLECT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, status(std::move(_o.status))
	, replyDetails(std::move(_o.replyDetails))
{
}

regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT_REPLY& regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT_REPLY::operator=(Protocol_MSG_REGULATOR_SE_BANKID_COLLECT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		status = std::move(_o.status);
		replyDetails = std::move(_o.replyDetails);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	status = 0;
	replyDetails.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT_REPLY::equals(const Protocol_MSG_REGULATOR_SE_BANKID_COLLECT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		status == _o.status &&
		replyDetails.equals(_o.replyDetails);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SE_BANKID_COLLECT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("status=");
		_buf.appendInt(status);
		_buf.append(',');
		_buf.append("replyDetails=");
		replyDetails.toTraceString(_buf);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(status);
		_msg.composeMsgBody(replyDetails);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(status);
		_parser.parseMsgBody(replyDetails);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SE_BANKID_COLLECT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 status; _parser.parseINT32(status);
		AtfValidator::validateIntRange(_descr, "status", status, 0, 2, _checker, __FILE__, __LINE__);
		size_t szReplyDetails; _parser.skipMsgBody(szReplyDetails);  /*replyDetails*/
		AtfValidator::validateInt(_descr, "replyDetails", szReplyDetails, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    BlackListInfo
//=================================================================

regulator::cli::BlackListInfo::BlackListInfo()
{
	clear();
}

void regulator::cli::BlackListInfo::clear()
{
	durationDays = 0;
	timeFrom.setNull();
	timeUntil.setNull();
}

bool regulator::cli::BlackListInfo::equals(const BlackListInfo& _o) const
{
	return durationDays == _o.durationDays &&
		timeFrom.equals(_o.timeFrom) &&
		timeUntil.equals(_o.timeUntil);
}

const char *regulator::cli::BlackListInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("durationDays=");
	_buf.appendInt(durationDays);
	_buf.append(',');
	_buf.append("timeFrom=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, timeFrom);
	_buf.append(',');
	_buf.append("timeUntil=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, timeUntil);
	_buf.append('}');
	return _buf.c_str();
}

void regulator::cli::BlackListInfo::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(BlackListInfo())) // not empty
	{
		_body.composeINT32(durationDays);
		_body.composeSrvTime(timeFrom);
		_body.composeSrvTime(timeUntil);
	}

	_msg.composeMsgBody(_body);
}

void regulator::cli::BlackListInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(durationDays);
	_parser0.parseSrvTime(timeFrom);
	_parser0.parseSrvTime(timeUntil);
}

/*static*/ void regulator::cli::BlackListInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 durationDays; _parser0.parseINT32(durationDays);
	AtfValidator::validateIntRange(_descr, "durationDays", durationDays, 0, 90, _checker, __FILE__, __LINE__);
	SrvTime timeFrom; _parser0.parseSrvTime(timeFrom);
	AtfValidator::validateSrvDateTime(_descr, "timeFrom", timeFrom, _checker, __FILE__, __LINE__);
	SrvTime timeUntil; _parser0.parseSrvTime(timeUntil);
	AtfValidator::validateSrvDateTime(_descr, "timeUntil", timeUntil, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    BlackListInfoConditional
//=================================================================

regulator::cli::BlackListInfoConditional::BlackListInfoConditional()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::BlackListInfoConditional::BlackListInfoConditional(BlackListInfoConditional&& _o)
	: isBlacklisted(std::move(_o.isBlacklisted))
	, infoBody(std::move(_o.infoBody))
{
}

regulator::cli::BlackListInfoConditional& regulator::cli::BlackListInfoConditional::operator=(BlackListInfoConditional&& _o)
{
	if(this != &_o)
	{
		isBlacklisted = std::move(_o.isBlacklisted);
		infoBody = std::move(_o.infoBody);
	}
	return *this;
}

#endif

void regulator::cli::BlackListInfoConditional::clear()
{
	isBlacklisted = false;
	infoBody.clear();
}

bool regulator::cli::BlackListInfoConditional::equals(const BlackListInfoConditional& _o) const
{
	return isBlacklisted == _o.isBlacklisted &&
		infoBody.equals(_o.infoBody);
}

const char *regulator::cli::BlackListInfoConditional::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("isBlacklisted=");
	_buf.appendUint(isBlacklisted);
	if(isBlacklisted)
	{
		_buf.append(',');
		_buf.append("infoBody=");
		infoBody.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void regulator::cli::BlackListInfoConditional::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBOOL(isBlacklisted);
	if(isBlacklisted)
	{
		infoBody.composeMsg(_msg);
	}
}

void regulator::cli::BlackListInfoConditional::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(isBlacklisted);
	if(isBlacklisted)
	{
		infoBody.parseMsg(_parser);
	}
}

/*static*/ void regulator::cli::BlackListInfoConditional::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	bool isBlacklisted = false;
	_parser.parseBOOL(isBlacklisted);
	AtfValidator::validateInt(_descr, "isBlacklisted", isBlacklisted, _checker, __FILE__, __LINE__);
	if(isBlacklisted)
	{
		PString _descbuf;
		BlackListInfo::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("infoBody"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO::clear()
{
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO::equals(const Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO& _o) const
{
	return true;
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_USER_BLACKLIST_INFO).append(")");
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO::composeMsg(CommMsgBody& _msg) const
{
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_USER_BLACKLIST_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY(Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, blackListInfo(std::move(_o.blackListInfo))
{
}

regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY& regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY::operator=(Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		blackListInfo = std::move(_o.blackListInfo);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	blackListInfo.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY::equals(const Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		blackListInfo.equals(_o.blackListInfo);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("blackListInfo=");
		blackListInfo.toTraceString(_buf);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		blackListInfo.composeMsg(_msg);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		blackListInfo.parseMsg(_parser);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		BlackListInfoConditional::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("blackListInfo"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED::clear()
{
	durationDays = 0;
}

bool regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED::equals(const Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED& _o) const
{
	return durationDays == _o.durationDays;
}

const char *regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_REQUEST_USER_BLACKLISTED).append(")");
	_buf.append(',');
	_buf.append("durationDays=");
	_buf.appendInt(durationDays);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(durationDays);
}

void regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(durationDays);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_REQUEST_USER_BLACKLISTED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 durationDays; _parser.parseINT32(durationDays);
	AtfValidator::validateIntRange(_descr, "durationDays", durationDays, 0, 90, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY(Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, infoBody(std::move(_o.infoBody))
{
}

regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY& regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY::operator=(Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		infoBody = std::move(_o.infoBody);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	infoBody.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY::equals(const Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc) &&
		infoBody.equals(_o.infoBody);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("infoBody=");
		infoBody.toTraceString(_buf);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		infoBody.composeMsg(_msg);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		infoBody.parseMsg(_parser);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		BlackListInfo::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("infoBody"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_SWISS_URL
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL::Protocol_MSG_REGULATOR_GET_SWISS_URL()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL::Protocol_MSG_REGULATOR_GET_SWISS_URL(Protocol_MSG_REGULATOR_GET_SWISS_URL&& _o)
	: commonRequest(std::move(_o.commonRequest))
{
}

regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL& regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL::operator=(Protocol_MSG_REGULATOR_GET_SWISS_URL&& _o)
{
	if(this != &_o)
	{
		commonRequest = std::move(_o.commonRequest);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL::clear()
{
	commonRequest.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL::equals(const Protocol_MSG_REGULATOR_GET_SWISS_URL& _o) const
{
	return commonRequest.equals(_o.commonRequest);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_SWISS_URL).append(")");
	_buf.append(',');
	_buf.append("commonRequest=");
	commonRequest.toTraceString(_buf);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL::composeMsg(CommMsgBody& _msg) const
{
	commonRequest.composeMsg(_msg);
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL::parseMsg(CommMsgParser& _parser)
{
	commonRequest.parseMsg(_parser);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_SWISS_URL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	common_structs::SwissUrlRequest::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("commonRequest"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY(Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, url(std::move(_o.url))
{
}

regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY& regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::operator=(Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		url = std::move(_o.url);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	url.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::equals(const Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		url.equals(_o.url);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_SWISS_URL_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("url=");
		_buf.append(url);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(url);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(url);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_SWISS_URL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "url"); size_t szUrl = strlen(_dummy);
		AtfValidator::validateInt(_descr, "url", szUrl, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL::clear()
{
	urlType = 1;
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL::equals(const Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL& _o) const
{
	return urlType == _o.urlType;
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_ASIA_GAMING_URL).append(")");
	_buf.append(',');
	_buf.append("urlType=");
	_buf.appendInt(urlType);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(urlType);
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseINT16(urlType);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_ASIA_GAMING_URL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(_parser.parseEnded()) return;
	INT16 urlType; _parser.parseINT16(urlType);
	AtfValidator::validateIntMax(_descr, "urlType", urlType, eAsiaB2B_LinkType_Last, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY(Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, url(std::move(_o.url))
{
}

regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY& regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY::operator=(Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		url = std::move(_o.url);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	url.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY::equals(const Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		url.equals(_o.url);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("url=");
		_buf.append("...");
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(url);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(url);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "url"); size_t szUrl = strlen(_dummy);
		AtfValidator::validateInt(_descr, "url", szUrl, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT()
{
	clear();
}

void regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT::clear()
{
}

bool regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT::equals(const Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT& _o) const
{
	return true;
}

const char *regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT).append(")");
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT::composeMsg(CommMsgBody& _msg) const
{
}

void regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY(Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY& regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY::operator=(Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY::equals(const Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION(Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION&& _o)
	: journeyId(std::move(_o.journeyId))
{
}

regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION& regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION::operator=(Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION&& _o)
{
	if(this != &_o)
	{
		journeyId = std::move(_o.journeyId);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION::clear()
{
	journeyId.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION::equals(const Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION& _o) const
{
	return journeyId.equals(_o.journeyId);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION).append(")");
	_buf.append(',');
	_buf.append("journeyId=");
	_buf.append(journeyId);
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(journeyId);
}

void regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(journeyId);
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "journeyId"); size_t szJourneyId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "journeyId", szJourneyId, 40, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY
//=================================================================

regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY(Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY& regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY::operator=(Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY::equals(const Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDesc.equals(_o.errDesc);
}

const char *regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

void regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

/*static*/ void regulator::cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP
//=================================================================

regulator::cli_unauth::Protocol_MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP::Protocol_MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP::Protocol_MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP(Protocol_MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP&& _o)
	: installId(std::move(_o.installId))
	, siteId(std::move(_o.siteId))
	, platformId(std::move(_o.platformId))
	, accountWizardPageName(std::move(_o.accountWizardPageName))
	, clientExtra(std::move(_o.clientExtra))
{
}

regulator::cli_unauth::Protocol_MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP& regulator::cli_unauth::Protocol_MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP::operator=(Protocol_MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP&& _o)
{
	if(this != &_o)
	{
		installId = std::move(_o.installId);
		siteId = std::move(_o.siteId);
		platformId = std::move(_o.platformId);
		accountWizardPageName = std::move(_o.accountWizardPageName);
		clientExtra = std::move(_o.clientExtra);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP::clear()
{
	installId.clear();
	siteId = 0;
	platformId = 0;
	accountWizardPageName.clear();
	clientExtra.clear();
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP::equals(const Protocol_MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP& _o) const
{
	return installId.equals(_o.installId) &&
		siteId == _o.siteId &&
		platformId == _o.platformId &&
		accountWizardPageName.equals(_o.accountWizardPageName) &&
		clientExtra.equals(_o.clientExtra);
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP).append(")");
	_buf.append(',');
	_buf.append("installId=");
	_buf.append(installId);
	_buf.append(',');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("platformId=");
	_buf.appendUint(platformId);
	_buf.append(',');
	_buf.append("accountWizardPageName=");
	_buf.append(accountWizardPageName);
	_buf.append(',');
	_buf.append("clientExtra=");
	clientExtra.toTraceString(_buf);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(installId);
	_msg.composeUINT32(siteId);
	_msg.composeUINT32(platformId);
	_msg.composeString(accountWizardPageName);
	clientExtra.composeMsg(_msg);
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(installId);
	_parser.parseUINT32(siteId);
	_parser.parseUINT32(platformId);
	_parser.parseStringP(accountWizardPageName);
	if(_parser.parseEnded()) return;
	clientExtra.parseMsg(_parser);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "installId"); size_t szInstallId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "installId", szInstallId, 100, _checker, __FILE__, __LINE__);
	UINT32 siteId; _parser.parseUINT32(siteId);
	AtfValidator::validateIntRange(_descr, "siteId", siteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	UINT32 platformId; _parser.parseUINT32(platformId);
	AtfValidator::validateIntRange(_descr, "platformId", platformId, Client_UnknownPlatform, Client_Last, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "accountWizardPageName"); size_t szAccountWizardPageName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "accountWizardPageName", szAccountWizardPageName, 100, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PString _descbuf;
	CommonThin::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientExtra"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_NAME_AVAILABLE
//=================================================================

regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE::Protocol_MSG_LOBBY_NAME_AVAILABLE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE::Protocol_MSG_LOBBY_NAME_AVAILABLE(Protocol_MSG_LOBBY_NAME_AVAILABLE&& _o)
	: body(std::move(_o.body))
{
}

regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE& regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE::operator=(Protocol_MSG_LOBBY_NAME_AVAILABLE&& _o)
{
	if(this != &_o)
	{
		body = std::move(_o.body);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE::clear()
{
	body.clear();
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE::equals(const Protocol_MSG_LOBBY_NAME_AVAILABLE& _o) const
{
	return body.equals(_o.body);
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_NAME_AVAILABLE).append(")");
	_buf.append(',');
	_buf.append("body=");
	body.toTraceString(_buf);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE::composeMsg(CommMsgBody& _msg) const
{
	body.composeMsg(_msg);
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE::parseMsg(CommMsgParser& _parser)
{
	body.parseMsg(_parser);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_NAME_AVAILABLE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	common_structs::LobbyNameAvailableStruct::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("body"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY(Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY&& _o)
	: replyBody(std::move(_o.replyBody))
{
}

regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY& regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::operator=(Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY&& _o)
{
	if(this != &_o)
	{
		replyBody = std::move(_o.replyBody);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::clear()
{
	replyBody.clear();
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::equals(const Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY& _o) const
{
	return replyBody.equals(_o.replyBody);
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_NAME_AVAILABLE_REPLY).append(")");
	_buf.append(',');
	_buf.append("replyBody=");
	replyBody.toTraceString(_buf);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	replyBody.composeMsg(_msg);
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::parseMsg(CommMsgParser& _parser)
{
	replyBody.parseMsg(_parser);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_NAME_AVAILABLE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	common_structs::LobbyNameAvailableReplyStruct::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("replyBody"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP
//=================================================================

regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP(Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP&& _o)
	: siteId(std::move(_o.siteId))
	, clientExtra(std::move(_o.clientExtra))
{
}

regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP& regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP::operator=(Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP&& _o)
{
	if(this != &_o)
	{
		siteId = std::move(_o.siteId);
		clientExtra = std::move(_o.clientExtra);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP::clear()
{
	siteId = 0;
	clientExtra.clear();
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP::equals(const Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP& _o) const
{
	return siteId == _o.siteId &&
		clientExtra.equals(_o.clientExtra);
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_COMPARE_SITE_FOR_IP).append(")");
	_buf.append(',');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("clientExtra=");
	clientExtra.toTraceString(_buf);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(siteId);
	clientExtra.composeMsg(_msg);
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(siteId);
	if(_parser.parseEnded()) return;
	clientExtra.parseMsg(_parser);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_COMPARE_SITE_FOR_IP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 siteId; _parser.parseUINT32(siteId);
	AtfValidator::validateIntRange(_descr, "siteId", siteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PString _descbuf;
	CommonThin::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientExtra"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    SiteMetadata
//=================================================================

regulator::cli_unauth::SiteMetadata::SiteMetadata()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::SiteMetadata::SiteMetadata(SiteMetadata&& _o)
	: siteId(std::move(_o.siteId))
	, name(std::move(_o.name))
	, contactEmail(std::move(_o.contactEmail))
	, contactURL(std::move(_o.contactURL))
	, downloadURL(std::move(_o.downloadURL))
	, faqURL(std::move(_o.faqURL))
{
}

regulator::cli_unauth::SiteMetadata& regulator::cli_unauth::SiteMetadata::operator=(SiteMetadata&& _o)
{
	if(this != &_o)
	{
		siteId = std::move(_o.siteId);
		name = std::move(_o.name);
		contactEmail = std::move(_o.contactEmail);
		contactURL = std::move(_o.contactURL);
		downloadURL = std::move(_o.downloadURL);
		faqURL = std::move(_o.faqURL);
	}
	return *this;
}

#endif

void regulator::cli_unauth::SiteMetadata::clear()
{
	siteId = 0;
	name.clear();
	contactEmail.clear();
	contactURL.clear();
	downloadURL.clear();
	faqURL.clear();
}

bool regulator::cli_unauth::SiteMetadata::equals(const SiteMetadata& _o) const
{
	return siteId == _o.siteId &&
		name.equals(_o.name) &&
		contactEmail.equals(_o.contactEmail) &&
		contactURL.equals(_o.contactURL) &&
		downloadURL.equals(_o.downloadURL) &&
		faqURL.equals(_o.faqURL);
}

const char *regulator::cli_unauth::SiteMetadata::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("contactEmail=");
	_buf.append(contactEmail);
	_buf.append(',');
	_buf.append("contactURL=");
	_buf.append(contactURL);
	_buf.append(',');
	_buf.append("downloadURL=");
	_buf.append(downloadURL);
	_buf.append(',');
	_buf.append("faqURL=");
	_buf.append(faqURL);
	_buf.append('}');
	return _buf.c_str();
}

void regulator::cli_unauth::SiteMetadata::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(siteId);
	_msg.composeString(name);
	_msg.composeString(contactEmail);
	_msg.composeString(contactURL);
	_msg.composeString(downloadURL);
	_msg.composeString(faqURL);
}

void regulator::cli_unauth::SiteMetadata::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(siteId);
	_parser.parseStringP(name);
	_parser.parseStringP(contactEmail);
	_parser.parseStringP(contactURL);
	_parser.parseStringP(downloadURL);
	_parser.parseStringP(faqURL);
}

/*static*/ void regulator::cli_unauth::SiteMetadata::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 siteId; _parser.parseUINT32(siteId);
	AtfValidator::validateInt(_descr, "siteId", siteId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "contactEmail"); size_t szContactEmail = strlen(_dummy);
	AtfValidator::validateInt(_descr, "contactEmail", szContactEmail, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "contactURL"); size_t szContactURL = strlen(_dummy);
	AtfValidator::validateInt(_descr, "contactURL", szContactURL, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "downloadURL"); size_t szDownloadURL = strlen(_dummy);
	AtfValidator::validateInt(_descr, "downloadURL", szDownloadURL, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "faqURL"); size_t szFaqURL = strlen(_dummy);
	AtfValidator::validateInt(_descr, "faqURL", szFaqURL, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY(Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, country(std::move(_o.country))
	, siteMetadata(std::move(_o.siteMetadata))
{
}

regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY& regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY::operator=(Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		country = std::move(_o.country);
		siteMetadata = std::move(_o.siteMetadata);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY::clear()
{
	errCode = 0;
	country.clear();
	siteMetadata.clear();
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY::equals(const Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY& _o) const
{
	return errCode == _o.errCode &&
		country.equals(_o.country) &&
		siteMetadata.equals(_o.siteMetadata);
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("siteMetadata=");
	siteMetadata.toTraceString(_buf);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(country);
	siteMetadata.composeMsg(_msg);
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(country);
	siteMetadata.parseMsg(_parser);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	PString _descbuf;
	SiteMetadata::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("siteMetadata"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE
//=================================================================

regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE(Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE&& _o)
	: country(std::move(_o.country))
	, locale(std::move(_o.locale))
{
}

regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE& regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE::operator=(Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE&& _o)
{
	if(this != &_o)
	{
		country = std::move(_o.country);
		locale = std::move(_o.locale);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE::clear()
{
	country.clear();
	locale = 0;
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE::equals(const Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE& _o) const
{
	return country.equals(_o.country) &&
		locale == _o.locale;
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SIGNUP_QUESTIONNAIRE).append(")");
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(country);
	_msg.composeUINT32(locale);
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(country);
	_parser.parseUINT32(locale);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SIGNUP_QUESTIONNAIRE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, 5, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    ReferralSource
//=================================================================

regulator::cli_unauth::ReferralSource::ReferralSource()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::ReferralSource::ReferralSource(ReferralSource&& _o)
	: sourceId(std::move(_o.sourceId))
	, sourceName(std::move(_o.sourceName))
	, pleaseSpecify(std::move(_o.pleaseSpecify))
	, options(std::move(_o.options))
{
}

regulator::cli_unauth::ReferralSource& regulator::cli_unauth::ReferralSource::operator=(ReferralSource&& _o)
{
	if(this != &_o)
	{
		sourceId = std::move(_o.sourceId);
		sourceName = std::move(_o.sourceName);
		pleaseSpecify = std::move(_o.pleaseSpecify);
		options = std::move(_o.options);
	}
	return *this;
}

#endif

void regulator::cli_unauth::ReferralSource::clear()
{
	sourceId = 0;
	sourceName.clear();
	pleaseSpecify.clear();
	options.clear();
}

bool regulator::cli_unauth::ReferralSource::equals(const ReferralSource& _o) const
{
	return sourceId == _o.sourceId &&
		sourceName.equals(_o.sourceName) &&
		pleaseSpecify.equals(_o.pleaseSpecify) &&
		options.equals(_o.options);
}

const char *regulator::cli_unauth::ReferralSource::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("sourceId=");
	_buf.appendUint(sourceId);
	_buf.append(',');
	_buf.append("sourceName=");
	_buf.append(sourceName);
	_buf.append(',');
	_buf.append("pleaseSpecify=");
	_buf.append(pleaseSpecify);
	_buf.append(',');
	_buf.append("options=");
	options.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void regulator::cli_unauth::ReferralSource::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(sourceId);
	_msg.composeString(sourceName);
	_msg.composeString(pleaseSpecify);
	options.composeMsg(_msg);
}

void regulator::cli_unauth::ReferralSource::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(sourceId);
	_parser.parseStringP(sourceName);
	_parser.parseStringP(pleaseSpecify);
	options.parseMsg(_parser);
}

/*static*/ void regulator::cli_unauth::ReferralSource::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 sourceId; _parser.parseUINT32(sourceId);
	AtfValidator::validateInt(_descr, "sourceId", sourceId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "sourceName"); size_t szSourceName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "sourceName", szSourceName, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "pleaseSpecify"); size_t szPleaseSpecify = strlen(_dummy);
	AtfValidator::validateInt(_descr, "pleaseSpecify", szPleaseSpecify, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szOptions = ThinAtf::LAtfVector< PString, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("options"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "options", szOptions, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY(Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, sources(std::move(_o.sources))
{
}

regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY& regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY::operator=(Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		sources = std::move(_o.sources);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	sources.clear();
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY::equals(const Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		sources.equals(_o.sources);
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("sources=");
		sources.toTraceString(_buf);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		sources.composeMsg(_msg);
	}
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		sources.parseMsg(_parser);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szSources = ThinAtf::LAtfVector< ReferralSource, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sources"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "sources", szSources, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    RegisterNewUserPrivileges
//=================================================================

regulator::cli_unauth::RegisterNewUserPrivileges::RegisterNewUserPrivileges()
{
	clear();
}

void regulator::cli_unauth::RegisterNewUserPrivileges::clear()
{
	untrustedPriv = 0;
	untrustedPrivMask = 0;
	untrustedPriv2 = 0;
	untrustedPriv2Mask = 0;
	untrustedPriv3 = 0;
	untrustedPriv3Mask = 0;
}

bool regulator::cli_unauth::RegisterNewUserPrivileges::equals(const RegisterNewUserPrivileges& _o) const
{
	return untrustedPriv == _o.untrustedPriv &&
		untrustedPrivMask == _o.untrustedPrivMask &&
		untrustedPriv2 == _o.untrustedPriv2 &&
		untrustedPriv2Mask == _o.untrustedPriv2Mask &&
		untrustedPriv3 == _o.untrustedPriv3 &&
		untrustedPriv3Mask == _o.untrustedPriv3Mask;
}

const char *regulator::cli_unauth::RegisterNewUserPrivileges::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("untrustedPriv=");
	_buf.appendUint(untrustedPriv);
	_buf.append(',');
	_buf.append("untrustedPrivMask=");
	_buf.appendUint(untrustedPrivMask);
	_buf.append(',');
	_buf.append("untrustedPriv2=");
	_buf.appendUint64(untrustedPriv2);
	_buf.append(',');
	_buf.append("untrustedPriv2Mask=");
	_buf.appendUint64(untrustedPriv2Mask);
	_buf.append(',');
	_buf.append("untrustedPriv3=");
	_buf.appendUint64(untrustedPriv3);
	_buf.append(',');
	_buf.append("untrustedPriv3Mask=");
	_buf.appendUint64(untrustedPriv3Mask);
	_buf.append('}');
	return _buf.c_str();
}

void regulator::cli_unauth::RegisterNewUserPrivileges::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(RegisterNewUserPrivileges())) // not empty
	{
		_body.composeUINT32(untrustedPriv);
		_body.composeUINT32(untrustedPrivMask);
		_body.composeUINT64(untrustedPriv2);
		_body.composeUINT64(untrustedPriv2Mask);
		_body.composeUINT64(untrustedPriv3);
		_body.composeUINT64(untrustedPriv3Mask);
	}

	_msg.composeMsgBody(_body);
}

void regulator::cli_unauth::RegisterNewUserPrivileges::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(untrustedPriv);
	_parser0.parseUINT32(untrustedPrivMask);
	_parser0.parseUINT64(untrustedPriv2);
	_parser0.parseUINT64(untrustedPriv2Mask);
	_parser0.parseUINT64(untrustedPriv3);
	_parser0.parseUINT64(untrustedPriv3Mask);
}

/*static*/ void regulator::cli_unauth::RegisterNewUserPrivileges::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 untrustedPriv; _parser0.parseUINT32(untrustedPriv);
	AtfValidator::validateInt(_descr, "untrustedPriv", untrustedPriv, _checker, __FILE__, __LINE__);
	UINT32 untrustedPrivMask; _parser0.parseUINT32(untrustedPrivMask);
	AtfValidator::validateInt(_descr, "untrustedPrivMask", untrustedPrivMask, _checker, __FILE__, __LINE__);
	UINT64 untrustedPriv2; _parser0.parseUINT64(untrustedPriv2);
	AtfValidator::validateUint(_descr, "untrustedPriv2", untrustedPriv2, _checker, __FILE__, __LINE__);
	UINT64 untrustedPriv2Mask; _parser0.parseUINT64(untrustedPriv2Mask);
	AtfValidator::validateUint(_descr, "untrustedPriv2Mask", untrustedPriv2Mask, _checker, __FILE__, __LINE__);
	UINT64 untrustedPriv3; _parser0.parseUINT64(untrustedPriv3);
	AtfValidator::validateUint(_descr, "untrustedPriv3", untrustedPriv3, _checker, __FILE__, __LINE__);
	UINT64 untrustedPriv3Mask; _parser0.parseUINT64(untrustedPriv3Mask);
	AtfValidator::validateUint(_descr, "untrustedPriv3Mask", untrustedPriv3Mask, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    RegisterNewUserRequest
//=================================================================

regulator::cli_unauth::RegisterNewUserRequest::RegisterNewUserRequest()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::RegisterNewUserRequest::RegisterNewUserRequest(RegisterNewUserRequest&& _o)
	: id(std::move(_o.id))
	, pwd(std::move(_o.pwd))
	, fullName(std::move(_o.fullName))
	, email(std::move(_o.email))
	, addr_1(std::move(_o.addr_1))
	, addr_2(std::move(_o.addr_2))
	, city(std::move(_o.city))
	, state(std::move(_o.state))
	, country(std::move(_o.country))
	, zipCode(std::move(_o.zipCode))
	, userInstallId(std::move(_o.userInstallId))
	, imageType(std::move(_o.imageType))
	, imageData(std::move(_o.imageData))
	, _dummy(std::move(_o._dummy))
	, siteIdShifted(std::move(_o.siteIdShifted))
	, referenceType(std::move(_o.referenceType))
	, referenceStr(std::move(_o.referenceStr))
	, _promisedFppDummy(std::move(_o._promisedFppDummy))
	, dob(std::move(_o.dob))
	, locale(std::move(_o.locale))
	, tiVer(std::move(_o.tiVer))
	, tiGUID(std::move(_o.tiGUID))
	, tiManualPromo(std::move(_o.tiManualPromo))
	, tiPromoCode(std::move(_o.tiPromoCode))
	, tiInfoFile(std::move(_o.tiInfoFile))
	, ignoreInvalidManualPromo(std::move(_o.ignoreInvalidManualPromo))
	, firstName(std::move(_o.firstName))
	, lastName(std::move(_o.lastName))
	, captchaData(std::move(_o.captchaData))
	, captchaText(std::move(_o.captchaText))
	, mailList(std::move(_o.mailList))
	, sex(std::move(_o.sex))
	, refDomain(std::move(_o.refDomain))
	, mobile(std::move(_o.mobile))
	, timezone(std::move(_o.timezone))
	, clientExtra(std::move(_o.clientExtra))
	, imageId(std::move(_o.imageId))
	, clientFlags(std::move(_o.clientFlags))
	, clientExtra_ignored(std::move(_o.clientExtra_ignored))
	, privileges(std::move(_o.privileges))
	, regSiteId(std::move(_o.regSiteId))
{
}

regulator::cli_unauth::RegisterNewUserRequest& regulator::cli_unauth::RegisterNewUserRequest::operator=(RegisterNewUserRequest&& _o)
{
	if(this != &_o)
	{
		id = std::move(_o.id);
		pwd = std::move(_o.pwd);
		fullName = std::move(_o.fullName);
		email = std::move(_o.email);
		addr_1 = std::move(_o.addr_1);
		addr_2 = std::move(_o.addr_2);
		city = std::move(_o.city);
		state = std::move(_o.state);
		country = std::move(_o.country);
		zipCode = std::move(_o.zipCode);
		userInstallId = std::move(_o.userInstallId);
		imageType = std::move(_o.imageType);
		imageData = std::move(_o.imageData);
		_dummy = std::move(_o._dummy);
		siteIdShifted = std::move(_o.siteIdShifted);
		referenceType = std::move(_o.referenceType);
		referenceStr = std::move(_o.referenceStr);
		_promisedFppDummy = std::move(_o._promisedFppDummy);
		dob = std::move(_o.dob);
		locale = std::move(_o.locale);
		tiVer = std::move(_o.tiVer);
		tiGUID = std::move(_o.tiGUID);
		tiManualPromo = std::move(_o.tiManualPromo);
		tiPromoCode = std::move(_o.tiPromoCode);
		tiInfoFile = std::move(_o.tiInfoFile);
		ignoreInvalidManualPromo = std::move(_o.ignoreInvalidManualPromo);
		firstName = std::move(_o.firstName);
		lastName = std::move(_o.lastName);
		captchaData = std::move(_o.captchaData);
		captchaText = std::move(_o.captchaText);
		mailList = std::move(_o.mailList);
		sex = std::move(_o.sex);
		refDomain = std::move(_o.refDomain);
		mobile = std::move(_o.mobile);
		timezone = std::move(_o.timezone);
		clientExtra = std::move(_o.clientExtra);
		imageId = std::move(_o.imageId);
		clientFlags = std::move(_o.clientFlags);
		clientExtra_ignored = std::move(_o.clientExtra_ignored);
		privileges = std::move(_o.privileges);
		regSiteId = std::move(_o.regSiteId);
	}
	return *this;
}

#endif

void regulator::cli_unauth::RegisterNewUserRequest::clear()
{
	id.clear();
	pwd.clear();
	fullName.clear();
	email.clear();
	addr_1.clear();
	addr_2.clear();
	city.clear();
	state.clear();
	country.clear();
	zipCode.clear();
	userInstallId.clear();
	imageType = 0;
	imageData.clear();
	_dummy.clear();
	siteIdShifted = 0;
	referenceType = 0;
	referenceStr.clear();
	_promisedFppDummy = 0;
	dob.setNull();
	locale = 0;
	tiVer.clear();
	tiGUID.clear();
	tiManualPromo.clear();
	tiPromoCode.clear();
	tiInfoFile.clear();
	ignoreInvalidManualPromo = false;
	firstName.clear();
	lastName.clear();
	captchaData.clear();
	captchaText.clear();
	mailList = false;
	sex.clear();
	refDomain.clear();
	mobile.clear();
	timezone = 0;
	clientExtra.clear();
	imageId = 0;
	clientFlags = 0;
	clientExtra_ignored.clear();
	privileges.clear();
	regSiteId = 0;
}

bool regulator::cli_unauth::RegisterNewUserRequest::equals(const RegisterNewUserRequest& _o) const
{
	return id.equals(_o.id) &&
		pwd.equals(_o.pwd) &&
		fullName.equals(_o.fullName) &&
		email.equals(_o.email) &&
		addr_1.equals(_o.addr_1) &&
		addr_2.equals(_o.addr_2) &&
		city.equals(_o.city) &&
		state.equals(_o.state) &&
		country.equals(_o.country) &&
		zipCode.equals(_o.zipCode) &&
		userInstallId.equals(_o.userInstallId) &&
		imageType == _o.imageType &&
		imageData.size() == _o.imageData.size() && memcmp(imageData.ptr(), _o.imageData.ptr(), imageData.size()) == 0 &&
		_dummy.equals(_o._dummy) &&
		siteIdShifted == _o.siteIdShifted &&
		referenceType == _o.referenceType &&
		referenceStr.equals(_o.referenceStr) &&
		_promisedFppDummy == _o._promisedFppDummy &&
		dob.equals(_o.dob) &&
		locale == _o.locale &&
		tiVer.equals(_o.tiVer) &&
		tiGUID.equals(_o.tiGUID) &&
		tiManualPromo.equals(_o.tiManualPromo) &&
		tiPromoCode.equals(_o.tiPromoCode) &&
		tiInfoFile.equals(_o.tiInfoFile) &&
		ignoreInvalidManualPromo == _o.ignoreInvalidManualPromo &&
		firstName.equals(_o.firstName) &&
		lastName.equals(_o.lastName) &&
		captchaData.size() == _o.captchaData.size() && memcmp(captchaData.ptr(), _o.captchaData.ptr(), captchaData.size()) == 0 &&
		captchaText.equals(_o.captchaText) &&
		mailList == _o.mailList &&
		sex.equals(_o.sex) &&
		refDomain.equals(_o.refDomain) &&
		mobile.equals(_o.mobile) &&
		timezone == _o.timezone &&
		clientExtra.equals(_o.clientExtra) &&
		imageId == _o.imageId &&
		clientFlags == _o.clientFlags &&
		clientExtra_ignored.equals(_o.clientExtra_ignored) &&
		privileges.equals(_o.privileges) &&
		regSiteId == _o.regSiteId;
}

const char *regulator::cli_unauth::RegisterNewUserRequest::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("id=");
	_buf.append(id);
	_buf.append(',');
	_buf.append("pwd=");
	_buf.append(pwd);
	_buf.append(',');
	_buf.append("fullName=");
	_buf.append(fullName);
	_buf.append(',');
	_buf.append("email=");
	_buf.append(email);
	_buf.append(',');
	_buf.append("addr_1=");
	_buf.append(addr_1);
	_buf.append(',');
	_buf.append("addr_2=");
	_buf.append(addr_2);
	_buf.append(',');
	_buf.append("city=");
	_buf.append(city);
	_buf.append(',');
	_buf.append("state=");
	_buf.append(state);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("zipCode=");
	_buf.append(zipCode);
	_buf.append(',');
	_buf.append("userInstallId=");
	_buf.append(userInstallId);
	_buf.append(',');
	_buf.append("imageType=");
	_buf.appendUint(imageType);
	_buf.append(',');
	_buf.append("imageData=");
	ThinAtf::AtfTempl<PBlock>::ToTraceString(_buf, imageData);
	_buf.append(',');
	_buf.append("_dummy=");
	_buf.append(_dummy);
	_buf.append(',');
	_buf.append("siteIdShifted=");
	_buf.appendUint(siteIdShifted);
	_buf.append(',');
	_buf.append("referenceType=");
	_buf.appendInt(referenceType);
	_buf.append(',');
	_buf.append("referenceStr=");
	_buf.append(referenceStr);
	_buf.append(',');
	_buf.append("_promisedFppDummy=");
	_buf.appendInt(_promisedFppDummy);
	_buf.append(',');
	_buf.append("dob=");
	ThinAtf::AtfTempl<CommSrvDate>::ToTraceString(_buf, dob);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("tiVer=");
	_buf.append(tiVer);
	_buf.append(',');
	_buf.append("tiGUID=");
	_buf.append(tiGUID);
	_buf.append(',');
	_buf.append("tiManualPromo=");
	_buf.append(tiManualPromo);
	_buf.append(',');
	_buf.append("tiPromoCode=");
	_buf.append(tiPromoCode);
	_buf.append(',');
	_buf.append("tiInfoFile=");
	_buf.append(tiInfoFile);
	_buf.append(',');
	_buf.append("ignoreInvalidManualPromo=");
	_buf.appendUint(ignoreInvalidManualPromo);
	_buf.append(',');
	_buf.append("firstName=");
	_buf.append(firstName);
	_buf.append(',');
	_buf.append("lastName=");
	_buf.append(lastName);
	_buf.append(',');
	_buf.append("captchaData=");
	ThinAtf::AtfTempl<PBlock>::ToTraceString(_buf, captchaData);
	_buf.append(',');
	_buf.append("captchaText=");
	_buf.append(captchaText);
	_buf.append(',');
	_buf.append("mailList=");
	_buf.appendUint(mailList);
	_buf.append(',');
	_buf.append("sex=");
	_buf.append(sex);
	_buf.append(',');
	_buf.append("refDomain=");
	_buf.append(refDomain);
	_buf.append(',');
	_buf.append("mobile=");
	_buf.append(mobile);
	_buf.append(',');
	_buf.append("timezone=");
	_buf.appendUint(timezone);
	_buf.append(',');
	_buf.append("clientExtra=");
	clientExtra.toTraceString(_buf);
	_buf.append(',');
	_buf.append("imageId=");
	_buf.appendUint(imageId);
	_buf.append(',');
	_buf.append("clientFlags=");
	_buf.appendUint(clientFlags);
	_buf.append(',');
	_buf.append("clientExtra_ignored=");
	clientExtra_ignored.toTraceString(_buf);
	_buf.append(',');
	_buf.append("privileges=");
	privileges.toTraceString(_buf);
	_buf.append(',');
	_buf.append("regSiteId=");
	_buf.appendUint(regSiteId);
	_buf.append('}');
	return _buf.c_str();
}

void regulator::cli_unauth::RegisterNewUserRequest::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(id);
	_msg.composeString(pwd);
	_msg.composeString(fullName);
	_msg.composeString(email);
	_msg.composeString(addr_1);
	_msg.composeString(addr_2);
	_msg.composeString(city);
	_msg.composeString(state);
	_msg.composeString(country);
	_msg.composeString(zipCode);
	_msg.composeString(userInstallId);
	_msg.composeBYTE(imageType);
	_msg._composeVarBlock(imageData.ptr(), imageData.size());
	_msg.composeString(_dummy);
	_msg.composeUINT32(siteIdShifted);
	_msg.composeINT32(referenceType);
	_msg.composeString(referenceStr);
	_msg.composeINT32(_promisedFppDummy);
	_msg.composeSrvDate(dob);
	_msg.composeUINT32(locale);
	_msg.composeString(tiVer);
	_msg.composeString(tiGUID);
	_msg.composeString(tiManualPromo);
	_msg.composeString(tiPromoCode);
	_msg.composeString(tiInfoFile);
	_msg.composeBOOL(ignoreInvalidManualPromo);
	_msg.composeString(firstName);
	_msg.composeString(lastName);
	_msg._composeVarBlock(captchaData.ptr(), captchaData.size());
	_msg.composeString(captchaText);
	_msg.composeBOOL(mailList);
	_msg.composeString(sex);
	_msg.composeString(refDomain);
	_msg.composeString(mobile);
	_msg.composeUINT32(timezone);
	clientExtra.composeMsg(_msg);
	_msg.composeUINT32(imageId);
	_msg.composeUINT32(clientFlags);
	clientExtra_ignored.composeMsg(_msg);
	privileges.composeMsg(_msg);
	_msg.composeUINT32(regSiteId);
}

void regulator::cli_unauth::RegisterNewUserRequest::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(id);
	_parser.parseStringP(pwd);
	_parser.parseStringP(fullName);
	_parser.parseStringP(email);
	_parser.parseStringP(addr_1);
	_parser.parseStringP(addr_2);
	_parser.parseStringP(city);
	_parser.parseStringP(state);
	_parser.parseStringP(country);
	_parser.parseStringP(zipCode);
	_parser.parseStringP(userInstallId);
	_parser.parseBYTE(imageType);
	_parser.parsePBlock(imageData);
	_parser.parseStringP(_dummy);
	_parser.parseUINT32(siteIdShifted);
	_parser.parseINT32(referenceType);
	_parser.parseStringP(referenceStr);
	_parser.parseINT32(_promisedFppDummy);
	_parser.parseSrvDate(dob);
	_parser.parseUINT32(locale);
	_parser.parseStringP(tiVer);
	_parser.parseStringP(tiGUID);
	_parser.parseStringP(tiManualPromo);
	_parser.parseStringP(tiPromoCode);
	_parser.parseStringP(tiInfoFile);
	_parser.parseBOOL(ignoreInvalidManualPromo);
	_parser.parseStringP(firstName);
	_parser.parseStringP(lastName);
	_parser.parsePBlock(captchaData);
	_parser.parseStringP(captchaText);
	_parser.parseBOOL(mailList);
	_parser.parseStringP(sex);
	_parser.parseStringP(refDomain);
	_parser.parseStringP(mobile);
	_parser.parseUINT32(timezone);
	if(_parser.parseEnded()) return;
	clientExtra.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(imageId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(clientFlags);
	if(_parser.parseEnded()) return;
	clientExtra_ignored.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	privileges.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(regSiteId);
}

/*static*/ void regulator::cli_unauth::RegisterNewUserRequest::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy0 = "";
	_parser.parseStringN(_dummy0, 0, "id"); size_t szId = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "id", szId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "pwd"); size_t szPwd = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "pwd", szPwd, USER_PWD_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "fullName"); size_t szFullName = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "fullName", szFullName, USER_FULLNAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "email"); size_t szEmail = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "email", szEmail, USER_EMAIL_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "addr_1"); size_t szAddr_1 = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "addr_1", szAddr_1, USER_ADDR_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "addr_2"); size_t szAddr_2 = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "addr_2", szAddr_2, USER_ADDR2_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "city"); size_t szCity = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "city", szCity, USER_CITY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "state"); size_t szState = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "state", szState, USER_STATE_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "country"); size_t szCountry = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "country", szCountry, USER_COUNTRY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "zipCode"); size_t szZipCode = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "zipCode", szZipCode, USER_ZIP_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "userInstallId"); size_t szUserInstallId = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "userInstallId", szUserInstallId, USER_INSTALLID_LEN, _checker, __FILE__, __LINE__);
	BYTE imageType; _parser.parseBYTE(imageType);
	AtfValidator::validateIntRange(_descr, "imageType", imageType, IMAGE_TYPE_NONE, IMAGE_TYPE_LAST, _checker, __FILE__, __LINE__);
	const BYTE* imageData; size_t szImageData; _parser._parseVarBlock(imageData, szImageData);  /*imageData*/
	AtfValidator::validateIntMax(_descr, "imageData", szImageData, IMAGE_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "_dummy"); size_t sz_dummy = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "_dummy", sz_dummy, 1000, _checker, __FILE__, __LINE__);
	UINT32 siteIdShifted; _parser.parseUINT32(siteIdShifted);
	AtfValidator::validateIntRange(_descr, "siteIdShifted", siteIdShifted, (UINT32(PokerStars_SiteUnknown)>>1), (UINT32(PokerStars_Last)>>1), _checker, __FILE__, __LINE__);
	INT32 referenceType; _parser.parseINT32(referenceType);
	AtfValidator::validateInt(_descr, "referenceType", referenceType, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "referenceStr"); size_t szReferenceStr = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "referenceStr", szReferenceStr, 1000, _checker, __FILE__, __LINE__);
	INT32 _promisedFppDummy; _parser.parseINT32(_promisedFppDummy);
	AtfValidator::validateInt(_descr, "_promisedFppDummy", _promisedFppDummy, _checker, __FILE__, __LINE__);
	CommSrvDate dob; _parser.parseSrvDate(dob);
	AtfValidator::validateSrvDateTime(_descr, "dob", dob, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "tiVer"); size_t szTiVer = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "tiVer", szTiVer, TINFO_VERSION_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "tiGUID"); size_t szTiGUID = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "tiGUID", szTiGUID, TINFO_GUID_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "tiManualPromo"); size_t szTiManualPromo = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "tiManualPromo", szTiManualPromo, 300, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "tiPromoCode"); size_t szTiPromoCode = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "tiPromoCode", szTiPromoCode, PROMO_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "tiInfoFile"); size_t szTiInfoFile = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "tiInfoFile", szTiInfoFile, 1000, _checker, __FILE__, __LINE__);
	bool ignoreInvalidManualPromo; _parser.parseBOOL(ignoreInvalidManualPromo);
	AtfValidator::validateInt(_descr, "ignoreInvalidManualPromo", ignoreInvalidManualPromo, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "firstName"); size_t szFirstName = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "firstName", szFirstName, USER_FIRST_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "lastName"); size_t szLastName = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "lastName", szLastName, USER_LAST_NAME_LEN, _checker, __FILE__, __LINE__);
	const BYTE* captchaData; size_t szCaptchaData; _parser._parseVarBlock(captchaData, szCaptchaData);  /*captchaData*/
	AtfValidator::validateIntMax(_descr, "captchaData", szCaptchaData, 10000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "captchaText"); size_t szCaptchaText = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "captchaText", szCaptchaText, 100, _checker, __FILE__, __LINE__);
	bool mailList; _parser.parseBOOL(mailList);
	AtfValidator::validateInt(_descr, "mailList", mailList, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "sex"); size_t szSex = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "sex", szSex, USER_SEX_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "refDomain"); size_t szRefDomain = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "refDomain", szRefDomain, TINFO_TINFO_RDN_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy0, 0, "mobile"); size_t szMobile = strlen(_dummy0);
	AtfValidator::validateIntMax(_descr, "mobile", szMobile, USER_MOBILE_LEN, _checker, __FILE__, __LINE__);
	UINT32 timezone; _parser.parseUINT32(timezone);
	AtfValidator::validateIntRange(_descr, "timezone", timezone, eTzUTC, (eTzNumber-1), _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PString _descbuf;
	CommonThin::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientExtra"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	UINT32 imageId; _parser.parseUINT32(imageId);
	AtfValidator::validateInt(_descr, "imageId", imageId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 clientFlags; _parser.parseUINT32(clientFlags);
	AtfValidator::validateIntMax(_descr, "clientFlags", clientFlags, ((UINT32(eRegisterNewUserFlags_Last)<<1)-1), _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	CommonThin::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientExtra_ignored"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	RegisterNewUserPrivileges::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privileges"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	UINT32 regSiteId; _parser.parseUINT32(regSiteId);
	AtfValidator::validateIntRange(_descr, "regSiteId", regSiteId, PokerStars_Com, PokerStars_Last, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_REGISTER_NEW_USER
//=================================================================

regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER::Protocol_MSG_LOBBY_REGISTER_NEW_USER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER::Protocol_MSG_LOBBY_REGISTER_NEW_USER(Protocol_MSG_LOBBY_REGISTER_NEW_USER&& _o)
	: newUser(std::move(_o.newUser))
{
}

regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER& regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER::operator=(Protocol_MSG_LOBBY_REGISTER_NEW_USER&& _o)
{
	if(this != &_o)
	{
		newUser = std::move(_o.newUser);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER::clear()
{
	newUser.clear();
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER::equals(const Protocol_MSG_LOBBY_REGISTER_NEW_USER& _o) const
{
	return newUser.equals(_o.newUser);
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_REGISTER_NEW_USER).append(")");
	_buf.append(',');
	_buf.append("newUser=");
	newUser.toTraceString(_buf);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER::composeMsg(CommMsgBody& _msg) const
{
	newUser.composeMsg(_msg);
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER::parseMsg(CommMsgParser& _parser)
{
	newUser.parseMsg(_parser);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_REGISTER_NEW_USER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	RegisterNewUserRequest::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("newUser"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_REGISTER_NEW_USER_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER_REPLY::Protocol_MSG_LOBBY_REGISTER_NEW_USER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER_REPLY::Protocol_MSG_LOBBY_REGISTER_NEW_USER_REPLY(Protocol_MSG_LOBBY_REGISTER_NEW_USER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, fppForQuestionnaire(std::move(_o.fppForQuestionnaire))
	, empty(std::move(_o.empty))
	, firstDepositBonusAmount(std::move(_o.firstDepositBonusAmount))
	, firstDepositBonusCurrency(std::move(_o.firstDepositBonusCurrency))
	, fdbPrompt(std::move(_o.fdbPrompt))
{
}

regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER_REPLY& regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER_REPLY::operator=(Protocol_MSG_LOBBY_REGISTER_NEW_USER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		fppForQuestionnaire = std::move(_o.fppForQuestionnaire);
		empty = std::move(_o.empty);
		firstDepositBonusAmount = std::move(_o.firstDepositBonusAmount);
		firstDepositBonusCurrency = std::move(_o.firstDepositBonusCurrency);
		fdbPrompt = std::move(_o.fdbPrompt);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	fppForQuestionnaire = 0;
	empty.clear();
	firstDepositBonusAmount = 0;
	firstDepositBonusCurrency.clear();
	fdbPrompt.clear();
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER_REPLY::equals(const Protocol_MSG_LOBBY_REGISTER_NEW_USER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		fppForQuestionnaire == _o.fppForQuestionnaire &&
		empty.equals(_o.empty) &&
		firstDepositBonusAmount == _o.firstDepositBonusAmount &&
		firstDepositBonusCurrency.equals(_o.firstDepositBonusCurrency) &&
		fdbPrompt.equals(_o.fdbPrompt);
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_REGISTER_NEW_USER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("fppForQuestionnaire=");
		_buf.appendInt(fppForQuestionnaire);
		_buf.append(',');
		_buf.append("empty=");
		_buf.append(empty);
		_buf.append(',');
		_buf.append("firstDepositBonusAmount=");
		_buf.appendInt(firstDepositBonusAmount);
		_buf.append(',');
		_buf.append("firstDepositBonusCurrency=");
		_buf.append(firstDepositBonusCurrency);
		_buf.append(',');
		_buf.append("fdbPrompt=");
		_buf.append(fdbPrompt);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(fppForQuestionnaire);
		_msg.composeString(empty);
		_msg.composeINT32(firstDepositBonusAmount);
		_msg.composeString(firstDepositBonusCurrency);
		_msg.composeString(fdbPrompt);
	}
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(fppForQuestionnaire);
		_parser.parseStringP(empty);
		_parser.parseINT32(firstDepositBonusAmount);
		_parser.parseStringP(firstDepositBonusCurrency);
		_parser.parseStringP(fdbPrompt);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_REGISTER_NEW_USER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 fppForQuestionnaire; _parser.parseINT32(fppForQuestionnaire);
		AtfValidator::validateInt(_descr, "fppForQuestionnaire", fppForQuestionnaire, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "empty"); size_t szEmpty = strlen(_dummy);
		AtfValidator::validateInt(_descr, "empty", szEmpty, _checker, __FILE__, __LINE__);
		INT32 firstDepositBonusAmount; _parser.parseINT32(firstDepositBonusAmount);
		AtfValidator::validateInt(_descr, "firstDepositBonusAmount", firstDepositBonusAmount, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "firstDepositBonusCurrency"); size_t szFirstDepositBonusCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "firstDepositBonusCurrency", szFirstDepositBonusCurrency, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "fdbPrompt"); size_t szFdbPrompt = strlen(_dummy);
		AtfValidator::validateInt(_descr, "fdbPrompt", szFdbPrompt, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN(Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN&& _o)
	: userId(std::move(_o.userId))
	, email(std::move(_o.email))
	, installId(std::move(_o.installId))
	, locale(std::move(_o.locale))
	, siteId(std::move(_o.siteId))
	, platformId(std::move(_o.platformId))
	, clientExtra(std::move(_o.clientExtra))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN& regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN::operator=(Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		email = std::move(_o.email);
		installId = std::move(_o.installId);
		locale = std::move(_o.locale);
		siteId = std::move(_o.siteId);
		platformId = std::move(_o.platformId);
		clientExtra = std::move(_o.clientExtra);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN::clear()
{
	userId.clear();
	email.clear();
	installId.clear();
	locale = 0;
	siteId = 0;
	platformId = 0;
	clientExtra.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN::equals(const Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN& _o) const
{
	return userId.equals(_o.userId) &&
		email.equals(_o.email) &&
		installId.equals(_o.installId) &&
		locale == _o.locale &&
		siteId == _o.siteId &&
		platformId == _o.platformId &&
		clientExtra.equals(_o.clientExtra);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("email=");
	_buf.append(email);
	_buf.append(',');
	_buf.append("installId=");
	_buf.append(installId);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("platformId=");
	_buf.appendUint(platformId);
	_buf.append(',');
	_buf.append("clientExtra=");
	clientExtra.toTraceString(_buf);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeString(email);
	_msg.composeString(installId);
	_msg.composeUINT32(locale);
	_msg.composeUINT32(siteId);
	_msg.composeUINT32(platformId);
	clientExtra.composeMsg(_msg);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseStringP(email);
	_parser.parseStringP(installId);
	_parser.parseUINT32(locale);
	_parser.parseUINT32(siteId);
	_parser.parseUINT32(platformId);
	if(_parser.parseEnded()) return;
	clientExtra.parseMsg(_parser);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "email", szEmail, USER_EMAIL_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "installId"); size_t szInstallId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "installId", szInstallId, USER_INSTALLID_LEN, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT32 siteId; _parser.parseUINT32(siteId);
	AtfValidator::validateIntRange(_descr, "siteId", siteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	UINT32 platformId; _parser.parseUINT32(platformId);
	AtfValidator::validateIntRange(_descr, "platformId", platformId, Client_UnknownPlatform, Client_Last, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PString _descbuf;
	CommonThin::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientExtra"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY(Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY& regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY::operator=(Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY::equals(const Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_EMAIL_AVAILABLE
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE(Protocol_MSG_REGULATOR_EMAIL_AVAILABLE&& _o)
	: email(std::move(_o.email))
	, locale(std::move(_o.locale))
	, clientExtra(std::move(_o.clientExtra))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE& regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE::operator=(Protocol_MSG_REGULATOR_EMAIL_AVAILABLE&& _o)
{
	if(this != &_o)
	{
		email = std::move(_o.email);
		locale = std::move(_o.locale);
		clientExtra = std::move(_o.clientExtra);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE::clear()
{
	email.clear();
	locale = 0;
	clientExtra.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE::equals(const Protocol_MSG_REGULATOR_EMAIL_AVAILABLE& _o) const
{
	return email.equals(_o.email) &&
		locale == _o.locale &&
		clientExtra.equals(_o.clientExtra);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_EMAIL_AVAILABLE).append(")");
	_buf.append(',');
	_buf.append("email=");
	_buf.append(email);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("clientExtra=");
	clientExtra.toTraceString(_buf);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(email);
	_msg.composeUINT32(locale);
	clientExtra.composeMsg(_msg);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(email);
	_parser.parseUINT32(locale);
	clientExtra.parseMsg(_parser);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_EMAIL_AVAILABLE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "email", szEmail, USER_EMAIL_LEN, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	PString _descbuf;
	CommonThin::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientExtra"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_EMAIL_AVAILABLE_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE_REPLY::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE_REPLY::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE_REPLY(Protocol_MSG_REGULATOR_EMAIL_AVAILABLE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, brandId(std::move(_o.brandId))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE_REPLY& regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE_REPLY::operator=(Protocol_MSG_REGULATOR_EMAIL_AVAILABLE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		brandId = std::move(_o.brandId);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	brandId = 0;
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE_REPLY::equals(const Protocol_MSG_REGULATOR_EMAIL_AVAILABLE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		brandId == _o.brandId;
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_EMAIL_AVAILABLE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	if (errCode == DUPLICATE_NEW_USER_EMAIL)
	{
		_buf.append(',');
		_buf.append("brandId=");
		_buf.appendUint(brandId);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	if (errCode == DUPLICATE_NEW_USER_EMAIL)
	{
		_msg.composeUINT32(brandId);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	if (errCode == DUPLICATE_NEW_USER_EMAIL)
	{
		_parser.parseUINT32(brandId);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_EMAIL_AVAILABLE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if (errCode == DUPLICATE_NEW_USER_EMAIL)
	{
		UINT32 brandId; _parser.parseUINT32(brandId);
		AtfValidator::validateInt(_descr, "brandId", brandId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_RESET_PWD
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD::Protocol_MSG_REGULATOR_RESET_PWD()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD::Protocol_MSG_REGULATOR_RESET_PWD(Protocol_MSG_REGULATOR_RESET_PWD&& _o)
	: resetPwd(std::move(_o.resetPwd))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD& regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD::operator=(Protocol_MSG_REGULATOR_RESET_PWD&& _o)
{
	if(this != &_o)
	{
		resetPwd = std::move(_o.resetPwd);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD::clear()
{
	resetPwd.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD::equals(const Protocol_MSG_REGULATOR_RESET_PWD& _o) const
{
	return resetPwd.equals(_o.resetPwd);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_RESET_PWD).append(")");
	_buf.append(',');
	_buf.append("resetPwd=");
	resetPwd.toTraceString(_buf);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD::composeMsg(CommMsgBody& _msg) const
{
	resetPwd.composeMsg(_msg);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD::parseMsg(CommMsgParser& _parser)
{
	resetPwd.parseMsg(_parser);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_RESET_PWD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	common_structs::ResetPwdMessageStruct::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("resetPwd"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_RESET_PWD_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::Protocol_MSG_REGULATOR_RESET_PWD_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::Protocol_MSG_REGULATOR_RESET_PWD_REPLY(Protocol_MSG_REGULATOR_RESET_PWD_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD_REPLY& regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::operator=(Protocol_MSG_REGULATOR_RESET_PWD_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::equals(const Protocol_MSG_REGULATOR_RESET_PWD_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_RESET_PWD_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_RESET_PWD_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_RETRIEVE_USERID
//=================================================================

regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID::Protocol_MSG_LOBBY_RETRIEVE_USERID()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID::Protocol_MSG_LOBBY_RETRIEVE_USERID(Protocol_MSG_LOBBY_RETRIEVE_USERID&& _o)
	: email(std::move(_o.email))
	, locale(std::move(_o.locale))
	, clientSiteId(std::move(_o.clientSiteId))
{
}

regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID& regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID::operator=(Protocol_MSG_LOBBY_RETRIEVE_USERID&& _o)
{
	if(this != &_o)
	{
		email = std::move(_o.email);
		locale = std::move(_o.locale);
		clientSiteId = std::move(_o.clientSiteId);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID::clear()
{
	email.clear();
	locale = LOCALE_DEFAULT;
	clientSiteId = PokerStars_SiteUnknown;
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID::equals(const Protocol_MSG_LOBBY_RETRIEVE_USERID& _o) const
{
	return email.equals(_o.email) &&
		locale == _o.locale &&
		clientSiteId == _o.clientSiteId;
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_RETRIEVE_USERID).append(")");
	_buf.append(',');
	_buf.append("email=");
	_buf.append(email);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("clientSiteId=");
	_buf.appendUint(clientSiteId);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(email);
	_msg.composeUINT32(locale);
	_msg.composeUINT32(clientSiteId);
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(email);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(locale);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(clientSiteId);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_RETRIEVE_USERID";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "email", szEmail, USER_EMAIL_LEN, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 clientSiteId; _parser.parseUINT32(clientSiteId);
	AtfValidator::validateIntRange(_descr, "clientSiteId", clientSiteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_RETRIEVE_USERID_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID_REPLY::Protocol_MSG_LOBBY_RETRIEVE_USERID_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID_REPLY::Protocol_MSG_LOBBY_RETRIEVE_USERID_REPLY(Protocol_MSG_LOBBY_RETRIEVE_USERID_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, emptyStr(std::move(_o.emptyStr))
	, licenseId(std::move(_o.licenseId))
	, challengeQuestions(std::move(_o.challengeQuestions))
{
}

regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID_REPLY& regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID_REPLY::operator=(Protocol_MSG_LOBBY_RETRIEVE_USERID_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		emptyStr = std::move(_o.emptyStr);
		licenseId = std::move(_o.licenseId);
		challengeQuestions = std::move(_o.challengeQuestions);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	emptyStr.clear();
	licenseId = 0;
	challengeQuestions.clear();
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID_REPLY::equals(const Protocol_MSG_LOBBY_RETRIEVE_USERID_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		emptyStr.equals(_o.emptyStr) &&
		licenseId == _o.licenseId &&
		challengeQuestions.equals(_o.challengeQuestions);
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_RETRIEVE_USERID_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("emptyStr=");
		_buf.append(emptyStr);
	}
	if (errCode == USER_EXISTS_ON_OTHER_LICENSE)
	{
		_buf.append(',');
		_buf.append("licenseId=");
		_buf.appendUint(licenseId);
	}
	if (errCode == CANNOT_RETRIEVE_USERID_STRONG_AUTH_REQD)
	{
		_buf.append(',');
		_buf.append("challengeQuestions=");
		challengeQuestions.toTraceString(_buf);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(emptyStr);
	}
	if (errCode == USER_EXISTS_ON_OTHER_LICENSE)
	{
		_msg.composeUINT32(licenseId);
	}
	if (errCode == CANNOT_RETRIEVE_USERID_STRONG_AUTH_REQD)
	{
		challengeQuestions.composeMsg(_msg);
	}
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(emptyStr);
	}
	if (errCode == USER_EXISTS_ON_OTHER_LICENSE)
	{
		_parser.parseUINT32(licenseId);
	}
	if (errCode == CANNOT_RETRIEVE_USERID_STRONG_AUTH_REQD)
	{
		challengeQuestions.parseMsg(_parser);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_RETRIEVE_USERID_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "emptyStr"); size_t szEmptyStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "emptyStr", szEmptyStr, _checker, __FILE__, __LINE__);
	}
	if (errCode == USER_EXISTS_ON_OTHER_LICENSE)
	{
		UINT32 licenseId; _parser.parseUINT32(licenseId);
		AtfValidator::validateInt(_descr, "licenseId", licenseId, _checker, __FILE__, __LINE__);
	}
	if (errCode == CANNOT_RETRIEVE_USERID_STRONG_AUTH_REQD)
	{
		PString _descbuf;
		int szChallengeQuestions = ThinAtf::LAtfVector< common_structs::ChallengeQuestion, 2 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("challengeQuestions"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "challengeQuestions", szChallengeQuestions, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SMS_RESET_PWD
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD::Protocol_MSG_REGULATOR_SMS_RESET_PWD()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD::Protocol_MSG_REGULATOR_SMS_RESET_PWD(Protocol_MSG_REGULATOR_SMS_RESET_PWD&& _o)
	: user(std::move(_o.user))
	, email(std::move(_o.email))
	, mobile(std::move(_o.mobile))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD& regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD::operator=(Protocol_MSG_REGULATOR_SMS_RESET_PWD&& _o)
{
	if(this != &_o)
	{
		user = std::move(_o.user);
		email = std::move(_o.email);
		mobile = std::move(_o.mobile);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD::clear()
{
	user.clear();
	email.clear();
	mobile.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD::equals(const Protocol_MSG_REGULATOR_SMS_RESET_PWD& _o) const
{
	return user.equals(_o.user) &&
		email.equals(_o.email) &&
		mobile.equals(_o.mobile);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SMS_RESET_PWD).append(")");
	_buf.append(',');
	_buf.append("user=");
	_buf.append(user);
	_buf.append(',');
	_buf.append("email=");
	_buf.append(email);
	_buf.append(',');
	_buf.append("mobile=");
	_buf.append(mobile);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(user);
	_msg.composeString(email);
	_msg.composeString(mobile);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(user);
	_parser.parseStringP(email);
	_parser.parseStringP(mobile);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SMS_RESET_PWD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "user"); size_t szUser = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "user", szUser, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "email", szEmail, USER_EMAIL_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "mobile"); size_t szMobile = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "mobile", szMobile, USER_MOBILE_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SMS_RESET_PWD_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD_REPLY::Protocol_MSG_REGULATOR_SMS_RESET_PWD_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD_REPLY::Protocol_MSG_REGULATOR_SMS_RESET_PWD_REPLY(Protocol_MSG_REGULATOR_SMS_RESET_PWD_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD_REPLY& regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD_REPLY::operator=(Protocol_MSG_REGULATOR_SMS_RESET_PWD_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD_REPLY::equals(const Protocol_MSG_REGULATOR_SMS_RESET_PWD_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SMS_RESET_PWD_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SMS_RESET_PWD_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS(Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS&& _o)
	: userId(std::move(_o.userId))
	, email(std::move(_o.email))
	, locale(std::move(_o.locale))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS& regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS::operator=(Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		email = std::move(_o.email);
		locale = std::move(_o.locale);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS::clear()
{
	userId.clear();
	email.clear();
	locale = 0;
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS::equals(const Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS& _o) const
{
	return userId.equals(_o.userId) &&
		email.equals(_o.email) &&
		locale == _o.locale;
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_PWD_RESET_QUESTIONS).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("email=");
	_buf.append(email);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeString(email);
	_msg.composeUINT32(locale);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseStringP(email);
	_parser.parseUINT32(locale);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_PWD_RESET_QUESTIONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "email", szEmail, USER_EMAIL_LEN, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY(Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, isRM(std::move(_o.isRM))
	, challengeQuestions(std::move(_o.challengeQuestions))
	, allowSMSReset(std::move(_o.allowSMSReset))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY& regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY::operator=(Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		isRM = std::move(_o.isRM);
		challengeQuestions = std::move(_o.challengeQuestions);
		allowSMSReset = std::move(_o.allowSMSReset);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	isRM = false;
	challengeQuestions.clear();
	allowSMSReset = false;
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY::equals(const Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		isRM == _o.isRM &&
		challengeQuestions.equals(_o.challengeQuestions) &&
		allowSMSReset == _o.allowSMSReset;
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("isRM=");
		_buf.appendUint(isRM);
		_buf.append(',');
		_buf.append("challengeQuestions=");
		challengeQuestions.toTraceString(_buf);
		_buf.append(',');
		_buf.append("allowSMSReset=");
		_buf.appendUint(allowSMSReset);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeBOOL(isRM);
		challengeQuestions.composeMsg(_msg);
		_msg.composeBOOL(allowSMSReset);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseBOOL(isRM);
		challengeQuestions.parseMsg(_parser);
		_parser.parseBOOL(allowSMSReset);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool isRM; _parser.parseBOOL(isRM);
		AtfValidator::validateInt(_descr, "isRM", isRM, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szChallengeQuestions = ThinAtf::LAtfVector< common_structs::ChallengeQuestion, 2 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("challengeQuestions"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "challengeQuestions", szChallengeQuestions, _checker, __FILE__, __LINE__);
		bool allowSMSReset; _parser.parseBOOL(allowSMSReset);
		AtfValidator::validateInt(_descr, "allowSMSReset", allowSMSReset, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2(Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2&& _o)
	: userId(std::move(_o.userId))
	, locale(std::move(_o.locale))
	, userIntId(std::move(_o.userIntId))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2& regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2::operator=(Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		locale = std::move(_o.locale);
		userIntId = std::move(_o.userIntId);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2::clear()
{
	userId.clear();
	locale = 0;
	userIntId = 0;
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2::equals(const Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2& _o) const
{
	return userId.equals(_o.userId) &&
		locale == _o.locale &&
		userIntId == _o.userIntId;
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_PWD_RESET_QUESTIONS2).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeUINT32(locale);
	_msg.composeUINT32(userIntId);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseUINT32(locale);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(userIntId);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_PWD_RESET_QUESTIONS2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, 100, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 userIntId; _parser.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY(Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, challengeQuestions(std::move(_o.challengeQuestions))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY& regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY::operator=(Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		challengeQuestions = std::move(_o.challengeQuestions);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	challengeQuestions.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY::equals(const Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		challengeQuestions.equals(_o.challengeQuestions);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("challengeQuestions=");
		challengeQuestions.toTraceString(_buf);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		challengeQuestions.composeMsg(_msg);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		challengeQuestions.parseMsg(_parser);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szChallengeQuestions = ThinAtf::LAtfVector< common_structs::ChallengeQuestion, 2 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("challengeQuestions"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "challengeQuestions", szChallengeQuestions, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD(Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD&& _o)
	: user(std::move(_o.user))
	, answer1(std::move(_o.answer1))
	, answer2(std::move(_o.answer2))
	, ssn4(std::move(_o.ssn4))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD& regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD::operator=(Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD&& _o)
{
	if(this != &_o)
	{
		user = std::move(_o.user);
		answer1 = std::move(_o.answer1);
		answer2 = std::move(_o.answer2);
		ssn4 = std::move(_o.ssn4);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD::clear()
{
	user.clear();
	answer1.clear();
	answer2.clear();
	ssn4.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD::equals(const Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD& _o) const
{
	return user.equals(_o.user) &&
		answer1.equals(_o.answer1) &&
		answer2.equals(_o.answer2) &&
		ssn4.equals(_o.ssn4);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD).append(")");
	_buf.append(',');
	_buf.append("user=");
	_buf.append(user);
	_buf.append(',');
	_buf.append("answer1=");
	_buf.append(answer1);
	_buf.append(',');
	_buf.append("answer2=");
	_buf.append(answer2);
	_buf.append(',');
	_buf.append("ssn4=");
	_buf.append(ssn4);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(user);
	_msg.composeString(answer1);
	_msg.composeString(answer2);
	_msg.composeString(ssn4);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(user);
	_parser.parseStringP(answer1);
	_parser.parseStringP(answer2);
	_parser.parseStringP(ssn4);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "user"); size_t szUser = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "user", szUser, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "answer1"); size_t szAnswer1 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "answer1", szAnswer1, 10000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "answer2"); size_t szAnswer2 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "answer2", szAnswer2, 10000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "ssn4"); size_t szSsn4 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "ssn4", szSsn4, SSN_4_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY(Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY& regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY::operator=(Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY::equals(const Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_RETRIEVE_USERID2
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2::Protocol_MSG_REGULATOR_RETRIEVE_USERID2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2::Protocol_MSG_REGULATOR_RETRIEVE_USERID2(Protocol_MSG_REGULATOR_RETRIEVE_USERID2&& _o)
	: eMail(std::move(_o.eMail))
	, answer1(std::move(_o.answer1))
	, answer2(std::move(_o.answer2))
	, ssn4(std::move(_o.ssn4))
	, locale(std::move(_o.locale))
	, clientSiteId(std::move(_o.clientSiteId))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2& regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2::operator=(Protocol_MSG_REGULATOR_RETRIEVE_USERID2&& _o)
{
	if(this != &_o)
	{
		eMail = std::move(_o.eMail);
		answer1 = std::move(_o.answer1);
		answer2 = std::move(_o.answer2);
		ssn4 = std::move(_o.ssn4);
		locale = std::move(_o.locale);
		clientSiteId = std::move(_o.clientSiteId);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2::clear()
{
	eMail.clear();
	answer1.clear();
	answer2.clear();
	ssn4.clear();
	locale = LOCALE_DEFAULT;
	clientSiteId = PokerStars_SiteUnknown;
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2::equals(const Protocol_MSG_REGULATOR_RETRIEVE_USERID2& _o) const
{
	return eMail.equals(_o.eMail) &&
		answer1.equals(_o.answer1) &&
		answer2.equals(_o.answer2) &&
		ssn4.equals(_o.ssn4) &&
		locale == _o.locale &&
		clientSiteId == _o.clientSiteId;
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_RETRIEVE_USERID2).append(")");
	_buf.append(',');
	_buf.append("eMail=");
	_buf.append(eMail);
	_buf.append(',');
	_buf.append("answer1=");
	_buf.append(answer1);
	_buf.append(',');
	_buf.append("answer2=");
	_buf.append(answer2);
	_buf.append(',');
	_buf.append("ssn4=");
	_buf.append(ssn4);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("clientSiteId=");
	_buf.appendUint(clientSiteId);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(eMail);
	_msg.composeString(answer1);
	_msg.composeString(answer2);
	_msg.composeString(ssn4);
	_msg.composeUINT32(locale);
	_msg.composeUINT32(clientSiteId);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(eMail);
	_parser.parseStringP(answer1);
	_parser.parseStringP(answer2);
	_parser.parseStringP(ssn4);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(locale);
	_parser.parseUINT32(clientSiteId);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_RETRIEVE_USERID2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "eMail"); size_t szEMail = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "eMail", szEMail, USER_EMAIL_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "answer1"); size_t szAnswer1 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "answer1", szAnswer1, 10000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "answer2"); size_t szAnswer2 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "answer2", szAnswer2, 10000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "ssn4"); size_t szSsn4 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "ssn4", szSsn4, SSN_4_LEN, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT32 clientSiteId; _parser.parseUINT32(clientSiteId);
	AtfValidator::validateIntRange(_descr, "clientSiteId", clientSiteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_RETRIEVE_USERID2_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2_REPLY::Protocol_MSG_REGULATOR_RETRIEVE_USERID2_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2_REPLY::Protocol_MSG_REGULATOR_RETRIEVE_USERID2_REPLY(Protocol_MSG_REGULATOR_RETRIEVE_USERID2_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, emptyStr(std::move(_o.emptyStr))
	, licenseId(std::move(_o.licenseId))
	, challengeQuestions(std::move(_o.challengeQuestions))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2_REPLY& regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2_REPLY::operator=(Protocol_MSG_REGULATOR_RETRIEVE_USERID2_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		emptyStr = std::move(_o.emptyStr);
		licenseId = std::move(_o.licenseId);
		challengeQuestions = std::move(_o.challengeQuestions);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	emptyStr.clear();
	licenseId = 0;
	challengeQuestions.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2_REPLY::equals(const Protocol_MSG_REGULATOR_RETRIEVE_USERID2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		emptyStr.equals(_o.emptyStr) &&
		licenseId == _o.licenseId &&
		challengeQuestions.equals(_o.challengeQuestions);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_RETRIEVE_USERID2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("emptyStr=");
		_buf.append(emptyStr);
	}
	if (errCode == USER_EXISTS_ON_OTHER_LICENSE)
	{
		_buf.append(',');
		_buf.append("licenseId=");
		_buf.appendUint(licenseId);
	}
	if (errCode == CANNOT_RETRIEVE_USERID_STRONG_AUTH_REQD)
	{
		_buf.append(',');
		_buf.append("challengeQuestions=");
		challengeQuestions.toTraceString(_buf);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(emptyStr);
	}
	if (errCode == USER_EXISTS_ON_OTHER_LICENSE)
	{
		_msg.composeUINT32(licenseId);
	}
	if (errCode == CANNOT_RETRIEVE_USERID_STRONG_AUTH_REQD)
	{
		challengeQuestions.composeMsg(_msg);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(emptyStr);
	}
	if (errCode == USER_EXISTS_ON_OTHER_LICENSE)
	{
		_parser.parseUINT32(licenseId);
	}
	if (errCode == CANNOT_RETRIEVE_USERID_STRONG_AUTH_REQD)
	{
		challengeQuestions.parseMsg(_parser);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_RETRIEVE_USERID2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "emptyStr"); size_t szEmptyStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "emptyStr", szEmptyStr, _checker, __FILE__, __LINE__);
	}
	if (errCode == USER_EXISTS_ON_OTHER_LICENSE)
	{
		UINT32 licenseId; _parser.parseUINT32(licenseId);
		AtfValidator::validateInt(_descr, "licenseId", licenseId, _checker, __FILE__, __LINE__);
	}
	if (errCode == CANNOT_RETRIEVE_USERID_STRONG_AUTH_REQD)
	{
		PString _descbuf;
		int szChallengeQuestions = ThinAtf::LAtfVector< common_structs::ChallengeQuestion, 2 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("challengeQuestions"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "challengeQuestions", szChallengeQuestions, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS(Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS&& _o)
	: userId(std::move(_o.userId))
	, locale(std::move(_o.locale))
	, clientSiteId(std::move(_o.clientSiteId))
	, userIntId(std::move(_o.userIntId))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS& regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS::operator=(Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		locale = std::move(_o.locale);
		clientSiteId = std::move(_o.clientSiteId);
		userIntId = std::move(_o.userIntId);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS::clear()
{
	userId.clear();
	locale = 0;
	clientSiteId = 0;
	userIntId = 0;
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS::equals(const Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS& _o) const
{
	return userId.equals(_o.userId) &&
		locale == _o.locale &&
		clientSiteId == _o.clientSiteId &&
		userIntId == _o.userIntId;
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("clientSiteId=");
	_buf.appendUint(clientSiteId);
	_buf.append(',');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeUINT32(locale);
	_msg.composeUINT32(clientSiteId);
	_msg.composeUINT32(userIntId);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseUINT32(locale);
	_parser.parseUINT32(clientSiteId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(userIntId);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT32 clientSiteId; _parser.parseUINT32(clientSiteId);
	AtfValidator::validateIntRange(_descr, "clientSiteId", clientSiteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 userIntId; _parser.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY(Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, revalidationMethods(std::move(_o.revalidationMethods))
	, phoneNumber(std::move(_o.phoneNumber))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY& regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY::operator=(Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		revalidationMethods = std::move(_o.revalidationMethods);
		phoneNumber = std::move(_o.phoneNumber);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	revalidationMethods = 0;
	phoneNumber.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY::equals(const Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		revalidationMethods == _o.revalidationMethods &&
		phoneNumber.equals(_o.phoneNumber);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("revalidationMethods=");
		_buf.appendUint(revalidationMethods);
		_buf.append(',');
		_buf.append("phoneNumber=");
		_buf.append(phoneNumber);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(revalidationMethods);
		_msg.composeString(phoneNumber);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(revalidationMethods);
		_parser.parseStringP(phoneNumber);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 revalidationMethods; _parser.parseUINT32(revalidationMethods);
		AtfValidator::validateInt(_descr, "revalidationMethods", revalidationMethods, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "phoneNumber"); size_t szPhoneNumber = strlen(_dummy);
		AtfValidator::validateInt(_descr, "phoneNumber", szPhoneNumber, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION(Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION&& _o)
	: userId(std::move(_o.userId))
	, locale(std::move(_o.locale))
	, clientSiteId(std::move(_o.clientSiteId))
	, revalidationMethod(std::move(_o.revalidationMethod))
	, answer1(std::move(_o.answer1))
	, answer2(std::move(_o.answer2))
	, userIntId(std::move(_o.userIntId))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION& regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION::operator=(Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		locale = std::move(_o.locale);
		clientSiteId = std::move(_o.clientSiteId);
		revalidationMethod = std::move(_o.revalidationMethod);
		answer1 = std::move(_o.answer1);
		answer2 = std::move(_o.answer2);
		userIntId = std::move(_o.userIntId);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION::clear()
{
	userId.clear();
	locale = 0;
	clientSiteId = 0;
	revalidationMethod = 0;
	answer1.clear();
	answer2.clear();
	userIntId = 0;
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION::equals(const Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION& _o) const
{
	return userId.equals(_o.userId) &&
		locale == _o.locale &&
		clientSiteId == _o.clientSiteId &&
		revalidationMethod == _o.revalidationMethod &&
		answer1.equals(_o.answer1) &&
		answer2.equals(_o.answer2) &&
		userIntId == _o.userIntId;
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("clientSiteId=");
	_buf.appendUint(clientSiteId);
	_buf.append(',');
	_buf.append("revalidationMethod=");
	_buf.appendInt(revalidationMethod);
	_buf.append(',');
	_buf.append("answer1=");
	_buf.append(answer1);
	_buf.append(',');
	_buf.append("answer2=");
	_buf.append(answer2);
	_buf.append(',');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeUINT32(locale);
	_msg.composeUINT32(clientSiteId);
	_msg.composeINT32(revalidationMethod);
	_msg.composeString(answer1);
	_msg.composeString(answer2);
	_msg.composeUINT32(userIntId);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseUINT32(locale);
	_parser.parseUINT32(clientSiteId);
	_parser.parseINT32(revalidationMethod);
	_parser.parseStringP(answer1);
	_parser.parseStringP(answer2);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(userIntId);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT32 clientSiteId; _parser.parseUINT32(clientSiteId);
	AtfValidator::validateIntRange(_descr, "clientSiteId", clientSiteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	INT32 revalidationMethod; _parser.parseINT32(revalidationMethod);
	AtfValidator::validateIntRange(_descr, "revalidationMethod", revalidationMethod, eRegulatorRevalidationMethods_None, eRegulatorRevalidationMethods_Last, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "answer1"); size_t szAnswer1 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "answer1", szAnswer1, 10000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "answer2"); size_t szAnswer2 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "answer2", szAnswer2, 10000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 userIntId; _parser.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY(Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY& regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY::operator=(Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY::equals(const Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED(Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED&& _o)
	: userId(std::move(_o.userId))
	, locale(std::move(_o.locale))
	, clientSiteId(std::move(_o.clientSiteId))
	, userIntId(std::move(_o.userIntId))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED& regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED::operator=(Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		locale = std::move(_o.locale);
		clientSiteId = std::move(_o.clientSiteId);
		userIntId = std::move(_o.userIntId);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED::clear()
{
	userId.clear();
	locale = 0;
	clientSiteId = 0;
	userIntId = 0;
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED::equals(const Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED& _o) const
{
	return userId.equals(_o.userId) &&
		locale == _o.locale &&
		clientSiteId == _o.clientSiteId &&
		userIntId == _o.userIntId;
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("clientSiteId=");
	_buf.appendUint(clientSiteId);
	_buf.append(',');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeUINT32(locale);
	_msg.composeUINT32(clientSiteId);
	_msg.composeUINT32(userIntId);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseUINT32(locale);
	_parser.parseUINT32(clientSiteId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(userIntId);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT32 clientSiteId; _parser.parseUINT32(clientSiteId);
	AtfValidator::validateIntRange(_descr, "clientSiteId", clientSiteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 userIntId; _parser.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY(Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY& regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY::operator=(Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY::equals(const Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS(Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS&& _o)
	: userId(std::move(_o.userId))
	, locale(std::move(_o.locale))
	, clientSiteId(std::move(_o.clientSiteId))
	, userIntId(std::move(_o.userIntId))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS& regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS::operator=(Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		locale = std::move(_o.locale);
		clientSiteId = std::move(_o.clientSiteId);
		userIntId = std::move(_o.userIntId);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS::clear()
{
	userId.clear();
	locale = 0;
	clientSiteId = 0;
	userIntId = 0;
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS::equals(const Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS& _o) const
{
	return userId.equals(_o.userId) &&
		locale == _o.locale &&
		clientSiteId == _o.clientSiteId &&
		userIntId == _o.userIntId;
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("clientSiteId=");
	_buf.appendUint(clientSiteId);
	_buf.append(',');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeUINT32(locale);
	_msg.composeUINT32(clientSiteId);
	_msg.composeUINT32(userIntId);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseUINT32(locale);
	_parser.parseUINT32(clientSiteId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(userIntId);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT32 clientSiteId; _parser.parseUINT32(clientSiteId);
	AtfValidator::validateIntRange(_descr, "clientSiteId", clientSiteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 userIntId; _parser.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY(Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY& regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY::operator=(Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY::equals(const Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC(Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC&& _o)
	: userId(std::move(_o.userId))
	, locale(std::move(_o.locale))
	, clientSiteId(std::move(_o.clientSiteId))
	, userIntId(std::move(_o.userIntId))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC& regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC::operator=(Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		locale = std::move(_o.locale);
		clientSiteId = std::move(_o.clientSiteId);
		userIntId = std::move(_o.userIntId);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC::clear()
{
	userId.clear();
	locale = 0;
	clientSiteId = 0;
	userIntId = 0;
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC::equals(const Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC& _o) const
{
	return userId.equals(_o.userId) &&
		locale == _o.locale &&
		clientSiteId == _o.clientSiteId &&
		userIntId == _o.userIntId;
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("clientSiteId=");
	_buf.appendUint(clientSiteId);
	_buf.append(',');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeUINT32(locale);
	_msg.composeUINT32(clientSiteId);
	_msg.composeUINT32(userIntId);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseUINT32(locale);
	_parser.parseUINT32(clientSiteId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(userIntId);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT32 clientSiteId; _parser.parseUINT32(clientSiteId);
	AtfValidator::validateIntRange(_descr, "clientSiteId", clientSiteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 userIntId; _parser.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    MaskedCardNum
//=================================================================

regulator::cli_unauth::MaskedCardNum::MaskedCardNum()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::MaskedCardNum::MaskedCardNum(MaskedCardNum&& _o)
	: paysystem(std::move(_o.paysystem))
	, maskedNum(std::move(_o.maskedNum))
	, whenUsed(std::move(_o.whenUsed))
{
}

regulator::cli_unauth::MaskedCardNum& regulator::cli_unauth::MaskedCardNum::operator=(MaskedCardNum&& _o)
{
	if(this != &_o)
	{
		paysystem = std::move(_o.paysystem);
		maskedNum = std::move(_o.maskedNum);
		whenUsed = std::move(_o.whenUsed);
	}
	return *this;
}

#endif

void regulator::cli_unauth::MaskedCardNum::clear()
{
	paysystem.clear();
	maskedNum.clear();
	whenUsed.setNull();
}

bool regulator::cli_unauth::MaskedCardNum::equals(const MaskedCardNum& _o) const
{
	return paysystem.equals(_o.paysystem) &&
		maskedNum.equals(_o.maskedNum) &&
		whenUsed.equals(_o.whenUsed);
}

const char *regulator::cli_unauth::MaskedCardNum::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("paysystem=");
	_buf.append(paysystem);
	_buf.append(',');
	_buf.append("maskedNum=");
	_buf.append(maskedNum);
	_buf.append(',');
	_buf.append("whenUsed=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, whenUsed);
	_buf.append('}');
	return _buf.c_str();
}

void regulator::cli_unauth::MaskedCardNum::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(paysystem);
	_msg.composeString(maskedNum);
	_msg.composeSrvTime(whenUsed);
}

void regulator::cli_unauth::MaskedCardNum::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(paysystem);
	_parser.parseStringP(maskedNum);
	_parser.parseSrvTime(whenUsed);
}

/*static*/ void regulator::cli_unauth::MaskedCardNum::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "paysystem"); size_t szPaysystem = strlen(_dummy);
	AtfValidator::validateInt(_descr, "paysystem", szPaysystem, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "maskedNum"); size_t szMaskedNum = strlen(_dummy);
	AtfValidator::validateInt(_descr, "maskedNum", szMaskedNum, _checker, __FILE__, __LINE__);
	SrvTime whenUsed; _parser.parseSrvTime(whenUsed);
	AtfValidator::validateSrvDateTime(_descr, "whenUsed", whenUsed, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY(Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, userMaskedCreditCards(std::move(_o.userMaskedCreditCards))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY& regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY::operator=(Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		userMaskedCreditCards = std::move(_o.userMaskedCreditCards);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	userMaskedCreditCards.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY::equals(const Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		userMaskedCreditCards.equals(_o.userMaskedCreditCards);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("userMaskedCreditCards=");
		userMaskedCreditCards.toTraceString(_buf);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		userMaskedCreditCards.composeMsg(_msg);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		userMaskedCreditCards.parseMsg(_parser);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szUserMaskedCreditCards = ThinAtf::LAtfVector< MaskedCardNum, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("userMaskedCreditCards"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "userMaskedCreditCards", szUserMaskedCreditCards, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2(Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2&& _o)
	: userId(std::move(_o.userId))
	, locale(std::move(_o.locale))
	, clientSiteId(std::move(_o.clientSiteId))
	, answers(std::move(_o.answers))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2& regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2::operator=(Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		locale = std::move(_o.locale);
		clientSiteId = std::move(_o.clientSiteId);
		answers = std::move(_o.answers);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2::clear()
{
	userId.clear();
	locale = 0;
	clientSiteId = 0;
	answers.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2::equals(const Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2& _o) const
{
	return userId.equals(_o.userId) &&
		locale == _o.locale &&
		clientSiteId == _o.clientSiteId &&
		answers.equals(_o.answers);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("clientSiteId=");
	_buf.appendUint(clientSiteId);
	_buf.append(',');
	_buf.append("answers=");
	answers.toTraceString(_buf);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeUINT32(locale);
	_msg.composeUINT32(clientSiteId);
	answers.composeMsg(_msg);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseUINT32(locale);
	_parser.parseUINT32(clientSiteId);
	answers.parseMsg(_parser);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT32 clientSiteId; _parser.parseUINT32(clientSiteId);
	AtfValidator::validateIntRange(_descr, "clientSiteId", clientSiteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szAnswers = ThinAtf::LAtfVector< common_structs::ChallengeAnswer, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("answers"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntRange(_descr, "answers", szAnswers, CHALLENGE_ANSWERS_SIZE, CHALLENGE_ANSWERS_SIZE, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY(Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, match(std::move(_o.match))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY& regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY::operator=(Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		match = std::move(_o.match);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	match = false;
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY::equals(const Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		match == _o.match;
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("match=");
		_buf.appendUint(match);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeBOOL(match);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseBOOL(match);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool match; _parser.parseBOOL(match);
		AtfValidator::validateInt(_descr, "match", match, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_REMIND_SID
//=================================================================

regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID::Protocol_MSG_LOBBY_REMIND_SID()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID::Protocol_MSG_LOBBY_REMIND_SID(Protocol_MSG_LOBBY_REMIND_SID&& _o)
	: userId(std::move(_o.userId))
{
}

regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID& regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID::operator=(Protocol_MSG_LOBBY_REMIND_SID&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID::clear()
{
	userId.clear();
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID::equals(const Protocol_MSG_LOBBY_REMIND_SID& _o) const
{
	return userId.equals(_o.userId);
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_REMIND_SID).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_REMIND_SID";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, 100, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_REMIND_SID_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID_REPLY::Protocol_MSG_LOBBY_REMIND_SID_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID_REPLY::Protocol_MSG_LOBBY_REMIND_SID_REPLY(Protocol_MSG_LOBBY_REMIND_SID_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, mobileOrEmail(std::move(_o.mobileOrEmail))
	, viaSMS(std::move(_o.viaSMS))
{
}

regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID_REPLY& regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID_REPLY::operator=(Protocol_MSG_LOBBY_REMIND_SID_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		mobileOrEmail = std::move(_o.mobileOrEmail);
		viaSMS = std::move(_o.viaSMS);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	mobileOrEmail.clear();
	viaSMS = false;
}

bool regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID_REPLY::equals(const Protocol_MSG_LOBBY_REMIND_SID_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		mobileOrEmail.equals(_o.mobileOrEmail) &&
		viaSMS == _o.viaSMS;
}

const char *regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_REMIND_SID_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("mobileOrEmail=");
		_buf.append(mobileOrEmail);
		_buf.append(',');
		_buf.append("viaSMS=");
		_buf.appendUint(viaSMS);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(mobileOrEmail);
		_msg.composeBOOL(viaSMS);
	}
}

void regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(mobileOrEmail);
		_parser.parseBOOL(viaSMS);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_LOBBY_REMIND_SID_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_REMIND_SID_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "mobileOrEmail"); size_t szMobileOrEmail = strlen(_dummy);
		AtfValidator::validateInt(_descr, "mobileOrEmail", szMobileOrEmail, _checker, __FILE__, __LINE__);
		bool viaSMS; _parser.parseBOOL(viaSMS);
		AtfValidator::validateInt(_descr, "viaSMS", viaSMS, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL(Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL&& _o)
	: userIdOrEmail(std::move(_o.userIdOrEmail))
	, locale(std::move(_o.locale))
	, clientSiteId(std::move(_o.clientSiteId))
	, installId(std::move(_o.installId))
	, brandId(std::move(_o.brandId))
	, clientExtra(std::move(_o.clientExtra))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL& regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL::operator=(Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL&& _o)
{
	if(this != &_o)
	{
		userIdOrEmail = std::move(_o.userIdOrEmail);
		locale = std::move(_o.locale);
		clientSiteId = std::move(_o.clientSiteId);
		installId = std::move(_o.installId);
		brandId = std::move(_o.brandId);
		clientExtra = std::move(_o.clientExtra);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL::clear()
{
	userIdOrEmail.clear();
	locale = 0;
	clientSiteId = 0;
	installId.clear();
	brandId = 0;
	clientExtra.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL::equals(const Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL& _o) const
{
	return userIdOrEmail.equals(_o.userIdOrEmail) &&
		locale == _o.locale &&
		clientSiteId == _o.clientSiteId &&
		installId.equals(_o.installId) &&
		brandId == _o.brandId &&
		clientExtra.equals(_o.clientExtra);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL).append(")");
	_buf.append(',');
	_buf.append("userIdOrEmail=");
	_buf.append(userIdOrEmail);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("clientSiteId=");
	_buf.appendUint(clientSiteId);
	_buf.append(',');
	_buf.append("installId=");
	_buf.append(installId);
	_buf.append(',');
	_buf.append("brandId=");
	_buf.appendInt(brandId);
	_buf.append(',');
	_buf.append("clientExtra=");
	clientExtra.toTraceString(_buf);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userIdOrEmail);
	_msg.composeUINT32(locale);
	_msg.composeUINT32(clientSiteId);
	_msg.composeString(installId);
	_msg.composeINT32(brandId);
	clientExtra.composeMsg(_msg);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userIdOrEmail);
	_parser.parseUINT32(locale);
	_parser.parseUINT32(clientSiteId);
	_parser.parseStringP(installId);
	_parser.parseINT32(brandId);
	if(_parser.parseEnded()) return;
	clientExtra.parseMsg(_parser);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userIdOrEmail"); size_t szUserIdOrEmail = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userIdOrEmail", szUserIdOrEmail, 1000, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT32 clientSiteId; _parser.parseUINT32(clientSiteId);
	AtfValidator::validateIntRange(_descr, "clientSiteId", clientSiteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "installId"); size_t szInstallId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "installId", szInstallId, USER_INSTALLID_LEN, _checker, __FILE__, __LINE__);
	INT32 brandId; _parser.parseINT32(brandId);
	AtfValidator::validateIntRange(_descr, "brandId", brandId, BrandType_None, BrandType_Last, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PString _descbuf;
	CommonThin::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientExtra"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY(Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, inputFormat(std::move(_o.inputFormat))
	, eMailMask(std::move(_o.eMailMask))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY& regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY::operator=(Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		inputFormat = std::move(_o.inputFormat);
		eMailMask = std::move(_o.eMailMask);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	inputFormat = 0;
	eMailMask.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY::equals(const Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		inputFormat == _o.inputFormat &&
		eMailMask.equals(_o.eMailMask);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("inputFormat=");
		_buf.appendInt(inputFormat);
		_buf.append(',');
		_buf.append("eMailMask=");
		_buf.append(eMailMask);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(inputFormat);
		_msg.composeString(eMailMask);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(inputFormat);
		_parser.parseStringP(eMailMask);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 inputFormat; _parser.parseINT32(inputFormat);
		AtfValidator::validateInt(_descr, "inputFormat", inputFormat, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "eMailMask"); size_t szEMailMask = strlen(_dummy);
		AtfValidator::validateInt(_descr, "eMailMask", szEMailMask, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD(Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD&& _o)
	: encryptedData(std::move(_o.encryptedData))
	, newPwd(std::move(_o.newPwd))
	, ipAddr(std::move(_o.ipAddr))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD& regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD::operator=(Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD&& _o)
{
	if(this != &_o)
	{
		encryptedData = std::move(_o.encryptedData);
		newPwd = std::move(_o.newPwd);
		ipAddr = std::move(_o.ipAddr);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD::clear()
{
	encryptedData.clear();
	newPwd.clear();
	ipAddr.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD::equals(const Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD& _o) const
{
	return encryptedData.equals(_o.encryptedData) &&
		newPwd.equals(_o.newPwd) &&
		ipAddr.equals(_o.ipAddr);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_WEB_PWD_SET_NEW_PWD).append(")");
	_buf.append(',');
	_buf.append("encryptedData=");
	_buf.append(encryptedData);
	_buf.append(',');
	_buf.append("newPwd=");
	_buf.append(newPwd);
	_buf.append(',');
	_buf.append("ipAddr=");
	_buf.append(ipAddr);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(encryptedData);
	_msg.composeString(newPwd);
	_msg.composeString(ipAddr);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(encryptedData);
	_parser.parseStringP(newPwd);
	_parser.parseStringP(ipAddr);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_WEB_PWD_SET_NEW_PWD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "encryptedData"); size_t szEncryptedData = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "encryptedData", szEncryptedData, 10000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "newPwd"); size_t szNewPwd = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "newPwd", szNewPwd, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "ipAddr"); size_t szIpAddr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "ipAddr", szIpAddr, IP_ADDR_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY(Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY& regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY::operator=(Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY::equals(const Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO(Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO&& _o)
	: encryptedData(std::move(_o.encryptedData))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO& regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO::operator=(Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO&& _o)
{
	if(this != &_o)
	{
		encryptedData = std::move(_o.encryptedData);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO::clear()
{
	encryptedData.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO::equals(const Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO& _o) const
{
	return encryptedData.equals(_o.encryptedData);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO).append(")");
	_buf.append(',');
	_buf.append("encryptedData=");
	_buf.append(encryptedData);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(encryptedData);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(encryptedData);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "encryptedData"); size_t szEncryptedData = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "encryptedData", szEncryptedData, 10000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY(Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, userId(std::move(_o.userId))
	, isRMOK(std::move(_o.isRMOK))
	, userFirstName(std::move(_o.userFirstName))
	, userLastName(std::move(_o.userLastName))
	, userLicenseId(std::move(_o.userLicenseId))
	, tokenExpiry(std::move(_o.tokenExpiry))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY& regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY::operator=(Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		userId = std::move(_o.userId);
		isRMOK = std::move(_o.isRMOK);
		userFirstName = std::move(_o.userFirstName);
		userLastName = std::move(_o.userLastName);
		userLicenseId = std::move(_o.userLicenseId);
		tokenExpiry = std::move(_o.tokenExpiry);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	userId.clear();
	isRMOK = false;
	userFirstName.clear();
	userLastName.clear();
	userLicenseId = 0;
	tokenExpiry.setNull();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY::equals(const Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		userId.equals(_o.userId) &&
		isRMOK == _o.isRMOK &&
		userFirstName.equals(_o.userFirstName) &&
		userLastName.equals(_o.userLastName) &&
		userLicenseId == _o.userLicenseId &&
		tokenExpiry.equals(_o.tokenExpiry);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("userId=");
		_buf.append(userId);
		_buf.append(',');
		_buf.append("isRMOK=");
		_buf.appendUint(isRMOK);
		_buf.append(',');
		_buf.append("userFirstName=");
		_buf.append(userFirstName);
		_buf.append(',');
		_buf.append("userLastName=");
		_buf.append(userLastName);
		_buf.append(',');
		_buf.append("userLicenseId=");
		_buf.appendUint(userLicenseId);
		_buf.append(',');
		_buf.append("tokenExpiry=");
		ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, tokenExpiry);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(userId);
		_msg.composeBOOL(isRMOK);
		_msg.composeString(userFirstName);
		_msg.composeString(userLastName);
		_msg.composeUINT32(userLicenseId);
		_msg.composeSrvTime(tokenExpiry);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(userId);
		_parser.parseBOOL(isRMOK);
		_parser.parseStringP(userFirstName);
		_parser.parseStringP(userLastName);
		_parser.parseUINT32(userLicenseId);
		_parser.parseSrvTime(tokenExpiry);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
		bool isRMOK; _parser.parseBOOL(isRMOK);
		AtfValidator::validateInt(_descr, "isRMOK", isRMOK, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "userFirstName"); size_t szUserFirstName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "userFirstName", szUserFirstName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "userLastName"); size_t szUserLastName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "userLastName", szUserLastName, _checker, __FILE__, __LINE__);
		UINT32 userLicenseId; _parser.parseUINT32(userLicenseId);
		AtfValidator::validateInt(_descr, "userLicenseId", userLicenseId, _checker, __FILE__, __LINE__);
		SrvTime tokenExpiry; _parser.parseSrvTime(tokenExpiry);
		AtfValidator::validateSrvDateTime(_descr, "tokenExpiry", tokenExpiry, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY(Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY&& _o)
	: encryptedData(std::move(_o.encryptedData))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY& regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY::operator=(Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY&& _o)
{
	if(this != &_o)
	{
		encryptedData = std::move(_o.encryptedData);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY::clear()
{
	encryptedData.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY::equals(const Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY& _o) const
{
	return encryptedData.equals(_o.encryptedData);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SET_PRIV_NO_SURVEY).append(")");
	_buf.append(',');
	_buf.append("encryptedData=");
	_buf.append(encryptedData);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(encryptedData);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(encryptedData);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_PRIV_NO_SURVEY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "encryptedData"); size_t szEncryptedData = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "encryptedData", szEncryptedData, 10000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY(Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY& regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY::operator=(Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY::equals(const Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE(Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE&& _o)
	: userId_ignore(std::move(_o.userId_ignore))
	, elements(std::move(_o.elements))
	, locale(std::move(_o.locale))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE& regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::operator=(Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE&& _o)
{
	if(this != &_o)
	{
		userId_ignore = std::move(_o.userId_ignore);
		elements = std::move(_o.elements);
		locale = std::move(_o.locale);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::clear()
{
	userId_ignore.clear();
	elements.clear();
	locale = 0;
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::equals(const Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE& _o) const
{
	return userId_ignore.equals(_o.userId_ignore) &&
		elements.equals(_o.elements) &&
		locale == _o.locale;
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_VALIDATE_USER_UPDATE).append(")");
	_buf.append(',');
	_buf.append("userId_ignore=");
	_buf.append(userId_ignore);
	_buf.append(',');
	_buf.append("elements=");
	elements.toTraceString(_buf);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId_ignore);
	elements.composeMsg(_msg);
	_msg.composeUINT32(locale);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId_ignore);
	elements.parseMsg(_parser);
	_parser.parseUINT32(locale);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_VALIDATE_USER_UPDATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId_ignore"); size_t szUserId_ignore = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId_ignore", szUserId_ignore, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szElements = ThinAtf::LAtfVector< common_structs::UserUpdateElement, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("elements"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "elements", szElements, 1000, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY(Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, validationResults(std::move(_o.validationResults))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY& regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::operator=(Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		validationResults = std::move(_o.validationResults);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::clear()
{
	errCode = 0;
	validationResults.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::equals(const Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		validationResults.equals(_o.validationResults);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("validationResults=");
		validationResults.toTraceString(_buf);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		validationResults.composeMsg(_msg);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		validationResults.parseMsg(_parser);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString _descbuf;
		int szValidationResults = ThinAtf::LAtfVector< common_structs::UserUpdateValidationResult, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("validationResults"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "validationResults", szValidationResults, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_SWISS_URL
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL::Protocol_MSG_REGULATOR_GET_SWISS_URL()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL::Protocol_MSG_REGULATOR_GET_SWISS_URL(Protocol_MSG_REGULATOR_GET_SWISS_URL&& _o)
	: loginExtra(std::move(_o.loginExtra))
	, commonRequest(std::move(_o.commonRequest))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL& regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL::operator=(Protocol_MSG_REGULATOR_GET_SWISS_URL&& _o)
{
	if(this != &_o)
	{
		loginExtra = std::move(_o.loginExtra);
		commonRequest = std::move(_o.commonRequest);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL::clear()
{
	loginExtra.clear();
	commonRequest.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL::equals(const Protocol_MSG_REGULATOR_GET_SWISS_URL& _o) const
{
	return loginExtra.equals(_o.loginExtra) &&
		commonRequest.equals(_o.commonRequest);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_SWISS_URL).append(")");
	_buf.append(',');
	_buf.append("loginExtra=");
	loginExtra.toTraceString(_buf);
	_buf.append(',');
	_buf.append("commonRequest=");
	commonRequest.toTraceString(_buf);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL::composeMsg(CommMsgBody& _msg) const
{
	loginExtra.composeMsg(_msg);
	commonRequest.composeMsg(_msg);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL::parseMsg(CommMsgParser& _parser)
{
	loginExtra.parseMsg(_parser);
	commonRequest.parseMsg(_parser);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_SWISS_URL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	CommonThin::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("loginExtra"), _fieldsWithUnparsedContent);
	common_structs::SwissUrlRequest::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("commonRequest"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY(Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, url(std::move(_o.url))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY& regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::operator=(Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		url = std::move(_o.url);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	url.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::equals(const Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		url.equals(_o.url);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_SWISS_URL_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("url=");
		_buf.append(url);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(url);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(url);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_SWISS_URL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "url"); size_t szUrl = strlen(_dummy);
		AtfValidator::validateInt(_descr, "url", szUrl, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY(Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY&& _o)
	: clientExtra(std::move(_o.clientExtra))
	, country(std::move(_o.country))
	, localeId(std::move(_o.localeId))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY& regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY::operator=(Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY&& _o)
{
	if(this != &_o)
	{
		clientExtra = std::move(_o.clientExtra);
		country = std::move(_o.country);
		localeId = std::move(_o.localeId);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY::clear()
{
	clientExtra.clear();
	country.clear();
	localeId = 0;
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY::equals(const Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY& _o) const
{
	return clientExtra.equals(_o.clientExtra) &&
		country.equals(_o.country) &&
		localeId == _o.localeId;
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY).append(")");
	_buf.append(',');
	_buf.append("clientExtra=");
	clientExtra.toTraceString(_buf);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("localeId=");
	_buf.appendUint(localeId);
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY::composeMsg(CommMsgBody& _msg) const
{
	clientExtra.composeMsg(_msg);
	_msg.composeString(country);
	_msg.composeUINT32(localeId);
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY::parseMsg(CommMsgParser& _parser)
{
	clientExtra.parseMsg(_parser);
	_parser.parseStringP(country);
	_parser.parseUINT32(localeId);
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	PString _descbuf;
	CommonThin::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientExtra"), _fieldsWithUnparsedContent);
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, COUNTRY_CODE_LEN, _checker, __FILE__, __LINE__);
	UINT32 localeId; _parser.parseUINT32(localeId);
	AtfValidator::validateIntMax(_descr, "localeId", localeId, MAX_LOCALES, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY
//=================================================================

regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY(Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY& regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY::operator=(Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY::equals(const Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void regulator::cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_NAME_AVAILABLE
//=================================================================

regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE::Protocol_MSG_LOBBY_NAME_AVAILABLE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE::Protocol_MSG_LOBBY_NAME_AVAILABLE(Protocol_MSG_LOBBY_NAME_AVAILABLE&& _o)
	: reqId(std::move(_o.reqId))
	, body(std::move(_o.body))
{
}

regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE& regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE::operator=(Protocol_MSG_LOBBY_NAME_AVAILABLE&& _o)
{
	if(this != &_o)
	{
		reqId = std::move(_o.reqId);
		body = std::move(_o.body);
	}
	return *this;
}

#endif

void regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE::clear()
{
	reqId = 0;
	body.clear();
}

bool regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE::equals(const Protocol_MSG_LOBBY_NAME_AVAILABLE& _o) const
{
	return reqId == _o.reqId &&
		body.equals(_o.body);
}

const char *regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_NAME_AVAILABLE).append(")");
	_buf.append(',');
	_buf.append("reqId=");
	_buf.appendUint(reqId);
	_buf.append(',');
	_buf.append("body=");
	body.toTraceString(_buf);
	return _buf.c_str();
}

void regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(reqId);
	body.composeMsg(_msg);
}

void regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(reqId);
	body.parseMsg(_parser);
}

/*static*/ void regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_NAME_AVAILABLE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 reqId; _parser.parseUINT32(reqId);
	AtfValidator::validateInt(_descr, "reqId", reqId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	common_structs::LobbyNameAvailableStruct::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("body"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY
//=================================================================

regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY(Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY&& _o)
	: reqId(std::move(_o.reqId))
	, replyBody(std::move(_o.replyBody))
{
}

regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY& regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::operator=(Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY&& _o)
{
	if(this != &_o)
	{
		reqId = std::move(_o.reqId);
		replyBody = std::move(_o.replyBody);
	}
	return *this;
}

#endif

void regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::clear()
{
	reqId = 0;
	replyBody.clear();
}

bool regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::equals(const Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY& _o) const
{
	return reqId == _o.reqId &&
		replyBody.equals(_o.replyBody);
}

const char *regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_NAME_AVAILABLE_REPLY).append(")");
	_buf.append(',');
	_buf.append("reqId=");
	_buf.appendUint(reqId);
	_buf.append(',');
	_buf.append("replyBody=");
	replyBody.toTraceString(_buf);
	return _buf.c_str();
}

void regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(reqId);
	replyBody.composeMsg(_msg);
}

void regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(reqId);
	replyBody.parseMsg(_parser);
}

/*static*/ void regulator::core::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_NAME_AVAILABLE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 reqId; _parser.parseUINT32(reqId);
	AtfValidator::validateInt(_descr, "reqId", reqId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	common_structs::LobbyNameAvailableReplyStruct::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("replyBody"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    AppTypeEssentials
//=================================================================

regulator::core::AppTypeEssentials::AppTypeEssentials()
{
	clear();
}

void regulator::core::AppTypeEssentials::clear()
{
	brandId = BrandType_PokerStars;
	osId = OSId_Unknown;
	appTypeId = AppTypeId_Unknown;
	productId = ProductId_Unknown;
}

bool regulator::core::AppTypeEssentials::equals(const AppTypeEssentials& _o) const
{
	return brandId == _o.brandId &&
		osId == _o.osId &&
		appTypeId == _o.appTypeId &&
		productId == _o.productId;
}

const char *regulator::core::AppTypeEssentials::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("brandId=");
	_buf.appendUint(brandId);
	_buf.append(',');
	_buf.append("osId=");
	_buf.appendUint(osId);
	_buf.append(',');
	_buf.append("appTypeId=");
	_buf.appendUint(appTypeId);
	_buf.append(',');
	_buf.append("productId=");
	_buf.appendUint(productId);
	_buf.append('}');
	return _buf.c_str();
}

void regulator::core::AppTypeEssentials::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(brandId);
	_msg.composeUINT32(osId);
	_msg.composeUINT32(appTypeId);
	_msg.composeUINT32(productId);
}

void regulator::core::AppTypeEssentials::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(brandId);
	_parser.parseUINT32(osId);
	_parser.parseUINT32(appTypeId);
	_parser.parseUINT32(productId);
}

/*static*/ void regulator::core::AppTypeEssentials::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 brandId; _parser.parseUINT32(brandId);
	AtfValidator::validateIntRange(_descr, "brandId", brandId, BrandType_None, BrandType_Last, _checker, __FILE__, __LINE__);
	UINT32 osId; _parser.parseUINT32(osId);
	AtfValidator::validateIntRange(_descr, "osId", osId, OSId_Unknown, OsId_Last, _checker, __FILE__, __LINE__);
	UINT32 appTypeId; _parser.parseUINT32(appTypeId);
	AtfValidator::validateIntRange(_descr, "appTypeId", appTypeId, AppTypeId_Unknown, AppTypeId_Last, _checker, __FILE__, __LINE__);
	UINT32 productId; _parser.parseUINT32(productId);
	AtfValidator::validateIntRange(_descr, "productId", productId, ProductId_Unknown, ProductId_Last, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_REGULATOR_REGISTER_NEW_USER2
//=================================================================

regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2(Protocol_MSG_REGULATOR_REGISTER_NEW_USER2&& _o)
	: reqId(std::move(_o.reqId))
	, ipAddr(std::move(_o.ipAddr))
	, id(std::move(_o.id))
	, facebookIntId(std::move(_o.facebookIntId))
	, email(std::move(_o.email))
	, userInstallId(std::move(_o.userInstallId))
	, addr_1(std::move(_o.addr_1))
	, city(std::move(_o.city))
	, state(std::move(_o.state))
	, country(std::move(_o.country))
	, zipCode(std::move(_o.zipCode))
	, dob(std::move(_o.dob))
	, locale(std::move(_o.locale))
	, firstName(std::move(_o.firstName))
	, lastName(std::move(_o.lastName))
	, sex(std::move(_o.sex))
	, timezone_(std::move(_o.timezone_))
	, clientPlatform(std::move(_o.clientPlatform))
	, clientType(std::move(_o.clientType))
	, clientDevice(std::move(_o.clientDevice))
	, appTypeEssentials(std::move(_o.appTypeEssentials))
	, phone(std::move(_o.phone))
{
}

regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2& regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2::operator=(Protocol_MSG_REGULATOR_REGISTER_NEW_USER2&& _o)
{
	if(this != &_o)
	{
		reqId = std::move(_o.reqId);
		ipAddr = std::move(_o.ipAddr);
		id = std::move(_o.id);
		facebookIntId = std::move(_o.facebookIntId);
		email = std::move(_o.email);
		userInstallId = std::move(_o.userInstallId);
		addr_1 = std::move(_o.addr_1);
		city = std::move(_o.city);
		state = std::move(_o.state);
		country = std::move(_o.country);
		zipCode = std::move(_o.zipCode);
		dob = std::move(_o.dob);
		locale = std::move(_o.locale);
		firstName = std::move(_o.firstName);
		lastName = std::move(_o.lastName);
		sex = std::move(_o.sex);
		timezone_ = std::move(_o.timezone_);
		clientPlatform = std::move(_o.clientPlatform);
		clientType = std::move(_o.clientType);
		clientDevice = std::move(_o.clientDevice);
		appTypeEssentials = std::move(_o.appTypeEssentials);
		phone = std::move(_o.phone);
	}
	return *this;
}

#endif

void regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2::clear()
{
	reqId = 0;
	ipAddr.clear();
	id.clear();
	facebookIntId = 0;
	email.clear();
	userInstallId.clear();
	addr_1.clear();
	city.clear();
	state.clear();
	country.clear();
	zipCode.clear();
	dob.setNull();
	locale = 0;
	firstName.clear();
	lastName.clear();
	sex.clear();
	timezone_ = 0;
	clientPlatform = 0;
	clientType = 0;
	clientDevice = 0;
	appTypeEssentials.clear();
	phone.clear();
}

bool regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2::equals(const Protocol_MSG_REGULATOR_REGISTER_NEW_USER2& _o) const
{
	return reqId == _o.reqId &&
		ipAddr.equals(_o.ipAddr) &&
		id.equals(_o.id) &&
		facebookIntId == _o.facebookIntId &&
		email.equals(_o.email) &&
		userInstallId.equals(_o.userInstallId) &&
		addr_1.equals(_o.addr_1) &&
		city.equals(_o.city) &&
		state.equals(_o.state) &&
		country.equals(_o.country) &&
		zipCode.equals(_o.zipCode) &&
		dob.equals(_o.dob) &&
		locale == _o.locale &&
		firstName.equals(_o.firstName) &&
		lastName.equals(_o.lastName) &&
		sex.equals(_o.sex) &&
		timezone_ == _o.timezone_ &&
		clientPlatform == _o.clientPlatform &&
		clientType == _o.clientType &&
		clientDevice == _o.clientDevice &&
		appTypeEssentials.equals(_o.appTypeEssentials) &&
		phone.equals(_o.phone);
}

const char *regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_REGISTER_NEW_USER2).append(")");
	_buf.append(',');
	_buf.append("reqId=");
	_buf.appendUint(reqId);
	_buf.append(',');
	_buf.append("ipAddr=");
	_buf.append(ipAddr);
	_buf.append(',');
	_buf.append("id=");
	_buf.append(id);
	_buf.append(',');
	_buf.append("facebookIntId=");
	_buf.appendUint64(facebookIntId);
	_buf.append(',');
	_buf.append("email=");
	_buf.append(email);
	_buf.append(',');
	_buf.append("userInstallId=");
	_buf.append(userInstallId);
	_buf.append(',');
	_buf.append("addr_1=");
	_buf.append(addr_1);
	_buf.append(',');
	_buf.append("city=");
	_buf.append(city);
	_buf.append(',');
	_buf.append("state=");
	_buf.append(state);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("zipCode=");
	_buf.append(zipCode);
	_buf.append(',');
	_buf.append("dob=");
	ThinAtf::AtfTempl<CommSrvDate>::ToTraceString(_buf, dob);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("firstName=");
	_buf.append(firstName);
	_buf.append(',');
	_buf.append("lastName=");
	_buf.append(lastName);
	_buf.append(',');
	_buf.append("sex=");
	_buf.append(sex);
	_buf.append(',');
	_buf.append("timezone_=");
	_buf.appendUint(timezone_);
	_buf.append(',');
	_buf.append("clientPlatform=");
	_buf.appendUint(clientPlatform);
	_buf.append(',');
	_buf.append("clientType=");
	_buf.appendUint(clientType);
	_buf.append(',');
	_buf.append("clientDevice=");
	_buf.appendUint(clientDevice);
	_buf.append(',');
	_buf.append("appTypeEssentials=");
	appTypeEssentials.toTraceString(_buf);
	_buf.append(',');
	_buf.append("phone=");
	_buf.append(phone);
	return _buf.c_str();
}

void regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(reqId);
	_msg.composeString(ipAddr);
	_msg.composeString(id);
	_msg.composeUINT64(facebookIntId);
	_msg.composeString(email);
	_msg.composeString(userInstallId);
	_msg.composeString(addr_1);
	_msg.composeString(city);
	_msg.composeString(state);
	_msg.composeString(country);
	_msg.composeString(zipCode);
	_msg.composeSrvDate(dob);
	_msg.composeUINT32(locale);
	_msg.composeString(firstName);
	_msg.composeString(lastName);
	_msg.composeString(sex);
	_msg.composeUINT32(timezone_);
	_msg.composeUINT32(clientPlatform);
	_msg.composeUINT32(clientType);
	_msg.composeUINT32(clientDevice);
	appTypeEssentials.composeMsg(_msg);
	_msg.composeString(phone);
}

void regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(reqId);
	_parser.parseStringP(ipAddr);
	_parser.parseStringP(id);
	_parser.parseUINT64(facebookIntId);
	_parser.parseStringP(email);
	_parser.parseStringP(userInstallId);
	_parser.parseStringP(addr_1);
	_parser.parseStringP(city);
	_parser.parseStringP(state);
	_parser.parseStringP(country);
	_parser.parseStringP(zipCode);
	_parser.parseSrvDate(dob);
	_parser.parseUINT32(locale);
	_parser.parseStringP(firstName);
	_parser.parseStringP(lastName);
	_parser.parseStringP(sex);
	_parser.parseUINT32(timezone_);
	_parser.parseUINT32(clientPlatform);
	_parser.parseUINT32(clientType);
	_parser.parseUINT32(clientDevice);
	if(_parser.parseEnded()) return;
	appTypeEssentials.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(phone);
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_REGISTER_NEW_USER2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 reqId; _parser.parseUINT32(reqId);
	AtfValidator::validateInt(_descr, "reqId", reqId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "ipAddr"); size_t szIpAddr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "ipAddr", szIpAddr, IP_ADDR_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "id"); size_t szId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "id", szId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT64 facebookIntId; _parser.parseUINT64(facebookIntId);
	AtfValidator::validateUint(_descr, "facebookIntId", facebookIntId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "email", szEmail, USER_EMAIL_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userInstallId"); size_t szUserInstallId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userInstallId", szUserInstallId, USER_INSTALLID_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "addr_1"); size_t szAddr_1 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "addr_1", szAddr_1, USER_ADDR_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "city", szCity, USER_CITY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "state"); size_t szState = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "state", szState, USER_STATE_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, USER_COUNTRY_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "zipCode"); size_t szZipCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "zipCode", szZipCode, USER_ZIP_LEN, _checker, __FILE__, __LINE__);
	CommSrvDate dob; _parser.parseSrvDate(dob);
	AtfValidator::validateSrvDateTime(_descr, "dob", dob, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "firstName"); size_t szFirstName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "firstName", szFirstName, USER_FIRST_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "lastName"); size_t szLastName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "lastName", szLastName, USER_LAST_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "sex"); size_t szSex = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "sex", szSex, USER_SEX_LEN, _checker, __FILE__, __LINE__);
	UINT32 timezone_; _parser.parseUINT32(timezone_);
	AtfValidator::validateIntRange(_descr, "timezone_", timezone_, eTzUTC, eTzNumber, _checker, __FILE__, __LINE__);
	UINT32 clientPlatform; _parser.parseUINT32(clientPlatform);
	AtfValidator::validateIntRange(_descr, "clientPlatform", clientPlatform, Client_UnknownPlatform, Client_Last, _checker, __FILE__, __LINE__);
	UINT32 clientType; _parser.parseUINT32(clientType);
	AtfValidator::validateIntRange(_descr, "clientType", clientType, ClientType_Unknown, ClientType_Last, _checker, __FILE__, __LINE__);
	UINT32 clientDevice; _parser.parseUINT32(clientDevice);
	AtfValidator::validateIntRange(_descr, "clientDevice", clientDevice, ClientDevice_Unknown, ClientDevice_Last, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PString _descbuf;
	AppTypeEssentials::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("appTypeEssentials"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "phone"); size_t szPhone = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "phone", szPhone, USER_PHONE_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_REGISTER_NEW_USER2_REPLY
//=================================================================

regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2_REPLY::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2_REPLY::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2_REPLY(Protocol_MSG_REGULATOR_REGISTER_NEW_USER2_REPLY&& _o)
	: reqId(std::move(_o.reqId))
	, errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, userIntId(std::move(_o.userIntId))
{
}

regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2_REPLY& regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2_REPLY::operator=(Protocol_MSG_REGULATOR_REGISTER_NEW_USER2_REPLY&& _o)
{
	if(this != &_o)
	{
		reqId = std::move(_o.reqId);
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		userIntId = std::move(_o.userIntId);
	}
	return *this;
}

#endif

void regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2_REPLY::clear()
{
	reqId = 0;
	errCode = 0;
	errDescr.clear();
	userIntId = 0;
}

bool regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2_REPLY::equals(const Protocol_MSG_REGULATOR_REGISTER_NEW_USER2_REPLY& _o) const
{
	return reqId == _o.reqId &&
		errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		userIntId == _o.userIntId;
}

const char *regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_REGISTER_NEW_USER2_REPLY).append(")");
	_buf.append(',');
	_buf.append("reqId=");
	_buf.appendUint(reqId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("userIntId=");
		_buf.appendUint(userIntId);
	}
	return _buf.c_str();
}

void regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(reqId);
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(userIntId);
	}
}

void regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(reqId);
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(userIntId);
	}
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_REGISTER_NEW_USER2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	UINT32 reqId; _parser.parseUINT32(reqId);
	AtfValidator::validateInt(_descr, "reqId", reqId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 userIntId; _parser.parseUINT32(userIntId);
		AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE
//=================================================================

regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE(Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE&& _o)
	: reqId(std::move(_o.reqId))
	, userId(std::move(_o.userId))
	, email(std::move(_o.email))
{
}

regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE& regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::operator=(Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE&& _o)
{
	if(this != &_o)
	{
		reqId = std::move(_o.reqId);
		userId = std::move(_o.userId);
		email = std::move(_o.email);
	}
	return *this;
}

#endif

void regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::clear()
{
	reqId = 0;
	userId.clear();
	email.clear();
}

bool regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::equals(const Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE& _o) const
{
	return reqId == _o.reqId &&
		userId.equals(_o.userId) &&
		email.equals(_o.email);
}

const char *regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_FACEBOOK_LINK_CODE).append(")");
	_buf.append(',');
	_buf.append("reqId=");
	_buf.appendUint(reqId);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("email=");
	_buf.append(email);
	return _buf.c_str();
}

void regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(reqId);
	_msg.composeString(userId);
	_msg.composeString(email);
}

void regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(reqId);
	_parser.parseStringP(userId);
	_parser.parseStringP(email);
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_FACEBOOK_LINK_CODE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 reqId; _parser.parseUINT32(reqId);
	AtfValidator::validateInt(_descr, "reqId", reqId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "email", szEmail, USER_EMAIL_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY
//=================================================================

regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY(Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY&& _o)
	: reqId(std::move(_o.reqId))
	, errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, facebookLinkCode(std::move(_o.facebookLinkCode))
{
}

regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY& regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::operator=(Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY&& _o)
{
	if(this != &_o)
	{
		reqId = std::move(_o.reqId);
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		facebookLinkCode = std::move(_o.facebookLinkCode);
	}
	return *this;
}

#endif

void regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::clear()
{
	reqId = 0;
	errCode = 0;
	errDescr.clear();
	facebookLinkCode = 0;
}

bool regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::equals(const Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY& _o) const
{
	return reqId == _o.reqId &&
		errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		facebookLinkCode == _o.facebookLinkCode;
}

const char *regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY).append(")");
	_buf.append(',');
	_buf.append("reqId=");
	_buf.appendUint(reqId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("facebookLinkCode=");
		_buf.appendUint(facebookLinkCode);
	}
	return _buf.c_str();
}

void regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(reqId);
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(facebookLinkCode);
	}
}

void regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(reqId);
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(facebookLinkCode);
	}
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	UINT32 reqId; _parser.parseUINT32(reqId);
	AtfValidator::validateInt(_descr, "reqId", reqId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 facebookLinkCode; _parser.parseUINT32(facebookLinkCode);
		AtfValidator::validateInt(_descr, "facebookLinkCode", facebookLinkCode, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK
//=================================================================

regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK(Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK&& _o)
	: reqId(std::move(_o.reqId))
	, userId(std::move(_o.userId))
	, facebookIntId(std::move(_o.facebookIntId))
	, linkCode(std::move(_o.linkCode))
{
}

regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK& regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK::operator=(Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK&& _o)
{
	if(this != &_o)
	{
		reqId = std::move(_o.reqId);
		userId = std::move(_o.userId);
		facebookIntId = std::move(_o.facebookIntId);
		linkCode = std::move(_o.linkCode);
	}
	return *this;
}

#endif

void regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK::clear()
{
	reqId = 0;
	userId.clear();
	facebookIntId = 0;
	linkCode = 0;
}

bool regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK::equals(const Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK& _o) const
{
	return reqId == _o.reqId &&
		userId.equals(_o.userId) &&
		facebookIntId == _o.facebookIntId &&
		linkCode == _o.linkCode;
}

const char *regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CREATE_FACEBOOK_LINK).append(")");
	_buf.append(',');
	_buf.append("reqId=");
	_buf.appendUint(reqId);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("facebookIntId=");
	_buf.appendUint64(facebookIntId);
	_buf.append(',');
	_buf.append("linkCode=");
	_buf.appendUint(linkCode);
	return _buf.c_str();
}

void regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(reqId);
	_msg.composeString(userId);
	_msg.composeUINT64(facebookIntId);
	_msg.composeUINT32(linkCode);
}

void regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(reqId);
	_parser.parseStringP(userId);
	_parser.parseUINT64(facebookIntId);
	_parser.parseUINT32(linkCode);
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CREATE_FACEBOOK_LINK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 reqId; _parser.parseUINT32(reqId);
	AtfValidator::validateInt(_descr, "reqId", reqId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT64 facebookIntId; _parser.parseUINT64(facebookIntId);
	AtfValidator::validateUint(_descr, "facebookIntId", facebookIntId, _checker, __FILE__, __LINE__);
	UINT32 linkCode; _parser.parseUINT32(linkCode);
	AtfValidator::validateInt(_descr, "linkCode", linkCode, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY
//=================================================================

regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY(Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY&& _o)
	: reqId(std::move(_o.reqId))
	, errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, userIntId(std::move(_o.userIntId))
	, userId(std::move(_o.userId))
{
}

regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY& regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY::operator=(Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY&& _o)
{
	if(this != &_o)
	{
		reqId = std::move(_o.reqId);
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		userIntId = std::move(_o.userIntId);
		userId = std::move(_o.userId);
	}
	return *this;
}

#endif

void regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY::clear()
{
	reqId = 0;
	errCode = 0;
	errDescr.clear();
	userIntId = 0;
	userId.clear();
}

bool regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY::equals(const Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY& _o) const
{
	return reqId == _o.reqId &&
		errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		userIntId == _o.userIntId &&
		userId.equals(_o.userId);
}

const char *regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY).append(")");
	_buf.append(',');
	_buf.append("reqId=");
	_buf.appendUint(reqId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("userIntId=");
		_buf.appendUint(userIntId);
		_buf.append(',');
		_buf.append("userId=");
		_buf.append(userId);
	}
	return _buf.c_str();
}

void regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(reqId);
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(userIntId);
		_msg.composeString(userId);
	}
}

void regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(reqId);
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(userIntId);
		_parser.parseStringP(userId);
	}
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	UINT32 reqId; _parser.parseUINT32(reqId);
	AtfValidator::validateInt(_descr, "reqId", reqId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 userIntId; _parser.parseUINT32(userIntId);
		AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SET_COMM_PREFS
//=================================================================

regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS::Protocol_MSG_REGULATOR_SET_COMM_PREFS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS::Protocol_MSG_REGULATOR_SET_COMM_PREFS(Protocol_MSG_REGULATOR_SET_COMM_PREFS&& _o)
	: token(std::move(_o.token))
	, poker(std::move(_o.poker))
	, casino(std::move(_o.casino))
	, sports(std::move(_o.sports))
{
}

regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS& regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS::operator=(Protocol_MSG_REGULATOR_SET_COMM_PREFS&& _o)
{
	if(this != &_o)
	{
		token = std::move(_o.token);
		poker = std::move(_o.poker);
		casino = std::move(_o.casino);
		sports = std::move(_o.sports);
	}
	return *this;
}

#endif

void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS::clear()
{
	token.clear();
	poker = false;
	casino = false;
	sports = false;
}

bool regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS::equals(const Protocol_MSG_REGULATOR_SET_COMM_PREFS& _o) const
{
	return token.equals(_o.token) &&
		poker == _o.poker &&
		casino == _o.casino &&
		sports == _o.sports;
}

const char *regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SET_COMM_PREFS).append(")");
	_buf.append(',');
	_buf.append("token=");
	_buf.append(token);
	_buf.append(',');
	_buf.append("poker=");
	_buf.appendUint(poker);
	_buf.append(',');
	_buf.append("casino=");
	_buf.appendUint(casino);
	_buf.append(',');
	_buf.append("sports=");
	_buf.appendUint(sports);
	return _buf.c_str();
}

void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(token);
	_msg.composeBOOL(poker);
	_msg.composeBOOL(casino);
	_msg.composeBOOL(sports);
}

void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(token);
	_parser.parseBOOL(poker);
	_parser.parseBOOL(casino);
	_parser.parseBOOL(sports);
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_COMM_PREFS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "token"); size_t szToken = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "token", szToken, 4096, _checker, __FILE__, __LINE__);
	bool poker; _parser.parseBOOL(poker);
	AtfValidator::validateInt(_descr, "poker", poker, _checker, __FILE__, __LINE__);
	bool casino; _parser.parseBOOL(casino);
	AtfValidator::validateInt(_descr, "casino", casino, _checker, __FILE__, __LINE__);
	bool sports; _parser.parseBOOL(sports);
	AtfValidator::validateInt(_descr, "sports", sports, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SET_COMM_PREFS_REPLY
//=================================================================

regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_REPLY::Protocol_MSG_REGULATOR_SET_COMM_PREFS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_REPLY::Protocol_MSG_REGULATOR_SET_COMM_PREFS_REPLY(Protocol_MSG_REGULATOR_SET_COMM_PREFS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_REPLY& regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_REPLY::operator=(Protocol_MSG_REGULATOR_SET_COMM_PREFS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_REPLY::equals(const Protocol_MSG_REGULATOR_SET_COMM_PREFS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SET_COMM_PREFS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_COMM_PREFS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_COMM_PREFS
//=================================================================

regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS::Protocol_MSG_REGULATOR_GET_COMM_PREFS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS::Protocol_MSG_REGULATOR_GET_COMM_PREFS(Protocol_MSG_REGULATOR_GET_COMM_PREFS&& _o)
	: token(std::move(_o.token))
{
}

regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS& regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS::operator=(Protocol_MSG_REGULATOR_GET_COMM_PREFS&& _o)
{
	if(this != &_o)
	{
		token = std::move(_o.token);
	}
	return *this;
}

#endif

void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS::clear()
{
	token.clear();
}

bool regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS::equals(const Protocol_MSG_REGULATOR_GET_COMM_PREFS& _o) const
{
	return token.equals(_o.token);
}

const char *regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_COMM_PREFS).append(")");
	_buf.append(',');
	_buf.append("token=");
	_buf.append(token);
	return _buf.c_str();
}

void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(token);
}

void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(token);
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_COMM_PREFS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "token"); size_t szToken = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "token", szToken, 4096, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_COMM_PREFS_REPLY
//=================================================================

regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_REPLY::Protocol_MSG_REGULATOR_GET_COMM_PREFS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_REPLY::Protocol_MSG_REGULATOR_GET_COMM_PREFS_REPLY(Protocol_MSG_REGULATOR_GET_COMM_PREFS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, userId(std::move(_o.userId))
	, poker(std::move(_o.poker))
	, casino(std::move(_o.casino))
	, sports(std::move(_o.sports))
{
}

regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_REPLY& regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_REPLY::operator=(Protocol_MSG_REGULATOR_GET_COMM_PREFS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		userId = std::move(_o.userId);
		poker = std::move(_o.poker);
		casino = std::move(_o.casino);
		sports = std::move(_o.sports);
	}
	return *this;
}

#endif

void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	userId.clear();
	poker = false;
	casino = false;
	sports = false;
}

bool regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_REPLY::equals(const Protocol_MSG_REGULATOR_GET_COMM_PREFS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		userId.equals(_o.userId) &&
		poker == _o.poker &&
		casino == _o.casino &&
		sports == _o.sports;
}

const char *regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_COMM_PREFS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("userId=");
		_buf.append(userId);
		_buf.append(',');
		_buf.append("poker=");
		_buf.appendUint(poker);
		_buf.append(',');
		_buf.append("casino=");
		_buf.appendUint(casino);
		_buf.append(',');
		_buf.append("sports=");
		_buf.appendUint(sports);
	}
	return _buf.c_str();
}

void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(userId);
		_msg.composeBOOL(poker);
		_msg.composeBOOL(casino);
		_msg.composeBOOL(sports);
	}
}

void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(userId);
		_parser.parseBOOL(poker);
		_parser.parseBOOL(casino);
		_parser.parseBOOL(sports);
	}
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_COMM_PREFS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
		bool poker; _parser.parseBOOL(poker);
		AtfValidator::validateInt(_descr, "poker", poker, _checker, __FILE__, __LINE__);
		bool casino; _parser.parseBOOL(casino);
		AtfValidator::validateInt(_descr, "casino", casino, _checker, __FILE__, __LINE__);
		bool sports; _parser.parseBOOL(sports);
		AtfValidator::validateInt(_descr, "sports", sports, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV
//=================================================================

regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV(Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV&& _o)
	: userId(std::move(_o.userId))
	, poker(std::move(_o.poker))
	, casino(std::move(_o.casino))
	, sports(std::move(_o.sports))
{
}

regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV& regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV::operator=(Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		poker = std::move(_o.poker);
		casino = std::move(_o.casino);
		sports = std::move(_o.sports);
	}
	return *this;
}

#endif

void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV::clear()
{
	userId.clear();
	poker = false;
	casino = false;
	sports = false;
}

bool regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV::equals(const Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV& _o) const
{
	return userId.equals(_o.userId) &&
		poker == _o.poker &&
		casino == _o.casino &&
		sports == _o.sports;
}

const char *regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SET_COMM_PREFS_SV).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("poker=");
	_buf.appendUint(poker);
	_buf.append(',');
	_buf.append("casino=");
	_buf.appendUint(casino);
	_buf.append(',');
	_buf.append("sports=");
	_buf.appendUint(sports);
	return _buf.c_str();
}

void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeBOOL(poker);
	_msg.composeBOOL(casino);
	_msg.composeBOOL(sports);
}

void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseBOOL(poker);
	_parser.parseBOOL(casino);
	_parser.parseBOOL(sports);
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_COMM_PREFS_SV";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	bool poker; _parser.parseBOOL(poker);
	AtfValidator::validateInt(_descr, "poker", poker, _checker, __FILE__, __LINE__);
	bool casino; _parser.parseBOOL(casino);
	AtfValidator::validateInt(_descr, "casino", casino, _checker, __FILE__, __LINE__);
	bool sports; _parser.parseBOOL(sports);
	AtfValidator::validateInt(_descr, "sports", sports, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY
//=================================================================

regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY(Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY& regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY::operator=(Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY::equals(const Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV
//=================================================================

regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV()
{
	clear();
}

void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV::clear()
{
	userIntId = 0;
}

bool regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV::equals(const Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV& _o) const
{
	return userIntId == _o.userIntId;
}

const char *regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_COMM_PREFS_SV).append(")");
	_buf.append(',');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	return _buf.c_str();
}

void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(userIntId);
}

void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(userIntId);
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_COMM_PREFS_SV";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 userIntId; _parser.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY
//=================================================================

regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY(Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, userId(std::move(_o.userId))
	, poker(std::move(_o.poker))
	, casino(std::move(_o.casino))
	, sports(std::move(_o.sports))
{
}

regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY& regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY::operator=(Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		userId = std::move(_o.userId);
		poker = std::move(_o.poker);
		casino = std::move(_o.casino);
		sports = std::move(_o.sports);
	}
	return *this;
}

#endif

void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	userId.clear();
	poker = false;
	casino = false;
	sports = false;
}

bool regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY::equals(const Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		userId.equals(_o.userId) &&
		poker == _o.poker &&
		casino == _o.casino &&
		sports == _o.sports;
}

const char *regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("userId=");
		_buf.append(userId);
		_buf.append(',');
		_buf.append("poker=");
		_buf.appendUint(poker);
		_buf.append(',');
		_buf.append("casino=");
		_buf.appendUint(casino);
		_buf.append(',');
		_buf.append("sports=");
		_buf.appendUint(sports);
	}
	return _buf.c_str();
}

void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(userId);
		_msg.composeBOOL(poker);
		_msg.composeBOOL(casino);
		_msg.composeBOOL(sports);
	}
}

void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(userId);
		_parser.parseBOOL(poker);
		_parser.parseBOOL(casino);
		_parser.parseBOOL(sports);
	}
}

/*static*/ void regulator::core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
		bool poker; _parser.parseBOOL(poker);
		AtfValidator::validateInt(_descr, "poker", poker, _checker, __FILE__, __LINE__);
		bool casino; _parser.parseBOOL(casino);
		AtfValidator::validateInt(_descr, "casino", casino, _checker, __FILE__, __LINE__);
		bool sports; _parser.parseBOOL(sports);
		AtfValidator::validateInt(_descr, "sports", sports, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN
//=================================================================

regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN()
{
	clear();
}

void regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN::clear()
{
}

bool regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN::equals(const Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN& _o) const
{
	return true;
}

const char *regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN).append(")");
	return _buf.c_str();
}

void regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN::composeMsg(CommMsgBody& _msg) const
{
}

void regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY
//=================================================================

regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY(Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, token(std::move(_o.token))
	, tokenSignature(std::move(_o.tokenSignature))
	, userIntId(std::move(_o.userIntId))
{
}

regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY& regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY::operator=(Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		token = std::move(_o.token);
		tokenSignature = std::move(_o.tokenSignature);
		userIntId = std::move(_o.userIntId);
	}
	return *this;
}

#endif

void regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	token.clear();
	tokenSignature.clear();
	userIntId = 0;
}

bool regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY::equals(const Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		token.equals(_o.token) &&
		tokenSignature.equals(_o.tokenSignature) &&
		userIntId == _o.userIntId;
}

const char *regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("token=");
		_buf.append(token);
		_buf.append(',');
		_buf.append("tokenSignature=");
		_buf.append(tokenSignature);
		_buf.append(',');
		_buf.append("userIntId=");
		_buf.appendUint(userIntId);
	}
	return _buf.c_str();
}

void regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(token);
		_msg.composeString(tokenSignature);
		_msg.composeUINT32(userIntId);
	}
}

void regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(token);
		_parser.parseStringP(tokenSignature);
		_parser.parseUINT32(userIntId);
	}
}

/*static*/ void regulator::Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "token"); size_t szToken = strlen(_dummy);
		AtfValidator::validateInt(_descr, "token", szToken, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "tokenSignature"); size_t szTokenSignature = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tokenSignature", szTokenSignature, _checker, __FILE__, __LINE__);
		UINT32 userIntId; _parser.parseUINT32(userIntId);
		AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY
//=================================================================

regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY(Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY&& _o)
	: userIdNotUsed(std::move(_o.userIdNotUsed))
{
}

regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY& regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::operator=(Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY&& _o)
{
	if(this != &_o)
	{
		userIdNotUsed = std::move(_o.userIdNotUsed);
	}
	return *this;
}

#endif

void regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::clear()
{
	userIdNotUsed.clear();
}

bool regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::equals(const Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY& _o) const
{
	return userIdNotUsed.equals(_o.userIdNotUsed);
}

const char *regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SUPPORT_EMAIL_READY).append(")");
	_buf.append(',');
	_buf.append("userIdNotUsed=");
	_buf.append(userIdNotUsed);
	return _buf.c_str();
}

void regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userIdNotUsed);
}

void regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseStringP(userIdNotUsed);
}

/*static*/ void regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SUPPORT_EMAIL_READY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "userIdNotUsed"); size_t szUserIdNotUsed = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userIdNotUsed", szUserIdNotUsed, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY
//=================================================================

regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY(Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY& regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::operator=(Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::equals(const Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void regulator::cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL
//=================================================================

regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL(Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL&& _o)
	: body(std::move(_o.body))
{
}

regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL& regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::operator=(Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL&& _o)
{
	if(this != &_o)
	{
		body = std::move(_o.body);
	}
	return *this;
}

#endif

void regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::clear()
{
	body.clear();
}

bool regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::equals(const Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL& _o) const
{
	return body.equals(_o.body);
}

const char *regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL).append(")");
	_buf.append(',');
	_buf.append("body=");
	body.toTraceString(_buf);
	return _buf.c_str();
}

void regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::composeMsg(CommMsgBody& _msg) const
{
	body.composeMsg(_msg);
}

void regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::parseMsg(CommMsgParser& _parser)
{
	body.parseMsg(_parser);
}

/*static*/ void regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	common_structs::LobbyClientToSupportEmailStruct::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("body"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY
//=================================================================

regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY(Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY&& _o)
	: replyBody(std::move(_o.replyBody))
{
}

regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY& regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::operator=(Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY&& _o)
{
	if(this != &_o)
	{
		replyBody = std::move(_o.replyBody);
	}
	return *this;
}

#endif

void regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::clear()
{
	replyBody.clear();
}

bool regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::equals(const Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY& _o) const
{
	return replyBody.equals(_o.replyBody);
}

const char *regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY).append(")");
	_buf.append(',');
	_buf.append("replyBody=");
	replyBody.toTraceString(_buf);
	return _buf.c_str();
}

void regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::composeMsg(CommMsgBody& _msg) const
{
	replyBody.composeMsg(_msg);
}

void regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::parseMsg(CommMsgParser& _parser)
{
	replyBody.parseMsg(_parser);
}

/*static*/ void regulator::cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	common_structs::LobbyClientToSupportEmailReplyStruct::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("replyBody"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ bool regulator::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "Asia"))
	{
		switch(_msgId)
		{
			case MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN: Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY: Asia::Protocol_MSG_REGULATOR_GET_EXTERNAL_OP_TOKEN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED: cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY: cli::Protocol_MSG_CASHIER_LIFETIME_LIMIT_CONFIRMED_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_LOOKUP_FISCAL_CODE: cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY: cli::Protocol_MSG_CASHIER_LOOKUP_FISCAL_CODE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_RMF_BANKACCOUNT: cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY: cli::Protocol_MSG_CASHIER_SET_RMF_BANKACCOUNT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL: cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY: cli::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SAVE_CONSENT: cli::Protocol_MSG_LOBBY_SAVE_CONSENT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SAVE_CONSENT_REPLY: cli::Protocol_MSG_LOBBY_SAVE_CONSENT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SUPPORT_EMAIL_READY: cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY: cli::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_UPDATE_USER2: cli::Protocol_MSG_LOBBY_UPDATE_USER2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_UPDATE_USER2_REPLY: cli::Protocol_MSG_LOBBY_UPDATE_USER2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CHALLENGE_QUESTION: cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CHALLENGE_QUESTION_REPLY: cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED: cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY: cli::Protocol_MSG_REGULATOR_CHALLENGE_QUESTION_SETUP_REFUSED_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE: cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY: cli::Protocol_MSG_REGULATOR_CHECK_USER_DOCUMENT_UNIQUE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE: cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY: cli::Protocol_MSG_REGULATOR_CHECK_USER_FISCALCODE_UNIQUE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CLIENT_FTPLAUNCHER: cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY: cli::Protocol_MSG_REGULATOR_CLIENT_FTPLAUNCHER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CONFIRMED_USER_LIMITS: cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY: cli::Protocol_MSG_REGULATOR_CONFIRMED_USER_LIMITS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR: cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY: cli::Protocol_MSG_REGULATOR_CONVERT_FUNDS_TO_ONE_ACCT_FOR_NJMIGR_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION: cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY: cli::Protocol_MSG_REGULATOR_ES_IDSCAN_DOCUMENT_SUBMISSION_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_EULA_TERMS_SIGNED: cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY: cli::Protocol_MSG_REGULATOR_EULA_TERMS_SIGNED_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION: cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY: cli::Protocol_MSG_REGULATOR_FR_ACC_VAL_PLAYER_ACTION_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM: cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY: cli::Protocol_MSG_REGULATOR_FULLTILT_CONVERSION_PERFORM_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_ASIA_GAMING_URL: cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY: cli::Protocol_MSG_REGULATOR_GET_ASIA_GAMING_URL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_CONFIG_INFO: cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_CONFIG_INFO_REPLY: cli::Protocol_MSG_REGULATOR_GET_CONFIG_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_FACEBOOK_LINK_CODE: cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY: cli::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_FTP_PAIRING_CODE: cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY: cli::Protocol_MSG_REGULATOR_GET_FTP_PAIRING_CODE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_LAST_LOGIN_DETAILS: cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY: cli::Protocol_MSG_REGULATOR_GET_LAST_LOGIN_DETAILS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_SWISS_URL: cli::Protocol_MSG_REGULATOR_GET_SWISS_URL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_SWISS_URL_REPLY: cli::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_USER_BLACKLIST_INFO: cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY: cli::Protocol_MSG_REGULATOR_GET_USER_BLACKLIST_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_USER_SESSION_WINNINGS: cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY: cli::Protocol_MSG_REGULATOR_GET_USER_SESSION_WINNINGS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_USER_WINNINGS: cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_USER_WINNINGS_REPLY: cli::Protocol_MSG_REGULATOR_GET_USER_WINNINGS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_MATCH_ZIP_CODE: cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_MATCH_ZIP_CODE_REPLY: cli::Protocol_MSG_REGULATOR_MATCH_ZIP_CODE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_MIGRATION_CHECK_ONLY: cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY: cli::Protocol_MSG_REGULATOR_MIGRATION_CHECK_ONLY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_MIGRATION_GET_INFO: cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_MIGRATION_GET_INFO_REPLY: cli::Protocol_MSG_REGULATOR_MIGRATION_GET_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_MIGRATION_PERFORM: cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_MIGRATION_PERFORM_REPLY: cli::Protocol_MSG_REGULATOR_MIGRATION_PERFORM_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT: cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY: cli::Protocol_MSG_REGULATOR_REACTIVATE_DORMANT_ACCOUNT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS: cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY: cli::Protocol_MSG_REGULATOR_REMOVE_CHALLENGE_QUESTIONS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_REQUEST_USER_BLACKLISTED: cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY: cli::Protocol_MSG_REGULATOR_REQUEST_USER_BLACKLISTED_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_RESET_PWD: cli::Protocol_MSG_REGULATOR_RESET_PWD::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_RESET_PWD_REPLY: cli::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER: cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY: cli::Protocol_MSG_REGULATOR_SET_CHALLENGE_QUESTIONS_REMINDER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_PROMO_CODE: cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_PROMO_CODE_REPLY: cli::Protocol_MSG_REGULATOR_SET_PROMO_CODE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_PWD_REMINDER: cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_PWD_REMINDER_REPLY: cli::Protocol_MSG_REGULATOR_SET_PWD_REMINDER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_RATE_MOBILE_FLAG: cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY: cli::Protocol_MSG_REGULATOR_SET_RATE_MOBILE_FLAG_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG: cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY: cli::Protocol_MSG_REGULATOR_SET_SHOW_CASINO_GAMES_FLAG_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SE_BANKID_COLLECT: cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SE_BANKID_COLLECT_REPLY: cli::Protocol_MSG_REGULATOR_SE_BANKID_COLLECT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SE_BANKID_VERIFY: cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SE_BANKID_VERIFY_REPLY: cli::Protocol_MSG_REGULATOR_SE_BANKID_VERIFY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_USER_GET_INFO: cli::Protocol_MSG_REGULATOR_USER_GET_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS: cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY: cli::Protocol_MSG_REGULATOR_USER_GET_INFO_NO_ACTIONS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_USER_GET_INFO_REPLY: cli::Protocol_MSG_REGULATOR_USER_GET_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS: cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY: cli::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_VALIDATE_USER_UPDATE: cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY: cli::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "cli_docs"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL: cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY: cli_docs::Protocol_MSG_LOBBY_CLIENT_TO_SUPPORT_EMAIL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SUPPORT_EMAIL_READY: cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY: cli_docs::Protocol_MSG_LOBBY_SUPPORT_EMAIL_READY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "cli_unauth"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_COMPARE_SITE_FOR_IP: cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY: cli_unauth::Protocol_MSG_LOBBY_COMPARE_SITE_FOR_IP_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_NAME_AVAILABLE: cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_NAME_AVAILABLE_REPLY: cli_unauth::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_REGISTER_NEW_USER: cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_REGISTER_NEW_USER_REPLY: cli_unauth::Protocol_MSG_LOBBY_REGISTER_NEW_USER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_REMIND_SID: cli_unauth::Protocol_MSG_LOBBY_REMIND_SID::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_REMIND_SID_REPLY: cli_unauth::Protocol_MSG_LOBBY_REMIND_SID_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP: cli_unauth::Protocol_MSG_LOBBY_REPORT_CREATE_ACCOUNT_GIVE_UP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_RETRIEVE_USERID: cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_RETRIEVE_USERID_REPLY: cli_unauth::Protocol_MSG_LOBBY_RETRIEVE_USERID_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SIGNUP_QUESTIONNAIRE: cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY: cli_unauth::Protocol_MSG_LOBBY_SIGNUP_QUESTIONNAIRE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN: cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY: cli_unauth::Protocol_MSG_REGULATOR_1ST_TIME_FACEBOOK_LOGIN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED: cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY: cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_CANCELLED_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC: cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY: cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_GET_LAST_CC_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS: cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY: cli_unauth::Protocol_MSG_REGULATOR_ACCOUNT_REVALIDATION_SEND_SMS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION: cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY: cli_unauth::Protocol_MSG_REGULATOR_CLEAR_ACCOUNT_REVALIDATION_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD: cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY: cli_unauth::Protocol_MSG_REGULATOR_CLEAR_STRONG_AUTH_REQD_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_EMAIL_AVAILABLE: cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_EMAIL_AVAILABLE_REPLY: cli_unauth::Protocol_MSG_REGULATOR_EMAIL_AVAILABLE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS: cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY: cli_unauth::Protocol_MSG_REGULATOR_GET_AVAIL_REVALIDATION_METHODS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_SWISS_URL: cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_SWISS_URL_REPLY: cli_unauth::Protocol_MSG_REGULATOR_GET_SWISS_URL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_PWD_RESET_QUESTIONS: cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_PWD_RESET_QUESTIONS2: cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY: cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY: cli_unauth::Protocol_MSG_REGULATOR_PWD_RESET_QUESTIONS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_RESET_PWD: cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_RESET_PWD_REPLY: cli_unauth::Protocol_MSG_REGULATOR_RESET_PWD_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_RETRIEVE_USERID2: cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_RETRIEVE_USERID2_REPLY: cli_unauth::Protocol_MSG_REGULATOR_RETRIEVE_USERID2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL: cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY: cli_unauth::Protocol_MSG_REGULATOR_SEND_WEB_PWD_RESET_EMAIL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_PRIV_NO_SURVEY: cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY: cli_unauth::Protocol_MSG_REGULATOR_SET_PRIV_NO_SURVEY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SMS_RESET_PWD: cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SMS_RESET_PWD_REPLY: cli_unauth::Protocol_MSG_REGULATOR_SMS_RESET_PWD_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2: cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY: cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_CHALLENGE_ANSWERS2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY: cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY: cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_REGISTRATION_COUNTRY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_VALIDATE_USER_UPDATE: cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY: cli_unauth::Protocol_MSG_REGULATOR_VALIDATE_USER_UPDATE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO: cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY: cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_GET_TOKEN_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_WEB_PWD_SET_NEW_PWD: cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY: cli_unauth::Protocol_MSG_REGULATOR_WEB_PWD_SET_NEW_PWD_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "core"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_NAME_AVAILABLE: core::Protocol_MSG_LOBBY_NAME_AVAILABLE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_NAME_AVAILABLE_REPLY: core::Protocol_MSG_LOBBY_NAME_AVAILABLE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CREATE_FACEBOOK_LINK: core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY: core::Protocol_MSG_REGULATOR_CREATE_FACEBOOK_LINK_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_COMM_PREFS: core::Protocol_MSG_REGULATOR_GET_COMM_PREFS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_COMM_PREFS_REPLY: core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_COMM_PREFS_SV: core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY: core::Protocol_MSG_REGULATOR_GET_COMM_PREFS_SV_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_FACEBOOK_LINK_CODE: core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY: core::Protocol_MSG_REGULATOR_GET_FACEBOOK_LINK_CODE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_REGISTER_NEW_USER2: core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_REGISTER_NEW_USER2_REPLY: core::Protocol_MSG_REGULATOR_REGISTER_NEW_USER2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_COMM_PREFS: core::Protocol_MSG_REGULATOR_SET_COMM_PREFS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_COMM_PREFS_REPLY: core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_COMM_PREFS_SV: core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY: core::Protocol_MSG_REGULATOR_SET_COMM_PREFS_SV_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

