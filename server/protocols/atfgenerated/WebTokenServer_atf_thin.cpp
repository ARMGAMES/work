/**
 * WebTokenServer_atf_thin.cpp
 *
 * This file was auto-generated from WebTokenServer_atf.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor -thin WebTokenServer_atf.txt
 */
 
#include "WebTokenServer_atf_thin.h"

//=================================================================
//                Protocol_WTS_Q_GET_TOKEN
//=================================================================

WebTokenServer::cli::Protocol_WTS_Q_GET_TOKEN::Protocol_WTS_Q_GET_TOKEN()
{
	clear();
}

void WebTokenServer::cli::Protocol_WTS_Q_GET_TOKEN::clear()
{
	tokenType = eWebTokenTypeCashier;
}

bool WebTokenServer::cli::Protocol_WTS_Q_GET_TOKEN::equals(const Protocol_WTS_Q_GET_TOKEN& _o) const
{
	return tokenType == _o.tokenType;
}

const char *WebTokenServer::cli::Protocol_WTS_Q_GET_TOKEN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(WTS_Q_GET_TOKEN).append(")");
	_buf.append(',');
	_buf.append("tokenType=");
	_buf.appendUint(tokenType);
	return _buf.c_str();
}

void WebTokenServer::cli::Protocol_WTS_Q_GET_TOKEN::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(tokenType);
}

void WebTokenServer::cli::Protocol_WTS_Q_GET_TOKEN::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(tokenType);
}

/*static*/ void WebTokenServer::cli::Protocol_WTS_Q_GET_TOKEN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "WTS_Q_GET_TOKEN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(_parser.parseEnded()) return;
	UINT32 tokenType; _parser.parseUINT32(tokenType);
	AtfValidator::validateIntMax(_descr, "tokenType", tokenType, eWebTokenTypeLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_WTS_A_GET_TOKEN
//=================================================================

WebTokenServer::cli::Protocol_WTS_A_GET_TOKEN::Protocol_WTS_A_GET_TOKEN()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

WebTokenServer::cli::Protocol_WTS_A_GET_TOKEN::Protocol_WTS_A_GET_TOKEN(Protocol_WTS_A_GET_TOKEN&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, token(std::move(_o.token))
	, signature(std::move(_o.signature))
{
}

WebTokenServer::cli::Protocol_WTS_A_GET_TOKEN& WebTokenServer::cli::Protocol_WTS_A_GET_TOKEN::operator=(Protocol_WTS_A_GET_TOKEN&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		token = std::move(_o.token);
		signature = std::move(_o.signature);
	}
	return *this;
}

#endif

void WebTokenServer::cli::Protocol_WTS_A_GET_TOKEN::clear()
{
	errCode = 0;
	errDescr.clear();
	token.clear();
	signature.clear();
}

bool WebTokenServer::cli::Protocol_WTS_A_GET_TOKEN::equals(const Protocol_WTS_A_GET_TOKEN& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		token.equals(_o.token) &&
		signature.equals(_o.signature);
}

const char *WebTokenServer::cli::Protocol_WTS_A_GET_TOKEN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(WTS_A_GET_TOKEN).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("token=");
		_buf.append(token);
		_buf.append(',');
		_buf.append("signature=");
		_buf.append(signature);
	}
	return _buf.c_str();
}

void WebTokenServer::cli::Protocol_WTS_A_GET_TOKEN::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(token);
		_msg.composeString(signature);
	}
}

void WebTokenServer::cli::Protocol_WTS_A_GET_TOKEN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(token);
		_parser.parseStringP(signature);
	}
}

/*static*/ void WebTokenServer::cli::Protocol_WTS_A_GET_TOKEN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "WTS_A_GET_TOKEN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "token"); size_t szToken = strlen(_dummy);
		AtfValidator::validateInt(_descr, "token", szToken, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "signature"); size_t szSignature = strlen(_dummy);
		AtfValidator::validateInt(_descr, "signature", szSignature, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN
//=================================================================

WebTokenServer::cli::Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN::Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

WebTokenServer::cli::Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN::Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN(Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN&& _o)
	: tokenStr(std::move(_o.tokenStr))
{
}

WebTokenServer::cli::Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN& WebTokenServer::cli::Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN::operator=(Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN&& _o)
{
	if(this != &_o)
	{
		tokenStr = std::move(_o.tokenStr);
	}
	return *this;
}

#endif

void WebTokenServer::cli::Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN::clear()
{
	tokenStr.clear();
}

bool WebTokenServer::cli::Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN::equals(const Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN& _o) const
{
	return tokenStr.equals(_o.tokenStr);
}

const char *WebTokenServer::cli::Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN).append(")");
	_buf.append(',');
	_buf.append("tokenStr=");
	_buf.append(tokenStr);
	return _buf.c_str();
}

void WebTokenServer::cli::Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(tokenStr);
}

void WebTokenServer::cli::Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(tokenStr);
}

/*static*/ void WebTokenServer::cli::Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "tokenStr"); size_t szTokenStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "tokenStr", szTokenStr, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN
//=================================================================

WebTokenServer::cli::Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN::Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

WebTokenServer::cli::Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN::Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN(Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

WebTokenServer::cli::Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN& WebTokenServer::cli::Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN::operator=(Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void WebTokenServer::cli::Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool WebTokenServer::cli::Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN::equals(const Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr);
}

const char *WebTokenServer::cli::Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void WebTokenServer::cli::Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void WebTokenServer::cli::Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void WebTokenServer::cli::Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME
//=================================================================

WebTokenServer::cli_unauth::Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME::Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

WebTokenServer::cli_unauth::Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME::Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME(Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME&& _o)
	: userIntId(std::move(_o.userIntId))
	, tokenStr(std::move(_o.tokenStr))
{
}

WebTokenServer::cli_unauth::Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME& WebTokenServer::cli_unauth::Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME::operator=(Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME&& _o)
{
	if(this != &_o)
	{
		userIntId = std::move(_o.userIntId);
		tokenStr = std::move(_o.tokenStr);
	}
	return *this;
}

#endif

void WebTokenServer::cli_unauth::Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME::clear()
{
	userIntId = 0;
	tokenStr.clear();
}

bool WebTokenServer::cli_unauth::Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME::equals(const Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME& _o) const
{
	return userIntId == _o.userIntId &&
		tokenStr.equals(_o.tokenStr);
}

const char *WebTokenServer::cli_unauth::Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(WTS_Q_GET_TOKEN_EXPIRY_TIME).append(")");
	_buf.append(',');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	_buf.append(',');
	_buf.append("tokenStr=");
	_buf.append(tokenStr);
	return _buf.c_str();
}

void WebTokenServer::cli_unauth::Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(userIntId);
	_msg.composeString(tokenStr);
}

void WebTokenServer::cli_unauth::Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(userIntId);
	_parser.parseStringP(tokenStr);
}

/*static*/ void WebTokenServer::cli_unauth::Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "WTS_Q_GET_TOKEN_EXPIRY_TIME";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 userIntId; _parser.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "tokenStr"); size_t szTokenStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "tokenStr", szTokenStr, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME
//=================================================================

WebTokenServer::cli_unauth::Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME::Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

WebTokenServer::cli_unauth::Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME::Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME(Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, tokenValidTimeInSec(std::move(_o.tokenValidTimeInSec))
	, userId(std::move(_o.userId))
{
}

WebTokenServer::cli_unauth::Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME& WebTokenServer::cli_unauth::Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME::operator=(Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		tokenValidTimeInSec = std::move(_o.tokenValidTimeInSec);
		userId = std::move(_o.userId);
	}
	return *this;
}

#endif

void WebTokenServer::cli_unauth::Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME::clear()
{
	errCode = 0;
	errDescr.clear();
	tokenValidTimeInSec = 0;
	userId.clear();
}

bool WebTokenServer::cli_unauth::Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME::equals(const Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		tokenValidTimeInSec == _o.tokenValidTimeInSec &&
		userId.equals(_o.userId);
}

const char *WebTokenServer::cli_unauth::Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(WTS_A_GET_TOKEN_EXPIRY_TIME).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("tokenValidTimeInSec=");
		_buf.appendUint(tokenValidTimeInSec);
		_buf.append(',');
		_buf.append("userId=");
		_buf.append(userId);
	}
	return _buf.c_str();
}

void WebTokenServer::cli_unauth::Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(tokenValidTimeInSec);
		_msg.composeString(userId);
	}
}

void WebTokenServer::cli_unauth::Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(tokenValidTimeInSec);
		_parser.parseStringP(userId);
	}
}

/*static*/ void WebTokenServer::cli_unauth::Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "WTS_A_GET_TOKEN_EXPIRY_TIME";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 tokenValidTimeInSec; _parser.parseUINT32(tokenValidTimeInSec);
		AtfValidator::validateInt(_descr, "tokenValidTimeInSec", tokenValidTimeInSec, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_WTS_Q_VERIFY_PSIP_TOKEN
//=================================================================

WebTokenServer::cli_unauth::Protocol_WTS_Q_VERIFY_PSIP_TOKEN::Protocol_WTS_Q_VERIFY_PSIP_TOKEN()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

WebTokenServer::cli_unauth::Protocol_WTS_Q_VERIFY_PSIP_TOKEN::Protocol_WTS_Q_VERIFY_PSIP_TOKEN(Protocol_WTS_Q_VERIFY_PSIP_TOKEN&& _o)
	: userIntId(std::move(_o.userIntId))
	, tokenStr(std::move(_o.tokenStr))
{
}

WebTokenServer::cli_unauth::Protocol_WTS_Q_VERIFY_PSIP_TOKEN& WebTokenServer::cli_unauth::Protocol_WTS_Q_VERIFY_PSIP_TOKEN::operator=(Protocol_WTS_Q_VERIFY_PSIP_TOKEN&& _o)
{
	if(this != &_o)
	{
		userIntId = std::move(_o.userIntId);
		tokenStr = std::move(_o.tokenStr);
	}
	return *this;
}

#endif

void WebTokenServer::cli_unauth::Protocol_WTS_Q_VERIFY_PSIP_TOKEN::clear()
{
	userIntId = 0;
	tokenStr.clear();
}

bool WebTokenServer::cli_unauth::Protocol_WTS_Q_VERIFY_PSIP_TOKEN::equals(const Protocol_WTS_Q_VERIFY_PSIP_TOKEN& _o) const
{
	return userIntId == _o.userIntId &&
		tokenStr.equals(_o.tokenStr);
}

const char *WebTokenServer::cli_unauth::Protocol_WTS_Q_VERIFY_PSIP_TOKEN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(WTS_Q_VERIFY_PSIP_TOKEN).append(")");
	_buf.append(',');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	_buf.append(',');
	_buf.append("tokenStr=");
	_buf.append(tokenStr);
	return _buf.c_str();
}

void WebTokenServer::cli_unauth::Protocol_WTS_Q_VERIFY_PSIP_TOKEN::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(userIntId);
	_msg.composeString(tokenStr);
}

void WebTokenServer::cli_unauth::Protocol_WTS_Q_VERIFY_PSIP_TOKEN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(userIntId);
	_parser.parseStringP(tokenStr);
}

/*static*/ void WebTokenServer::cli_unauth::Protocol_WTS_Q_VERIFY_PSIP_TOKEN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "WTS_Q_VERIFY_PSIP_TOKEN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 userIntId; _parser.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "tokenStr"); size_t szTokenStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "tokenStr", szTokenStr, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_WTS_A_VERIFY_PSIP_TOKEN
//=================================================================

WebTokenServer::cli_unauth::Protocol_WTS_A_VERIFY_PSIP_TOKEN::Protocol_WTS_A_VERIFY_PSIP_TOKEN()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

WebTokenServer::cli_unauth::Protocol_WTS_A_VERIFY_PSIP_TOKEN::Protocol_WTS_A_VERIFY_PSIP_TOKEN(Protocol_WTS_A_VERIFY_PSIP_TOKEN&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, userId(std::move(_o.userId))
{
}

WebTokenServer::cli_unauth::Protocol_WTS_A_VERIFY_PSIP_TOKEN& WebTokenServer::cli_unauth::Protocol_WTS_A_VERIFY_PSIP_TOKEN::operator=(Protocol_WTS_A_VERIFY_PSIP_TOKEN&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		userId = std::move(_o.userId);
	}
	return *this;
}

#endif

void WebTokenServer::cli_unauth::Protocol_WTS_A_VERIFY_PSIP_TOKEN::clear()
{
	errCode = 0;
	errDescr.clear();
	userId.clear();
}

bool WebTokenServer::cli_unauth::Protocol_WTS_A_VERIFY_PSIP_TOKEN::equals(const Protocol_WTS_A_VERIFY_PSIP_TOKEN& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		userId.equals(_o.userId);
}

const char *WebTokenServer::cli_unauth::Protocol_WTS_A_VERIFY_PSIP_TOKEN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(WTS_A_VERIFY_PSIP_TOKEN).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("userId=");
		_buf.append(userId);
	}
	return _buf.c_str();
}

void WebTokenServer::cli_unauth::Protocol_WTS_A_VERIFY_PSIP_TOKEN::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(userId);
	}
}

void WebTokenServer::cli_unauth::Protocol_WTS_A_VERIFY_PSIP_TOKEN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(userId);
	}
}

/*static*/ void WebTokenServer::cli_unauth::Protocol_WTS_A_VERIFY_PSIP_TOKEN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "WTS_A_VERIFY_PSIP_TOKEN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_WTS_U_APP_SESSION_LOGOUT
//=================================================================

WebTokenServer::notifications::Protocol_WTS_U_APP_SESSION_LOGOUT::Protocol_WTS_U_APP_SESSION_LOGOUT()
{
	clear();
}

void WebTokenServer::notifications::Protocol_WTS_U_APP_SESSION_LOGOUT::clear()
{
	appSessionId = 0;
	userIntId = 0;
}

bool WebTokenServer::notifications::Protocol_WTS_U_APP_SESSION_LOGOUT::equals(const Protocol_WTS_U_APP_SESSION_LOGOUT& _o) const
{
	return appSessionId == _o.appSessionId &&
		userIntId == _o.userIntId;
}

const char *WebTokenServer::notifications::Protocol_WTS_U_APP_SESSION_LOGOUT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(WTS_U_APP_SESSION_LOGOUT).append(")");
	_buf.append(',');
	_buf.append("appSessionId=");
	_buf.appendUint64(appSessionId);
	_buf.append(',');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	return _buf.c_str();
}

void WebTokenServer::notifications::Protocol_WTS_U_APP_SESSION_LOGOUT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT64(appSessionId);
	_msg.composeUINT32(userIntId);
}

void WebTokenServer::notifications::Protocol_WTS_U_APP_SESSION_LOGOUT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(appSessionId);
	_parser.parseUINT32(userIntId);
}

/*static*/ void WebTokenServer::notifications::Protocol_WTS_U_APP_SESSION_LOGOUT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "WTS_U_APP_SESSION_LOGOUT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT64 appSessionId; _parser.parseUINT64(appSessionId);
	AtfValidator::validateUint(_descr, "appSessionId", appSessionId, _checker, __FILE__, __LINE__);
	UINT32 userIntId; _parser.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ bool WebTokenServer::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case WTS_A_GET_TOKEN: cli::Protocol_WTS_A_GET_TOKEN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN: cli::Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case WTS_Q_GET_TOKEN: cli::Protocol_WTS_Q_GET_TOKEN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN: cli::Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "cli_unauth"))
	{
		switch(_msgId)
		{
			case WTS_A_GET_TOKEN_EXPIRY_TIME: cli_unauth::Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case WTS_A_VERIFY_PSIP_TOKEN: cli_unauth::Protocol_WTS_A_VERIFY_PSIP_TOKEN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case WTS_Q_GET_TOKEN_EXPIRY_TIME: cli_unauth::Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case WTS_Q_VERIFY_PSIP_TOKEN: cli_unauth::Protocol_WTS_Q_VERIFY_PSIP_TOKEN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "notifications"))
	{
		switch(_msgId)
		{
			case WTS_U_APP_SESSION_LOGOUT: notifications::Protocol_WTS_U_APP_SESSION_LOGOUT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

