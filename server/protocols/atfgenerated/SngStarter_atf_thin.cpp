/**
 * SngStarter_atf_thin.cpp
 *
 * This file was auto-generated from SngStarter_atf.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor -thin SngStarter_atf.txt
 */
 
#include "SngStarter_atf_thin.h"

//=================================================================
//                Protocol_MSG_LOBBY_TOURN_REG_INFO
//=================================================================

SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::Protocol_MSG_LOBBY_TOURN_REG_INFO()
{
	clear();
}

void SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::clear()
{
	scriptId = 0;
	numGames = 0;
	tournRegInfoFlags = 0;
}

bool SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::equals(const Protocol_MSG_LOBBY_TOURN_REG_INFO& _o) const
{
	return scriptId == _o.scriptId &&
		numGames == _o.numGames &&
		tournRegInfoFlags == _o.tournRegInfoFlags;
}

const char *SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_TOURN_REG_INFO).append(")");
	_buf.append(',');
	_buf.append("scriptId=");
	_buf.appendUint(scriptId);
	_buf.append(',');
	_buf.append("numGames=");
	_buf.appendUint(numGames);
	_buf.append(',');
	_buf.append("tournRegInfoFlags=");
	_buf.appendUint(tournRegInfoFlags);
	return _buf.c_str();
}

void SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(scriptId);
	_msg.composeBYTE(numGames);
	_msg.composeUINT32(tournRegInfoFlags);
}

void SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(scriptId);
	_parser.parseBYTE(numGames);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(tournRegInfoFlags);
}

/*static*/ void SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TOURN_REG_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 scriptId; _parser.parseUINT32(scriptId);
	AtfValidator::validateInt(_descr, "scriptId", scriptId, _checker, __FILE__, __LINE__);
	BYTE numGames; _parser.parseBYTE(numGames);
	AtfValidator::validateIntRange(_descr, "numGames", numGames, 1, ATF_SNG_MAX_REG_GAMES, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 tournRegInfoFlags; _parser.parseUINT32(tournRegInfoFlags);
	AtfValidator::validateInt(_descr, "tournRegInfoFlags", tournRegInfoFlags, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_SNG_POOL_CHECKIN
//=================================================================

SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN::Protocol_MSG_SNG_POOL_CHECKIN()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN::Protocol_MSG_SNG_POOL_CHECKIN(Protocol_MSG_SNG_POOL_CHECKIN&& _o)
	: userId(std::move(_o.userId))
	, buyInRM(std::move(_o.buyInRM))
	, buyInPlay(std::move(_o.buyInPlay))
	, buyInFpp(std::move(_o.buyInFpp))
	, tournPwd(std::move(_o.tournPwd))
	, useTicket(std::move(_o.useTicket))
	, buyInT(std::move(_o.buyInT))
	, buyInW(std::move(_o.buyInW))
	, currencyContext(std::move(_o.currencyContext))
	, scriptId(std::move(_o.scriptId))
	, numGames(std::move(_o.numGames))
	, admissionPrice(std::move(_o.admissionPrice))
	, admissions(std::move(_o.admissions))
{
}

SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN& SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN::operator=(Protocol_MSG_SNG_POOL_CHECKIN&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		buyInRM = std::move(_o.buyInRM);
		buyInPlay = std::move(_o.buyInPlay);
		buyInFpp = std::move(_o.buyInFpp);
		tournPwd = std::move(_o.tournPwd);
		useTicket = std::move(_o.useTicket);
		buyInT = std::move(_o.buyInT);
		buyInW = std::move(_o.buyInW);
		currencyContext = std::move(_o.currencyContext);
		scriptId = std::move(_o.scriptId);
		numGames = std::move(_o.numGames);
		admissionPrice = std::move(_o.admissionPrice);
		admissions = std::move(_o.admissions);
	}
	return *this;
}

#endif

void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN::clear()
{
	userId.clear();
	buyInRM = 0;
	buyInPlay = 0;
	buyInFpp = 0;
	tournPwd.clear();
	useTicket = 0;
	buyInT = 0;
	buyInW = 0;
	currencyContext.clear();
	scriptId = 0;
	numGames = 0;
	admissionPrice = 0;
	admissions.clear();
}

bool SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN::equals(const Protocol_MSG_SNG_POOL_CHECKIN& _o) const
{
	return userId.equals(_o.userId) &&
		buyInRM == _o.buyInRM &&
		buyInPlay == _o.buyInPlay &&
		buyInFpp == _o.buyInFpp &&
		tournPwd.equals(_o.tournPwd) &&
		useTicket == _o.useTicket &&
		buyInT == _o.buyInT &&
		buyInW == _o.buyInW &&
		currencyContext.equals(_o.currencyContext) &&
		scriptId == _o.scriptId &&
		numGames == _o.numGames &&
		admissionPrice == _o.admissionPrice &&
		admissions.equals(_o.admissions);
}

const char *SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_SNG_POOL_CHECKIN).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("buyInRM=");
	_buf.appendInt(buyInRM);
	_buf.append(',');
	_buf.append("buyInPlay=");
	_buf.appendInt(buyInPlay);
	_buf.append(',');
	_buf.append("buyInFpp=");
	_buf.appendInt(buyInFpp);
	_buf.append(',');
	_buf.append("tournPwd=");
	_buf.append(tournPwd);
	_buf.append(',');
	_buf.append("useTicket=");
	_buf.appendUint(useTicket);
	_buf.append(',');
	_buf.append("buyInT=");
	_buf.appendInt(buyInT);
	_buf.append(',');
	_buf.append("buyInW=");
	_buf.appendInt(buyInW);
	_buf.append(',');
	_buf.append("currencyContext=");
	currencyContext.toTraceString(_buf);
	_buf.append(',');
	_buf.append("scriptId=");
	_buf.appendUint(scriptId);
	_buf.append(',');
	_buf.append("numGames=");
	_buf.appendUint(numGames);
	_buf.append(',');
	_buf.append("admissionPrice=");
	_buf.appendInt64(admissionPrice);
	_buf.append(',');
	_buf.append("admissions=");
	admissions.toTraceString(_buf);
	return _buf.c_str();
}

void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeINT32(buyInRM);
	_msg.composeINT32(buyInPlay);
	_msg.composeINT32(buyInFpp);
	_msg.composeString(tournPwd);
	_msg.composeBYTE(useTicket);
	_msg.composeINT32(buyInT);
	_msg.composeINT32(buyInW);
	_msg.composeMsgBody(currencyContext);
	_msg.composeUINT32(scriptId);
	_msg.composeBYTE(numGames);
	_msg.composeINT64(admissionPrice);
	admissions.composeMsg(_msg);
}

void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseINT32(buyInRM);
	_parser.parseINT32(buyInPlay);
	_parser.parseINT32(buyInFpp);
	_parser.parseStringP(tournPwd);
	_parser.parseBYTE(useTicket);
	_parser.parseINT32(buyInT);
	_parser.parseINT32(buyInW);
	_parser.parseMsgBody(currencyContext);
	_parser.parseUINT32(scriptId);
	_parser.parseBYTE(numGames);
	_parser.parseINT64(admissionPrice);
	admissions.parseMsg(_parser);
}

/*static*/ void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_SNG_POOL_CHECKIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, ATF_USER_NAME_MAX_LENGTH, _checker, __FILE__, __LINE__);
	INT32 buyInRM; _parser.parseINT32(buyInRM);
	AtfValidator::validateIntRange(_descr, "buyInRM", buyInRM, 0, ATF_SNG_MAX_BUYIN_REAL, _checker, __FILE__, __LINE__);
	INT32 buyInPlay; _parser.parseINT32(buyInPlay);
	AtfValidator::validateIntRange(_descr, "buyInPlay", buyInPlay, 0, ATF_SNG_MAX_BUYIN_PM, _checker, __FILE__, __LINE__);
	INT32 buyInFpp; _parser.parseINT32(buyInFpp);
	AtfValidator::validateIntRange(_descr, "buyInFpp", buyInFpp, 0, ATF_SNG_MAX_BUYIN_FPP, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "tournPwd"); size_t szTournPwd = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "tournPwd", szTournPwd, ATF_SNG_MAX_PASSWORD_LEN, _checker, __FILE__, __LINE__);
	BYTE useTicket; _parser.parseBYTE(useTicket);
	AtfValidator::validateIntRange(_descr, "useTicket", useTicket, 0, 1, _checker, __FILE__, __LINE__);
	INT32 buyInT; _parser.parseINT32(buyInT);
	AtfValidator::validateIntRange(_descr, "buyInT", buyInT, 0, ATF_SNG_MAX_BUYIN_REAL, _checker, __FILE__, __LINE__);
	INT32 buyInW; _parser.parseINT32(buyInW);
	AtfValidator::validateIntRange(_descr, "buyInW", buyInW, 0, 0, _checker, __FILE__, __LINE__);
	size_t szCurrencyContext; _parser.skipMsgBody(szCurrencyContext);  /*currencyContext*/
	AtfValidator::validateIntMax(_descr, "currencyContext", szCurrencyContext, 10000, _checker, __FILE__, __LINE__);
	UINT32 scriptId; _parser.parseUINT32(scriptId);
	AtfValidator::validateInt(_descr, "scriptId", scriptId, _checker, __FILE__, __LINE__);
	BYTE numGames; _parser.parseBYTE(numGames);
	AtfValidator::validateIntRange(_descr, "numGames", numGames, 1, ATF_SNG_MAX_REG_GAMES, _checker, __FILE__, __LINE__);
	INT64 admissionPrice; _parser.parseINT64(admissionPrice);
	AtfValidator::validateIntRange(_descr, "admissionPrice", admissionPrice, 0, ATF_SNG_MAX_ADMISSION_PRICE, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szAdmissions = ThinAtf::LAtfVector< CommonThin::AtfShared::UserTicketDataBase, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("admissions"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "admissions", szAdmissions, ATF_SNG_MAX_ADMISSIONS, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_SNG_POOL_CHECKOUT
//=================================================================

SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT::Protocol_MSG_SNG_POOL_CHECKOUT()
{
	clear();
}

void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT::clear()
{
	scriptId = 0;
}

bool SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT::equals(const Protocol_MSG_SNG_POOL_CHECKOUT& _o) const
{
	return scriptId == _o.scriptId;
}

const char *SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_SNG_POOL_CHECKOUT).append(")");
	_buf.append(',');
	_buf.append("scriptId=");
	_buf.appendUint(scriptId);
	return _buf.c_str();
}

void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(scriptId);
}

void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(scriptId);
}

/*static*/ void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_SNG_POOL_CHECKOUT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 scriptId; _parser.parseUINT32(scriptId);
	AtfValidator::validateInt(_descr, "scriptId", scriptId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER
//=================================================================

SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER(Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER&& _o)
	: userId(std::move(_o.userId))
{
}

SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER& SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER::operator=(Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
	}
	return *this;
}

#endif

void SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER::clear()
{
	userId.clear();
}

bool SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER::equals(const Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER& _o) const
{
	return userId.equals(_o.userId);
}

const char *SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_SNG_POOL_WHERE_IS_PLAYER).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	return _buf.c_str();
}

void SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
}

void SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
}

/*static*/ void SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_SNG_POOL_WHERE_IS_PLAYER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, 100, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    UserTicketDataATF
//=================================================================

SngStarter::cli::UserTicketDataATF::UserTicketDataATF()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

SngStarter::cli::UserTicketDataATF::UserTicketDataATF(UserTicketDataATF&& _o)
	: admissionId(std::move(_o.admissionId))
	, totalCount(std::move(_o.totalCount))
	, reserved(std::move(_o.reserved))
{
}

SngStarter::cli::UserTicketDataATF& SngStarter::cli::UserTicketDataATF::operator=(UserTicketDataATF&& _o)
{
	if(this != &_o)
	{
		admissionId = std::move(_o.admissionId);
		totalCount = std::move(_o.totalCount);
		reserved = std::move(_o.reserved);
	}
	return *this;
}

#endif

void SngStarter::cli::UserTicketDataATF::clear()
{
	admissionId.clear();
	totalCount = 0;
	reserved = 0;
}

bool SngStarter::cli::UserTicketDataATF::equals(const UserTicketDataATF& _o) const
{
	return admissionId.equals(_o.admissionId) &&
		totalCount == _o.totalCount &&
		reserved == _o.reserved;
}

const char *SngStarter::cli::UserTicketDataATF::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("admissionId=");
	_buf.append(admissionId);
	_buf.append(',');
	_buf.append("totalCount=");
	_buf.appendUint(totalCount);
	_buf.append(',');
	_buf.append("reserved=");
	_buf.appendUint(reserved);
	_buf.append('}');
	return _buf.c_str();
}

void SngStarter::cli::UserTicketDataATF::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(admissionId);
	_msg.composeUINT32(totalCount);
	_msg.composeUINT32(reserved);
}

void SngStarter::cli::UserTicketDataATF::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(admissionId);
	_parser.parseUINT32(totalCount);
	_parser.parseUINT32(reserved);
}

/*static*/ void SngStarter::cli::UserTicketDataATF::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "admissionId"); size_t szAdmissionId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "admissionId", szAdmissionId, _checker, __FILE__, __LINE__);
	UINT32 totalCount; _parser.parseUINT32(totalCount);
	AtfValidator::validateInt(_descr, "totalCount", totalCount, _checker, __FILE__, __LINE__);
	UINT32 reserved; _parser.parseUINT32(reserved);
	AtfValidator::validateInt(_descr, "reserved", reserved, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY
//=================================================================

SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY(Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errMsg(std::move(_o.errMsg))
	, buyin(std::move(_o.buyin))
	, rake(std::move(_o.rake))
	, fppBuyin(std::move(_o.fppBuyin))
	, admission(std::move(_o.admission))
	, pm(std::move(_o.pm))
	, pwd(std::move(_o.pwd))
	, chips(std::move(_o.chips))
	, playChips32(std::move(_o.playChips32))
	, fpp(std::move(_o.fpp))
	, tickets(std::move(_o.tickets))
	, tchips(std::move(_o.tchips))
	, notused(std::move(_o.notused))
	, preRegistrMessage(std::move(_o.preRegistrMessage))
	, game(std::move(_o.game))
	, isHiLo(std::move(_o.isHiLo))
	, structure(std::move(_o.structure))
	, currency(std::move(_o.currency))
	, enoughMoneyInOtherCurrency(std::move(_o.enoughMoneyInOtherCurrency))
	, currencyContext(std::move(_o.currencyContext))
	, clientCurrencyContext(std::move(_o.clientCurrencyContext))
	, whenStartAbs(std::move(_o.whenStartAbs))
	, name(std::move(_o.name))
	, playChips(std::move(_o.playChips))
	, scalePM(std::move(_o.scalePM))
	, speedDisplay(std::move(_o.speedDisplay))
	, minPlayers(std::move(_o.minPlayers))
	, maxPlayers(std::move(_o.maxPlayers))
	, maxPerTable(std::move(_o.maxPerTable))
	, tournFlags(std::move(_o.tournFlags))
	, knockout(std::move(_o.knockout))
	, boolValue(std::move(_o.boolValue))
	, admissionPrice(std::move(_o.admissionPrice))
	, effectiveAdmissions(std::move(_o.effectiveAdmissions))
	, tournFlags2(std::move(_o.tournFlags2))
{
}

SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY& SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::operator=(Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errMsg = std::move(_o.errMsg);
		buyin = std::move(_o.buyin);
		rake = std::move(_o.rake);
		fppBuyin = std::move(_o.fppBuyin);
		admission = std::move(_o.admission);
		pm = std::move(_o.pm);
		pwd = std::move(_o.pwd);
		chips = std::move(_o.chips);
		playChips32 = std::move(_o.playChips32);
		fpp = std::move(_o.fpp);
		tickets = std::move(_o.tickets);
		tchips = std::move(_o.tchips);
		notused = std::move(_o.notused);
		preRegistrMessage = std::move(_o.preRegistrMessage);
		game = std::move(_o.game);
		isHiLo = std::move(_o.isHiLo);
		structure = std::move(_o.structure);
		currency = std::move(_o.currency);
		enoughMoneyInOtherCurrency = std::move(_o.enoughMoneyInOtherCurrency);
		currencyContext = std::move(_o.currencyContext);
		clientCurrencyContext = std::move(_o.clientCurrencyContext);
		whenStartAbs = std::move(_o.whenStartAbs);
		name = std::move(_o.name);
		playChips = std::move(_o.playChips);
		scalePM = std::move(_o.scalePM);
		speedDisplay = std::move(_o.speedDisplay);
		minPlayers = std::move(_o.minPlayers);
		maxPlayers = std::move(_o.maxPlayers);
		maxPerTable = std::move(_o.maxPerTable);
		tournFlags = std::move(_o.tournFlags);
		knockout = std::move(_o.knockout);
		boolValue = std::move(_o.boolValue);
		admissionPrice = std::move(_o.admissionPrice);
		effectiveAdmissions = std::move(_o.effectiveAdmissions);
		tournFlags2 = std::move(_o.tournFlags2);
	}
	return *this;
}

#endif

void SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::clear()
{
	errCode = 0;
	errMsg.clear();
	buyin = 0;
	rake = 0;
	fppBuyin = 0;
	admission.clear();
	pm = 0;
	pwd = 0;
	chips = 0;
	playChips32 = 0;
	fpp = 0;
	tickets = 0;
	tchips = 0;
	notused = 0;
	preRegistrMessage.clear();
	game = 0;
	isHiLo = 0;
	structure = 0;
	currency.clear();
	enoughMoneyInOtherCurrency = false;
	currencyContext.clear();
	clientCurrencyContext.clear();
	whenStartAbs.setNull();
	name.clear();
	playChips = 0;
	scalePM = 0;
	speedDisplay = 0;
	minPlayers = 0;
	maxPlayers = 0;
	maxPerTable = 0;
	tournFlags = 0;
	knockout = 0;
	boolValue = false;
	admissionPrice = 0;
	effectiveAdmissions.clear();
	tournFlags2 = 0;
}

bool SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::equals(const Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errMsg.equals(_o.errMsg) &&
		buyin == _o.buyin &&
		rake == _o.rake &&
		fppBuyin == _o.fppBuyin &&
		admission.equals(_o.admission) &&
		pm == _o.pm &&
		pwd == _o.pwd &&
		chips == _o.chips &&
		playChips32 == _o.playChips32 &&
		fpp == _o.fpp &&
		tickets == _o.tickets &&
		tchips == _o.tchips &&
		notused == _o.notused &&
		preRegistrMessage.equals(_o.preRegistrMessage) &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		structure == _o.structure &&
		currency.equals(_o.currency) &&
		enoughMoneyInOtherCurrency == _o.enoughMoneyInOtherCurrency &&
		currencyContext.equals(_o.currencyContext) &&
		clientCurrencyContext.equals(_o.clientCurrencyContext) &&
		whenStartAbs.equals(_o.whenStartAbs) &&
		name.equals(_o.name) &&
		playChips == _o.playChips &&
		scalePM == _o.scalePM &&
		speedDisplay == _o.speedDisplay &&
		minPlayers == _o.minPlayers &&
		maxPlayers == _o.maxPlayers &&
		maxPerTable == _o.maxPerTable &&
		tournFlags == _o.tournFlags &&
		knockout == _o.knockout &&
		boolValue == _o.boolValue &&
		admissionPrice == _o.admissionPrice &&
		effectiveAdmissions.equals(_o.effectiveAdmissions) &&
		tournFlags2 == _o.tournFlags2;
}

const char *SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_TOURN_REG_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != DBM_NO_ERROR )
	{
		_buf.append(',');
		_buf.append("errMsg=");
		_buf.append(errMsg);
	}
	else
	{
		_buf.append(',');
		_buf.append("buyin=");
		_buf.appendUint(buyin);
		_buf.append(',');
		_buf.append("rake=");
		_buf.appendUint(rake);
		_buf.append(',');
		_buf.append("fppBuyin=");
		_buf.appendUint(fppBuyin);
		_buf.append(',');
		_buf.append("admission=");
		_buf.append(admission);
		_buf.append(',');
		_buf.append("pm=");
		_buf.appendUint(pm);
		_buf.append(',');
		_buf.append("pwd=");
		_buf.appendUint(pwd);
		_buf.append(',');
		_buf.append("chips=");
		_buf.appendUint(chips);
		_buf.append(',');
		_buf.append("playChips32=");
		_buf.appendUint(playChips32);
		_buf.append(',');
		_buf.append("fpp=");
		_buf.appendUint(fpp);
		_buf.append(',');
		_buf.append("tickets=");
		_buf.appendUint(tickets);
		_buf.append(',');
		_buf.append("tchips=");
		_buf.appendUint(tchips);
		_buf.append(',');
		_buf.append("notused=");
		_buf.appendUint(notused);
		_buf.append(',');
		_buf.append("preRegistrMessage=");
		_buf.append(preRegistrMessage);
		_buf.append(',');
		_buf.append("game=");
		_buf.appendUint(game);
		_buf.append(',');
		_buf.append("isHiLo=");
		_buf.appendUint(isHiLo);
		_buf.append(',');
		_buf.append("structure=");
		_buf.appendUint(structure);
		_buf.append(',');
		_buf.append("currency=");
		_buf.append(currency);
		_buf.append(',');
		_buf.append("enoughMoneyInOtherCurrency=");
		_buf.appendUint(enoughMoneyInOtherCurrency);
		_buf.append(',');
		_buf.append("currencyContext=");
		currencyContext.toTraceString(_buf);
		_buf.append(',');
		_buf.append("clientCurrencyContext=");
		clientCurrencyContext.toTraceString(_buf);
		_buf.append(',');
		_buf.append("whenStartAbs=");
		ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, whenStartAbs);
		_buf.append(',');
		_buf.append("name=");
		_buf.append(name);
		_buf.append(',');
		_buf.append("playChips=");
		_buf.appendUint64(playChips);
		_buf.append(',');
		_buf.append("scalePM=");
		_buf.appendUint(scalePM);
		_buf.append(',');
		_buf.append("speedDisplay=");
		_buf.appendUint(speedDisplay);
		_buf.append(',');
		_buf.append("minPlayers=");
		_buf.appendUint(minPlayers);
		_buf.append(',');
		_buf.append("maxPlayers=");
		_buf.appendUint(maxPlayers);
		_buf.append(',');
		_buf.append("maxPerTable=");
		_buf.appendUint(maxPerTable);
		_buf.append(',');
		_buf.append("tournFlags=");
		_buf.appendUint(tournFlags);
		_buf.append(',');
		_buf.append("knockout=");
		_buf.appendUint(knockout);
		_buf.append(',');
		_buf.append("boolValue=");
		_buf.appendUint(boolValue);
		_buf.append(',');
		_buf.append("admissionPrice=");
		_buf.appendInt64(admissionPrice);
		_buf.append(',');
		_buf.append("effectiveAdmissions=");
		effectiveAdmissions.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tournFlags2=");
		_buf.appendUint64(tournFlags2);
	}
	return _buf.c_str();
}

void SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode != DBM_NO_ERROR )
	{
		_msg.composeString(errMsg);
	}
	else
	{
		_msg.composeUINT32(buyin);
		_msg.composeUINT32(rake);
		_msg.composeUINT32(fppBuyin);
		_msg.composeString(admission);
		_msg.composeBYTE(pm);
		_msg.composeBYTE(pwd);
		_msg.composeUINT32(chips);
		_msg.composeUINT32(playChips32);
		_msg.composeUINT32(fpp);
		_msg.composeUINT32(tickets);
		_msg.composeUINT32(tchips);
		_msg.composeUINT32(notused);
		_msg.composeString(preRegistrMessage);
		_msg.composeBYTE(game);
		_msg.composeBYTE(isHiLo);
		_msg.composeBYTE(structure);
		_msg.composeString(currency);
		_msg.composeBOOL(enoughMoneyInOtherCurrency);
		_msg.composeMsgBody(currencyContext);
		_msg.composeMsgBody(clientCurrencyContext);
		_msg.composeSrvTime(whenStartAbs);
		_msg.composeString(name);
		_msg.composeUINT64(playChips);
		_msg.composeUINT32(scalePM);
		_msg.composeBYTE(speedDisplay);
		_msg.composeUINT32(minPlayers);
		_msg.composeUINT32(maxPlayers);
		_msg.composeBYTE(maxPerTable);
		_msg.composeUINT32(tournFlags);
		_msg.composeUINT32(knockout);
		_msg.composeBOOL(boolValue);
		_msg.composeINT64(admissionPrice);
		effectiveAdmissions.composeMsg(_msg);
		_msg.composeUINT64(tournFlags2);
	}
}

void SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != DBM_NO_ERROR )
	{
		_parser.parseStringP(errMsg);
	}
	else
	{
		_parser.parseUINT32(buyin);
		_parser.parseUINT32(rake);
		_parser.parseUINT32(fppBuyin);
		_parser.parseStringP(admission);
		_parser.parseBYTE(pm);
		_parser.parseBYTE(pwd);
		_parser.parseUINT32(chips);
		_parser.parseUINT32(playChips32);
		_parser.parseUINT32(fpp);
		_parser.parseUINT32(tickets);
		_parser.parseUINT32(tchips);
		_parser.parseUINT32(notused);
		_parser.parseStringP(preRegistrMessage);
		_parser.parseBYTE(game);
		_parser.parseBYTE(isHiLo);
		_parser.parseBYTE(structure);
		_parser.parseStringP(currency);
		_parser.parseBOOL(enoughMoneyInOtherCurrency);
		_parser.parseMsgBody(currencyContext);
		_parser.parseMsgBody(clientCurrencyContext);
		_parser.parseSrvTime(whenStartAbs);
		_parser.parseStringP(name);
		_parser.parseUINT64(playChips);
		_parser.parseUINT32(scalePM);
		_parser.parseBYTE(speedDisplay);
		_parser.parseUINT32(minPlayers);
		_parser.parseUINT32(maxPlayers);
		_parser.parseBYTE(maxPerTable);
		_parser.parseUINT32(tournFlags);
		_parser.parseUINT32(knockout);
		_parser.parseBOOL(boolValue);
		_parser.parseINT64(admissionPrice);
		effectiveAdmissions.parseMsg(_parser);
		_parser.parseUINT64(tournFlags2);
	}
}

/*static*/ void SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TOURN_REG_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != DBM_NO_ERROR )
	{
		_parser.parseStringN(_dummy, 0, "errMsg"); size_t szErrMsg = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errMsg", szErrMsg, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 buyin; _parser.parseUINT32(buyin);
		AtfValidator::validateInt(_descr, "buyin", buyin, _checker, __FILE__, __LINE__);
		UINT32 rake; _parser.parseUINT32(rake);
		AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
		UINT32 fppBuyin; _parser.parseUINT32(fppBuyin);
		AtfValidator::validateInt(_descr, "fppBuyin", fppBuyin, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "admission"); size_t szAdmission = strlen(_dummy);
		AtfValidator::validateInt(_descr, "admission", szAdmission, _checker, __FILE__, __LINE__);
		BYTE pm; _parser.parseBYTE(pm);
		AtfValidator::validateInt(_descr, "pm", pm, _checker, __FILE__, __LINE__);
		BYTE pwd; _parser.parseBYTE(pwd);
		AtfValidator::validateInt(_descr, "pwd", pwd, _checker, __FILE__, __LINE__);
		UINT32 chips; _parser.parseUINT32(chips);
		AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
		UINT32 playChips32; _parser.parseUINT32(playChips32);
		AtfValidator::validateInt(_descr, "playChips32", playChips32, _checker, __FILE__, __LINE__);
		UINT32 fpp; _parser.parseUINT32(fpp);
		AtfValidator::validateInt(_descr, "fpp", fpp, _checker, __FILE__, __LINE__);
		UINT32 tickets; _parser.parseUINT32(tickets);
		AtfValidator::validateInt(_descr, "tickets", tickets, _checker, __FILE__, __LINE__);
		UINT32 tchips; _parser.parseUINT32(tchips);
		AtfValidator::validateInt(_descr, "tchips", tchips, _checker, __FILE__, __LINE__);
		UINT32 notused; _parser.parseUINT32(notused);
		AtfValidator::validateInt(_descr, "notused", notused, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "preRegistrMessage"); size_t szPreRegistrMessage = strlen(_dummy);
		AtfValidator::validateInt(_descr, "preRegistrMessage", szPreRegistrMessage, _checker, __FILE__, __LINE__);
		BYTE game; _parser.parseBYTE(game);
		AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
		BYTE isHiLo; _parser.parseBYTE(isHiLo);
		AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
		BYTE structure; _parser.parseBYTE(structure);
		AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
		bool enoughMoneyInOtherCurrency; _parser.parseBOOL(enoughMoneyInOtherCurrency);
		AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _checker, __FILE__, __LINE__);
		size_t szCurrencyContext; _parser.skipMsgBody(szCurrencyContext);  /*currencyContext*/
		AtfValidator::validateInt(_descr, "currencyContext", szCurrencyContext, _checker, __FILE__, __LINE__);
		size_t szClientCurrencyContext; _parser.skipMsgBody(szClientCurrencyContext);  /*clientCurrencyContext*/
		AtfValidator::validateInt(_descr, "clientCurrencyContext", szClientCurrencyContext, _checker, __FILE__, __LINE__);
		SrvTime whenStartAbs; _parser.parseSrvTime(whenStartAbs);
		AtfValidator::validateSrvDateTime(_descr, "whenStartAbs", whenStartAbs, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
		UINT64 playChips; _parser.parseUINT64(playChips);
		AtfValidator::validateUint(_descr, "playChips", playChips, _checker, __FILE__, __LINE__);
		UINT32 scalePM; _parser.parseUINT32(scalePM);
		AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
		BYTE speedDisplay; _parser.parseBYTE(speedDisplay);
		AtfValidator::validateInt(_descr, "speedDisplay", speedDisplay, _checker, __FILE__, __LINE__);
		UINT32 minPlayers; _parser.parseUINT32(minPlayers);
		AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
		UINT32 maxPlayers; _parser.parseUINT32(maxPlayers);
		AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
		BYTE maxPerTable; _parser.parseBYTE(maxPerTable);
		AtfValidator::validateInt(_descr, "maxPerTable", maxPerTable, _checker, __FILE__, __LINE__);
		UINT32 tournFlags; _parser.parseUINT32(tournFlags);
		AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
		UINT32 knockout; _parser.parseUINT32(knockout);
		AtfValidator::validateInt(_descr, "knockout", knockout, _checker, __FILE__, __LINE__);
		bool boolValue; _parser.parseBOOL(boolValue);
		AtfValidator::validateInt(_descr, "boolValue", boolValue, _checker, __FILE__, __LINE__);
		INT64 admissionPrice; _parser.parseINT64(admissionPrice);
		AtfValidator::validateInt(_descr, "admissionPrice", admissionPrice, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szEffectiveAdmissions = ThinAtf::LAtfVector< UserTicketDataATF, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("effectiveAdmissions"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "effectiveAdmissions", szEffectiveAdmissions, _checker, __FILE__, __LINE__);
		UINT64 tournFlags2; _parser.parseUINT64(tournFlags2);
		AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_SNG_POOL_CHECKIN_REPLY
//=================================================================

SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN_REPLY::Protocol_MSG_SNG_POOL_CHECKIN_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN_REPLY::Protocol_MSG_SNG_POOL_CHECKIN_REPLY(Protocol_MSG_SNG_POOL_CHECKIN_REPLY&& _o)
	: scriptId(std::move(_o.scriptId))
	, errCode(std::move(_o.errCode))
	, errMsg(std::move(_o.errMsg))
	, totalGamesNow(std::move(_o.totalGamesNow))
	, tournId(std::move(_o.tournId))
	, sampleAddress(std::move(_o.sampleAddress))
	, buyIn(std::move(_o.buyIn))
	, fppBuyIn(std::move(_o.fppBuyIn))
	, rake(std::move(_o.rake))
	, game(std::move(_o.game))
	, hiLo(std::move(_o.hiLo))
	, structure(std::move(_o.structure))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, icurrency(std::move(_o.icurrency))
	, scalePM(std::move(_o.scalePM))
	, name(std::move(_o.name))
{
}

SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN_REPLY& SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN_REPLY::operator=(Protocol_MSG_SNG_POOL_CHECKIN_REPLY&& _o)
{
	if(this != &_o)
	{
		scriptId = std::move(_o.scriptId);
		errCode = std::move(_o.errCode);
		errMsg = std::move(_o.errMsg);
		totalGamesNow = std::move(_o.totalGamesNow);
		tournId = std::move(_o.tournId);
		sampleAddress = std::move(_o.sampleAddress);
		buyIn = std::move(_o.buyIn);
		fppBuyIn = std::move(_o.fppBuyIn);
		rake = std::move(_o.rake);
		game = std::move(_o.game);
		hiLo = std::move(_o.hiLo);
		structure = std::move(_o.structure);
		isPlayMoney = std::move(_o.isPlayMoney);
		icurrency = std::move(_o.icurrency);
		scalePM = std::move(_o.scalePM);
		name = std::move(_o.name);
	}
	return *this;
}

#endif

void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN_REPLY::clear()
{
	scriptId = 0;
	errCode = 0;
	errMsg.clear();
	totalGamesNow = 0;
	tournId = 0;
	sampleAddress.clear();
	buyIn = 0;
	fppBuyIn = 0;
	rake = 0;
	game = 0;
	hiLo = 0;
	structure = 0;
	isPlayMoney = 0;
	icurrency.clear();
	scalePM = 0;
	name.clear();
}

bool SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN_REPLY::equals(const Protocol_MSG_SNG_POOL_CHECKIN_REPLY& _o) const
{
	return scriptId == _o.scriptId &&
		errCode == _o.errCode &&
		errMsg.equals(_o.errMsg) &&
		totalGamesNow == _o.totalGamesNow &&
		tournId == _o.tournId &&
		sampleAddress.equals(_o.sampleAddress) &&
		buyIn == _o.buyIn &&
		fppBuyIn == _o.fppBuyIn &&
		rake == _o.rake &&
		game == _o.game &&
		hiLo == _o.hiLo &&
		structure == _o.structure &&
		isPlayMoney == _o.isPlayMoney &&
		icurrency.equals(_o.icurrency) &&
		scalePM == _o.scalePM &&
		name.equals(_o.name);
}

const char *SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_SNG_POOL_CHECKIN_REPLY).append(")");
	_buf.append(',');
	_buf.append("scriptId=");
	_buf.appendUint(scriptId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != DBM_NO_ERROR )
	{
		_buf.append(',');
		_buf.append("errMsg=");
		_buf.append(errMsg);
	}
	else
	{
		_buf.append(',');
		_buf.append("totalGamesNow=");
		_buf.appendUint(totalGamesNow);
		_buf.append(',');
		_buf.append("tournId=");
		_buf.appendUint(tournId);
		_buf.append(',');
		_buf.append("sampleAddress=");
		_buf.append(sampleAddress);
		_buf.append(',');
		_buf.append("buyIn=");
		_buf.appendUint(buyIn);
		_buf.append(',');
		_buf.append("fppBuyIn=");
		_buf.appendUint(fppBuyIn);
		_buf.append(',');
		_buf.append("rake=");
		_buf.appendUint(rake);
		_buf.append(',');
		_buf.append("game=");
		_buf.appendUint(game);
		_buf.append(',');
		_buf.append("hiLo=");
		_buf.appendUint(hiLo);
		_buf.append(',');
		_buf.append("structure=");
		_buf.appendUint(structure);
		_buf.append(',');
		_buf.append("isPlayMoney=");
		_buf.appendUint(isPlayMoney);
		_buf.append(',');
		_buf.append("icurrency=");
		_buf.append(icurrency);
		_buf.append(',');
		_buf.append("scalePM=");
		_buf.appendUint(scalePM);
		_buf.append(',');
		_buf.append("name=");
		_buf.append(name);
	}
	return _buf.c_str();
}

void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(scriptId);
	_msg.composeINT16(errCode);
	if( errCode != DBM_NO_ERROR )
	{
		_msg.composeString(errMsg);
	}
	else
	{
		_msg.composeBYTE(totalGamesNow);
		_msg.composeUINT32(tournId);
		_msg.composeString(sampleAddress);
		_msg.composeUINT32(buyIn);
		_msg.composeUINT32(fppBuyIn);
		_msg.composeUINT32(rake);
		_msg.composeBYTE(game);
		_msg.composeBYTE(hiLo);
		_msg.composeBYTE(structure);
		_msg.composeBYTE(isPlayMoney);
		_msg.composeString(icurrency);
		_msg.composeUINT32(scalePM);
		_msg.composeString(name);
	}
}

void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(scriptId);
	_parser.parseINT16(errCode);
	if( errCode != DBM_NO_ERROR )
	{
		_parser.parseStringP(errMsg);
	}
	else
	{
		_parser.parseBYTE(totalGamesNow);
		_parser.parseUINT32(tournId);
		_parser.parseStringP(sampleAddress);
		_parser.parseUINT32(buyIn);
		_parser.parseUINT32(fppBuyIn);
		_parser.parseUINT32(rake);
		_parser.parseBYTE(game);
		_parser.parseBYTE(hiLo);
		_parser.parseBYTE(structure);
		_parser.parseBYTE(isPlayMoney);
		_parser.parseStringP(icurrency);
		_parser.parseUINT32(scalePM);
		_parser.parseStringP(name);
	}
}

/*static*/ void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_SNG_POOL_CHECKIN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	UINT32 scriptId; _parser.parseUINT32(scriptId);
	AtfValidator::validateInt(_descr, "scriptId", scriptId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != DBM_NO_ERROR )
	{
		_parser.parseStringN(_dummy, 0, "errMsg"); size_t szErrMsg = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errMsg", szErrMsg, _checker, __FILE__, __LINE__);
	}
	else
	{
		BYTE totalGamesNow; _parser.parseBYTE(totalGamesNow);
		AtfValidator::validateInt(_descr, "totalGamesNow", totalGamesNow, _checker, __FILE__, __LINE__);
		UINT32 tournId; _parser.parseUINT32(tournId);
		AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "sampleAddress"); size_t szSampleAddress = strlen(_dummy);
		AtfValidator::validateInt(_descr, "sampleAddress", szSampleAddress, _checker, __FILE__, __LINE__);
		UINT32 buyIn; _parser.parseUINT32(buyIn);
		AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
		UINT32 fppBuyIn; _parser.parseUINT32(fppBuyIn);
		AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
		UINT32 rake; _parser.parseUINT32(rake);
		AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
		BYTE game; _parser.parseBYTE(game);
		AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
		BYTE hiLo; _parser.parseBYTE(hiLo);
		AtfValidator::validateInt(_descr, "hiLo", hiLo, _checker, __FILE__, __LINE__);
		BYTE structure; _parser.parseBYTE(structure);
		AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
		BYTE isPlayMoney; _parser.parseBYTE(isPlayMoney);
		AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "icurrency"); size_t szIcurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "icurrency", szIcurrency, _checker, __FILE__, __LINE__);
		UINT32 scalePM; _parser.parseUINT32(scalePM);
		AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_SNG_POOL_CHECKOUT_REPLY
//=================================================================

SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT_REPLY::Protocol_MSG_SNG_POOL_CHECKOUT_REPLY()
{
	clear();
}

void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT_REPLY::clear()
{
	scriptId = 0;
	errCode = 0;
	cancelledGames = 0;
}

bool SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT_REPLY::equals(const Protocol_MSG_SNG_POOL_CHECKOUT_REPLY& _o) const
{
	return scriptId == _o.scriptId &&
		errCode == _o.errCode &&
		cancelledGames == _o.cancelledGames;
}

const char *SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_SNG_POOL_CHECKOUT_REPLY).append(")");
	_buf.append(',');
	_buf.append("scriptId=");
	_buf.appendUint(scriptId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("cancelledGames=");
	_buf.appendUint(cancelledGames);
	return _buf.c_str();
}

void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(scriptId);
	_msg.composeINT16(errCode);
	_msg.composeBYTE(cancelledGames);
}

void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(scriptId);
	_parser.parseINT16(errCode);
	_parser.parseBYTE(cancelledGames);
}

/*static*/ void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_SNG_POOL_CHECKOUT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 scriptId; _parser.parseUINT32(scriptId);
	AtfValidator::validateInt(_descr, "scriptId", scriptId, _checker, __FILE__, __LINE__);
	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	BYTE cancelledGames; _parser.parseBYTE(cancelledGames);
	AtfValidator::validateInt(_descr, "cancelledGames", cancelledGames, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    SngGameBody
//=================================================================

SngStarter::cli::SngGameBody::SngGameBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

SngStarter::cli::SngGameBody::SngGameBody(SngGameBody&& _o)
	: scriptId(std::move(_o.scriptId))
	, numGames(std::move(_o.numGames))
	, tournId(std::move(_o.tournId))
	, sampleAddress(std::move(_o.sampleAddress))
	, buyIn(std::move(_o.buyIn))
	, fppBuyIn(std::move(_o.fppBuyIn))
	, rake(std::move(_o.rake))
	, game(std::move(_o.game))
	, hiLo(std::move(_o.hiLo))
	, structure(std::move(_o.structure))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, currency(std::move(_o.currency))
	, scalePM(std::move(_o.scalePM))
	, name(std::move(_o.name))
	, tournFlags2(std::move(_o.tournFlags2))
{
}

SngStarter::cli::SngGameBody& SngStarter::cli::SngGameBody::operator=(SngGameBody&& _o)
{
	if(this != &_o)
	{
		scriptId = std::move(_o.scriptId);
		numGames = std::move(_o.numGames);
		tournId = std::move(_o.tournId);
		sampleAddress = std::move(_o.sampleAddress);
		buyIn = std::move(_o.buyIn);
		fppBuyIn = std::move(_o.fppBuyIn);
		rake = std::move(_o.rake);
		game = std::move(_o.game);
		hiLo = std::move(_o.hiLo);
		structure = std::move(_o.structure);
		isPlayMoney = std::move(_o.isPlayMoney);
		currency = std::move(_o.currency);
		scalePM = std::move(_o.scalePM);
		name = std::move(_o.name);
		tournFlags2 = std::move(_o.tournFlags2);
	}
	return *this;
}

#endif

void SngStarter::cli::SngGameBody::clear()
{
	scriptId = 0;
	numGames = 0;
	tournId = 0;
	sampleAddress.clear();
	buyIn = 0;
	fppBuyIn = 0;
	rake = 0;
	game = 0;
	hiLo = 0;
	structure = 0;
	isPlayMoney = 0;
	currency.clear();
	scalePM = 0;
	name.clear();
	tournFlags2 = 0;
}

bool SngStarter::cli::SngGameBody::equals(const SngGameBody& _o) const
{
	return scriptId == _o.scriptId &&
		numGames == _o.numGames &&
		tournId == _o.tournId &&
		sampleAddress.equals(_o.sampleAddress) &&
		buyIn == _o.buyIn &&
		fppBuyIn == _o.fppBuyIn &&
		rake == _o.rake &&
		game == _o.game &&
		hiLo == _o.hiLo &&
		structure == _o.structure &&
		isPlayMoney == _o.isPlayMoney &&
		currency.equals(_o.currency) &&
		scalePM == _o.scalePM &&
		name.equals(_o.name) &&
		tournFlags2 == _o.tournFlags2;
}

const char *SngStarter::cli::SngGameBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("scriptId=");
	_buf.appendUint(scriptId);
	_buf.append(',');
	_buf.append("numGames=");
	_buf.appendUint(numGames);
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("sampleAddress=");
	_buf.append(sampleAddress);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendUint(buyIn);
	_buf.append(',');
	_buf.append("fppBuyIn=");
	_buf.appendUint(fppBuyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendUint(rake);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("hiLo=");
	_buf.appendUint(hiLo);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("tournFlags2=");
	_buf.appendUint64(tournFlags2);
	_buf.append('}');
	return _buf.c_str();
}

void SngStarter::cli::SngGameBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(SngGameBody())) // not empty
	{
		_body.composeUINT32(scriptId);
		_body.composeBYTE(numGames);
		_body.composeUINT32(tournId);
		_body.composeString(sampleAddress);
		_body.composeUINT32(buyIn);
		_body.composeUINT32(fppBuyIn);
		_body.composeUINT32(rake);
		_body.composeBYTE(game);
		_body.composeBYTE(hiLo);
		_body.composeBYTE(structure);
		_body.composeBYTE(isPlayMoney);
		_body.composeString(currency);
		_body.composeUINT32(scalePM);
		_body.composeString(name);
		_body.composeUINT64(tournFlags2);
	}

	_msg.composeMsgBody(_body);
}

void SngStarter::cli::SngGameBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(scriptId);
	_parser0.parseBYTE(numGames);
	_parser0.parseUINT32(tournId);
	_parser0.parseStringP(sampleAddress);
	_parser0.parseUINT32(buyIn);
	_parser0.parseUINT32(fppBuyIn);
	_parser0.parseUINT32(rake);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(hiLo);
	_parser0.parseBYTE(structure);
	_parser0.parseBYTE(isPlayMoney);
	_parser0.parseStringP(currency);
	_parser0.parseUINT32(scalePM);
	_parser0.parseStringP(name);
	_parser0.parseUINT64(tournFlags2);
}

/*static*/ void SngStarter::cli::SngGameBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 scriptId; _parser0.parseUINT32(scriptId);
	AtfValidator::validateInt(_descr, "scriptId", scriptId, _checker, __FILE__, __LINE__);
	BYTE numGames; _parser0.parseBYTE(numGames);
	AtfValidator::validateInt(_descr, "numGames", numGames, _checker, __FILE__, __LINE__);
	UINT32 tournId; _parser0.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "sampleAddress"); size_t szSampleAddress = strlen(_dummy);
	AtfValidator::validateInt(_descr, "sampleAddress", szSampleAddress, _checker, __FILE__, __LINE__);
	UINT32 buyIn; _parser0.parseUINT32(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT32 fppBuyIn; _parser0.parseUINT32(fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	UINT32 rake; _parser0.parseUINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE hiLo; _parser0.parseBYTE(hiLo);
	AtfValidator::validateInt(_descr, "hiLo", hiLo, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser0.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser0.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	UINT64 tournFlags2; _parser0.parseUINT64(tournFlags2);
	AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY
//=================================================================

SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY(Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errMsg(std::move(_o.errMsg))
	, sngs(std::move(_o.sngs))
{
}

SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY& SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY::operator=(Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errMsg = std::move(_o.errMsg);
		sngs = std::move(_o.sngs);
	}
	return *this;
}

#endif

void SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY::clear()
{
	errCode = 0;
	errMsg.clear();
	sngs.clear();
}

bool SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY::equals(const Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errMsg.equals(_o.errMsg) &&
		sngs.equals(_o.sngs);
}

const char *SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != DBM_NO_ERROR )
	{
		_buf.append(',');
		_buf.append("errMsg=");
		_buf.append(errMsg);
	}
	else
	{
		_buf.append(',');
		_buf.append("sngs=");
		sngs.toTraceString(_buf);
	}
	return _buf.c_str();
}

void SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode != DBM_NO_ERROR )
	{
		_msg.composeString(errMsg);
	}
	else
	{
		sngs.composeMsg(_msg);
	}
}

void SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != DBM_NO_ERROR )
	{
		_parser.parseStringP(errMsg);
	}
	else
	{
		sngs.parseMsg(_parser);
	}
}

/*static*/ void SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != DBM_NO_ERROR )
	{
		_parser.parseStringN(_dummy, 0, "errMsg"); size_t szErrMsg = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errMsg", szErrMsg, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szSngs = ThinAtf::LAtfVector< SngGameBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sngs"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "sngs", szSngs, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ bool SngStarter::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_TOURN_REG_INFO: cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_TOURN_REG_INFO_REPLY: cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_SNG_POOL_CHECKIN: cli::Protocol_MSG_SNG_POOL_CHECKIN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_SNG_POOL_CHECKIN_REPLY: cli::Protocol_MSG_SNG_POOL_CHECKIN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_SNG_POOL_CHECKOUT: cli::Protocol_MSG_SNG_POOL_CHECKOUT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_SNG_POOL_CHECKOUT_REPLY: cli::Protocol_MSG_SNG_POOL_CHECKOUT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_SNG_POOL_WHERE_IS_PLAYER: cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY: cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

