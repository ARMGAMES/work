/**
 * ChipsDbm_atf.cpp
 *
 * This file was auto-generated from ChipsDbm_atf.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: ChipsDbm_atf.txt
 */
 
#include "ChipsDbm_atf.h"

//=================================================================
//                Protocol_CHIPSDBM_Q_APPLE_STORE_PURCHASE
//=================================================================

ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_APPLE_STORE_PURCHASE::Protocol_CHIPSDBM_Q_APPLE_STORE_PURCHASE()
{
	clear();
}

void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_APPLE_STORE_PURCHASE::clear()
{
	receipt.clear();
	useNewPaywall = false;
}

bool ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_APPLE_STORE_PURCHASE::equals(const Protocol_CHIPSDBM_Q_APPLE_STORE_PURCHASE& _o) const
{
	return Atf::atfPStringEquals(receipt, _o.receipt) &&
		useNewPaywall == _o.useNewPaywall;
}

bool ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_APPLE_STORE_PURCHASE::equals(Atf::MessageProtocol* _other) const
{
	if (CHIPSDBM_Q_APPLE_STORE_PURCHASE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_CHIPSDBM_Q_APPLE_STORE_PURCHASE*)_other));
}

const char *ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_APPLE_STORE_PURCHASE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(CHIPSDBM_Q_APPLE_STORE_PURCHASE).append(")");
	_buf.append(',');
	_buf.append("receipt=");
	_buf.append(receipt);
	_buf.append(',');
	_buf.append("useNewPaywall=");
	_buf.appendUint(useNewPaywall);
	return _buf.c_str();
}

const char *ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_APPLE_STORE_PURCHASE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_APPLE_STORE_PURCHASE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(CHIPSDBM_Q_APPLE_STORE_PURCHASE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("receipt", receipt, _buf);
	Atf::XmlElement::encodeAsXmlElement("useNewPaywall", useNewPaywall, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_APPLE_STORE_PURCHASE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("receipt"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, receipt)) return false;
			}
			else if (_element.equals("useNewPaywall"))
			{
				useNewPaywall = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_APPLE_STORE_PURCHASE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(receipt);
	_msg.composeBOOL(useNewPaywall);
}

void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_APPLE_STORE_PURCHASE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(receipt);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(useNewPaywall);
}

const char *ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_APPLE_STORE_PURCHASE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("receipt", receipt);
	_jsonstr.compose("useNewPaywall", useNewPaywall);
	return _buf.c_str();
}

void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_APPLE_STORE_PURCHASE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("receipt", receipt);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("useNewPaywall", useNewPaywall);
}

/*static*/ void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_APPLE_STORE_PURCHASE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "CHIPSDBM_Q_APPLE_STORE_PURCHASE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString receipt; _jparser.validateByNameThrow("receipt", receipt);
	AtfValidator::validateIntMax(_descr, "receipt", receipt.length(), 10000, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool useNewPaywall; _jparser.validateByNameThrow("useNewPaywall", useNewPaywall);
	AtfValidator::validateInt(_descr, "useNewPaywall", useNewPaywall, _checker, __FILE__, __LINE__);
}

/*static*/ void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_APPLE_STORE_PURCHASE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "CHIPSDBM_Q_APPLE_STORE_PURCHASE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "receipt"); size_t szReceipt = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "receipt", szReceipt, 10000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool useNewPaywall; _parser.parseBOOL(useNewPaywall);
	AtfValidator::validateInt(_descr, "useNewPaywall", useNewPaywall, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_CHIPSDBM_A_APPLE_STORE_PURCHASE
//=================================================================

ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_APPLE_STORE_PURCHASE::Protocol_CHIPSDBM_A_APPLE_STORE_PURCHASE()
{
	clear();
}

void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_APPLE_STORE_PURCHASE::clear()
{
	errCode = 0;
	errDescr.clear();
	purchaseToken = 0;
}

bool ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_APPLE_STORE_PURCHASE::equals(const Protocol_CHIPSDBM_A_APPLE_STORE_PURCHASE& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		purchaseToken == _o.purchaseToken;
}

bool ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_APPLE_STORE_PURCHASE::equals(Atf::MessageProtocol* _other) const
{
	if (CHIPSDBM_A_APPLE_STORE_PURCHASE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_CHIPSDBM_A_APPLE_STORE_PURCHASE*)_other));
}

const char *ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_APPLE_STORE_PURCHASE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(CHIPSDBM_A_APPLE_STORE_PURCHASE).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("purchaseToken=");
		_buf.appendUint64(purchaseToken);
	}
	return _buf.c_str();
}

const char *ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_APPLE_STORE_PURCHASE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_APPLE_STORE_PURCHASE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(CHIPSDBM_A_APPLE_STORE_PURCHASE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("purchaseToken", purchaseToken, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_APPLE_STORE_PURCHASE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("purchaseToken"))
			{
				purchaseToken = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_APPLE_STORE_PURCHASE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT64(purchaseToken);
	}
}

void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_APPLE_STORE_PURCHASE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT64(purchaseToken);
	}
}

const char *ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_APPLE_STORE_PURCHASE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("purchaseToken", purchaseToken);
	}
	return _buf.c_str();
}

void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_APPLE_STORE_PURCHASE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("purchaseToken", purchaseToken);
	}
}

/*static*/ void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_APPLE_STORE_PURCHASE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "CHIPSDBM_A_APPLE_STORE_PURCHASE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT64 purchaseToken; _jparser.validateByNameThrow("purchaseToken", purchaseToken);
		AtfValidator::validateUint(_descr, "purchaseToken", purchaseToken, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_APPLE_STORE_PURCHASE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "CHIPSDBM_A_APPLE_STORE_PURCHASE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT64 purchaseToken; _parser.parseUINT64(purchaseToken);
		AtfValidator::validateUint(_descr, "purchaseToken", purchaseToken, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_CHIPSDBM_Q_GOOGLE_PLAY_PURCHASE
//=================================================================

ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GOOGLE_PLAY_PURCHASE::Protocol_CHIPSDBM_Q_GOOGLE_PLAY_PURCHASE()
{
	clear();
}

void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GOOGLE_PLAY_PURCHASE::clear()
{
	notUsedStr.clear();
	orderJson.clear();
	signature.clear();
	useNewPaywall = false;
}

bool ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GOOGLE_PLAY_PURCHASE::equals(const Protocol_CHIPSDBM_Q_GOOGLE_PLAY_PURCHASE& _o) const
{
	return Atf::atfPStringEquals(notUsedStr, _o.notUsedStr) &&
		Atf::atfPStringEquals(orderJson, _o.orderJson) &&
		Atf::atfPStringEquals(signature, _o.signature) &&
		useNewPaywall == _o.useNewPaywall;
}

bool ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GOOGLE_PLAY_PURCHASE::equals(Atf::MessageProtocol* _other) const
{
	if (CHIPSDBM_Q_GOOGLE_PLAY_PURCHASE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_CHIPSDBM_Q_GOOGLE_PLAY_PURCHASE*)_other));
}

const char *ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GOOGLE_PLAY_PURCHASE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(CHIPSDBM_Q_GOOGLE_PLAY_PURCHASE).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("orderJson=");
	_buf.append(orderJson);
	_buf.append(',');
	_buf.append("signature=");
	_buf.append(signature);
	_buf.append(',');
	_buf.append("useNewPaywall=");
	_buf.appendUint(useNewPaywall);
	return _buf.c_str();
}

const char *ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GOOGLE_PLAY_PURCHASE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GOOGLE_PLAY_PURCHASE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(CHIPSDBM_Q_GOOGLE_PLAY_PURCHASE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsedStr", notUsedStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("orderJson", orderJson, _buf);
	Atf::XmlElement::encodeAsXmlElement("signature", signature, _buf);
	Atf::XmlElement::encodeAsXmlElement("useNewPaywall", useNewPaywall, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GOOGLE_PLAY_PURCHASE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedStr)) return false;
			}
			else if (_element.equals("orderJson"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, orderJson)) return false;
			}
			else if (_element.equals("signature"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, signature)) return false;
			}
			else if (_element.equals("useNewPaywall"))
			{
				useNewPaywall = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GOOGLE_PLAY_PURCHASE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsedStr);
	_msg.composeString(orderJson);
	_msg.composeString(signature);
	_msg.composeBOOL(useNewPaywall);
}

void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GOOGLE_PLAY_PURCHASE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseStringP(orderJson);
	_parser.parseStringP(signature);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(useNewPaywall);
}

const char *ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GOOGLE_PLAY_PURCHASE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsedStr", notUsedStr);
	_jsonstr.compose("orderJson", orderJson);
	_jsonstr.compose("signature", signature);
	_jsonstr.compose("useNewPaywall", useNewPaywall);
	return _buf.c_str();
}

void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GOOGLE_PLAY_PURCHASE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsedStr", notUsedStr);
	_jparser.parseByNameThrow("orderJson", orderJson);
	_jparser.parseByNameThrow("signature", signature);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("useNewPaywall", useNewPaywall);
}

/*static*/ void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GOOGLE_PLAY_PURCHASE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "CHIPSDBM_Q_GOOGLE_PLAY_PURCHASE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsedStr; _jparser.validateByNameThrow("notUsedStr", notUsedStr);
	AtfValidator::validateIntMax(_descr, "notUsedStr", notUsedStr.length(), 10000, _checker, __FILE__, __LINE__);
	PString orderJson; _jparser.validateByNameThrow("orderJson", orderJson);
	AtfValidator::validateIntMax(_descr, "orderJson", orderJson.length(), 10000, _checker, __FILE__, __LINE__);
	PString signature; _jparser.validateByNameThrow("signature", signature);
	AtfValidator::validateIntMax(_descr, "signature", signature.length(), 10000, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool useNewPaywall; _jparser.validateByNameThrow("useNewPaywall", useNewPaywall);
	AtfValidator::validateInt(_descr, "useNewPaywall", useNewPaywall, _checker, __FILE__, __LINE__);
}

/*static*/ void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GOOGLE_PLAY_PURCHASE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "CHIPSDBM_Q_GOOGLE_PLAY_PURCHASE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 10000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "orderJson"); size_t szOrderJson = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "orderJson", szOrderJson, 10000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "signature"); size_t szSignature = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "signature", szSignature, 10000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool useNewPaywall; _parser.parseBOOL(useNewPaywall);
	AtfValidator::validateInt(_descr, "useNewPaywall", useNewPaywall, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_CHIPSDBM_A_GOOGLE_PLAY_PURCHASE
//=================================================================

ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GOOGLE_PLAY_PURCHASE::Protocol_CHIPSDBM_A_GOOGLE_PLAY_PURCHASE()
{
	clear();
}

void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GOOGLE_PLAY_PURCHASE::clear()
{
	errCode = 0;
	errDescr.clear();
	purchaseToken = 0;
}

bool ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GOOGLE_PLAY_PURCHASE::equals(const Protocol_CHIPSDBM_A_GOOGLE_PLAY_PURCHASE& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		purchaseToken == _o.purchaseToken;
}

bool ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GOOGLE_PLAY_PURCHASE::equals(Atf::MessageProtocol* _other) const
{
	if (CHIPSDBM_A_GOOGLE_PLAY_PURCHASE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_CHIPSDBM_A_GOOGLE_PLAY_PURCHASE*)_other));
}

const char *ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GOOGLE_PLAY_PURCHASE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(CHIPSDBM_A_GOOGLE_PLAY_PURCHASE).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("purchaseToken=");
		_buf.appendUint64(purchaseToken);
	}
	return _buf.c_str();
}

const char *ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GOOGLE_PLAY_PURCHASE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GOOGLE_PLAY_PURCHASE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(CHIPSDBM_A_GOOGLE_PLAY_PURCHASE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("purchaseToken", purchaseToken, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GOOGLE_PLAY_PURCHASE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("purchaseToken"))
			{
				purchaseToken = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GOOGLE_PLAY_PURCHASE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT64(purchaseToken);
	}
}

void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GOOGLE_PLAY_PURCHASE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT64(purchaseToken);
	}
}

const char *ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GOOGLE_PLAY_PURCHASE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("purchaseToken", purchaseToken);
	}
	return _buf.c_str();
}

void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GOOGLE_PLAY_PURCHASE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("purchaseToken", purchaseToken);
	}
}

/*static*/ void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GOOGLE_PLAY_PURCHASE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "CHIPSDBM_A_GOOGLE_PLAY_PURCHASE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT64 purchaseToken; _jparser.validateByNameThrow("purchaseToken", purchaseToken);
		AtfValidator::validateUint(_descr, "purchaseToken", purchaseToken, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GOOGLE_PLAY_PURCHASE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "CHIPSDBM_A_GOOGLE_PLAY_PURCHASE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT64 purchaseToken; _parser.parseUINT64(purchaseToken);
		AtfValidator::validateUint(_descr, "purchaseToken", purchaseToken, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_CHIPSDBM_Q_GET_CHIPS_TRANS
//=================================================================

ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GET_CHIPS_TRANS::Protocol_CHIPSDBM_Q_GET_CHIPS_TRANS()
{
	clear();
}

void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GET_CHIPS_TRANS::clear()
{
	purchaseId = 0;
}

bool ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GET_CHIPS_TRANS::equals(const Protocol_CHIPSDBM_Q_GET_CHIPS_TRANS& _o) const
{
	return purchaseId == _o.purchaseId;
}

bool ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GET_CHIPS_TRANS::equals(Atf::MessageProtocol* _other) const
{
	if (CHIPSDBM_Q_GET_CHIPS_TRANS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_CHIPSDBM_Q_GET_CHIPS_TRANS*)_other));
}

const char *ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GET_CHIPS_TRANS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(CHIPSDBM_Q_GET_CHIPS_TRANS).append(")");
	_buf.append(',');
	_buf.append("purchaseId=");
	_buf.appendUint(purchaseId);
	return _buf.c_str();
}

const char *ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GET_CHIPS_TRANS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GET_CHIPS_TRANS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(CHIPSDBM_Q_GET_CHIPS_TRANS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("purchaseId", purchaseId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GET_CHIPS_TRANS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("purchaseId"))
			{
				purchaseId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GET_CHIPS_TRANS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(purchaseId);
}

void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GET_CHIPS_TRANS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(purchaseId);
}

const char *ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GET_CHIPS_TRANS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("purchaseId", purchaseId);
	return _buf.c_str();
}

void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GET_CHIPS_TRANS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("purchaseId", purchaseId);
}

/*static*/ void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GET_CHIPS_TRANS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "CHIPSDBM_Q_GET_CHIPS_TRANS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 purchaseId; _jparser.validateByNameThrow("purchaseId", purchaseId);
	AtfValidator::validateInt(_descr, "purchaseId", purchaseId, _checker, __FILE__, __LINE__);
}

/*static*/ void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GET_CHIPS_TRANS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "CHIPSDBM_Q_GET_CHIPS_TRANS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 purchaseId; _parser.parseUINT32(purchaseId);
	AtfValidator::validateInt(_descr, "purchaseId", purchaseId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_CHIPSDBM_A_GET_CHIPS_TRANS
//=================================================================

ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GET_CHIPS_TRANS::Protocol_CHIPSDBM_A_GET_CHIPS_TRANS()
{
	clear();
}

void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GET_CHIPS_TRANS::clear()
{
	errCode = 0;
	errDescr.clear();
	purchaseId = 0;
	parentId = 0;
	amount = 0;
	playChipsAmount = 0;
	gateway.clear();
	status.clear();
	errCodeChipsInfo.clear();
	errInfo.clear();
	extRefId.clear();
	started.setNull();
	completed.setNull();
	userId.clear();
	auditId = 0;
	userIntId = 0;
	paywallId = 0;
	paywallVersionId = 0;
	segmentId = 0;
	segmentVersionId = 0;
	bundleId = 0;
	bundleVersionId = 0;
}

bool ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GET_CHIPS_TRANS::equals(const Protocol_CHIPSDBM_A_GET_CHIPS_TRANS& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		purchaseId == _o.purchaseId &&
		parentId == _o.parentId &&
		amount == _o.amount &&
		playChipsAmount == _o.playChipsAmount &&
		Atf::atfPStringEquals(gateway, _o.gateway) &&
		Atf::atfPStringEquals(status, _o.status) &&
		Atf::atfPStringEquals(errCodeChipsInfo, _o.errCodeChipsInfo) &&
		Atf::atfPStringEquals(errInfo, _o.errInfo) &&
		Atf::atfPStringEquals(extRefId, _o.extRefId) &&
		started.equals(_o.started) &&
		completed.equals(_o.completed) &&
		Atf::atfPStringEquals(userId, _o.userId) &&
		auditId == _o.auditId &&
		userIntId == _o.userIntId &&
		paywallId == _o.paywallId &&
		paywallVersionId == _o.paywallVersionId &&
		segmentId == _o.segmentId &&
		segmentVersionId == _o.segmentVersionId &&
		bundleId == _o.bundleId &&
		bundleVersionId == _o.bundleVersionId;
}

bool ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GET_CHIPS_TRANS::equals(Atf::MessageProtocol* _other) const
{
	if (CHIPSDBM_A_GET_CHIPS_TRANS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_CHIPSDBM_A_GET_CHIPS_TRANS*)_other));
}

const char *ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GET_CHIPS_TRANS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(CHIPSDBM_A_GET_CHIPS_TRANS).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("purchaseId=");
		_buf.appendUint(purchaseId);
		_buf.append(',');
		_buf.append("parentId=");
		_buf.appendUint(parentId);
		_buf.append(',');
		_buf.append("amount=");
		_buf.appendUint64(amount);
		_buf.append(',');
		_buf.append("playChipsAmount=");
		_buf.appendUint64(playChipsAmount);
		_buf.append(',');
		_buf.append("gateway=");
		_buf.append(gateway);
		_buf.append(',');
		_buf.append("status=");
		_buf.append(status);
		_buf.append(',');
		_buf.append("errCodeChipsInfo=");
		_buf.append(errCodeChipsInfo);
		_buf.append(',');
		_buf.append("errInfo=");
		_buf.append(errInfo);
		_buf.append(',');
		_buf.append("extRefId=");
		_buf.append(extRefId);
		_buf.append(',');
		_buf.append("started=");
		Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, started);
		_buf.append(',');
		_buf.append("completed=");
		Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, completed);
		_buf.append(',');
		_buf.append("userId=");
		_buf.append(userId);
		_buf.append(',');
		_buf.append("auditId=");
		_buf.appendUint64(auditId);
		_buf.append(',');
		_buf.append("userIntId=");
		_buf.appendUint(userIntId);
		_buf.append(',');
		_buf.append("paywallId=");
		_buf.appendUint(paywallId);
		_buf.append(',');
		_buf.append("paywallVersionId=");
		_buf.appendInt(paywallVersionId);
		_buf.append(',');
		_buf.append("segmentId=");
		_buf.appendUint(segmentId);
		_buf.append(',');
		_buf.append("segmentVersionId=");
		_buf.appendInt(segmentVersionId);
		_buf.append(',');
		_buf.append("bundleId=");
		_buf.appendUint(bundleId);
		_buf.append(',');
		_buf.append("bundleVersionId=");
		_buf.appendInt(bundleVersionId);
	}
	return _buf.c_str();
}

const char *ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GET_CHIPS_TRANS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GET_CHIPS_TRANS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(CHIPSDBM_A_GET_CHIPS_TRANS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("purchaseId", purchaseId, _buf);
		Atf::XmlElement::encodeAsXmlElement("parentId", parentId, _buf);
		Atf::XmlElement::encodeAsXmlElement("amount", amount, _buf);
		Atf::XmlElement::encodeAsXmlElement("playChipsAmount", playChipsAmount, _buf);
		Atf::XmlElement::encodeAsXmlElement("gateway", gateway, _buf);
		Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
		Atf::XmlElement::encodeAsXmlElement("errCodeChipsInfo", errCodeChipsInfo, _buf);
		Atf::XmlElement::encodeAsXmlElement("errInfo", errInfo, _buf);
		Atf::XmlElement::encodeAsXmlElement("extRefId", extRefId, _buf);
		Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "started", started);
		Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "completed", completed);
		Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
		Atf::XmlElement::encodeAsXmlElement("auditId", auditId, _buf);
		Atf::XmlElement::encodeAsXmlElement("userIntId", userIntId, _buf);
		Atf::XmlElement::encodeAsXmlElement("paywallId", paywallId, _buf);
		Atf::XmlElement::encodeAsXmlElement("paywallVersionId", paywallVersionId, _buf);
		Atf::XmlElement::encodeAsXmlElement("segmentId", segmentId, _buf);
		Atf::XmlElement::encodeAsXmlElement("segmentVersionId", segmentVersionId, _buf);
		Atf::XmlElement::encodeAsXmlElement("bundleId", bundleId, _buf);
		Atf::XmlElement::encodeAsXmlElement("bundleVersionId", bundleVersionId, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GET_CHIPS_TRANS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("purchaseId"))
			{
				purchaseId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("parentId"))
			{
				parentId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("amount"))
			{
				amount = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("playChipsAmount"))
			{
				playChipsAmount = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("gateway"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, gateway)) return false;
			}
			else if (_element.equals("status"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, status)) return false;
			}
			else if (_element.equals("errCodeChipsInfo"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errCodeChipsInfo)) return false;
			}
			else if (_element.equals("errInfo"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errInfo)) return false;
			}
			else if (_element.equals("extRefId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, extRefId)) return false;
			}
			else if (_element.equals("started"))
			{
				Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, started);
			}
			else if (_element.equals("completed"))
			{
				Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, completed);
			}
			else if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("auditId"))
			{
				auditId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userIntId"))
			{
				userIntId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("paywallId"))
			{
				paywallId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("paywallVersionId"))
			{
				paywallVersionId = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("segmentId"))
			{
				segmentId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("segmentVersionId"))
			{
				segmentVersionId = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("bundleId"))
			{
				bundleId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("bundleVersionId"))
			{
				bundleVersionId = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GET_CHIPS_TRANS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(purchaseId);
		_msg.composeUINT32(parentId);
		_msg.composeUINT64(amount);
		_msg.composeUINT64(playChipsAmount);
		_msg.composeString(gateway);
		_msg.composeString(status);
		_msg.composeString(errCodeChipsInfo);
		_msg.composeString(errInfo);
		_msg.composeString(extRefId);
		_msg.composeSrvTime(started);
		_msg.composeSrvTime(completed);
		_msg.composeString(userId);
		_msg.composeUINT64(auditId);
		_msg.composeUINT32(userIntId);
		_msg.composeUINT32(paywallId);
		_msg.composeINT16(paywallVersionId);
		_msg.composeUINT32(segmentId);
		_msg.composeINT16(segmentVersionId);
		_msg.composeUINT32(bundleId);
		_msg.composeINT16(bundleVersionId);
	}
}

void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GET_CHIPS_TRANS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(purchaseId);
		_parser.parseUINT32(parentId);
		_parser.parseUINT64(amount);
		_parser.parseUINT64(playChipsAmount);
		_parser.parseStringP(gateway);
		_parser.parseStringP(status);
		_parser.parseStringP(errCodeChipsInfo);
		_parser.parseStringP(errInfo);
		_parser.parseStringP(extRefId);
		_parser.parseSrvTime(started);
		_parser.parseSrvTime(completed);
		_parser.parseStringP(userId);
		_parser.parseUINT64(auditId);
		_parser.parseUINT32(userIntId);
		_parser.parseUINT32(paywallId);
		_parser.parseINT16(paywallVersionId);
		_parser.parseUINT32(segmentId);
		_parser.parseINT16(segmentVersionId);
		_parser.parseUINT32(bundleId);
		_parser.parseINT16(bundleVersionId);
	}
}

const char *ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GET_CHIPS_TRANS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("purchaseId", purchaseId);
		_jsonstr.compose("parentId", parentId);
		_jsonstr.compose("amount", amount);
		_jsonstr.compose("playChipsAmount", playChipsAmount);
		_jsonstr.compose("gateway", gateway);
		_jsonstr.compose("status", status);
		_jsonstr.compose("errCodeChipsInfo", errCodeChipsInfo);
		_jsonstr.compose("errInfo", errInfo);
		_jsonstr.compose("extRefId", extRefId);
		_jsonstr.compose("started", started);
		_jsonstr.compose("completed", completed);
		_jsonstr.compose("userId", userId);
		_jsonstr.compose("auditId", auditId);
		_jsonstr.compose("userIntId", userIntId);
		_jsonstr.compose("paywallId", paywallId);
		_jsonstr.compose("paywallVersionId", paywallVersionId);
		_jsonstr.compose("segmentId", segmentId);
		_jsonstr.compose("segmentVersionId", segmentVersionId);
		_jsonstr.compose("bundleId", bundleId);
		_jsonstr.compose("bundleVersionId", bundleVersionId);
	}
	return _buf.c_str();
}

void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GET_CHIPS_TRANS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("purchaseId", purchaseId);
		_jparser.parseByNameThrow("parentId", parentId);
		_jparser.parseByNameThrow("amount", amount);
		_jparser.parseByNameThrow("playChipsAmount", playChipsAmount);
		_jparser.parseByNameThrow("gateway", gateway);
		_jparser.parseByNameThrow("status", status);
		_jparser.parseByNameThrow("errCodeChipsInfo", errCodeChipsInfo);
		_jparser.parseByNameThrow("errInfo", errInfo);
		_jparser.parseByNameThrow("extRefId", extRefId);
		_jparser.parseByNameThrow("started", started);
		_jparser.parseByNameThrow("completed", completed);
		_jparser.parseByNameThrow("userId", userId);
		_jparser.parseByNameThrow("auditId", auditId);
		_jparser.parseByNameThrow("userIntId", userIntId);
		_jparser.parseByNameThrow("paywallId", paywallId);
		_jparser.parseByNameThrow("paywallVersionId", paywallVersionId);
		_jparser.parseByNameThrow("segmentId", segmentId);
		_jparser.parseByNameThrow("segmentVersionId", segmentVersionId);
		_jparser.parseByNameThrow("bundleId", bundleId);
		_jparser.parseByNameThrow("bundleVersionId", bundleVersionId);
	}
}

/*static*/ void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GET_CHIPS_TRANS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "CHIPSDBM_A_GET_CHIPS_TRANS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 purchaseId; _jparser.validateByNameThrow("purchaseId", purchaseId);
		AtfValidator::validateInt(_descr, "purchaseId", purchaseId, _checker, __FILE__, __LINE__);
		UINT32 parentId; _jparser.validateByNameThrow("parentId", parentId);
		AtfValidator::validateInt(_descr, "parentId", parentId, _checker, __FILE__, __LINE__);
		UINT64 amount; _jparser.validateByNameThrow("amount", amount);
		AtfValidator::validateUint(_descr, "amount", amount, _checker, __FILE__, __LINE__);
		UINT64 playChipsAmount; _jparser.validateByNameThrow("playChipsAmount", playChipsAmount);
		AtfValidator::validateUint(_descr, "playChipsAmount", playChipsAmount, _checker, __FILE__, __LINE__);
		PString gateway; _jparser.validateByNameThrow("gateway", gateway);
		AtfValidator::validateInt(_descr, "gateway", gateway.length(), _checker, __FILE__, __LINE__);
		PString status; _jparser.validateByNameThrow("status", status);
		AtfValidator::validateInt(_descr, "status", status.length(), _checker, __FILE__, __LINE__);
		PString errCodeChipsInfo; _jparser.validateByNameThrow("errCodeChipsInfo", errCodeChipsInfo);
		AtfValidator::validateInt(_descr, "errCodeChipsInfo", errCodeChipsInfo.length(), _checker, __FILE__, __LINE__);
		PString errInfo; _jparser.validateByNameThrow("errInfo", errInfo);
		AtfValidator::validateInt(_descr, "errInfo", errInfo.length(), _checker, __FILE__, __LINE__);
		PString extRefId; _jparser.validateByNameThrow("extRefId", extRefId);
		AtfValidator::validateInt(_descr, "extRefId", extRefId.length(), _checker, __FILE__, __LINE__);
		CommSrvTime started; _jparser.validateByNameThrow("started", started);
		AtfValidator::validateSrvDateTime(_descr, "started", started, _checker, __FILE__, __LINE__);
		CommSrvTime completed; _jparser.validateByNameThrow("completed", completed);
		AtfValidator::validateSrvDateTime(_descr, "completed", completed, _checker, __FILE__, __LINE__);
		PString userId; _jparser.validateByNameThrow("userId", userId);
		AtfValidator::validateInt(_descr, "userId", userId.length(), _checker, __FILE__, __LINE__);
		UINT64 auditId; _jparser.validateByNameThrow("auditId", auditId);
		AtfValidator::validateUint(_descr, "auditId", auditId, _checker, __FILE__, __LINE__);
		UINT32 userIntId; _jparser.validateByNameThrow("userIntId", userIntId);
		AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
		UINT32 paywallId; _jparser.validateByNameThrow("paywallId", paywallId);
		AtfValidator::validateInt(_descr, "paywallId", paywallId, _checker, __FILE__, __LINE__);
		INT16 paywallVersionId; _jparser.validateByNameThrow("paywallVersionId", paywallVersionId);
		AtfValidator::validateInt(_descr, "paywallVersionId", paywallVersionId, _checker, __FILE__, __LINE__);
		UINT32 segmentId; _jparser.validateByNameThrow("segmentId", segmentId);
		AtfValidator::validateInt(_descr, "segmentId", segmentId, _checker, __FILE__, __LINE__);
		INT16 segmentVersionId; _jparser.validateByNameThrow("segmentVersionId", segmentVersionId);
		AtfValidator::validateInt(_descr, "segmentVersionId", segmentVersionId, _checker, __FILE__, __LINE__);
		UINT32 bundleId; _jparser.validateByNameThrow("bundleId", bundleId);
		AtfValidator::validateInt(_descr, "bundleId", bundleId, _checker, __FILE__, __LINE__);
		INT16 bundleVersionId; _jparser.validateByNameThrow("bundleVersionId", bundleVersionId);
		AtfValidator::validateInt(_descr, "bundleVersionId", bundleVersionId, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GET_CHIPS_TRANS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "CHIPSDBM_A_GET_CHIPS_TRANS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 purchaseId; _parser.parseUINT32(purchaseId);
		AtfValidator::validateInt(_descr, "purchaseId", purchaseId, _checker, __FILE__, __LINE__);
		UINT32 parentId; _parser.parseUINT32(parentId);
		AtfValidator::validateInt(_descr, "parentId", parentId, _checker, __FILE__, __LINE__);
		UINT64 amount; _parser.parseUINT64(amount);
		AtfValidator::validateUint(_descr, "amount", amount, _checker, __FILE__, __LINE__);
		UINT64 playChipsAmount; _parser.parseUINT64(playChipsAmount);
		AtfValidator::validateUint(_descr, "playChipsAmount", playChipsAmount, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "gateway"); size_t szGateway = strlen(_dummy);
		AtfValidator::validateInt(_descr, "gateway", szGateway, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "status"); size_t szStatus = strlen(_dummy);
		AtfValidator::validateInt(_descr, "status", szStatus, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "errCodeChipsInfo"); size_t szErrCodeChipsInfo = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errCodeChipsInfo", szErrCodeChipsInfo, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "errInfo"); size_t szErrInfo = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errInfo", szErrInfo, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "extRefId"); size_t szExtRefId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "extRefId", szExtRefId, _checker, __FILE__, __LINE__);
		CommSrvTime started; _parser.parseSrvTime(started);
		AtfValidator::validateSrvDateTime(_descr, "started", started, _checker, __FILE__, __LINE__);
		CommSrvTime completed; _parser.parseSrvTime(completed);
		AtfValidator::validateSrvDateTime(_descr, "completed", completed, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
		UINT64 auditId; _parser.parseUINT64(auditId);
		AtfValidator::validateUint(_descr, "auditId", auditId, _checker, __FILE__, __LINE__);
		UINT32 userIntId; _parser.parseUINT32(userIntId);
		AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
		UINT32 paywallId; _parser.parseUINT32(paywallId);
		AtfValidator::validateInt(_descr, "paywallId", paywallId, _checker, __FILE__, __LINE__);
		INT16 paywallVersionId; _parser.parseINT16(paywallVersionId);
		AtfValidator::validateInt(_descr, "paywallVersionId", paywallVersionId, _checker, __FILE__, __LINE__);
		UINT32 segmentId; _parser.parseUINT32(segmentId);
		AtfValidator::validateInt(_descr, "segmentId", segmentId, _checker, __FILE__, __LINE__);
		INT16 segmentVersionId; _parser.parseINT16(segmentVersionId);
		AtfValidator::validateInt(_descr, "segmentVersionId", segmentVersionId, _checker, __FILE__, __LINE__);
		UINT32 bundleId; _parser.parseUINT32(bundleId);
		AtfValidator::validateInt(_descr, "bundleId", bundleId, _checker, __FILE__, __LINE__);
		INT16 bundleVersionId; _parser.parseINT16(bundleVersionId);
		AtfValidator::validateInt(_descr, "bundleVersionId", bundleVersionId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_CHIPSDBM_Q_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG
//=================================================================

ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG::Protocol_CHIPSDBM_Q_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG()
{
	clear();
}

void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG::clear()
{
	storeId = 0;
}

bool ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG::equals(const Protocol_CHIPSDBM_Q_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG& _o) const
{
	return storeId == _o.storeId;
}

bool ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG::equals(Atf::MessageProtocol* _other) const
{
	if (CHIPSDBM_Q_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_CHIPSDBM_Q_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG*)_other));
}

const char *ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(CHIPSDBM_Q_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG).append(")");
	_buf.append(',');
	_buf.append("storeId=");
	_buf.appendUint(storeId);
	return _buf.c_str();
}

const char *ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(CHIPSDBM_Q_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("storeId", storeId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("storeId"))
			{
				storeId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(storeId);
}

void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(storeId);
}

const char *ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("storeId", storeId);
	return _buf.c_str();
}

void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("storeId", storeId);
}

/*static*/ void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "CHIPSDBM_Q_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 storeId; _jparser.validateByNameThrow("storeId", storeId);
	AtfValidator::validateInt(_descr, "storeId", storeId, _checker, __FILE__, __LINE__);
}

/*static*/ void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_Q_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "CHIPSDBM_Q_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 storeId; _parser.parseUINT32(storeId);
	AtfValidator::validateInt(_descr, "storeId", storeId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    PlayChipsConfigStore
//=================================================================

ChipsDbm::cli_mobile::PlayChipsConfigStore::PlayChipsConfigStore()
{
	clear();
}

void ChipsDbm::cli_mobile::PlayChipsConfigStore::clear()
{
	configId = 0;
	storeId = 0;
	productId.clear();
}

bool ChipsDbm::cli_mobile::PlayChipsConfigStore::equals(const PlayChipsConfigStore& _o) const
{
	return configId == _o.configId &&
		storeId == _o.storeId &&
		Atf::atfPStringEquals(productId, _o.productId);
}

const char *ChipsDbm::cli_mobile::PlayChipsConfigStore::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("configId=");
	_buf.appendUint(configId);
	_buf.append(',');
	_buf.append("storeId=");
	_buf.appendUint(storeId);
	_buf.append(',');
	_buf.append("productId=");
	_buf.append(productId);
	_buf.append('}');
	return _buf.c_str();
}

const char *ChipsDbm::cli_mobile::PlayChipsConfigStore::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("configId", configId, _buf);
	Atf::XmlElement::encodeAsXmlElement("storeId", storeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("productId", productId, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool ChipsDbm::cli_mobile::PlayChipsConfigStore::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("configId"))
		{
			configId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("storeId"))
		{
			storeId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("productId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, productId)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void ChipsDbm::cli_mobile::PlayChipsConfigStore::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(PlayChipsConfigStore())) // not empty
	{
		_body.composeUINT32(configId);
		_body.composeUINT32(storeId);
		_body.composeString(productId);
	}

	_msg.composeMsgBody(_body);
}

void ChipsDbm::cli_mobile::PlayChipsConfigStore::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(configId);
	_parser0.parseUINT32(storeId);
	_parser0.parseStringP(productId);
}

const char *ChipsDbm::cli_mobile::PlayChipsConfigStore::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("configId", configId);
	_jsonstr.compose("storeId", storeId);
	_jsonstr.compose("productId", productId);
	return _buf.c_str();
}

void ChipsDbm::cli_mobile::PlayChipsConfigStore::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("configId", configId);
	_jparser.parseByNameThrow("storeId", storeId);
	_jparser.parseByNameThrow("productId", productId);
}

/* static */ void ChipsDbm::cli_mobile::PlayChipsConfigStore::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 configId; _jparser.validateByNameThrow("configId", configId);
	AtfValidator::validateInt(_descr, "configId", configId, _checker, __FILE__, __LINE__);
	UINT32 storeId; _jparser.validateByNameThrow("storeId", storeId);
	AtfValidator::validateInt(_descr, "storeId", storeId, _checker, __FILE__, __LINE__);
	PString productId; _jparser.validateByNameThrow("productId", productId);
	AtfValidator::validateInt(_descr, "productId", productId.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void ChipsDbm::cli_mobile::PlayChipsConfigStore::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 configId; _parser0.parseUINT32(configId);
	AtfValidator::validateInt(_descr, "configId", configId, _checker, __FILE__, __LINE__);
	UINT32 storeId; _parser0.parseUINT32(storeId);
	AtfValidator::validateInt(_descr, "storeId", storeId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "productId"); size_t szProductId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "productId", szProductId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PlayChipsConfig
//=================================================================

ChipsDbm::cli_mobile::PlayChipsConfig::PlayChipsConfig()
{
	clear();
}

void ChipsDbm::cli_mobile::PlayChipsConfig::clear()
{
	configId = 0;
	amount = 0;
	playChipsAmount = 0;
	payTier = 0;
	whenCreated.setNull();
	createdBy = 0;
	whenObsoleted.setNull();
	obsoletedBy = 0;
	platform = 0;
	popular = 0;
	storeConfigs.clear();
}

bool ChipsDbm::cli_mobile::PlayChipsConfig::equals(const PlayChipsConfig& _o) const
{
	return configId == _o.configId &&
		amount == _o.amount &&
		playChipsAmount == _o.playChipsAmount &&
		payTier == _o.payTier &&
		whenCreated.equals(_o.whenCreated) &&
		createdBy == _o.createdBy &&
		whenObsoleted.equals(_o.whenObsoleted) &&
		obsoletedBy == _o.obsoletedBy &&
		platform == _o.platform &&
		popular == _o.popular &&
		storeConfigs.equals(_o.storeConfigs);
}

const char *ChipsDbm::cli_mobile::PlayChipsConfig::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("configId=");
	_buf.appendUint(configId);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendInt64(amount);
	_buf.append(',');
	_buf.append("playChipsAmount=");
	_buf.appendInt64(playChipsAmount);
	_buf.append(',');
	_buf.append("payTier=");
	_buf.appendUint(payTier);
	_buf.append(',');
	_buf.append("whenCreated=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, whenCreated);
	_buf.append(',');
	_buf.append("createdBy=");
	_buf.appendUint(createdBy);
	_buf.append(',');
	_buf.append("whenObsoleted=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, whenObsoleted);
	_buf.append(',');
	_buf.append("obsoletedBy=");
	_buf.appendUint(obsoletedBy);
	_buf.append(',');
	_buf.append("platform=");
	_buf.appendUint(platform);
	_buf.append(',');
	_buf.append("popular=");
	_buf.appendUint(popular);
	_buf.append(',');
	_buf.append("storeConfigs=");
	storeConfigs.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *ChipsDbm::cli_mobile::PlayChipsConfig::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("configId", configId, _buf);
	Atf::XmlElement::encodeAsXmlElement("amount", amount, _buf);
	Atf::XmlElement::encodeAsXmlElement("playChipsAmount", playChipsAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("payTier", payTier, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "whenCreated", whenCreated);
	Atf::XmlElement::encodeAsXmlElement("createdBy", createdBy, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "whenObsoleted", whenObsoleted);
	Atf::XmlElement::encodeAsXmlElement("obsoletedBy", obsoletedBy, _buf);
	Atf::XmlElement::encodeAsXmlElement("platform", platform, _buf);
	Atf::XmlElement::encodeAsXmlElement("popular", popular, _buf);
	storeConfigs.toXmlString("storeConfigs", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool ChipsDbm::cli_mobile::PlayChipsConfig::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("configId"))
		{
			configId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("amount"))
		{
			amount = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("playChipsAmount"))
		{
			playChipsAmount = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("payTier"))
		{
			payTier = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("whenCreated"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, whenCreated);
		}
		else if (_element.equals("createdBy"))
		{
			createdBy = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("whenObsoleted"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, whenObsoleted);
		}
		else if (_element.equals("obsoletedBy"))
		{
			obsoletedBy = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("platform"))
		{
			platform = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("popular"))
		{
			popular = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("storeConfigs"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PlayChipsConfigStore, 4 > >::FromXmlString(_value, storeConfigs)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void ChipsDbm::cli_mobile::PlayChipsConfig::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(PlayChipsConfig())) // not empty
	{
		_body.composeUINT32(configId);
		_body.composeINT64(amount);
		_body.composeINT64(playChipsAmount);
		_body.composeUINT32(payTier);
		_body.composeSrvTime(whenCreated);
		_body.composeUINT32(createdBy);
		_body.composeSrvTime(whenObsoleted);
		_body.composeUINT32(obsoletedBy);
		_body.composeUINT32(platform);
		_body.composeUINT16(popular);
		storeConfigs.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void ChipsDbm::cli_mobile::PlayChipsConfig::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(configId);
	_parser0.parseINT64(amount);
	_parser0.parseINT64(playChipsAmount);
	_parser0.parseUINT32(payTier);
	_parser0.parseSrvTime(whenCreated);
	_parser0.parseUINT32(createdBy);
	_parser0.parseSrvTime(whenObsoleted);
	_parser0.parseUINT32(obsoletedBy);
	_parser0.parseUINT32(platform);
	_parser0.parseUINT16(popular);
	storeConfigs.parseMsg(_parser0);
}

const char *ChipsDbm::cli_mobile::PlayChipsConfig::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("configId", configId);
	_jsonstr.compose("amount", amount);
	_jsonstr.compose("playChipsAmount", playChipsAmount);
	_jsonstr.compose("payTier", payTier);
	_jsonstr.compose("whenCreated", whenCreated);
	_jsonstr.compose("createdBy", createdBy);
	_jsonstr.compose("whenObsoleted", whenObsoleted);
	_jsonstr.compose("obsoletedBy", obsoletedBy);
	_jsonstr.compose("platform", platform);
	_jsonstr.compose("popular", popular);
	_jsonstr.compose("storeConfigs", storeConfigs);
	return _buf.c_str();
}

void ChipsDbm::cli_mobile::PlayChipsConfig::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("configId", configId);
	_jparser.parseByNameThrow("amount", amount);
	_jparser.parseByNameThrow("playChipsAmount", playChipsAmount);
	_jparser.parseByNameThrow("payTier", payTier);
	_jparser.parseByNameThrow("whenCreated", whenCreated);
	_jparser.parseByNameThrow("createdBy", createdBy);
	_jparser.parseByNameThrow("whenObsoleted", whenObsoleted);
	_jparser.parseByNameThrow("obsoletedBy", obsoletedBy);
	_jparser.parseByNameThrow("platform", platform);
	_jparser.parseByNameThrow("popular", popular);
	_jparser.parseByNameThrow("storeConfigs", storeConfigs);
}

/* static */ void ChipsDbm::cli_mobile::PlayChipsConfig::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 configId; _jparser.validateByNameThrow("configId", configId);
	AtfValidator::validateInt(_descr, "configId", configId, _checker, __FILE__, __LINE__);
	INT64 amount; _jparser.validateByNameThrow("amount", amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	INT64 playChipsAmount; _jparser.validateByNameThrow("playChipsAmount", playChipsAmount);
	AtfValidator::validateInt(_descr, "playChipsAmount", playChipsAmount, _checker, __FILE__, __LINE__);
	UINT32 payTier; _jparser.validateByNameThrow("payTier", payTier);
	AtfValidator::validateInt(_descr, "payTier", payTier, _checker, __FILE__, __LINE__);
	CommSrvTime whenCreated; _jparser.validateByNameThrow("whenCreated", whenCreated);
	AtfValidator::validateSrvDateTime(_descr, "whenCreated", whenCreated, _checker, __FILE__, __LINE__);
	UINT32 createdBy; _jparser.validateByNameThrow("createdBy", createdBy);
	AtfValidator::validateInt(_descr, "createdBy", createdBy, _checker, __FILE__, __LINE__);
	CommSrvTime whenObsoleted; _jparser.validateByNameThrow("whenObsoleted", whenObsoleted);
	AtfValidator::validateSrvDateTime(_descr, "whenObsoleted", whenObsoleted, _checker, __FILE__, __LINE__);
	UINT32 obsoletedBy; _jparser.validateByNameThrow("obsoletedBy", obsoletedBy);
	AtfValidator::validateInt(_descr, "obsoletedBy", obsoletedBy, _checker, __FILE__, __LINE__);
	UINT32 platform; _jparser.validateByNameThrow("platform", platform);
	AtfValidator::validateInt(_descr, "platform", platform, _checker, __FILE__, __LINE__);
	UINT16 popular; _jparser.validateByNameThrow("popular", popular);
	AtfValidator::validateInt(_descr, "popular", popular, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PlayChipsConfigStore > storeConfigs; _jparser.validateByNameThrow("storeConfigs", storeConfigs);
	AtfValidator::validateInt(_descr, "storeConfigs", storeConfigs.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void ChipsDbm::cli_mobile::PlayChipsConfig::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 configId; _parser0.parseUINT32(configId);
	AtfValidator::validateInt(_descr, "configId", configId, _checker, __FILE__, __LINE__);
	INT64 amount; _parser0.parseINT64(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	INT64 playChipsAmount; _parser0.parseINT64(playChipsAmount);
	AtfValidator::validateInt(_descr, "playChipsAmount", playChipsAmount, _checker, __FILE__, __LINE__);
	UINT32 payTier; _parser0.parseUINT32(payTier);
	AtfValidator::validateInt(_descr, "payTier", payTier, _checker, __FILE__, __LINE__);
	CommSrvTime whenCreated; _parser0.parseSrvTime(whenCreated);
	AtfValidator::validateSrvDateTime(_descr, "whenCreated", whenCreated, _checker, __FILE__, __LINE__);
	UINT32 createdBy; _parser0.parseUINT32(createdBy);
	AtfValidator::validateInt(_descr, "createdBy", createdBy, _checker, __FILE__, __LINE__);
	CommSrvTime whenObsoleted; _parser0.parseSrvTime(whenObsoleted);
	AtfValidator::validateSrvDateTime(_descr, "whenObsoleted", whenObsoleted, _checker, __FILE__, __LINE__);
	UINT32 obsoletedBy; _parser0.parseUINT32(obsoletedBy);
	AtfValidator::validateInt(_descr, "obsoletedBy", obsoletedBy, _checker, __FILE__, __LINE__);
	UINT32 platform; _parser0.parseUINT32(platform);
	AtfValidator::validateInt(_descr, "platform", platform, _checker, __FILE__, __LINE__);
	UINT16 popular; _parser0.parseUINT16(popular);
	AtfValidator::validateInt(_descr, "popular", popular, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szStoreConfigs = Atf::LAtfVector< PlayChipsConfigStore, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("storeConfigs"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "storeConfigs", szStoreConfigs, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_CHIPSDBM_A_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG
//=================================================================

ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG::Protocol_CHIPSDBM_A_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG()
{
	clear();
}

void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG::clear()
{
	errCode = 0;
	errDescr.clear();
	playChipsConfig.clear();
}

bool ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG::equals(const Protocol_CHIPSDBM_A_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		playChipsConfig.equals(_o.playChipsConfig);
}

bool ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG::equals(Atf::MessageProtocol* _other) const
{
	if (CHIPSDBM_A_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_CHIPSDBM_A_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG*)_other));
}

const char *ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(CHIPSDBM_A_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("playChipsConfig=");
		playChipsConfig.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(CHIPSDBM_A_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		playChipsConfig.toXmlString("playChipsConfig", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("playChipsConfig"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< PlayChipsConfig, 4 > >::FromXmlString(_value, playChipsConfig)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		playChipsConfig.composeMsg(_msg, _ignoreJSON);
	}
}

void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		playChipsConfig.parseMsg(_parser);
	}
}

const char *ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("playChipsConfig", playChipsConfig);
	}
	return _buf.c_str();
}

void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("playChipsConfig", playChipsConfig);
	}
}

/*static*/ void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "CHIPSDBM_A_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< PlayChipsConfig > playChipsConfig; _jparser.validateByNameThrow("playChipsConfig", playChipsConfig);
		AtfValidator::validateInt(_descr, "playChipsConfig", playChipsConfig.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void ChipsDbm::cli_mobile::Protocol_CHIPSDBM_A_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "CHIPSDBM_A_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szPlayChipsConfig = Atf::LAtfVector< PlayChipsConfig, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("playChipsConfig"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "playChipsConfig", szPlayChipsConfig, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ Atf::MessageProtocol* ChipsDbm::ProtocolFactory::createMessageProtocolObject(const char *_nameSpace, UINT32 _msgId)
{
	Atf::MessageProtocol *_obj = NULL;

	if(!strcmp(_nameSpace, "cli_mobile"))
	{
		switch(_msgId)
		{
			case CHIPSDBM_A_APPLE_STORE_PURCHASE: _obj = new cli_mobile::Protocol_CHIPSDBM_A_APPLE_STORE_PURCHASE(); break;
			case CHIPSDBM_A_GET_CHIPS_TRANS: _obj = new cli_mobile::Protocol_CHIPSDBM_A_GET_CHIPS_TRANS(); break;
			case CHIPSDBM_A_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG: _obj = new cli_mobile::Protocol_CHIPSDBM_A_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG(); break;
			case CHIPSDBM_A_GOOGLE_PLAY_PURCHASE: _obj = new cli_mobile::Protocol_CHIPSDBM_A_GOOGLE_PLAY_PURCHASE(); break;
			case CHIPSDBM_Q_APPLE_STORE_PURCHASE: _obj = new cli_mobile::Protocol_CHIPSDBM_Q_APPLE_STORE_PURCHASE(); break;
			case CHIPSDBM_Q_GET_CHIPS_TRANS: _obj = new cli_mobile::Protocol_CHIPSDBM_Q_GET_CHIPS_TRANS(); break;
			case CHIPSDBM_Q_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG: _obj = new cli_mobile::Protocol_CHIPSDBM_Q_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG(); break;
			case CHIPSDBM_Q_GOOGLE_PLAY_PURCHASE: _obj = new cli_mobile::Protocol_CHIPSDBM_Q_GOOGLE_PLAY_PURCHASE(); break;
		}
	}
	
	return _obj;
}

/* static */ bool ChipsDbm::ProtocolFactory::validateProtocolMessageFromJSONString(const char *_nameSpace, UINT32 _msgId, const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli_mobile"))
	{
		switch(_msgId)
		{
			case CHIPSDBM_A_APPLE_STORE_PURCHASE: cli_mobile::Protocol_CHIPSDBM_A_APPLE_STORE_PURCHASE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case CHIPSDBM_A_GET_CHIPS_TRANS: cli_mobile::Protocol_CHIPSDBM_A_GET_CHIPS_TRANS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case CHIPSDBM_A_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG: cli_mobile::Protocol_CHIPSDBM_A_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case CHIPSDBM_A_GOOGLE_PLAY_PURCHASE: cli_mobile::Protocol_CHIPSDBM_A_GOOGLE_PLAY_PURCHASE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case CHIPSDBM_Q_APPLE_STORE_PURCHASE: cli_mobile::Protocol_CHIPSDBM_Q_APPLE_STORE_PURCHASE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case CHIPSDBM_Q_GET_CHIPS_TRANS: cli_mobile::Protocol_CHIPSDBM_Q_GET_CHIPS_TRANS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case CHIPSDBM_Q_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG: cli_mobile::Protocol_CHIPSDBM_Q_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case CHIPSDBM_Q_GOOGLE_PLAY_PURCHASE: cli_mobile::Protocol_CHIPSDBM_Q_GOOGLE_PLAY_PURCHASE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

/* static */ bool ChipsDbm::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli_mobile"))
	{
		switch(_msgId)
		{
			case CHIPSDBM_A_APPLE_STORE_PURCHASE: cli_mobile::Protocol_CHIPSDBM_A_APPLE_STORE_PURCHASE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case CHIPSDBM_A_GET_CHIPS_TRANS: cli_mobile::Protocol_CHIPSDBM_A_GET_CHIPS_TRANS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case CHIPSDBM_A_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG: cli_mobile::Protocol_CHIPSDBM_A_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case CHIPSDBM_A_GOOGLE_PLAY_PURCHASE: cli_mobile::Protocol_CHIPSDBM_A_GOOGLE_PLAY_PURCHASE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case CHIPSDBM_Q_APPLE_STORE_PURCHASE: cli_mobile::Protocol_CHIPSDBM_Q_APPLE_STORE_PURCHASE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case CHIPSDBM_Q_GET_CHIPS_TRANS: cli_mobile::Protocol_CHIPSDBM_Q_GET_CHIPS_TRANS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case CHIPSDBM_Q_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG: cli_mobile::Protocol_CHIPSDBM_Q_GET_STORE_AVAILABLE_PLAYCHIPSCONFIG::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case CHIPSDBM_Q_GOOGLE_PLAY_PURCHASE: cli_mobile::Protocol_CHIPSDBM_Q_GOOGLE_PLAY_PURCHASE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

