/**
 * dbm_atf.cpp
 *
 * This file was auto-generated from dbm_atf.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: dbm_atf.txt
 */
 
#include "dbm_atf.h"

//=================================================================
//                Protocol_DBM_Q_SET_FRAUDULENT_ACCOUNT_FLAG
//=================================================================

dbm::admin::Protocol_DBM_Q_SET_FRAUDULENT_ACCOUNT_FLAG::Protocol_DBM_Q_SET_FRAUDULENT_ACCOUNT_FLAG()
{
	clear();
}

void dbm::admin::Protocol_DBM_Q_SET_FRAUDULENT_ACCOUNT_FLAG::clear()
{
	userIntId = 0;
	reasons = 0;
	updateType = 0;
	comment.clear();
}

bool dbm::admin::Protocol_DBM_Q_SET_FRAUDULENT_ACCOUNT_FLAG::equals(const Protocol_DBM_Q_SET_FRAUDULENT_ACCOUNT_FLAG& _o) const
{
	return userIntId == _o.userIntId &&
		reasons == _o.reasons &&
		updateType == _o.updateType &&
		Atf::atfPStringEquals(comment, _o.comment);
}

bool dbm::admin::Protocol_DBM_Q_SET_FRAUDULENT_ACCOUNT_FLAG::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_Q_SET_FRAUDULENT_ACCOUNT_FLAG != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_Q_SET_FRAUDULENT_ACCOUNT_FLAG*)_other));
}

const char *dbm::admin::Protocol_DBM_Q_SET_FRAUDULENT_ACCOUNT_FLAG::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_Q_SET_FRAUDULENT_ACCOUNT_FLAG).append(")");
	_buf.append(',');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	_buf.append(',');
	_buf.append("reasons=");
	_buf.appendUint(reasons);
	_buf.append(',');
	_buf.append("updateType=");
	_buf.appendInt(updateType);
	_buf.append(',');
	_buf.append("comment=");
	_buf.append(comment);
	return _buf.c_str();
}

const char *dbm::admin::Protocol_DBM_Q_SET_FRAUDULENT_ACCOUNT_FLAG::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *dbm::admin::Protocol_DBM_Q_SET_FRAUDULENT_ACCOUNT_FLAG::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_Q_SET_FRAUDULENT_ACCOUNT_FLAG).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userIntId", userIntId, _buf);
	Atf::XmlElement::encodeAsXmlElement("reasons", reasons, _buf);
	Atf::XmlElement::encodeAsXmlElement("updateType", updateType, _buf);
	Atf::XmlElement::encodeAsXmlElement("comment", comment, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool dbm::admin::Protocol_DBM_Q_SET_FRAUDULENT_ACCOUNT_FLAG::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userIntId"))
			{
				userIntId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("reasons"))
			{
				reasons = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("updateType"))
			{
				updateType = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("comment"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, comment)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void dbm::admin::Protocol_DBM_Q_SET_FRAUDULENT_ACCOUNT_FLAG::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(userIntId);
	_msg.composeUINT32(reasons);
	_msg.composeINT32(updateType);
	_msg.composeString(comment);
}

void dbm::admin::Protocol_DBM_Q_SET_FRAUDULENT_ACCOUNT_FLAG::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(userIntId);
	_parser.parseUINT32(reasons);
	_parser.parseINT32(updateType);
	_parser.parseStringP(comment);
}

const char *dbm::admin::Protocol_DBM_Q_SET_FRAUDULENT_ACCOUNT_FLAG::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userIntId", userIntId);
	_jsonstr.compose("reasons", reasons);
	_jsonstr.compose("updateType", updateType);
	_jsonstr.compose("comment", comment);
	return _buf.c_str();
}

void dbm::admin::Protocol_DBM_Q_SET_FRAUDULENT_ACCOUNT_FLAG::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userIntId", userIntId);
	_jparser.parseByNameThrow("reasons", reasons);
	_jparser.parseByNameThrow("updateType", updateType);
	_jparser.parseByNameThrow("comment", comment);
}

/*static*/ void dbm::admin::Protocol_DBM_Q_SET_FRAUDULENT_ACCOUNT_FLAG::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "DBM_Q_SET_FRAUDULENT_ACCOUNT_FLAG";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 userIntId; _jparser.validateByNameThrow("userIntId", userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	UINT32 reasons; _jparser.validateByNameThrow("reasons", reasons);
	AtfValidator::validateIntRange(_descr, "reasons", reasons, eFraudulentAccountReasons_Min, eFraudulentAccountReasons_Max, _checker, __FILE__, __LINE__);
	INT32 updateType; _jparser.validateByNameThrow("updateType", updateType);
	AtfValidator::validateInt(_descr, "updateType", updateType, _checker, __FILE__, __LINE__);
	PString comment; _jparser.validateByNameThrow("comment", comment);
	AtfValidator::validateIntMax(_descr, "comment", comment.length(), (USER_COMMENTS_LEN-1), _checker, __FILE__, __LINE__);
}

/*static*/ void dbm::admin::Protocol_DBM_Q_SET_FRAUDULENT_ACCOUNT_FLAG::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "DBM_Q_SET_FRAUDULENT_ACCOUNT_FLAG";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 userIntId; _parser.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	UINT32 reasons; _parser.parseUINT32(reasons);
	AtfValidator::validateIntRange(_descr, "reasons", reasons, eFraudulentAccountReasons_Min, eFraudulentAccountReasons_Max, _checker, __FILE__, __LINE__);
	INT32 updateType; _parser.parseINT32(updateType);
	AtfValidator::validateInt(_descr, "updateType", updateType, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "comment"); size_t szComment = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "comment", szComment, (USER_COMMENTS_LEN-1), _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_DBM_A_SET_FRAUDULENT_ACCOUNT_FLAG
//=================================================================

dbm::admin::Protocol_DBM_A_SET_FRAUDULENT_ACCOUNT_FLAG::Protocol_DBM_A_SET_FRAUDULENT_ACCOUNT_FLAG()
{
	clear();
}

void dbm::admin::Protocol_DBM_A_SET_FRAUDULENT_ACCOUNT_FLAG::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool dbm::admin::Protocol_DBM_A_SET_FRAUDULENT_ACCOUNT_FLAG::equals(const Protocol_DBM_A_SET_FRAUDULENT_ACCOUNT_FLAG& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc);
}

bool dbm::admin::Protocol_DBM_A_SET_FRAUDULENT_ACCOUNT_FLAG::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_A_SET_FRAUDULENT_ACCOUNT_FLAG != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_A_SET_FRAUDULENT_ACCOUNT_FLAG*)_other));
}

const char *dbm::admin::Protocol_DBM_A_SET_FRAUDULENT_ACCOUNT_FLAG::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_A_SET_FRAUDULENT_ACCOUNT_FLAG).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

const char *dbm::admin::Protocol_DBM_A_SET_FRAUDULENT_ACCOUNT_FLAG::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *dbm::admin::Protocol_DBM_A_SET_FRAUDULENT_ACCOUNT_FLAG::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_A_SET_FRAUDULENT_ACCOUNT_FLAG).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool dbm::admin::Protocol_DBM_A_SET_FRAUDULENT_ACCOUNT_FLAG::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void dbm::admin::Protocol_DBM_A_SET_FRAUDULENT_ACCOUNT_FLAG::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void dbm::admin::Protocol_DBM_A_SET_FRAUDULENT_ACCOUNT_FLAG::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

const char *dbm::admin::Protocol_DBM_A_SET_FRAUDULENT_ACCOUNT_FLAG::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	return _buf.c_str();
}

void dbm::admin::Protocol_DBM_A_SET_FRAUDULENT_ACCOUNT_FLAG::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
}

/*static*/ void dbm::admin::Protocol_DBM_A_SET_FRAUDULENT_ACCOUNT_FLAG::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "DBM_A_SET_FRAUDULENT_ACCOUNT_FLAG";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void dbm::admin::Protocol_DBM_A_SET_FRAUDULENT_ACCOUNT_FLAG::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "DBM_A_SET_FRAUDULENT_ACCOUNT_FLAG";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_DBM_Q_CLEAR_FRAUDULENT_ACCOUNT_FLAG
//=================================================================

dbm::admin::Protocol_DBM_Q_CLEAR_FRAUDULENT_ACCOUNT_FLAG::Protocol_DBM_Q_CLEAR_FRAUDULENT_ACCOUNT_FLAG()
{
	clear();
}

void dbm::admin::Protocol_DBM_Q_CLEAR_FRAUDULENT_ACCOUNT_FLAG::clear()
{
	userIntId = 0;
	updateType = 0;
	comment.clear();
}

bool dbm::admin::Protocol_DBM_Q_CLEAR_FRAUDULENT_ACCOUNT_FLAG::equals(const Protocol_DBM_Q_CLEAR_FRAUDULENT_ACCOUNT_FLAG& _o) const
{
	return userIntId == _o.userIntId &&
		updateType == _o.updateType &&
		Atf::atfPStringEquals(comment, _o.comment);
}

bool dbm::admin::Protocol_DBM_Q_CLEAR_FRAUDULENT_ACCOUNT_FLAG::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_Q_CLEAR_FRAUDULENT_ACCOUNT_FLAG != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_Q_CLEAR_FRAUDULENT_ACCOUNT_FLAG*)_other));
}

const char *dbm::admin::Protocol_DBM_Q_CLEAR_FRAUDULENT_ACCOUNT_FLAG::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_Q_CLEAR_FRAUDULENT_ACCOUNT_FLAG).append(")");
	_buf.append(',');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	_buf.append(',');
	_buf.append("updateType=");
	_buf.appendInt(updateType);
	_buf.append(',');
	_buf.append("comment=");
	_buf.append(comment);
	return _buf.c_str();
}

const char *dbm::admin::Protocol_DBM_Q_CLEAR_FRAUDULENT_ACCOUNT_FLAG::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *dbm::admin::Protocol_DBM_Q_CLEAR_FRAUDULENT_ACCOUNT_FLAG::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_Q_CLEAR_FRAUDULENT_ACCOUNT_FLAG).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userIntId", userIntId, _buf);
	Atf::XmlElement::encodeAsXmlElement("updateType", updateType, _buf);
	Atf::XmlElement::encodeAsXmlElement("comment", comment, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool dbm::admin::Protocol_DBM_Q_CLEAR_FRAUDULENT_ACCOUNT_FLAG::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userIntId"))
			{
				userIntId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("updateType"))
			{
				updateType = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("comment"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, comment)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void dbm::admin::Protocol_DBM_Q_CLEAR_FRAUDULENT_ACCOUNT_FLAG::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(userIntId);
	_msg.composeINT32(updateType);
	_msg.composeString(comment);
}

void dbm::admin::Protocol_DBM_Q_CLEAR_FRAUDULENT_ACCOUNT_FLAG::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(userIntId);
	_parser.parseINT32(updateType);
	_parser.parseStringP(comment);
}

const char *dbm::admin::Protocol_DBM_Q_CLEAR_FRAUDULENT_ACCOUNT_FLAG::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userIntId", userIntId);
	_jsonstr.compose("updateType", updateType);
	_jsonstr.compose("comment", comment);
	return _buf.c_str();
}

void dbm::admin::Protocol_DBM_Q_CLEAR_FRAUDULENT_ACCOUNT_FLAG::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userIntId", userIntId);
	_jparser.parseByNameThrow("updateType", updateType);
	_jparser.parseByNameThrow("comment", comment);
}

/*static*/ void dbm::admin::Protocol_DBM_Q_CLEAR_FRAUDULENT_ACCOUNT_FLAG::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "DBM_Q_CLEAR_FRAUDULENT_ACCOUNT_FLAG";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 userIntId; _jparser.validateByNameThrow("userIntId", userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	INT32 updateType; _jparser.validateByNameThrow("updateType", updateType);
	AtfValidator::validateInt(_descr, "updateType", updateType, _checker, __FILE__, __LINE__);
	PString comment; _jparser.validateByNameThrow("comment", comment);
	AtfValidator::validateIntMax(_descr, "comment", comment.length(), (USER_COMMENTS_LEN-1), _checker, __FILE__, __LINE__);
}

/*static*/ void dbm::admin::Protocol_DBM_Q_CLEAR_FRAUDULENT_ACCOUNT_FLAG::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "DBM_Q_CLEAR_FRAUDULENT_ACCOUNT_FLAG";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 userIntId; _parser.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	INT32 updateType; _parser.parseINT32(updateType);
	AtfValidator::validateInt(_descr, "updateType", updateType, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "comment"); size_t szComment = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "comment", szComment, (USER_COMMENTS_LEN-1), _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_DBM_A_CLEAR_FRAUDULENT_ACCOUNT_FLAG
//=================================================================

dbm::admin::Protocol_DBM_A_CLEAR_FRAUDULENT_ACCOUNT_FLAG::Protocol_DBM_A_CLEAR_FRAUDULENT_ACCOUNT_FLAG()
{
	clear();
}

void dbm::admin::Protocol_DBM_A_CLEAR_FRAUDULENT_ACCOUNT_FLAG::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool dbm::admin::Protocol_DBM_A_CLEAR_FRAUDULENT_ACCOUNT_FLAG::equals(const Protocol_DBM_A_CLEAR_FRAUDULENT_ACCOUNT_FLAG& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc);
}

bool dbm::admin::Protocol_DBM_A_CLEAR_FRAUDULENT_ACCOUNT_FLAG::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_A_CLEAR_FRAUDULENT_ACCOUNT_FLAG != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_A_CLEAR_FRAUDULENT_ACCOUNT_FLAG*)_other));
}

const char *dbm::admin::Protocol_DBM_A_CLEAR_FRAUDULENT_ACCOUNT_FLAG::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_A_CLEAR_FRAUDULENT_ACCOUNT_FLAG).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

const char *dbm::admin::Protocol_DBM_A_CLEAR_FRAUDULENT_ACCOUNT_FLAG::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *dbm::admin::Protocol_DBM_A_CLEAR_FRAUDULENT_ACCOUNT_FLAG::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_A_CLEAR_FRAUDULENT_ACCOUNT_FLAG).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool dbm::admin::Protocol_DBM_A_CLEAR_FRAUDULENT_ACCOUNT_FLAG::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void dbm::admin::Protocol_DBM_A_CLEAR_FRAUDULENT_ACCOUNT_FLAG::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void dbm::admin::Protocol_DBM_A_CLEAR_FRAUDULENT_ACCOUNT_FLAG::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

const char *dbm::admin::Protocol_DBM_A_CLEAR_FRAUDULENT_ACCOUNT_FLAG::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	return _buf.c_str();
}

void dbm::admin::Protocol_DBM_A_CLEAR_FRAUDULENT_ACCOUNT_FLAG::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
}

/*static*/ void dbm::admin::Protocol_DBM_A_CLEAR_FRAUDULENT_ACCOUNT_FLAG::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "DBM_A_CLEAR_FRAUDULENT_ACCOUNT_FLAG";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void dbm::admin::Protocol_DBM_A_CLEAR_FRAUDULENT_ACCOUNT_FLAG::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "DBM_A_CLEAR_FRAUDULENT_ACCOUNT_FLAG";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    RelatedUsers
//=================================================================

dbm::ArchiveManager::RelatedUsers::RelatedUsers()
{
	clear();
}

void dbm::ArchiveManager::RelatedUsers::clear()
{
	groupId.clear();
	severity = 0;
	userWhen.setNull();
	userComment.clear();
	otherIntId = 0;
	otherUserId.clear();
	otherWhen.setNull();
	otherComment.clear();
	otherAdminIntId = 0;
}

bool dbm::ArchiveManager::RelatedUsers::equals(const RelatedUsers& _o) const
{
	return Atf::atfPStringEquals(groupId, _o.groupId) &&
		severity == _o.severity &&
		userWhen.equals(_o.userWhen) &&
		Atf::atfPStringEquals(userComment, _o.userComment) &&
		otherIntId == _o.otherIntId &&
		Atf::atfPStringEquals(otherUserId, _o.otherUserId) &&
		otherWhen.equals(_o.otherWhen) &&
		Atf::atfPStringEquals(otherComment, _o.otherComment) &&
		otherAdminIntId == _o.otherAdminIntId;
}

const char *dbm::ArchiveManager::RelatedUsers::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("groupId=");
	_buf.append(groupId);
	_buf.append(',');
	_buf.append("severity=");
	_buf.appendUint(severity);
	_buf.append(',');
	_buf.append("userWhen=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, userWhen);
	_buf.append(',');
	_buf.append("userComment=");
	_buf.append(userComment);
	_buf.append(',');
	_buf.append("otherIntId=");
	_buf.appendUint(otherIntId);
	_buf.append(',');
	_buf.append("otherUserId=");
	_buf.append(otherUserId);
	_buf.append(',');
	_buf.append("otherWhen=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, otherWhen);
	_buf.append(',');
	_buf.append("otherComment=");
	_buf.append(otherComment);
	_buf.append(',');
	_buf.append("otherAdminIntId=");
	_buf.appendUint(otherAdminIntId);
	_buf.append('}');
	return _buf.c_str();
}

const char *dbm::ArchiveManager::RelatedUsers::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("groupId", groupId, _buf);
	Atf::XmlElement::encodeAsXmlElement("severity", severity, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "userWhen", userWhen);
	Atf::XmlElement::encodeAsXmlElement("userComment", userComment, _buf);
	Atf::XmlElement::encodeAsXmlElement("otherIntId", otherIntId, _buf);
	Atf::XmlElement::encodeAsXmlElement("otherUserId", otherUserId, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "otherWhen", otherWhen);
	Atf::XmlElement::encodeAsXmlElement("otherComment", otherComment, _buf);
	Atf::XmlElement::encodeAsXmlElement("otherAdminIntId", otherAdminIntId, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool dbm::ArchiveManager::RelatedUsers::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("groupId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, groupId)) return false;
		}
		else if (_element.equals("severity"))
		{
			severity = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("userWhen"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, userWhen);
		}
		else if (_element.equals("userComment"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, userComment)) return false;
		}
		else if (_element.equals("otherIntId"))
		{
			otherIntId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("otherUserId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, otherUserId)) return false;
		}
		else if (_element.equals("otherWhen"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, otherWhen);
		}
		else if (_element.equals("otherComment"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, otherComment)) return false;
		}
		else if (_element.equals("otherAdminIntId"))
		{
			otherAdminIntId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void dbm::ArchiveManager::RelatedUsers::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(RelatedUsers())) // not empty
	{
		_body.composeString(groupId);
		_body.composeUINT32(severity);
		_body.composeSrvTime(userWhen);
		_body.composeString(userComment);
		_body.composeUINT32(otherIntId);
		_body.composeString(otherUserId);
		_body.composeSrvTime(otherWhen);
		_body.composeString(otherComment);
		_body.composeUINT32(otherAdminIntId);
	}

	_msg.composeMsgBody(_body);
}

void dbm::ArchiveManager::RelatedUsers::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(groupId);
	_parser0.parseUINT32(severity);
	_parser0.parseSrvTime(userWhen);
	_parser0.parseStringP(userComment);
	_parser0.parseUINT32(otherIntId);
	_parser0.parseStringP(otherUserId);
	_parser0.parseSrvTime(otherWhen);
	_parser0.parseStringP(otherComment);
	_parser0.parseUINT32(otherAdminIntId);
}

const char *dbm::ArchiveManager::RelatedUsers::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("groupId", groupId);
	_jsonstr.compose("severity", severity);
	_jsonstr.compose("userWhen", userWhen);
	_jsonstr.compose("userComment", userComment);
	_jsonstr.compose("otherIntId", otherIntId);
	_jsonstr.compose("otherUserId", otherUserId);
	_jsonstr.compose("otherWhen", otherWhen);
	_jsonstr.compose("otherComment", otherComment);
	_jsonstr.compose("otherAdminIntId", otherAdminIntId);
	return _buf.c_str();
}

void dbm::ArchiveManager::RelatedUsers::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("groupId", groupId);
	_jparser.parseByNameThrow("severity", severity);
	_jparser.parseByNameThrow("userWhen", userWhen);
	_jparser.parseByNameThrow("userComment", userComment);
	_jparser.parseByNameThrow("otherIntId", otherIntId);
	_jparser.parseByNameThrow("otherUserId", otherUserId);
	_jparser.parseByNameThrow("otherWhen", otherWhen);
	_jparser.parseByNameThrow("otherComment", otherComment);
	_jparser.parseByNameThrow("otherAdminIntId", otherAdminIntId);
}

/* static */ void dbm::ArchiveManager::RelatedUsers::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString groupId; _jparser.validateByNameThrow("groupId", groupId);
	AtfValidator::validateInt(_descr, "groupId", groupId.length(), _checker, __FILE__, __LINE__);
	UINT32 severity; _jparser.validateByNameThrow("severity", severity);
	AtfValidator::validateInt(_descr, "severity", severity, _checker, __FILE__, __LINE__);
	CommSrvTime userWhen; _jparser.validateByNameThrow("userWhen", userWhen);
	AtfValidator::validateSrvDateTime(_descr, "userWhen", userWhen, _checker, __FILE__, __LINE__);
	PString userComment; _jparser.validateByNameThrow("userComment", userComment);
	AtfValidator::validateInt(_descr, "userComment", userComment.length(), _checker, __FILE__, __LINE__);
	UINT32 otherIntId; _jparser.validateByNameThrow("otherIntId", otherIntId);
	AtfValidator::validateInt(_descr, "otherIntId", otherIntId, _checker, __FILE__, __LINE__);
	PString otherUserId; _jparser.validateByNameThrow("otherUserId", otherUserId);
	AtfValidator::validateInt(_descr, "otherUserId", otherUserId.length(), _checker, __FILE__, __LINE__);
	CommSrvTime otherWhen; _jparser.validateByNameThrow("otherWhen", otherWhen);
	AtfValidator::validateSrvDateTime(_descr, "otherWhen", otherWhen, _checker, __FILE__, __LINE__);
	PString otherComment; _jparser.validateByNameThrow("otherComment", otherComment);
	AtfValidator::validateInt(_descr, "otherComment", otherComment.length(), _checker, __FILE__, __LINE__);
	UINT32 otherAdminIntId; _jparser.validateByNameThrow("otherAdminIntId", otherAdminIntId);
	AtfValidator::validateInt(_descr, "otherAdminIntId", otherAdminIntId, _checker, __FILE__, __LINE__);
}

/*static*/ void dbm::ArchiveManager::RelatedUsers::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "groupId"); size_t szGroupId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "groupId", szGroupId, _checker, __FILE__, __LINE__);
	UINT32 severity; _parser0.parseUINT32(severity);
	AtfValidator::validateInt(_descr, "severity", severity, _checker, __FILE__, __LINE__);
	CommSrvTime userWhen; _parser0.parseSrvTime(userWhen);
	AtfValidator::validateSrvDateTime(_descr, "userWhen", userWhen, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "userComment"); size_t szUserComment = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userComment", szUserComment, _checker, __FILE__, __LINE__);
	UINT32 otherIntId; _parser0.parseUINT32(otherIntId);
	AtfValidator::validateInt(_descr, "otherIntId", otherIntId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "otherUserId"); size_t szOtherUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "otherUserId", szOtherUserId, _checker, __FILE__, __LINE__);
	CommSrvTime otherWhen; _parser0.parseSrvTime(otherWhen);
	AtfValidator::validateSrvDateTime(_descr, "otherWhen", otherWhen, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "otherComment"); size_t szOtherComment = strlen(_dummy);
	AtfValidator::validateInt(_descr, "otherComment", szOtherComment, _checker, __FILE__, __LINE__);
	UINT32 otherAdminIntId; _parser0.parseUINT32(otherAdminIntId);
	AtfValidator::validateInt(_descr, "otherAdminIntId", otherAdminIntId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_DBM_Q_ARCH_GET_RELATEDUSERS
//=================================================================

dbm::ArchiveManager::Protocol_DBM_Q_ARCH_GET_RELATEDUSERS::Protocol_DBM_Q_ARCH_GET_RELATEDUSERS()
{
	clear();
}

void dbm::ArchiveManager::Protocol_DBM_Q_ARCH_GET_RELATEDUSERS::clear()
{
	userId.clear();
}

bool dbm::ArchiveManager::Protocol_DBM_Q_ARCH_GET_RELATEDUSERS::equals(const Protocol_DBM_Q_ARCH_GET_RELATEDUSERS& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId);
}

bool dbm::ArchiveManager::Protocol_DBM_Q_ARCH_GET_RELATEDUSERS::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_Q_ARCH_GET_RELATEDUSERS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_Q_ARCH_GET_RELATEDUSERS*)_other));
}

const char *dbm::ArchiveManager::Protocol_DBM_Q_ARCH_GET_RELATEDUSERS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_Q_ARCH_GET_RELATEDUSERS).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	return _buf.c_str();
}

const char *dbm::ArchiveManager::Protocol_DBM_Q_ARCH_GET_RELATEDUSERS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *dbm::ArchiveManager::Protocol_DBM_Q_ARCH_GET_RELATEDUSERS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_Q_ARCH_GET_RELATEDUSERS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool dbm::ArchiveManager::Protocol_DBM_Q_ARCH_GET_RELATEDUSERS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void dbm::ArchiveManager::Protocol_DBM_Q_ARCH_GET_RELATEDUSERS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
}

void dbm::ArchiveManager::Protocol_DBM_Q_ARCH_GET_RELATEDUSERS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
}

const char *dbm::ArchiveManager::Protocol_DBM_Q_ARCH_GET_RELATEDUSERS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	return _buf.c_str();
}

void dbm::ArchiveManager::Protocol_DBM_Q_ARCH_GET_RELATEDUSERS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
}

/*static*/ void dbm::ArchiveManager::Protocol_DBM_Q_ARCH_GET_RELATEDUSERS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "DBM_Q_ARCH_GET_RELATEDUSERS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateInt(_descr, "userId", userId.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void dbm::ArchiveManager::Protocol_DBM_Q_ARCH_GET_RELATEDUSERS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "DBM_Q_ARCH_GET_RELATEDUSERS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_DBM_A_ARCH_GET_RELATEDUSERS
//=================================================================

dbm::ArchiveManager::Protocol_DBM_A_ARCH_GET_RELATEDUSERS::Protocol_DBM_A_ARCH_GET_RELATEDUSERS()
{
	clear();
}

void dbm::ArchiveManager::Protocol_DBM_A_ARCH_GET_RELATEDUSERS::clear()
{
	errCode = 0;
	relatedUsers.clear();
	errString.clear();
}

bool dbm::ArchiveManager::Protocol_DBM_A_ARCH_GET_RELATEDUSERS::equals(const Protocol_DBM_A_ARCH_GET_RELATEDUSERS& _o) const
{
	return errCode == _o.errCode &&
		relatedUsers.equals(_o.relatedUsers) &&
		Atf::atfPStringEquals(errString, _o.errString);
}

bool dbm::ArchiveManager::Protocol_DBM_A_ARCH_GET_RELATEDUSERS::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_A_ARCH_GET_RELATEDUSERS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_A_ARCH_GET_RELATEDUSERS*)_other));
}

const char *dbm::ArchiveManager::Protocol_DBM_A_ARCH_GET_RELATEDUSERS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_A_ARCH_GET_RELATEDUSERS).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode == 0)
	{
		_buf.append(',');
		_buf.append("relatedUsers=");
		relatedUsers.toTraceString(_buf);
	}
	else
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	return _buf.c_str();
}

const char *dbm::ArchiveManager::Protocol_DBM_A_ARCH_GET_RELATEDUSERS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *dbm::ArchiveManager::Protocol_DBM_A_ARCH_GET_RELATEDUSERS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_A_ARCH_GET_RELATEDUSERS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode == 0)
	{
		relatedUsers.toXmlString("relatedUsers", _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool dbm::ArchiveManager::Protocol_DBM_A_ARCH_GET_RELATEDUSERS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("relatedUsers"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< RelatedUsers, 4 > >::FromXmlString(_value, relatedUsers)) return false;
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void dbm::ArchiveManager::Protocol_DBM_A_ARCH_GET_RELATEDUSERS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode == 0)
	{
		relatedUsers.composeMsg(_msg, _ignoreJSON);
	}
	else
	{
		_msg.composeString(errString);
	}
}

void dbm::ArchiveManager::Protocol_DBM_A_ARCH_GET_RELATEDUSERS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode == 0)
	{
		relatedUsers.parseMsg(_parser);
	}
	else
	{
		_parser.parseStringP(errString);
	}
}

const char *dbm::ArchiveManager::Protocol_DBM_A_ARCH_GET_RELATEDUSERS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode == 0)
	{
		_jsonstr.compose("relatedUsers", relatedUsers);
	}
	else
	{
		_jsonstr.compose("errString", errString);
	}
	return _buf.c_str();
}

void dbm::ArchiveManager::Protocol_DBM_A_ARCH_GET_RELATEDUSERS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode == 0)
	{
		_jparser.parseByNameThrow("relatedUsers", relatedUsers);
	}
	else
	{
		_jparser.parseByNameThrow("errString", errString);
	}
}

/*static*/ void dbm::ArchiveManager::Protocol_DBM_A_ARCH_GET_RELATEDUSERS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "DBM_A_ARCH_GET_RELATEDUSERS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode == 0)
	{
		Atf::AtfVectorBase< RelatedUsers > relatedUsers; _jparser.validateByNameThrow("relatedUsers", relatedUsers);
		AtfValidator::validateInt(_descr, "relatedUsers", relatedUsers.size(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString errString; _jparser.validateByNameThrow("errString", errString);
		AtfValidator::validateInt(_descr, "errString", errString.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void dbm::ArchiveManager::Protocol_DBM_A_ARCH_GET_RELATEDUSERS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "DBM_A_ARCH_GET_RELATEDUSERS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode == 0)
	{
		PString _descbuf;
		int szRelatedUsers = Atf::LAtfVector< RelatedUsers, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("relatedUsers"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "relatedUsers", szRelatedUsers, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_DBM_Q_UNARCHIVE_INSERT_RELATEDUSERS
//=================================================================

dbm::ArchiveManager::Protocol_DBM_Q_UNARCHIVE_INSERT_RELATEDUSERS::Protocol_DBM_Q_UNARCHIVE_INSERT_RELATEDUSERS()
{
	clear();
}

void dbm::ArchiveManager::Protocol_DBM_Q_UNARCHIVE_INSERT_RELATEDUSERS::clear()
{
	userIntId = 0;
	userId.clear();
	relatedUsers.clear();
}

bool dbm::ArchiveManager::Protocol_DBM_Q_UNARCHIVE_INSERT_RELATEDUSERS::equals(const Protocol_DBM_Q_UNARCHIVE_INSERT_RELATEDUSERS& _o) const
{
	return userIntId == _o.userIntId &&
		Atf::atfPStringEquals(userId, _o.userId) &&
		relatedUsers.equals(_o.relatedUsers);
}

bool dbm::ArchiveManager::Protocol_DBM_Q_UNARCHIVE_INSERT_RELATEDUSERS::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_Q_UNARCHIVE_INSERT_RELATEDUSERS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_Q_UNARCHIVE_INSERT_RELATEDUSERS*)_other));
}

const char *dbm::ArchiveManager::Protocol_DBM_Q_UNARCHIVE_INSERT_RELATEDUSERS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_Q_UNARCHIVE_INSERT_RELATEDUSERS).append(")");
	_buf.append(',');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("relatedUsers=");
	relatedUsers.toTraceString(_buf);
	return _buf.c_str();
}

const char *dbm::ArchiveManager::Protocol_DBM_Q_UNARCHIVE_INSERT_RELATEDUSERS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *dbm::ArchiveManager::Protocol_DBM_Q_UNARCHIVE_INSERT_RELATEDUSERS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_Q_UNARCHIVE_INSERT_RELATEDUSERS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userIntId", userIntId, _buf);
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	relatedUsers.toXmlString("relatedUsers", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool dbm::ArchiveManager::Protocol_DBM_Q_UNARCHIVE_INSERT_RELATEDUSERS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userIntId"))
			{
				userIntId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("relatedUsers"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< RelatedUsers, 4 > >::FromXmlString(_value, relatedUsers)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void dbm::ArchiveManager::Protocol_DBM_Q_UNARCHIVE_INSERT_RELATEDUSERS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(userIntId);
	_msg.composeString(userId);
	relatedUsers.composeMsg(_msg, _ignoreJSON);
}

void dbm::ArchiveManager::Protocol_DBM_Q_UNARCHIVE_INSERT_RELATEDUSERS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(userIntId);
	_parser.parseStringP(userId);
	relatedUsers.parseMsg(_parser);
}

const char *dbm::ArchiveManager::Protocol_DBM_Q_UNARCHIVE_INSERT_RELATEDUSERS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userIntId", userIntId);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("relatedUsers", relatedUsers);
	return _buf.c_str();
}

void dbm::ArchiveManager::Protocol_DBM_Q_UNARCHIVE_INSERT_RELATEDUSERS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userIntId", userIntId);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("relatedUsers", relatedUsers);
}

/*static*/ void dbm::ArchiveManager::Protocol_DBM_Q_UNARCHIVE_INSERT_RELATEDUSERS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "DBM_Q_UNARCHIVE_INSERT_RELATEDUSERS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 userIntId; _jparser.validateByNameThrow("userIntId", userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateInt(_descr, "userId", userId.length(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< RelatedUsers > relatedUsers; _jparser.validateByNameThrow("relatedUsers", relatedUsers);
	AtfValidator::validateInt(_descr, "relatedUsers", relatedUsers.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void dbm::ArchiveManager::Protocol_DBM_Q_UNARCHIVE_INSERT_RELATEDUSERS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "DBM_Q_UNARCHIVE_INSERT_RELATEDUSERS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 userIntId; _parser.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szRelatedUsers = Atf::LAtfVector< RelatedUsers, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("relatedUsers"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "relatedUsers", szRelatedUsers, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_DBM_A_UNARCHIVE_INSERT_RELATEDUSERS
//=================================================================

dbm::ArchiveManager::Protocol_DBM_A_UNARCHIVE_INSERT_RELATEDUSERS::Protocol_DBM_A_UNARCHIVE_INSERT_RELATEDUSERS()
{
	clear();
}

void dbm::ArchiveManager::Protocol_DBM_A_UNARCHIVE_INSERT_RELATEDUSERS::clear()
{
	errCode = 0;
	errString.clear();
}

bool dbm::ArchiveManager::Protocol_DBM_A_UNARCHIVE_INSERT_RELATEDUSERS::equals(const Protocol_DBM_A_UNARCHIVE_INSERT_RELATEDUSERS& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errString, _o.errString);
}

bool dbm::ArchiveManager::Protocol_DBM_A_UNARCHIVE_INSERT_RELATEDUSERS::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_A_UNARCHIVE_INSERT_RELATEDUSERS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_A_UNARCHIVE_INSERT_RELATEDUSERS*)_other));
}

const char *dbm::ArchiveManager::Protocol_DBM_A_UNARCHIVE_INSERT_RELATEDUSERS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_A_UNARCHIVE_INSERT_RELATEDUSERS).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	return _buf.c_str();
}

const char *dbm::ArchiveManager::Protocol_DBM_A_UNARCHIVE_INSERT_RELATEDUSERS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *dbm::ArchiveManager::Protocol_DBM_A_UNARCHIVE_INSERT_RELATEDUSERS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_A_UNARCHIVE_INSERT_RELATEDUSERS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool dbm::ArchiveManager::Protocol_DBM_A_UNARCHIVE_INSERT_RELATEDUSERS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void dbm::ArchiveManager::Protocol_DBM_A_UNARCHIVE_INSERT_RELATEDUSERS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode != 0)
	{
		_msg.composeString(errString);
	}
}

void dbm::ArchiveManager::Protocol_DBM_A_UNARCHIVE_INSERT_RELATEDUSERS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringP(errString);
	}
}

const char *dbm::ArchiveManager::Protocol_DBM_A_UNARCHIVE_INSERT_RELATEDUSERS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode != 0)
	{
		_jsonstr.compose("errString", errString);
	}
	return _buf.c_str();
}

void dbm::ArchiveManager::Protocol_DBM_A_UNARCHIVE_INSERT_RELATEDUSERS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
}

/*static*/ void dbm::ArchiveManager::Protocol_DBM_A_UNARCHIVE_INSERT_RELATEDUSERS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "DBM_A_UNARCHIVE_INSERT_RELATEDUSERS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode != 0)
	{
		PString errString; _jparser.validateByNameThrow("errString", errString);
		AtfValidator::validateInt(_descr, "errString", errString.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void dbm::ArchiveManager::Protocol_DBM_A_UNARCHIVE_INSERT_RELATEDUSERS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "DBM_A_UNARCHIVE_INSERT_RELATEDUSERS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_DBM_Q_USER_INFO
//=================================================================

dbm::Protocol_DBM_Q_USER_INFO::Protocol_DBM_Q_USER_INFO()
{
	clear();
}

void dbm::Protocol_DBM_Q_USER_INFO::clear()
{
	userId.clear();
	countryByIp.clear();
	stateByIp.clear();
}

bool dbm::Protocol_DBM_Q_USER_INFO::equals(const Protocol_DBM_Q_USER_INFO& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		Atf::atfPStringEquals(countryByIp, _o.countryByIp) &&
		Atf::atfPStringEquals(stateByIp, _o.stateByIp);
}

bool dbm::Protocol_DBM_Q_USER_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_Q_USER_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_Q_USER_INFO*)_other));
}

const char *dbm::Protocol_DBM_Q_USER_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_Q_USER_INFO).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("countryByIp=");
	_buf.append(countryByIp);
	_buf.append(',');
	_buf.append("stateByIp=");
	_buf.append(stateByIp);
	return _buf.c_str();
}

const char *dbm::Protocol_DBM_Q_USER_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *dbm::Protocol_DBM_Q_USER_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_Q_USER_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("countryByIp", countryByIp, _buf);
	Atf::XmlElement::encodeAsXmlElement("stateByIp", stateByIp, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool dbm::Protocol_DBM_Q_USER_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("countryByIp"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, countryByIp)) return false;
			}
			else if (_element.equals("stateByIp"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, stateByIp)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void dbm::Protocol_DBM_Q_USER_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeString(countryByIp);
	_msg.composeString(stateByIp);
}

void dbm::Protocol_DBM_Q_USER_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseStringP(countryByIp);
	_parser.parseStringP(stateByIp);
}

const char *dbm::Protocol_DBM_Q_USER_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("countryByIp", countryByIp);
	_jsonstr.compose("stateByIp", stateByIp);
	return _buf.c_str();
}

void dbm::Protocol_DBM_Q_USER_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("countryByIp", countryByIp);
	_jparser.parseByNameThrow("stateByIp", stateByIp);
}

/*static*/ void dbm::Protocol_DBM_Q_USER_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "DBM_Q_USER_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateInt(_descr, "userId", userId.length(), _checker, __FILE__, __LINE__);
	PString countryByIp; _jparser.validateByNameThrow("countryByIp", countryByIp);
	AtfValidator::validateInt(_descr, "countryByIp", countryByIp.length(), _checker, __FILE__, __LINE__);
	PString stateByIp; _jparser.validateByNameThrow("stateByIp", stateByIp);
	AtfValidator::validateInt(_descr, "stateByIp", stateByIp.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void dbm::Protocol_DBM_Q_USER_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "DBM_Q_USER_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "countryByIp"); size_t szCountryByIp = strlen(_dummy);
	AtfValidator::validateInt(_descr, "countryByIp", szCountryByIp, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "stateByIp"); size_t szStateByIp = strlen(_dummy);
	AtfValidator::validateInt(_descr, "stateByIp", szStateByIp, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    P_UserProperty
//=================================================================

dbm::P_UserProperty::P_UserProperty()
{
	clear();
}

void dbm::P_UserProperty::clear()
{
	propType = 0;
	propInt = 0;
	propStr.clear();
	propWhen.setNull();
}

bool dbm::P_UserProperty::equals(const P_UserProperty& _o) const
{
	return propType == _o.propType &&
		propInt == _o.propInt &&
		Atf::atfPStringEquals(propStr, _o.propStr) &&
		propWhen.equals(_o.propWhen);
}

const char *dbm::P_UserProperty::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("propType=");
	_buf.appendInt(propType);
	_buf.append(',');
	_buf.append("propInt=");
	_buf.appendInt(propInt);
	_buf.append(',');
	_buf.append("propStr=");
	_buf.append(propStr);
	_buf.append(',');
	_buf.append("propWhen=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, propWhen);
	_buf.append('}');
	return _buf.c_str();
}

const char *dbm::P_UserProperty::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("propType", propType, _buf);
	Atf::XmlElement::encodeAsXmlElement("propInt", propInt, _buf);
	Atf::XmlElement::encodeAsXmlElement("propStr", propStr, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "propWhen", propWhen);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool dbm::P_UserProperty::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("propType"))
		{
			propType = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("propInt"))
		{
			propInt = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("propStr"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, propStr)) return false;
		}
		else if (_element.equals("propWhen"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, propWhen);
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void dbm::P_UserProperty::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(propType);
	_msg.composeINT32(propInt);
	_msg.composeString(propStr);
	_msg.composeSrvTime(propWhen);
}

void dbm::P_UserProperty::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(propType);
	_parser.parseINT32(propInt);
	_parser.parseStringP(propStr);
	_parser.parseSrvTime(propWhen);
}

const char *dbm::P_UserProperty::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("propType", propType);
	_jsonstr.compose("propInt", propInt);
	_jsonstr.compose("propStr", propStr);
	_jsonstr.compose("propWhen", propWhen);
	return _buf.c_str();
}

void dbm::P_UserProperty::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("propType", propType);
	_jparser.parseByNameThrow("propInt", propInt);
	_jparser.parseByNameThrow("propStr", propStr);
	_jparser.parseByNameThrow("propWhen", propWhen);
}

/* static */ void dbm::P_UserProperty::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 propType; _jparser.validateByNameThrow("propType", propType);
	AtfValidator::validateInt(_descr, "propType", propType, _checker, __FILE__, __LINE__);
	INT32 propInt; _jparser.validateByNameThrow("propInt", propInt);
	AtfValidator::validateInt(_descr, "propInt", propInt, _checker, __FILE__, __LINE__);
	PString propStr; _jparser.validateByNameThrow("propStr", propStr);
	AtfValidator::validateInt(_descr, "propStr", propStr.length(), _checker, __FILE__, __LINE__);
	SrvTime propWhen; _jparser.validateByNameThrow("propWhen", propWhen);
	AtfValidator::validateSrvDateTime(_descr, "propWhen", propWhen, _checker, __FILE__, __LINE__);
}

/*static*/ void dbm::P_UserProperty::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	INT32 propType; _parser.parseINT32(propType);
	AtfValidator::validateInt(_descr, "propType", propType, _checker, __FILE__, __LINE__);
	INT32 propInt; _parser.parseINT32(propInt);
	AtfValidator::validateInt(_descr, "propInt", propInt, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "propStr"); size_t szPropStr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "propStr", szPropStr, _checker, __FILE__, __LINE__);
	SrvTime propWhen; _parser.parseSrvTime(propWhen);
	AtfValidator::validateSrvDateTime(_descr, "propWhen", propWhen, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_DBM_A_USER_INFO
//=================================================================

dbm::Protocol_DBM_A_USER_INFO::Protocol_DBM_A_USER_INFO()
{
	clear();
}

void dbm::Protocol_DBM_A_USER_INFO::clear()
{
	errcode = 0;
	errstr.clear();
	fullName.clear();
	email.clear();
	addr_1.clear();
	addr_2.clear();
	city.clear();
	state.clear();
	country.clear();
	zipCode.clear();
	image.clear();
	privileges = 0;
	correctedUserFlags = 0;
	effectivePrivileges = 0;
	imageIdUser = 0;
	bonus = 0;
	fppToEarn = 0;
	availAmount = 0;
	phone.clear();
	birthDate.setNull();
	privileges2 = 0;
	effectivePrivileges2 = 0;
	daysExclActual = 0;
	srvExclFrom.setNull();
	srvExclUntil.setNull();
	firstName.clear();
	lastName.clear();
	fiscalCode.clear();
	userProps.clear();
	vipCounter1 = 0;
	vipCounter1Cents = 0;
	vipCounter2 = 0;
	vipCounter2Cents = 0;
	correctedUserFlags2 = 0;
	imageId = 0;
	sex.clear();
	mobile.clear();
	addressStateLocked = false;
	registered.setNull();
	promoName.clear();
	blockingCode = 0;
	privileges3 = 0;
	effectivePrivileges3 = 0;
	missedMonths = 0;
	vipStatusUntil.setNull();
	missableMonthsYearly = 0;
	correctedUserFlags3 = 0;
	brandImages.clear();
	hallOfFameLevel = 0;
	licenseId = 0;
}

bool dbm::Protocol_DBM_A_USER_INFO::equals(const Protocol_DBM_A_USER_INFO& _o) const
{
	return errcode == _o.errcode &&
		Atf::atfPStringEquals(errstr, _o.errstr) &&
		Atf::atfPStringEquals(fullName, _o.fullName) &&
		Atf::atfPStringEquals(email, _o.email) &&
		Atf::atfPStringEquals(addr_1, _o.addr_1) &&
		Atf::atfPStringEquals(addr_2, _o.addr_2) &&
		Atf::atfPStringEquals(city, _o.city) &&
		Atf::atfPStringEquals(state, _o.state) &&
		Atf::atfPStringEquals(country, _o.country) &&
		Atf::atfPStringEquals(zipCode, _o.zipCode) &&
		image.size() == _o.image.size() && memcmp(image.ptr(), _o.image.ptr(), image.size()) == 0 &&
		privileges == _o.privileges &&
		correctedUserFlags == _o.correctedUserFlags &&
		effectivePrivileges == _o.effectivePrivileges &&
		imageIdUser == _o.imageIdUser &&
		bonus == _o.bonus &&
		fppToEarn == _o.fppToEarn &&
		availAmount == _o.availAmount &&
		Atf::atfPStringEquals(phone, _o.phone) &&
		birthDate.equals(_o.birthDate) &&
		privileges2 == _o.privileges2 &&
		effectivePrivileges2 == _o.effectivePrivileges2 &&
		daysExclActual == _o.daysExclActual &&
		srvExclFrom.equals(_o.srvExclFrom) &&
		srvExclUntil.equals(_o.srvExclUntil) &&
		Atf::atfPStringEquals(firstName, _o.firstName) &&
		Atf::atfPStringEquals(lastName, _o.lastName) &&
		Atf::atfPStringEquals(fiscalCode, _o.fiscalCode) &&
		userProps.equals(_o.userProps) &&
		vipCounter1 == _o.vipCounter1 &&
		vipCounter1Cents == _o.vipCounter1Cents &&
		vipCounter2 == _o.vipCounter2 &&
		vipCounter2Cents == _o.vipCounter2Cents &&
		correctedUserFlags2 == _o.correctedUserFlags2 &&
		imageId == _o.imageId &&
		Atf::atfPStringEquals(sex, _o.sex) &&
		Atf::atfPStringEquals(mobile, _o.mobile) &&
		addressStateLocked == _o.addressStateLocked &&
		registered.equals(_o.registered) &&
		Atf::atfPStringEquals(promoName, _o.promoName) &&
		blockingCode == _o.blockingCode &&
		privileges3 == _o.privileges3 &&
		effectivePrivileges3 == _o.effectivePrivileges3 &&
		missedMonths == _o.missedMonths &&
		vipStatusUntil.equals(_o.vipStatusUntil) &&
		missableMonthsYearly == _o.missableMonthsYearly &&
		correctedUserFlags3 == _o.correctedUserFlags3 &&
		brandImages.equals(_o.brandImages) &&
		hallOfFameLevel == _o.hallOfFameLevel &&
		licenseId == _o.licenseId;
}

bool dbm::Protocol_DBM_A_USER_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_A_USER_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_A_USER_INFO*)_other));
}

const char *dbm::Protocol_DBM_A_USER_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_A_USER_INFO).append(")");
	_buf.append(',');
	_buf.append("errcode=");
	_buf.appendInt(errcode);
	if( errcode )
	{
		_buf.append(',');
		_buf.append("errstr=");
		_buf.append(errstr);
	}
	else
	{
		_buf.append(',');
		_buf.append("fullName=");
		_buf.append(fullName);
		_buf.append(',');
		_buf.append("email=");
		_buf.append(email);
		_buf.append(',');
		_buf.append("addr_1=");
		_buf.append(addr_1);
		_buf.append(',');
		_buf.append("addr_2=");
		_buf.append(addr_2);
		_buf.append(',');
		_buf.append("city=");
		_buf.append(city);
		_buf.append(',');
		_buf.append("state=");
		_buf.append(state);
		_buf.append(',');
		_buf.append("country=");
		_buf.append(country);
		_buf.append(',');
		_buf.append("zipCode=");
		_buf.append(zipCode);
		_buf.append(',');
		_buf.append("image=");
		Atf::AtfTempl<PBlock>::ToTraceString(_buf, image);
		_buf.append(',');
		_buf.append("privileges=");
		_buf.appendUint(privileges);
		_buf.append(',');
		_buf.append("correctedUserFlags=");
		_buf.appendUint(correctedUserFlags);
		_buf.append(',');
		_buf.append("effectivePrivileges=");
		_buf.appendUint(effectivePrivileges);
		_buf.append(',');
		_buf.append("imageIdUser=");
		_buf.appendUint(imageIdUser);
		_buf.append(',');
		_buf.append("bonus=");
		_buf.appendUint(bonus);
		_buf.append(',');
		_buf.append("fppToEarn=");
		_buf.appendUint(fppToEarn);
		_buf.append(',');
		_buf.append("availAmount=");
		_buf.appendUint(availAmount);
		_buf.append(',');
		_buf.append("phone=");
		_buf.append(phone);
		_buf.append(',');
		_buf.append("birthDate=");
		Atf::AtfTempl<SrvDate>::ToTraceString(_buf, birthDate);
		_buf.append(',');
		_buf.append("privileges2=");
		_buf.appendUint64(privileges2);
		_buf.append(',');
		_buf.append("effectivePrivileges2=");
		_buf.appendUint64(effectivePrivileges2);
		_buf.append(',');
		_buf.append("daysExclActual=");
		_buf.appendUint(daysExclActual);
		_buf.append(',');
		_buf.append("srvExclFrom=");
		Atf::AtfTempl<SrvTime>::ToTraceString(_buf, srvExclFrom);
		_buf.append(',');
		_buf.append("srvExclUntil=");
		Atf::AtfTempl<SrvTime>::ToTraceString(_buf, srvExclUntil);
		_buf.append(',');
		_buf.append("firstName=");
		_buf.append(firstName);
		_buf.append(',');
		_buf.append("lastName=");
		_buf.append(lastName);
		_buf.append(',');
		_buf.append("fiscalCode=");
		_buf.append(fiscalCode);
		_buf.append(',');
		_buf.append("userProps=");
		userProps.toTraceString(_buf);
		_buf.append(',');
		_buf.append("vipCounter1=");
		_buf.appendUint(vipCounter1);
		_buf.append(',');
		_buf.append("vipCounter1Cents=");
		_buf.appendUint(vipCounter1Cents);
		_buf.append(',');
		_buf.append("vipCounter2=");
		_buf.appendUint(vipCounter2);
		_buf.append(',');
		_buf.append("vipCounter2Cents=");
		_buf.appendUint(vipCounter2Cents);
		_buf.append(',');
		_buf.append("correctedUserFlags2=");
		_buf.appendUint64(correctedUserFlags2);
		_buf.append(',');
		_buf.append("imageId=");
		_buf.appendUint(imageId);
		_buf.append(',');
		_buf.append("sex=");
		_buf.append(sex);
		_buf.append(',');
		_buf.append("mobile=");
		_buf.append(mobile);
		_buf.append(',');
		_buf.append("addressStateLocked=");
		_buf.appendUint(addressStateLocked);
		_buf.append(',');
		_buf.append("registered=");
		Atf::AtfTempl<SrvTime>::ToTraceString(_buf, registered);
		_buf.append(',');
		_buf.append("promoName=");
		_buf.append(promoName);
		_buf.append(',');
		_buf.append("blockingCode=");
		_buf.appendUint(blockingCode);
		_buf.append(',');
		_buf.append("privileges3=");
		_buf.appendUint64(privileges3);
		_buf.append(',');
		_buf.append("effectivePrivileges3=");
		_buf.appendUint64(effectivePrivileges3);
		_buf.append(',');
		_buf.append("missedMonths=");
		_buf.appendInt(missedMonths);
		_buf.append(',');
		_buf.append("vipStatusUntil=");
		Atf::AtfTempl<SrvDate>::ToTraceString(_buf, vipStatusUntil);
		_buf.append(',');
		_buf.append("missableMonthsYearly=");
		_buf.appendInt(missableMonthsYearly);
		_buf.append(',');
		_buf.append("correctedUserFlags3=");
		_buf.appendUint64(correctedUserFlags3);
		_buf.append(',');
		_buf.append("brandImages=");
		brandImages.toTraceString(_buf);
		_buf.append(',');
		_buf.append("hallOfFameLevel=");
		_buf.appendUint(hallOfFameLevel);
		_buf.append(',');
		_buf.append("licenseId=");
		_buf.appendUint(licenseId);
	}
	return _buf.c_str();
}

const char *dbm::Protocol_DBM_A_USER_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *dbm::Protocol_DBM_A_USER_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_A_USER_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errcode", errcode, _buf);
	if( errcode )
	{
		Atf::XmlElement::encodeAsXmlElement("errstr", errstr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("fullName", fullName, _buf);
		Atf::XmlElement::encodeAsXmlElement("email", email, _buf);
		Atf::XmlElement::encodeAsXmlElement("addr_1", addr_1, _buf);
		Atf::XmlElement::encodeAsXmlElement("addr_2", addr_2, _buf);
		Atf::XmlElement::encodeAsXmlElement("city", city, _buf);
		Atf::XmlElement::encodeAsXmlElement("state", state, _buf);
		Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
		Atf::XmlElement::encodeAsXmlElement("zipCode", zipCode, _buf);
		Atf::XmlElement::encodeAsXmlElement("image", image, _buf);
		Atf::XmlElement::encodeAsXmlElement("privileges", privileges, _buf);
		Atf::XmlElement::encodeAsXmlElement("correctedUserFlags", correctedUserFlags, _buf);
		Atf::XmlElement::encodeAsXmlElement("effectivePrivileges", effectivePrivileges, _buf);
		Atf::XmlElement::encodeAsXmlElement("imageIdUser", imageIdUser, _buf);
		Atf::XmlElement::encodeAsXmlElement("bonus", bonus, _buf);
		Atf::XmlElement::encodeAsXmlElement("fppToEarn", fppToEarn, _buf);
		Atf::XmlElement::encodeAsXmlElement("availAmount", availAmount, _buf);
		Atf::XmlElement::encodeAsXmlElement("phone", phone, _buf);
		Atf::AtfTempl<SrvDate>::ToXmlString(_buf, "birthDate", birthDate);
		Atf::XmlElement::encodeAsXmlElement("privileges2", privileges2, _buf);
		Atf::XmlElement::encodeAsXmlElement("effectivePrivileges2", effectivePrivileges2, _buf);
		Atf::XmlElement::encodeAsXmlElement("daysExclActual", daysExclActual, _buf);
		Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "srvExclFrom", srvExclFrom);
		Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "srvExclUntil", srvExclUntil);
		Atf::XmlElement::encodeAsXmlElement("firstName", firstName, _buf);
		Atf::XmlElement::encodeAsXmlElement("lastName", lastName, _buf);
		Atf::XmlElement::encodeAsXmlElement("fiscalCode", fiscalCode, _buf);
		userProps.toXmlString("userProps", _buf);
		Atf::XmlElement::encodeAsXmlElement("vipCounter1", vipCounter1, _buf);
		Atf::XmlElement::encodeAsXmlElement("vipCounter1Cents", vipCounter1Cents, _buf);
		Atf::XmlElement::encodeAsXmlElement("vipCounter2", vipCounter2, _buf);
		Atf::XmlElement::encodeAsXmlElement("vipCounter2Cents", vipCounter2Cents, _buf);
		Atf::XmlElement::encodeAsXmlElement("correctedUserFlags2", correctedUserFlags2, _buf);
		Atf::XmlElement::encodeAsXmlElement("imageId", imageId, _buf);
		Atf::XmlElement::encodeAsXmlElement("sex", sex, _buf);
		Atf::XmlElement::encodeAsXmlElement("mobile", mobile, _buf);
		Atf::XmlElement::encodeAsXmlElement("addressStateLocked", addressStateLocked, _buf);
		Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "registered", registered);
		Atf::XmlElement::encodeAsXmlElement("promoName", promoName, _buf);
		Atf::XmlElement::encodeAsXmlElement("blockingCode", blockingCode, _buf);
		Atf::XmlElement::encodeAsXmlElement("privileges3", privileges3, _buf);
		Atf::XmlElement::encodeAsXmlElement("effectivePrivileges3", effectivePrivileges3, _buf);
		Atf::XmlElement::encodeAsXmlElement("missedMonths", missedMonths, _buf);
		Atf::AtfTempl<SrvDate>::ToXmlString(_buf, "vipStatusUntil", vipStatusUntil);
		Atf::XmlElement::encodeAsXmlElement("missableMonthsYearly", missableMonthsYearly, _buf);
		Atf::XmlElement::encodeAsXmlElement("correctedUserFlags3", correctedUserFlags3, _buf);
		brandImages.toXmlString("brandImages", _buf);
		Atf::XmlElement::encodeAsXmlElement("hallOfFameLevel", hallOfFameLevel, _buf);
		Atf::XmlElement::encodeAsXmlElement("licenseId", licenseId, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool dbm::Protocol_DBM_A_USER_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errcode"))
			{
				errcode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errstr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errstr)) return false;
			}
			else if (_element.equals("fullName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, fullName)) return false;
			}
			else if (_element.equals("email"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, email)) return false;
			}
			else if (_element.equals("addr_1"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, addr_1)) return false;
			}
			else if (_element.equals("addr_2"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, addr_2)) return false;
			}
			else if (_element.equals("city"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, city)) return false;
			}
			else if (_element.equals("state"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, state)) return false;
			}
			else if (_element.equals("country"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
			}
			else if (_element.equals("zipCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, zipCode)) return false;
			}
			else if (_element.equals("image"))
			{
				Atf::XmlElement::_movePBlockWithNullStrip(_value, image);
			}
			else if (_element.equals("privileges"))
			{
				privileges = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("correctedUserFlags"))
			{
				correctedUserFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("effectivePrivileges"))
			{
				effectivePrivileges = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("imageIdUser"))
			{
				imageIdUser = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("bonus"))
			{
				bonus = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("fppToEarn"))
			{
				fppToEarn = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("availAmount"))
			{
				availAmount = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("phone"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, phone)) return false;
			}
			else if (_element.equals("birthDate"))
			{
				Atf::AtfTempl<SrvDate>::FromXmlString(_value, birthDate);
			}
			else if (_element.equals("privileges2"))
			{
				privileges2 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("effectivePrivileges2"))
			{
				effectivePrivileges2 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("daysExclActual"))
			{
				daysExclActual = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("srvExclFrom"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, srvExclFrom);
			}
			else if (_element.equals("srvExclUntil"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, srvExclUntil);
			}
			else if (_element.equals("firstName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, firstName)) return false;
			}
			else if (_element.equals("lastName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, lastName)) return false;
			}
			else if (_element.equals("fiscalCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, fiscalCode)) return false;
			}
			else if (_element.equals("userProps"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< P_UserProperty, 4 > >::FromXmlString(_value, userProps)) return false;
			}
			else if (_element.equals("vipCounter1"))
			{
				vipCounter1 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("vipCounter1Cents"))
			{
				vipCounter1Cents = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("vipCounter2"))
			{
				vipCounter2 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("vipCounter2Cents"))
			{
				vipCounter2Cents = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("correctedUserFlags2"))
			{
				correctedUserFlags2 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("imageId"))
			{
				imageId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("sex"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, sex)) return false;
			}
			else if (_element.equals("mobile"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, mobile)) return false;
			}
			else if (_element.equals("addressStateLocked"))
			{
				addressStateLocked = (*_value.ptr() == '1');
			}
			else if (_element.equals("registered"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, registered);
			}
			else if (_element.equals("promoName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, promoName)) return false;
			}
			else if (_element.equals("blockingCode"))
			{
				blockingCode = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("privileges3"))
			{
				privileges3 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("effectivePrivileges3"))
			{
				effectivePrivileges3 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("missedMonths"))
			{
				missedMonths = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("vipStatusUntil"))
			{
				Atf::AtfTempl<SrvDate>::FromXmlString(_value, vipStatusUntil);
			}
			else if (_element.equals("missableMonthsYearly"))
			{
				missableMonthsYearly = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("correctedUserFlags3"))
			{
				correctedUserFlags3 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("brandImages"))
			{
				if(!Atf::AtfTempl< BrandProt::BrandImageList >::FromXmlString(_value, brandImages)) return false;
			}
			else if (_element.equals("hallOfFameLevel"))
			{
				hallOfFameLevel = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("licenseId"))
			{
				licenseId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void dbm::Protocol_DBM_A_USER_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errcode);
	if( errcode )
	{
		_msg.composeString(errstr);
	}
	else
	{
		_msg.composeString(fullName);
		_msg.composeString(email);
		_msg.composeString(addr_1);
		_msg.composeString(addr_2);
		_msg.composeString(city);
		_msg.composeString(state);
		_msg.composeString(country);
		_msg.composeString(zipCode);
		_msg._composeVarBlock(image.ptr(), image.size());
		_msg.composeUINT32(privileges);
		_msg.composeUINT32(correctedUserFlags);
		_msg.composeUINT32(effectivePrivileges);
		_msg.composeUINT32(imageIdUser);
		_msg.composeUINT32(bonus);
		_msg.composeUINT32(fppToEarn);
		_msg.composeUINT32(availAmount);
		_msg.composeString(phone);
		_msg.composeSrvDate(birthDate);
		_msg.composeUINT64(privileges2);
		_msg.composeUINT64(effectivePrivileges2);
		_msg.composeUINT32(daysExclActual);
		_msg.composeSrvTime(srvExclFrom);
		_msg.composeSrvTime(srvExclUntil);
		_msg.composeString(firstName);
		_msg.composeString(lastName);
		_msg.composeString(fiscalCode);
		userProps.composeMsg(_msg, _ignoreJSON);
		_msg.composeUINT32(vipCounter1);
		_msg.composeUINT16(vipCounter1Cents);
		_msg.composeUINT32(vipCounter2);
		_msg.composeUINT16(vipCounter2Cents);
		_msg.composeUINT64(correctedUserFlags2);
		_msg.composeUINT32(imageId);
		_msg.composeString(sex);
		_msg.composeString(mobile);
		_msg.composeBOOL(addressStateLocked);
		_msg.composeSrvTime(registered);
		_msg.composeString(promoName);
		_msg.composeUINT32(blockingCode);
		_msg.composeUINT64(privileges3);
		_msg.composeUINT64(effectivePrivileges3);
		_msg.composeINT8(missedMonths);
		_msg.composeSrvDate(vipStatusUntil);
		_msg.composeINT8(missableMonthsYearly);
		_msg.composeUINT64(correctedUserFlags3);
		brandImages.composeMsg(_msg, _ignoreJSON);
		_msg.composeUINT32(hallOfFameLevel);
		_msg.composeUINT32(licenseId);
	}
}

void dbm::Protocol_DBM_A_USER_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errcode);
	if( errcode )
	{
		_parser.parseStringP(errstr);
	}
	else
	{
		_parser.parseStringP(fullName);
		_parser.parseStringP(email);
		_parser.parseStringP(addr_1);
		_parser.parseStringP(addr_2);
		_parser.parseStringP(city);
		_parser.parseStringP(state);
		_parser.parseStringP(country);
		_parser.parseStringP(zipCode);
		_parser.parsePBlock(image);
		_parser.parseUINT32(privileges);
		_parser.parseUINT32(correctedUserFlags);
		_parser.parseUINT32(effectivePrivileges);
		_parser.parseUINT32(imageIdUser);
		_parser.parseUINT32(bonus);
		_parser.parseUINT32(fppToEarn);
		_parser.parseUINT32(availAmount);
		_parser.parseStringP(phone);
		_parser.parseSrvDate(birthDate);
		_parser.parseUINT64(privileges2);
		_parser.parseUINT64(effectivePrivileges2);
		_parser.parseUINT32(daysExclActual);
		_parser.parseSrvTime(srvExclFrom);
		_parser.parseSrvTime(srvExclUntil);
		_parser.parseStringP(firstName);
		_parser.parseStringP(lastName);
		_parser.parseStringP(fiscalCode);
		userProps.parseMsg(_parser);
		_parser.parseUINT32(vipCounter1);
		_parser.parseUINT16(vipCounter1Cents);
		_parser.parseUINT32(vipCounter2);
		_parser.parseUINT16(vipCounter2Cents);
		_parser.parseUINT64(correctedUserFlags2);
		_parser.parseUINT32(imageId);
		_parser.parseStringP(sex);
		_parser.parseStringP(mobile);
		_parser.parseBOOL(addressStateLocked);
		_parser.parseSrvTime(registered);
		_parser.parseStringP(promoName);
		_parser.parseUINT32(blockingCode);
		_parser.parseUINT64(privileges3);
		_parser.parseUINT64(effectivePrivileges3);
		_parser.parseINT8(missedMonths);
		_parser.parseSrvDate(vipStatusUntil);
		_parser.parseINT8(missableMonthsYearly);
		_parser.parseUINT64(correctedUserFlags3);
		brandImages.parseMsg(_parser);
		_parser.parseUINT32(hallOfFameLevel);
		_parser.parseUINT32(licenseId);
	}
}

const char *dbm::Protocol_DBM_A_USER_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errcode", errcode);
	if( errcode )
	{
		_jsonstr.compose("errstr", errstr);
	}
	else
	{
		_jsonstr.compose("fullName", fullName);
		_jsonstr.compose("email", email);
		_jsonstr.compose("addr_1", addr_1);
		_jsonstr.compose("addr_2", addr_2);
		_jsonstr.compose("city", city);
		_jsonstr.compose("state", state);
		_jsonstr.compose("country", country);
		_jsonstr.compose("zipCode", zipCode);
		_jsonstr.compose("image", image);
		_jsonstr.compose("privileges", privileges);
		_jsonstr.compose("correctedUserFlags", correctedUserFlags);
		_jsonstr.compose("effectivePrivileges", effectivePrivileges);
		_jsonstr.compose("imageIdUser", imageIdUser);
		_jsonstr.compose("bonus", bonus);
		_jsonstr.compose("fppToEarn", fppToEarn);
		_jsonstr.compose("availAmount", availAmount);
		_jsonstr.compose("phone", phone);
		_jsonstr.compose("birthDate", birthDate);
		_jsonstr.compose("privileges2", privileges2);
		_jsonstr.compose("effectivePrivileges2", effectivePrivileges2);
		_jsonstr.compose("daysExclActual", daysExclActual);
		_jsonstr.compose("srvExclFrom", srvExclFrom);
		_jsonstr.compose("srvExclUntil", srvExclUntil);
		_jsonstr.compose("firstName", firstName);
		_jsonstr.compose("lastName", lastName);
		_jsonstr.compose("fiscalCode", fiscalCode);
		_jsonstr.compose("userProps", userProps);
		_jsonstr.compose("vipCounter1", vipCounter1);
		_jsonstr.compose("vipCounter1Cents", vipCounter1Cents);
		_jsonstr.compose("vipCounter2", vipCounter2);
		_jsonstr.compose("vipCounter2Cents", vipCounter2Cents);
		_jsonstr.compose("correctedUserFlags2", correctedUserFlags2);
		_jsonstr.compose("imageId", imageId);
		_jsonstr.compose("sex", sex);
		_jsonstr.compose("mobile", mobile);
		_jsonstr.compose("addressStateLocked", addressStateLocked);
		_jsonstr.compose("registered", registered);
		_jsonstr.compose("promoName", promoName);
		_jsonstr.compose("blockingCode", blockingCode);
		_jsonstr.compose("privileges3", privileges3);
		_jsonstr.compose("effectivePrivileges3", effectivePrivileges3);
		_jsonstr.compose("missedMonths", missedMonths);
		_jsonstr.compose("vipStatusUntil", vipStatusUntil);
		_jsonstr.compose("missableMonthsYearly", missableMonthsYearly);
		_jsonstr.compose("correctedUserFlags3", correctedUserFlags3);
		_jsonstr.compose("brandImages", brandImages);
		_jsonstr.compose("hallOfFameLevel", hallOfFameLevel);
		_jsonstr.compose("licenseId", licenseId);
	}
	return _buf.c_str();
}

void dbm::Protocol_DBM_A_USER_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errcode", errcode);
	if( errcode )
	{
		_jparser.parseByNameThrow("errstr", errstr);
	}
	else
	{
		_jparser.parseByNameThrow("fullName", fullName);
		_jparser.parseByNameThrow("email", email);
		_jparser.parseByNameThrow("addr_1", addr_1);
		_jparser.parseByNameThrow("addr_2", addr_2);
		_jparser.parseByNameThrow("city", city);
		_jparser.parseByNameThrow("state", state);
		_jparser.parseByNameThrow("country", country);
		_jparser.parseByNameThrow("zipCode", zipCode);
		_jparser.parseByNameThrow("image", image);
		_jparser.parseByNameThrow("privileges", privileges);
		_jparser.parseByNameThrow("correctedUserFlags", correctedUserFlags);
		_jparser.parseByNameThrow("effectivePrivileges", effectivePrivileges);
		_jparser.parseByNameThrow("imageIdUser", imageIdUser);
		_jparser.parseByNameThrow("bonus", bonus);
		_jparser.parseByNameThrow("fppToEarn", fppToEarn);
		_jparser.parseByNameThrow("availAmount", availAmount);
		_jparser.parseByNameThrow("phone", phone);
		_jparser.parseByNameThrow("birthDate", birthDate);
		_jparser.parseByNameThrow("privileges2", privileges2);
		_jparser.parseByNameThrow("effectivePrivileges2", effectivePrivileges2);
		_jparser.parseByNameThrow("daysExclActual", daysExclActual);
		_jparser.parseByNameThrow("srvExclFrom", srvExclFrom);
		_jparser.parseByNameThrow("srvExclUntil", srvExclUntil);
		_jparser.parseByNameThrow("firstName", firstName);
		_jparser.parseByNameThrow("lastName", lastName);
		_jparser.parseByNameThrow("fiscalCode", fiscalCode);
		_jparser.parseByNameThrow("userProps", userProps);
		_jparser.parseByNameThrow("vipCounter1", vipCounter1);
		_jparser.parseByNameThrow("vipCounter1Cents", vipCounter1Cents);
		_jparser.parseByNameThrow("vipCounter2", vipCounter2);
		_jparser.parseByNameThrow("vipCounter2Cents", vipCounter2Cents);
		_jparser.parseByNameThrow("correctedUserFlags2", correctedUserFlags2);
		_jparser.parseByNameThrow("imageId", imageId);
		_jparser.parseByNameThrow("sex", sex);
		_jparser.parseByNameThrow("mobile", mobile);
		_jparser.parseByNameThrow("addressStateLocked", addressStateLocked);
		_jparser.parseByNameThrow("registered", registered);
		_jparser.parseByNameThrow("promoName", promoName);
		_jparser.parseByNameThrow("blockingCode", blockingCode);
		_jparser.parseByNameThrow("privileges3", privileges3);
		_jparser.parseByNameThrow("effectivePrivileges3", effectivePrivileges3);
		_jparser.parseByNameThrow("missedMonths", missedMonths);
		_jparser.parseByNameThrow("vipStatusUntil", vipStatusUntil);
		_jparser.parseByNameThrow("missableMonthsYearly", missableMonthsYearly);
		_jparser.parseByNameThrow("correctedUserFlags3", correctedUserFlags3);
		_jparser.parseByNameThrow("brandImages", brandImages);
		_jparser.parseByNameThrow("hallOfFameLevel", hallOfFameLevel);
		_jparser.parseByNameThrow("licenseId", licenseId);
	}
}

/*static*/ void dbm::Protocol_DBM_A_USER_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "DBM_A_USER_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errcode = 0;
	_jparser.validateByNameThrow("errcode", errcode);
	AtfValidator::validateInt(_descr, "errcode", errcode, _checker, __FILE__, __LINE__);
	if( errcode )
	{
		PString errstr; _jparser.validateByNameThrow("errstr", errstr);
		AtfValidator::validateInt(_descr, "errstr", errstr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString fullName; _jparser.validateByNameThrow("fullName", fullName);
		AtfValidator::validateInt(_descr, "fullName", fullName.length(), _checker, __FILE__, __LINE__);
		PString email; _jparser.validateByNameThrow("email", email);
		AtfValidator::validateInt(_descr, "email", email.length(), _checker, __FILE__, __LINE__);
		PString addr_1; _jparser.validateByNameThrow("addr_1", addr_1);
		AtfValidator::validateInt(_descr, "addr_1", addr_1.length(), _checker, __FILE__, __LINE__);
		PString addr_2; _jparser.validateByNameThrow("addr_2", addr_2);
		AtfValidator::validateInt(_descr, "addr_2", addr_2.length(), _checker, __FILE__, __LINE__);
		PString city; _jparser.validateByNameThrow("city", city);
		AtfValidator::validateInt(_descr, "city", city.length(), _checker, __FILE__, __LINE__);
		PString state; _jparser.validateByNameThrow("state", state);
		AtfValidator::validateInt(_descr, "state", state.length(), _checker, __FILE__, __LINE__);
		PString country; _jparser.validateByNameThrow("country", country);
		AtfValidator::validateInt(_descr, "country", country.length(), _checker, __FILE__, __LINE__);
		PString zipCode; _jparser.validateByNameThrow("zipCode", zipCode);
		AtfValidator::validateInt(_descr, "zipCode", zipCode.length(), _checker, __FILE__, __LINE__);
		PBlock image; _jparser.validateByNameThrow("image", image);
		AtfValidator::validateInt(_descr, "image", image.size(), _checker, __FILE__, __LINE__);
		UINT32 privileges; _jparser.validateByNameThrow("privileges", privileges);
		AtfValidator::validateInt(_descr, "privileges", privileges, _checker, __FILE__, __LINE__);
		UINT32 correctedUserFlags; _jparser.validateByNameThrow("correctedUserFlags", correctedUserFlags);
		AtfValidator::validateInt(_descr, "correctedUserFlags", correctedUserFlags, _checker, __FILE__, __LINE__);
		UINT32 effectivePrivileges; _jparser.validateByNameThrow("effectivePrivileges", effectivePrivileges);
		AtfValidator::validateInt(_descr, "effectivePrivileges", effectivePrivileges, _checker, __FILE__, __LINE__);
		UINT32 imageIdUser; _jparser.validateByNameThrow("imageIdUser", imageIdUser);
		AtfValidator::validateInt(_descr, "imageIdUser", imageIdUser, _checker, __FILE__, __LINE__);
		UINT32 bonus; _jparser.validateByNameThrow("bonus", bonus);
		AtfValidator::validateInt(_descr, "bonus", bonus, _checker, __FILE__, __LINE__);
		UINT32 fppToEarn; _jparser.validateByNameThrow("fppToEarn", fppToEarn);
		AtfValidator::validateInt(_descr, "fppToEarn", fppToEarn, _checker, __FILE__, __LINE__);
		UINT32 availAmount; _jparser.validateByNameThrow("availAmount", availAmount);
		AtfValidator::validateInt(_descr, "availAmount", availAmount, _checker, __FILE__, __LINE__);
		PString phone; _jparser.validateByNameThrow("phone", phone);
		AtfValidator::validateInt(_descr, "phone", phone.length(), _checker, __FILE__, __LINE__);
		SrvDate birthDate; _jparser.validateByNameThrow("birthDate", birthDate);
		AtfValidator::validateSrvDateTime(_descr, "birthDate", birthDate, _checker, __FILE__, __LINE__);
		UINT64 privileges2; _jparser.validateByNameThrow("privileges2", privileges2);
		AtfValidator::validateUint(_descr, "privileges2", privileges2, _checker, __FILE__, __LINE__);
		UINT64 effectivePrivileges2; _jparser.validateByNameThrow("effectivePrivileges2", effectivePrivileges2);
		AtfValidator::validateUint(_descr, "effectivePrivileges2", effectivePrivileges2, _checker, __FILE__, __LINE__);
		UINT32 daysExclActual; _jparser.validateByNameThrow("daysExclActual", daysExclActual);
		AtfValidator::validateInt(_descr, "daysExclActual", daysExclActual, _checker, __FILE__, __LINE__);
		SrvTime srvExclFrom; _jparser.validateByNameThrow("srvExclFrom", srvExclFrom);
		AtfValidator::validateSrvDateTime(_descr, "srvExclFrom", srvExclFrom, _checker, __FILE__, __LINE__);
		SrvTime srvExclUntil; _jparser.validateByNameThrow("srvExclUntil", srvExclUntil);
		AtfValidator::validateSrvDateTime(_descr, "srvExclUntil", srvExclUntil, _checker, __FILE__, __LINE__);
		PString firstName; _jparser.validateByNameThrow("firstName", firstName);
		AtfValidator::validateInt(_descr, "firstName", firstName.length(), _checker, __FILE__, __LINE__);
		PString lastName; _jparser.validateByNameThrow("lastName", lastName);
		AtfValidator::validateInt(_descr, "lastName", lastName.length(), _checker, __FILE__, __LINE__);
		PString fiscalCode; _jparser.validateByNameThrow("fiscalCode", fiscalCode);
		AtfValidator::validateInt(_descr, "fiscalCode", fiscalCode.length(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< P_UserProperty > userProps; _jparser.validateByNameThrow("userProps", userProps);
		AtfValidator::validateInt(_descr, "userProps", userProps.size(), _checker, __FILE__, __LINE__);
		UINT32 vipCounter1; _jparser.validateByNameThrow("vipCounter1", vipCounter1);
		AtfValidator::validateInt(_descr, "vipCounter1", vipCounter1, _checker, __FILE__, __LINE__);
		UINT16 vipCounter1Cents; _jparser.validateByNameThrow("vipCounter1Cents", vipCounter1Cents);
		AtfValidator::validateInt(_descr, "vipCounter1Cents", vipCounter1Cents, _checker, __FILE__, __LINE__);
		UINT32 vipCounter2; _jparser.validateByNameThrow("vipCounter2", vipCounter2);
		AtfValidator::validateInt(_descr, "vipCounter2", vipCounter2, _checker, __FILE__, __LINE__);
		UINT16 vipCounter2Cents; _jparser.validateByNameThrow("vipCounter2Cents", vipCounter2Cents);
		AtfValidator::validateInt(_descr, "vipCounter2Cents", vipCounter2Cents, _checker, __FILE__, __LINE__);
		UINT64 correctedUserFlags2; _jparser.validateByNameThrow("correctedUserFlags2", correctedUserFlags2);
		AtfValidator::validateUint(_descr, "correctedUserFlags2", correctedUserFlags2, _checker, __FILE__, __LINE__);
		UINT32 imageId; _jparser.validateByNameThrow("imageId", imageId);
		AtfValidator::validateInt(_descr, "imageId", imageId, _checker, __FILE__, __LINE__);
		PString sex; _jparser.validateByNameThrow("sex", sex);
		AtfValidator::validateInt(_descr, "sex", sex.length(), _checker, __FILE__, __LINE__);
		PString mobile; _jparser.validateByNameThrow("mobile", mobile);
		AtfValidator::validateInt(_descr, "mobile", mobile.length(), _checker, __FILE__, __LINE__);
		bool addressStateLocked; _jparser.validateByNameThrow("addressStateLocked", addressStateLocked);
		AtfValidator::validateInt(_descr, "addressStateLocked", addressStateLocked, _checker, __FILE__, __LINE__);
		SrvTime registered; _jparser.validateByNameThrow("registered", registered);
		AtfValidator::validateSrvDateTime(_descr, "registered", registered, _checker, __FILE__, __LINE__);
		PString promoName; _jparser.validateByNameThrow("promoName", promoName);
		AtfValidator::validateInt(_descr, "promoName", promoName.length(), _checker, __FILE__, __LINE__);
		UINT32 blockingCode; _jparser.validateByNameThrow("blockingCode", blockingCode);
		AtfValidator::validateInt(_descr, "blockingCode", blockingCode, _checker, __FILE__, __LINE__);
		UINT64 privileges3; _jparser.validateByNameThrow("privileges3", privileges3);
		AtfValidator::validateUint(_descr, "privileges3", privileges3, _checker, __FILE__, __LINE__);
		UINT64 effectivePrivileges3; _jparser.validateByNameThrow("effectivePrivileges3", effectivePrivileges3);
		AtfValidator::validateUint(_descr, "effectivePrivileges3", effectivePrivileges3, _checker, __FILE__, __LINE__);
		INT8 missedMonths; _jparser.validateByNameThrow("missedMonths", missedMonths);
		AtfValidator::validateInt(_descr, "missedMonths", missedMonths, _checker, __FILE__, __LINE__);
		SrvDate vipStatusUntil; _jparser.validateByNameThrow("vipStatusUntil", vipStatusUntil);
		AtfValidator::validateSrvDateTime(_descr, "vipStatusUntil", vipStatusUntil, _checker, __FILE__, __LINE__);
		INT8 missableMonthsYearly; _jparser.validateByNameThrow("missableMonthsYearly", missableMonthsYearly);
		AtfValidator::validateInt(_descr, "missableMonthsYearly", missableMonthsYearly, _checker, __FILE__, __LINE__);
		UINT64 correctedUserFlags3; _jparser.validateByNameThrow("correctedUserFlags3", correctedUserFlags3);
		AtfValidator::validateUint(_descr, "correctedUserFlags3", correctedUserFlags3, _checker, __FILE__, __LINE__);
		BrandProt::BrandImageList brandImages; _jparser.validateByNameThrow("brandImages", brandImages);
		UINT32 hallOfFameLevel; _jparser.validateByNameThrow("hallOfFameLevel", hallOfFameLevel);
		AtfValidator::validateInt(_descr, "hallOfFameLevel", hallOfFameLevel, _checker, __FILE__, __LINE__);
		UINT32 licenseId; _jparser.validateByNameThrow("licenseId", licenseId);
		AtfValidator::validateInt(_descr, "licenseId", licenseId, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void dbm::Protocol_DBM_A_USER_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "DBM_A_USER_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errcode = 0;
	_parser.parseINT16(errcode);
	AtfValidator::validateInt(_descr, "errcode", errcode, _checker, __FILE__, __LINE__);
	if( errcode )
	{
		_parser.parseStringN(_dummy, 0, "errstr"); size_t szErrstr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errstr", szErrstr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "fullName"); size_t szFullName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "fullName", szFullName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
		AtfValidator::validateInt(_descr, "email", szEmail, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "addr_1"); size_t szAddr_1 = strlen(_dummy);
		AtfValidator::validateInt(_descr, "addr_1", szAddr_1, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "addr_2"); size_t szAddr_2 = strlen(_dummy);
		AtfValidator::validateInt(_descr, "addr_2", szAddr_2, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
		AtfValidator::validateInt(_descr, "city", szCity, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "state"); size_t szState = strlen(_dummy);
		AtfValidator::validateInt(_descr, "state", szState, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
		AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "zipCode"); size_t szZipCode = strlen(_dummy);
		AtfValidator::validateInt(_descr, "zipCode", szZipCode, _checker, __FILE__, __LINE__);
		const BYTE* image; size_t szImage; _parser._parseVarBlock(image, szImage);  /*image*/
		AtfValidator::validateInt(_descr, "image", szImage, _checker, __FILE__, __LINE__);
		UINT32 privileges; _parser.parseUINT32(privileges);
		AtfValidator::validateInt(_descr, "privileges", privileges, _checker, __FILE__, __LINE__);
		UINT32 correctedUserFlags; _parser.parseUINT32(correctedUserFlags);
		AtfValidator::validateInt(_descr, "correctedUserFlags", correctedUserFlags, _checker, __FILE__, __LINE__);
		UINT32 effectivePrivileges; _parser.parseUINT32(effectivePrivileges);
		AtfValidator::validateInt(_descr, "effectivePrivileges", effectivePrivileges, _checker, __FILE__, __LINE__);
		UINT32 imageIdUser; _parser.parseUINT32(imageIdUser);
		AtfValidator::validateInt(_descr, "imageIdUser", imageIdUser, _checker, __FILE__, __LINE__);
		UINT32 bonus; _parser.parseUINT32(bonus);
		AtfValidator::validateInt(_descr, "bonus", bonus, _checker, __FILE__, __LINE__);
		UINT32 fppToEarn; _parser.parseUINT32(fppToEarn);
		AtfValidator::validateInt(_descr, "fppToEarn", fppToEarn, _checker, __FILE__, __LINE__);
		UINT32 availAmount; _parser.parseUINT32(availAmount);
		AtfValidator::validateInt(_descr, "availAmount", availAmount, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "phone"); size_t szPhone = strlen(_dummy);
		AtfValidator::validateInt(_descr, "phone", szPhone, _checker, __FILE__, __LINE__);
		SrvDate birthDate; _parser.parseSrvDate(birthDate);
		AtfValidator::validateSrvDateTime(_descr, "birthDate", birthDate, _checker, __FILE__, __LINE__);
		UINT64 privileges2; _parser.parseUINT64(privileges2);
		AtfValidator::validateUint(_descr, "privileges2", privileges2, _checker, __FILE__, __LINE__);
		UINT64 effectivePrivileges2; _parser.parseUINT64(effectivePrivileges2);
		AtfValidator::validateUint(_descr, "effectivePrivileges2", effectivePrivileges2, _checker, __FILE__, __LINE__);
		UINT32 daysExclActual; _parser.parseUINT32(daysExclActual);
		AtfValidator::validateInt(_descr, "daysExclActual", daysExclActual, _checker, __FILE__, __LINE__);
		SrvTime srvExclFrom; _parser.parseSrvTime(srvExclFrom);
		AtfValidator::validateSrvDateTime(_descr, "srvExclFrom", srvExclFrom, _checker, __FILE__, __LINE__);
		SrvTime srvExclUntil; _parser.parseSrvTime(srvExclUntil);
		AtfValidator::validateSrvDateTime(_descr, "srvExclUntil", srvExclUntil, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "firstName"); size_t szFirstName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "firstName", szFirstName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "lastName"); size_t szLastName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "lastName", szLastName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "fiscalCode"); size_t szFiscalCode = strlen(_dummy);
		AtfValidator::validateInt(_descr, "fiscalCode", szFiscalCode, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szUserProps = Atf::LAtfVector< P_UserProperty, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("userProps"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "userProps", szUserProps, _checker, __FILE__, __LINE__);
		UINT32 vipCounter1; _parser.parseUINT32(vipCounter1);
		AtfValidator::validateInt(_descr, "vipCounter1", vipCounter1, _checker, __FILE__, __LINE__);
		UINT16 vipCounter1Cents; _parser.parseUINT16(vipCounter1Cents);
		AtfValidator::validateInt(_descr, "vipCounter1Cents", vipCounter1Cents, _checker, __FILE__, __LINE__);
		UINT32 vipCounter2; _parser.parseUINT32(vipCounter2);
		AtfValidator::validateInt(_descr, "vipCounter2", vipCounter2, _checker, __FILE__, __LINE__);
		UINT16 vipCounter2Cents; _parser.parseUINT16(vipCounter2Cents);
		AtfValidator::validateInt(_descr, "vipCounter2Cents", vipCounter2Cents, _checker, __FILE__, __LINE__);
		UINT64 correctedUserFlags2; _parser.parseUINT64(correctedUserFlags2);
		AtfValidator::validateUint(_descr, "correctedUserFlags2", correctedUserFlags2, _checker, __FILE__, __LINE__);
		UINT32 imageId; _parser.parseUINT32(imageId);
		AtfValidator::validateInt(_descr, "imageId", imageId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "sex"); size_t szSex = strlen(_dummy);
		AtfValidator::validateInt(_descr, "sex", szSex, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "mobile"); size_t szMobile = strlen(_dummy);
		AtfValidator::validateInt(_descr, "mobile", szMobile, _checker, __FILE__, __LINE__);
		bool addressStateLocked; _parser.parseBOOL(addressStateLocked);
		AtfValidator::validateInt(_descr, "addressStateLocked", addressStateLocked, _checker, __FILE__, __LINE__);
		SrvTime registered; _parser.parseSrvTime(registered);
		AtfValidator::validateSrvDateTime(_descr, "registered", registered, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "promoName"); size_t szPromoName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "promoName", szPromoName, _checker, __FILE__, __LINE__);
		UINT32 blockingCode; _parser.parseUINT32(blockingCode);
		AtfValidator::validateInt(_descr, "blockingCode", blockingCode, _checker, __FILE__, __LINE__);
		UINT64 privileges3; _parser.parseUINT64(privileges3);
		AtfValidator::validateUint(_descr, "privileges3", privileges3, _checker, __FILE__, __LINE__);
		UINT64 effectivePrivileges3; _parser.parseUINT64(effectivePrivileges3);
		AtfValidator::validateUint(_descr, "effectivePrivileges3", effectivePrivileges3, _checker, __FILE__, __LINE__);
		INT8 missedMonths; _parser.parseINT8(missedMonths);
		AtfValidator::validateInt(_descr, "missedMonths", missedMonths, _checker, __FILE__, __LINE__);
		SrvDate vipStatusUntil; _parser.parseSrvDate(vipStatusUntil);
		AtfValidator::validateSrvDateTime(_descr, "vipStatusUntil", vipStatusUntil, _checker, __FILE__, __LINE__);
		INT8 missableMonthsYearly; _parser.parseINT8(missableMonthsYearly);
		AtfValidator::validateInt(_descr, "missableMonthsYearly", missableMonthsYearly, _checker, __FILE__, __LINE__);
		UINT64 correctedUserFlags3; _parser.parseUINT64(correctedUserFlags3);
		AtfValidator::validateUint(_descr, "correctedUserFlags3", correctedUserFlags3, _checker, __FILE__, __LINE__);
		BrandProt::BrandImageList::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("brandImages"), _fieldsWithUnparsedContent);
		UINT32 hallOfFameLevel; _parser.parseUINT32(hallOfFameLevel);
		AtfValidator::validateInt(_descr, "hallOfFameLevel", hallOfFameLevel, _checker, __FILE__, __LINE__);
		UINT32 licenseId; _parser.parseUINT32(licenseId);
		AtfValidator::validateInt(_descr, "licenseId", licenseId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ Atf::MessageProtocol* dbm::ProtocolFactory::createMessageProtocolObject(const char *_nameSpace, UINT32 _msgId)
{
	Atf::MessageProtocol *_obj = NULL;

	if(!strcmp(_nameSpace, ""))
	{
		switch(_msgId)
		{
			case DBM_A_USER_INFO: _obj = new Protocol_DBM_A_USER_INFO(); break;
			case DBM_Q_USER_INFO: _obj = new Protocol_DBM_Q_USER_INFO(); break;
		}
	}
	else if(!strcmp(_nameSpace, "ArchiveManager"))
	{
		switch(_msgId)
		{
			case DBM_A_ARCH_GET_RELATEDUSERS: _obj = new ArchiveManager::Protocol_DBM_A_ARCH_GET_RELATEDUSERS(); break;
			case DBM_A_UNARCHIVE_INSERT_RELATEDUSERS: _obj = new ArchiveManager::Protocol_DBM_A_UNARCHIVE_INSERT_RELATEDUSERS(); break;
			case DBM_Q_ARCH_GET_RELATEDUSERS: _obj = new ArchiveManager::Protocol_DBM_Q_ARCH_GET_RELATEDUSERS(); break;
			case DBM_Q_UNARCHIVE_INSERT_RELATEDUSERS: _obj = new ArchiveManager::Protocol_DBM_Q_UNARCHIVE_INSERT_RELATEDUSERS(); break;
		}
	}
	else if(!strcmp(_nameSpace, "admin"))
	{
		switch(_msgId)
		{
			case DBM_A_CLEAR_FRAUDULENT_ACCOUNT_FLAG: _obj = new admin::Protocol_DBM_A_CLEAR_FRAUDULENT_ACCOUNT_FLAG(); break;
			case DBM_A_SET_FRAUDULENT_ACCOUNT_FLAG: _obj = new admin::Protocol_DBM_A_SET_FRAUDULENT_ACCOUNT_FLAG(); break;
			case DBM_Q_CLEAR_FRAUDULENT_ACCOUNT_FLAG: _obj = new admin::Protocol_DBM_Q_CLEAR_FRAUDULENT_ACCOUNT_FLAG(); break;
			case DBM_Q_SET_FRAUDULENT_ACCOUNT_FLAG: _obj = new admin::Protocol_DBM_Q_SET_FRAUDULENT_ACCOUNT_FLAG(); break;
		}
	}
	
	return _obj;
}

/* static */ bool dbm::ProtocolFactory::validateProtocolMessageFromJSONString(const char *_nameSpace, UINT32 _msgId, const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, ""))
	{
		switch(_msgId)
		{
			case DBM_A_USER_INFO: Protocol_DBM_A_USER_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case DBM_Q_USER_INFO: Protocol_DBM_Q_USER_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "ArchiveManager"))
	{
		switch(_msgId)
		{
			case DBM_A_ARCH_GET_RELATEDUSERS: ArchiveManager::Protocol_DBM_A_ARCH_GET_RELATEDUSERS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case DBM_A_UNARCHIVE_INSERT_RELATEDUSERS: ArchiveManager::Protocol_DBM_A_UNARCHIVE_INSERT_RELATEDUSERS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case DBM_Q_ARCH_GET_RELATEDUSERS: ArchiveManager::Protocol_DBM_Q_ARCH_GET_RELATEDUSERS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case DBM_Q_UNARCHIVE_INSERT_RELATEDUSERS: ArchiveManager::Protocol_DBM_Q_UNARCHIVE_INSERT_RELATEDUSERS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "admin"))
	{
		switch(_msgId)
		{
			case DBM_A_CLEAR_FRAUDULENT_ACCOUNT_FLAG: admin::Protocol_DBM_A_CLEAR_FRAUDULENT_ACCOUNT_FLAG::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case DBM_A_SET_FRAUDULENT_ACCOUNT_FLAG: admin::Protocol_DBM_A_SET_FRAUDULENT_ACCOUNT_FLAG::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case DBM_Q_CLEAR_FRAUDULENT_ACCOUNT_FLAG: admin::Protocol_DBM_Q_CLEAR_FRAUDULENT_ACCOUNT_FLAG::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case DBM_Q_SET_FRAUDULENT_ACCOUNT_FLAG: admin::Protocol_DBM_Q_SET_FRAUDULENT_ACCOUNT_FLAG::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

/* static */ bool dbm::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, ""))
	{
		switch(_msgId)
		{
			case DBM_A_USER_INFO: Protocol_DBM_A_USER_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case DBM_Q_USER_INFO: Protocol_DBM_Q_USER_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "ArchiveManager"))
	{
		switch(_msgId)
		{
			case DBM_A_ARCH_GET_RELATEDUSERS: ArchiveManager::Protocol_DBM_A_ARCH_GET_RELATEDUSERS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case DBM_A_UNARCHIVE_INSERT_RELATEDUSERS: ArchiveManager::Protocol_DBM_A_UNARCHIVE_INSERT_RELATEDUSERS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case DBM_Q_ARCH_GET_RELATEDUSERS: ArchiveManager::Protocol_DBM_Q_ARCH_GET_RELATEDUSERS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case DBM_Q_UNARCHIVE_INSERT_RELATEDUSERS: ArchiveManager::Protocol_DBM_Q_UNARCHIVE_INSERT_RELATEDUSERS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "admin"))
	{
		switch(_msgId)
		{
			case DBM_A_CLEAR_FRAUDULENT_ACCOUNT_FLAG: admin::Protocol_DBM_A_CLEAR_FRAUDULENT_ACCOUNT_FLAG::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case DBM_A_SET_FRAUDULENT_ACCOUNT_FLAG: admin::Protocol_DBM_A_SET_FRAUDULENT_ACCOUNT_FLAG::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case DBM_Q_CLEAR_FRAUDULENT_ACCOUNT_FLAG: admin::Protocol_DBM_Q_CLEAR_FRAUDULENT_ACCOUNT_FLAG::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case DBM_Q_SET_FRAUDULENT_ACCOUNT_FLAG: admin::Protocol_DBM_Q_SET_FRAUDULENT_ACCOUNT_FLAG::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

