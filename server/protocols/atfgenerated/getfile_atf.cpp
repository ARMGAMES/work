/**
 * getfile_atf.cpp
 *
 * This file was auto-generated from getfile_atf.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: getfile_atf.txt
 */
 
#include "getfile_atf.h"

//=================================================================
//                Protocol_MSG_GET_FILE_CHUNK
//=================================================================

GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK::Protocol_MSG_GET_FILE_CHUNK()
{
	clear();
}

void GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK::clear()
{
	client_reqId = 0;
	filePath.clear();
	offset = 0;
	verInfo.clear();
}

bool GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK::equals(const Protocol_MSG_GET_FILE_CHUNK& _o) const
{
	return client_reqId == _o.client_reqId &&
		Atf::atfPStringEquals(filePath, _o.filePath) &&
		offset == _o.offset &&
		Atf::atfPStringEquals(verInfo, _o.verInfo);
}

bool GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_GET_FILE_CHUNK != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_GET_FILE_CHUNK*)_other));
}

const char *GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_GET_FILE_CHUNK).append(")");
	_buf.append(',');
	_buf.append("client_reqId=");
	_buf.appendUint(client_reqId);
	_buf.append(',');
	_buf.append("filePath=");
	_buf.append(filePath);
	_buf.append(',');
	_buf.append("offset=");
	_buf.appendUint(offset);
	_buf.append(',');
	_buf.append("verInfo=");
	_buf.append(verInfo);
	return _buf.c_str();
}

const char *GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_GET_FILE_CHUNK).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("client_reqId", client_reqId, _buf);
	Atf::XmlElement::encodeAsXmlElement("filePath", filePath, _buf);
	Atf::XmlElement::encodeAsXmlElement("offset", offset, _buf);
	Atf::XmlElement::encodeAsXmlElement("verInfo", verInfo, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("client_reqId"))
			{
				client_reqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("filePath"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, filePath)) return false;
			}
			else if (_element.equals("offset"))
			{
				offset = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("verInfo"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, verInfo)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(client_reqId);
	_msg.composeString(filePath);
	_msg.composeUINT32(offset);
	_msg.composeString(verInfo);
}

void GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(client_reqId);
	_parser.parseStringP(filePath);
	_parser.parseUINT32(offset);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(verInfo);
}

const char *GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("client_reqId", client_reqId);
	_jsonstr.compose("filePath", filePath);
	_jsonstr.compose("offset", offset);
	_jsonstr.compose("verInfo", verInfo);
	return _buf.c_str();
}

void GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("client_reqId", client_reqId);
	_jparser.parseByNameThrow("filePath", filePath);
	_jparser.parseByNameThrow("offset", offset);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("verInfo", verInfo);
}

/*static*/ void GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_GET_FILE_CHUNK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 client_reqId; _jparser.validateByNameThrow("client_reqId", client_reqId);
	AtfValidator::validateInt(_descr, "client_reqId", client_reqId, _checker, __FILE__, __LINE__);
	PString filePath; _jparser.validateByNameThrow("filePath", filePath);
	AtfValidator::validateIntMax(_descr, "filePath", filePath.length(), 100, _checker, __FILE__, __LINE__);
	UINT32 offset; _jparser.validateByNameThrow("offset", offset);
	AtfValidator::validateIntMax(_descr, "offset", offset, 500000000, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString verInfo; _jparser.validateByNameThrow("verInfo", verInfo);
	AtfValidator::validateIntMax(_descr, "verInfo", verInfo.length(), 100, _checker, __FILE__, __LINE__);
}

/*static*/ void GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_GET_FILE_CHUNK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 client_reqId; _parser.parseUINT32(client_reqId);
	AtfValidator::validateInt(_descr, "client_reqId", client_reqId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "filePath"); size_t szFilePath = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "filePath", szFilePath, 100, _checker, __FILE__, __LINE__);
	UINT32 offset; _parser.parseUINT32(offset);
	AtfValidator::validateIntMax(_descr, "offset", offset, 500000000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "verInfo"); size_t szVerInfo = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "verInfo", szVerInfo, 100, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_GET_FILE_CHUNK_REPLY
//=================================================================

GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK_REPLY::Protocol_MSG_GET_FILE_CHUNK_REPLY()
{
	clear();
}

void GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK_REPLY::clear()
{
	client_reqId = 0;
	error = 0;
	errMsg.clear();
	fileLength = 0;
	isLast = 0;
	chunk.clear();
}

bool GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK_REPLY::equals(const Protocol_MSG_GET_FILE_CHUNK_REPLY& _o) const
{
	return client_reqId == _o.client_reqId &&
		error == _o.error &&
		Atf::atfPStringEquals(errMsg, _o.errMsg) &&
		fileLength == _o.fileLength &&
		isLast == _o.isLast &&
		chunk.size() == _o.chunk.size() && memcmp(chunk.ptr(), _o.chunk.ptr(), chunk.size()) == 0;
}

bool GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_GET_FILE_CHUNK_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_GET_FILE_CHUNK_REPLY*)_other));
}

const char *GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_GET_FILE_CHUNK_REPLY).append(")");
	_buf.append(',');
	_buf.append("client_reqId=");
	_buf.appendUint(client_reqId);
	_buf.append(',');
	_buf.append("error=");
	_buf.appendUint(error);
	if (error)
	{
		_buf.append(',');
		_buf.append("errMsg=");
		_buf.append(errMsg);
	}
	else
	{
		_buf.append(',');
		_buf.append("fileLength=");
		_buf.appendUint(fileLength);
		_buf.append(',');
		_buf.append("isLast=");
		_buf.appendUint(isLast);
		_buf.append(',');
		_buf.append("chunk=");
		Atf::AtfTempl<PBlock>::ToTraceString(_buf, chunk);
	}
	return _buf.c_str();
}

const char *GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_GET_FILE_CHUNK_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("client_reqId", client_reqId, _buf);
	Atf::XmlElement::encodeAsXmlElement("error", error, _buf);
	if (error)
	{
		Atf::XmlElement::encodeAsXmlElement("errMsg", errMsg, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("fileLength", fileLength, _buf);
		Atf::XmlElement::encodeAsXmlElement("isLast", isLast, _buf);
		Atf::XmlElement::encodeAsXmlElement("chunk", chunk, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("client_reqId"))
			{
				client_reqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("error"))
			{
				error = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errMsg"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errMsg)) return false;
			}
			else if (_element.equals("fileLength"))
			{
				fileLength = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isLast"))
			{
				isLast = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("chunk"))
			{
				Atf::XmlElement::_movePBlockWithNullStrip(_value, chunk);
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(client_reqId);
	_msg.composeUINT16(error);
	if (error)
	{
		_msg.composeString(errMsg);
	}
	else
	{
		_msg.composeUINT32(fileLength);
		_msg.composeBYTE(isLast);
		_msg._composeVarBlock(chunk.ptr(), chunk.size());
	}
}

void GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(client_reqId);
	_parser.parseUINT16(error);
	if (error)
	{
		_parser.parseStringP(errMsg);
	}
	else
	{
		_parser.parseUINT32(fileLength);
		_parser.parseBYTE(isLast);
		_parser.parsePBlock(chunk);
	}
}

const char *GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("client_reqId", client_reqId);
	_jsonstr.compose("error", error);
	if (error)
	{
		_jsonstr.compose("errMsg", errMsg);
	}
	else
	{
		_jsonstr.compose("fileLength", fileLength);
		_jsonstr.compose("isLast", isLast);
		_jsonstr.compose("chunk", chunk);
	}
	return _buf.c_str();
}

void GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("client_reqId", client_reqId);
	_jparser.parseByNameThrow("error", error);
	if (error)
	{
		_jparser.parseByNameThrow("errMsg", errMsg);
	}
	else
	{
		_jparser.parseByNameThrow("fileLength", fileLength);
		_jparser.parseByNameThrow("isLast", isLast);
		_jparser.parseByNameThrow("chunk", chunk);
	}
}

/*static*/ void GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_GET_FILE_CHUNK_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT16 error = 0;
	UINT32 client_reqId; _jparser.validateByNameThrow("client_reqId", client_reqId);
	AtfValidator::validateInt(_descr, "client_reqId", client_reqId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("error", error);
	AtfValidator::validateInt(_descr, "error", error, _checker, __FILE__, __LINE__);
	if (error)
	{
		PString errMsg; _jparser.validateByNameThrow("errMsg", errMsg);
		AtfValidator::validateInt(_descr, "errMsg", errMsg.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 fileLength; _jparser.validateByNameThrow("fileLength", fileLength);
		AtfValidator::validateInt(_descr, "fileLength", fileLength, _checker, __FILE__, __LINE__);
		BYTE isLast; _jparser.validateByNameThrow("isLast", isLast);
		AtfValidator::validateInt(_descr, "isLast", isLast, _checker, __FILE__, __LINE__);
		PBlock chunk; _jparser.validateByNameThrow("chunk", chunk);
		AtfValidator::validateInt(_descr, "chunk", chunk.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void GetFile::getfile_client::Protocol_MSG_GET_FILE_CHUNK_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_GET_FILE_CHUNK_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT16 error = 0;
	UINT32 client_reqId; _parser.parseUINT32(client_reqId);
	AtfValidator::validateInt(_descr, "client_reqId", client_reqId, _checker, __FILE__, __LINE__);
	_parser.parseUINT16(error);
	AtfValidator::validateInt(_descr, "error", error, _checker, __FILE__, __LINE__);
	if (error)
	{
		_parser.parseStringN(_dummy, 0, "errMsg"); size_t szErrMsg = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errMsg", szErrMsg, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 fileLength; _parser.parseUINT32(fileLength);
		AtfValidator::validateInt(_descr, "fileLength", fileLength, _checker, __FILE__, __LINE__);
		BYTE isLast; _parser.parseBYTE(isLast);
		AtfValidator::validateInt(_descr, "isLast", isLast, _checker, __FILE__, __LINE__);
		const BYTE* chunk; size_t szChunk; _parser._parseVarBlock(chunk, szChunk);  /*chunk*/
		AtfValidator::validateInt(_descr, "chunk", szChunk, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ Atf::MessageProtocol* GetFile::ProtocolFactory::createMessageProtocolObject(const char *_nameSpace, UINT32 _msgId)
{
	Atf::MessageProtocol *_obj = NULL;

	if(!strcmp(_nameSpace, "getfile_client"))
	{
		switch(_msgId)
		{
			case MSG_GET_FILE_CHUNK: _obj = new getfile_client::Protocol_MSG_GET_FILE_CHUNK(); break;
			case MSG_GET_FILE_CHUNK_REPLY: _obj = new getfile_client::Protocol_MSG_GET_FILE_CHUNK_REPLY(); break;
		}
	}
	
	return _obj;
}

/* static */ bool GetFile::ProtocolFactory::validateProtocolMessageFromJSONString(const char *_nameSpace, UINT32 _msgId, const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "getfile_client"))
	{
		switch(_msgId)
		{
			case MSG_GET_FILE_CHUNK: getfile_client::Protocol_MSG_GET_FILE_CHUNK::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_GET_FILE_CHUNK_REPLY: getfile_client::Protocol_MSG_GET_FILE_CHUNK_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

/* static */ bool GetFile::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "getfile_client"))
	{
		switch(_msgId)
		{
			case MSG_GET_FILE_CHUNK: getfile_client::Protocol_MSG_GET_FILE_CHUNK::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_GET_FILE_CHUNK_REPLY: getfile_client::Protocol_MSG_GET_FILE_CHUNK_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

