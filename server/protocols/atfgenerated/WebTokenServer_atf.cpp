/**
 * WebTokenServer_atf.cpp
 *
 * This file was auto-generated from WebTokenServer_atf.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor WebTokenServer_atf.txt
 */
 
#include "WebTokenServer_atf.h"

//=================================================================
//                Protocol_WTS_Q_GET_TOKEN
//=================================================================

WebTokenServer::cli::Protocol_WTS_Q_GET_TOKEN::Protocol_WTS_Q_GET_TOKEN()
{
	clear();
}

void WebTokenServer::cli::Protocol_WTS_Q_GET_TOKEN::clear()
{
	tokenType = eWebTokenTypeCashier;
}

bool WebTokenServer::cli::Protocol_WTS_Q_GET_TOKEN::equals(const Protocol_WTS_Q_GET_TOKEN& _o) const
{
	return tokenType == _o.tokenType;
}

bool WebTokenServer::cli::Protocol_WTS_Q_GET_TOKEN::equals(Atf::MessageProtocol* _other) const
{
	if (WTS_Q_GET_TOKEN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_WTS_Q_GET_TOKEN*)_other));
}

const char *WebTokenServer::cli::Protocol_WTS_Q_GET_TOKEN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(WTS_Q_GET_TOKEN).append(")");
	_buf.append(',');
	_buf.append("tokenType=");
	_buf.appendUint(tokenType);
	return _buf.c_str();
}

const char *WebTokenServer::cli::Protocol_WTS_Q_GET_TOKEN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *WebTokenServer::cli::Protocol_WTS_Q_GET_TOKEN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(WTS_Q_GET_TOKEN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("tokenType", tokenType, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool WebTokenServer::cli::Protocol_WTS_Q_GET_TOKEN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tokenType"))
			{
				tokenType = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void WebTokenServer::cli::Protocol_WTS_Q_GET_TOKEN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(tokenType);
}

void WebTokenServer::cli::Protocol_WTS_Q_GET_TOKEN::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(tokenType);
}

const char *WebTokenServer::cli::Protocol_WTS_Q_GET_TOKEN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tokenType", tokenType);
	return _buf.c_str();
}

void WebTokenServer::cli::Protocol_WTS_Q_GET_TOKEN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tokenType", tokenType);
}

/*static*/ void WebTokenServer::cli::Protocol_WTS_Q_GET_TOKEN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "WTS_Q_GET_TOKEN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	UINT32 tokenType; _jparser.validateByNameThrow("tokenType", tokenType);
	AtfValidator::validateIntMax(_descr, "tokenType", tokenType, eWebTokenTypeLast, _checker, __FILE__, __LINE__);
}

/*static*/ void WebTokenServer::cli::Protocol_WTS_Q_GET_TOKEN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "WTS_Q_GET_TOKEN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(_parser.parseEnded()) return;
	UINT32 tokenType; _parser.parseUINT32(tokenType);
	AtfValidator::validateIntMax(_descr, "tokenType", tokenType, eWebTokenTypeLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_WTS_A_GET_TOKEN
//=================================================================

WebTokenServer::cli::Protocol_WTS_A_GET_TOKEN::Protocol_WTS_A_GET_TOKEN()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

WebTokenServer::cli::Protocol_WTS_A_GET_TOKEN::Protocol_WTS_A_GET_TOKEN(Protocol_WTS_A_GET_TOKEN&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, token(std::move(_o.token))
	, signature(std::move(_o.signature))
{
}

WebTokenServer::cli::Protocol_WTS_A_GET_TOKEN& WebTokenServer::cli::Protocol_WTS_A_GET_TOKEN::operator=(Protocol_WTS_A_GET_TOKEN&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		token = std::move(_o.token);
		signature = std::move(_o.signature);
	}
	return *this;
}

#endif

void WebTokenServer::cli::Protocol_WTS_A_GET_TOKEN::clear()
{
	errCode = 0;
	errDescr.clear();
	token.clear();
	signature.clear();
}

bool WebTokenServer::cli::Protocol_WTS_A_GET_TOKEN::equals(const Protocol_WTS_A_GET_TOKEN& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(token, _o.token) &&
		Atf::atfPStringEquals(signature, _o.signature);
}

bool WebTokenServer::cli::Protocol_WTS_A_GET_TOKEN::equals(Atf::MessageProtocol* _other) const
{
	if (WTS_A_GET_TOKEN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_WTS_A_GET_TOKEN*)_other));
}

const char *WebTokenServer::cli::Protocol_WTS_A_GET_TOKEN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(WTS_A_GET_TOKEN).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("token=");
		_buf.append(token);
		_buf.append(',');
		_buf.append("signature=");
		_buf.append(signature);
	}
	return _buf.c_str();
}

const char *WebTokenServer::cli::Protocol_WTS_A_GET_TOKEN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *WebTokenServer::cli::Protocol_WTS_A_GET_TOKEN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(WTS_A_GET_TOKEN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("token", token, _buf);
		Atf::XmlElement::encodeAsXmlElement("signature", signature, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool WebTokenServer::cli::Protocol_WTS_A_GET_TOKEN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("token"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, token)) return false;
			}
			else if (_element.equals("signature"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, signature)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void WebTokenServer::cli::Protocol_WTS_A_GET_TOKEN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(token);
		_msg.composeString(signature);
	}
}

void WebTokenServer::cli::Protocol_WTS_A_GET_TOKEN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(token);
		_parser.parseStringP(signature);
	}
}

const char *WebTokenServer::cli::Protocol_WTS_A_GET_TOKEN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("token", token);
		_jsonstr.compose("signature", signature);
	}
	return _buf.c_str();
}

void WebTokenServer::cli::Protocol_WTS_A_GET_TOKEN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("token", token);
		_jparser.parseByNameThrow("signature", signature);
	}
}

/*static*/ void WebTokenServer::cli::Protocol_WTS_A_GET_TOKEN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "WTS_A_GET_TOKEN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString token; _jparser.validateByNameThrow("token", token);
		AtfValidator::validateInt(_descr, "token", token.length(), _checker, __FILE__, __LINE__);
		PString signature; _jparser.validateByNameThrow("signature", signature);
		AtfValidator::validateInt(_descr, "signature", signature.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void WebTokenServer::cli::Protocol_WTS_A_GET_TOKEN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "WTS_A_GET_TOKEN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "token"); size_t szToken = strlen(_dummy);
		AtfValidator::validateInt(_descr, "token", szToken, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "signature"); size_t szSignature = strlen(_dummy);
		AtfValidator::validateInt(_descr, "signature", szSignature, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN
//=================================================================

WebTokenServer::cli::Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN::Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

WebTokenServer::cli::Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN::Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN(Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN&& _o)
	: tokenStr(std::move(_o.tokenStr))
{
}

WebTokenServer::cli::Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN& WebTokenServer::cli::Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN::operator=(Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN&& _o)
{
	if(this != &_o)
	{
		tokenStr = std::move(_o.tokenStr);
	}
	return *this;
}

#endif

void WebTokenServer::cli::Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN::clear()
{
	tokenStr.clear();
}

bool WebTokenServer::cli::Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN::equals(const Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN& _o) const
{
	return Atf::atfPStringEquals(tokenStr, _o.tokenStr);
}

bool WebTokenServer::cli::Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN::equals(Atf::MessageProtocol* _other) const
{
	if (WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN*)_other));
}

const char *WebTokenServer::cli::Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN).append(")");
	_buf.append(',');
	_buf.append("tokenStr=");
	_buf.append(tokenStr);
	return _buf.c_str();
}

const char *WebTokenServer::cli::Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *WebTokenServer::cli::Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("tokenStr", tokenStr, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool WebTokenServer::cli::Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tokenStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tokenStr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void WebTokenServer::cli::Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(tokenStr);
}

void WebTokenServer::cli::Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(tokenStr);
}

const char *WebTokenServer::cli::Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tokenStr", tokenStr);
	return _buf.c_str();
}

void WebTokenServer::cli::Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tokenStr", tokenStr);
}

/*static*/ void WebTokenServer::cli::Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString tokenStr; _jparser.validateByNameThrow("tokenStr", tokenStr);
	AtfValidator::validateIntMax(_descr, "tokenStr", tokenStr.length(), 1000, _checker, __FILE__, __LINE__);
}

/*static*/ void WebTokenServer::cli::Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "tokenStr"); size_t szTokenStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "tokenStr", szTokenStr, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN
//=================================================================

WebTokenServer::cli::Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN::Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

WebTokenServer::cli::Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN::Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN(Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

WebTokenServer::cli::Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN& WebTokenServer::cli::Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN::operator=(Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void WebTokenServer::cli::Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool WebTokenServer::cli::Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN::equals(const Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool WebTokenServer::cli::Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN::equals(Atf::MessageProtocol* _other) const
{
	if (WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN*)_other));
}

const char *WebTokenServer::cli::Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *WebTokenServer::cli::Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *WebTokenServer::cli::Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool WebTokenServer::cli::Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void WebTokenServer::cli::Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void WebTokenServer::cli::Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *WebTokenServer::cli::Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void WebTokenServer::cli::Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void WebTokenServer::cli::Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void WebTokenServer::cli::Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME
//=================================================================

WebTokenServer::cli_unauth::Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME::Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

WebTokenServer::cli_unauth::Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME::Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME(Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME&& _o)
	: userIntId(std::move(_o.userIntId))
	, tokenStr(std::move(_o.tokenStr))
{
}

WebTokenServer::cli_unauth::Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME& WebTokenServer::cli_unauth::Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME::operator=(Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME&& _o)
{
	if(this != &_o)
	{
		userIntId = std::move(_o.userIntId);
		tokenStr = std::move(_o.tokenStr);
	}
	return *this;
}

#endif

void WebTokenServer::cli_unauth::Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME::clear()
{
	userIntId = 0;
	tokenStr.clear();
}

bool WebTokenServer::cli_unauth::Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME::equals(const Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME& _o) const
{
	return userIntId == _o.userIntId &&
		Atf::atfPStringEquals(tokenStr, _o.tokenStr);
}

bool WebTokenServer::cli_unauth::Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME::equals(Atf::MessageProtocol* _other) const
{
	if (WTS_Q_GET_TOKEN_EXPIRY_TIME != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME*)_other));
}

const char *WebTokenServer::cli_unauth::Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(WTS_Q_GET_TOKEN_EXPIRY_TIME).append(")");
	_buf.append(',');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	_buf.append(',');
	_buf.append("tokenStr=");
	_buf.append(tokenStr);
	return _buf.c_str();
}

const char *WebTokenServer::cli_unauth::Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *WebTokenServer::cli_unauth::Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(WTS_Q_GET_TOKEN_EXPIRY_TIME).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userIntId", userIntId, _buf);
	Atf::XmlElement::encodeAsXmlElement("tokenStr", tokenStr, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool WebTokenServer::cli_unauth::Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userIntId"))
			{
				userIntId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tokenStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tokenStr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void WebTokenServer::cli_unauth::Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(userIntId);
	_msg.composeString(tokenStr);
}

void WebTokenServer::cli_unauth::Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(userIntId);
	_parser.parseStringP(tokenStr);
}

const char *WebTokenServer::cli_unauth::Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userIntId", userIntId);
	_jsonstr.compose("tokenStr", tokenStr);
	return _buf.c_str();
}

void WebTokenServer::cli_unauth::Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userIntId", userIntId);
	_jparser.parseByNameThrow("tokenStr", tokenStr);
}

/*static*/ void WebTokenServer::cli_unauth::Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "WTS_Q_GET_TOKEN_EXPIRY_TIME";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 userIntId; _jparser.validateByNameThrow("userIntId", userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	PString tokenStr; _jparser.validateByNameThrow("tokenStr", tokenStr);
	AtfValidator::validateIntMax(_descr, "tokenStr", tokenStr.length(), 1000, _checker, __FILE__, __LINE__);
}

/*static*/ void WebTokenServer::cli_unauth::Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "WTS_Q_GET_TOKEN_EXPIRY_TIME";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 userIntId; _parser.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "tokenStr"); size_t szTokenStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "tokenStr", szTokenStr, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME
//=================================================================

WebTokenServer::cli_unauth::Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME::Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

WebTokenServer::cli_unauth::Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME::Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME(Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, tokenValidTimeInSec(std::move(_o.tokenValidTimeInSec))
	, userId(std::move(_o.userId))
{
}

WebTokenServer::cli_unauth::Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME& WebTokenServer::cli_unauth::Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME::operator=(Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		tokenValidTimeInSec = std::move(_o.tokenValidTimeInSec);
		userId = std::move(_o.userId);
	}
	return *this;
}

#endif

void WebTokenServer::cli_unauth::Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME::clear()
{
	errCode = 0;
	errDescr.clear();
	tokenValidTimeInSec = 0;
	userId.clear();
}

bool WebTokenServer::cli_unauth::Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME::equals(const Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		tokenValidTimeInSec == _o.tokenValidTimeInSec &&
		Atf::atfPStringEquals(userId, _o.userId);
}

bool WebTokenServer::cli_unauth::Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME::equals(Atf::MessageProtocol* _other) const
{
	if (WTS_A_GET_TOKEN_EXPIRY_TIME != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME*)_other));
}

const char *WebTokenServer::cli_unauth::Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(WTS_A_GET_TOKEN_EXPIRY_TIME).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("tokenValidTimeInSec=");
		_buf.appendUint(tokenValidTimeInSec);
		_buf.append(',');
		_buf.append("userId=");
		_buf.append(userId);
	}
	return _buf.c_str();
}

const char *WebTokenServer::cli_unauth::Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *WebTokenServer::cli_unauth::Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(WTS_A_GET_TOKEN_EXPIRY_TIME).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("tokenValidTimeInSec", tokenValidTimeInSec, _buf);
		Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool WebTokenServer::cli_unauth::Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("tokenValidTimeInSec"))
			{
				tokenValidTimeInSec = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void WebTokenServer::cli_unauth::Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(tokenValidTimeInSec);
		_msg.composeString(userId);
	}
}

void WebTokenServer::cli_unauth::Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(tokenValidTimeInSec);
		_parser.parseStringP(userId);
	}
}

const char *WebTokenServer::cli_unauth::Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("tokenValidTimeInSec", tokenValidTimeInSec);
		_jsonstr.compose("userId", userId);
	}
	return _buf.c_str();
}

void WebTokenServer::cli_unauth::Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("tokenValidTimeInSec", tokenValidTimeInSec);
		_jparser.parseByNameThrow("userId", userId);
	}
}

/*static*/ void WebTokenServer::cli_unauth::Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "WTS_A_GET_TOKEN_EXPIRY_TIME";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 tokenValidTimeInSec; _jparser.validateByNameThrow("tokenValidTimeInSec", tokenValidTimeInSec);
		AtfValidator::validateInt(_descr, "tokenValidTimeInSec", tokenValidTimeInSec, _checker, __FILE__, __LINE__);
		PString userId; _jparser.validateByNameThrow("userId", userId);
		AtfValidator::validateInt(_descr, "userId", userId.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void WebTokenServer::cli_unauth::Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "WTS_A_GET_TOKEN_EXPIRY_TIME";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 tokenValidTimeInSec; _parser.parseUINT32(tokenValidTimeInSec);
		AtfValidator::validateInt(_descr, "tokenValidTimeInSec", tokenValidTimeInSec, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_WTS_Q_VERIFY_PSIP_TOKEN
//=================================================================

WebTokenServer::cli_unauth::Protocol_WTS_Q_VERIFY_PSIP_TOKEN::Protocol_WTS_Q_VERIFY_PSIP_TOKEN()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

WebTokenServer::cli_unauth::Protocol_WTS_Q_VERIFY_PSIP_TOKEN::Protocol_WTS_Q_VERIFY_PSIP_TOKEN(Protocol_WTS_Q_VERIFY_PSIP_TOKEN&& _o)
	: userIntId(std::move(_o.userIntId))
	, tokenStr(std::move(_o.tokenStr))
{
}

WebTokenServer::cli_unauth::Protocol_WTS_Q_VERIFY_PSIP_TOKEN& WebTokenServer::cli_unauth::Protocol_WTS_Q_VERIFY_PSIP_TOKEN::operator=(Protocol_WTS_Q_VERIFY_PSIP_TOKEN&& _o)
{
	if(this != &_o)
	{
		userIntId = std::move(_o.userIntId);
		tokenStr = std::move(_o.tokenStr);
	}
	return *this;
}

#endif

void WebTokenServer::cli_unauth::Protocol_WTS_Q_VERIFY_PSIP_TOKEN::clear()
{
	userIntId = 0;
	tokenStr.clear();
}

bool WebTokenServer::cli_unauth::Protocol_WTS_Q_VERIFY_PSIP_TOKEN::equals(const Protocol_WTS_Q_VERIFY_PSIP_TOKEN& _o) const
{
	return userIntId == _o.userIntId &&
		Atf::atfPStringEquals(tokenStr, _o.tokenStr);
}

bool WebTokenServer::cli_unauth::Protocol_WTS_Q_VERIFY_PSIP_TOKEN::equals(Atf::MessageProtocol* _other) const
{
	if (WTS_Q_VERIFY_PSIP_TOKEN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_WTS_Q_VERIFY_PSIP_TOKEN*)_other));
}

const char *WebTokenServer::cli_unauth::Protocol_WTS_Q_VERIFY_PSIP_TOKEN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(WTS_Q_VERIFY_PSIP_TOKEN).append(")");
	_buf.append(',');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	_buf.append(',');
	_buf.append("tokenStr=");
	_buf.append(tokenStr);
	return _buf.c_str();
}

const char *WebTokenServer::cli_unauth::Protocol_WTS_Q_VERIFY_PSIP_TOKEN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *WebTokenServer::cli_unauth::Protocol_WTS_Q_VERIFY_PSIP_TOKEN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(WTS_Q_VERIFY_PSIP_TOKEN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userIntId", userIntId, _buf);
	Atf::XmlElement::encodeAsXmlElement("tokenStr", tokenStr, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool WebTokenServer::cli_unauth::Protocol_WTS_Q_VERIFY_PSIP_TOKEN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userIntId"))
			{
				userIntId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tokenStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tokenStr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void WebTokenServer::cli_unauth::Protocol_WTS_Q_VERIFY_PSIP_TOKEN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(userIntId);
	_msg.composeString(tokenStr);
}

void WebTokenServer::cli_unauth::Protocol_WTS_Q_VERIFY_PSIP_TOKEN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(userIntId);
	_parser.parseStringP(tokenStr);
}

const char *WebTokenServer::cli_unauth::Protocol_WTS_Q_VERIFY_PSIP_TOKEN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userIntId", userIntId);
	_jsonstr.compose("tokenStr", tokenStr);
	return _buf.c_str();
}

void WebTokenServer::cli_unauth::Protocol_WTS_Q_VERIFY_PSIP_TOKEN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userIntId", userIntId);
	_jparser.parseByNameThrow("tokenStr", tokenStr);
}

/*static*/ void WebTokenServer::cli_unauth::Protocol_WTS_Q_VERIFY_PSIP_TOKEN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "WTS_Q_VERIFY_PSIP_TOKEN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 userIntId; _jparser.validateByNameThrow("userIntId", userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	PString tokenStr; _jparser.validateByNameThrow("tokenStr", tokenStr);
	AtfValidator::validateIntMax(_descr, "tokenStr", tokenStr.length(), 1000, _checker, __FILE__, __LINE__);
}

/*static*/ void WebTokenServer::cli_unauth::Protocol_WTS_Q_VERIFY_PSIP_TOKEN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "WTS_Q_VERIFY_PSIP_TOKEN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 userIntId; _parser.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "tokenStr"); size_t szTokenStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "tokenStr", szTokenStr, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_WTS_A_VERIFY_PSIP_TOKEN
//=================================================================

WebTokenServer::cli_unauth::Protocol_WTS_A_VERIFY_PSIP_TOKEN::Protocol_WTS_A_VERIFY_PSIP_TOKEN()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

WebTokenServer::cli_unauth::Protocol_WTS_A_VERIFY_PSIP_TOKEN::Protocol_WTS_A_VERIFY_PSIP_TOKEN(Protocol_WTS_A_VERIFY_PSIP_TOKEN&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, userId(std::move(_o.userId))
{
}

WebTokenServer::cli_unauth::Protocol_WTS_A_VERIFY_PSIP_TOKEN& WebTokenServer::cli_unauth::Protocol_WTS_A_VERIFY_PSIP_TOKEN::operator=(Protocol_WTS_A_VERIFY_PSIP_TOKEN&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		userId = std::move(_o.userId);
	}
	return *this;
}

#endif

void WebTokenServer::cli_unauth::Protocol_WTS_A_VERIFY_PSIP_TOKEN::clear()
{
	errCode = 0;
	errDescr.clear();
	userId.clear();
}

bool WebTokenServer::cli_unauth::Protocol_WTS_A_VERIFY_PSIP_TOKEN::equals(const Protocol_WTS_A_VERIFY_PSIP_TOKEN& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(userId, _o.userId);
}

bool WebTokenServer::cli_unauth::Protocol_WTS_A_VERIFY_PSIP_TOKEN::equals(Atf::MessageProtocol* _other) const
{
	if (WTS_A_VERIFY_PSIP_TOKEN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_WTS_A_VERIFY_PSIP_TOKEN*)_other));
}

const char *WebTokenServer::cli_unauth::Protocol_WTS_A_VERIFY_PSIP_TOKEN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(WTS_A_VERIFY_PSIP_TOKEN).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("userId=");
		_buf.append(userId);
	}
	return _buf.c_str();
}

const char *WebTokenServer::cli_unauth::Protocol_WTS_A_VERIFY_PSIP_TOKEN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *WebTokenServer::cli_unauth::Protocol_WTS_A_VERIFY_PSIP_TOKEN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(WTS_A_VERIFY_PSIP_TOKEN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool WebTokenServer::cli_unauth::Protocol_WTS_A_VERIFY_PSIP_TOKEN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void WebTokenServer::cli_unauth::Protocol_WTS_A_VERIFY_PSIP_TOKEN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(userId);
	}
}

void WebTokenServer::cli_unauth::Protocol_WTS_A_VERIFY_PSIP_TOKEN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(userId);
	}
}

const char *WebTokenServer::cli_unauth::Protocol_WTS_A_VERIFY_PSIP_TOKEN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("userId", userId);
	}
	return _buf.c_str();
}

void WebTokenServer::cli_unauth::Protocol_WTS_A_VERIFY_PSIP_TOKEN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("userId", userId);
	}
}

/*static*/ void WebTokenServer::cli_unauth::Protocol_WTS_A_VERIFY_PSIP_TOKEN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "WTS_A_VERIFY_PSIP_TOKEN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString userId; _jparser.validateByNameThrow("userId", userId);
		AtfValidator::validateInt(_descr, "userId", userId.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void WebTokenServer::cli_unauth::Protocol_WTS_A_VERIFY_PSIP_TOKEN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "WTS_A_VERIFY_PSIP_TOKEN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_WTS_U_APP_SESSION_LOGOUT
//=================================================================

WebTokenServer::notifications::Protocol_WTS_U_APP_SESSION_LOGOUT::Protocol_WTS_U_APP_SESSION_LOGOUT()
{
	clear();
}

void WebTokenServer::notifications::Protocol_WTS_U_APP_SESSION_LOGOUT::clear()
{
	appSessionId = 0;
	userIntId = 0;
}

bool WebTokenServer::notifications::Protocol_WTS_U_APP_SESSION_LOGOUT::equals(const Protocol_WTS_U_APP_SESSION_LOGOUT& _o) const
{
	return appSessionId == _o.appSessionId &&
		userIntId == _o.userIntId;
}

bool WebTokenServer::notifications::Protocol_WTS_U_APP_SESSION_LOGOUT::equals(Atf::MessageProtocol* _other) const
{
	if (WTS_U_APP_SESSION_LOGOUT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_WTS_U_APP_SESSION_LOGOUT*)_other));
}

const char *WebTokenServer::notifications::Protocol_WTS_U_APP_SESSION_LOGOUT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(WTS_U_APP_SESSION_LOGOUT).append(")");
	_buf.append(',');
	_buf.append("appSessionId=");
	_buf.appendUint64(appSessionId);
	_buf.append(',');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	return _buf.c_str();
}

const char *WebTokenServer::notifications::Protocol_WTS_U_APP_SESSION_LOGOUT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *WebTokenServer::notifications::Protocol_WTS_U_APP_SESSION_LOGOUT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(WTS_U_APP_SESSION_LOGOUT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("appSessionId", appSessionId, _buf);
	Atf::XmlElement::encodeAsXmlElement("userIntId", userIntId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool WebTokenServer::notifications::Protocol_WTS_U_APP_SESSION_LOGOUT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("appSessionId"))
			{
				appSessionId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userIntId"))
			{
				userIntId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void WebTokenServer::notifications::Protocol_WTS_U_APP_SESSION_LOGOUT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(appSessionId);
	_msg.composeUINT32(userIntId);
}

void WebTokenServer::notifications::Protocol_WTS_U_APP_SESSION_LOGOUT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(appSessionId);
	_parser.parseUINT32(userIntId);
}

const char *WebTokenServer::notifications::Protocol_WTS_U_APP_SESSION_LOGOUT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("appSessionId", appSessionId);
	_jsonstr.compose("userIntId", userIntId);
	return _buf.c_str();
}

void WebTokenServer::notifications::Protocol_WTS_U_APP_SESSION_LOGOUT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("appSessionId", appSessionId);
	_jparser.parseByNameThrow("userIntId", userIntId);
}

/*static*/ void WebTokenServer::notifications::Protocol_WTS_U_APP_SESSION_LOGOUT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "WTS_U_APP_SESSION_LOGOUT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT64 appSessionId; _jparser.validateByNameThrow("appSessionId", appSessionId);
	AtfValidator::validateUint(_descr, "appSessionId", appSessionId, _checker, __FILE__, __LINE__);
	UINT32 userIntId; _jparser.validateByNameThrow("userIntId", userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
}

/*static*/ void WebTokenServer::notifications::Protocol_WTS_U_APP_SESSION_LOGOUT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "WTS_U_APP_SESSION_LOGOUT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT64 appSessionId; _parser.parseUINT64(appSessionId);
	AtfValidator::validateUint(_descr, "appSessionId", appSessionId, _checker, __FILE__, __LINE__);
	UINT32 userIntId; _parser.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ Atf::MessageProtocol* WebTokenServer::ProtocolFactory::createMessageProtocolObject(const char *_nameSpace, UINT32 _msgId)
{
	Atf::MessageProtocol *_obj = NULL;

	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case WTS_A_GET_TOKEN: _obj = new cli::Protocol_WTS_A_GET_TOKEN(); break;
			case WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN: _obj = new cli::Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN(); break;
			case WTS_Q_GET_TOKEN: _obj = new cli::Protocol_WTS_Q_GET_TOKEN(); break;
			case WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN: _obj = new cli::Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN(); break;
		}
	}
	else if(!strcmp(_nameSpace, "cli_unauth"))
	{
		switch(_msgId)
		{
			case WTS_A_GET_TOKEN_EXPIRY_TIME: _obj = new cli_unauth::Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME(); break;
			case WTS_A_VERIFY_PSIP_TOKEN: _obj = new cli_unauth::Protocol_WTS_A_VERIFY_PSIP_TOKEN(); break;
			case WTS_Q_GET_TOKEN_EXPIRY_TIME: _obj = new cli_unauth::Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME(); break;
			case WTS_Q_VERIFY_PSIP_TOKEN: _obj = new cli_unauth::Protocol_WTS_Q_VERIFY_PSIP_TOKEN(); break;
		}
	}
	else if(!strcmp(_nameSpace, "notifications"))
	{
		switch(_msgId)
		{
			case WTS_U_APP_SESSION_LOGOUT: _obj = new notifications::Protocol_WTS_U_APP_SESSION_LOGOUT(); break;
		}
	}
	
	return _obj;
}

/* static */ bool WebTokenServer::ProtocolFactory::validateProtocolMessageFromJSONString(const char *_nameSpace, UINT32 _msgId, const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case WTS_A_GET_TOKEN: cli::Protocol_WTS_A_GET_TOKEN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN: cli::Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case WTS_Q_GET_TOKEN: cli::Protocol_WTS_Q_GET_TOKEN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN: cli::Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "cli_unauth"))
	{
		switch(_msgId)
		{
			case WTS_A_GET_TOKEN_EXPIRY_TIME: cli_unauth::Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case WTS_A_VERIFY_PSIP_TOKEN: cli_unauth::Protocol_WTS_A_VERIFY_PSIP_TOKEN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case WTS_Q_GET_TOKEN_EXPIRY_TIME: cli_unauth::Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case WTS_Q_VERIFY_PSIP_TOKEN: cli_unauth::Protocol_WTS_Q_VERIFY_PSIP_TOKEN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "notifications"))
	{
		switch(_msgId)
		{
			case WTS_U_APP_SESSION_LOGOUT: notifications::Protocol_WTS_U_APP_SESSION_LOGOUT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

/* static */ bool WebTokenServer::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case WTS_A_GET_TOKEN: cli::Protocol_WTS_A_GET_TOKEN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN: cli::Protocol_WTS_A_REMOVE_WEBACCOUNTSERVICE_TOKEN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case WTS_Q_GET_TOKEN: cli::Protocol_WTS_Q_GET_TOKEN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN: cli::Protocol_WTS_Q_REMOVE_WEBACCOUNTSERVICE_TOKEN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "cli_unauth"))
	{
		switch(_msgId)
		{
			case WTS_A_GET_TOKEN_EXPIRY_TIME: cli_unauth::Protocol_WTS_A_GET_TOKEN_EXPIRY_TIME::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case WTS_A_VERIFY_PSIP_TOKEN: cli_unauth::Protocol_WTS_A_VERIFY_PSIP_TOKEN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case WTS_Q_GET_TOKEN_EXPIRY_TIME: cli_unauth::Protocol_WTS_Q_GET_TOKEN_EXPIRY_TIME::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case WTS_Q_VERIFY_PSIP_TOKEN: cli_unauth::Protocol_WTS_Q_VERIFY_PSIP_TOKEN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "notifications"))
	{
		switch(_msgId)
		{
			case WTS_U_APP_SESSION_LOGOUT: notifications::Protocol_WTS_U_APP_SESSION_LOGOUT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

