/**
 * ip2country_atf.cpp
 *
 * This file was auto-generated from ip2country_atf.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: ip2country_atf.txt
 */
 
#include "ip2country_atf.h"

//=================================================================
//                Protocol_MSG_REDIRECTOR_URL
//=================================================================

ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL::Protocol_MSG_REDIRECTOR_URL()
{
	clear();
}

void ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL::clear()
{
	siteId = 0;
	clientExtra.clear();
	userId = "";
	licenseId = 0;
}

bool ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL::equals(const Protocol_MSG_REDIRECTOR_URL& _o) const
{
	return siteId == _o.siteId &&
		clientExtra.equals(_o.clientExtra) &&
		Atf::atfPStringEquals(userId, _o.userId) &&
		licenseId == _o.licenseId;
}

bool ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REDIRECTOR_URL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REDIRECTOR_URL*)_other));
}

const char *ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REDIRECTOR_URL).append(")");
	_buf.append(',');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("clientExtra=");
	clientExtra.toTraceString(_buf);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("licenseId=");
	_buf.appendUint(licenseId);
	return _buf.c_str();
}

const char *ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REDIRECTOR_URL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("siteId", siteId, _buf);
	clientExtra.toXmlString("clientExtra", _buf);
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("licenseId", licenseId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("siteId"))
			{
				siteId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientExtra"))
			{
				if(!Atf::AtfTempl< Common::AtfShared::LoginExtra >::FromXmlString(_value, clientExtra)) return false;
			}
			else if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("licenseId"))
			{
				licenseId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(siteId);
	clientExtra.composeMsg(_msg, _ignoreJSON);
	_msg.composeString(userId);
	_msg.composeUINT32(licenseId);
}

void ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(siteId);
	if(_parser.parseEnded()) return;
	clientExtra.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(userId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(licenseId);
}

const char *ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("siteId", siteId);
	_jsonstr.compose("clientExtra", clientExtra);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("licenseId", licenseId);
	return _buf.c_str();
}

void ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("siteId", siteId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("clientExtra", clientExtra);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("userId", userId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("licenseId", licenseId);
}

/*static*/ void ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REDIRECTOR_URL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 siteId; _jparser.validateByNameThrow("siteId", siteId);
	AtfValidator::validateIntMax(_descr, "siteId", siteId, PokerStars_Last, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	Common::AtfShared::LoginExtra clientExtra; _jparser.validateByNameThrow("clientExtra", clientExtra);
	if(_jparser.parseEnded()) return;
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), 20, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 licenseId; _jparser.validateByNameThrow("licenseId", licenseId);
	AtfValidator::validateIntMax(_descr, "licenseId", licenseId, eLicenceLast, _checker, __FILE__, __LINE__);
}

/*static*/ void ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REDIRECTOR_URL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 siteId; _parser.parseUINT32(siteId);
	AtfValidator::validateIntMax(_descr, "siteId", siteId, PokerStars_Last, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PString _descbuf;
	Common::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientExtra"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, 20, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 licenseId; _parser.parseUINT32(licenseId);
	AtfValidator::validateIntMax(_descr, "licenseId", licenseId, eLicenceLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REDIRECTOR_URL_ERROR_REPLY
//=================================================================

ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_ERROR_REPLY::Protocol_MSG_REDIRECTOR_URL_ERROR_REPLY()
{
	clear();
}

void ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_ERROR_REPLY::clear()
{
	errCode = 0;
}

bool ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_ERROR_REPLY::equals(const Protocol_MSG_REDIRECTOR_URL_ERROR_REPLY& _o) const
{
	return errCode == _o.errCode;
}

bool ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_ERROR_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REDIRECTOR_URL_ERROR_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REDIRECTOR_URL_ERROR_REPLY*)_other));
}

const char *ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_ERROR_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REDIRECTOR_URL_ERROR_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendUint(errCode);
	return _buf.c_str();
}

const char *ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_ERROR_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_ERROR_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REDIRECTOR_URL_ERROR_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_ERROR_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_ERROR_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT16(errCode);
}

void ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_ERROR_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT16(errCode);
}

const char *ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_ERROR_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	return _buf.c_str();
}

void ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_ERROR_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
}

/*static*/ void ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_ERROR_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REDIRECTOR_URL_ERROR_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
}

/*static*/ void ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_ERROR_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REDIRECTOR_URL_ERROR_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT16 errCode; _parser.parseUINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_REDIRECTOR_URL_REPLY
//=================================================================

ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_REPLY::Protocol_MSG_REDIRECTOR_URL_REPLY()
{
	clear();
}

void ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_REPLY::clear()
{
	url.clear();
	country.clear();
	ipAddr.clear();
	region.clear();
	redirectorTemplate.clear();
}

bool ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_REPLY::equals(const Protocol_MSG_REDIRECTOR_URL_REPLY& _o) const
{
	return Atf::atfPStringEquals(url, _o.url) &&
		Atf::atfPStringEquals(country, _o.country) &&
		Atf::atfPStringEquals(ipAddr, _o.ipAddr) &&
		Atf::atfPStringEquals(region, _o.region) &&
		Atf::atfPStringEquals(redirectorTemplate, _o.redirectorTemplate);
}

bool ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_REDIRECTOR_URL_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_REDIRECTOR_URL_REPLY*)_other));
}

const char *ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_REDIRECTOR_URL_REPLY).append(")");
	_buf.append(',');
	_buf.append("url=");
	_buf.append(url);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("ipAddr=");
	_buf.append(ipAddr);
	_buf.append(',');
	_buf.append("region=");
	_buf.append(region);
	_buf.append(',');
	_buf.append("redirectorTemplate=");
	_buf.append(redirectorTemplate);
	return _buf.c_str();
}

const char *ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_REDIRECTOR_URL_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("url", url, _buf);
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::encodeAsXmlElement("ipAddr", ipAddr, _buf);
	Atf::XmlElement::encodeAsXmlElement("region", region, _buf);
	Atf::XmlElement::encodeAsXmlElement("redirectorTemplate", redirectorTemplate, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("url"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, url)) return false;
			}
			else if (_element.equals("country"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
			}
			else if (_element.equals("ipAddr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, ipAddr)) return false;
			}
			else if (_element.equals("region"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, region)) return false;
			}
			else if (_element.equals("redirectorTemplate"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, redirectorTemplate)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(url);
	_msg.composeString(country);
	_msg.composeString(ipAddr);
	_msg.composeString(region);
	CommMsgBody _msg0;
	_msg0.composeString(redirectorTemplate);
	_msg.composeMsgBody(_msg0);
}

void ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(url);
	_parser.parseStringP(country);
	_parser.parseStringP(ipAddr);
	_parser.parseStringP(region);
	parseAnonymousMsgBody0(_parser);
}

const char *ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("url", url);
	_jsonstr.compose("country", country);
	_jsonstr.compose("ipAddr", ipAddr);
	_jsonstr.compose("region", region);
	_jsonstr.compose("redirectorTemplate", redirectorTemplate);
	return _buf.c_str();
}

void ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("url", url);
	_jparser.parseByNameThrow("country", country);
	_jparser.parseByNameThrow("ipAddr", ipAddr);
	_jparser.parseByNameThrow("region", region);
	_jparser.parseByNameThrow("redirectorTemplate", redirectorTemplate);
}

/*static*/ void ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REDIRECTOR_URL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString url; _jparser.validateByNameThrow("url", url);
	AtfValidator::validateInt(_descr, "url", url.length(), _checker, __FILE__, __LINE__);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateInt(_descr, "country", country.length(), _checker, __FILE__, __LINE__);
	PString ipAddr; _jparser.validateByNameThrow("ipAddr", ipAddr);
	AtfValidator::validateInt(_descr, "ipAddr", ipAddr.length(), _checker, __FILE__, __LINE__);
	PString region; _jparser.validateByNameThrow("region", region);
	AtfValidator::validateInt(_descr, "region", region.length(), _checker, __FILE__, __LINE__);
	PString redirectorTemplate; _jparser.validateByNameThrow("redirectorTemplate", redirectorTemplate);
	AtfValidator::validateInt(_descr, "redirectorTemplate", redirectorTemplate.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_REDIRECTOR_URL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "url"); size_t szUrl = strlen(_dummy);
	AtfValidator::validateInt(_descr, "url", szUrl, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "ipAddr"); size_t szIpAddr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "ipAddr", szIpAddr, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "region"); size_t szRegion = strlen(_dummy);
	AtfValidator::validateInt(_descr, "region", szRegion, _checker, __FILE__, __LINE__);
	validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_REPLY::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(redirectorTemplate);
}

/*static*/ void ip2country::cli_unauth::Protocol_MSG_REDIRECTOR_URL_REPLY::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "redirectorTemplate"); size_t szRedirectorTemplate = strlen(_dummy);
	AtfValidator::validateInt(_descr, "redirectorTemplate", szRedirectorTemplate, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    NameValuePair
//=================================================================

ip2country::cli_unauth::NameValuePair::NameValuePair()
{
	clear();
}

void ip2country::cli_unauth::NameValuePair::clear()
{
	name.clear();
	value.clear();
}

bool ip2country::cli_unauth::NameValuePair::equals(const NameValuePair& _o) const
{
	return Atf::atfPStringEquals(name, _o.name) &&
		Atf::atfPStringEquals(value, _o.value);
}

const char *ip2country::cli_unauth::NameValuePair::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("value=");
	_buf.append(value);
	_buf.append('}');
	return _buf.c_str();
}

const char *ip2country::cli_unauth::NameValuePair::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	Atf::XmlElement::encodeAsXmlElement("value", value, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool ip2country::cli_unauth::NameValuePair::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("name"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
		}
		else if (_element.equals("value"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, value)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void ip2country::cli_unauth::NameValuePair::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(NameValuePair())) // not empty
	{
		_body.composeString(name);
		_body.composeString(value);
	}

	_msg.composeMsgBody(_body);
}

void ip2country::cli_unauth::NameValuePair::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(name);
	_parser0.parseStringP(value);
}

const char *ip2country::cli_unauth::NameValuePair::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("name", name);
	_jsonstr.compose("value", value);
	return _buf.c_str();
}

void ip2country::cli_unauth::NameValuePair::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("name", name);
	_jparser.parseByNameThrow("value", value);
}

/* static */ void ip2country::cli_unauth::NameValuePair::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateIntMax(_descr, "name", name.length(), 128, _checker, __FILE__, __LINE__);
	PString value; _jparser.validateByNameThrow("value", value);
	AtfValidator::validateIntMax(_descr, "value", value.length(), 2000, _checker, __FILE__, __LINE__);
}

/*static*/ void ip2country::cli_unauth::NameValuePair::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "name", szName, 128, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "value"); size_t szValue = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "value", szValue, 2000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    Params
//=================================================================

ip2country::cli_unauth::Params::Params()
{
	clear();
}

void ip2country::cli_unauth::Params::clear()
{
	pairs.clear();
}

bool ip2country::cli_unauth::Params::equals(const Params& _o) const
{
	return pairs.equals(_o.pairs);
}

const char *ip2country::cli_unauth::Params::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("pairs=");
	pairs.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *ip2country::cli_unauth::Params::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	pairs.toXmlString("pairs", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool ip2country::cli_unauth::Params::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("pairs"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< NameValuePair, 4 > >::FromXmlString(_value, pairs)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void ip2country::cli_unauth::Params::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(Params())) // not empty
	{
		pairs.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void ip2country::cli_unauth::Params::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	pairs.parseMsg(_parser0);
}

const char *ip2country::cli_unauth::Params::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("pairs", pairs);
	return _buf.c_str();
}

void ip2country::cli_unauth::Params::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("pairs", pairs);
}

/* static */ void ip2country::cli_unauth::Params::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< NameValuePair > pairs; _jparser.validateByNameThrow("pairs", pairs);
	AtfValidator::validateIntMax(_descr, "pairs", pairs.size(), 500, _checker, __FILE__, __LINE__);
}

/*static*/ void ip2country::cli_unauth::Params::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szPairs = Atf::LAtfVector< NameValuePair, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("pairs"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "pairs", szPairs, 500, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_RESOLVER_TAG
//=================================================================

ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG::Protocol_MSG_RESOLVER_TAG()
{
	clear();
}

void ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG::clear()
{
	tag.clear();
	siteId = 0;
	country.clear();
	localeId = 0;
	clientExtra.clear();
	urlParamStr.clear();
	isForceTest = false;
	appUserIntId = 0;
	appTimeUtc.setNull();
	params.clear();
	state.clear();
	licenseId = 0;
}

bool ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG::equals(const Protocol_MSG_RESOLVER_TAG& _o) const
{
	return Atf::atfPStringEquals(tag, _o.tag) &&
		siteId == _o.siteId &&
		Atf::atfPStringEquals(country, _o.country) &&
		localeId == _o.localeId &&
		clientExtra.equals(_o.clientExtra) &&
		Atf::atfPStringEquals(urlParamStr, _o.urlParamStr) &&
		isForceTest == _o.isForceTest &&
		appUserIntId == _o.appUserIntId &&
		appTimeUtc.equals(_o.appTimeUtc) &&
		params.equals(_o.params) &&
		Atf::atfPStringEquals(state, _o.state) &&
		licenseId == _o.licenseId;
}

bool ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_RESOLVER_TAG != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_RESOLVER_TAG*)_other));
}

const char *ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_RESOLVER_TAG).append(")");
	_buf.append(',');
	_buf.append("tag=");
	_buf.append(tag);
	_buf.append(',');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("localeId=");
	_buf.appendUint(localeId);
	_buf.append(',');
	_buf.append("clientExtra=");
	clientExtra.toTraceString(_buf);
	_buf.append(',');
	_buf.append("urlParamStr=");
	_buf.append(urlParamStr);
	_buf.append(',');
	_buf.append("isForceTest=");
	_buf.appendUint(isForceTest);
	_buf.append(',');
	_buf.append("appUserIntId=");
	_buf.appendUint(appUserIntId);
	_buf.append(',');
	_buf.append("appTimeUtc=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, appTimeUtc);
	_buf.append(',');
	_buf.append("params=");
	params.toTraceString(_buf);
	_buf.append(',');
	_buf.append("state=");
	_buf.append(state);
	_buf.append(',');
	_buf.append("licenseId=");
	_buf.appendUint(licenseId);
	return _buf.c_str();
}

const char *ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_RESOLVER_TAG).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("tag", tag, _buf);
	Atf::XmlElement::encodeAsXmlElement("siteId", siteId, _buf);
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::encodeAsXmlElement("localeId", localeId, _buf);
	clientExtra.toXmlString("clientExtra", _buf);
	Atf::XmlElement::encodeAsXmlElement("urlParamStr", urlParamStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("isForceTest", isForceTest, _buf);
	Atf::XmlElement::encodeAsXmlElement("appUserIntId", appUserIntId, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "appTimeUtc", appTimeUtc);
	params.toXmlString("params", _buf);
	Atf::XmlElement::encodeAsXmlElement("state", state, _buf);
	Atf::XmlElement::encodeAsXmlElement("licenseId", licenseId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tag"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tag)) return false;
			}
			else if (_element.equals("siteId"))
			{
				siteId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("country"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
			}
			else if (_element.equals("localeId"))
			{
				localeId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientExtra"))
			{
				if(!Atf::AtfTempl< Common::AtfShared::LoginExtra >::FromXmlString(_value, clientExtra)) return false;
			}
			else if (_element.equals("urlParamStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, urlParamStr)) return false;
			}
			else if (_element.equals("isForceTest"))
			{
				isForceTest = (*_value.ptr() == '1');
			}
			else if (_element.equals("appUserIntId"))
			{
				appUserIntId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("appTimeUtc"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, appTimeUtc);
			}
			else if (_element.equals("params"))
			{
				if(!Atf::AtfTempl< Params >::FromXmlString(_value, params)) return false;
			}
			else if (_element.equals("state"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, state)) return false;
			}
			else if (_element.equals("licenseId"))
			{
				licenseId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(tag);
	_msg.composeUINT32(siteId);
	_msg.composeString(country);
	_msg.composeUINT32(localeId);
	clientExtra.composeMsg(_msg, _ignoreJSON);
	_msg.composeString(urlParamStr);
	_msg.composeBOOL(isForceTest);
	_msg.composeUINT32(appUserIntId);
	_msg.composeSrvTime(appTimeUtc);
	params.composeMsg(_msg, _ignoreJSON);
	_msg.composeString(state);
	_msg.composeUINT32(licenseId);
}

void ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(tag);
	_parser.parseUINT32(siteId);
	_parser.parseStringP(country);
	_parser.parseUINT32(localeId);
	clientExtra.parseMsg(_parser);
	_parser.parseStringP(urlParamStr);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(isForceTest);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(appUserIntId);
	if(_parser.parseEnded()) return;
	_parser.parseSrvTime(appTimeUtc);
	if(_parser.parseEnded()) return;
	params.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(state);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(licenseId);
}

const char *ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tag", tag);
	_jsonstr.compose("siteId", siteId);
	_jsonstr.compose("country", country);
	_jsonstr.compose("localeId", localeId);
	_jsonstr.compose("clientExtra", clientExtra);
	_jsonstr.compose("urlParamStr", urlParamStr);
	_jsonstr.compose("isForceTest", isForceTest);
	_jsonstr.compose("appUserIntId", appUserIntId);
	_jsonstr.compose("appTimeUtc", appTimeUtc);
	_jsonstr.compose("params", params);
	_jsonstr.compose("state", state);
	_jsonstr.compose("licenseId", licenseId);
	return _buf.c_str();
}

void ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tag", tag);
	_jparser.parseByNameThrow("siteId", siteId);
	_jparser.parseByNameThrow("country", country);
	_jparser.parseByNameThrow("localeId", localeId);
	_jparser.parseByNameThrow("clientExtra", clientExtra);
	_jparser.parseByNameThrow("urlParamStr", urlParamStr);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("isForceTest", isForceTest);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("appUserIntId", appUserIntId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("appTimeUtc", appTimeUtc);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("params", params);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("state", state);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("licenseId", licenseId);
}

/*static*/ void ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_RESOLVER_TAG";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString tag; _jparser.validateByNameThrow("tag", tag);
	AtfValidator::validateIntMax(_descr, "tag", tag.length(), 128, _checker, __FILE__, __LINE__);
	UINT32 siteId; _jparser.validateByNameThrow("siteId", siteId);
	AtfValidator::validateIntMax(_descr, "siteId", siteId, Sites::PokerStars_Last, _checker, __FILE__, __LINE__);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateIntMax(_descr, "country", country.length(), 100, _checker, __FILE__, __LINE__);
	UINT32 localeId; _jparser.validateByNameThrow("localeId", localeId);
	AtfValidator::validateIntMax(_descr, "localeId", localeId, MAX_LOCALES, _checker, __FILE__, __LINE__);
	Common::AtfShared::LoginExtra clientExtra; _jparser.validateByNameThrow("clientExtra", clientExtra);
	PString urlParamStr; _jparser.validateByNameThrow("urlParamStr", urlParamStr);
	AtfValidator::validateIntMax(_descr, "urlParamStr", urlParamStr.length(), 10000, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool isForceTest; _jparser.validateByNameThrow("isForceTest", isForceTest);
	AtfValidator::validateInt(_descr, "isForceTest", isForceTest, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 appUserIntId; _jparser.validateByNameThrow("appUserIntId", appUserIntId);
	AtfValidator::validateInt(_descr, "appUserIntId", appUserIntId, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	SrvTime appTimeUtc; _jparser.validateByNameThrow("appTimeUtc", appTimeUtc);
	AtfValidator::validateSrvDateTime(_descr, "appTimeUtc", appTimeUtc, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	Params params; _jparser.validateByNameThrow("params", params);
	if(_jparser.parseEnded()) return;
	PString state; _jparser.validateByNameThrow("state", state);
	AtfValidator::validateIntMax(_descr, "state", state.length(), 100, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 licenseId; _jparser.validateByNameThrow("licenseId", licenseId);
	AtfValidator::validateIntMax(_descr, "licenseId", licenseId, eLicenceLast, _checker, __FILE__, __LINE__);
}

/*static*/ void ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_RESOLVER_TAG";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "tag"); size_t szTag = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "tag", szTag, 128, _checker, __FILE__, __LINE__);
	UINT32 siteId; _parser.parseUINT32(siteId);
	AtfValidator::validateIntMax(_descr, "siteId", siteId, Sites::PokerStars_Last, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, 100, _checker, __FILE__, __LINE__);
	UINT32 localeId; _parser.parseUINT32(localeId);
	AtfValidator::validateIntMax(_descr, "localeId", localeId, MAX_LOCALES, _checker, __FILE__, __LINE__);
	PString _descbuf;
	Common::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientExtra"), _fieldsWithUnparsedContent);
	_parser.parseStringN(_dummy, 0, "urlParamStr"); size_t szUrlParamStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "urlParamStr", szUrlParamStr, 10000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool isForceTest; _parser.parseBOOL(isForceTest);
	AtfValidator::validateInt(_descr, "isForceTest", isForceTest, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 appUserIntId; _parser.parseUINT32(appUserIntId);
	AtfValidator::validateInt(_descr, "appUserIntId", appUserIntId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	SrvTime appTimeUtc; _parser.parseSrvTime(appTimeUtc);
	AtfValidator::validateSrvDateTime(_descr, "appTimeUtc", appTimeUtc, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	Params::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("params"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "state"); size_t szState = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "state", szState, 100, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 licenseId; _parser.parseUINT32(licenseId);
	AtfValidator::validateIntMax(_descr, "licenseId", licenseId, eLicenceLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_RESOLVER_TAG_REPLY
//=================================================================

ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG_REPLY::Protocol_MSG_RESOLVER_TAG_REPLY()
{
	clear();
}

void ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG_REPLY::clear()
{
	errCode = 0;
	url.clear();
	errDescr.clear();
}

bool ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG_REPLY::equals(const Protocol_MSG_RESOLVER_TAG_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(url, _o.url) &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_RESOLVER_TAG_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_RESOLVER_TAG_REPLY*)_other));
}

const char *ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_RESOLVER_TAG_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode == 0 )
	{
		_buf.append(',');
		_buf.append("url=");
		_buf.append(url);
	}
	else
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_RESOLVER_TAG_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode == 0 )
	{
		Atf::XmlElement::encodeAsXmlElement("url", url, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("url"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, url)) return false;
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode == 0 )
	{
		_msg.composeString(url);
	}
	else
	{
		_msg.composeString(errDescr);
	}
}

void ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode == 0 )
	{
		_parser.parseStringP(url);
	}
	else
	{
		_parser.parseStringP(errDescr);
	}
}

const char *ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode == 0 )
	{
		_jsonstr.compose("url", url);
	}
	else
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode == 0 )
	{
		_jparser.parseByNameThrow("url", url);
	}
	else
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_RESOLVER_TAG_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode == 0 )
	{
		PString url; _jparser.validateByNameThrow("url", url);
		AtfValidator::validateInt(_descr, "url", url.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void ip2country::cli_unauth::Protocol_MSG_RESOLVER_TAG_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_RESOLVER_TAG_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode == 0 )
	{
		_parser.parseStringN(_dummy, 0, "url"); size_t szUrl = strlen(_dummy);
		AtfValidator::validateInt(_descr, "url", szUrl, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_RESOLVER_GET_VERSION
//=================================================================

ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION::Protocol_MSG_RESOLVER_GET_VERSION()
{
	clear();
}

void ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION::clear()
{
}

bool ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION::equals(const Protocol_MSG_RESOLVER_GET_VERSION& _o) const
{
	return true;
}

bool ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_RESOLVER_GET_VERSION != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_RESOLVER_GET_VERSION*)_other));
}

const char *ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_RESOLVER_GET_VERSION).append(")");
	return _buf.c_str();
}

const char *ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_RESOLVER_GET_VERSION).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION::parseMsg(CommMsgParser& _parser)
{
}

const char *ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_RESOLVER_GET_VERSION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_RESOLVER_GET_VERSION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_RESOLVER_GET_VERSION_REPLY
//=================================================================

ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION_REPLY::Protocol_MSG_RESOLVER_GET_VERSION_REPLY()
{
	clear();
}

void ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION_REPLY::clear()
{
	errCode = 0;
	version.clear();
	errDescr.clear();
}

bool ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION_REPLY::equals(const Protocol_MSG_RESOLVER_GET_VERSION_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(version, _o.version) &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_RESOLVER_GET_VERSION_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_RESOLVER_GET_VERSION_REPLY*)_other));
}

const char *ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_RESOLVER_GET_VERSION_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode == 0 )
	{
		_buf.append(',');
		_buf.append("version=");
		_buf.append(version);
	}
	else
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_RESOLVER_GET_VERSION_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode == 0 )
	{
		Atf::XmlElement::encodeAsXmlElement("version", version, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("version"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, version)) return false;
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode == 0 )
	{
		_msg.composeString(version);
	}
	else
	{
		_msg.composeString(errDescr);
	}
}

void ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode == 0 )
	{
		_parser.parseStringP(version);
	}
	else
	{
		_parser.parseStringP(errDescr);
	}
}

const char *ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode == 0 )
	{
		_jsonstr.compose("version", version);
	}
	else
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode == 0 )
	{
		_jparser.parseByNameThrow("version", version);
	}
	else
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_RESOLVER_GET_VERSION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode == 0 )
	{
		PString version; _jparser.validateByNameThrow("version", version);
		AtfValidator::validateInt(_descr, "version", version.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void ip2country::cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_RESOLVER_GET_VERSION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode == 0 )
	{
		_parser.parseStringN(_dummy, 0, "version"); size_t szVersion = strlen(_dummy);
		AtfValidator::validateInt(_descr, "version", szVersion, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ Atf::MessageProtocol* ip2country::ProtocolFactory::createMessageProtocolObject(const char *_nameSpace, UINT32 _msgId)
{
	Atf::MessageProtocol *_obj = NULL;

	if(!strcmp(_nameSpace, "cli_unauth"))
	{
		switch(_msgId)
		{
			case MSG_REDIRECTOR_URL: _obj = new cli_unauth::Protocol_MSG_REDIRECTOR_URL(); break;
			case MSG_REDIRECTOR_URL_ERROR_REPLY: _obj = new cli_unauth::Protocol_MSG_REDIRECTOR_URL_ERROR_REPLY(); break;
			case MSG_REDIRECTOR_URL_REPLY: _obj = new cli_unauth::Protocol_MSG_REDIRECTOR_URL_REPLY(); break;
			case MSG_RESOLVER_GET_VERSION: _obj = new cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION(); break;
			case MSG_RESOLVER_GET_VERSION_REPLY: _obj = new cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION_REPLY(); break;
			case MSG_RESOLVER_TAG: _obj = new cli_unauth::Protocol_MSG_RESOLVER_TAG(); break;
			case MSG_RESOLVER_TAG_REPLY: _obj = new cli_unauth::Protocol_MSG_RESOLVER_TAG_REPLY(); break;
		}
	}
	
	return _obj;
}

/* static */ bool ip2country::ProtocolFactory::validateProtocolMessageFromJSONString(const char *_nameSpace, UINT32 _msgId, const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli_unauth"))
	{
		switch(_msgId)
		{
			case MSG_REDIRECTOR_URL: cli_unauth::Protocol_MSG_REDIRECTOR_URL::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REDIRECTOR_URL_ERROR_REPLY: cli_unauth::Protocol_MSG_REDIRECTOR_URL_ERROR_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_REDIRECTOR_URL_REPLY: cli_unauth::Protocol_MSG_REDIRECTOR_URL_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_RESOLVER_GET_VERSION: cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_RESOLVER_GET_VERSION_REPLY: cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_RESOLVER_TAG: cli_unauth::Protocol_MSG_RESOLVER_TAG::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_RESOLVER_TAG_REPLY: cli_unauth::Protocol_MSG_RESOLVER_TAG_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

/* static */ bool ip2country::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli_unauth"))
	{
		switch(_msgId)
		{
			case MSG_REDIRECTOR_URL: cli_unauth::Protocol_MSG_REDIRECTOR_URL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REDIRECTOR_URL_ERROR_REPLY: cli_unauth::Protocol_MSG_REDIRECTOR_URL_ERROR_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_REDIRECTOR_URL_REPLY: cli_unauth::Protocol_MSG_REDIRECTOR_URL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_RESOLVER_GET_VERSION: cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_RESOLVER_GET_VERSION_REPLY: cli_unauth::Protocol_MSG_RESOLVER_GET_VERSION_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_RESOLVER_TAG: cli_unauth::Protocol_MSG_RESOLVER_TAG::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_RESOLVER_TAG_REPLY: cli_unauth::Protocol_MSG_RESOLVER_TAG_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

