/**
 * mlobby_atf.cpp
 *
 * This file was auto-generated from mlobby_atf.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: mlobby_atf.txt
 */
 
#include "mlobby_atf.h"

//=================================================================
//                    Filter
//=================================================================

MLobby::cli::Filter::Filter()
{
	clear();
}

void MLobby::cli::Filter::clear()
{
	version = 0;
	locale = 0;
	country.clear();
	siteId = 0;
	game = 0;
	hiLo = 0;
	limit = 0;
	minStake = 0;
	maxStake = 0;
	buyInMask = 0;
	minBuyIn = 0;
	maxBuyIn = 0;
	maxPlayers = 0;
	minSeated = 0;
	minAvailable = 0;
	speed = 0;
	currencies = 0;
	format = 0;
	startingSoon = 0;
	state = 0;
	order = 0;
	realMoney = false;
	minEntrants = 0;
	maxEntrants = 0;
	zoomTournaments = 0;
	multiplierPM = 0;
	features = 0;
	tableStarters = false;
	nameCriteria.clear();
	specialSearchMode = 0;
	clientSortingSeed = 0;
	brandMask = 0;
	notUsed = 0;
	seatFindersAndBlitzes = 0;
}

bool MLobby::cli::Filter::equals(const Filter& _o) const
{
	return version == _o.version &&
		locale == _o.locale &&
		Atf::atfPStringEquals(country, _o.country) &&
		siteId == _o.siteId &&
		game == _o.game &&
		hiLo == _o.hiLo &&
		limit == _o.limit &&
		minStake == _o.minStake &&
		maxStake == _o.maxStake &&
		buyInMask == _o.buyInMask &&
		minBuyIn == _o.minBuyIn &&
		maxBuyIn == _o.maxBuyIn &&
		maxPlayers == _o.maxPlayers &&
		minSeated == _o.minSeated &&
		minAvailable == _o.minAvailable &&
		speed == _o.speed &&
		currencies == _o.currencies &&
		format == _o.format &&
		startingSoon == _o.startingSoon &&
		state == _o.state &&
		order == _o.order &&
		realMoney == _o.realMoney &&
		minEntrants == _o.minEntrants &&
		maxEntrants == _o.maxEntrants &&
		zoomTournaments == _o.zoomTournaments &&
		multiplierPM == _o.multiplierPM &&
		features == _o.features &&
		tableStarters == _o.tableStarters &&
		Atf::atfPStringEquals(nameCriteria, _o.nameCriteria) &&
		specialSearchMode == _o.specialSearchMode &&
		clientSortingSeed == _o.clientSortingSeed &&
		brandMask == _o.brandMask &&
		notUsed == _o.notUsed &&
		seatFindersAndBlitzes == _o.seatFindersAndBlitzes;
}

const char *MLobby::cli::Filter::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("version=");
	_buf.appendUint(version);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("hiLo=");
	_buf.appendUint(hiLo);
	_buf.append(',');
	_buf.append("limit=");
	_buf.appendUint(limit);
	_buf.append(',');
	_buf.append("minStake=");
	_buf.appendUint(minStake);
	_buf.append(',');
	_buf.append("maxStake=");
	_buf.appendUint(maxStake);
	_buf.append(',');
	_buf.append("buyInMask=");
	_buf.appendUint(buyInMask);
	_buf.append(',');
	_buf.append("minBuyIn=");
	_buf.appendUint(minBuyIn);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendUint(maxBuyIn);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendUint(maxPlayers);
	_buf.append(',');
	_buf.append("minSeated=");
	_buf.appendUint(minSeated);
	_buf.append(',');
	_buf.append("minAvailable=");
	_buf.appendUint(minAvailable);
	_buf.append(',');
	_buf.append("speed=");
	_buf.appendUint(speed);
	_buf.append(',');
	_buf.append("currencies=");
	_buf.appendUint(currencies);
	_buf.append(',');
	_buf.append("format=");
	_buf.appendUint(format);
	_buf.append(',');
	_buf.append("startingSoon=");
	_buf.appendUint(startingSoon);
	_buf.append(',');
	_buf.append("state=");
	_buf.appendUint(state);
	_buf.append(',');
	_buf.append("order=");
	_buf.appendUint(order);
	if( version >= 2 )
	{
		_buf.append(',');
		_buf.append("realMoney=");
		_buf.appendUint(realMoney);
	}
	if( version >= 3 )
	{
		_buf.append(',');
		_buf.append("minEntrants=");
		_buf.appendUint(minEntrants);
		_buf.append(',');
		_buf.append("maxEntrants=");
		_buf.appendUint(maxEntrants);
	}
	if( version >= 4 )
	{
		_buf.append(',');
		_buf.append("zoomTournaments=");
		_buf.appendUint(zoomTournaments);
		_buf.append(',');
		_buf.append("multiplierPM=");
		_buf.appendUint(multiplierPM);
		_buf.append(',');
		_buf.append("features=");
		_buf.appendUint(features);
	}
	if( version >= 5 )
	{
		_buf.append(',');
		_buf.append("tableStarters=");
		_buf.appendUint(tableStarters);
	}
	if( version >= 6 )
	{
		_buf.append(',');
		_buf.append("nameCriteria=");
		_buf.append(nameCriteria);
		_buf.append(',');
		_buf.append("specialSearchMode=");
		_buf.appendUint(specialSearchMode);
	}
	if( version >= 7 )
	{
		_buf.append(',');
		_buf.append("clientSortingSeed=");
		_buf.appendUint(clientSortingSeed);
	}
	if( version >= 8 )
	{
		_buf.append(',');
		_buf.append("brandMask=");
		_buf.appendUint(brandMask);
	}
	if (version == 9)
	{
		_buf.append(',');
		_buf.append("notUsed=");
		_buf.appendInt(notUsed);
	}
	if( version >= 10 )
	{
		_buf.append(',');
		_buf.append("seatFindersAndBlitzes=");
		_buf.appendInt(seatFindersAndBlitzes);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobby::cli::Filter::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("version", version, _buf);
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::encodeAsXmlElement("siteId", siteId, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("hiLo", hiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("limit", limit, _buf);
	Atf::XmlElement::encodeAsXmlElement("minStake", minStake, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxStake", maxStake, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyInMask", buyInMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("minBuyIn", minBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxBuyIn", maxBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPlayers", maxPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("minSeated", minSeated, _buf);
	Atf::XmlElement::encodeAsXmlElement("minAvailable", minAvailable, _buf);
	Atf::XmlElement::encodeAsXmlElement("speed", speed, _buf);
	Atf::XmlElement::encodeAsXmlElement("currencies", currencies, _buf);
	Atf::XmlElement::encodeAsXmlElement("format", format, _buf);
	Atf::XmlElement::encodeAsXmlElement("startingSoon", startingSoon, _buf);
	Atf::XmlElement::encodeAsXmlElement("state", state, _buf);
	Atf::XmlElement::encodeAsXmlElement("order", order, _buf);
	if( version >= 2 )
	{
		Atf::XmlElement::encodeAsXmlElement("realMoney", realMoney, _buf);
	}
	if( version >= 3 )
	{
		Atf::XmlElement::encodeAsXmlElement("minEntrants", minEntrants, _buf);
		Atf::XmlElement::encodeAsXmlElement("maxEntrants", maxEntrants, _buf);
	}
	if( version >= 4 )
	{
		Atf::XmlElement::encodeAsXmlElement("zoomTournaments", zoomTournaments, _buf);
		Atf::XmlElement::encodeAsXmlElement("multiplierPM", multiplierPM, _buf);
		Atf::XmlElement::encodeAsXmlElement("features", features, _buf);
	}
	if( version >= 5 )
	{
		Atf::XmlElement::encodeAsXmlElement("tableStarters", tableStarters, _buf);
	}
	if( version >= 6 )
	{
		Atf::XmlElement::encodeAsXmlElement("nameCriteria", nameCriteria, _buf);
		Atf::XmlElement::encodeAsXmlElement("specialSearchMode", specialSearchMode, _buf);
	}
	if( version >= 7 )
	{
		Atf::XmlElement::encodeAsXmlElement("clientSortingSeed", clientSortingSeed, _buf);
	}
	if( version >= 8 )
	{
		Atf::XmlElement::encodeAsXmlElement("brandMask", brandMask, _buf);
	}
	if (version == 9)
	{
		Atf::XmlElement::encodeAsXmlElement("notUsed", notUsed, _buf);
	}
	if( version >= 10 )
	{
		Atf::XmlElement::encodeAsXmlElement("seatFindersAndBlitzes", seatFindersAndBlitzes, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobby::cli::Filter::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("version"))
		{
			version = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("locale"))
		{
			locale = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("country"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
		}
		else if (_element.equals("siteId"))
		{
			siteId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("game"))
		{
			game = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("hiLo"))
		{
			hiLo = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("limit"))
		{
			limit = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minStake"))
		{
			minStake = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxStake"))
		{
			maxStake = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("buyInMask"))
		{
			buyInMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minBuyIn"))
		{
			minBuyIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxBuyIn"))
		{
			maxBuyIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxPlayers"))
		{
			maxPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minSeated"))
		{
			minSeated = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minAvailable"))
		{
			minAvailable = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("speed"))
		{
			speed = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currencies"))
		{
			currencies = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("format"))
		{
			format = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("startingSoon"))
		{
			startingSoon = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("state"))
		{
			state = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("order"))
		{
			order = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("realMoney"))
		{
			realMoney = (*_value.ptr() == '1');
		}
		else if (_element.equals("minEntrants"))
		{
			minEntrants = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxEntrants"))
		{
			maxEntrants = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("zoomTournaments"))
		{
			zoomTournaments = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("multiplierPM"))
		{
			multiplierPM = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("features"))
		{
			features = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableStarters"))
		{
			tableStarters = (*_value.ptr() == '1');
		}
		else if (_element.equals("nameCriteria"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, nameCriteria)) return false;
		}
		else if (_element.equals("specialSearchMode"))
		{
			specialSearchMode = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("clientSortingSeed"))
		{
			clientSortingSeed = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("brandMask"))
		{
			brandMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("notUsed"))
		{
			notUsed = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("seatFindersAndBlitzes"))
		{
			seatFindersAndBlitzes = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobby::cli::Filter::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(Filter())) // not empty
	{
		_body.composeBYTE(version);
		_body.composeUINT32(locale);
		_body.composeString(country);
		_body.composeUINT32(siteId);
		_body.composeBYTE(game);
		_body.composeBYTE(hiLo);
		_body.composeBYTE(limit);
		_body.composeUINT32(minStake);
		_body.composeUINT32(maxStake);
		_body.composeUINT32(buyInMask);
		_body.composeUINT32(minBuyIn);
		_body.composeUINT32(maxBuyIn);
		_body.composeUINT32(maxPlayers);
		_body.composeBYTE(minSeated);
		_body.composeBYTE(minAvailable);
		_body.composeBYTE(speed);
		_body.composeUINT32(currencies);
		_body.composeUINT32(format);
		_body.composeUINT32(startingSoon);
		_body.composeUINT32(state);
		_body.composeBYTE(order);
		if( version >= 2 )
		{
			_body.composeBOOL(realMoney);
		}
		if( version >= 3 )
		{
			_body.composeUINT32(minEntrants);
			_body.composeUINT32(maxEntrants);
		}
		if( version >= 4 )
		{
			_body.composeUINT32(zoomTournaments);
			_body.composeUINT32(multiplierPM);
			_body.composeUINT32(features);
		}
		if( version >= 5 )
		{
			_body.composeBOOL(tableStarters);
		}
		if( version >= 6 )
		{
			_body.composeString(nameCriteria);
			_body.composeUINT32(specialSearchMode);
		}
		if( version >= 7 )
		{
			_body.composeUINT32(clientSortingSeed);
		}
		if( version >= 8 )
		{
			_body.composeUINT32(brandMask);
		}
		if (version == 9)
		{
			_body.composeINT8(notUsed);
		}
		if( version >= 10 )
		{
			_body.composeINT8(seatFindersAndBlitzes);
		}
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::Filter::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(version);
	_parser0.parseUINT32(locale);
	_parser0.parseStringP(country);
	_parser0.parseUINT32(siteId);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(hiLo);
	_parser0.parseBYTE(limit);
	_parser0.parseUINT32(minStake);
	_parser0.parseUINT32(maxStake);
	_parser0.parseUINT32(buyInMask);
	_parser0.parseUINT32(minBuyIn);
	_parser0.parseUINT32(maxBuyIn);
	_parser0.parseUINT32(maxPlayers);
	_parser0.parseBYTE(minSeated);
	_parser0.parseBYTE(minAvailable);
	_parser0.parseBYTE(speed);
	_parser0.parseUINT32(currencies);
	_parser0.parseUINT32(format);
	_parser0.parseUINT32(startingSoon);
	_parser0.parseUINT32(state);
	_parser0.parseBYTE(order);
	if( version >= 2 )
	{
		_parser0.parseBOOL(realMoney);
	}
	if( version >= 3 )
	{
		_parser0.parseUINT32(minEntrants);
		_parser0.parseUINT32(maxEntrants);
	}
	if( version >= 4 )
	{
		_parser0.parseUINT32(zoomTournaments);
		_parser0.parseUINT32(multiplierPM);
		_parser0.parseUINT32(features);
	}
	if( version >= 5 )
	{
		_parser0.parseBOOL(tableStarters);
	}
	if( version >= 6 )
	{
		_parser0.parseStringP(nameCriteria);
		_parser0.parseUINT32(specialSearchMode);
	}
	if( version >= 7 )
	{
		_parser0.parseUINT32(clientSortingSeed);
	}
	if( version >= 8 )
	{
		_parser0.parseUINT32(brandMask);
	}
	if (version == 9)
	{
		if(_parser0.parseEnded()) return;
		_parser0.parseINT8(notUsed);
	}
	if( version >= 10 )
	{
		_parser0.parseINT8(seatFindersAndBlitzes);
	}
}

const char *MLobby::cli::Filter::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("version", version);
	_jsonstr.compose("locale", locale);
	_jsonstr.compose("country", country);
	_jsonstr.compose("siteId", siteId);
	_jsonstr.compose("game", game);
	_jsonstr.compose("hiLo", hiLo);
	_jsonstr.compose("limit", limit);
	_jsonstr.compose("minStake", minStake);
	_jsonstr.compose("maxStake", maxStake);
	_jsonstr.compose("buyInMask", buyInMask);
	_jsonstr.compose("minBuyIn", minBuyIn);
	_jsonstr.compose("maxBuyIn", maxBuyIn);
	_jsonstr.compose("maxPlayers", maxPlayers);
	_jsonstr.compose("minSeated", minSeated);
	_jsonstr.compose("minAvailable", minAvailable);
	_jsonstr.compose("speed", speed);
	_jsonstr.compose("currencies", currencies);
	_jsonstr.compose("format", format);
	_jsonstr.compose("startingSoon", startingSoon);
	_jsonstr.compose("state", state);
	_jsonstr.compose("order", order);
	if( version >= 2 )
	{
		_jsonstr.compose("realMoney", realMoney);
	}
	if( version >= 3 )
	{
		_jsonstr.compose("minEntrants", minEntrants);
		_jsonstr.compose("maxEntrants", maxEntrants);
	}
	if( version >= 4 )
	{
		_jsonstr.compose("zoomTournaments", zoomTournaments);
		_jsonstr.compose("multiplierPM", multiplierPM);
		_jsonstr.compose("features", features);
	}
	if( version >= 5 )
	{
		_jsonstr.compose("tableStarters", tableStarters);
	}
	if( version >= 6 )
	{
		_jsonstr.compose("nameCriteria", nameCriteria);
		_jsonstr.compose("specialSearchMode", specialSearchMode);
	}
	if( version >= 7 )
	{
		_jsonstr.compose("clientSortingSeed", clientSortingSeed);
	}
	if( version >= 8 )
	{
		_jsonstr.compose("brandMask", brandMask);
	}
	if (version == 9)
	{
		_jsonstr.compose("notUsed", notUsed);
	}
	if( version >= 10 )
	{
		_jsonstr.compose("seatFindersAndBlitzes", seatFindersAndBlitzes);
	}
	return _buf.c_str();
}

void MLobby::cli::Filter::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("version", version);
	_jparser.parseByNameThrow("locale", locale);
	_jparser.parseByNameThrow("country", country);
	_jparser.parseByNameThrow("siteId", siteId);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("hiLo", hiLo);
	_jparser.parseByNameThrow("limit", limit);
	_jparser.parseByNameThrow("minStake", minStake);
	_jparser.parseByNameThrow("maxStake", maxStake);
	_jparser.parseByNameThrow("buyInMask", buyInMask);
	_jparser.parseByNameThrow("minBuyIn", minBuyIn);
	_jparser.parseByNameThrow("maxBuyIn", maxBuyIn);
	_jparser.parseByNameThrow("maxPlayers", maxPlayers);
	_jparser.parseByNameThrow("minSeated", minSeated);
	_jparser.parseByNameThrow("minAvailable", minAvailable);
	_jparser.parseByNameThrow("speed", speed);
	_jparser.parseByNameThrow("currencies", currencies);
	_jparser.parseByNameThrow("format", format);
	_jparser.parseByNameThrow("startingSoon", startingSoon);
	_jparser.parseByNameThrow("state", state);
	_jparser.parseByNameThrow("order", order);
	if( version >= 2 )
	{
		_jparser.parseByNameThrow("realMoney", realMoney);
	}
	if( version >= 3 )
	{
		_jparser.parseByNameThrow("minEntrants", minEntrants);
		_jparser.parseByNameThrow("maxEntrants", maxEntrants);
	}
	if( version >= 4 )
	{
		_jparser.parseByNameThrow("zoomTournaments", zoomTournaments);
		_jparser.parseByNameThrow("multiplierPM", multiplierPM);
		_jparser.parseByNameThrow("features", features);
	}
	if( version >= 5 )
	{
		_jparser.parseByNameThrow("tableStarters", tableStarters);
	}
	if( version >= 6 )
	{
		_jparser.parseByNameThrow("nameCriteria", nameCriteria);
		_jparser.parseByNameThrow("specialSearchMode", specialSearchMode);
	}
	if( version >= 7 )
	{
		_jparser.parseByNameThrow("clientSortingSeed", clientSortingSeed);
	}
	if( version >= 8 )
	{
		_jparser.parseByNameThrow("brandMask", brandMask);
	}
	if (version == 9)
	{
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("notUsed", notUsed);
	}
	if( version >= 10 )
	{
		_jparser.parseByNameThrow("seatFindersAndBlitzes", seatFindersAndBlitzes);
	}
}

/* static */ void MLobby::cli::Filter::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE version = 0;
	_jparser.validateByNameThrow("version", version);
	AtfValidator::validateInt(_descr, "version", version, _checker, __FILE__, __LINE__);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateIntMax(_descr, "country", country.length(), 3, _checker, __FILE__, __LINE__);
	UINT32 siteId; _jparser.validateByNameThrow("siteId", siteId);
	AtfValidator::validateIntRange(_descr, "siteId", siteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateIntRange(_descr, "game", game, HandTypeNone, HandType_Last, _checker, __FILE__, __LINE__);
	BYTE hiLo; _jparser.validateByNameThrow("hiLo", hiLo);
	AtfValidator::validateIntMax(_descr, "hiLo", hiLo, 1, _checker, __FILE__, __LINE__);
	BYTE limit; _jparser.validateByNameThrow("limit", limit);
	AtfValidator::validateIntRange(_descr, "limit", limit, StructNonDefined, PotStruct_Last, _checker, __FILE__, __LINE__);
	UINT32 minStake; _jparser.validateByNameThrow("minStake", minStake);
	AtfValidator::validateIntMax(_descr, "minStake", minStake, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 maxStake; _jparser.validateByNameThrow("maxStake", maxStake);
	AtfValidator::validateIntMax(_descr, "maxStake", maxStake, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 buyInMask; _jparser.validateByNameThrow("buyInMask", buyInMask);
	AtfValidator::validateIntRange(_descr, "buyInMask", buyInMask, SelectionFilter::Cash, SelectionFilter::BuyInMask_Last, _checker, __FILE__, __LINE__);
	UINT32 minBuyIn; _jparser.validateByNameThrow("minBuyIn", minBuyIn);
	AtfValidator::validateIntMax(_descr, "minBuyIn", minBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 maxBuyIn; _jparser.validateByNameThrow("maxBuyIn", maxBuyIn);
	AtfValidator::validateIntMax(_descr, "maxBuyIn", maxBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 maxPlayers; _jparser.validateByNameThrow("maxPlayers", maxPlayers);
	AtfValidator::validateIntMax(_descr, "maxPlayers", maxPlayers, SelectionFilter::MaxPlayers_Mask_Max, _checker, __FILE__, __LINE__);
	BYTE minSeated; _jparser.validateByNameThrow("minSeated", minSeated);
	AtfValidator::validateIntMax(_descr, "minSeated", minSeated, 10, _checker, __FILE__, __LINE__);
	BYTE minAvailable; _jparser.validateByNameThrow("minAvailable", minAvailable);
	AtfValidator::validateIntMax(_descr, "minAvailable", minAvailable, 10, _checker, __FILE__, __LINE__);
	BYTE speed; _jparser.validateByNameThrow("speed", speed);
	AtfValidator::validateIntMax(_descr, "speed", speed, (2*SelectionFilter::TourneySpeed_Last-1), _checker, __FILE__, __LINE__);
	UINT32 currencies; _jparser.validateByNameThrow("currencies", currencies);
	AtfValidator::validateInt(_descr, "currencies", currencies, _checker, __FILE__, __LINE__);
	UINT32 format; _jparser.validateByNameThrow("format", format);
	AtfValidator::validateIntMax(_descr, "format", format, (2*SelectionFilter::Format_Last-1), _checker, __FILE__, __LINE__);
	UINT32 startingSoon; _jparser.validateByNameThrow("startingSoon", startingSoon);
	AtfValidator::validateInt(_descr, "startingSoon", startingSoon, _checker, __FILE__, __LINE__);
	UINT32 state; _jparser.validateByNameThrow("state", state);
	AtfValidator::validateIntMax(_descr, "state", state, (2*SelectionFilter::State_Last-1), _checker, __FILE__, __LINE__);
	BYTE order; _jparser.validateByNameThrow("order", order);
	AtfValidator::validateIntMax(_descr, "order", order, SelectionFilter::TableOrder_Last, _checker, __FILE__, __LINE__);
	if( version >= 2 )
	{
		bool realMoney; _jparser.validateByNameThrow("realMoney", realMoney);
		AtfValidator::validateInt(_descr, "realMoney", realMoney, _checker, __FILE__, __LINE__);
	}
	if( version >= 3 )
	{
		UINT32 minEntrants; _jparser.validateByNameThrow("minEntrants", minEntrants);
		AtfValidator::validateIntMax(_descr, "minEntrants", minEntrants, 1000000, _checker, __FILE__, __LINE__);
		UINT32 maxEntrants; _jparser.validateByNameThrow("maxEntrants", maxEntrants);
		AtfValidator::validateIntMax(_descr, "maxEntrants", maxEntrants, 1000000, _checker, __FILE__, __LINE__);
	}
	if( version >= 4 )
	{
		UINT32 zoomTournaments; _jparser.validateByNameThrow("zoomTournaments", zoomTournaments);
		AtfValidator::validateIntRange(_descr, "zoomTournaments", zoomTournaments, SelectionFilter::zoom_Exclude, SelectionFilter::ZoomTournaments_Last, _checker, __FILE__, __LINE__);
		UINT32 multiplierPM; _jparser.validateByNameThrow("multiplierPM", multiplierPM);
		AtfValidator::validateInt(_descr, "multiplierPM", multiplierPM, _checker, __FILE__, __LINE__);
		UINT32 features; _jparser.validateByNameThrow("features", features);
		AtfValidator::validateIntRange(_descr, "features", features, SelectionFilter::feature_None, (2*SelectionFilter::ClientFeaturesMobile_Last-1), _checker, __FILE__, __LINE__);
	}
	if( version >= 5 )
	{
		bool tableStarters; _jparser.validateByNameThrow("tableStarters", tableStarters);
		AtfValidator::validateInt(_descr, "tableStarters", tableStarters, _checker, __FILE__, __LINE__);
	}
	if( version >= 6 )
	{
		PString nameCriteria; _jparser.validateByNameThrow("nameCriteria", nameCriteria);
		AtfValidator::validateIntMax(_descr, "nameCriteria", nameCriteria.length(), 1000, _checker, __FILE__, __LINE__);
		UINT32 specialSearchMode; _jparser.validateByNameThrow("specialSearchMode", specialSearchMode);
		AtfValidator::validateIntRange(_descr, "specialSearchMode", specialSearchMode, SelectionFilter::specialSearchMode_None, SelectionFilter::specialSearchMode_tournByNameOnly, _checker, __FILE__, __LINE__);
	}
	if( version >= 7 )
	{
		UINT32 clientSortingSeed; _jparser.validateByNameThrow("clientSortingSeed", clientSortingSeed);
		AtfValidator::validateInt(_descr, "clientSortingSeed", clientSortingSeed, _checker, __FILE__, __LINE__);
	}
	if( version >= 8 )
	{
		UINT32 brandMask; _jparser.validateByNameThrow("brandMask", brandMask);
		AtfValidator::validateIntRange(_descr, "brandMask", brandMask, BrandType_None, BrandType_Last, _checker, __FILE__, __LINE__);
	}
	if (version == 9)
	{
		if(_jparser.parseEnded()) return;
		INT8 notUsed; _jparser.validateByNameThrow("notUsed", notUsed);
		AtfValidator::validateInt(_descr, "notUsed", notUsed, _checker, __FILE__, __LINE__);
	}
	if( version >= 10 )
	{
		INT8 seatFindersAndBlitzes; _jparser.validateByNameThrow("seatFindersAndBlitzes", seatFindersAndBlitzes);
		AtfValidator::validateIntRange(_descr, "seatFindersAndBlitzes", seatFindersAndBlitzes, SelectionFilter::SeatFindersAndBlitzes_Both, SelectionFilter::SeatFindersAndBlitzes_Last, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void MLobby::cli::Filter::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	BYTE version = 0;
	_parser0.parseBYTE(version);
	AtfValidator::validateInt(_descr, "version", version, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser0.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, 3, _checker, __FILE__, __LINE__);
	UINT32 siteId; _parser0.parseUINT32(siteId);
	AtfValidator::validateIntRange(_descr, "siteId", siteId, PokerStars_SiteUnknown, PokerStars_Last, _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateIntRange(_descr, "game", game, HandTypeNone, HandType_Last, _checker, __FILE__, __LINE__);
	BYTE hiLo; _parser0.parseBYTE(hiLo);
	AtfValidator::validateIntMax(_descr, "hiLo", hiLo, 1, _checker, __FILE__, __LINE__);
	BYTE limit; _parser0.parseBYTE(limit);
	AtfValidator::validateIntRange(_descr, "limit", limit, StructNonDefined, PotStruct_Last, _checker, __FILE__, __LINE__);
	UINT32 minStake; _parser0.parseUINT32(minStake);
	AtfValidator::validateIntMax(_descr, "minStake", minStake, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 maxStake; _parser0.parseUINT32(maxStake);
	AtfValidator::validateIntMax(_descr, "maxStake", maxStake, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 buyInMask; _parser0.parseUINT32(buyInMask);
	AtfValidator::validateIntRange(_descr, "buyInMask", buyInMask, SelectionFilter::Cash, SelectionFilter::BuyInMask_Last, _checker, __FILE__, __LINE__);
	UINT32 minBuyIn; _parser0.parseUINT32(minBuyIn);
	AtfValidator::validateIntMax(_descr, "minBuyIn", minBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 maxBuyIn; _parser0.parseUINT32(maxBuyIn);
	AtfValidator::validateIntMax(_descr, "maxBuyIn", maxBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 maxPlayers; _parser0.parseUINT32(maxPlayers);
	AtfValidator::validateIntMax(_descr, "maxPlayers", maxPlayers, SelectionFilter::MaxPlayers_Mask_Max, _checker, __FILE__, __LINE__);
	BYTE minSeated; _parser0.parseBYTE(minSeated);
	AtfValidator::validateIntMax(_descr, "minSeated", minSeated, 10, _checker, __FILE__, __LINE__);
	BYTE minAvailable; _parser0.parseBYTE(minAvailable);
	AtfValidator::validateIntMax(_descr, "minAvailable", minAvailable, 10, _checker, __FILE__, __LINE__);
	BYTE speed; _parser0.parseBYTE(speed);
	AtfValidator::validateIntMax(_descr, "speed", speed, (2*SelectionFilter::TourneySpeed_Last-1), _checker, __FILE__, __LINE__);
	UINT32 currencies; _parser0.parseUINT32(currencies);
	AtfValidator::validateInt(_descr, "currencies", currencies, _checker, __FILE__, __LINE__);
	UINT32 format; _parser0.parseUINT32(format);
	AtfValidator::validateIntMax(_descr, "format", format, (2*SelectionFilter::Format_Last-1), _checker, __FILE__, __LINE__);
	UINT32 startingSoon; _parser0.parseUINT32(startingSoon);
	AtfValidator::validateInt(_descr, "startingSoon", startingSoon, _checker, __FILE__, __LINE__);
	UINT32 state; _parser0.parseUINT32(state);
	AtfValidator::validateIntMax(_descr, "state", state, (2*SelectionFilter::State_Last-1), _checker, __FILE__, __LINE__);
	BYTE order; _parser0.parseBYTE(order);
	AtfValidator::validateIntMax(_descr, "order", order, SelectionFilter::TableOrder_Last, _checker, __FILE__, __LINE__);
	if( version >= 2 )
	{
		bool realMoney; _parser0.parseBOOL(realMoney);
		AtfValidator::validateInt(_descr, "realMoney", realMoney, _checker, __FILE__, __LINE__);
	}
	if( version >= 3 )
	{
		UINT32 minEntrants; _parser0.parseUINT32(minEntrants);
		AtfValidator::validateIntMax(_descr, "minEntrants", minEntrants, 1000000, _checker, __FILE__, __LINE__);
		UINT32 maxEntrants; _parser0.parseUINT32(maxEntrants);
		AtfValidator::validateIntMax(_descr, "maxEntrants", maxEntrants, 1000000, _checker, __FILE__, __LINE__);
	}
	if( version >= 4 )
	{
		UINT32 zoomTournaments; _parser0.parseUINT32(zoomTournaments);
		AtfValidator::validateIntRange(_descr, "zoomTournaments", zoomTournaments, SelectionFilter::zoom_Exclude, SelectionFilter::ZoomTournaments_Last, _checker, __FILE__, __LINE__);
		UINT32 multiplierPM; _parser0.parseUINT32(multiplierPM);
		AtfValidator::validateInt(_descr, "multiplierPM", multiplierPM, _checker, __FILE__, __LINE__);
		UINT32 features; _parser0.parseUINT32(features);
		AtfValidator::validateIntRange(_descr, "features", features, SelectionFilter::feature_None, (2*SelectionFilter::ClientFeaturesMobile_Last-1), _checker, __FILE__, __LINE__);
	}
	if( version >= 5 )
	{
		bool tableStarters; _parser0.parseBOOL(tableStarters);
		AtfValidator::validateInt(_descr, "tableStarters", tableStarters, _checker, __FILE__, __LINE__);
	}
	if( version >= 6 )
	{
		_parser0.parseStringN(_dummy, 0, "nameCriteria"); size_t szNameCriteria = strlen(_dummy);
		AtfValidator::validateIntMax(_descr, "nameCriteria", szNameCriteria, 1000, _checker, __FILE__, __LINE__);
		UINT32 specialSearchMode; _parser0.parseUINT32(specialSearchMode);
		AtfValidator::validateIntRange(_descr, "specialSearchMode", specialSearchMode, SelectionFilter::specialSearchMode_None, SelectionFilter::specialSearchMode_tournByNameOnly, _checker, __FILE__, __LINE__);
	}
	if( version >= 7 )
	{
		UINT32 clientSortingSeed; _parser0.parseUINT32(clientSortingSeed);
		AtfValidator::validateInt(_descr, "clientSortingSeed", clientSortingSeed, _checker, __FILE__, __LINE__);
	}
	if( version >= 8 )
	{
		UINT32 brandMask; _parser0.parseUINT32(brandMask);
		AtfValidator::validateIntRange(_descr, "brandMask", brandMask, BrandType_None, BrandType_Last, _checker, __FILE__, __LINE__);
	}
	if (version == 9)
	{
		if(_parser0.parseEnded()) return;
		INT8 notUsed; _parser0.parseINT8(notUsed);
		AtfValidator::validateInt(_descr, "notUsed", notUsed, _checker, __FILE__, __LINE__);
	}
	if( version >= 10 )
	{
		INT8 seatFindersAndBlitzes; _parser0.parseINT8(seatFindersAndBlitzes);
		AtfValidator::validateIntRange(_descr, "seatFindersAndBlitzes", seatFindersAndBlitzes, SelectionFilter::SeatFindersAndBlitzes_Both, SelectionFilter::SeatFindersAndBlitzes_Last, _checker, __FILE__, __LINE__);
	}
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_RINGGAMES
//=================================================================

MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES::Protocol_MSG_MLOBBY_FIND_RINGGAMES()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES::clear()
{
	filter.clear();
	maxItems = 0;
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES::equals(const Protocol_MSG_MLOBBY_FIND_RINGGAMES& _o) const
{
	return filter.equals(_o.filter) &&
		maxItems == _o.maxItems;
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBY_FIND_RINGGAMES != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBY_FIND_RINGGAMES*)_other));
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_RINGGAMES).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("maxItems=");
	_buf.appendUint(maxItems);
	return _buf.c_str();
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBY_FIND_RINGGAMES).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	filter.toXmlString("filter", _buf);
	Atf::XmlElement::encodeAsXmlElement("maxItems", maxItems, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("filter"))
			{
				if(!Atf::AtfTempl< Filter >::FromXmlString(_value, filter)) return false;
			}
			else if (_element.equals("maxItems"))
			{
				maxItems = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	filter.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(maxItems);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	_parser.parseUINT32(maxItems);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("filter", filter);
	_jsonstr.compose("maxItems", maxItems);
	return _buf.c_str();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("filter", filter);
	_jparser.parseByNameThrow("maxItems", maxItems);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_RINGGAMES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Filter filter; _jparser.validateByNameThrow("filter", filter);
	UINT32 maxItems; _jparser.validateByNameThrow("maxItems", maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_RINGGAMES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	Filter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	UINT32 maxItems; _parser.parseUINT32(maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_TOURNAMENTS
//=================================================================

MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS::clear()
{
	filter.clear();
	maxItems = 0;
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS::equals(const Protocol_MSG_MLOBBY_FIND_TOURNAMENTS& _o) const
{
	return filter.equals(_o.filter) &&
		maxItems == _o.maxItems;
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBY_FIND_TOURNAMENTS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBY_FIND_TOURNAMENTS*)_other));
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_TOURNAMENTS).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("maxItems=");
	_buf.appendUint(maxItems);
	return _buf.c_str();
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBY_FIND_TOURNAMENTS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	filter.toXmlString("filter", _buf);
	Atf::XmlElement::encodeAsXmlElement("maxItems", maxItems, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("filter"))
			{
				if(!Atf::AtfTempl< Filter >::FromXmlString(_value, filter)) return false;
			}
			else if (_element.equals("maxItems"))
			{
				maxItems = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	filter.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(maxItems);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	_parser.parseUINT32(maxItems);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("filter", filter);
	_jsonstr.compose("maxItems", maxItems);
	return _buf.c_str();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("filter", filter);
	_jparser.parseByNameThrow("maxItems", maxItems);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_TOURNAMENTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Filter filter; _jparser.validateByNameThrow("filter", filter);
	UINT32 maxItems; _jparser.validateByNameThrow("maxItems", maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_TOURNAMENTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	Filter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	UINT32 maxItems; _parser.parseUINT32(maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_TABLE_OLD
//=================================================================

MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE_OLD::Protocol_MSG_MLOBBY_FIND_TABLE_OLD()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE_OLD::clear()
{
	filter.clear();
	excludedTables.clear();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE_OLD::equals(const Protocol_MSG_MLOBBY_FIND_TABLE_OLD& _o) const
{
	return filter.equals(_o.filter) &&
		excludedTables.equals(_o.excludedTables);
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE_OLD::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBY_FIND_TABLE_OLD != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBY_FIND_TABLE_OLD*)_other));
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE_OLD::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_TABLE_OLD).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("excludedTables=");
	excludedTables.toTraceString(_buf);
	return _buf.c_str();
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE_OLD::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE_OLD::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBY_FIND_TABLE_OLD).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	filter.toXmlString("filter", _buf);
	excludedTables.toXmlString("excludedTables", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE_OLD::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("filter"))
			{
				if(!Atf::AtfTempl< Filter >::FromXmlString(_value, filter)) return false;
			}
			else if (_element.equals("excludedTables"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, excludedTables)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE_OLD::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	filter.composeMsg(_msg, _ignoreJSON);
	excludedTables.composeMsg(_msg, _ignoreJSON);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE_OLD::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	excludedTables.parseMsg(_parser);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE_OLD::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("filter", filter);
	_jsonstr.compose("excludedTables", excludedTables);
	return _buf.c_str();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE_OLD::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("filter", filter);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("excludedTables", excludedTables);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE_OLD::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_TABLE_OLD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Filter filter; _jparser.validateByNameThrow("filter", filter);
	if(_jparser.parseEnded()) return;
	Atf::AtfVectorBase< UINT32 > excludedTables; _jparser.validateByNameThrow("excludedTables", excludedTables);
	AtfValidator::validateIntMax(_descr, "excludedTables", excludedTables.size(), 1024, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE_OLD::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_TABLE_OLD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	Filter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	int szExcludedTables = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("excludedTables"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "excludedTables", szExcludedTables, 1024, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_TABLE64
//=================================================================

MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64::Protocol_MSG_MLOBBY_FIND_TABLE64()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64::clear()
{
	filter.clear();
	excludedTables.clear();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64::equals(const Protocol_MSG_MLOBBY_FIND_TABLE64& _o) const
{
	return filter.equals(_o.filter) &&
		excludedTables.equals(_o.excludedTables);
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBY_FIND_TABLE64 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBY_FIND_TABLE64*)_other));
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_TABLE64).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("excludedTables=");
	excludedTables.toTraceString(_buf);
	return _buf.c_str();
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBY_FIND_TABLE64).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	filter.toXmlString("filter", _buf);
	excludedTables.toXmlString("excludedTables", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("filter"))
			{
				if(!Atf::AtfTempl< Filter >::FromXmlString(_value, filter)) return false;
			}
			else if (_element.equals("excludedTables"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT64, 4 > >::FromXmlString(_value, excludedTables)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	filter.composeMsg(_msg, _ignoreJSON);
	excludedTables.composeMsg(_msg, _ignoreJSON);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	excludedTables.parseMsg(_parser);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("filter", filter);
	_jsonstr.compose("excludedTables", excludedTables);
	return _buf.c_str();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("filter", filter);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("excludedTables", excludedTables);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_TABLE64";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Filter filter; _jparser.validateByNameThrow("filter", filter);
	if(_jparser.parseEnded()) return;
	Atf::AtfVectorBase< UINT64 > excludedTables; _jparser.validateByNameThrow("excludedTables", excludedTables);
	AtfValidator::validateIntMax(_descr, "excludedTables", excludedTables.size(), 1024, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_TABLE64";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	Filter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	int szExcludedTables = Atf::LAtfVector< UINT64, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("excludedTables"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "excludedTables", szExcludedTables, 1024, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_BLITZ
//=================================================================

MLobby::cli::Protocol_MSG_MLOBBY_FIND_BLITZ::Protocol_MSG_MLOBBY_FIND_BLITZ()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_BLITZ::clear()
{
	filter.clear();
	maxItems = 0;
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_BLITZ::equals(const Protocol_MSG_MLOBBY_FIND_BLITZ& _o) const
{
	return filter.equals(_o.filter) &&
		maxItems == _o.maxItems;
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_BLITZ::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBY_FIND_BLITZ != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBY_FIND_BLITZ*)_other));
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_BLITZ::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_BLITZ).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("maxItems=");
	_buf.appendUint(maxItems);
	return _buf.c_str();
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_BLITZ::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_BLITZ::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBY_FIND_BLITZ).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	filter.toXmlString("filter", _buf);
	Atf::XmlElement::encodeAsXmlElement("maxItems", maxItems, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_BLITZ::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("filter"))
			{
				if(!Atf::AtfTempl< Filter >::FromXmlString(_value, filter)) return false;
			}
			else if (_element.equals("maxItems"))
			{
				maxItems = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_BLITZ::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	filter.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(maxItems);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_BLITZ::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	_parser.parseUINT32(maxItems);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_BLITZ::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("filter", filter);
	_jsonstr.compose("maxItems", maxItems);
	return _buf.c_str();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_BLITZ::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("filter", filter);
	_jparser.parseByNameThrow("maxItems", maxItems);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_BLITZ::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_BLITZ";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Filter filter; _jparser.validateByNameThrow("filter", filter);
	UINT32 maxItems; _jparser.validateByNameThrow("maxItems", maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_BLITZ::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_BLITZ";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	Filter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	UINT32 maxItems; _parser.parseUINT32(maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES
//=================================================================

MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES::clear()
{
	filter.clear();
	maxItems = 0;
	excludedFinders.clear();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES::equals(const Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES& _o) const
{
	return filter.equals(_o.filter) &&
		maxItems == _o.maxItems &&
		excludedFinders.equals(_o.excludedFinders);
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES*)_other));
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("maxItems=");
	_buf.appendUint(maxItems);
	_buf.append(',');
	_buf.append("excludedFinders=");
	excludedFinders.toTraceString(_buf);
	return _buf.c_str();
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	filter.toXmlString("filter", _buf);
	Atf::XmlElement::encodeAsXmlElement("maxItems", maxItems, _buf);
	excludedFinders.toXmlString("excludedFinders", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("filter"))
			{
				if(!Atf::AtfTempl< Filter >::FromXmlString(_value, filter)) return false;
			}
			else if (_element.equals("maxItems"))
			{
				maxItems = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("excludedFinders"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, excludedFinders)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	filter.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(maxItems);
	excludedFinders.composeMsg(_msg, _ignoreJSON);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	_parser.parseUINT32(maxItems);
	excludedFinders.parseMsg(_parser);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("filter", filter);
	_jsonstr.compose("maxItems", maxItems);
	_jsonstr.compose("excludedFinders", excludedFinders);
	return _buf.c_str();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("filter", filter);
	_jparser.parseByNameThrow("maxItems", maxItems);
	_jparser.parseByNameThrow("excludedFinders", excludedFinders);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Filter filter; _jparser.validateByNameThrow("filter", filter);
	UINT32 maxItems; _jparser.validateByNameThrow("maxItems", maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT32 > excludedFinders; _jparser.validateByNameThrow("excludedFinders", excludedFinders);
	AtfValidator::validateIntMax(_descr, "excludedFinders", excludedFinders.size(), 1024, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	Filter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	UINT32 maxItems; _parser.parseUINT32(maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
	int szExcludedFinders = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("excludedFinders"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "excludedFinders", szExcludedFinders, 1024, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    TableSelectionFilter
//=================================================================

MLobby::cli::TableSelectionFilter::TableSelectionFilter()
{
	clear();
}

void MLobby::cli::TableSelectionFilter::clear()
{
	version = 0;
	country.clear();
	siteId = 0;
	brandId = 0;
	gameMask = 0;
	buyInMask = 0;
	minBuyIn = 0;
	maxBuyIn = 0;
	multiplierPM = 0;
	currencyMask = 0;
	sortOrder = 0;
	maxPlayerMask = 0;
	clientSortingSeed = 0;
	standardFormatOnly = false;
}

bool MLobby::cli::TableSelectionFilter::equals(const TableSelectionFilter& _o) const
{
	return version == _o.version &&
		Atf::atfPStringEquals(country, _o.country) &&
		siteId == _o.siteId &&
		brandId == _o.brandId &&
		gameMask == _o.gameMask &&
		buyInMask == _o.buyInMask &&
		minBuyIn == _o.minBuyIn &&
		maxBuyIn == _o.maxBuyIn &&
		multiplierPM == _o.multiplierPM &&
		currencyMask == _o.currencyMask &&
		sortOrder == _o.sortOrder &&
		maxPlayerMask == _o.maxPlayerMask &&
		clientSortingSeed == _o.clientSortingSeed &&
		standardFormatOnly == _o.standardFormatOnly;
}

const char *MLobby::cli::TableSelectionFilter::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("version=");
	_buf.appendUint(version);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("brandId=");
	_buf.appendUint(brandId);
	_buf.append(',');
	_buf.append("gameMask=");
	_buf.appendUint64(gameMask);
	_buf.append(',');
	_buf.append("buyInMask=");
	_buf.appendUint(buyInMask);
	_buf.append(',');
	_buf.append("minBuyIn=");
	_buf.appendUint64(minBuyIn);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendUint64(maxBuyIn);
	_buf.append(',');
	_buf.append("multiplierPM=");
	_buf.appendUint(multiplierPM);
	_buf.append(',');
	_buf.append("currencyMask=");
	_buf.appendUint(currencyMask);
	_buf.append(',');
	_buf.append("sortOrder=");
	_buf.appendUint(sortOrder);
	_buf.append(',');
	_buf.append("maxPlayerMask=");
	_buf.appendUint(maxPlayerMask);
	_buf.append(',');
	_buf.append("clientSortingSeed=");
	_buf.appendUint(clientSortingSeed);
	_buf.append(',');
	_buf.append("standardFormatOnly=");
	_buf.appendUint(standardFormatOnly);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobby::cli::TableSelectionFilter::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("version", version, _buf);
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::encodeAsXmlElement("siteId", siteId, _buf);
	Atf::XmlElement::encodeAsXmlElement("brandId", brandId, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameMask", gameMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyInMask", buyInMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("minBuyIn", minBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxBuyIn", maxBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("multiplierPM", multiplierPM, _buf);
	Atf::XmlElement::encodeAsXmlElement("currencyMask", currencyMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("sortOrder", sortOrder, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPlayerMask", maxPlayerMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientSortingSeed", clientSortingSeed, _buf);
	Atf::XmlElement::encodeAsXmlElement("standardFormatOnly", standardFormatOnly, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobby::cli::TableSelectionFilter::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("version"))
		{
			version = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("country"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
		}
		else if (_element.equals("siteId"))
		{
			siteId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("brandId"))
		{
			brandId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("gameMask"))
		{
			gameMask = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("buyInMask"))
		{
			buyInMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minBuyIn"))
		{
			minBuyIn = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxBuyIn"))
		{
			maxBuyIn = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("multiplierPM"))
		{
			multiplierPM = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currencyMask"))
		{
			currencyMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("sortOrder"))
		{
			sortOrder = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxPlayerMask"))
		{
			maxPlayerMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("clientSortingSeed"))
		{
			clientSortingSeed = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("standardFormatOnly"))
		{
			standardFormatOnly = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobby::cli::TableSelectionFilter::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(TableSelectionFilter())) // not empty
	{
		_body.composeBYTE(version);
		_body.composeString(country);
		_body.composeUINT32(siteId);
		_body.composeUINT32(brandId);
		_body.composeUINT64(gameMask);
		_body.composeUINT32(buyInMask);
		_body.composeUINT64(minBuyIn);
		_body.composeUINT64(maxBuyIn);
		_body.composeUINT32(multiplierPM);
		_body.composeUINT32(currencyMask);
		_body.composeUINT32(sortOrder);
		_body.composeUINT32(maxPlayerMask);
		_body.composeUINT32(clientSortingSeed);
		_body.composeBOOL(standardFormatOnly);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::TableSelectionFilter::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(version);
	_parser0.parseStringP(country);
	_parser0.parseUINT32(siteId);
	_parser0.parseUINT32(brandId);
	_parser0.parseUINT64(gameMask);
	_parser0.parseUINT32(buyInMask);
	_parser0.parseUINT64(minBuyIn);
	_parser0.parseUINT64(maxBuyIn);
	_parser0.parseUINT32(multiplierPM);
	_parser0.parseUINT32(currencyMask);
	_parser0.parseUINT32(sortOrder);
	_parser0.parseUINT32(maxPlayerMask);
	_parser0.parseUINT32(clientSortingSeed);
	_parser0.parseBOOL(standardFormatOnly);
}

const char *MLobby::cli::TableSelectionFilter::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("version", version);
	_jsonstr.compose("country", country);
	_jsonstr.compose("siteId", siteId);
	_jsonstr.compose("brandId", brandId);
	_jsonstr.compose("gameMask", gameMask);
	_jsonstr.compose("buyInMask", buyInMask);
	_jsonstr.compose("minBuyIn", minBuyIn);
	_jsonstr.compose("maxBuyIn", maxBuyIn);
	_jsonstr.compose("multiplierPM", multiplierPM);
	_jsonstr.compose("currencyMask", currencyMask);
	_jsonstr.compose("sortOrder", sortOrder);
	_jsonstr.compose("maxPlayerMask", maxPlayerMask);
	_jsonstr.compose("clientSortingSeed", clientSortingSeed);
	_jsonstr.compose("standardFormatOnly", standardFormatOnly);
	return _buf.c_str();
}

void MLobby::cli::TableSelectionFilter::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("version", version);
	_jparser.parseByNameThrow("country", country);
	_jparser.parseByNameThrow("siteId", siteId);
	_jparser.parseByNameThrow("brandId", brandId);
	_jparser.parseByNameThrow("gameMask", gameMask);
	_jparser.parseByNameThrow("buyInMask", buyInMask);
	_jparser.parseByNameThrow("minBuyIn", minBuyIn);
	_jparser.parseByNameThrow("maxBuyIn", maxBuyIn);
	_jparser.parseByNameThrow("multiplierPM", multiplierPM);
	_jparser.parseByNameThrow("currencyMask", currencyMask);
	_jparser.parseByNameThrow("sortOrder", sortOrder);
	_jparser.parseByNameThrow("maxPlayerMask", maxPlayerMask);
	_jparser.parseByNameThrow("clientSortingSeed", clientSortingSeed);
	_jparser.parseByNameThrow("standardFormatOnly", standardFormatOnly);
}

/* static */ void MLobby::cli::TableSelectionFilter::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE version; _jparser.validateByNameThrow("version", version);
	AtfValidator::validateInt(_descr, "version", version, _checker, __FILE__, __LINE__);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateInt(_descr, "country", country.length(), _checker, __FILE__, __LINE__);
	UINT32 siteId; _jparser.validateByNameThrow("siteId", siteId);
	AtfValidator::validateIntRange(_descr, "siteId", siteId, PokerStars_SiteUnknown, (2*PokerStars_Last-1), _checker, __FILE__, __LINE__);
	UINT32 brandId; _jparser.validateByNameThrow("brandId", brandId);
	AtfValidator::validateIntRange(_descr, "brandId", brandId, BrandType_None, (2*BrandType_Last-1), _checker, __FILE__, __LINE__);
	UINT64 gameMask; _jparser.validateByNameThrow("gameMask", gameMask);
	AtfValidator::validateUintMax(_descr, "gameMask", gameMask, (2*(UINT64)MobileGameTypes::MobileGame_Last-1), _checker, __FILE__, __LINE__);
	UINT32 buyInMask; _jparser.validateByNameThrow("buyInMask", buyInMask);
	AtfValidator::validateIntMax(_descr, "buyInMask", buyInMask, (2*MobileBuyIn_Last-1), _checker, __FILE__, __LINE__);
	UINT64 minBuyIn; _jparser.validateByNameThrow("minBuyIn", minBuyIn);
	AtfValidator::validateUintMax(_descr, "minBuyIn", minBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	UINT64 maxBuyIn; _jparser.validateByNameThrow("maxBuyIn", maxBuyIn);
	AtfValidator::validateUintMax(_descr, "maxBuyIn", maxBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 multiplierPM; _jparser.validateByNameThrow("multiplierPM", multiplierPM);
	AtfValidator::validateIntMax(_descr, "multiplierPM", multiplierPM, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 currencyMask; _jparser.validateByNameThrow("currencyMask", currencyMask);
	AtfValidator::validateIntMax(_descr, "currencyMask", currencyMask, (2*MobileCurrency_Last-1), _checker, __FILE__, __LINE__);
	UINT32 sortOrder; _jparser.validateByNameThrow("sortOrder", sortOrder);
	AtfValidator::validateIntRange(_descr, "sortOrder", sortOrder, MobileSortOrder_None, MobileSortOrder_Last, _checker, __FILE__, __LINE__);
	UINT32 maxPlayerMask; _jparser.validateByNameThrow("maxPlayerMask", maxPlayerMask);
	AtfValidator::validateIntMax(_descr, "maxPlayerMask", maxPlayerMask, (2*MobileMaxPlayer_Last-1), _checker, __FILE__, __LINE__);
	UINT32 clientSortingSeed; _jparser.validateByNameThrow("clientSortingSeed", clientSortingSeed);
	AtfValidator::validateInt(_descr, "clientSortingSeed", clientSortingSeed, _checker, __FILE__, __LINE__);
	bool standardFormatOnly; _jparser.validateByNameThrow("standardFormatOnly", standardFormatOnly);
	AtfValidator::validateInt(_descr, "standardFormatOnly", standardFormatOnly, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobby::cli::TableSelectionFilter::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	BYTE version; _parser0.parseBYTE(version);
	AtfValidator::validateInt(_descr, "version", version, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	UINT32 siteId; _parser0.parseUINT32(siteId);
	AtfValidator::validateIntRange(_descr, "siteId", siteId, PokerStars_SiteUnknown, (2*PokerStars_Last-1), _checker, __FILE__, __LINE__);
	UINT32 brandId; _parser0.parseUINT32(brandId);
	AtfValidator::validateIntRange(_descr, "brandId", brandId, BrandType_None, (2*BrandType_Last-1), _checker, __FILE__, __LINE__);
	UINT64 gameMask; _parser0.parseUINT64(gameMask);
	AtfValidator::validateUintMax(_descr, "gameMask", gameMask, (2*(UINT64)MobileGameTypes::MobileGame_Last-1), _checker, __FILE__, __LINE__);
	UINT32 buyInMask; _parser0.parseUINT32(buyInMask);
	AtfValidator::validateIntMax(_descr, "buyInMask", buyInMask, (2*MobileBuyIn_Last-1), _checker, __FILE__, __LINE__);
	UINT64 minBuyIn; _parser0.parseUINT64(minBuyIn);
	AtfValidator::validateUintMax(_descr, "minBuyIn", minBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	UINT64 maxBuyIn; _parser0.parseUINT64(maxBuyIn);
	AtfValidator::validateUintMax(_descr, "maxBuyIn", maxBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 multiplierPM; _parser0.parseUINT32(multiplierPM);
	AtfValidator::validateIntMax(_descr, "multiplierPM", multiplierPM, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 currencyMask; _parser0.parseUINT32(currencyMask);
	AtfValidator::validateIntMax(_descr, "currencyMask", currencyMask, (2*MobileCurrency_Last-1), _checker, __FILE__, __LINE__);
	UINT32 sortOrder; _parser0.parseUINT32(sortOrder);
	AtfValidator::validateIntRange(_descr, "sortOrder", sortOrder, MobileSortOrder_None, MobileSortOrder_Last, _checker, __FILE__, __LINE__);
	UINT32 maxPlayerMask; _parser0.parseUINT32(maxPlayerMask);
	AtfValidator::validateIntMax(_descr, "maxPlayerMask", maxPlayerMask, (2*MobileMaxPlayer_Last-1), _checker, __FILE__, __LINE__);
	UINT32 clientSortingSeed; _parser0.parseUINT32(clientSortingSeed);
	AtfValidator::validateInt(_descr, "clientSortingSeed", clientSortingSeed, _checker, __FILE__, __LINE__);
	bool standardFormatOnly; _parser0.parseBOOL(standardFormatOnly);
	AtfValidator::validateInt(_descr, "standardFormatOnly", standardFormatOnly, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TournSelectionFilter
//=================================================================

MLobby::cli::TournSelectionFilter::TournSelectionFilter()
{
	clear();
}

void MLobby::cli::TournSelectionFilter::clear()
{
	version = 0;
	country.clear();
	siteId = 0;
	brandId = 0;
	gameMask = 0;
	buyInMask = 0;
	minBuyIn = 0;
	maxBuyIn = 0;
	multiplierPM = 0;
	currencyMask = 0;
	sortOrder = 0;
	locale = 0;
	speedMask = 0;
	gameVariantMask = 0;
	startingWithin = 0;
	registeringOnly = false;
	tournName.clear();
	tableSize = 0;
	visibilityStrings.clear();
	tournLobbies.clear();
}

bool MLobby::cli::TournSelectionFilter::equals(const TournSelectionFilter& _o) const
{
	return version == _o.version &&
		Atf::atfPStringEquals(country, _o.country) &&
		siteId == _o.siteId &&
		brandId == _o.brandId &&
		gameMask == _o.gameMask &&
		buyInMask == _o.buyInMask &&
		minBuyIn == _o.minBuyIn &&
		maxBuyIn == _o.maxBuyIn &&
		multiplierPM == _o.multiplierPM &&
		currencyMask == _o.currencyMask &&
		sortOrder == _o.sortOrder &&
		locale == _o.locale &&
		speedMask == _o.speedMask &&
		gameVariantMask == _o.gameVariantMask &&
		startingWithin == _o.startingWithin &&
		registeringOnly == _o.registeringOnly &&
		Atf::atfPStringEquals(tournName, _o.tournName) &&
		tableSize == _o.tableSize &&
		visibilityStrings.equals(_o.visibilityStrings) &&
		tournLobbies.equals(_o.tournLobbies);
}

const char *MLobby::cli::TournSelectionFilter::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("version=");
	_buf.appendUint(version);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("brandId=");
	_buf.appendUint(brandId);
	_buf.append(',');
	_buf.append("gameMask=");
	_buf.appendUint64(gameMask);
	_buf.append(',');
	_buf.append("buyInMask=");
	_buf.appendUint(buyInMask);
	_buf.append(',');
	_buf.append("minBuyIn=");
	_buf.appendUint64(minBuyIn);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendUint64(maxBuyIn);
	_buf.append(',');
	_buf.append("multiplierPM=");
	_buf.appendUint(multiplierPM);
	_buf.append(',');
	_buf.append("currencyMask=");
	_buf.appendUint(currencyMask);
	_buf.append(',');
	_buf.append("sortOrder=");
	_buf.appendUint(sortOrder);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("speedMask=");
	_buf.appendUint(speedMask);
	_buf.append(',');
	_buf.append("gameVariantMask=");
	_buf.appendUint(gameVariantMask);
	_buf.append(',');
	_buf.append("startingWithin=");
	_buf.appendUint(startingWithin);
	_buf.append(',');
	_buf.append("registeringOnly=");
	_buf.appendUint(registeringOnly);
	_buf.append(',');
	_buf.append("tournName=");
	_buf.append(tournName);
	_buf.append(',');
	_buf.append("tableSize=");
	_buf.appendUint(tableSize);
	_buf.append(',');
	_buf.append("visibilityStrings=");
	visibilityStrings.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tournLobbies=");
	tournLobbies.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobby::cli::TournSelectionFilter::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("version", version, _buf);
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::encodeAsXmlElement("siteId", siteId, _buf);
	Atf::XmlElement::encodeAsXmlElement("brandId", brandId, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameMask", gameMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyInMask", buyInMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("minBuyIn", minBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxBuyIn", maxBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("multiplierPM", multiplierPM, _buf);
	Atf::XmlElement::encodeAsXmlElement("currencyMask", currencyMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("sortOrder", sortOrder, _buf);
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	Atf::XmlElement::encodeAsXmlElement("speedMask", speedMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameVariantMask", gameVariantMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("startingWithin", startingWithin, _buf);
	Atf::XmlElement::encodeAsXmlElement("registeringOnly", registeringOnly, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournName", tournName, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableSize", tableSize, _buf);
	visibilityStrings.toXmlString("visibilityStrings", _buf);
	tournLobbies.toXmlString("tournLobbies", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobby::cli::TournSelectionFilter::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("version"))
		{
			version = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("country"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
		}
		else if (_element.equals("siteId"))
		{
			siteId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("brandId"))
		{
			brandId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("gameMask"))
		{
			gameMask = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("buyInMask"))
		{
			buyInMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minBuyIn"))
		{
			minBuyIn = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxBuyIn"))
		{
			maxBuyIn = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("multiplierPM"))
		{
			multiplierPM = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currencyMask"))
		{
			currencyMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("sortOrder"))
		{
			sortOrder = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("locale"))
		{
			locale = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("speedMask"))
		{
			speedMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("gameVariantMask"))
		{
			gameVariantMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("startingWithin"))
		{
			startingWithin = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("registeringOnly"))
		{
			registeringOnly = (*_value.ptr() == '1');
		}
		else if (_element.equals("tournName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, tournName)) return false;
		}
		else if (_element.equals("tableSize"))
		{
			tableSize = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("visibilityStrings"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PString , 4 > >::FromXmlString(_value, visibilityStrings)) return false;
		}
		else if (_element.equals("tournLobbies"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PString, 4 > >::FromXmlString(_value, tournLobbies)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobby::cli::TournSelectionFilter::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(TournSelectionFilter())) // not empty
	{
		_body.composeBYTE(version);
		_body.composeString(country);
		_body.composeUINT32(siteId);
		_body.composeUINT32(brandId);
		_body.composeUINT64(gameMask);
		_body.composeUINT32(buyInMask);
		_body.composeUINT64(minBuyIn);
		_body.composeUINT64(maxBuyIn);
		_body.composeUINT32(multiplierPM);
		_body.composeUINT32(currencyMask);
		_body.composeUINT32(sortOrder);
		_body.composeUINT32(locale);
		_body.composeUINT32(speedMask);
		_body.composeUINT32(gameVariantMask);
		_body.composeUINT32(startingWithin);
		_body.composeBOOL(registeringOnly);
		_body.composeString(tournName);
		_body.composeUINT32(tableSize);
		visibilityStrings.composeMsg(_body, _ignoreJSON);
		tournLobbies.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::TournSelectionFilter::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(version);
	_parser0.parseStringP(country);
	_parser0.parseUINT32(siteId);
	_parser0.parseUINT32(brandId);
	_parser0.parseUINT64(gameMask);
	_parser0.parseUINT32(buyInMask);
	_parser0.parseUINT64(minBuyIn);
	_parser0.parseUINT64(maxBuyIn);
	_parser0.parseUINT32(multiplierPM);
	_parser0.parseUINT32(currencyMask);
	_parser0.parseUINT32(sortOrder);
	_parser0.parseUINT32(locale);
	_parser0.parseUINT32(speedMask);
	_parser0.parseUINT32(gameVariantMask);
	_parser0.parseUINT32(startingWithin);
	_parser0.parseBOOL(registeringOnly);
	_parser0.parseStringP(tournName);
	_parser0.parseUINT32(tableSize);
	if(_parser0.parseEnded()) return;
	visibilityStrings.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	tournLobbies.parseMsg(_parser0);
}

const char *MLobby::cli::TournSelectionFilter::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("version", version);
	_jsonstr.compose("country", country);
	_jsonstr.compose("siteId", siteId);
	_jsonstr.compose("brandId", brandId);
	_jsonstr.compose("gameMask", gameMask);
	_jsonstr.compose("buyInMask", buyInMask);
	_jsonstr.compose("minBuyIn", minBuyIn);
	_jsonstr.compose("maxBuyIn", maxBuyIn);
	_jsonstr.compose("multiplierPM", multiplierPM);
	_jsonstr.compose("currencyMask", currencyMask);
	_jsonstr.compose("sortOrder", sortOrder);
	_jsonstr.compose("locale", locale);
	_jsonstr.compose("speedMask", speedMask);
	_jsonstr.compose("gameVariantMask", gameVariantMask);
	_jsonstr.compose("startingWithin", startingWithin);
	_jsonstr.compose("registeringOnly", registeringOnly);
	_jsonstr.compose("tournName", tournName);
	_jsonstr.compose("tableSize", tableSize);
	_jsonstr.compose("visibilityStrings", visibilityStrings);
	_jsonstr.compose("tournLobbies", tournLobbies);
	return _buf.c_str();
}

void MLobby::cli::TournSelectionFilter::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("version", version);
	_jparser.parseByNameThrow("country", country);
	_jparser.parseByNameThrow("siteId", siteId);
	_jparser.parseByNameThrow("brandId", brandId);
	_jparser.parseByNameThrow("gameMask", gameMask);
	_jparser.parseByNameThrow("buyInMask", buyInMask);
	_jparser.parseByNameThrow("minBuyIn", minBuyIn);
	_jparser.parseByNameThrow("maxBuyIn", maxBuyIn);
	_jparser.parseByNameThrow("multiplierPM", multiplierPM);
	_jparser.parseByNameThrow("currencyMask", currencyMask);
	_jparser.parseByNameThrow("sortOrder", sortOrder);
	_jparser.parseByNameThrow("locale", locale);
	_jparser.parseByNameThrow("speedMask", speedMask);
	_jparser.parseByNameThrow("gameVariantMask", gameVariantMask);
	_jparser.parseByNameThrow("startingWithin", startingWithin);
	_jparser.parseByNameThrow("registeringOnly", registeringOnly);
	_jparser.parseByNameThrow("tournName", tournName);
	_jparser.parseByNameThrow("tableSize", tableSize);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("visibilityStrings", visibilityStrings);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tournLobbies", tournLobbies);
}

/* static */ void MLobby::cli::TournSelectionFilter::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE version; _jparser.validateByNameThrow("version", version);
	AtfValidator::validateInt(_descr, "version", version, _checker, __FILE__, __LINE__);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateIntMax(_descr, "country", country.length(), 3, _checker, __FILE__, __LINE__);
	UINT32 siteId; _jparser.validateByNameThrow("siteId", siteId);
	AtfValidator::validateIntRange(_descr, "siteId", siteId, PokerStars_SiteUnknown, (2*PokerStars_Last-1), _checker, __FILE__, __LINE__);
	UINT32 brandId; _jparser.validateByNameThrow("brandId", brandId);
	AtfValidator::validateIntRange(_descr, "brandId", brandId, BrandType_None, (2*BrandType_Last-1), _checker, __FILE__, __LINE__);
	UINT64 gameMask; _jparser.validateByNameThrow("gameMask", gameMask);
	AtfValidator::validateUintMax(_descr, "gameMask", gameMask, (2*(UINT64)MobileGameTypes::MobileGame_Last-1), _checker, __FILE__, __LINE__);
	UINT32 buyInMask; _jparser.validateByNameThrow("buyInMask", buyInMask);
	AtfValidator::validateIntMax(_descr, "buyInMask", buyInMask, (2*MobileBuyIn_Last-1), _checker, __FILE__, __LINE__);
	UINT64 minBuyIn; _jparser.validateByNameThrow("minBuyIn", minBuyIn);
	AtfValidator::validateUintMax(_descr, "minBuyIn", minBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	UINT64 maxBuyIn; _jparser.validateByNameThrow("maxBuyIn", maxBuyIn);
	AtfValidator::validateUintMax(_descr, "maxBuyIn", maxBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 multiplierPM; _jparser.validateByNameThrow("multiplierPM", multiplierPM);
	AtfValidator::validateIntMax(_descr, "multiplierPM", multiplierPM, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 currencyMask; _jparser.validateByNameThrow("currencyMask", currencyMask);
	AtfValidator::validateIntMax(_descr, "currencyMask", currencyMask, (2*MobileCurrency_Last-1), _checker, __FILE__, __LINE__);
	UINT32 sortOrder; _jparser.validateByNameThrow("sortOrder", sortOrder);
	AtfValidator::validateIntRange(_descr, "sortOrder", sortOrder, MobileSortOrder_None, MobileSortOrder_Last, _checker, __FILE__, __LINE__);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT32 speedMask; _jparser.validateByNameThrow("speedMask", speedMask);
	AtfValidator::validateIntMax(_descr, "speedMask", speedMask, (2*MobileTournSpeed_Last-1), _checker, __FILE__, __LINE__);
	UINT32 gameVariantMask; _jparser.validateByNameThrow("gameVariantMask", gameVariantMask);
	AtfValidator::validateIntMax(_descr, "gameVariantMask", gameVariantMask, (2*MobileGameVariant_Last-1), _checker, __FILE__, __LINE__);
	UINT32 startingWithin; _jparser.validateByNameThrow("startingWithin", startingWithin);
	AtfValidator::validateIntMax(_descr, "startingWithin", startingWithin, 1440, _checker, __FILE__, __LINE__);
	bool registeringOnly; _jparser.validateByNameThrow("registeringOnly", registeringOnly);
	AtfValidator::validateInt(_descr, "registeringOnly", registeringOnly, _checker, __FILE__, __LINE__);
	PString tournName; _jparser.validateByNameThrow("tournName", tournName);
	AtfValidator::validateIntMax(_descr, "tournName", tournName.length(), 1000, _checker, __FILE__, __LINE__);
	UINT32 tableSize; _jparser.validateByNameThrow("tableSize", tableSize);
	AtfValidator::validateIntRange(_descr, "tableSize", tableSize, MobileTournTableSize_None, (2*MobileTournTableSize_Last-1), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	Atf::AtfVectorBase< PString > visibilityStrings; _jparser.validateByNameThrow("visibilityStrings", visibilityStrings);
	AtfValidator::validateIntMax(_descr, "visibilityStrings", visibilityStrings.size(), 100, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	Atf::AtfVectorBase< PString > tournLobbies; _jparser.validateByNameThrow("tournLobbies", tournLobbies);
	AtfValidator::validateIntMax(_descr, "tournLobbies", tournLobbies.size(), 1024, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobby::cli::TournSelectionFilter::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	BYTE version; _parser0.parseBYTE(version);
	AtfValidator::validateInt(_descr, "version", version, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, 3, _checker, __FILE__, __LINE__);
	UINT32 siteId; _parser0.parseUINT32(siteId);
	AtfValidator::validateIntRange(_descr, "siteId", siteId, PokerStars_SiteUnknown, (2*PokerStars_Last-1), _checker, __FILE__, __LINE__);
	UINT32 brandId; _parser0.parseUINT32(brandId);
	AtfValidator::validateIntRange(_descr, "brandId", brandId, BrandType_None, (2*BrandType_Last-1), _checker, __FILE__, __LINE__);
	UINT64 gameMask; _parser0.parseUINT64(gameMask);
	AtfValidator::validateUintMax(_descr, "gameMask", gameMask, (2*(UINT64)MobileGameTypes::MobileGame_Last-1), _checker, __FILE__, __LINE__);
	UINT32 buyInMask; _parser0.parseUINT32(buyInMask);
	AtfValidator::validateIntMax(_descr, "buyInMask", buyInMask, (2*MobileBuyIn_Last-1), _checker, __FILE__, __LINE__);
	UINT64 minBuyIn; _parser0.parseUINT64(minBuyIn);
	AtfValidator::validateUintMax(_descr, "minBuyIn", minBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	UINT64 maxBuyIn; _parser0.parseUINT64(maxBuyIn);
	AtfValidator::validateUintMax(_descr, "maxBuyIn", maxBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 multiplierPM; _parser0.parseUINT32(multiplierPM);
	AtfValidator::validateIntMax(_descr, "multiplierPM", multiplierPM, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 currencyMask; _parser0.parseUINT32(currencyMask);
	AtfValidator::validateIntMax(_descr, "currencyMask", currencyMask, (2*MobileCurrency_Last-1), _checker, __FILE__, __LINE__);
	UINT32 sortOrder; _parser0.parseUINT32(sortOrder);
	AtfValidator::validateIntRange(_descr, "sortOrder", sortOrder, MobileSortOrder_None, MobileSortOrder_Last, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser0.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT32 speedMask; _parser0.parseUINT32(speedMask);
	AtfValidator::validateIntMax(_descr, "speedMask", speedMask, (2*MobileTournSpeed_Last-1), _checker, __FILE__, __LINE__);
	UINT32 gameVariantMask; _parser0.parseUINT32(gameVariantMask);
	AtfValidator::validateIntMax(_descr, "gameVariantMask", gameVariantMask, (2*MobileGameVariant_Last-1), _checker, __FILE__, __LINE__);
	UINT32 startingWithin; _parser0.parseUINT32(startingWithin);
	AtfValidator::validateIntMax(_descr, "startingWithin", startingWithin, 1440, _checker, __FILE__, __LINE__);
	bool registeringOnly; _parser0.parseBOOL(registeringOnly);
	AtfValidator::validateInt(_descr, "registeringOnly", registeringOnly, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "tournName"); size_t szTournName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "tournName", szTournName, 1000, _checker, __FILE__, __LINE__);
	UINT32 tableSize; _parser0.parseUINT32(tableSize);
	AtfValidator::validateIntRange(_descr, "tableSize", tableSize, MobileTournTableSize_None, (2*MobileTournTableSize_Last-1), _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PString _descbuf;
	int szVisibilityStrings = Atf::LAtfVector< PString , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("visibilityStrings"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "visibilityStrings", szVisibilityStrings, 100, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	int szTournLobbies = Atf::LAtfVector< PString, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tournLobbies"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "tournLobbies", szTournLobbies, 1024, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    FinderAndBlitzSelectionFilter
//=================================================================

MLobby::cli::FinderAndBlitzSelectionFilter::FinderAndBlitzSelectionFilter()
{
	clear();
}

void MLobby::cli::FinderAndBlitzSelectionFilter::clear()
{
	version = 0;
	country.clear();
	siteId = 0;
	brandId = 0;
	gameMask = 0;
	buyInMask = 0;
	minBuyIn = 0;
	maxBuyIn = 0;
	multiplierPM = 0;
	currencyMask = 0;
	order = 0;
	maxPlayerMask = 0;
	clientSortingSeed = 0;
	standardFormatOnly = false;
	seatFindersAndBlitzes = 0;
}

bool MLobby::cli::FinderAndBlitzSelectionFilter::equals(const FinderAndBlitzSelectionFilter& _o) const
{
	return version == _o.version &&
		Atf::atfPStringEquals(country, _o.country) &&
		siteId == _o.siteId &&
		brandId == _o.brandId &&
		gameMask == _o.gameMask &&
		buyInMask == _o.buyInMask &&
		minBuyIn == _o.minBuyIn &&
		maxBuyIn == _o.maxBuyIn &&
		multiplierPM == _o.multiplierPM &&
		currencyMask == _o.currencyMask &&
		order == _o.order &&
		maxPlayerMask == _o.maxPlayerMask &&
		clientSortingSeed == _o.clientSortingSeed &&
		standardFormatOnly == _o.standardFormatOnly &&
		seatFindersAndBlitzes == _o.seatFindersAndBlitzes;
}

const char *MLobby::cli::FinderAndBlitzSelectionFilter::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("version=");
	_buf.appendUint(version);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("brandId=");
	_buf.appendUint(brandId);
	_buf.append(',');
	_buf.append("gameMask=");
	_buf.appendUint64(gameMask);
	_buf.append(',');
	_buf.append("buyInMask=");
	_buf.appendUint(buyInMask);
	_buf.append(',');
	_buf.append("minBuyIn=");
	_buf.appendUint64(minBuyIn);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendUint64(maxBuyIn);
	_buf.append(',');
	_buf.append("multiplierPM=");
	_buf.appendUint(multiplierPM);
	_buf.append(',');
	_buf.append("currencyMask=");
	_buf.appendUint(currencyMask);
	_buf.append(',');
	_buf.append("order=");
	_buf.appendUint(order);
	_buf.append(',');
	_buf.append("maxPlayerMask=");
	_buf.appendUint(maxPlayerMask);
	_buf.append(',');
	_buf.append("clientSortingSeed=");
	_buf.appendUint(clientSortingSeed);
	_buf.append(',');
	_buf.append("standardFormatOnly=");
	_buf.appendUint(standardFormatOnly);
	_buf.append(',');
	_buf.append("seatFindersAndBlitzes=");
	_buf.appendInt(seatFindersAndBlitzes);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobby::cli::FinderAndBlitzSelectionFilter::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("version", version, _buf);
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::encodeAsXmlElement("siteId", siteId, _buf);
	Atf::XmlElement::encodeAsXmlElement("brandId", brandId, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameMask", gameMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyInMask", buyInMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("minBuyIn", minBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxBuyIn", maxBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("multiplierPM", multiplierPM, _buf);
	Atf::XmlElement::encodeAsXmlElement("currencyMask", currencyMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("order", order, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPlayerMask", maxPlayerMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientSortingSeed", clientSortingSeed, _buf);
	Atf::XmlElement::encodeAsXmlElement("standardFormatOnly", standardFormatOnly, _buf);
	Atf::XmlElement::encodeAsXmlElement("seatFindersAndBlitzes", seatFindersAndBlitzes, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobby::cli::FinderAndBlitzSelectionFilter::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("version"))
		{
			version = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("country"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
		}
		else if (_element.equals("siteId"))
		{
			siteId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("brandId"))
		{
			brandId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("gameMask"))
		{
			gameMask = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("buyInMask"))
		{
			buyInMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minBuyIn"))
		{
			minBuyIn = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxBuyIn"))
		{
			maxBuyIn = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("multiplierPM"))
		{
			multiplierPM = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currencyMask"))
		{
			currencyMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("order"))
		{
			order = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxPlayerMask"))
		{
			maxPlayerMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("clientSortingSeed"))
		{
			clientSortingSeed = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("standardFormatOnly"))
		{
			standardFormatOnly = (*_value.ptr() == '1');
		}
		else if (_element.equals("seatFindersAndBlitzes"))
		{
			seatFindersAndBlitzes = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobby::cli::FinderAndBlitzSelectionFilter::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(FinderAndBlitzSelectionFilter())) // not empty
	{
		_body.composeBYTE(version);
		_body.composeString(country);
		_body.composeUINT32(siteId);
		_body.composeUINT32(brandId);
		_body.composeUINT64(gameMask);
		_body.composeUINT32(buyInMask);
		_body.composeUINT64(minBuyIn);
		_body.composeUINT64(maxBuyIn);
		_body.composeUINT32(multiplierPM);
		_body.composeUINT32(currencyMask);
		_body.composeUINT32(order);
		_body.composeUINT32(maxPlayerMask);
		_body.composeUINT32(clientSortingSeed);
		_body.composeBOOL(standardFormatOnly);
		_body.composeINT8(seatFindersAndBlitzes);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::FinderAndBlitzSelectionFilter::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(version);
	_parser0.parseStringP(country);
	_parser0.parseUINT32(siteId);
	_parser0.parseUINT32(brandId);
	_parser0.parseUINT64(gameMask);
	_parser0.parseUINT32(buyInMask);
	_parser0.parseUINT64(minBuyIn);
	_parser0.parseUINT64(maxBuyIn);
	_parser0.parseUINT32(multiplierPM);
	_parser0.parseUINT32(currencyMask);
	_parser0.parseUINT32(order);
	_parser0.parseUINT32(maxPlayerMask);
	_parser0.parseUINT32(clientSortingSeed);
	_parser0.parseBOOL(standardFormatOnly);
	_parser0.parseINT8(seatFindersAndBlitzes);
}

const char *MLobby::cli::FinderAndBlitzSelectionFilter::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("version", version);
	_jsonstr.compose("country", country);
	_jsonstr.compose("siteId", siteId);
	_jsonstr.compose("brandId", brandId);
	_jsonstr.compose("gameMask", gameMask);
	_jsonstr.compose("buyInMask", buyInMask);
	_jsonstr.compose("minBuyIn", minBuyIn);
	_jsonstr.compose("maxBuyIn", maxBuyIn);
	_jsonstr.compose("multiplierPM", multiplierPM);
	_jsonstr.compose("currencyMask", currencyMask);
	_jsonstr.compose("order", order);
	_jsonstr.compose("maxPlayerMask", maxPlayerMask);
	_jsonstr.compose("clientSortingSeed", clientSortingSeed);
	_jsonstr.compose("standardFormatOnly", standardFormatOnly);
	_jsonstr.compose("seatFindersAndBlitzes", seatFindersAndBlitzes);
	return _buf.c_str();
}

void MLobby::cli::FinderAndBlitzSelectionFilter::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("version", version);
	_jparser.parseByNameThrow("country", country);
	_jparser.parseByNameThrow("siteId", siteId);
	_jparser.parseByNameThrow("brandId", brandId);
	_jparser.parseByNameThrow("gameMask", gameMask);
	_jparser.parseByNameThrow("buyInMask", buyInMask);
	_jparser.parseByNameThrow("minBuyIn", minBuyIn);
	_jparser.parseByNameThrow("maxBuyIn", maxBuyIn);
	_jparser.parseByNameThrow("multiplierPM", multiplierPM);
	_jparser.parseByNameThrow("currencyMask", currencyMask);
	_jparser.parseByNameThrow("order", order);
	_jparser.parseByNameThrow("maxPlayerMask", maxPlayerMask);
	_jparser.parseByNameThrow("clientSortingSeed", clientSortingSeed);
	_jparser.parseByNameThrow("standardFormatOnly", standardFormatOnly);
	_jparser.parseByNameThrow("seatFindersAndBlitzes", seatFindersAndBlitzes);
}

/* static */ void MLobby::cli::FinderAndBlitzSelectionFilter::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE version; _jparser.validateByNameThrow("version", version);
	AtfValidator::validateInt(_descr, "version", version, _checker, __FILE__, __LINE__);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateIntMax(_descr, "country", country.length(), 3, _checker, __FILE__, __LINE__);
	UINT32 siteId; _jparser.validateByNameThrow("siteId", siteId);
	AtfValidator::validateIntRange(_descr, "siteId", siteId, PokerStars_SiteUnknown, (2*PokerStars_Last-1), _checker, __FILE__, __LINE__);
	UINT32 brandId; _jparser.validateByNameThrow("brandId", brandId);
	AtfValidator::validateIntRange(_descr, "brandId", brandId, BrandType_None, (2*BrandType_Last-1), _checker, __FILE__, __LINE__);
	UINT64 gameMask; _jparser.validateByNameThrow("gameMask", gameMask);
	AtfValidator::validateUintMax(_descr, "gameMask", gameMask, (2*(UINT64)MobileGameTypes::MobileGame_Last-1), _checker, __FILE__, __LINE__);
	UINT32 buyInMask; _jparser.validateByNameThrow("buyInMask", buyInMask);
	AtfValidator::validateIntMax(_descr, "buyInMask", buyInMask, (2*MobileBuyIn_Last-1), _checker, __FILE__, __LINE__);
	UINT64 minBuyIn; _jparser.validateByNameThrow("minBuyIn", minBuyIn);
	AtfValidator::validateUintMax(_descr, "minBuyIn", minBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	UINT64 maxBuyIn; _jparser.validateByNameThrow("maxBuyIn", maxBuyIn);
	AtfValidator::validateUintMax(_descr, "maxBuyIn", maxBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 multiplierPM; _jparser.validateByNameThrow("multiplierPM", multiplierPM);
	AtfValidator::validateIntMax(_descr, "multiplierPM", multiplierPM, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 currencyMask; _jparser.validateByNameThrow("currencyMask", currencyMask);
	AtfValidator::validateIntMax(_descr, "currencyMask", currencyMask, (2*MobileCurrency_Last-1), _checker, __FILE__, __LINE__);
	UINT32 order; _jparser.validateByNameThrow("order", order);
	AtfValidator::validateIntMax(_descr, "order", order, SelectionFilter::TableOrder_Last, _checker, __FILE__, __LINE__);
	UINT32 maxPlayerMask; _jparser.validateByNameThrow("maxPlayerMask", maxPlayerMask);
	AtfValidator::validateIntMax(_descr, "maxPlayerMask", maxPlayerMask, (2*MobileMaxPlayer_Last-1), _checker, __FILE__, __LINE__);
	UINT32 clientSortingSeed; _jparser.validateByNameThrow("clientSortingSeed", clientSortingSeed);
	AtfValidator::validateInt(_descr, "clientSortingSeed", clientSortingSeed, _checker, __FILE__, __LINE__);
	bool standardFormatOnly; _jparser.validateByNameThrow("standardFormatOnly", standardFormatOnly);
	AtfValidator::validateInt(_descr, "standardFormatOnly", standardFormatOnly, _checker, __FILE__, __LINE__);
	INT8 seatFindersAndBlitzes; _jparser.validateByNameThrow("seatFindersAndBlitzes", seatFindersAndBlitzes);
	AtfValidator::validateIntRange(_descr, "seatFindersAndBlitzes", seatFindersAndBlitzes, SelectionFilter::SeatFindersAndBlitzes_Both, SelectionFilter::SeatFindersAndBlitzes_Last, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobby::cli::FinderAndBlitzSelectionFilter::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	BYTE version; _parser0.parseBYTE(version);
	AtfValidator::validateInt(_descr, "version", version, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, 3, _checker, __FILE__, __LINE__);
	UINT32 siteId; _parser0.parseUINT32(siteId);
	AtfValidator::validateIntRange(_descr, "siteId", siteId, PokerStars_SiteUnknown, (2*PokerStars_Last-1), _checker, __FILE__, __LINE__);
	UINT32 brandId; _parser0.parseUINT32(brandId);
	AtfValidator::validateIntRange(_descr, "brandId", brandId, BrandType_None, (2*BrandType_Last-1), _checker, __FILE__, __LINE__);
	UINT64 gameMask; _parser0.parseUINT64(gameMask);
	AtfValidator::validateUintMax(_descr, "gameMask", gameMask, (2*(UINT64)MobileGameTypes::MobileGame_Last-1), _checker, __FILE__, __LINE__);
	UINT32 buyInMask; _parser0.parseUINT32(buyInMask);
	AtfValidator::validateIntMax(_descr, "buyInMask", buyInMask, (2*MobileBuyIn_Last-1), _checker, __FILE__, __LINE__);
	UINT64 minBuyIn; _parser0.parseUINT64(minBuyIn);
	AtfValidator::validateUintMax(_descr, "minBuyIn", minBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	UINT64 maxBuyIn; _parser0.parseUINT64(maxBuyIn);
	AtfValidator::validateUintMax(_descr, "maxBuyIn", maxBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 multiplierPM; _parser0.parseUINT32(multiplierPM);
	AtfValidator::validateIntMax(_descr, "multiplierPM", multiplierPM, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 currencyMask; _parser0.parseUINT32(currencyMask);
	AtfValidator::validateIntMax(_descr, "currencyMask", currencyMask, (2*MobileCurrency_Last-1), _checker, __FILE__, __LINE__);
	UINT32 order; _parser0.parseUINT32(order);
	AtfValidator::validateIntMax(_descr, "order", order, SelectionFilter::TableOrder_Last, _checker, __FILE__, __LINE__);
	UINT32 maxPlayerMask; _parser0.parseUINT32(maxPlayerMask);
	AtfValidator::validateIntMax(_descr, "maxPlayerMask", maxPlayerMask, (2*MobileMaxPlayer_Last-1), _checker, __FILE__, __LINE__);
	UINT32 clientSortingSeed; _parser0.parseUINT32(clientSortingSeed);
	AtfValidator::validateInt(_descr, "clientSortingSeed", clientSortingSeed, _checker, __FILE__, __LINE__);
	bool standardFormatOnly; _parser0.parseBOOL(standardFormatOnly);
	AtfValidator::validateInt(_descr, "standardFormatOnly", standardFormatOnly, _checker, __FILE__, __LINE__);
	INT8 seatFindersAndBlitzes; _parser0.parseINT8(seatFindersAndBlitzes);
	AtfValidator::validateIntRange(_descr, "seatFindersAndBlitzes", seatFindersAndBlitzes, SelectionFilter::SeatFindersAndBlitzes_Both, SelectionFilter::SeatFindersAndBlitzes_Last, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    RingStaticData
//=================================================================

MLobby::cli::RingStaticData::RingStaticData()
{
	clear();
}

void MLobby::cli::RingStaticData::clear()
{
	tableId32 = 0;
	name.clear();
	server.clear();
	serverObject.clear();
	tableFlags = 0;
	isOneOnOne = 0;
	isPlayMoney = 0;
	maxPlayers = 0;
	game = 0;
	isHiLo = 0;
	loBet = 0;
	hiBet = 0;
	structure = 0;
	specialName.clear();
	visibilityMask = 0;
	chatLang = 0;
	currency.clear();
	minChipsLimit = 0;
	maxBuyIn = 0;
	ante = 0;
	countryRestrictionInverted = false;
	restrictedCountries.clear();
	cap = 0;
	icon = 0;
	filter = 0;
	tableInstanceFlags = 0;
	isTableStarter = false;
	tableFlags2 = 0;
	tableTypeId = 0;
	scalePM = 0;
	defaultBuyIn = 0;
	tableId = 0;
	brandMask = 0;
	poolBlockMinHands = 0;
	visibilityCriteria.clear();
	tableStakes.clear();
	variableAntes.clear();
	visibilityMaskEx.clear();
}

bool MLobby::cli::RingStaticData::equals(const RingStaticData& _o) const
{
	return tableId32 == _o.tableId32 &&
		Atf::atfPStringEquals(name, _o.name) &&
		Atf::atfPStringEquals(server, _o.server) &&
		Atf::atfPStringEquals(serverObject, _o.serverObject) &&
		tableFlags == _o.tableFlags &&
		isOneOnOne == _o.isOneOnOne &&
		isPlayMoney == _o.isPlayMoney &&
		maxPlayers == _o.maxPlayers &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		loBet == _o.loBet &&
		hiBet == _o.hiBet &&
		structure == _o.structure &&
		Atf::atfPStringEquals(specialName, _o.specialName) &&
		visibilityMask == _o.visibilityMask &&
		chatLang == _o.chatLang &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		minChipsLimit == _o.minChipsLimit &&
		maxBuyIn == _o.maxBuyIn &&
		ante == _o.ante &&
		countryRestrictionInverted == _o.countryRestrictionInverted &&
		restrictedCountries.equals(_o.restrictedCountries) &&
		cap == _o.cap &&
		icon == _o.icon &&
		filter == _o.filter &&
		tableInstanceFlags == _o.tableInstanceFlags &&
		isTableStarter == _o.isTableStarter &&
		tableFlags2 == _o.tableFlags2 &&
		tableTypeId == _o.tableTypeId &&
		scalePM == _o.scalePM &&
		defaultBuyIn == _o.defaultBuyIn &&
		tableId == _o.tableId &&
		brandMask == _o.brandMask &&
		poolBlockMinHands == _o.poolBlockMinHands &&
		Atf::atfPStringEquals(visibilityCriteria, _o.visibilityCriteria) &&
		tableStakes.equals(_o.tableStakes) &&
		variableAntes.equals(_o.variableAntes) &&
		visibilityMaskEx.equals(_o.visibilityMaskEx);
}

const char *MLobby::cli::RingStaticData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tableId32=");
	_buf.appendUint(tableId32);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("serverObject=");
	_buf.append(serverObject);
	_buf.append(',');
	_buf.append("tableFlags=");
	_buf.appendUint(tableFlags);
	_buf.append(',');
	_buf.append("isOneOnOne=");
	_buf.appendUint(isOneOnOne);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendUint(maxPlayers);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("loBet=");
	_buf.appendUint(loBet);
	_buf.append(',');
	_buf.append("hiBet=");
	_buf.appendUint(hiBet);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("specialName=");
	_buf.append(specialName);
	_buf.append(',');
	_buf.append("visibilityMask=");
	_buf.appendUint(visibilityMask);
	_buf.append(',');
	_buf.append("chatLang=");
	_buf.appendUint(chatLang);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("minChipsLimit=");
	_buf.appendUint(minChipsLimit);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendInt(maxBuyIn);
	_buf.append(',');
	_buf.append("ante=");
	_buf.appendUint(ante);
	_buf.append(',');
	_buf.append("countryRestrictionInverted=");
	_buf.appendUint(countryRestrictionInverted);
	_buf.append(',');
	_buf.append("restrictedCountries=");
	restrictedCountries.toTraceString(_buf);
	_buf.append(',');
	_buf.append("cap=");
	_buf.appendUint(cap);
	_buf.append(',');
	_buf.append("icon=");
	_buf.appendUint(icon);
	_buf.append(',');
	_buf.append("filter=");
	_buf.appendUint(filter);
	_buf.append(',');
	_buf.append("tableInstanceFlags=");
	_buf.appendUint(tableInstanceFlags);
	_buf.append(',');
	_buf.append("isTableStarter=");
	_buf.appendUint(isTableStarter);
	_buf.append(',');
	_buf.append("tableFlags2=");
	_buf.appendUint64(tableFlags2);
	_buf.append(',');
	_buf.append("tableTypeId=");
	_buf.appendUint(tableTypeId);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("defaultBuyIn=");
	_buf.appendUint(defaultBuyIn);
	_buf.append(',');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	_buf.append(',');
	_buf.append("brandMask=");
	_buf.appendUint(brandMask);
	_buf.append(',');
	_buf.append("poolBlockMinHands=");
	_buf.appendInt(poolBlockMinHands);
	_buf.append(',');
	_buf.append("visibilityCriteria=");
	_buf.append(visibilityCriteria);
	_buf.append(',');
	_buf.append("tableStakes=");
	tableStakes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("variableAntes=");
	variableAntes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("visibilityMaskEx=");
	visibilityMaskEx.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobby::cli::RingStaticData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("tableId32", tableId32, _buf);
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	Atf::XmlElement::encodeAsXmlElement("server", server, _buf);
	Atf::XmlElement::encodeAsXmlElement("serverObject", serverObject, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableFlags", tableFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("isOneOnOne", isOneOnOne, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPlayers", maxPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("loBet", loBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("hiBet", hiBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("specialName", specialName, _buf);
	Atf::XmlElement::encodeAsXmlElement("visibilityMask", visibilityMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("chatLang", chatLang, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("minChipsLimit", minChipsLimit, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxBuyIn", maxBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("ante", ante, _buf);
	Atf::XmlElement::encodeAsXmlElement("countryRestrictionInverted", countryRestrictionInverted, _buf);
	restrictedCountries.toXmlString("restrictedCountries", _buf);
	Atf::XmlElement::encodeAsXmlElement("cap", cap, _buf);
	Atf::XmlElement::encodeAsXmlElement("icon", icon, _buf);
	Atf::XmlElement::encodeAsXmlElement("filter", filter, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableInstanceFlags", tableInstanceFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("isTableStarter", isTableStarter, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableFlags2", tableFlags2, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableTypeId", tableTypeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
	Atf::XmlElement::encodeAsXmlElement("defaultBuyIn", defaultBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableId", tableId, _buf);
	Atf::XmlElement::encodeAsXmlElement("brandMask", brandMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("poolBlockMinHands", poolBlockMinHands, _buf);
	Atf::XmlElement::encodeAsXmlElement("visibilityCriteria", visibilityCriteria, _buf);
	tableStakes.toXmlString("tableStakes", _buf);
	variableAntes.toXmlString("variableAntes", _buf);
	visibilityMaskEx.toXmlString("visibilityMaskEx", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobby::cli::RingStaticData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("tableId32"))
		{
			tableId32 = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("name"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
		}
		else if (_element.equals("server"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, server)) return false;
		}
		else if (_element.equals("serverObject"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, serverObject)) return false;
		}
		else if (_element.equals("tableFlags"))
		{
			tableFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isOneOnOne"))
		{
			isOneOnOne = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isPlayMoney"))
		{
			isPlayMoney = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxPlayers"))
		{
			maxPlayers = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("game"))
		{
			game = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("loBet"))
		{
			loBet = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("hiBet"))
		{
			hiBet = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("structure"))
		{
			structure = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("specialName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, specialName)) return false;
		}
		else if (_element.equals("visibilityMask"))
		{
			visibilityMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("chatLang"))
		{
			chatLang = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("minChipsLimit"))
		{
			minChipsLimit = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxBuyIn"))
		{
			maxBuyIn = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("ante"))
		{
			ante = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("countryRestrictionInverted"))
		{
			countryRestrictionInverted = (*_value.ptr() == '1');
		}
		else if (_element.equals("restrictedCountries"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PString , 4 > >::FromXmlString(_value, restrictedCountries)) return false;
		}
		else if (_element.equals("cap"))
		{
			cap = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("icon"))
		{
			icon = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("filter"))
		{
			filter = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableInstanceFlags"))
		{
			tableInstanceFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isTableStarter"))
		{
			isTableStarter = (*_value.ptr() == '1');
		}
		else if (_element.equals("tableFlags2"))
		{
			tableFlags2 = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableTypeId"))
		{
			tableTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("scalePM"))
		{
			scalePM = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("defaultBuyIn"))
		{
			defaultBuyIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableId"))
		{
			tableId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("brandMask"))
		{
			brandMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("poolBlockMinHands"))
		{
			poolBlockMinHands = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("visibilityCriteria"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, visibilityCriteria)) return false;
		}
		else if (_element.equals("tableStakes"))
		{
			if(!Atf::AtfTempl< TableCommon::TableStakes >::FromXmlString(_value, tableStakes)) return false;
		}
		else if (_element.equals("variableAntes"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT64, 4 > >::FromXmlString(_value, variableAntes)) return false;
		}
		else if (_element.equals("visibilityMaskEx"))
		{
			if(!Atf::AtfTempl< PSiteMask >::FromXmlString(_value, visibilityMaskEx)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobby::cli::RingStaticData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(RingStaticData())) // not empty
	{
		_body.composeUINT32(tableId32);
		_body.composeString(name);
		_body.composeString(server);
		_body.composeString(serverObject);
		_body.composeUINT32(tableFlags);
		_body.composeBYTE(isOneOnOne);
		_body.composeBYTE(isPlayMoney);
		_body.composeBYTE(maxPlayers);
		_body.composeBYTE(game);
		_body.composeBYTE(isHiLo);
		_body.composeUINT32(loBet);
		_body.composeUINT32(hiBet);
		_body.composeBYTE(structure);
		_body.composeString(specialName);
		_body.composeUINT32(visibilityMask);
		_body.composeUINT16(chatLang);
		_body.composeString(currency);
		_body.composeUINT32(minChipsLimit);
		_body.composeINT32(maxBuyIn);
		_body.composeUINT32(ante);
		_body.composeBOOL(countryRestrictionInverted);
		restrictedCountries.composeMsg(_body, _ignoreJSON);
		_body.composeUINT32(cap);
		_body.composeBYTE(icon);
		_body.composeBYTE(filter);
		_body.composeUINT32(tableInstanceFlags);
		_body.composeBOOL(isTableStarter);
		_body.composeUINT64(tableFlags2);
		_body.composeUINT32(tableTypeId);
		_body.composeUINT32(scalePM);
		_body.composeUINT32(defaultBuyIn);
		_body.composeUINT64(tableId);
		_body.composeUINT32(brandMask);
		_body.composeINT32(poolBlockMinHands);
		_body.composeString(visibilityCriteria);
		tableStakes.composeMsg(_body, _ignoreJSON);
		variableAntes.composeMsg(_body, _ignoreJSON);
		visibilityMaskEx.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::RingStaticData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(tableId32);
	_parser0.parseStringP(name);
	_parser0.parseStringP(server);
	_parser0.parseStringP(serverObject);
	_parser0.parseUINT32(tableFlags);
	_parser0.parseBYTE(isOneOnOne);
	_parser0.parseBYTE(isPlayMoney);
	_parser0.parseBYTE(maxPlayers);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(isHiLo);
	_parser0.parseUINT32(loBet);
	_parser0.parseUINT32(hiBet);
	_parser0.parseBYTE(structure);
	_parser0.parseStringP(specialName);
	_parser0.parseUINT32(visibilityMask);
	_parser0.parseUINT16(chatLang);
	_parser0.parseStringP(currency);
	_parser0.parseUINT32(minChipsLimit);
	_parser0.parseINT32(maxBuyIn);
	_parser0.parseUINT32(ante);
	_parser0.parseBOOL(countryRestrictionInverted);
	restrictedCountries.parseMsg(_parser0);
	_parser0.parseUINT32(cap);
	_parser0.parseBYTE(icon);
	_parser0.parseBYTE(filter);
	_parser0.parseUINT32(tableInstanceFlags);
	_parser0.parseBOOL(isTableStarter);
	_parser0.parseUINT64(tableFlags2);
	_parser0.parseUINT32(tableTypeId);
	_parser0.parseUINT32(scalePM);
	_parser0.parseUINT32(defaultBuyIn);
	_parser0.parseUINT64(tableId);
	_parser0.parseUINT32(brandMask);
	_parser0.parseINT32(poolBlockMinHands);
	_parser0.parseStringP(visibilityCriteria);
	if(_parser0.parseEnded()) return;
	tableStakes.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	variableAntes.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	visibilityMaskEx.parseMsg(_parser0);
}

const char *MLobby::cli::RingStaticData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tableId32", tableId32);
	_jsonstr.compose("name", name);
	_jsonstr.compose("server", server);
	_jsonstr.compose("serverObject", serverObject);
	_jsonstr.compose("tableFlags", tableFlags);
	_jsonstr.compose("isOneOnOne", isOneOnOne);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("maxPlayers", maxPlayers);
	_jsonstr.compose("game", game);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("loBet", loBet);
	_jsonstr.compose("hiBet", hiBet);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("specialName", specialName);
	_jsonstr.compose("visibilityMask", visibilityMask);
	_jsonstr.compose("chatLang", chatLang);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("minChipsLimit", minChipsLimit);
	_jsonstr.compose("maxBuyIn", maxBuyIn);
	_jsonstr.compose("ante", ante);
	_jsonstr.compose("countryRestrictionInverted", countryRestrictionInverted);
	_jsonstr.compose("restrictedCountries", restrictedCountries);
	_jsonstr.compose("cap", cap);
	_jsonstr.compose("icon", icon);
	_jsonstr.compose("filter", filter);
	_jsonstr.compose("tableInstanceFlags", tableInstanceFlags);
	_jsonstr.compose("isTableStarter", isTableStarter);
	_jsonstr.compose("tableFlags2", tableFlags2);
	_jsonstr.compose("tableTypeId", tableTypeId);
	_jsonstr.compose("scalePM", scalePM);
	_jsonstr.compose("defaultBuyIn", defaultBuyIn);
	_jsonstr.compose("tableId", tableId);
	_jsonstr.compose("brandMask", brandMask);
	_jsonstr.compose("poolBlockMinHands", poolBlockMinHands);
	_jsonstr.compose("visibilityCriteria", visibilityCriteria);
	_jsonstr.compose("tableStakes", tableStakes);
	_jsonstr.compose("variableAntes", variableAntes);
	_jsonstr.compose("visibilityMaskEx", visibilityMaskEx);
	return _buf.c_str();
}

void MLobby::cli::RingStaticData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tableId32", tableId32);
	_jparser.parseByNameThrow("name", name);
	_jparser.parseByNameThrow("server", server);
	_jparser.parseByNameThrow("serverObject", serverObject);
	_jparser.parseByNameThrow("tableFlags", tableFlags);
	_jparser.parseByNameThrow("isOneOnOne", isOneOnOne);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("maxPlayers", maxPlayers);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("loBet", loBet);
	_jparser.parseByNameThrow("hiBet", hiBet);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("specialName", specialName);
	_jparser.parseByNameThrow("visibilityMask", visibilityMask);
	_jparser.parseByNameThrow("chatLang", chatLang);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("minChipsLimit", minChipsLimit);
	_jparser.parseByNameThrow("maxBuyIn", maxBuyIn);
	_jparser.parseByNameThrow("ante", ante);
	_jparser.parseByNameThrow("countryRestrictionInverted", countryRestrictionInverted);
	_jparser.parseByNameThrow("restrictedCountries", restrictedCountries);
	_jparser.parseByNameThrow("cap", cap);
	_jparser.parseByNameThrow("icon", icon);
	_jparser.parseByNameThrow("filter", filter);
	_jparser.parseByNameThrow("tableInstanceFlags", tableInstanceFlags);
	_jparser.parseByNameThrow("isTableStarter", isTableStarter);
	_jparser.parseByNameThrow("tableFlags2", tableFlags2);
	_jparser.parseByNameThrow("tableTypeId", tableTypeId);
	_jparser.parseByNameThrow("scalePM", scalePM);
	_jparser.parseByNameThrow("defaultBuyIn", defaultBuyIn);
	_jparser.parseByNameThrow("tableId", tableId);
	_jparser.parseByNameThrow("brandMask", brandMask);
	_jparser.parseByNameThrow("poolBlockMinHands", poolBlockMinHands);
	_jparser.parseByNameThrow("visibilityCriteria", visibilityCriteria);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tableStakes", tableStakes);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("variableAntes", variableAntes);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("visibilityMaskEx", visibilityMaskEx);
}

/* static */ void MLobby::cli::RingStaticData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tableId32; _jparser.validateByNameThrow("tableId32", tableId32);
	AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateInt(_descr, "name", name.length(), _checker, __FILE__, __LINE__);
	PString server; _jparser.validateByNameThrow("server", server);
	AtfValidator::validateInt(_descr, "server", server.length(), _checker, __FILE__, __LINE__);
	PString serverObject; _jparser.validateByNameThrow("serverObject", serverObject);
	AtfValidator::validateInt(_descr, "serverObject", serverObject.length(), _checker, __FILE__, __LINE__);
	UINT32 tableFlags; _jparser.validateByNameThrow("tableFlags", tableFlags);
	AtfValidator::validateInt(_descr, "tableFlags", tableFlags, _checker, __FILE__, __LINE__);
	BYTE isOneOnOne; _jparser.validateByNameThrow("isOneOnOne", isOneOnOne);
	AtfValidator::validateInt(_descr, "isOneOnOne", isOneOnOne, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	BYTE maxPlayers; _jparser.validateByNameThrow("maxPlayers", maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	UINT32 loBet; _jparser.validateByNameThrow("loBet", loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	UINT32 hiBet; _jparser.validateByNameThrow("hiBet", hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	PString specialName; _jparser.validateByNameThrow("specialName", specialName);
	AtfValidator::validateInt(_descr, "specialName", specialName.length(), _checker, __FILE__, __LINE__);
	UINT32 visibilityMask; _jparser.validateByNameThrow("visibilityMask", visibilityMask);
	AtfValidator::validateInt(_descr, "visibilityMask", visibilityMask, _checker, __FILE__, __LINE__);
	UINT16 chatLang; _jparser.validateByNameThrow("chatLang", chatLang);
	AtfValidator::validateInt(_descr, "chatLang", chatLang, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	UINT32 minChipsLimit; _jparser.validateByNameThrow("minChipsLimit", minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	INT32 maxBuyIn; _jparser.validateByNameThrow("maxBuyIn", maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	UINT32 ante; _jparser.validateByNameThrow("ante", ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	bool countryRestrictionInverted; _jparser.validateByNameThrow("countryRestrictionInverted", countryRestrictionInverted);
	AtfValidator::validateInt(_descr, "countryRestrictionInverted", countryRestrictionInverted, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PString > restrictedCountries; _jparser.validateByNameThrow("restrictedCountries", restrictedCountries);
	AtfValidator::validateInt(_descr, "restrictedCountries", restrictedCountries.size(), _checker, __FILE__, __LINE__);
	UINT32 cap; _jparser.validateByNameThrow("cap", cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	BYTE icon; _jparser.validateByNameThrow("icon", icon);
	AtfValidator::validateInt(_descr, "icon", icon, _checker, __FILE__, __LINE__);
	BYTE filter; _jparser.validateByNameThrow("filter", filter);
	AtfValidator::validateInt(_descr, "filter", filter, _checker, __FILE__, __LINE__);
	UINT32 tableInstanceFlags; _jparser.validateByNameThrow("tableInstanceFlags", tableInstanceFlags);
	AtfValidator::validateInt(_descr, "tableInstanceFlags", tableInstanceFlags, _checker, __FILE__, __LINE__);
	bool isTableStarter; _jparser.validateByNameThrow("isTableStarter", isTableStarter);
	AtfValidator::validateInt(_descr, "isTableStarter", isTableStarter, _checker, __FILE__, __LINE__);
	UINT64 tableFlags2; _jparser.validateByNameThrow("tableFlags2", tableFlags2);
	AtfValidator::validateUint(_descr, "tableFlags2", tableFlags2, _checker, __FILE__, __LINE__);
	UINT32 tableTypeId; _jparser.validateByNameThrow("tableTypeId", tableTypeId);
	AtfValidator::validateInt(_descr, "tableTypeId", tableTypeId, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT32 defaultBuyIn; _jparser.validateByNameThrow("defaultBuyIn", defaultBuyIn);
	AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	UINT64 tableId; _jparser.validateByNameThrow("tableId", tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	UINT32 brandMask; _jparser.validateByNameThrow("brandMask", brandMask);
	AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
	INT32 poolBlockMinHands; _jparser.validateByNameThrow("poolBlockMinHands", poolBlockMinHands);
	AtfValidator::validateInt(_descr, "poolBlockMinHands", poolBlockMinHands, _checker, __FILE__, __LINE__);
	PString visibilityCriteria; _jparser.validateByNameThrow("visibilityCriteria", visibilityCriteria);
	AtfValidator::validateInt(_descr, "visibilityCriteria", visibilityCriteria.length(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	TableCommon::TableStakes tableStakes; _jparser.validateByNameThrow("tableStakes", tableStakes);
	if(_jparser.parseEnded()) return;
	Atf::AtfVectorBase< INT64 > variableAntes; _jparser.validateByNameThrow("variableAntes", variableAntes);
	AtfValidator::validateInt(_descr, "variableAntes", variableAntes.size(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PSiteMask visibilityMaskEx; _jparser.validateByNameThrow("visibilityMaskEx", visibilityMaskEx);
}

/*static*/ void MLobby::cli::RingStaticData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 tableId32; _parser0.parseUINT32(tableId32);
	AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "serverObject"); size_t szServerObject = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObject", szServerObject, _checker, __FILE__, __LINE__);
	UINT32 tableFlags; _parser0.parseUINT32(tableFlags);
	AtfValidator::validateInt(_descr, "tableFlags", tableFlags, _checker, __FILE__, __LINE__);
	BYTE isOneOnOne; _parser0.parseBYTE(isOneOnOne);
	AtfValidator::validateInt(_descr, "isOneOnOne", isOneOnOne, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser0.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	BYTE maxPlayers; _parser0.parseBYTE(maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser0.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	UINT32 loBet; _parser0.parseUINT32(loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	UINT32 hiBet; _parser0.parseUINT32(hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "specialName"); size_t szSpecialName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "specialName", szSpecialName, _checker, __FILE__, __LINE__);
	UINT32 visibilityMask; _parser0.parseUINT32(visibilityMask);
	AtfValidator::validateInt(_descr, "visibilityMask", visibilityMask, _checker, __FILE__, __LINE__);
	UINT16 chatLang; _parser0.parseUINT16(chatLang);
	AtfValidator::validateInt(_descr, "chatLang", chatLang, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 minChipsLimit; _parser0.parseUINT32(minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	INT32 maxBuyIn; _parser0.parseINT32(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	UINT32 ante; _parser0.parseUINT32(ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	bool countryRestrictionInverted; _parser0.parseBOOL(countryRestrictionInverted);
	AtfValidator::validateInt(_descr, "countryRestrictionInverted", countryRestrictionInverted, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szRestrictedCountries = Atf::LAtfVector< PString , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("restrictedCountries"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "restrictedCountries", szRestrictedCountries, _checker, __FILE__, __LINE__);
	UINT32 cap; _parser0.parseUINT32(cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	BYTE icon; _parser0.parseBYTE(icon);
	AtfValidator::validateInt(_descr, "icon", icon, _checker, __FILE__, __LINE__);
	BYTE filter; _parser0.parseBYTE(filter);
	AtfValidator::validateInt(_descr, "filter", filter, _checker, __FILE__, __LINE__);
	UINT32 tableInstanceFlags; _parser0.parseUINT32(tableInstanceFlags);
	AtfValidator::validateInt(_descr, "tableInstanceFlags", tableInstanceFlags, _checker, __FILE__, __LINE__);
	bool isTableStarter; _parser0.parseBOOL(isTableStarter);
	AtfValidator::validateInt(_descr, "isTableStarter", isTableStarter, _checker, __FILE__, __LINE__);
	UINT64 tableFlags2; _parser0.parseUINT64(tableFlags2);
	AtfValidator::validateUint(_descr, "tableFlags2", tableFlags2, _checker, __FILE__, __LINE__);
	UINT32 tableTypeId; _parser0.parseUINT32(tableTypeId);
	AtfValidator::validateInt(_descr, "tableTypeId", tableTypeId, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser0.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT32 defaultBuyIn; _parser0.parseUINT32(defaultBuyIn);
	AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	UINT64 tableId; _parser0.parseUINT64(tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	UINT32 brandMask; _parser0.parseUINT32(brandMask);
	AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
	INT32 poolBlockMinHands; _parser0.parseINT32(poolBlockMinHands);
	AtfValidator::validateInt(_descr, "poolBlockMinHands", poolBlockMinHands, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "visibilityCriteria"); size_t szVisibilityCriteria = strlen(_dummy);
	AtfValidator::validateInt(_descr, "visibilityCriteria", szVisibilityCriteria, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	TableCommon::TableStakes::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tableStakes"), _fieldsWithUnparsedContent);
	if(_parser0.parseEnded()) return;
	int szVariableAntes = Atf::LAtfVector< INT64, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("variableAntes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "variableAntes", szVariableAntes, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("visibilityMaskEx"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    FppFactorStruct
//=================================================================

MLobby::cli::FppFactorStruct::FppFactorStruct()
{
	clear();
}

void MLobby::cli::FppFactorStruct::clear()
{
	fppFactor = 0;
	sites = 0;
	gameCategory = 0;
	number = 0;
	endT.setNull();
	sitesEx.clear();
}

bool MLobby::cli::FppFactorStruct::equals(const FppFactorStruct& _o) const
{
	return fppFactor == _o.fppFactor &&
		sites == _o.sites &&
		gameCategory == _o.gameCategory &&
		number == _o.number &&
		endT.equals(_o.endT) &&
		sitesEx.equals(_o.sitesEx);
}

const char *MLobby::cli::FppFactorStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("fppFactor=");
	_buf.appendUint(fppFactor);
	_buf.append(',');
	_buf.append("sites=");
	_buf.appendUint(sites);
	_buf.append(',');
	_buf.append("gameCategory=");
	_buf.appendUint(gameCategory);
	_buf.append(',');
	_buf.append("number=");
	_buf.appendUint(number);
	_buf.append(',');
	_buf.append("endT=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, endT);
	_buf.append(',');
	_buf.append("sitesEx=");
	sitesEx.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobby::cli::FppFactorStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("fppFactor", fppFactor, _buf);
	Atf::XmlElement::encodeAsXmlElement("sites", sites, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameCategory", gameCategory, _buf);
	Atf::XmlElement::encodeAsXmlElement("number", number, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "endT", endT);
	sitesEx.toXmlString("sitesEx", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobby::cli::FppFactorStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("fppFactor"))
		{
			fppFactor = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("sites"))
		{
			sites = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("gameCategory"))
		{
			gameCategory = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("number"))
		{
			number = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("endT"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, endT);
		}
		else if (_element.equals("sitesEx"))
		{
			if(!Atf::AtfTempl< PSiteMask >::FromXmlString(_value, sitesEx)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobby::cli::FppFactorStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(FppFactorStruct())) // not empty
	{
		_body.composeUINT16(fppFactor);
		_body.composeUINT32(sites);
		_body.composeUINT32(gameCategory);
		_body.composeUINT32(number);
		_body.composeSrvTime(endT);
		sitesEx.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::FppFactorStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT16(fppFactor);
	_parser0.parseUINT32(sites);
	_parser0.parseUINT32(gameCategory);
	_parser0.parseUINT32(number);
	_parser0.parseSrvTime(endT);
	if(_parser0.parseEnded()) return;
	sitesEx.parseMsg(_parser0);
}

const char *MLobby::cli::FppFactorStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("fppFactor", fppFactor);
	_jsonstr.compose("sites", sites);
	_jsonstr.compose("gameCategory", gameCategory);
	_jsonstr.compose("number", number);
	_jsonstr.compose("endT", endT);
	_jsonstr.compose("sitesEx", sitesEx);
	return _buf.c_str();
}

void MLobby::cli::FppFactorStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("fppFactor", fppFactor);
	_jparser.parseByNameThrow("sites", sites);
	_jparser.parseByNameThrow("gameCategory", gameCategory);
	_jparser.parseByNameThrow("number", number);
	_jparser.parseByNameThrow("endT", endT);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("sitesEx", sitesEx);
}

/* static */ void MLobby::cli::FppFactorStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT16 fppFactor; _jparser.validateByNameThrow("fppFactor", fppFactor);
	AtfValidator::validateInt(_descr, "fppFactor", fppFactor, _checker, __FILE__, __LINE__);
	UINT32 sites; _jparser.validateByNameThrow("sites", sites);
	AtfValidator::validateInt(_descr, "sites", sites, _checker, __FILE__, __LINE__);
	UINT32 gameCategory; _jparser.validateByNameThrow("gameCategory", gameCategory);
	AtfValidator::validateInt(_descr, "gameCategory", gameCategory, _checker, __FILE__, __LINE__);
	UINT32 number; _jparser.validateByNameThrow("number", number);
	AtfValidator::validateInt(_descr, "number", number, _checker, __FILE__, __LINE__);
	SrvTime endT; _jparser.validateByNameThrow("endT", endT);
	AtfValidator::validateSrvDateTime(_descr, "endT", endT, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PSiteMask sitesEx; _jparser.validateByNameThrow("sitesEx", sitesEx);
}

/*static*/ void MLobby::cli::FppFactorStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT16 fppFactor; _parser0.parseUINT16(fppFactor);
	AtfValidator::validateInt(_descr, "fppFactor", fppFactor, _checker, __FILE__, __LINE__);
	UINT32 sites; _parser0.parseUINT32(sites);
	AtfValidator::validateInt(_descr, "sites", sites, _checker, __FILE__, __LINE__);
	UINT32 gameCategory; _parser0.parseUINT32(gameCategory);
	AtfValidator::validateInt(_descr, "gameCategory", gameCategory, _checker, __FILE__, __LINE__);
	UINT32 number; _parser0.parseUINT32(number);
	AtfValidator::validateInt(_descr, "number", number, _checker, __FILE__, __LINE__);
	SrvTime endT; _parser0.parseSrvTime(endT);
	AtfValidator::validateSrvDateTime(_descr, "endT", endT, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PString _descbuf;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("sitesEx"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    RingDynaData
//=================================================================

MLobby::cli::RingDynaData::RingDynaData()
{
	clear();
}

void MLobby::cli::RingDynaData::clear()
{
	numPlayers = 0;
	wait = 0;
	playersPerFlop = 0;
	potSize = 0;
	handsPerHour = 0;
	publProp = 0;
	averageStackSize = 0;
	vpip = 0;
	fppFactors.clear();
	isTableDealingCards = false;
}

bool MLobby::cli::RingDynaData::equals(const RingDynaData& _o) const
{
	return numPlayers == _o.numPlayers &&
		wait == _o.wait &&
		playersPerFlop == _o.playersPerFlop &&
		potSize == _o.potSize &&
		handsPerHour == _o.handsPerHour &&
		publProp == _o.publProp &&
		averageStackSize == _o.averageStackSize &&
		vpip == _o.vpip &&
		fppFactors.equals(_o.fppFactors) &&
		isTableDealingCards == _o.isTableDealingCards;
}

const char *MLobby::cli::RingDynaData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("numPlayers=");
	_buf.appendUint(numPlayers);
	_buf.append(',');
	_buf.append("wait=");
	_buf.appendUint(wait);
	_buf.append(',');
	_buf.append("playersPerFlop=");
	_buf.appendUint(playersPerFlop);
	_buf.append(',');
	_buf.append("potSize=");
	_buf.appendUint(potSize);
	_buf.append(',');
	_buf.append("handsPerHour=");
	_buf.appendUint(handsPerHour);
	_buf.append(',');
	_buf.append("publProp=");
	_buf.appendUint(publProp);
	_buf.append(',');
	_buf.append("averageStackSize=");
	_buf.appendUint(averageStackSize);
	_buf.append(',');
	_buf.append("vpip=");
	_buf.appendUint(vpip);
	_buf.append(',');
	_buf.append("fppFactors=");
	fppFactors.toTraceString(_buf);
	_buf.append(',');
	_buf.append("isTableDealingCards=");
	_buf.appendUint(isTableDealingCards);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobby::cli::RingDynaData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("numPlayers", numPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("wait", wait, _buf);
	Atf::XmlElement::encodeAsXmlElement("playersPerFlop", playersPerFlop, _buf);
	Atf::XmlElement::encodeAsXmlElement("potSize", potSize, _buf);
	Atf::XmlElement::encodeAsXmlElement("handsPerHour", handsPerHour, _buf);
	Atf::XmlElement::encodeAsXmlElement("publProp", publProp, _buf);
	Atf::XmlElement::encodeAsXmlElement("averageStackSize", averageStackSize, _buf);
	Atf::XmlElement::encodeAsXmlElement("vpip", vpip, _buf);
	fppFactors.toXmlString("fppFactors", _buf);
	Atf::XmlElement::encodeAsXmlElement("isTableDealingCards", isTableDealingCards, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobby::cli::RingDynaData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("numPlayers"))
		{
			numPlayers = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("wait"))
		{
			wait = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("playersPerFlop"))
		{
			playersPerFlop = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("potSize"))
		{
			potSize = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("handsPerHour"))
		{
			handsPerHour = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("publProp"))
		{
			publProp = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("averageStackSize"))
		{
			averageStackSize = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("vpip"))
		{
			vpip = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("fppFactors"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< FppFactorStruct, 4 > >::FromXmlString(_value, fppFactors)) return false;
		}
		else if (_element.equals("isTableDealingCards"))
		{
			isTableDealingCards = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobby::cli::RingDynaData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(RingDynaData())) // not empty
	{
		_body.composeBYTE(numPlayers);
		_body.composeBYTE(wait);
		_body.composeBYTE(playersPerFlop);
		_body.composeUINT32(potSize);
		_body.composeUINT16(handsPerHour);
		_body.composeBYTE(publProp);
		_body.composeUINT32(averageStackSize);
		_body.composeBYTE(vpip);
		fppFactors.composeMsg(_body, _ignoreJSON);
		_body.composeBOOL(isTableDealingCards);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::RingDynaData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(numPlayers);
	_parser0.parseBYTE(wait);
	_parser0.parseBYTE(playersPerFlop);
	_parser0.parseUINT32(potSize);
	_parser0.parseUINT16(handsPerHour);
	_parser0.parseBYTE(publProp);
	_parser0.parseUINT32(averageStackSize);
	_parser0.parseBYTE(vpip);
	fppFactors.parseMsg(_parser0);
	_parser0.parseBOOL(isTableDealingCards);
}

const char *MLobby::cli::RingDynaData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("numPlayers", numPlayers);
	_jsonstr.compose("wait", wait);
	_jsonstr.compose("playersPerFlop", playersPerFlop);
	_jsonstr.compose("potSize", potSize);
	_jsonstr.compose("handsPerHour", handsPerHour);
	_jsonstr.compose("publProp", publProp);
	_jsonstr.compose("averageStackSize", averageStackSize);
	_jsonstr.compose("vpip", vpip);
	_jsonstr.compose("fppFactors", fppFactors);
	_jsonstr.compose("isTableDealingCards", isTableDealingCards);
	return _buf.c_str();
}

void MLobby::cli::RingDynaData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("numPlayers", numPlayers);
	_jparser.parseByNameThrow("wait", wait);
	_jparser.parseByNameThrow("playersPerFlop", playersPerFlop);
	_jparser.parseByNameThrow("potSize", potSize);
	_jparser.parseByNameThrow("handsPerHour", handsPerHour);
	_jparser.parseByNameThrow("publProp", publProp);
	_jparser.parseByNameThrow("averageStackSize", averageStackSize);
	_jparser.parseByNameThrow("vpip", vpip);
	_jparser.parseByNameThrow("fppFactors", fppFactors);
	_jparser.parseByNameThrow("isTableDealingCards", isTableDealingCards);
}

/* static */ void MLobby::cli::RingDynaData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE numPlayers; _jparser.validateByNameThrow("numPlayers", numPlayers);
	AtfValidator::validateInt(_descr, "numPlayers", numPlayers, _checker, __FILE__, __LINE__);
	BYTE wait; _jparser.validateByNameThrow("wait", wait);
	AtfValidator::validateInt(_descr, "wait", wait, _checker, __FILE__, __LINE__);
	BYTE playersPerFlop; _jparser.validateByNameThrow("playersPerFlop", playersPerFlop);
	AtfValidator::validateInt(_descr, "playersPerFlop", playersPerFlop, _checker, __FILE__, __LINE__);
	UINT32 potSize; _jparser.validateByNameThrow("potSize", potSize);
	AtfValidator::validateInt(_descr, "potSize", potSize, _checker, __FILE__, __LINE__);
	UINT16 handsPerHour; _jparser.validateByNameThrow("handsPerHour", handsPerHour);
	AtfValidator::validateInt(_descr, "handsPerHour", handsPerHour, _checker, __FILE__, __LINE__);
	BYTE publProp; _jparser.validateByNameThrow("publProp", publProp);
	AtfValidator::validateInt(_descr, "publProp", publProp, _checker, __FILE__, __LINE__);
	UINT32 averageStackSize; _jparser.validateByNameThrow("averageStackSize", averageStackSize);
	AtfValidator::validateInt(_descr, "averageStackSize", averageStackSize, _checker, __FILE__, __LINE__);
	BYTE vpip; _jparser.validateByNameThrow("vpip", vpip);
	AtfValidator::validateInt(_descr, "vpip", vpip, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< FppFactorStruct > fppFactors; _jparser.validateByNameThrow("fppFactors", fppFactors);
	AtfValidator::validateInt(_descr, "fppFactors", fppFactors.size(), _checker, __FILE__, __LINE__);
	bool isTableDealingCards; _jparser.validateByNameThrow("isTableDealingCards", isTableDealingCards);
	AtfValidator::validateInt(_descr, "isTableDealingCards", isTableDealingCards, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobby::cli::RingDynaData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	BYTE numPlayers; _parser0.parseBYTE(numPlayers);
	AtfValidator::validateInt(_descr, "numPlayers", numPlayers, _checker, __FILE__, __LINE__);
	BYTE wait; _parser0.parseBYTE(wait);
	AtfValidator::validateInt(_descr, "wait", wait, _checker, __FILE__, __LINE__);
	BYTE playersPerFlop; _parser0.parseBYTE(playersPerFlop);
	AtfValidator::validateInt(_descr, "playersPerFlop", playersPerFlop, _checker, __FILE__, __LINE__);
	UINT32 potSize; _parser0.parseUINT32(potSize);
	AtfValidator::validateInt(_descr, "potSize", potSize, _checker, __FILE__, __LINE__);
	UINT16 handsPerHour; _parser0.parseUINT16(handsPerHour);
	AtfValidator::validateInt(_descr, "handsPerHour", handsPerHour, _checker, __FILE__, __LINE__);
	BYTE publProp; _parser0.parseBYTE(publProp);
	AtfValidator::validateInt(_descr, "publProp", publProp, _checker, __FILE__, __LINE__);
	UINT32 averageStackSize; _parser0.parseUINT32(averageStackSize);
	AtfValidator::validateInt(_descr, "averageStackSize", averageStackSize, _checker, __FILE__, __LINE__);
	BYTE vpip; _parser0.parseBYTE(vpip);
	AtfValidator::validateInt(_descr, "vpip", vpip, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szFppFactors = Atf::LAtfVector< FppFactorStruct, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("fppFactors"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "fppFactors", szFppFactors, _checker, __FILE__, __LINE__);
	bool isTableDealingCards; _parser0.parseBOOL(isTableDealingCards);
	AtfValidator::validateInt(_descr, "isTableDealingCards", isTableDealingCards, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    RingDataStruct
//=================================================================

MLobby::cli::RingDataStruct::RingDataStruct()
{
	clear();
}

void MLobby::cli::RingDataStruct::clear()
{
	staticData.clear();
	dynamicData.clear();
}

bool MLobby::cli::RingDataStruct::equals(const RingDataStruct& _o) const
{
	return staticData.equals(_o.staticData) &&
		dynamicData.equals(_o.dynamicData);
}

const char *MLobby::cli::RingDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("staticData=");
	staticData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("dynamicData=");
	dynamicData.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobby::cli::RingDataStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	staticData.toXmlString("staticData", _buf);
	dynamicData.toXmlString("dynamicData", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobby::cli::RingDataStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("staticData"))
		{
			if(!Atf::AtfTempl< RingStaticData >::FromXmlString(_value, staticData)) return false;
		}
		else if (_element.equals("dynamicData"))
		{
			if(!Atf::AtfTempl< RingDynaData >::FromXmlString(_value, dynamicData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobby::cli::RingDataStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(RingDataStruct())) // not empty
	{
		staticData.composeMsg(_body, _ignoreJSON);
		dynamicData.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::RingDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	staticData.parseMsg(_parser0);
	dynamicData.parseMsg(_parser0);
}

const char *MLobby::cli::RingDataStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("staticData", staticData);
	_jsonstr.compose("dynamicData", dynamicData);
	return _buf.c_str();
}

void MLobby::cli::RingDataStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("staticData", staticData);
	_jparser.parseByNameThrow("dynamicData", dynamicData);
}

/* static */ void MLobby::cli::RingDataStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	RingStaticData staticData; _jparser.validateByNameThrow("staticData", staticData);
	RingDynaData dynamicData; _jparser.validateByNameThrow("dynamicData", dynamicData);
}

/*static*/ void MLobby::cli::RingDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	RingStaticData::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("staticData"), _fieldsWithUnparsedContent);
	RingDynaData::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("dynamicData"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    HybridLobbySelectionFilter
//=================================================================

MLobby::cli::HybridLobbySelectionFilter::HybridLobbySelectionFilter()
{
	clear();
}

void MLobby::cli::HybridLobbySelectionFilter::clear()
{
	version = 0;
	country.clear();
	siteId = 0;
	brandId = 0;
	gameMask = 0;
	buyInMask = 0;
	minBuyIn = 0;
	maxBuyIn = 0;
	multiplierPM = 0;
	currencyMask = 0;
	order = 0;
	maxPlayerMask = 0;
	clientSortingSeed = 0;
	standardFormatOnly = false;
	gameTypes = 0;
	showStealthTables = true;
}

bool MLobby::cli::HybridLobbySelectionFilter::equals(const HybridLobbySelectionFilter& _o) const
{
	return version == _o.version &&
		Atf::atfPStringEquals(country, _o.country) &&
		siteId == _o.siteId &&
		brandId == _o.brandId &&
		gameMask == _o.gameMask &&
		buyInMask == _o.buyInMask &&
		minBuyIn == _o.minBuyIn &&
		maxBuyIn == _o.maxBuyIn &&
		multiplierPM == _o.multiplierPM &&
		currencyMask == _o.currencyMask &&
		order == _o.order &&
		maxPlayerMask == _o.maxPlayerMask &&
		clientSortingSeed == _o.clientSortingSeed &&
		standardFormatOnly == _o.standardFormatOnly &&
		gameTypes == _o.gameTypes &&
		showStealthTables == _o.showStealthTables;
}

const char *MLobby::cli::HybridLobbySelectionFilter::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("version=");
	_buf.appendUint(version);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("brandId=");
	_buf.appendUint(brandId);
	_buf.append(',');
	_buf.append("gameMask=");
	_buf.appendUint64(gameMask);
	_buf.append(',');
	_buf.append("buyInMask=");
	_buf.appendUint(buyInMask);
	_buf.append(',');
	_buf.append("minBuyIn=");
	_buf.appendUint64(minBuyIn);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendUint64(maxBuyIn);
	_buf.append(',');
	_buf.append("multiplierPM=");
	_buf.appendUint(multiplierPM);
	_buf.append(',');
	_buf.append("currencyMask=");
	_buf.appendUint(currencyMask);
	_buf.append(',');
	_buf.append("order=");
	_buf.appendUint(order);
	_buf.append(',');
	_buf.append("maxPlayerMask=");
	_buf.appendUint(maxPlayerMask);
	_buf.append(',');
	_buf.append("clientSortingSeed=");
	_buf.appendUint(clientSortingSeed);
	_buf.append(',');
	_buf.append("standardFormatOnly=");
	_buf.appendUint(standardFormatOnly);
	_buf.append(',');
	_buf.append("gameTypes=");
	_buf.appendUint(gameTypes);
	_buf.append(',');
	_buf.append("showStealthTables=");
	_buf.appendUint(showStealthTables);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobby::cli::HybridLobbySelectionFilter::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("version", version, _buf);
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::encodeAsXmlElement("siteId", siteId, _buf);
	Atf::XmlElement::encodeAsXmlElement("brandId", brandId, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameMask", gameMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyInMask", buyInMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("minBuyIn", minBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxBuyIn", maxBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("multiplierPM", multiplierPM, _buf);
	Atf::XmlElement::encodeAsXmlElement("currencyMask", currencyMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("order", order, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPlayerMask", maxPlayerMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientSortingSeed", clientSortingSeed, _buf);
	Atf::XmlElement::encodeAsXmlElement("standardFormatOnly", standardFormatOnly, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameTypes", gameTypes, _buf);
	Atf::XmlElement::encodeAsXmlElement("showStealthTables", showStealthTables, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobby::cli::HybridLobbySelectionFilter::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("version"))
		{
			version = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("country"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
		}
		else if (_element.equals("siteId"))
		{
			siteId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("brandId"))
		{
			brandId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("gameMask"))
		{
			gameMask = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("buyInMask"))
		{
			buyInMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minBuyIn"))
		{
			minBuyIn = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxBuyIn"))
		{
			maxBuyIn = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("multiplierPM"))
		{
			multiplierPM = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currencyMask"))
		{
			currencyMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("order"))
		{
			order = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxPlayerMask"))
		{
			maxPlayerMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("clientSortingSeed"))
		{
			clientSortingSeed = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("standardFormatOnly"))
		{
			standardFormatOnly = (*_value.ptr() == '1');
		}
		else if (_element.equals("gameTypes"))
		{
			gameTypes = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("showStealthTables"))
		{
			showStealthTables = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobby::cli::HybridLobbySelectionFilter::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(HybridLobbySelectionFilter())) // not empty
	{
		_body.composeBYTE(version);
		_body.composeString(country);
		_body.composeUINT32(siteId);
		_body.composeUINT32(brandId);
		_body.composeUINT64(gameMask);
		_body.composeUINT32(buyInMask);
		_body.composeUINT64(minBuyIn);
		_body.composeUINT64(maxBuyIn);
		_body.composeUINT32(multiplierPM);
		_body.composeUINT32(currencyMask);
		_body.composeUINT32(order);
		_body.composeUINT32(maxPlayerMask);
		_body.composeUINT32(clientSortingSeed);
		_body.composeBOOL(standardFormatOnly);
		_body.composeUINT32(gameTypes);
		_body.composeBOOL(showStealthTables);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::HybridLobbySelectionFilter::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(version);
	_parser0.parseStringP(country);
	_parser0.parseUINT32(siteId);
	_parser0.parseUINT32(brandId);
	_parser0.parseUINT64(gameMask);
	_parser0.parseUINT32(buyInMask);
	_parser0.parseUINT64(minBuyIn);
	_parser0.parseUINT64(maxBuyIn);
	_parser0.parseUINT32(multiplierPM);
	_parser0.parseUINT32(currencyMask);
	_parser0.parseUINT32(order);
	_parser0.parseUINT32(maxPlayerMask);
	_parser0.parseUINT32(clientSortingSeed);
	_parser0.parseBOOL(standardFormatOnly);
	_parser0.parseUINT32(gameTypes);
	if(_parser0.parseEnded()) return;
	_parser0.parseBOOL(showStealthTables);
}

const char *MLobby::cli::HybridLobbySelectionFilter::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("version", version);
	_jsonstr.compose("country", country);
	_jsonstr.compose("siteId", siteId);
	_jsonstr.compose("brandId", brandId);
	_jsonstr.compose("gameMask", gameMask);
	_jsonstr.compose("buyInMask", buyInMask);
	_jsonstr.compose("minBuyIn", minBuyIn);
	_jsonstr.compose("maxBuyIn", maxBuyIn);
	_jsonstr.compose("multiplierPM", multiplierPM);
	_jsonstr.compose("currencyMask", currencyMask);
	_jsonstr.compose("order", order);
	_jsonstr.compose("maxPlayerMask", maxPlayerMask);
	_jsonstr.compose("clientSortingSeed", clientSortingSeed);
	_jsonstr.compose("standardFormatOnly", standardFormatOnly);
	_jsonstr.compose("gameTypes", gameTypes);
	_jsonstr.compose("showStealthTables", showStealthTables);
	return _buf.c_str();
}

void MLobby::cli::HybridLobbySelectionFilter::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("version", version);
	_jparser.parseByNameThrow("country", country);
	_jparser.parseByNameThrow("siteId", siteId);
	_jparser.parseByNameThrow("brandId", brandId);
	_jparser.parseByNameThrow("gameMask", gameMask);
	_jparser.parseByNameThrow("buyInMask", buyInMask);
	_jparser.parseByNameThrow("minBuyIn", minBuyIn);
	_jparser.parseByNameThrow("maxBuyIn", maxBuyIn);
	_jparser.parseByNameThrow("multiplierPM", multiplierPM);
	_jparser.parseByNameThrow("currencyMask", currencyMask);
	_jparser.parseByNameThrow("order", order);
	_jparser.parseByNameThrow("maxPlayerMask", maxPlayerMask);
	_jparser.parseByNameThrow("clientSortingSeed", clientSortingSeed);
	_jparser.parseByNameThrow("standardFormatOnly", standardFormatOnly);
	_jparser.parseByNameThrow("gameTypes", gameTypes);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("showStealthTables", showStealthTables);
}

/* static */ void MLobby::cli::HybridLobbySelectionFilter::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE version; _jparser.validateByNameThrow("version", version);
	AtfValidator::validateInt(_descr, "version", version, _checker, __FILE__, __LINE__);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateIntMax(_descr, "country", country.length(), 3, _checker, __FILE__, __LINE__);
	UINT32 siteId; _jparser.validateByNameThrow("siteId", siteId);
	AtfValidator::validateIntRange(_descr, "siteId", siteId, PokerStars_SiteUnknown, (2*PokerStars_Last-1), _checker, __FILE__, __LINE__);
	UINT32 brandId; _jparser.validateByNameThrow("brandId", brandId);
	AtfValidator::validateIntRange(_descr, "brandId", brandId, BrandType_None, (2*BrandType_Last-1), _checker, __FILE__, __LINE__);
	UINT64 gameMask; _jparser.validateByNameThrow("gameMask", gameMask);
	AtfValidator::validateUintMax(_descr, "gameMask", gameMask, (2*(UINT64)MobileGameTypes::MobileGame_Last-1), _checker, __FILE__, __LINE__);
	UINT32 buyInMask; _jparser.validateByNameThrow("buyInMask", buyInMask);
	AtfValidator::validateIntMax(_descr, "buyInMask", buyInMask, (2*MobileBuyIn_Last-1), _checker, __FILE__, __LINE__);
	UINT64 minBuyIn; _jparser.validateByNameThrow("minBuyIn", minBuyIn);
	AtfValidator::validateUintMax(_descr, "minBuyIn", minBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	UINT64 maxBuyIn; _jparser.validateByNameThrow("maxBuyIn", maxBuyIn);
	AtfValidator::validateUintMax(_descr, "maxBuyIn", maxBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 multiplierPM; _jparser.validateByNameThrow("multiplierPM", multiplierPM);
	AtfValidator::validateIntMax(_descr, "multiplierPM", multiplierPM, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 currencyMask; _jparser.validateByNameThrow("currencyMask", currencyMask);
	AtfValidator::validateIntMax(_descr, "currencyMask", currencyMask, (2*MobileCurrency_Last-1), _checker, __FILE__, __LINE__);
	UINT32 order; _jparser.validateByNameThrow("order", order);
	AtfValidator::validateIntMax(_descr, "order", order, SelectionFilter::TableOrder_Last, _checker, __FILE__, __LINE__);
	UINT32 maxPlayerMask; _jparser.validateByNameThrow("maxPlayerMask", maxPlayerMask);
	AtfValidator::validateIntMax(_descr, "maxPlayerMask", maxPlayerMask, (2*MobileMaxPlayer_Last-1), _checker, __FILE__, __LINE__);
	UINT32 clientSortingSeed; _jparser.validateByNameThrow("clientSortingSeed", clientSortingSeed);
	AtfValidator::validateInt(_descr, "clientSortingSeed", clientSortingSeed, _checker, __FILE__, __LINE__);
	bool standardFormatOnly; _jparser.validateByNameThrow("standardFormatOnly", standardFormatOnly);
	AtfValidator::validateInt(_descr, "standardFormatOnly", standardFormatOnly, _checker, __FILE__, __LINE__);
	UINT32 gameTypes; _jparser.validateByNameThrow("gameTypes", gameTypes);
	AtfValidator::validateIntRange(_descr, "gameTypes", gameTypes, MobileHybridLobbyGameTypes_None, (2*MobileHybridLobbyGameTypes_Last-1), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool showStealthTables; _jparser.validateByNameThrow("showStealthTables", showStealthTables);
	AtfValidator::validateInt(_descr, "showStealthTables", showStealthTables, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobby::cli::HybridLobbySelectionFilter::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	BYTE version; _parser0.parseBYTE(version);
	AtfValidator::validateInt(_descr, "version", version, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, 3, _checker, __FILE__, __LINE__);
	UINT32 siteId; _parser0.parseUINT32(siteId);
	AtfValidator::validateIntRange(_descr, "siteId", siteId, PokerStars_SiteUnknown, (2*PokerStars_Last-1), _checker, __FILE__, __LINE__);
	UINT32 brandId; _parser0.parseUINT32(brandId);
	AtfValidator::validateIntRange(_descr, "brandId", brandId, BrandType_None, (2*BrandType_Last-1), _checker, __FILE__, __LINE__);
	UINT64 gameMask; _parser0.parseUINT64(gameMask);
	AtfValidator::validateUintMax(_descr, "gameMask", gameMask, (2*(UINT64)MobileGameTypes::MobileGame_Last-1), _checker, __FILE__, __LINE__);
	UINT32 buyInMask; _parser0.parseUINT32(buyInMask);
	AtfValidator::validateIntMax(_descr, "buyInMask", buyInMask, (2*MobileBuyIn_Last-1), _checker, __FILE__, __LINE__);
	UINT64 minBuyIn; _parser0.parseUINT64(minBuyIn);
	AtfValidator::validateUintMax(_descr, "minBuyIn", minBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	UINT64 maxBuyIn; _parser0.parseUINT64(maxBuyIn);
	AtfValidator::validateUintMax(_descr, "maxBuyIn", maxBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 multiplierPM; _parser0.parseUINT32(multiplierPM);
	AtfValidator::validateIntMax(_descr, "multiplierPM", multiplierPM, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 currencyMask; _parser0.parseUINT32(currencyMask);
	AtfValidator::validateIntMax(_descr, "currencyMask", currencyMask, (2*MobileCurrency_Last-1), _checker, __FILE__, __LINE__);
	UINT32 order; _parser0.parseUINT32(order);
	AtfValidator::validateIntMax(_descr, "order", order, SelectionFilter::TableOrder_Last, _checker, __FILE__, __LINE__);
	UINT32 maxPlayerMask; _parser0.parseUINT32(maxPlayerMask);
	AtfValidator::validateIntMax(_descr, "maxPlayerMask", maxPlayerMask, (2*MobileMaxPlayer_Last-1), _checker, __FILE__, __LINE__);
	UINT32 clientSortingSeed; _parser0.parseUINT32(clientSortingSeed);
	AtfValidator::validateInt(_descr, "clientSortingSeed", clientSortingSeed, _checker, __FILE__, __LINE__);
	bool standardFormatOnly; _parser0.parseBOOL(standardFormatOnly);
	AtfValidator::validateInt(_descr, "standardFormatOnly", standardFormatOnly, _checker, __FILE__, __LINE__);
	UINT32 gameTypes; _parser0.parseUINT32(gameTypes);
	AtfValidator::validateIntRange(_descr, "gameTypes", gameTypes, MobileHybridLobbyGameTypes_None, (2*MobileHybridLobbyGameTypes_Last-1), _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	bool showStealthTables; _parser0.parseBOOL(showStealthTables);
	AtfValidator::validateInt(_descr, "showStealthTables", showStealthTables, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_RINGGAMES2
//=================================================================

MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2::Protocol_MSG_MLOBBY_FIND_RINGGAMES2()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2::clear()
{
	filter.clear();
	maxItems = 0;
	excludedTables.clear();
	context = 0;
	installId.clear();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2::equals(const Protocol_MSG_MLOBBY_FIND_RINGGAMES2& _o) const
{
	return filter.equals(_o.filter) &&
		maxItems == _o.maxItems &&
		excludedTables.equals(_o.excludedTables) &&
		context == _o.context &&
		Atf::atfPStringEquals(installId, _o.installId);
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBY_FIND_RINGGAMES2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBY_FIND_RINGGAMES2*)_other));
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_RINGGAMES2).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("maxItems=");
	_buf.appendUint(maxItems);
	_buf.append(',');
	_buf.append("excludedTables=");
	excludedTables.toTraceString(_buf);
	_buf.append(',');
	_buf.append("context=");
	_buf.appendUint(context);
	_buf.append(',');
	_buf.append("installId=");
	_buf.append(installId);
	return _buf.c_str();
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBY_FIND_RINGGAMES2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	filter.toXmlString("filter", _buf);
	Atf::XmlElement::encodeAsXmlElement("maxItems", maxItems, _buf);
	excludedTables.toXmlString("excludedTables", _buf);
	Atf::XmlElement::encodeAsXmlElement("context", context, _buf);
	Atf::XmlElement::encodeAsXmlElement("installId", installId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("filter"))
			{
				if(!Atf::AtfTempl< TableSelectionFilter >::FromXmlString(_value, filter)) return false;
			}
			else if (_element.equals("maxItems"))
			{
				maxItems = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("excludedTables"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT64, 4 > >::FromXmlString(_value, excludedTables)) return false;
			}
			else if (_element.equals("context"))
			{
				context = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("installId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, installId)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	filter.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(maxItems);
	excludedTables.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(context);
	_msg.composeString(installId);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	_parser.parseUINT32(maxItems);
	if(_parser.parseEnded()) return;
	excludedTables.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(context);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(installId);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("filter", filter);
	_jsonstr.compose("maxItems", maxItems);
	_jsonstr.compose("excludedTables", excludedTables);
	_jsonstr.compose("context", context);
	_jsonstr.compose("installId", installId);
	return _buf.c_str();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("filter", filter);
	_jparser.parseByNameThrow("maxItems", maxItems);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("excludedTables", excludedTables);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("context", context);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("installId", installId);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_RINGGAMES2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TableSelectionFilter filter; _jparser.validateByNameThrow("filter", filter);
	UINT32 maxItems; _jparser.validateByNameThrow("maxItems", maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	Atf::AtfVectorBase< UINT64 > excludedTables; _jparser.validateByNameThrow("excludedTables", excludedTables);
	AtfValidator::validateIntMax(_descr, "excludedTables", excludedTables.size(), 1024, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 context; _jparser.validateByNameThrow("context", context);
	AtfValidator::validateInt(_descr, "context", context, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString installId; _jparser.validateByNameThrow("installId", installId);
	AtfValidator::validateIntMax(_descr, "installId", installId.length(), 128, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_RINGGAMES2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	PString _descbuf;
	TableSelectionFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	UINT32 maxItems; _parser.parseUINT32(maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	int szExcludedTables = Atf::LAtfVector< UINT64, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("excludedTables"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "excludedTables", szExcludedTables, 1024, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 context; _parser.parseUINT32(context);
	AtfValidator::validateInt(_descr, "context", context, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "installId"); size_t szInstallId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "installId", szInstallId, 128, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_RINGGAMES2_REPLY
//=================================================================

MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2_REPLY::Protocol_MSG_MLOBBY_FIND_RINGGAMES2_REPLY()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2_REPLY::clear()
{
	totalItems = 0;
	tables.clear();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2_REPLY::equals(const Protocol_MSG_MLOBBY_FIND_RINGGAMES2_REPLY& _o) const
{
	return totalItems == _o.totalItems &&
		tables.equals(_o.tables);
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBY_FIND_RINGGAMES2_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBY_FIND_RINGGAMES2_REPLY*)_other));
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_RINGGAMES2_REPLY).append(")");
	_buf.append(',');
	_buf.append("totalItems=");
	_buf.appendUint(totalItems);
	_buf.append(',');
	_buf.append("tables=");
	tables.toTraceString(_buf);
	return _buf.c_str();
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBY_FIND_RINGGAMES2_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("totalItems", totalItems, _buf);
	tables.toXmlString("tables", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("totalItems"))
			{
				totalItems = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tables"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< RingDataStruct, 4 > >::FromXmlString(_value, tables)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(totalItems);
	tables.composeMsg(_msg, _ignoreJSON);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(totalItems);
	tables.parseMsg(_parser);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("totalItems", totalItems);
	_jsonstr.compose("tables", tables);
	return _buf.c_str();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("totalItems", totalItems);
	_jparser.parseByNameThrow("tables", tables);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_RINGGAMES2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 totalItems; _jparser.validateByNameThrow("totalItems", totalItems);
	AtfValidator::validateInt(_descr, "totalItems", totalItems, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< RingDataStruct > tables; _jparser.validateByNameThrow("tables", tables);
	AtfValidator::validateInt(_descr, "tables", tables.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_RINGGAMES2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 totalItems; _parser.parseUINT32(totalItems);
	AtfValidator::validateInt(_descr, "totalItems", totalItems, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTables = Atf::LAtfVector< RingDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tables"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tables", szTables, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    TournStaticData
//=================================================================

MLobby::cli::TournStaticData::TournStaticData()
{
	clear();
}

void MLobby::cli::TournStaticData::clear()
{
	tournamentId = 0;
	server.clear();
	targetServer.clear();
	hasSatellite.clear();
	whenStart.setNull();
	buyIn = 0;
	rake = 0;
	fppBuyIn = 0;
	isRestricted = 0;
	isPwdProtected = 0;
	name.clear();
	admissionId.clear();
	isPlayMoney = 0;
	satelliteTarget = 0;
	minPlayers = 0;
	tournFlags = 0;
	game = 0;
	isHiLo = 0;
	structure = 0;
	tournMask = 0;
	tournSites = 0;
	whenStartInt = 0;
	tournMask2 = 0;
	targetWhenStart.setNull();
	tournMask3 = 0;
	tournMask4 = 0;
	maxPerTable = 0;
	countryRestrictionInverted = false;
	restrictedCountries.clear();
	hasDayTwoStart = 0;
	dayTwoStartSec = 0;
	dayTwoStart.setNull();
	shortText.clear();
	chatLang = 0;
	currency.clear();
	tournFlagsServInt = 0;
	knockout = 0;
	satelliteTargetReference.clear();
	satelliteTargetReferenceLock = 0;
	maxPlayers = 0;
	speedDisplay = 0;
	nameSnG.clear();
	step = 0;
	timedTournType = 0;
	timedTournTime = 0;
	timedTournPayout = 0;
	isFlightTourn = false;
	tournBrand.clear();
	scalePM = 0;
	progressiveKnockout = 0;
	awardScheme = 0;
	numReentries = 0;
	internalReference.clear();
	favReference.clear();
	satelliteTargetName.clear();
	admissionPrice = 0;
	tournFlags2 = 0;
	regEndAbs.setNull();
	regEndAbsInt = 0;
	doNotAllowToUnreg = false;
	nStackInfo.clear();
	tournMask5 = 0;
	tournMask6 = 0;
	satelliteTargetNameMTT.clear();
	liveEventMask = 0;
	timedTournPlayersPercent = 0;
	dummy1 = 0;
	rmPmLobby = 0;
	brandAccessMask = 0;
	activeFlags = 0;
	sngScriptId = 0;
	customSpeedDisplayName.clear();
	tournSitesEx.clear();
}

bool MLobby::cli::TournStaticData::equals(const TournStaticData& _o) const
{
	return tournamentId == _o.tournamentId &&
		Atf::atfPStringEquals(server, _o.server) &&
		Atf::atfPStringEquals(targetServer, _o.targetServer) &&
		Atf::atfPStringEquals(hasSatellite, _o.hasSatellite) &&
		whenStart.equals(_o.whenStart) &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		fppBuyIn == _o.fppBuyIn &&
		isRestricted == _o.isRestricted &&
		isPwdProtected == _o.isPwdProtected &&
		Atf::atfPStringEquals(name, _o.name) &&
		Atf::atfPStringEquals(admissionId, _o.admissionId) &&
		isPlayMoney == _o.isPlayMoney &&
		satelliteTarget == _o.satelliteTarget &&
		minPlayers == _o.minPlayers &&
		tournFlags == _o.tournFlags &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		structure == _o.structure &&
		tournMask == _o.tournMask &&
		tournSites == _o.tournSites &&
		whenStartInt == _o.whenStartInt &&
		tournMask2 == _o.tournMask2 &&
		targetWhenStart.equals(_o.targetWhenStart) &&
		tournMask3 == _o.tournMask3 &&
		tournMask4 == _o.tournMask4 &&
		maxPerTable == _o.maxPerTable &&
		countryRestrictionInverted == _o.countryRestrictionInverted &&
		restrictedCountries.equals(_o.restrictedCountries) &&
		hasDayTwoStart == _o.hasDayTwoStart &&
		dayTwoStartSec == _o.dayTwoStartSec &&
		dayTwoStart.equals(_o.dayTwoStart) &&
		shortText.equals(_o.shortText) &&
		chatLang == _o.chatLang &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		tournFlagsServInt == _o.tournFlagsServInt &&
		knockout == _o.knockout &&
		Atf::atfPStringEquals(satelliteTargetReference, _o.satelliteTargetReference) &&
		satelliteTargetReferenceLock == _o.satelliteTargetReferenceLock &&
		maxPlayers == _o.maxPlayers &&
		speedDisplay == _o.speedDisplay &&
		nameSnG.equals(_o.nameSnG) &&
		step == _o.step &&
		timedTournType == _o.timedTournType &&
		timedTournTime == _o.timedTournTime &&
		timedTournPayout == _o.timedTournPayout &&
		isFlightTourn == _o.isFlightTourn &&
		Atf::atfPStringEquals(tournBrand, _o.tournBrand) &&
		scalePM == _o.scalePM &&
		progressiveKnockout == _o.progressiveKnockout &&
		awardScheme == _o.awardScheme &&
		numReentries == _o.numReentries &&
		Atf::atfPStringEquals(internalReference, _o.internalReference) &&
		Atf::atfPStringEquals(favReference, _o.favReference) &&
		Atf::atfPStringEquals(satelliteTargetName, _o.satelliteTargetName) &&
		admissionPrice == _o.admissionPrice &&
		tournFlags2 == _o.tournFlags2 &&
		regEndAbs.equals(_o.regEndAbs) &&
		regEndAbsInt == _o.regEndAbsInt &&
		doNotAllowToUnreg == _o.doNotAllowToUnreg &&
		nStackInfo.equals(_o.nStackInfo) &&
		tournMask5 == _o.tournMask5 &&
		tournMask6 == _o.tournMask6 &&
		Atf::atfPStringEquals(satelliteTargetNameMTT, _o.satelliteTargetNameMTT) &&
		liveEventMask == _o.liveEventMask &&
		timedTournPlayersPercent == _o.timedTournPlayersPercent &&
		dummy1 == _o.dummy1 &&
		rmPmLobby == _o.rmPmLobby &&
		brandAccessMask == _o.brandAccessMask &&
		activeFlags == _o.activeFlags &&
		sngScriptId == _o.sngScriptId &&
		Atf::atfPStringEquals(customSpeedDisplayName, _o.customSpeedDisplayName) &&
		tournSitesEx.equals(_o.tournSitesEx);
}

const char *MLobby::cli::TournStaticData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournamentId=");
	_buf.appendUint(tournamentId);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("targetServer=");
	_buf.append(targetServer);
	_buf.append(',');
	_buf.append("hasSatellite=");
	_buf.append(hasSatellite);
	_buf.append(',');
	_buf.append("whenStart=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, whenStart);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendUint(buyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendUint(rake);
	_buf.append(',');
	_buf.append("fppBuyIn=");
	_buf.appendUint(fppBuyIn);
	_buf.append(',');
	_buf.append("isRestricted=");
	_buf.appendUint(isRestricted);
	_buf.append(',');
	_buf.append("isPwdProtected=");
	_buf.appendUint(isPwdProtected);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("admissionId=");
	_buf.append(admissionId);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("satelliteTarget=");
	_buf.appendUint(satelliteTarget);
	_buf.append(',');
	_buf.append("minPlayers=");
	_buf.appendUint(minPlayers);
	_buf.append(',');
	_buf.append("tournFlags=");
	_buf.appendUint(tournFlags);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("tournMask=");
	_buf.appendUint(tournMask);
	_buf.append(',');
	_buf.append("tournSites=");
	_buf.appendUint(tournSites);
	_buf.append(',');
	_buf.append("whenStartInt=");
	_buf.appendUint(whenStartInt);
	_buf.append(',');
	_buf.append("tournMask2=");
	_buf.appendUint(tournMask2);
	_buf.append(',');
	_buf.append("targetWhenStart=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, targetWhenStart);
	_buf.append(',');
	_buf.append("tournMask3=");
	_buf.appendUint(tournMask3);
	_buf.append(',');
	_buf.append("tournMask4=");
	_buf.appendUint(tournMask4);
	_buf.append(',');
	_buf.append("maxPerTable=");
	_buf.appendUint(maxPerTable);
	_buf.append(',');
	_buf.append("countryRestrictionInverted=");
	_buf.appendUint(countryRestrictionInverted);
	_buf.append(',');
	_buf.append("restrictedCountries=");
	restrictedCountries.toTraceString(_buf);
	_buf.append(',');
	_buf.append("hasDayTwoStart=");
	_buf.appendUint(hasDayTwoStart);
	_buf.append(',');
	_buf.append("dayTwoStartSec=");
	_buf.appendUint(dayTwoStartSec);
	_buf.append(',');
	_buf.append("dayTwoStart=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, dayTwoStart);
	_buf.append(',');
	_buf.append("shortText=");
	Atf::AtfTempl<I18nPString>::ToTraceString(_buf, shortText);
	_buf.append(',');
	_buf.append("chatLang=");
	_buf.appendUint(chatLang);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("tournFlagsServInt=");
	_buf.appendUint(tournFlagsServInt);
	_buf.append(',');
	_buf.append("knockout=");
	_buf.appendUint(knockout);
	_buf.append(',');
	_buf.append("satelliteTargetReference=");
	_buf.append(satelliteTargetReference);
	_buf.append(',');
	_buf.append("satelliteTargetReferenceLock=");
	_buf.appendUint(satelliteTargetReferenceLock);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendUint(maxPlayers);
	_buf.append(',');
	_buf.append("speedDisplay=");
	_buf.appendUint(speedDisplay);
	_buf.append(',');
	_buf.append("nameSnG=");
	Atf::AtfTempl<I18nPString>::ToTraceString(_buf, nameSnG);
	_buf.append(',');
	_buf.append("step=");
	_buf.appendUint(step);
	_buf.append(',');
	_buf.append("timedTournType=");
	_buf.appendUint(timedTournType);
	_buf.append(',');
	_buf.append("timedTournTime=");
	_buf.appendUint(timedTournTime);
	_buf.append(',');
	_buf.append("timedTournPayout=");
	_buf.appendUint(timedTournPayout);
	_buf.append(',');
	_buf.append("isFlightTourn=");
	_buf.appendUint(isFlightTourn);
	_buf.append(',');
	_buf.append("tournBrand=");
	_buf.append(tournBrand);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("progressiveKnockout=");
	_buf.appendUint(progressiveKnockout);
	_buf.append(',');
	_buf.append("awardScheme=");
	_buf.appendUint(awardScheme);
	_buf.append(',');
	_buf.append("numReentries=");
	_buf.appendUint(numReentries);
	_buf.append(',');
	_buf.append("internalReference=");
	_buf.append(internalReference);
	_buf.append(',');
	_buf.append("favReference=");
	_buf.append(favReference);
	_buf.append(',');
	_buf.append("satelliteTargetName=");
	_buf.append(satelliteTargetName);
	_buf.append(',');
	_buf.append("admissionPrice=");
	_buf.appendInt64(admissionPrice);
	_buf.append(',');
	_buf.append("tournFlags2=");
	_buf.appendUint64(tournFlags2);
	_buf.append(',');
	_buf.append("regEndAbs=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, regEndAbs);
	_buf.append(',');
	_buf.append("regEndAbsInt=");
	_buf.appendUint(regEndAbsInt);
	_buf.append(',');
	_buf.append("doNotAllowToUnreg=");
	_buf.appendUint(doNotAllowToUnreg);
	_buf.append(',');
	_buf.append("nStackInfo=");
	nStackInfo.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tournMask5=");
	_buf.appendUint(tournMask5);
	_buf.append(',');
	_buf.append("tournMask6=");
	_buf.appendUint(tournMask6);
	_buf.append(',');
	_buf.append("satelliteTargetNameMTT=");
	_buf.append(satelliteTargetNameMTT);
	_buf.append(',');
	_buf.append("liveEventMask=");
	_buf.appendUint(liveEventMask);
	_buf.append(',');
	_buf.append("timedTournPlayersPercent=");
	_buf.appendUint(timedTournPlayersPercent);
	_buf.append(',');
	_buf.append("dummy1=");
	_buf.appendUint(dummy1);
	_buf.append(',');
	_buf.append("rmPmLobby=");
	_buf.appendUint(rmPmLobby);
	_buf.append(',');
	_buf.append("brandAccessMask=");
	_buf.appendUint(brandAccessMask);
	_buf.append(',');
	_buf.append("activeFlags=");
	_buf.appendUint(activeFlags);
	_buf.append(',');
	_buf.append("sngScriptId=");
	_buf.appendUint(sngScriptId);
	_buf.append(',');
	_buf.append("customSpeedDisplayName=");
	_buf.append(customSpeedDisplayName);
	_buf.append(',');
	_buf.append("tournSitesEx=");
	tournSitesEx.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobby::cli::TournStaticData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("tournamentId", tournamentId, _buf);
	Atf::XmlElement::encodeAsXmlElement("server", server, _buf);
	Atf::XmlElement::encodeAsXmlElement("targetServer", targetServer, _buf);
	Atf::XmlElement::encodeAsXmlElement("hasSatellite", hasSatellite, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "whenStart", whenStart);
	Atf::XmlElement::encodeAsXmlElement("buyIn", buyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("rake", rake, _buf);
	Atf::XmlElement::encodeAsXmlElement("fppBuyIn", fppBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("isRestricted", isRestricted, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPwdProtected", isPwdProtected, _buf);
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	Atf::XmlElement::encodeAsXmlElement("admissionId", admissionId, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("satelliteTarget", satelliteTarget, _buf);
	Atf::XmlElement::encodeAsXmlElement("minPlayers", minPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournFlags", tournFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMask", tournMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournSites", tournSites, _buf);
	Atf::XmlElement::encodeAsXmlElement("whenStartInt", whenStartInt, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMask2", tournMask2, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "targetWhenStart", targetWhenStart);
	Atf::XmlElement::encodeAsXmlElement("tournMask3", tournMask3, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMask4", tournMask4, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPerTable", maxPerTable, _buf);
	Atf::XmlElement::encodeAsXmlElement("countryRestrictionInverted", countryRestrictionInverted, _buf);
	restrictedCountries.toXmlString("restrictedCountries", _buf);
	Atf::XmlElement::encodeAsXmlElement("hasDayTwoStart", hasDayTwoStart, _buf);
	Atf::XmlElement::encodeAsXmlElement("dayTwoStartSec", dayTwoStartSec, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "dayTwoStart", dayTwoStart);
	Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "shortText", shortText);
	Atf::XmlElement::encodeAsXmlElement("chatLang", chatLang, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournFlagsServInt", tournFlagsServInt, _buf);
	Atf::XmlElement::encodeAsXmlElement("knockout", knockout, _buf);
	Atf::XmlElement::encodeAsXmlElement("satelliteTargetReference", satelliteTargetReference, _buf);
	Atf::XmlElement::encodeAsXmlElement("satelliteTargetReferenceLock", satelliteTargetReferenceLock, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPlayers", maxPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("speedDisplay", speedDisplay, _buf);
	Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "nameSnG", nameSnG);
	Atf::XmlElement::encodeAsXmlElement("step", step, _buf);
	Atf::XmlElement::encodeAsXmlElement("timedTournType", timedTournType, _buf);
	Atf::XmlElement::encodeAsXmlElement("timedTournTime", timedTournTime, _buf);
	Atf::XmlElement::encodeAsXmlElement("timedTournPayout", timedTournPayout, _buf);
	Atf::XmlElement::encodeAsXmlElement("isFlightTourn", isFlightTourn, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournBrand", tournBrand, _buf);
	Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
	Atf::XmlElement::encodeAsXmlElement("progressiveKnockout", progressiveKnockout, _buf);
	Atf::XmlElement::encodeAsXmlElement("awardScheme", awardScheme, _buf);
	Atf::XmlElement::encodeAsXmlElement("numReentries", numReentries, _buf);
	Atf::XmlElement::encodeAsXmlElement("internalReference", internalReference, _buf);
	Atf::XmlElement::encodeAsXmlElement("favReference", favReference, _buf);
	Atf::XmlElement::encodeAsXmlElement("satelliteTargetName", satelliteTargetName, _buf);
	Atf::XmlElement::encodeAsXmlElement("admissionPrice", admissionPrice, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournFlags2", tournFlags2, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "regEndAbs", regEndAbs);
	Atf::XmlElement::encodeAsXmlElement("regEndAbsInt", regEndAbsInt, _buf);
	Atf::XmlElement::encodeAsXmlElement("doNotAllowToUnreg", doNotAllowToUnreg, _buf);
	nStackInfo.toXmlString("nStackInfo", _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMask5", tournMask5, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMask6", tournMask6, _buf);
	Atf::XmlElement::encodeAsXmlElement("satelliteTargetNameMTT", satelliteTargetNameMTT, _buf);
	Atf::XmlElement::encodeAsXmlElement("liveEventMask", liveEventMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("timedTournPlayersPercent", timedTournPlayersPercent, _buf);
	Atf::XmlElement::encodeAsXmlElement("dummy1", dummy1, _buf);
	Atf::XmlElement::encodeAsXmlElement("rmPmLobby", rmPmLobby, _buf);
	Atf::XmlElement::encodeAsXmlElement("brandAccessMask", brandAccessMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("activeFlags", activeFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("sngScriptId", sngScriptId, _buf);
	Atf::XmlElement::encodeAsXmlElement("customSpeedDisplayName", customSpeedDisplayName, _buf);
	tournSitesEx.toXmlString("tournSitesEx", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobby::cli::TournStaticData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		switch((BYTE)*_element)
		{
		case 'a':
			if (_element.equals("admissionId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, admissionId)) return false;
			}
			else if (_element.equals("awardScheme"))
			{
				awardScheme = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("admissionPrice"))
			{
				admissionPrice = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("activeFlags"))
			{
				activeFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'b':
			if (_element.equals("buyIn"))
			{
				buyIn = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("brandAccessMask"))
			{
				brandAccessMask = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'c':
			if (_element.equals("countryRestrictionInverted"))
			{
				countryRestrictionInverted = (*_value.ptr() == '1');
			}
			else if (_element.equals("chatLang"))
			{
				chatLang = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else if (_element.equals("customSpeedDisplayName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, customSpeedDisplayName)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'd':
			if (_element.equals("dayTwoStartSec"))
			{
				dayTwoStartSec = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("dayTwoStart"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, dayTwoStart);
			}
			else if (_element.equals("doNotAllowToUnreg"))
			{
				doNotAllowToUnreg = (*_value.ptr() == '1');
			}
			else if (_element.equals("dummy1"))
			{
				dummy1 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'f':
			if (_element.equals("fppBuyIn"))
			{
				fppBuyIn = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("favReference"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, favReference)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'g':
			if (_element.equals("game"))
			{
				game = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'h':
			if (_element.equals("hasSatellite"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, hasSatellite)) return false;
			}
			else if (_element.equals("hasDayTwoStart"))
			{
				hasDayTwoStart = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'i':
			if (_element.equals("isRestricted"))
			{
				isRestricted = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isPwdProtected"))
			{
				isPwdProtected = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isPlayMoney"))
			{
				isPlayMoney = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isHiLo"))
			{
				isHiLo = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isFlightTourn"))
			{
				isFlightTourn = (*_value.ptr() == '1');
			}
			else if (_element.equals("internalReference"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, internalReference)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'k':
			if (_element.equals("knockout"))
			{
				knockout = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'l':
			if (_element.equals("liveEventMask"))
			{
				liveEventMask = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'm':
			if (_element.equals("minPlayers"))
			{
				minPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxPerTable"))
			{
				maxPerTable = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxPlayers"))
			{
				maxPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'n':
			if (_element.equals("name"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
			}
			else if (_element.equals("nameSnG"))
			{
				Atf::AtfTempl<I18nPString>::FromXmlString(_value, nameSnG);
			}
			else if (_element.equals("numReentries"))
			{
				numReentries = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("nStackInfo"))
			{
				if(!Atf::AtfTempl< TournClient::NStackTournInfoStruct >::FromXmlString(_value, nStackInfo)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'p':
			if (_element.equals("progressiveKnockout"))
			{
				progressiveKnockout = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'r':
			if (_element.equals("rake"))
			{
				rake = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("restrictedCountries"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< PString , 4 > >::FromXmlString(_value, restrictedCountries)) return false;
			}
			else if (_element.equals("regEndAbs"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, regEndAbs);
			}
			else if (_element.equals("regEndAbsInt"))
			{
				regEndAbsInt = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("rmPmLobby"))
			{
				rmPmLobby = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 's':
			if (_element.equals("server"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, server)) return false;
			}
			else if (_element.equals("satelliteTarget"))
			{
				satelliteTarget = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("structure"))
			{
				structure = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("shortText"))
			{
				Atf::AtfTempl<I18nPString>::FromXmlString(_value, shortText);
			}
			else if (_element.equals("satelliteTargetReference"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, satelliteTargetReference)) return false;
			}
			else if (_element.equals("satelliteTargetReferenceLock"))
			{
				satelliteTargetReferenceLock = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("speedDisplay"))
			{
				speedDisplay = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("step"))
			{
				step = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("scalePM"))
			{
				scalePM = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("satelliteTargetName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, satelliteTargetName)) return false;
			}
			else if (_element.equals("satelliteTargetNameMTT"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, satelliteTargetNameMTT)) return false;
			}
			else if (_element.equals("sngScriptId"))
			{
				sngScriptId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 't':
			if (_element.equals("tournamentId"))
			{
				tournamentId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("targetServer"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, targetServer)) return false;
			}
			else if (_element.equals("tournFlags"))
			{
				tournFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournMask"))
			{
				tournMask = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournSites"))
			{
				tournSites = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournMask2"))
			{
				tournMask2 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("targetWhenStart"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, targetWhenStart);
			}
			else if (_element.equals("tournMask3"))
			{
				tournMask3 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournMask4"))
			{
				tournMask4 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournFlagsServInt"))
			{
				tournFlagsServInt = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("timedTournType"))
			{
				timedTournType = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("timedTournTime"))
			{
				timedTournTime = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("timedTournPayout"))
			{
				timedTournPayout = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournBrand"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tournBrand)) return false;
			}
			else if (_element.equals("tournFlags2"))
			{
				tournFlags2 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournMask5"))
			{
				tournMask5 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournMask6"))
			{
				tournMask6 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("timedTournPlayersPercent"))
			{
				timedTournPlayersPercent = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournSitesEx"))
			{
				if(!Atf::AtfTempl< PSiteMask >::FromXmlString(_value, tournSitesEx)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'w':
			if (_element.equals("whenStart"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, whenStart);
			}
			else if (_element.equals("whenStartInt"))
			{
				whenStartInt = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		default:
			return false;
		}
	}
	return true;
}

void MLobby::cli::TournStaticData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(TournStaticData())) // not empty
	{
		_body.composeUINT32(tournamentId);
		_body.composeString(server);
		_body.composeString(targetServer);
		_body.composeString(hasSatellite);
		_body.composeSrvTime(whenStart);
		_body.composeUINT32(buyIn);
		_body.composeUINT32(rake);
		_body.composeUINT32(fppBuyIn);
		_body.composeBYTE(isRestricted);
		_body.composeBYTE(isPwdProtected);
		_body.composeString(name);
		_body.composeString(admissionId);
		_body.composeBYTE(isPlayMoney);
		_body.composeUINT32(satelliteTarget);
		_body.composeUINT32(minPlayers);
		_body.composeUINT32(tournFlags);
		_body.composeBYTE(game);
		_body.composeBYTE(isHiLo);
		_body.composeBYTE(structure);
		_body.composeUINT32(tournMask);
		_body.composeUINT32(tournSites);
		_body.composeUINT32(whenStartInt);
		_body.composeUINT32(tournMask2);
		_body.composeSrvTime(targetWhenStart);
		_body.composeUINT32(tournMask3);
		_body.composeUINT32(tournMask4);
		_body.composeUINT32(maxPerTable);
		_body.composeBOOL(countryRestrictionInverted);
		restrictedCountries.composeMsg(_body, _ignoreJSON);
		_body.composeBYTE(hasDayTwoStart);
		_body.composeUINT32(dayTwoStartSec);
		_body.composeSrvTime(dayTwoStart);
		shortText.compose(_body);
		_body.composeUINT16(chatLang);
		_body.composeString(currency);
		_body.composeUINT32(tournFlagsServInt);
		_body.composeUINT32(knockout);
		_body.composeString(satelliteTargetReference);
		_body.composeUINT16(satelliteTargetReferenceLock);
		_body.composeUINT32(maxPlayers);
		_body.composeBYTE(speedDisplay);
		nameSnG.compose(_body);
		_body.composeBYTE(step);
		_body.composeBYTE(timedTournType);
		_body.composeUINT16(timedTournTime);
		_body.composeBYTE(timedTournPayout);
		_body.composeBOOL(isFlightTourn);
		_body.composeString(tournBrand);
		_body.composeUINT32(scalePM);
		_body.composeBYTE(progressiveKnockout);
		_body.composeBYTE(awardScheme);
		_body.composeUINT16(numReentries);
		_body.composeString(internalReference);
		_body.composeString(favReference);
		_body.composeString(satelliteTargetName);
		_body.composeINT64(admissionPrice);
		_body.composeUINT64(tournFlags2);
		_body.composeSrvTime(regEndAbs);
		_body.composeUINT32(regEndAbsInt);
		_body.composeBOOL(doNotAllowToUnreg);
		nStackInfo.composeMsg(_body, _ignoreJSON);
		_body.composeUINT32(tournMask5);
		_body.composeUINT32(tournMask6);
		_body.composeString(satelliteTargetNameMTT);
		_body.composeUINT32(liveEventMask);
		_body.composeBYTE(timedTournPlayersPercent);
		_body.composeUINT32(dummy1);
		_body.composeBYTE(rmPmLobby);
		_body.composeUINT32(brandAccessMask);
		_body.composeUINT32(activeFlags);
		_body.composeUINT32(sngScriptId);
		_body.composeString(customSpeedDisplayName);
		tournSitesEx.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::TournStaticData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(tournamentId);
	_parser0.parseStringP(server);
	_parser0.parseStringP(targetServer);
	_parser0.parseStringP(hasSatellite);
	_parser0.parseSrvTime(whenStart);
	_parser0.parseUINT32(buyIn);
	_parser0.parseUINT32(rake);
	_parser0.parseUINT32(fppBuyIn);
	_parser0.parseBYTE(isRestricted);
	_parser0.parseBYTE(isPwdProtected);
	_parser0.parseStringP(name);
	_parser0.parseStringP(admissionId);
	_parser0.parseBYTE(isPlayMoney);
	_parser0.parseUINT32(satelliteTarget);
	_parser0.parseUINT32(minPlayers);
	_parser0.parseUINT32(tournFlags);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(isHiLo);
	_parser0.parseBYTE(structure);
	_parser0.parseUINT32(tournMask);
	_parser0.parseUINT32(tournSites);
	_parser0.parseUINT32(whenStartInt);
	_parser0.parseUINT32(tournMask2);
	_parser0.parseSrvTime(targetWhenStart);
	_parser0.parseUINT32(tournMask3);
	_parser0.parseUINT32(tournMask4);
	_parser0.parseUINT32(maxPerTable);
	_parser0.parseBOOL(countryRestrictionInverted);
	restrictedCountries.parseMsg(_parser0);
	_parser0.parseBYTE(hasDayTwoStart);
	_parser0.parseUINT32(dayTwoStartSec);
	_parser0.parseSrvTime(dayTwoStart);
	shortText.parse(_parser0);
	_parser0.parseUINT16(chatLang);
	_parser0.parseStringP(currency);
	_parser0.parseUINT32(tournFlagsServInt);
	_parser0.parseUINT32(knockout);
	_parser0.parseStringP(satelliteTargetReference);
	_parser0.parseUINT16(satelliteTargetReferenceLock);
	_parser0.parseUINT32(maxPlayers);
	_parser0.parseBYTE(speedDisplay);
	nameSnG.parse(_parser0);
	_parser0.parseBYTE(step);
	_parser0.parseBYTE(timedTournType);
	_parser0.parseUINT16(timedTournTime);
	_parser0.parseBYTE(timedTournPayout);
	_parser0.parseBOOL(isFlightTourn);
	_parser0.parseStringP(tournBrand);
	_parser0.parseUINT32(scalePM);
	_parser0.parseBYTE(progressiveKnockout);
	_parser0.parseBYTE(awardScheme);
	_parser0.parseUINT16(numReentries);
	_parser0.parseStringP(internalReference);
	_parser0.parseStringP(favReference);
	_parser0.parseStringP(satelliteTargetName);
	_parser0.parseINT64(admissionPrice);
	_parser0.parseUINT64(tournFlags2);
	_parser0.parseSrvTime(regEndAbs);
	_parser0.parseUINT32(regEndAbsInt);
	_parser0.parseBOOL(doNotAllowToUnreg);
	nStackInfo.parseMsg(_parser0);
	_parser0.parseUINT32(tournMask5);
	_parser0.parseUINT32(tournMask6);
	_parser0.parseStringP(satelliteTargetNameMTT);
	_parser0.parseUINT32(liveEventMask);
	_parser0.parseBYTE(timedTournPlayersPercent);
	_parser0.parseUINT32(dummy1);
	_parser0.parseBYTE(rmPmLobby);
	_parser0.parseUINT32(brandAccessMask);
	_parser0.parseUINT32(activeFlags);
	_parser0.parseUINT32(sngScriptId);
	_parser0.parseStringP(customSpeedDisplayName);
	if(_parser0.parseEnded()) return;
	tournSitesEx.parseMsg(_parser0);
}

const char *MLobby::cli::TournStaticData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tournamentId", tournamentId);
	_jsonstr.compose("server", server);
	_jsonstr.compose("targetServer", targetServer);
	_jsonstr.compose("hasSatellite", hasSatellite);
	_jsonstr.compose("whenStart", whenStart);
	_jsonstr.compose("buyIn", buyIn);
	_jsonstr.compose("rake", rake);
	_jsonstr.compose("fppBuyIn", fppBuyIn);
	_jsonstr.compose("isRestricted", isRestricted);
	_jsonstr.compose("isPwdProtected", isPwdProtected);
	_jsonstr.compose("name", name);
	_jsonstr.compose("admissionId", admissionId);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("satelliteTarget", satelliteTarget);
	_jsonstr.compose("minPlayers", minPlayers);
	_jsonstr.compose("tournFlags", tournFlags);
	_jsonstr.compose("game", game);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("tournMask", tournMask);
	_jsonstr.compose("tournSites", tournSites);
	_jsonstr.compose("whenStartInt", whenStartInt);
	_jsonstr.compose("tournMask2", tournMask2);
	_jsonstr.compose("targetWhenStart", targetWhenStart);
	_jsonstr.compose("tournMask3", tournMask3);
	_jsonstr.compose("tournMask4", tournMask4);
	_jsonstr.compose("maxPerTable", maxPerTable);
	_jsonstr.compose("countryRestrictionInverted", countryRestrictionInverted);
	_jsonstr.compose("restrictedCountries", restrictedCountries);
	_jsonstr.compose("hasDayTwoStart", hasDayTwoStart);
	_jsonstr.compose("dayTwoStartSec", dayTwoStartSec);
	_jsonstr.compose("dayTwoStart", dayTwoStart);
	_jsonstr.compose("shortText", shortText);
	_jsonstr.compose("chatLang", chatLang);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("tournFlagsServInt", tournFlagsServInt);
	_jsonstr.compose("knockout", knockout);
	_jsonstr.compose("satelliteTargetReference", satelliteTargetReference);
	_jsonstr.compose("satelliteTargetReferenceLock", satelliteTargetReferenceLock);
	_jsonstr.compose("maxPlayers", maxPlayers);
	_jsonstr.compose("speedDisplay", speedDisplay);
	_jsonstr.compose("nameSnG", nameSnG);
	_jsonstr.compose("step", step);
	_jsonstr.compose("timedTournType", timedTournType);
	_jsonstr.compose("timedTournTime", timedTournTime);
	_jsonstr.compose("timedTournPayout", timedTournPayout);
	_jsonstr.compose("isFlightTourn", isFlightTourn);
	_jsonstr.compose("tournBrand", tournBrand);
	_jsonstr.compose("scalePM", scalePM);
	_jsonstr.compose("progressiveKnockout", progressiveKnockout);
	_jsonstr.compose("awardScheme", awardScheme);
	_jsonstr.compose("numReentries", numReentries);
	_jsonstr.compose("internalReference", internalReference);
	_jsonstr.compose("favReference", favReference);
	_jsonstr.compose("satelliteTargetName", satelliteTargetName);
	_jsonstr.compose("admissionPrice", admissionPrice);
	_jsonstr.compose("tournFlags2", tournFlags2);
	_jsonstr.compose("regEndAbs", regEndAbs);
	_jsonstr.compose("regEndAbsInt", regEndAbsInt);
	_jsonstr.compose("doNotAllowToUnreg", doNotAllowToUnreg);
	_jsonstr.compose("nStackInfo", nStackInfo);
	_jsonstr.compose("tournMask5", tournMask5);
	_jsonstr.compose("tournMask6", tournMask6);
	_jsonstr.compose("satelliteTargetNameMTT", satelliteTargetNameMTT);
	_jsonstr.compose("liveEventMask", liveEventMask);
	_jsonstr.compose("timedTournPlayersPercent", timedTournPlayersPercent);
	_jsonstr.compose("dummy1", dummy1);
	_jsonstr.compose("rmPmLobby", rmPmLobby);
	_jsonstr.compose("brandAccessMask", brandAccessMask);
	_jsonstr.compose("activeFlags", activeFlags);
	_jsonstr.compose("sngScriptId", sngScriptId);
	_jsonstr.compose("customSpeedDisplayName", customSpeedDisplayName);
	_jsonstr.compose("tournSitesEx", tournSitesEx);
	return _buf.c_str();
}

void MLobby::cli::TournStaticData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tournamentId", tournamentId);
	_jparser.parseByNameThrow("server", server);
	_jparser.parseByNameThrow("targetServer", targetServer);
	_jparser.parseByNameThrow("hasSatellite", hasSatellite);
	_jparser.parseByNameThrow("whenStart", whenStart);
	_jparser.parseByNameThrow("buyIn", buyIn);
	_jparser.parseByNameThrow("rake", rake);
	_jparser.parseByNameThrow("fppBuyIn", fppBuyIn);
	_jparser.parseByNameThrow("isRestricted", isRestricted);
	_jparser.parseByNameThrow("isPwdProtected", isPwdProtected);
	_jparser.parseByNameThrow("name", name);
	_jparser.parseByNameThrow("admissionId", admissionId);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("satelliteTarget", satelliteTarget);
	_jparser.parseByNameThrow("minPlayers", minPlayers);
	_jparser.parseByNameThrow("tournFlags", tournFlags);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("tournMask", tournMask);
	_jparser.parseByNameThrow("tournSites", tournSites);
	_jparser.parseByNameThrow("whenStartInt", whenStartInt);
	_jparser.parseByNameThrow("tournMask2", tournMask2);
	_jparser.parseByNameThrow("targetWhenStart", targetWhenStart);
	_jparser.parseByNameThrow("tournMask3", tournMask3);
	_jparser.parseByNameThrow("tournMask4", tournMask4);
	_jparser.parseByNameThrow("maxPerTable", maxPerTable);
	_jparser.parseByNameThrow("countryRestrictionInverted", countryRestrictionInverted);
	_jparser.parseByNameThrow("restrictedCountries", restrictedCountries);
	_jparser.parseByNameThrow("hasDayTwoStart", hasDayTwoStart);
	_jparser.parseByNameThrow("dayTwoStartSec", dayTwoStartSec);
	_jparser.parseByNameThrow("dayTwoStart", dayTwoStart);
	_jparser.parseByNameThrow("shortText", shortText);
	_jparser.parseByNameThrow("chatLang", chatLang);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("tournFlagsServInt", tournFlagsServInt);
	_jparser.parseByNameThrow("knockout", knockout);
	_jparser.parseByNameThrow("satelliteTargetReference", satelliteTargetReference);
	_jparser.parseByNameThrow("satelliteTargetReferenceLock", satelliteTargetReferenceLock);
	_jparser.parseByNameThrow("maxPlayers", maxPlayers);
	_jparser.parseByNameThrow("speedDisplay", speedDisplay);
	_jparser.parseByNameThrow("nameSnG", nameSnG);
	_jparser.parseByNameThrow("step", step);
	_jparser.parseByNameThrow("timedTournType", timedTournType);
	_jparser.parseByNameThrow("timedTournTime", timedTournTime);
	_jparser.parseByNameThrow("timedTournPayout", timedTournPayout);
	_jparser.parseByNameThrow("isFlightTourn", isFlightTourn);
	_jparser.parseByNameThrow("tournBrand", tournBrand);
	_jparser.parseByNameThrow("scalePM", scalePM);
	_jparser.parseByNameThrow("progressiveKnockout", progressiveKnockout);
	_jparser.parseByNameThrow("awardScheme", awardScheme);
	_jparser.parseByNameThrow("numReentries", numReentries);
	_jparser.parseByNameThrow("internalReference", internalReference);
	_jparser.parseByNameThrow("favReference", favReference);
	_jparser.parseByNameThrow("satelliteTargetName", satelliteTargetName);
	_jparser.parseByNameThrow("admissionPrice", admissionPrice);
	_jparser.parseByNameThrow("tournFlags2", tournFlags2);
	_jparser.parseByNameThrow("regEndAbs", regEndAbs);
	_jparser.parseByNameThrow("regEndAbsInt", regEndAbsInt);
	_jparser.parseByNameThrow("doNotAllowToUnreg", doNotAllowToUnreg);
	_jparser.parseByNameThrow("nStackInfo", nStackInfo);
	_jparser.parseByNameThrow("tournMask5", tournMask5);
	_jparser.parseByNameThrow("tournMask6", tournMask6);
	_jparser.parseByNameThrow("satelliteTargetNameMTT", satelliteTargetNameMTT);
	_jparser.parseByNameThrow("liveEventMask", liveEventMask);
	_jparser.parseByNameThrow("timedTournPlayersPercent", timedTournPlayersPercent);
	_jparser.parseByNameThrow("dummy1", dummy1);
	_jparser.parseByNameThrow("rmPmLobby", rmPmLobby);
	_jparser.parseByNameThrow("brandAccessMask", brandAccessMask);
	_jparser.parseByNameThrow("activeFlags", activeFlags);
	_jparser.parseByNameThrow("sngScriptId", sngScriptId);
	_jparser.parseByNameThrow("customSpeedDisplayName", customSpeedDisplayName);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tournSitesEx", tournSitesEx);
}

/* static */ void MLobby::cli::TournStaticData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tournamentId; _jparser.validateByNameThrow("tournamentId", tournamentId);
	AtfValidator::validateInt(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
	PString server; _jparser.validateByNameThrow("server", server);
	AtfValidator::validateInt(_descr, "server", server.length(), _checker, __FILE__, __LINE__);
	PString targetServer; _jparser.validateByNameThrow("targetServer", targetServer);
	AtfValidator::validateInt(_descr, "targetServer", targetServer.length(), _checker, __FILE__, __LINE__);
	PString hasSatellite; _jparser.validateByNameThrow("hasSatellite", hasSatellite);
	AtfValidator::validateInt(_descr, "hasSatellite", hasSatellite.length(), _checker, __FILE__, __LINE__);
	SrvTime whenStart; _jparser.validateByNameThrow("whenStart", whenStart);
	AtfValidator::validateSrvDateTime(_descr, "whenStart", whenStart, _checker, __FILE__, __LINE__);
	UINT32 buyIn; _jparser.validateByNameThrow("buyIn", buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT32 rake; _jparser.validateByNameThrow("rake", rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	UINT32 fppBuyIn; _jparser.validateByNameThrow("fppBuyIn", fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	BYTE isRestricted; _jparser.validateByNameThrow("isRestricted", isRestricted);
	AtfValidator::validateInt(_descr, "isRestricted", isRestricted, _checker, __FILE__, __LINE__);
	BYTE isPwdProtected; _jparser.validateByNameThrow("isPwdProtected", isPwdProtected);
	AtfValidator::validateInt(_descr, "isPwdProtected", isPwdProtected, _checker, __FILE__, __LINE__);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateInt(_descr, "name", name.length(), _checker, __FILE__, __LINE__);
	PString admissionId; _jparser.validateByNameThrow("admissionId", admissionId);
	AtfValidator::validateInt(_descr, "admissionId", admissionId.length(), _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 satelliteTarget; _jparser.validateByNameThrow("satelliteTarget", satelliteTarget);
	AtfValidator::validateInt(_descr, "satelliteTarget", satelliteTarget, _checker, __FILE__, __LINE__);
	UINT32 minPlayers; _jparser.validateByNameThrow("minPlayers", minPlayers);
	AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
	UINT32 tournFlags; _jparser.validateByNameThrow("tournFlags", tournFlags);
	AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	UINT32 tournMask; _jparser.validateByNameThrow("tournMask", tournMask);
	AtfValidator::validateInt(_descr, "tournMask", tournMask, _checker, __FILE__, __LINE__);
	UINT32 tournSites; _jparser.validateByNameThrow("tournSites", tournSites);
	AtfValidator::validateInt(_descr, "tournSites", tournSites, _checker, __FILE__, __LINE__);
	UINT32 whenStartInt; _jparser.validateByNameThrow("whenStartInt", whenStartInt);
	AtfValidator::validateInt(_descr, "whenStartInt", whenStartInt, _checker, __FILE__, __LINE__);
	UINT32 tournMask2; _jparser.validateByNameThrow("tournMask2", tournMask2);
	AtfValidator::validateInt(_descr, "tournMask2", tournMask2, _checker, __FILE__, __LINE__);
	SrvTime targetWhenStart; _jparser.validateByNameThrow("targetWhenStart", targetWhenStart);
	AtfValidator::validateSrvDateTime(_descr, "targetWhenStart", targetWhenStart, _checker, __FILE__, __LINE__);
	UINT32 tournMask3; _jparser.validateByNameThrow("tournMask3", tournMask3);
	AtfValidator::validateInt(_descr, "tournMask3", tournMask3, _checker, __FILE__, __LINE__);
	UINT32 tournMask4; _jparser.validateByNameThrow("tournMask4", tournMask4);
	AtfValidator::validateInt(_descr, "tournMask4", tournMask4, _checker, __FILE__, __LINE__);
	UINT32 maxPerTable; _jparser.validateByNameThrow("maxPerTable", maxPerTable);
	AtfValidator::validateInt(_descr, "maxPerTable", maxPerTable, _checker, __FILE__, __LINE__);
	bool countryRestrictionInverted; _jparser.validateByNameThrow("countryRestrictionInverted", countryRestrictionInverted);
	AtfValidator::validateInt(_descr, "countryRestrictionInverted", countryRestrictionInverted, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PString > restrictedCountries; _jparser.validateByNameThrow("restrictedCountries", restrictedCountries);
	AtfValidator::validateInt(_descr, "restrictedCountries", restrictedCountries.size(), _checker, __FILE__, __LINE__);
	BYTE hasDayTwoStart; _jparser.validateByNameThrow("hasDayTwoStart", hasDayTwoStart);
	AtfValidator::validateInt(_descr, "hasDayTwoStart", hasDayTwoStart, _checker, __FILE__, __LINE__);
	UINT32 dayTwoStartSec; _jparser.validateByNameThrow("dayTwoStartSec", dayTwoStartSec);
	AtfValidator::validateInt(_descr, "dayTwoStartSec", dayTwoStartSec, _checker, __FILE__, __LINE__);
	SrvTime dayTwoStart; _jparser.validateByNameThrow("dayTwoStart", dayTwoStart);
	AtfValidator::validateSrvDateTime(_descr, "dayTwoStart", dayTwoStart, _checker, __FILE__, __LINE__);
	I18nPString shortText; _jparser.validateByNameThrow("shortText", shortText);
	UINT16 chatLang; _jparser.validateByNameThrow("chatLang", chatLang);
	AtfValidator::validateInt(_descr, "chatLang", chatLang, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	UINT32 tournFlagsServInt; _jparser.validateByNameThrow("tournFlagsServInt", tournFlagsServInt);
	AtfValidator::validateInt(_descr, "tournFlagsServInt", tournFlagsServInt, _checker, __FILE__, __LINE__);
	UINT32 knockout; _jparser.validateByNameThrow("knockout", knockout);
	AtfValidator::validateInt(_descr, "knockout", knockout, _checker, __FILE__, __LINE__);
	PString satelliteTargetReference; _jparser.validateByNameThrow("satelliteTargetReference", satelliteTargetReference);
	AtfValidator::validateInt(_descr, "satelliteTargetReference", satelliteTargetReference.length(), _checker, __FILE__, __LINE__);
	UINT16 satelliteTargetReferenceLock; _jparser.validateByNameThrow("satelliteTargetReferenceLock", satelliteTargetReferenceLock);
	AtfValidator::validateInt(_descr, "satelliteTargetReferenceLock", satelliteTargetReferenceLock, _checker, __FILE__, __LINE__);
	UINT32 maxPlayers; _jparser.validateByNameThrow("maxPlayers", maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	BYTE speedDisplay; _jparser.validateByNameThrow("speedDisplay", speedDisplay);
	AtfValidator::validateInt(_descr, "speedDisplay", speedDisplay, _checker, __FILE__, __LINE__);
	I18nPString nameSnG; _jparser.validateByNameThrow("nameSnG", nameSnG);
	BYTE step; _jparser.validateByNameThrow("step", step);
	AtfValidator::validateInt(_descr, "step", step, _checker, __FILE__, __LINE__);
	BYTE timedTournType; _jparser.validateByNameThrow("timedTournType", timedTournType);
	AtfValidator::validateInt(_descr, "timedTournType", timedTournType, _checker, __FILE__, __LINE__);
	UINT16 timedTournTime; _jparser.validateByNameThrow("timedTournTime", timedTournTime);
	AtfValidator::validateInt(_descr, "timedTournTime", timedTournTime, _checker, __FILE__, __LINE__);
	BYTE timedTournPayout; _jparser.validateByNameThrow("timedTournPayout", timedTournPayout);
	AtfValidator::validateInt(_descr, "timedTournPayout", timedTournPayout, _checker, __FILE__, __LINE__);
	bool isFlightTourn; _jparser.validateByNameThrow("isFlightTourn", isFlightTourn);
	AtfValidator::validateInt(_descr, "isFlightTourn", isFlightTourn, _checker, __FILE__, __LINE__);
	PString tournBrand; _jparser.validateByNameThrow("tournBrand", tournBrand);
	AtfValidator::validateInt(_descr, "tournBrand", tournBrand.length(), _checker, __FILE__, __LINE__);
	UINT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	BYTE progressiveKnockout; _jparser.validateByNameThrow("progressiveKnockout", progressiveKnockout);
	AtfValidator::validateInt(_descr, "progressiveKnockout", progressiveKnockout, _checker, __FILE__, __LINE__);
	BYTE awardScheme; _jparser.validateByNameThrow("awardScheme", awardScheme);
	AtfValidator::validateInt(_descr, "awardScheme", awardScheme, _checker, __FILE__, __LINE__);
	UINT16 numReentries; _jparser.validateByNameThrow("numReentries", numReentries);
	AtfValidator::validateInt(_descr, "numReentries", numReentries, _checker, __FILE__, __LINE__);
	PString internalReference; _jparser.validateByNameThrow("internalReference", internalReference);
	AtfValidator::validateInt(_descr, "internalReference", internalReference.length(), _checker, __FILE__, __LINE__);
	PString favReference; _jparser.validateByNameThrow("favReference", favReference);
	AtfValidator::validateInt(_descr, "favReference", favReference.length(), _checker, __FILE__, __LINE__);
	PString satelliteTargetName; _jparser.validateByNameThrow("satelliteTargetName", satelliteTargetName);
	AtfValidator::validateInt(_descr, "satelliteTargetName", satelliteTargetName.length(), _checker, __FILE__, __LINE__);
	INT64 admissionPrice; _jparser.validateByNameThrow("admissionPrice", admissionPrice);
	AtfValidator::validateInt(_descr, "admissionPrice", admissionPrice, _checker, __FILE__, __LINE__);
	UINT64 tournFlags2; _jparser.validateByNameThrow("tournFlags2", tournFlags2);
	AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	SrvTime regEndAbs; _jparser.validateByNameThrow("regEndAbs", regEndAbs);
	AtfValidator::validateSrvDateTime(_descr, "regEndAbs", regEndAbs, _checker, __FILE__, __LINE__);
	UINT32 regEndAbsInt; _jparser.validateByNameThrow("regEndAbsInt", regEndAbsInt);
	AtfValidator::validateInt(_descr, "regEndAbsInt", regEndAbsInt, _checker, __FILE__, __LINE__);
	bool doNotAllowToUnreg; _jparser.validateByNameThrow("doNotAllowToUnreg", doNotAllowToUnreg);
	AtfValidator::validateInt(_descr, "doNotAllowToUnreg", doNotAllowToUnreg, _checker, __FILE__, __LINE__);
	TournClient::NStackTournInfoStruct nStackInfo; _jparser.validateByNameThrow("nStackInfo", nStackInfo);
	UINT32 tournMask5; _jparser.validateByNameThrow("tournMask5", tournMask5);
	AtfValidator::validateInt(_descr, "tournMask5", tournMask5, _checker, __FILE__, __LINE__);
	UINT32 tournMask6; _jparser.validateByNameThrow("tournMask6", tournMask6);
	AtfValidator::validateInt(_descr, "tournMask6", tournMask6, _checker, __FILE__, __LINE__);
	PString satelliteTargetNameMTT; _jparser.validateByNameThrow("satelliteTargetNameMTT", satelliteTargetNameMTT);
	AtfValidator::validateInt(_descr, "satelliteTargetNameMTT", satelliteTargetNameMTT.length(), _checker, __FILE__, __LINE__);
	UINT32 liveEventMask; _jparser.validateByNameThrow("liveEventMask", liveEventMask);
	AtfValidator::validateInt(_descr, "liveEventMask", liveEventMask, _checker, __FILE__, __LINE__);
	BYTE timedTournPlayersPercent; _jparser.validateByNameThrow("timedTournPlayersPercent", timedTournPlayersPercent);
	AtfValidator::validateInt(_descr, "timedTournPlayersPercent", timedTournPlayersPercent, _checker, __FILE__, __LINE__);
	UINT32 dummy1; _jparser.validateByNameThrow("dummy1", dummy1);
	AtfValidator::validateInt(_descr, "dummy1", dummy1, _checker, __FILE__, __LINE__);
	BYTE rmPmLobby; _jparser.validateByNameThrow("rmPmLobby", rmPmLobby);
	AtfValidator::validateInt(_descr, "rmPmLobby", rmPmLobby, _checker, __FILE__, __LINE__);
	UINT32 brandAccessMask; _jparser.validateByNameThrow("brandAccessMask", brandAccessMask);
	AtfValidator::validateInt(_descr, "brandAccessMask", brandAccessMask, _checker, __FILE__, __LINE__);
	UINT32 activeFlags; _jparser.validateByNameThrow("activeFlags", activeFlags);
	AtfValidator::validateInt(_descr, "activeFlags", activeFlags, _checker, __FILE__, __LINE__);
	UINT32 sngScriptId; _jparser.validateByNameThrow("sngScriptId", sngScriptId);
	AtfValidator::validateInt(_descr, "sngScriptId", sngScriptId, _checker, __FILE__, __LINE__);
	PString customSpeedDisplayName; _jparser.validateByNameThrow("customSpeedDisplayName", customSpeedDisplayName);
	AtfValidator::validateInt(_descr, "customSpeedDisplayName", customSpeedDisplayName.length(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PSiteMask tournSitesEx; _jparser.validateByNameThrow("tournSitesEx", tournSitesEx);
}

/*static*/ void MLobby::cli::TournStaticData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 tournamentId; _parser0.parseUINT32(tournamentId);
	AtfValidator::validateInt(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "targetServer"); size_t szTargetServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "targetServer", szTargetServer, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "hasSatellite"); size_t szHasSatellite = strlen(_dummy);
	AtfValidator::validateInt(_descr, "hasSatellite", szHasSatellite, _checker, __FILE__, __LINE__);
	SrvTime whenStart; _parser0.parseSrvTime(whenStart);
	AtfValidator::validateSrvDateTime(_descr, "whenStart", whenStart, _checker, __FILE__, __LINE__);
	UINT32 buyIn; _parser0.parseUINT32(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT32 rake; _parser0.parseUINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	UINT32 fppBuyIn; _parser0.parseUINT32(fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	BYTE isRestricted; _parser0.parseBYTE(isRestricted);
	AtfValidator::validateInt(_descr, "isRestricted", isRestricted, _checker, __FILE__, __LINE__);
	BYTE isPwdProtected; _parser0.parseBYTE(isPwdProtected);
	AtfValidator::validateInt(_descr, "isPwdProtected", isPwdProtected, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "admissionId"); size_t szAdmissionId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "admissionId", szAdmissionId, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser0.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 satelliteTarget; _parser0.parseUINT32(satelliteTarget);
	AtfValidator::validateInt(_descr, "satelliteTarget", satelliteTarget, _checker, __FILE__, __LINE__);
	UINT32 minPlayers; _parser0.parseUINT32(minPlayers);
	AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
	UINT32 tournFlags; _parser0.parseUINT32(tournFlags);
	AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser0.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	UINT32 tournMask; _parser0.parseUINT32(tournMask);
	AtfValidator::validateInt(_descr, "tournMask", tournMask, _checker, __FILE__, __LINE__);
	UINT32 tournSites; _parser0.parseUINT32(tournSites);
	AtfValidator::validateInt(_descr, "tournSites", tournSites, _checker, __FILE__, __LINE__);
	UINT32 whenStartInt; _parser0.parseUINT32(whenStartInt);
	AtfValidator::validateInt(_descr, "whenStartInt", whenStartInt, _checker, __FILE__, __LINE__);
	UINT32 tournMask2; _parser0.parseUINT32(tournMask2);
	AtfValidator::validateInt(_descr, "tournMask2", tournMask2, _checker, __FILE__, __LINE__);
	SrvTime targetWhenStart; _parser0.parseSrvTime(targetWhenStart);
	AtfValidator::validateSrvDateTime(_descr, "targetWhenStart", targetWhenStart, _checker, __FILE__, __LINE__);
	UINT32 tournMask3; _parser0.parseUINT32(tournMask3);
	AtfValidator::validateInt(_descr, "tournMask3", tournMask3, _checker, __FILE__, __LINE__);
	UINT32 tournMask4; _parser0.parseUINT32(tournMask4);
	AtfValidator::validateInt(_descr, "tournMask4", tournMask4, _checker, __FILE__, __LINE__);
	UINT32 maxPerTable; _parser0.parseUINT32(maxPerTable);
	AtfValidator::validateInt(_descr, "maxPerTable", maxPerTable, _checker, __FILE__, __LINE__);
	bool countryRestrictionInverted; _parser0.parseBOOL(countryRestrictionInverted);
	AtfValidator::validateInt(_descr, "countryRestrictionInverted", countryRestrictionInverted, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szRestrictedCountries = Atf::LAtfVector< PString , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("restrictedCountries"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "restrictedCountries", szRestrictedCountries, _checker, __FILE__, __LINE__);
	BYTE hasDayTwoStart; _parser0.parseBYTE(hasDayTwoStart);
	AtfValidator::validateInt(_descr, "hasDayTwoStart", hasDayTwoStart, _checker, __FILE__, __LINE__);
	UINT32 dayTwoStartSec; _parser0.parseUINT32(dayTwoStartSec);
	AtfValidator::validateInt(_descr, "dayTwoStartSec", dayTwoStartSec, _checker, __FILE__, __LINE__);
	SrvTime dayTwoStart; _parser0.parseSrvTime(dayTwoStart);
	AtfValidator::validateSrvDateTime(_descr, "dayTwoStart", dayTwoStart, _checker, __FILE__, __LINE__);
	I18nPString shortText; shortText.parse(_parser0);
	UINT16 chatLang; _parser0.parseUINT16(chatLang);
	AtfValidator::validateInt(_descr, "chatLang", chatLang, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 tournFlagsServInt; _parser0.parseUINT32(tournFlagsServInt);
	AtfValidator::validateInt(_descr, "tournFlagsServInt", tournFlagsServInt, _checker, __FILE__, __LINE__);
	UINT32 knockout; _parser0.parseUINT32(knockout);
	AtfValidator::validateInt(_descr, "knockout", knockout, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "satelliteTargetReference"); size_t szSatelliteTargetReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "satelliteTargetReference", szSatelliteTargetReference, _checker, __FILE__, __LINE__);
	UINT16 satelliteTargetReferenceLock; _parser0.parseUINT16(satelliteTargetReferenceLock);
	AtfValidator::validateInt(_descr, "satelliteTargetReferenceLock", satelliteTargetReferenceLock, _checker, __FILE__, __LINE__);
	UINT32 maxPlayers; _parser0.parseUINT32(maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	BYTE speedDisplay; _parser0.parseBYTE(speedDisplay);
	AtfValidator::validateInt(_descr, "speedDisplay", speedDisplay, _checker, __FILE__, __LINE__);
	I18nPString nameSnG; nameSnG.parse(_parser0);
	BYTE step; _parser0.parseBYTE(step);
	AtfValidator::validateInt(_descr, "step", step, _checker, __FILE__, __LINE__);
	BYTE timedTournType; _parser0.parseBYTE(timedTournType);
	AtfValidator::validateInt(_descr, "timedTournType", timedTournType, _checker, __FILE__, __LINE__);
	UINT16 timedTournTime; _parser0.parseUINT16(timedTournTime);
	AtfValidator::validateInt(_descr, "timedTournTime", timedTournTime, _checker, __FILE__, __LINE__);
	BYTE timedTournPayout; _parser0.parseBYTE(timedTournPayout);
	AtfValidator::validateInt(_descr, "timedTournPayout", timedTournPayout, _checker, __FILE__, __LINE__);
	bool isFlightTourn; _parser0.parseBOOL(isFlightTourn);
	AtfValidator::validateInt(_descr, "isFlightTourn", isFlightTourn, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "tournBrand"); size_t szTournBrand = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tournBrand", szTournBrand, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser0.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	BYTE progressiveKnockout; _parser0.parseBYTE(progressiveKnockout);
	AtfValidator::validateInt(_descr, "progressiveKnockout", progressiveKnockout, _checker, __FILE__, __LINE__);
	BYTE awardScheme; _parser0.parseBYTE(awardScheme);
	AtfValidator::validateInt(_descr, "awardScheme", awardScheme, _checker, __FILE__, __LINE__);
	UINT16 numReentries; _parser0.parseUINT16(numReentries);
	AtfValidator::validateInt(_descr, "numReentries", numReentries, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "internalReference"); size_t szInternalReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "internalReference", szInternalReference, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "favReference"); size_t szFavReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "favReference", szFavReference, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "satelliteTargetName"); size_t szSatelliteTargetName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "satelliteTargetName", szSatelliteTargetName, _checker, __FILE__, __LINE__);
	INT64 admissionPrice; _parser0.parseINT64(admissionPrice);
	AtfValidator::validateInt(_descr, "admissionPrice", admissionPrice, _checker, __FILE__, __LINE__);
	UINT64 tournFlags2; _parser0.parseUINT64(tournFlags2);
	AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	SrvTime regEndAbs; _parser0.parseSrvTime(regEndAbs);
	AtfValidator::validateSrvDateTime(_descr, "regEndAbs", regEndAbs, _checker, __FILE__, __LINE__);
	UINT32 regEndAbsInt; _parser0.parseUINT32(regEndAbsInt);
	AtfValidator::validateInt(_descr, "regEndAbsInt", regEndAbsInt, _checker, __FILE__, __LINE__);
	bool doNotAllowToUnreg; _parser0.parseBOOL(doNotAllowToUnreg);
	AtfValidator::validateInt(_descr, "doNotAllowToUnreg", doNotAllowToUnreg, _checker, __FILE__, __LINE__);
	TournClient::NStackTournInfoStruct::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("nStackInfo"), _fieldsWithUnparsedContent);
	UINT32 tournMask5; _parser0.parseUINT32(tournMask5);
	AtfValidator::validateInt(_descr, "tournMask5", tournMask5, _checker, __FILE__, __LINE__);
	UINT32 tournMask6; _parser0.parseUINT32(tournMask6);
	AtfValidator::validateInt(_descr, "tournMask6", tournMask6, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "satelliteTargetNameMTT"); size_t szSatelliteTargetNameMTT = strlen(_dummy);
	AtfValidator::validateInt(_descr, "satelliteTargetNameMTT", szSatelliteTargetNameMTT, _checker, __FILE__, __LINE__);
	UINT32 liveEventMask; _parser0.parseUINT32(liveEventMask);
	AtfValidator::validateInt(_descr, "liveEventMask", liveEventMask, _checker, __FILE__, __LINE__);
	BYTE timedTournPlayersPercent; _parser0.parseBYTE(timedTournPlayersPercent);
	AtfValidator::validateInt(_descr, "timedTournPlayersPercent", timedTournPlayersPercent, _checker, __FILE__, __LINE__);
	UINT32 dummy1; _parser0.parseUINT32(dummy1);
	AtfValidator::validateInt(_descr, "dummy1", dummy1, _checker, __FILE__, __LINE__);
	BYTE rmPmLobby; _parser0.parseBYTE(rmPmLobby);
	AtfValidator::validateInt(_descr, "rmPmLobby", rmPmLobby, _checker, __FILE__, __LINE__);
	UINT32 brandAccessMask; _parser0.parseUINT32(brandAccessMask);
	AtfValidator::validateInt(_descr, "brandAccessMask", brandAccessMask, _checker, __FILE__, __LINE__);
	UINT32 activeFlags; _parser0.parseUINT32(activeFlags);
	AtfValidator::validateInt(_descr, "activeFlags", activeFlags, _checker, __FILE__, __LINE__);
	UINT32 sngScriptId; _parser0.parseUINT32(sngScriptId);
	AtfValidator::validateInt(_descr, "sngScriptId", sngScriptId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "customSpeedDisplayName"); size_t szCustomSpeedDisplayName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "customSpeedDisplayName", szCustomSpeedDisplayName, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tournSitesEx"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TournDynaData
//=================================================================

MLobby::cli::TournDynaData::TournDynaData()
{
	clear();
}

void MLobby::cli::TournDynaData::clear()
{
	fakeStatus = 0;
	entrants = 0;
	publProp = 0;
	prizePoolToPublish = 0;
	prizePoolUnit = 0;
	happyHoursMultipliers.clear();
	goldenSnGMilestoneAwardStub = 0;
	dummy1 = 0;
	goldenSnGEligibleStub = false;
	goldenSnGTotalAddonStub = 0;
	prizePoolMoneyToPublish = 0;
	timedTournPlayersThreshold = 0;
	mixTournSatellite = 0;
}

bool MLobby::cli::TournDynaData::equals(const TournDynaData& _o) const
{
	return fakeStatus == _o.fakeStatus &&
		entrants == _o.entrants &&
		publProp == _o.publProp &&
		prizePoolToPublish == _o.prizePoolToPublish &&
		prizePoolUnit == _o.prizePoolUnit &&
		happyHoursMultipliers.equals(_o.happyHoursMultipliers) &&
		goldenSnGMilestoneAwardStub == _o.goldenSnGMilestoneAwardStub &&
		dummy1 == _o.dummy1 &&
		goldenSnGEligibleStub == _o.goldenSnGEligibleStub &&
		goldenSnGTotalAddonStub == _o.goldenSnGTotalAddonStub &&
		prizePoolMoneyToPublish == _o.prizePoolMoneyToPublish &&
		timedTournPlayersThreshold == _o.timedTournPlayersThreshold &&
		mixTournSatellite == _o.mixTournSatellite;
}

const char *MLobby::cli::TournDynaData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("fakeStatus=");
	_buf.appendUint(fakeStatus);
	_buf.append(',');
	_buf.append("entrants=");
	_buf.appendUint(entrants);
	_buf.append(',');
	_buf.append("publProp=");
	_buf.appendUint(publProp);
	_buf.append(',');
	_buf.append("prizePoolToPublish=");
	_buf.appendUint(prizePoolToPublish);
	_buf.append(',');
	_buf.append("prizePoolUnit=");
	_buf.appendUint(prizePoolUnit);
	_buf.append(',');
	_buf.append("happyHoursMultipliers=");
	happyHoursMultipliers.toTraceString(_buf);
	_buf.append(',');
	_buf.append("goldenSnGMilestoneAwardStub=");
	_buf.appendUint(goldenSnGMilestoneAwardStub);
	_buf.append(',');
	_buf.append("dummy1=");
	_buf.appendUint(dummy1);
	_buf.append(',');
	_buf.append("goldenSnGEligibleStub=");
	_buf.appendUint(goldenSnGEligibleStub);
	_buf.append(',');
	_buf.append("goldenSnGTotalAddonStub=");
	_buf.appendUint(goldenSnGTotalAddonStub);
	_buf.append(',');
	_buf.append("prizePoolMoneyToPublish=");
	_buf.appendUint(prizePoolMoneyToPublish);
	_buf.append(',');
	_buf.append("timedTournPlayersThreshold=");
	_buf.appendUint(timedTournPlayersThreshold);
	_buf.append(',');
	_buf.append("mixTournSatellite=");
	_buf.appendInt(mixTournSatellite);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobby::cli::TournDynaData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("fakeStatus", fakeStatus, _buf);
	Atf::XmlElement::encodeAsXmlElement("entrants", entrants, _buf);
	Atf::XmlElement::encodeAsXmlElement("publProp", publProp, _buf);
	Atf::XmlElement::encodeAsXmlElement("prizePoolToPublish", prizePoolToPublish, _buf);
	Atf::XmlElement::encodeAsXmlElement("prizePoolUnit", prizePoolUnit, _buf);
	happyHoursMultipliers.toXmlString("happyHoursMultipliers", _buf);
	Atf::XmlElement::encodeAsXmlElement("goldenSnGMilestoneAwardStub", goldenSnGMilestoneAwardStub, _buf);
	Atf::XmlElement::encodeAsXmlElement("dummy1", dummy1, _buf);
	Atf::XmlElement::encodeAsXmlElement("goldenSnGEligibleStub", goldenSnGEligibleStub, _buf);
	Atf::XmlElement::encodeAsXmlElement("goldenSnGTotalAddonStub", goldenSnGTotalAddonStub, _buf);
	Atf::XmlElement::encodeAsXmlElement("prizePoolMoneyToPublish", prizePoolMoneyToPublish, _buf);
	Atf::XmlElement::encodeAsXmlElement("timedTournPlayersThreshold", timedTournPlayersThreshold, _buf);
	Atf::XmlElement::encodeAsXmlElement("mixTournSatellite", mixTournSatellite, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobby::cli::TournDynaData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("fakeStatus"))
		{
			fakeStatus = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("entrants"))
		{
			entrants = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("publProp"))
		{
			publProp = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("prizePoolToPublish"))
		{
			prizePoolToPublish = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("prizePoolUnit"))
		{
			prizePoolUnit = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("happyHoursMultipliers"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< FppFactorStruct, 4 > >::FromXmlString(_value, happyHoursMultipliers)) return false;
		}
		else if (_element.equals("goldenSnGMilestoneAwardStub"))
		{
			goldenSnGMilestoneAwardStub = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("dummy1"))
		{
			dummy1 = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("goldenSnGEligibleStub"))
		{
			goldenSnGEligibleStub = (*_value.ptr() == '1');
		}
		else if (_element.equals("goldenSnGTotalAddonStub"))
		{
			goldenSnGTotalAddonStub = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("prizePoolMoneyToPublish"))
		{
			prizePoolMoneyToPublish = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("timedTournPlayersThreshold"))
		{
			timedTournPlayersThreshold = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("mixTournSatellite"))
		{
			mixTournSatellite = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobby::cli::TournDynaData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(TournDynaData())) // not empty
	{
		_body.composeUINT32(fakeStatus);
		_body.composeUINT32(entrants);
		_body.composeBYTE(publProp);
		_body.composeUINT32(prizePoolToPublish);
		_body.composeBYTE(prizePoolUnit);
		happyHoursMultipliers.composeMsg(_body, _ignoreJSON);
		_body.composeUINT32(goldenSnGMilestoneAwardStub);
		_body.composeUINT32(dummy1);
		_body.composeBOOL(goldenSnGEligibleStub);
		_body.composeUINT32(goldenSnGTotalAddonStub);
		_body.composeUINT32(prizePoolMoneyToPublish);
		_body.composeUINT32(timedTournPlayersThreshold);
		_body.composeINT8(mixTournSatellite);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::TournDynaData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(fakeStatus);
	_parser0.parseUINT32(entrants);
	_parser0.parseBYTE(publProp);
	_parser0.parseUINT32(prizePoolToPublish);
	_parser0.parseBYTE(prizePoolUnit);
	happyHoursMultipliers.parseMsg(_parser0);
	_parser0.parseUINT32(goldenSnGMilestoneAwardStub);
	_parser0.parseUINT32(dummy1);
	_parser0.parseBOOL(goldenSnGEligibleStub);
	_parser0.parseUINT32(goldenSnGTotalAddonStub);
	_parser0.parseUINT32(prizePoolMoneyToPublish);
	_parser0.parseUINT32(timedTournPlayersThreshold);
	_parser0.parseINT8(mixTournSatellite);
}

const char *MLobby::cli::TournDynaData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("fakeStatus", fakeStatus);
	_jsonstr.compose("entrants", entrants);
	_jsonstr.compose("publProp", publProp);
	_jsonstr.compose("prizePoolToPublish", prizePoolToPublish);
	_jsonstr.compose("prizePoolUnit", prizePoolUnit);
	_jsonstr.compose("happyHoursMultipliers", happyHoursMultipliers);
	_jsonstr.compose("goldenSnGMilestoneAwardStub", goldenSnGMilestoneAwardStub);
	_jsonstr.compose("dummy1", dummy1);
	_jsonstr.compose("goldenSnGEligibleStub", goldenSnGEligibleStub);
	_jsonstr.compose("goldenSnGTotalAddonStub", goldenSnGTotalAddonStub);
	_jsonstr.compose("prizePoolMoneyToPublish", prizePoolMoneyToPublish);
	_jsonstr.compose("timedTournPlayersThreshold", timedTournPlayersThreshold);
	_jsonstr.compose("mixTournSatellite", mixTournSatellite);
	return _buf.c_str();
}

void MLobby::cli::TournDynaData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("fakeStatus", fakeStatus);
	_jparser.parseByNameThrow("entrants", entrants);
	_jparser.parseByNameThrow("publProp", publProp);
	_jparser.parseByNameThrow("prizePoolToPublish", prizePoolToPublish);
	_jparser.parseByNameThrow("prizePoolUnit", prizePoolUnit);
	_jparser.parseByNameThrow("happyHoursMultipliers", happyHoursMultipliers);
	_jparser.parseByNameThrow("goldenSnGMilestoneAwardStub", goldenSnGMilestoneAwardStub);
	_jparser.parseByNameThrow("dummy1", dummy1);
	_jparser.parseByNameThrow("goldenSnGEligibleStub", goldenSnGEligibleStub);
	_jparser.parseByNameThrow("goldenSnGTotalAddonStub", goldenSnGTotalAddonStub);
	_jparser.parseByNameThrow("prizePoolMoneyToPublish", prizePoolMoneyToPublish);
	_jparser.parseByNameThrow("timedTournPlayersThreshold", timedTournPlayersThreshold);
	_jparser.parseByNameThrow("mixTournSatellite", mixTournSatellite);
}

/* static */ void MLobby::cli::TournDynaData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 fakeStatus; _jparser.validateByNameThrow("fakeStatus", fakeStatus);
	AtfValidator::validateInt(_descr, "fakeStatus", fakeStatus, _checker, __FILE__, __LINE__);
	UINT32 entrants; _jparser.validateByNameThrow("entrants", entrants);
	AtfValidator::validateInt(_descr, "entrants", entrants, _checker, __FILE__, __LINE__);
	BYTE publProp; _jparser.validateByNameThrow("publProp", publProp);
	AtfValidator::validateInt(_descr, "publProp", publProp, _checker, __FILE__, __LINE__);
	UINT32 prizePoolToPublish; _jparser.validateByNameThrow("prizePoolToPublish", prizePoolToPublish);
	AtfValidator::validateInt(_descr, "prizePoolToPublish", prizePoolToPublish, _checker, __FILE__, __LINE__);
	BYTE prizePoolUnit; _jparser.validateByNameThrow("prizePoolUnit", prizePoolUnit);
	AtfValidator::validateInt(_descr, "prizePoolUnit", prizePoolUnit, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< FppFactorStruct > happyHoursMultipliers; _jparser.validateByNameThrow("happyHoursMultipliers", happyHoursMultipliers);
	AtfValidator::validateInt(_descr, "happyHoursMultipliers", happyHoursMultipliers.size(), _checker, __FILE__, __LINE__);
	UINT32 goldenSnGMilestoneAwardStub; _jparser.validateByNameThrow("goldenSnGMilestoneAwardStub", goldenSnGMilestoneAwardStub);
	AtfValidator::validateInt(_descr, "goldenSnGMilestoneAwardStub", goldenSnGMilestoneAwardStub, _checker, __FILE__, __LINE__);
	UINT32 dummy1; _jparser.validateByNameThrow("dummy1", dummy1);
	AtfValidator::validateInt(_descr, "dummy1", dummy1, _checker, __FILE__, __LINE__);
	bool goldenSnGEligibleStub; _jparser.validateByNameThrow("goldenSnGEligibleStub", goldenSnGEligibleStub);
	AtfValidator::validateInt(_descr, "goldenSnGEligibleStub", goldenSnGEligibleStub, _checker, __FILE__, __LINE__);
	UINT32 goldenSnGTotalAddonStub; _jparser.validateByNameThrow("goldenSnGTotalAddonStub", goldenSnGTotalAddonStub);
	AtfValidator::validateInt(_descr, "goldenSnGTotalAddonStub", goldenSnGTotalAddonStub, _checker, __FILE__, __LINE__);
	UINT32 prizePoolMoneyToPublish; _jparser.validateByNameThrow("prizePoolMoneyToPublish", prizePoolMoneyToPublish);
	AtfValidator::validateInt(_descr, "prizePoolMoneyToPublish", prizePoolMoneyToPublish, _checker, __FILE__, __LINE__);
	UINT32 timedTournPlayersThreshold; _jparser.validateByNameThrow("timedTournPlayersThreshold", timedTournPlayersThreshold);
	AtfValidator::validateInt(_descr, "timedTournPlayersThreshold", timedTournPlayersThreshold, _checker, __FILE__, __LINE__);
	INT8 mixTournSatellite; _jparser.validateByNameThrow("mixTournSatellite", mixTournSatellite);
	AtfValidator::validateInt(_descr, "mixTournSatellite", mixTournSatellite, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobby::cli::TournDynaData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 fakeStatus; _parser0.parseUINT32(fakeStatus);
	AtfValidator::validateInt(_descr, "fakeStatus", fakeStatus, _checker, __FILE__, __LINE__);
	UINT32 entrants; _parser0.parseUINT32(entrants);
	AtfValidator::validateInt(_descr, "entrants", entrants, _checker, __FILE__, __LINE__);
	BYTE publProp; _parser0.parseBYTE(publProp);
	AtfValidator::validateInt(_descr, "publProp", publProp, _checker, __FILE__, __LINE__);
	UINT32 prizePoolToPublish; _parser0.parseUINT32(prizePoolToPublish);
	AtfValidator::validateInt(_descr, "prizePoolToPublish", prizePoolToPublish, _checker, __FILE__, __LINE__);
	BYTE prizePoolUnit; _parser0.parseBYTE(prizePoolUnit);
	AtfValidator::validateInt(_descr, "prizePoolUnit", prizePoolUnit, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szHappyHoursMultipliers = Atf::LAtfVector< FppFactorStruct, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("happyHoursMultipliers"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "happyHoursMultipliers", szHappyHoursMultipliers, _checker, __FILE__, __LINE__);
	UINT32 goldenSnGMilestoneAwardStub; _parser0.parseUINT32(goldenSnGMilestoneAwardStub);
	AtfValidator::validateInt(_descr, "goldenSnGMilestoneAwardStub", goldenSnGMilestoneAwardStub, _checker, __FILE__, __LINE__);
	UINT32 dummy1; _parser0.parseUINT32(dummy1);
	AtfValidator::validateInt(_descr, "dummy1", dummy1, _checker, __FILE__, __LINE__);
	bool goldenSnGEligibleStub; _parser0.parseBOOL(goldenSnGEligibleStub);
	AtfValidator::validateInt(_descr, "goldenSnGEligibleStub", goldenSnGEligibleStub, _checker, __FILE__, __LINE__);
	UINT32 goldenSnGTotalAddonStub; _parser0.parseUINT32(goldenSnGTotalAddonStub);
	AtfValidator::validateInt(_descr, "goldenSnGTotalAddonStub", goldenSnGTotalAddonStub, _checker, __FILE__, __LINE__);
	UINT32 prizePoolMoneyToPublish; _parser0.parseUINT32(prizePoolMoneyToPublish);
	AtfValidator::validateInt(_descr, "prizePoolMoneyToPublish", prizePoolMoneyToPublish, _checker, __FILE__, __LINE__);
	UINT32 timedTournPlayersThreshold; _parser0.parseUINT32(timedTournPlayersThreshold);
	AtfValidator::validateInt(_descr, "timedTournPlayersThreshold", timedTournPlayersThreshold, _checker, __FILE__, __LINE__);
	INT8 mixTournSatellite; _parser0.parseINT8(mixTournSatellite);
	AtfValidator::validateInt(_descr, "mixTournSatellite", mixTournSatellite, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TournDataStruct
//=================================================================

MLobby::cli::TournDataStruct::TournDataStruct()
{
	clear();
}

void MLobby::cli::TournDataStruct::clear()
{
	staticData.clear();
	dynamicData.clear();
}

bool MLobby::cli::TournDataStruct::equals(const TournDataStruct& _o) const
{
	return staticData.equals(_o.staticData) &&
		dynamicData.equals(_o.dynamicData);
}

const char *MLobby::cli::TournDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("staticData=");
	staticData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("dynamicData=");
	dynamicData.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobby::cli::TournDataStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	staticData.toXmlString("staticData", _buf);
	dynamicData.toXmlString("dynamicData", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobby::cli::TournDataStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("staticData"))
		{
			if(!Atf::AtfTempl< TournStaticData >::FromXmlString(_value, staticData)) return false;
		}
		else if (_element.equals("dynamicData"))
		{
			if(!Atf::AtfTempl< TournDynaData >::FromXmlString(_value, dynamicData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobby::cli::TournDataStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(TournDataStruct())) // not empty
	{
		staticData.composeMsg(_body, _ignoreJSON);
		dynamicData.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::TournDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	staticData.parseMsg(_parser0);
	dynamicData.parseMsg(_parser0);
}

const char *MLobby::cli::TournDataStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("staticData", staticData);
	_jsonstr.compose("dynamicData", dynamicData);
	return _buf.c_str();
}

void MLobby::cli::TournDataStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("staticData", staticData);
	_jparser.parseByNameThrow("dynamicData", dynamicData);
}

/* static */ void MLobby::cli::TournDataStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TournStaticData staticData; _jparser.validateByNameThrow("staticData", staticData);
	TournDynaData dynamicData; _jparser.validateByNameThrow("dynamicData", dynamicData);
}

/*static*/ void MLobby::cli::TournDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	TournStaticData::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("staticData"), _fieldsWithUnparsedContent);
	TournDynaData::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("dynamicData"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2
//=================================================================

MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2::clear()
{
	filter.clear();
	maxItems = 0;
	context = 0;
	installId.clear();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2::equals(const Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2& _o) const
{
	return filter.equals(_o.filter) &&
		maxItems == _o.maxItems &&
		context == _o.context &&
		Atf::atfPStringEquals(installId, _o.installId);
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBY_FIND_TOURNAMENTS2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2*)_other));
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_TOURNAMENTS2).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("maxItems=");
	_buf.appendUint(maxItems);
	_buf.append(',');
	_buf.append("context=");
	_buf.appendUint(context);
	_buf.append(',');
	_buf.append("installId=");
	_buf.append(installId);
	return _buf.c_str();
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBY_FIND_TOURNAMENTS2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	filter.toXmlString("filter", _buf);
	Atf::XmlElement::encodeAsXmlElement("maxItems", maxItems, _buf);
	Atf::XmlElement::encodeAsXmlElement("context", context, _buf);
	Atf::XmlElement::encodeAsXmlElement("installId", installId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("filter"))
			{
				if(!Atf::AtfTempl< TournSelectionFilter >::FromXmlString(_value, filter)) return false;
			}
			else if (_element.equals("maxItems"))
			{
				maxItems = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("context"))
			{
				context = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("installId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, installId)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	filter.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(maxItems);
	_msg.composeUINT32(context);
	_msg.composeString(installId);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	_parser.parseUINT32(maxItems);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(context);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(installId);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("filter", filter);
	_jsonstr.compose("maxItems", maxItems);
	_jsonstr.compose("context", context);
	_jsonstr.compose("installId", installId);
	return _buf.c_str();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("filter", filter);
	_jparser.parseByNameThrow("maxItems", maxItems);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("context", context);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("installId", installId);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_TOURNAMENTS2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TournSelectionFilter filter; _jparser.validateByNameThrow("filter", filter);
	UINT32 maxItems; _jparser.validateByNameThrow("maxItems", maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 context; _jparser.validateByNameThrow("context", context);
	AtfValidator::validateInt(_descr, "context", context, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString installId; _jparser.validateByNameThrow("installId", installId);
	AtfValidator::validateIntMax(_descr, "installId", installId.length(), 128, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_TOURNAMENTS2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	PString _descbuf;
	TournSelectionFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	UINT32 maxItems; _parser.parseUINT32(maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 context; _parser.parseUINT32(context);
	AtfValidator::validateInt(_descr, "context", context, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "installId"); size_t szInstallId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "installId", szInstallId, 128, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY
//=================================================================

MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY::clear()
{
	totalItems = 0;
	tourns.clear();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY::equals(const Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY& _o) const
{
	return totalItems == _o.totalItems &&
		tourns.equals(_o.tourns);
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY*)_other));
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY).append(")");
	_buf.append(',');
	_buf.append("totalItems=");
	_buf.appendUint(totalItems);
	_buf.append(',');
	_buf.append("tourns=");
	tourns.toTraceString(_buf);
	return _buf.c_str();
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("totalItems", totalItems, _buf);
	tourns.toXmlString("tourns", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("totalItems"))
			{
				totalItems = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tourns"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TournDataStruct, 4 > >::FromXmlString(_value, tourns)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(totalItems);
	tourns.composeMsg(_msg, _ignoreJSON);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(totalItems);
	tourns.parseMsg(_parser);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("totalItems", totalItems);
	_jsonstr.compose("tourns", tourns);
	return _buf.c_str();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("totalItems", totalItems);
	_jparser.parseByNameThrow("tourns", tourns);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 totalItems; _jparser.validateByNameThrow("totalItems", totalItems);
	AtfValidator::validateInt(_descr, "totalItems", totalItems, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TournDataStruct > tourns; _jparser.validateByNameThrow("tourns", tourns);
	AtfValidator::validateInt(_descr, "tourns", tourns.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 totalItems; _parser.parseUINT32(totalItems);
	AtfValidator::validateInt(_descr, "totalItems", totalItems, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTourns = Atf::LAtfVector< TournDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2
//=================================================================

MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2::clear()
{
	filter.clear();
	maxItems = 0;
	excludedFinders.clear();
	context = 0;
	installId.clear();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2::equals(const Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2& _o) const
{
	return filter.equals(_o.filter) &&
		maxItems == _o.maxItems &&
		excludedFinders.equals(_o.excludedFinders) &&
		context == _o.context &&
		Atf::atfPStringEquals(installId, _o.installId);
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2*)_other));
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("maxItems=");
	_buf.appendUint(maxItems);
	_buf.append(',');
	_buf.append("excludedFinders=");
	excludedFinders.toTraceString(_buf);
	_buf.append(',');
	_buf.append("context=");
	_buf.appendUint(context);
	_buf.append(',');
	_buf.append("installId=");
	_buf.append(installId);
	return _buf.c_str();
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	filter.toXmlString("filter", _buf);
	Atf::XmlElement::encodeAsXmlElement("maxItems", maxItems, _buf);
	excludedFinders.toXmlString("excludedFinders", _buf);
	Atf::XmlElement::encodeAsXmlElement("context", context, _buf);
	Atf::XmlElement::encodeAsXmlElement("installId", installId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("filter"))
			{
				if(!Atf::AtfTempl< FinderAndBlitzSelectionFilter >::FromXmlString(_value, filter)) return false;
			}
			else if (_element.equals("maxItems"))
			{
				maxItems = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("excludedFinders"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, excludedFinders)) return false;
			}
			else if (_element.equals("context"))
			{
				context = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("installId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, installId)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	filter.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(maxItems);
	excludedFinders.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(context);
	_msg.composeString(installId);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	_parser.parseUINT32(maxItems);
	excludedFinders.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(context);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(installId);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("filter", filter);
	_jsonstr.compose("maxItems", maxItems);
	_jsonstr.compose("excludedFinders", excludedFinders);
	_jsonstr.compose("context", context);
	_jsonstr.compose("installId", installId);
	return _buf.c_str();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("filter", filter);
	_jparser.parseByNameThrow("maxItems", maxItems);
	_jparser.parseByNameThrow("excludedFinders", excludedFinders);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("context", context);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("installId", installId);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	FinderAndBlitzSelectionFilter filter; _jparser.validateByNameThrow("filter", filter);
	UINT32 maxItems; _jparser.validateByNameThrow("maxItems", maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT32 > excludedFinders; _jparser.validateByNameThrow("excludedFinders", excludedFinders);
	AtfValidator::validateIntMax(_descr, "excludedFinders", excludedFinders.size(), 1024, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 context; _jparser.validateByNameThrow("context", context);
	AtfValidator::validateInt(_descr, "context", context, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString installId; _jparser.validateByNameThrow("installId", installId);
	AtfValidator::validateIntMax(_descr, "installId", installId.length(), 128, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	PString _descbuf;
	FinderAndBlitzSelectionFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	UINT32 maxItems; _parser.parseUINT32(maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
	int szExcludedFinders = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("excludedFinders"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "excludedFinders", szExcludedFinders, 1024, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 context; _parser.parseUINT32(context);
	AtfValidator::validateInt(_descr, "context", context, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "installId"); size_t szInstallId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "installId", szInstallId, 128, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY
//=================================================================

// @Override
bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY::equals(const Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY& _o) const
{ 
	return false; 
}

// @Override
const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY).append(")");
	_buf.append(',');
	_buf.append("sortedSeatFindersAndBlitzes= NOT IMPLEMENTED!!!!");
	return _buf.c_str();
}

// @Override
const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("NOT IMPLEMENTED!!!!");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

// @Override
bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY::loadFromXmlString(const PString& _xmlString)
{
	return false;
}

// @Override
const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY::asJSONString(PString& _buf) const
{
	return"";
}

// @Override
void MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY::loadFromJSONString(const PString& _jsonString)
{
}

// @Override
void MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
}

// @Override
void MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{}

MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY::clear()
{
	sortedSeatFindersAndBlitzes.clear();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY*)_other));
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	sortedSeatFindersAndBlitzes.composeMsg(_msg, _ignoreJSON);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY::parseMsg(CommMsgParser& _parser)
{
	sortedSeatFindersAndBlitzes.parseMsg(_parser);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_TABLE64_2
//=================================================================

MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2::Protocol_MSG_MLOBBY_FIND_TABLE64_2()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2::clear()
{
	filter.clear();
	maxItems = 0;
	excludedTables.clear();
	context = 0;
	installId.clear();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2::equals(const Protocol_MSG_MLOBBY_FIND_TABLE64_2& _o) const
{
	return filter.equals(_o.filter) &&
		maxItems == _o.maxItems &&
		excludedTables.equals(_o.excludedTables) &&
		context == _o.context &&
		Atf::atfPStringEquals(installId, _o.installId);
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBY_FIND_TABLE64_2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBY_FIND_TABLE64_2*)_other));
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_TABLE64_2).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("maxItems=");
	_buf.appendUint(maxItems);
	_buf.append(',');
	_buf.append("excludedTables=");
	excludedTables.toTraceString(_buf);
	_buf.append(',');
	_buf.append("context=");
	_buf.appendUint(context);
	_buf.append(',');
	_buf.append("installId=");
	_buf.append(installId);
	return _buf.c_str();
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBY_FIND_TABLE64_2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	filter.toXmlString("filter", _buf);
	Atf::XmlElement::encodeAsXmlElement("maxItems", maxItems, _buf);
	excludedTables.toXmlString("excludedTables", _buf);
	Atf::XmlElement::encodeAsXmlElement("context", context, _buf);
	Atf::XmlElement::encodeAsXmlElement("installId", installId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("filter"))
			{
				if(!Atf::AtfTempl< TableSelectionFilter >::FromXmlString(_value, filter)) return false;
			}
			else if (_element.equals("maxItems"))
			{
				maxItems = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("excludedTables"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT64, 4 > >::FromXmlString(_value, excludedTables)) return false;
			}
			else if (_element.equals("context"))
			{
				context = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("installId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, installId)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	filter.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(maxItems);
	excludedTables.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(context);
	_msg.composeString(installId);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	_parser.parseUINT32(maxItems);
	if(_parser.parseEnded()) return;
	excludedTables.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(context);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(installId);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("filter", filter);
	_jsonstr.compose("maxItems", maxItems);
	_jsonstr.compose("excludedTables", excludedTables);
	_jsonstr.compose("context", context);
	_jsonstr.compose("installId", installId);
	return _buf.c_str();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("filter", filter);
	_jparser.parseByNameThrow("maxItems", maxItems);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("excludedTables", excludedTables);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("context", context);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("installId", installId);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_TABLE64_2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TableSelectionFilter filter; _jparser.validateByNameThrow("filter", filter);
	UINT32 maxItems; _jparser.validateByNameThrow("maxItems", maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	Atf::AtfVectorBase< UINT64 > excludedTables; _jparser.validateByNameThrow("excludedTables", excludedTables);
	AtfValidator::validateIntMax(_descr, "excludedTables", excludedTables.size(), 1024, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 context; _jparser.validateByNameThrow("context", context);
	AtfValidator::validateInt(_descr, "context", context, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString installId; _jparser.validateByNameThrow("installId", installId);
	AtfValidator::validateIntMax(_descr, "installId", installId.length(), 128, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_TABLE64_2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	PString _descbuf;
	TableSelectionFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	UINT32 maxItems; _parser.parseUINT32(maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	int szExcludedTables = Atf::LAtfVector< UINT64, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("excludedTables"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "excludedTables", szExcludedTables, 1024, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 context; _parser.parseUINT32(context);
	AtfValidator::validateInt(_descr, "context", context, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "installId"); size_t szInstallId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "installId", szInstallId, 128, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_TABLE64_2_REPLY
//=================================================================

MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2_REPLY::Protocol_MSG_MLOBBY_FIND_TABLE64_2_REPLY()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2_REPLY::clear()
{
	totalItems = 0;
	tables.clear();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2_REPLY::equals(const Protocol_MSG_MLOBBY_FIND_TABLE64_2_REPLY& _o) const
{
	return totalItems == _o.totalItems &&
		tables.equals(_o.tables);
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBY_FIND_TABLE64_2_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBY_FIND_TABLE64_2_REPLY*)_other));
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_TABLE64_2_REPLY).append(")");
	_buf.append(',');
	_buf.append("totalItems=");
	_buf.appendUint(totalItems);
	_buf.append(',');
	_buf.append("tables=");
	tables.toTraceString(_buf);
	return _buf.c_str();
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBY_FIND_TABLE64_2_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("totalItems", totalItems, _buf);
	tables.toXmlString("tables", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("totalItems"))
			{
				totalItems = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tables"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< RingDataStruct, 4 > >::FromXmlString(_value, tables)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(totalItems);
	tables.composeMsg(_msg, _ignoreJSON);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(totalItems);
	tables.parseMsg(_parser);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("totalItems", totalItems);
	_jsonstr.compose("tables", tables);
	return _buf.c_str();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("totalItems", totalItems);
	_jparser.parseByNameThrow("tables", tables);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_TABLE64_2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 totalItems; _jparser.validateByNameThrow("totalItems", totalItems);
	AtfValidator::validateInt(_descr, "totalItems", totalItems, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< RingDataStruct > tables; _jparser.validateByNameThrow("tables", tables);
	AtfValidator::validateInt(_descr, "tables", tables.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_TABLE64_2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 totalItems; _parser.parseUINT32(totalItems);
	AtfValidator::validateInt(_descr, "totalItems", totalItems, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTables = Atf::LAtfVector< RingDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tables"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tables", szTables, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    Game
//=================================================================

MLobby::cli::Game::Game()
{
	clear();
}

void MLobby::cli::Game::clear()
{
	handType = 0;
	structure = 0;
	hiLo = 0;
}

bool MLobby::cli::Game::equals(const Game& _o) const
{
	return handType == _o.handType &&
		structure == _o.structure &&
		hiLo == _o.hiLo;
}

const char *MLobby::cli::Game::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("handType=");
	_buf.appendUint(handType);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("hiLo=");
	_buf.appendUint(hiLo);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobby::cli::Game::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("handType", handType, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("hiLo", hiLo, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobby::cli::Game::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("handType"))
		{
			handType = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("structure"))
		{
			structure = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("hiLo"))
		{
			hiLo = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobby::cli::Game::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(Game())) // not empty
	{
		_body.composeBYTE(handType);
		_body.composeBYTE(structure);
		_body.composeBYTE(hiLo);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::Game::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(handType);
	_parser0.parseBYTE(structure);
	_parser0.parseBYTE(hiLo);
}

const char *MLobby::cli::Game::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("handType", handType);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("hiLo", hiLo);
	return _buf.c_str();
}

void MLobby::cli::Game::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("handType", handType);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("hiLo", hiLo);
}

/* static */ void MLobby::cli::Game::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE handType; _jparser.validateByNameThrow("handType", handType);
	AtfValidator::validateIntRange(_descr, "handType", handType, HandTypeNone, HandType_Last, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateIntRange(_descr, "structure", structure, StructNonDefined, PotStruct_Last, _checker, __FILE__, __LINE__);
	BYTE hiLo; _jparser.validateByNameThrow("hiLo", hiLo);
	AtfValidator::validateIntMax(_descr, "hiLo", hiLo, 1, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobby::cli::Game::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	BYTE handType; _parser0.parseBYTE(handType);
	AtfValidator::validateIntRange(_descr, "handType", handType, HandTypeNone, HandType_Last, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateIntRange(_descr, "structure", structure, StructNonDefined, PotStruct_Last, _checker, __FILE__, __LINE__);
	BYTE hiLo; _parser0.parseBYTE(hiLo);
	AtfValidator::validateIntMax(_descr, "hiLo", hiLo, 1, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    MorphLobbySelectionFilter
//=================================================================

MLobby::cli::MorphLobbySelectionFilter::MorphLobbySelectionFilter()
{
	clear();
}

void MLobby::cli::MorphLobbySelectionFilter::clear()
{
	version = 0;
	country.clear();
	siteId = 0;
	brandId = 0;
	game = 0;
	hiLo = 0;
	limit = 0;
	currencyMask = 0;
	isPM = false;
	games.clear();
	showStealthTables = true;
}

bool MLobby::cli::MorphLobbySelectionFilter::equals(const MorphLobbySelectionFilter& _o) const
{
	return version == _o.version &&
		Atf::atfPStringEquals(country, _o.country) &&
		siteId == _o.siteId &&
		brandId == _o.brandId &&
		game == _o.game &&
		hiLo == _o.hiLo &&
		limit == _o.limit &&
		currencyMask == _o.currencyMask &&
		isPM == _o.isPM &&
		games.equals(_o.games) &&
		showStealthTables == _o.showStealthTables;
}

const char *MLobby::cli::MorphLobbySelectionFilter::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("version=");
	_buf.appendUint(version);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("brandId=");
	_buf.appendUint(brandId);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("hiLo=");
	_buf.appendUint(hiLo);
	_buf.append(',');
	_buf.append("limit=");
	_buf.appendUint(limit);
	_buf.append(',');
	_buf.append("currencyMask=");
	_buf.appendUint(currencyMask);
	_buf.append(',');
	_buf.append("isPM=");
	_buf.appendUint(isPM);
	_buf.append(',');
	_buf.append("games=");
	games.toTraceString(_buf);
	_buf.append(',');
	_buf.append("showStealthTables=");
	_buf.appendUint(showStealthTables);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobby::cli::MorphLobbySelectionFilter::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("version", version, _buf);
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::encodeAsXmlElement("siteId", siteId, _buf);
	Atf::XmlElement::encodeAsXmlElement("brandId", brandId, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("hiLo", hiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("limit", limit, _buf);
	Atf::XmlElement::encodeAsXmlElement("currencyMask", currencyMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPM", isPM, _buf);
	games.toXmlString("games", _buf);
	Atf::XmlElement::encodeAsXmlElement("showStealthTables", showStealthTables, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobby::cli::MorphLobbySelectionFilter::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("version"))
		{
			version = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("country"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
		}
		else if (_element.equals("siteId"))
		{
			siteId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("brandId"))
		{
			brandId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("game"))
		{
			game = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("hiLo"))
		{
			hiLo = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("limit"))
		{
			limit = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currencyMask"))
		{
			currencyMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isPM"))
		{
			isPM = (*_value.ptr() == '1');
		}
		else if (_element.equals("games"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< Game, 4 > >::FromXmlString(_value, games)) return false;
		}
		else if (_element.equals("showStealthTables"))
		{
			showStealthTables = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobby::cli::MorphLobbySelectionFilter::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(MorphLobbySelectionFilter())) // not empty
	{
		_body.composeBYTE(version);
		_body.composeString(country);
		_body.composeUINT32(siteId);
		_body.composeUINT32(brandId);
		_body.composeBYTE(game);
		_body.composeBYTE(hiLo);
		_body.composeBYTE(limit);
		_body.composeUINT32(currencyMask);
		_body.composeBOOL(isPM);
		games.composeMsg(_body, _ignoreJSON);
		_body.composeBOOL(showStealthTables);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::MorphLobbySelectionFilter::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(version);
	_parser0.parseStringP(country);
	_parser0.parseUINT32(siteId);
	_parser0.parseUINT32(brandId);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(hiLo);
	_parser0.parseBYTE(limit);
	_parser0.parseUINT32(currencyMask);
	_parser0.parseBOOL(isPM);
	if(_parser0.parseEnded()) return;
	games.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	_parser0.parseBOOL(showStealthTables);
}

const char *MLobby::cli::MorphLobbySelectionFilter::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("version", version);
	_jsonstr.compose("country", country);
	_jsonstr.compose("siteId", siteId);
	_jsonstr.compose("brandId", brandId);
	_jsonstr.compose("game", game);
	_jsonstr.compose("hiLo", hiLo);
	_jsonstr.compose("limit", limit);
	_jsonstr.compose("currencyMask", currencyMask);
	_jsonstr.compose("isPM", isPM);
	_jsonstr.compose("games", games);
	_jsonstr.compose("showStealthTables", showStealthTables);
	return _buf.c_str();
}

void MLobby::cli::MorphLobbySelectionFilter::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("version", version);
	_jparser.parseByNameThrow("country", country);
	_jparser.parseByNameThrow("siteId", siteId);
	_jparser.parseByNameThrow("brandId", brandId);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("hiLo", hiLo);
	_jparser.parseByNameThrow("limit", limit);
	_jparser.parseByNameThrow("currencyMask", currencyMask);
	_jparser.parseByNameThrow("isPM", isPM);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("games", games);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("showStealthTables", showStealthTables);
}

/* static */ void MLobby::cli::MorphLobbySelectionFilter::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE version; _jparser.validateByNameThrow("version", version);
	AtfValidator::validateInt(_descr, "version", version, _checker, __FILE__, __LINE__);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateIntMax(_descr, "country", country.length(), 3, _checker, __FILE__, __LINE__);
	UINT32 siteId; _jparser.validateByNameThrow("siteId", siteId);
	AtfValidator::validateIntRange(_descr, "siteId", siteId, PokerStars_SiteUnknown, (2*PokerStars_Last-1), _checker, __FILE__, __LINE__);
	UINT32 brandId; _jparser.validateByNameThrow("brandId", brandId);
	AtfValidator::validateIntRange(_descr, "brandId", brandId, BrandType_None, (2*BrandType_Last-1), _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateIntRange(_descr, "game", game, HandTypeNone, HandType_Last, _checker, __FILE__, __LINE__);
	BYTE hiLo; _jparser.validateByNameThrow("hiLo", hiLo);
	AtfValidator::validateIntMax(_descr, "hiLo", hiLo, 1, _checker, __FILE__, __LINE__);
	BYTE limit; _jparser.validateByNameThrow("limit", limit);
	AtfValidator::validateIntRange(_descr, "limit", limit, StructNonDefined, PotStruct_Last, _checker, __FILE__, __LINE__);
	UINT32 currencyMask; _jparser.validateByNameThrow("currencyMask", currencyMask);
	AtfValidator::validateIntMax(_descr, "currencyMask", currencyMask, (2*MobileCurrency_Last-1), _checker, __FILE__, __LINE__);
	bool isPM; _jparser.validateByNameThrow("isPM", isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	Atf::AtfVectorBase< Game > games; _jparser.validateByNameThrow("games", games);
	AtfValidator::validateIntMax(_descr, "games", games.size(), 128, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool showStealthTables; _jparser.validateByNameThrow("showStealthTables", showStealthTables);
	AtfValidator::validateInt(_descr, "showStealthTables", showStealthTables, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobby::cli::MorphLobbySelectionFilter::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	BYTE version; _parser0.parseBYTE(version);
	AtfValidator::validateInt(_descr, "version", version, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "country", szCountry, 3, _checker, __FILE__, __LINE__);
	UINT32 siteId; _parser0.parseUINT32(siteId);
	AtfValidator::validateIntRange(_descr, "siteId", siteId, PokerStars_SiteUnknown, (2*PokerStars_Last-1), _checker, __FILE__, __LINE__);
	UINT32 brandId; _parser0.parseUINT32(brandId);
	AtfValidator::validateIntRange(_descr, "brandId", brandId, BrandType_None, (2*BrandType_Last-1), _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateIntRange(_descr, "game", game, HandTypeNone, HandType_Last, _checker, __FILE__, __LINE__);
	BYTE hiLo; _parser0.parseBYTE(hiLo);
	AtfValidator::validateIntMax(_descr, "hiLo", hiLo, 1, _checker, __FILE__, __LINE__);
	BYTE limit; _parser0.parseBYTE(limit);
	AtfValidator::validateIntRange(_descr, "limit", limit, StructNonDefined, PotStruct_Last, _checker, __FILE__, __LINE__);
	UINT32 currencyMask; _parser0.parseUINT32(currencyMask);
	AtfValidator::validateIntMax(_descr, "currencyMask", currencyMask, (2*MobileCurrency_Last-1), _checker, __FILE__, __LINE__);
	bool isPM; _parser0.parseBOOL(isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PString _descbuf;
	int szGames = Atf::LAtfVector< Game, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("games"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "games", szGames, 128, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	bool showStealthTables; _parser0.parseBOOL(showStealthTables);
	AtfValidator::validateInt(_descr, "showStealthTables", showStealthTables, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SeatFinderStruct
//=================================================================

MLobby::cli::SeatFinderStruct::SeatFinderStruct()
{
	clear();
}

void MLobby::cli::SeatFinderStruct::clear()
{
	id = 0;
	game = 0;
	structure = 0;
	isHiLo = 0;
	maxPlayersPerTable = 0;
	loBet = 0;
	hiBet = 0;
	ante = 0;
	cap = 0;
	currency.clear();
	minChipsLimit = 0;
	maxBuyIn = 0;
	visibilityMask = 0;
	defaultBuyIn = 0;
	specialName.clear();
	countryRestrictionInverted = false;
	restrictedCountries.clear();
	replayerAddress.clear();
	replayerInstance.clear();
	minPlayersPerTable = 0;
	isPasswordProtected = false;
	poolBlockMinHands = 0;
	poolBlockTimePenalty.clear();
	flags = 0;
	flags2 = 0;
	isPM = false;
	scalePM = 0;
	handsPerHour = 0;
	avgPotSize = 0;
	avgStackSize = 0;
	numPlayers = 0;
	numTables = 0;
	numFullTables = 0;
	tableStakes.clear();
	variableAntes.clear();
	visibilityMaskEx.clear();
}

bool MLobby::cli::SeatFinderStruct::equals(const SeatFinderStruct& _o) const
{
	return id == _o.id &&
		game == _o.game &&
		structure == _o.structure &&
		isHiLo == _o.isHiLo &&
		maxPlayersPerTable == _o.maxPlayersPerTable &&
		loBet == _o.loBet &&
		hiBet == _o.hiBet &&
		ante == _o.ante &&
		cap == _o.cap &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		minChipsLimit == _o.minChipsLimit &&
		maxBuyIn == _o.maxBuyIn &&
		visibilityMask == _o.visibilityMask &&
		defaultBuyIn == _o.defaultBuyIn &&
		Atf::atfPStringEquals(specialName, _o.specialName) &&
		countryRestrictionInverted == _o.countryRestrictionInverted &&
		restrictedCountries.equals(_o.restrictedCountries) &&
		Atf::atfPStringEquals(replayerAddress, _o.replayerAddress) &&
		Atf::atfPStringEquals(replayerInstance, _o.replayerInstance) &&
		minPlayersPerTable == _o.minPlayersPerTable &&
		isPasswordProtected == _o.isPasswordProtected &&
		poolBlockMinHands == _o.poolBlockMinHands &&
		poolBlockTimePenalty.equals(_o.poolBlockTimePenalty) &&
		flags == _o.flags &&
		flags2 == _o.flags2 &&
		isPM == _o.isPM &&
		scalePM == _o.scalePM &&
		handsPerHour == _o.handsPerHour &&
		avgPotSize == _o.avgPotSize &&
		avgStackSize == _o.avgStackSize &&
		numPlayers == _o.numPlayers &&
		numTables == _o.numTables &&
		numFullTables == _o.numFullTables &&
		tableStakes.equals(_o.tableStakes) &&
		variableAntes.equals(_o.variableAntes) &&
		visibilityMaskEx.equals(_o.visibilityMaskEx);
}

const char *MLobby::cli::SeatFinderStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("id=");
	_buf.appendUint(id);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("maxPlayersPerTable=");
	_buf.appendUint(maxPlayersPerTable);
	_buf.append(',');
	_buf.append("loBet=");
	_buf.appendInt(loBet);
	_buf.append(',');
	_buf.append("hiBet=");
	_buf.appendInt(hiBet);
	_buf.append(',');
	_buf.append("ante=");
	_buf.appendInt(ante);
	_buf.append(',');
	_buf.append("cap=");
	_buf.appendInt(cap);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("minChipsLimit=");
	_buf.appendInt(minChipsLimit);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendInt(maxBuyIn);
	_buf.append(',');
	_buf.append("visibilityMask=");
	_buf.appendUint(visibilityMask);
	_buf.append(',');
	_buf.append("defaultBuyIn=");
	_buf.appendInt(defaultBuyIn);
	_buf.append(',');
	_buf.append("specialName=");
	_buf.append(specialName);
	_buf.append(',');
	_buf.append("countryRestrictionInverted=");
	_buf.appendUint(countryRestrictionInverted);
	_buf.append(',');
	_buf.append("restrictedCountries=");
	restrictedCountries.toTraceString(_buf);
	_buf.append(',');
	_buf.append("replayerAddress=");
	_buf.append(replayerAddress);
	_buf.append(',');
	_buf.append("replayerInstance=");
	_buf.append(replayerInstance);
	_buf.append(',');
	_buf.append("minPlayersPerTable=");
	_buf.appendInt(minPlayersPerTable);
	_buf.append(',');
	_buf.append("isPasswordProtected=");
	_buf.appendUint(isPasswordProtected);
	_buf.append(',');
	_buf.append("poolBlockMinHands=");
	_buf.appendInt(poolBlockMinHands);
	_buf.append(',');
	_buf.append("poolBlockTimePenalty=");
	poolBlockTimePenalty.toTraceString(_buf);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("flags2=");
	_buf.appendUint64(flags2);
	_buf.append(',');
	_buf.append("isPM=");
	_buf.appendUint(isPM);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("handsPerHour=");
	_buf.appendInt(handsPerHour);
	_buf.append(',');
	_buf.append("avgPotSize=");
	_buf.appendInt(avgPotSize);
	_buf.append(',');
	_buf.append("avgStackSize=");
	_buf.appendInt(avgStackSize);
	_buf.append(',');
	_buf.append("numPlayers=");
	_buf.appendInt(numPlayers);
	_buf.append(',');
	_buf.append("numTables=");
	_buf.appendInt(numTables);
	_buf.append(',');
	_buf.append("numFullTables=");
	_buf.appendInt(numFullTables);
	_buf.append(',');
	_buf.append("tableStakes=");
	tableStakes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("variableAntes=");
	variableAntes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("visibilityMaskEx=");
	visibilityMaskEx.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobby::cli::SeatFinderStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("id", id, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPlayersPerTable", maxPlayersPerTable, _buf);
	Atf::XmlElement::encodeAsXmlElement("loBet", loBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("hiBet", hiBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("ante", ante, _buf);
	Atf::XmlElement::encodeAsXmlElement("cap", cap, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("minChipsLimit", minChipsLimit, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxBuyIn", maxBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("visibilityMask", visibilityMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("defaultBuyIn", defaultBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("specialName", specialName, _buf);
	Atf::XmlElement::encodeAsXmlElement("countryRestrictionInverted", countryRestrictionInverted, _buf);
	restrictedCountries.toXmlString("restrictedCountries", _buf);
	Atf::XmlElement::encodeAsXmlElement("replayerAddress", replayerAddress, _buf);
	Atf::XmlElement::encodeAsXmlElement("replayerInstance", replayerInstance, _buf);
	Atf::XmlElement::encodeAsXmlElement("minPlayersPerTable", minPlayersPerTable, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPasswordProtected", isPasswordProtected, _buf);
	Atf::XmlElement::encodeAsXmlElement("poolBlockMinHands", poolBlockMinHands, _buf);
	poolBlockTimePenalty.toXmlString("poolBlockTimePenalty", _buf);
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags2", flags2, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPM", isPM, _buf);
	Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
	Atf::XmlElement::encodeAsXmlElement("handsPerHour", handsPerHour, _buf);
	Atf::XmlElement::encodeAsXmlElement("avgPotSize", avgPotSize, _buf);
	Atf::XmlElement::encodeAsXmlElement("avgStackSize", avgStackSize, _buf);
	Atf::XmlElement::encodeAsXmlElement("numPlayers", numPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("numTables", numTables, _buf);
	Atf::XmlElement::encodeAsXmlElement("numFullTables", numFullTables, _buf);
	tableStakes.toXmlString("tableStakes", _buf);
	variableAntes.toXmlString("variableAntes", _buf);
	visibilityMaskEx.toXmlString("visibilityMaskEx", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobby::cli::SeatFinderStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("id"))
		{
			id = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("game"))
		{
			game = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("structure"))
		{
			structure = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxPlayersPerTable"))
		{
			maxPlayersPerTable = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("loBet"))
		{
			loBet = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("hiBet"))
		{
			hiBet = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("ante"))
		{
			ante = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("cap"))
		{
			cap = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("minChipsLimit"))
		{
			minChipsLimit = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxBuyIn"))
		{
			maxBuyIn = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("visibilityMask"))
		{
			visibilityMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("defaultBuyIn"))
		{
			defaultBuyIn = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("specialName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, specialName)) return false;
		}
		else if (_element.equals("countryRestrictionInverted"))
		{
			countryRestrictionInverted = (*_value.ptr() == '1');
		}
		else if (_element.equals("restrictedCountries"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PString, 4 > >::FromXmlString(_value, restrictedCountries)) return false;
		}
		else if (_element.equals("replayerAddress"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, replayerAddress)) return false;
		}
		else if (_element.equals("replayerInstance"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, replayerInstance)) return false;
		}
		else if (_element.equals("minPlayersPerTable"))
		{
			minPlayersPerTable = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isPasswordProtected"))
		{
			isPasswordProtected = (*_value.ptr() == '1');
		}
		else if (_element.equals("poolBlockMinHands"))
		{
			poolBlockMinHands = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("poolBlockTimePenalty"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT32, 4 > >::FromXmlString(_value, poolBlockTimePenalty)) return false;
		}
		else if (_element.equals("flags"))
		{
			flags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("flags2"))
		{
			flags2 = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isPM"))
		{
			isPM = (*_value.ptr() == '1');
		}
		else if (_element.equals("scalePM"))
		{
			scalePM = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("handsPerHour"))
		{
			handsPerHour = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("avgPotSize"))
		{
			avgPotSize = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("avgStackSize"))
		{
			avgStackSize = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numPlayers"))
		{
			numPlayers = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numTables"))
		{
			numTables = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numFullTables"))
		{
			numFullTables = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableStakes"))
		{
			if(!Atf::AtfTempl< TableCommon::TableStakes >::FromXmlString(_value, tableStakes)) return false;
		}
		else if (_element.equals("variableAntes"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT64, 4 > >::FromXmlString(_value, variableAntes)) return false;
		}
		else if (_element.equals("visibilityMaskEx"))
		{
			if(!Atf::AtfTempl< PSiteMask >::FromXmlString(_value, visibilityMaskEx)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobby::cli::SeatFinderStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(SeatFinderStruct())) // not empty
	{
		_body.composeUINT32(id);
		_body.composeBYTE(game);
		_body.composeBYTE(structure);
		_body.composeBYTE(isHiLo);
		_body.composeBYTE(maxPlayersPerTable);
		_body.composeINT32(loBet);
		_body.composeINT32(hiBet);
		_body.composeINT32(ante);
		_body.composeINT32(cap);
		_body.composeString(currency);
		_body.composeINT32(minChipsLimit);
		_body.composeINT32(maxBuyIn);
		_body.composeUINT32(visibilityMask);
		_body.composeINT32(defaultBuyIn);
		_body.composeString(specialName);
		_body.composeBOOL(countryRestrictionInverted);
		restrictedCountries.composeMsg(_body, _ignoreJSON);
		_body.composeString(replayerAddress);
		_body.composeString(replayerInstance);
		_body.composeINT8(minPlayersPerTable);
		_body.composeBOOL(isPasswordProtected);
		_body.composeINT32(poolBlockMinHands);
		poolBlockTimePenalty.composeMsg(_body, _ignoreJSON);
		_body.composeUINT32(flags);
		_body.composeUINT64(flags2);
		_body.composeBOOL(isPM);
		_body.composeUINT32(scalePM);
		_body.composeINT32(handsPerHour);
		_body.composeINT32(avgPotSize);
		_body.composeINT32(avgStackSize);
		_body.composeINT32(numPlayers);
		_body.composeINT32(numTables);
		_body.composeINT32(numFullTables);
		tableStakes.composeMsg(_body, _ignoreJSON);
		variableAntes.composeMsg(_body, _ignoreJSON);
		visibilityMaskEx.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::SeatFinderStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(id);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(structure);
	_parser0.parseBYTE(isHiLo);
	_parser0.parseBYTE(maxPlayersPerTable);
	_parser0.parseINT32(loBet);
	_parser0.parseINT32(hiBet);
	_parser0.parseINT32(ante);
	_parser0.parseINT32(cap);
	_parser0.parseStringP(currency);
	_parser0.parseINT32(minChipsLimit);
	_parser0.parseINT32(maxBuyIn);
	_parser0.parseUINT32(visibilityMask);
	_parser0.parseINT32(defaultBuyIn);
	_parser0.parseStringP(specialName);
	_parser0.parseBOOL(countryRestrictionInverted);
	restrictedCountries.parseMsg(_parser0);
	_parser0.parseStringP(replayerAddress);
	_parser0.parseStringP(replayerInstance);
	_parser0.parseINT8(minPlayersPerTable);
	_parser0.parseBOOL(isPasswordProtected);
	_parser0.parseINT32(poolBlockMinHands);
	poolBlockTimePenalty.parseMsg(_parser0);
	_parser0.parseUINT32(flags);
	_parser0.parseUINT64(flags2);
	_parser0.parseBOOL(isPM);
	_parser0.parseUINT32(scalePM);
	_parser0.parseINT32(handsPerHour);
	_parser0.parseINT32(avgPotSize);
	_parser0.parseINT32(avgStackSize);
	_parser0.parseINT32(numPlayers);
	_parser0.parseINT32(numTables);
	_parser0.parseINT32(numFullTables);
	if(_parser0.parseEnded()) return;
	tableStakes.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	variableAntes.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	visibilityMaskEx.parseMsg(_parser0);
}

const char *MLobby::cli::SeatFinderStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("id", id);
	_jsonstr.compose("game", game);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("maxPlayersPerTable", maxPlayersPerTable);
	_jsonstr.compose("loBet", loBet);
	_jsonstr.compose("hiBet", hiBet);
	_jsonstr.compose("ante", ante);
	_jsonstr.compose("cap", cap);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("minChipsLimit", minChipsLimit);
	_jsonstr.compose("maxBuyIn", maxBuyIn);
	_jsonstr.compose("visibilityMask", visibilityMask);
	_jsonstr.compose("defaultBuyIn", defaultBuyIn);
	_jsonstr.compose("specialName", specialName);
	_jsonstr.compose("countryRestrictionInverted", countryRestrictionInverted);
	_jsonstr.compose("restrictedCountries", restrictedCountries);
	_jsonstr.compose("replayerAddress", replayerAddress);
	_jsonstr.compose("replayerInstance", replayerInstance);
	_jsonstr.compose("minPlayersPerTable", minPlayersPerTable);
	_jsonstr.compose("isPasswordProtected", isPasswordProtected);
	_jsonstr.compose("poolBlockMinHands", poolBlockMinHands);
	_jsonstr.compose("poolBlockTimePenalty", poolBlockTimePenalty);
	_jsonstr.compose("flags", flags);
	_jsonstr.compose("flags2", flags2);
	_jsonstr.compose("isPM", isPM);
	_jsonstr.compose("scalePM", scalePM);
	_jsonstr.compose("handsPerHour", handsPerHour);
	_jsonstr.compose("avgPotSize", avgPotSize);
	_jsonstr.compose("avgStackSize", avgStackSize);
	_jsonstr.compose("numPlayers", numPlayers);
	_jsonstr.compose("numTables", numTables);
	_jsonstr.compose("numFullTables", numFullTables);
	_jsonstr.compose("tableStakes", tableStakes);
	_jsonstr.compose("variableAntes", variableAntes);
	_jsonstr.compose("visibilityMaskEx", visibilityMaskEx);
	return _buf.c_str();
}

void MLobby::cli::SeatFinderStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("id", id);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("maxPlayersPerTable", maxPlayersPerTable);
	_jparser.parseByNameThrow("loBet", loBet);
	_jparser.parseByNameThrow("hiBet", hiBet);
	_jparser.parseByNameThrow("ante", ante);
	_jparser.parseByNameThrow("cap", cap);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("minChipsLimit", minChipsLimit);
	_jparser.parseByNameThrow("maxBuyIn", maxBuyIn);
	_jparser.parseByNameThrow("visibilityMask", visibilityMask);
	_jparser.parseByNameThrow("defaultBuyIn", defaultBuyIn);
	_jparser.parseByNameThrow("specialName", specialName);
	_jparser.parseByNameThrow("countryRestrictionInverted", countryRestrictionInverted);
	_jparser.parseByNameThrow("restrictedCountries", restrictedCountries);
	_jparser.parseByNameThrow("replayerAddress", replayerAddress);
	_jparser.parseByNameThrow("replayerInstance", replayerInstance);
	_jparser.parseByNameThrow("minPlayersPerTable", minPlayersPerTable);
	_jparser.parseByNameThrow("isPasswordProtected", isPasswordProtected);
	_jparser.parseByNameThrow("poolBlockMinHands", poolBlockMinHands);
	_jparser.parseByNameThrow("poolBlockTimePenalty", poolBlockTimePenalty);
	_jparser.parseByNameThrow("flags", flags);
	_jparser.parseByNameThrow("flags2", flags2);
	_jparser.parseByNameThrow("isPM", isPM);
	_jparser.parseByNameThrow("scalePM", scalePM);
	_jparser.parseByNameThrow("handsPerHour", handsPerHour);
	_jparser.parseByNameThrow("avgPotSize", avgPotSize);
	_jparser.parseByNameThrow("avgStackSize", avgStackSize);
	_jparser.parseByNameThrow("numPlayers", numPlayers);
	_jparser.parseByNameThrow("numTables", numTables);
	_jparser.parseByNameThrow("numFullTables", numFullTables);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tableStakes", tableStakes);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("variableAntes", variableAntes);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("visibilityMaskEx", visibilityMaskEx);
}

/* static */ void MLobby::cli::SeatFinderStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 id; _jparser.validateByNameThrow("id", id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE maxPlayersPerTable; _jparser.validateByNameThrow("maxPlayersPerTable", maxPlayersPerTable);
	AtfValidator::validateInt(_descr, "maxPlayersPerTable", maxPlayersPerTable, _checker, __FILE__, __LINE__);
	INT32 loBet; _jparser.validateByNameThrow("loBet", loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	INT32 hiBet; _jparser.validateByNameThrow("hiBet", hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	INT32 ante; _jparser.validateByNameThrow("ante", ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	INT32 cap; _jparser.validateByNameThrow("cap", cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	INT32 minChipsLimit; _jparser.validateByNameThrow("minChipsLimit", minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	INT32 maxBuyIn; _jparser.validateByNameThrow("maxBuyIn", maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	UINT32 visibilityMask; _jparser.validateByNameThrow("visibilityMask", visibilityMask);
	AtfValidator::validateInt(_descr, "visibilityMask", visibilityMask, _checker, __FILE__, __LINE__);
	INT32 defaultBuyIn; _jparser.validateByNameThrow("defaultBuyIn", defaultBuyIn);
	AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	PString specialName; _jparser.validateByNameThrow("specialName", specialName);
	AtfValidator::validateInt(_descr, "specialName", specialName.length(), _checker, __FILE__, __LINE__);
	bool countryRestrictionInverted; _jparser.validateByNameThrow("countryRestrictionInverted", countryRestrictionInverted);
	AtfValidator::validateInt(_descr, "countryRestrictionInverted", countryRestrictionInverted, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PString > restrictedCountries; _jparser.validateByNameThrow("restrictedCountries", restrictedCountries);
	AtfValidator::validateInt(_descr, "restrictedCountries", restrictedCountries.size(), _checker, __FILE__, __LINE__);
	PString replayerAddress; _jparser.validateByNameThrow("replayerAddress", replayerAddress);
	AtfValidator::validateInt(_descr, "replayerAddress", replayerAddress.length(), _checker, __FILE__, __LINE__);
	PString replayerInstance; _jparser.validateByNameThrow("replayerInstance", replayerInstance);
	AtfValidator::validateInt(_descr, "replayerInstance", replayerInstance.length(), _checker, __FILE__, __LINE__);
	INT8 minPlayersPerTable; _jparser.validateByNameThrow("minPlayersPerTable", minPlayersPerTable);
	AtfValidator::validateInt(_descr, "minPlayersPerTable", minPlayersPerTable, _checker, __FILE__, __LINE__);
	bool isPasswordProtected; _jparser.validateByNameThrow("isPasswordProtected", isPasswordProtected);
	AtfValidator::validateInt(_descr, "isPasswordProtected", isPasswordProtected, _checker, __FILE__, __LINE__);
	INT32 poolBlockMinHands; _jparser.validateByNameThrow("poolBlockMinHands", poolBlockMinHands);
	AtfValidator::validateInt(_descr, "poolBlockMinHands", poolBlockMinHands, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< INT32 > poolBlockTimePenalty; _jparser.validateByNameThrow("poolBlockTimePenalty", poolBlockTimePenalty);
	AtfValidator::validateInt(_descr, "poolBlockTimePenalty", poolBlockTimePenalty.size(), _checker, __FILE__, __LINE__);
	UINT32 flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT64 flags2; _jparser.validateByNameThrow("flags2", flags2);
	AtfValidator::validateUint(_descr, "flags2", flags2, _checker, __FILE__, __LINE__);
	bool isPM; _jparser.validateByNameThrow("isPM", isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	INT32 handsPerHour; _jparser.validateByNameThrow("handsPerHour", handsPerHour);
	AtfValidator::validateInt(_descr, "handsPerHour", handsPerHour, _checker, __FILE__, __LINE__);
	INT32 avgPotSize; _jparser.validateByNameThrow("avgPotSize", avgPotSize);
	AtfValidator::validateInt(_descr, "avgPotSize", avgPotSize, _checker, __FILE__, __LINE__);
	INT32 avgStackSize; _jparser.validateByNameThrow("avgStackSize", avgStackSize);
	AtfValidator::validateInt(_descr, "avgStackSize", avgStackSize, _checker, __FILE__, __LINE__);
	INT32 numPlayers; _jparser.validateByNameThrow("numPlayers", numPlayers);
	AtfValidator::validateInt(_descr, "numPlayers", numPlayers, _checker, __FILE__, __LINE__);
	INT32 numTables; _jparser.validateByNameThrow("numTables", numTables);
	AtfValidator::validateInt(_descr, "numTables", numTables, _checker, __FILE__, __LINE__);
	INT32 numFullTables; _jparser.validateByNameThrow("numFullTables", numFullTables);
	AtfValidator::validateInt(_descr, "numFullTables", numFullTables, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	TableCommon::TableStakes tableStakes; _jparser.validateByNameThrow("tableStakes", tableStakes);
	if(_jparser.parseEnded()) return;
	Atf::AtfVectorBase< INT64 > variableAntes; _jparser.validateByNameThrow("variableAntes", variableAntes);
	AtfValidator::validateInt(_descr, "variableAntes", variableAntes.size(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PSiteMask visibilityMaskEx; _jparser.validateByNameThrow("visibilityMaskEx", visibilityMaskEx);
}

/*static*/ void MLobby::cli::SeatFinderStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 id; _parser0.parseUINT32(id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser0.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE maxPlayersPerTable; _parser0.parseBYTE(maxPlayersPerTable);
	AtfValidator::validateInt(_descr, "maxPlayersPerTable", maxPlayersPerTable, _checker, __FILE__, __LINE__);
	INT32 loBet; _parser0.parseINT32(loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	INT32 hiBet; _parser0.parseINT32(hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	INT32 ante; _parser0.parseINT32(ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	INT32 cap; _parser0.parseINT32(cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT32 minChipsLimit; _parser0.parseINT32(minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	INT32 maxBuyIn; _parser0.parseINT32(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	UINT32 visibilityMask; _parser0.parseUINT32(visibilityMask);
	AtfValidator::validateInt(_descr, "visibilityMask", visibilityMask, _checker, __FILE__, __LINE__);
	INT32 defaultBuyIn; _parser0.parseINT32(defaultBuyIn);
	AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "specialName"); size_t szSpecialName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "specialName", szSpecialName, _checker, __FILE__, __LINE__);
	bool countryRestrictionInverted; _parser0.parseBOOL(countryRestrictionInverted);
	AtfValidator::validateInt(_descr, "countryRestrictionInverted", countryRestrictionInverted, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szRestrictedCountries = Atf::LAtfVector< PString, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("restrictedCountries"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "restrictedCountries", szRestrictedCountries, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "replayerAddress"); size_t szReplayerAddress = strlen(_dummy);
	AtfValidator::validateInt(_descr, "replayerAddress", szReplayerAddress, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "replayerInstance"); size_t szReplayerInstance = strlen(_dummy);
	AtfValidator::validateInt(_descr, "replayerInstance", szReplayerInstance, _checker, __FILE__, __LINE__);
	INT8 minPlayersPerTable; _parser0.parseINT8(minPlayersPerTable);
	AtfValidator::validateInt(_descr, "minPlayersPerTable", minPlayersPerTable, _checker, __FILE__, __LINE__);
	bool isPasswordProtected; _parser0.parseBOOL(isPasswordProtected);
	AtfValidator::validateInt(_descr, "isPasswordProtected", isPasswordProtected, _checker, __FILE__, __LINE__);
	INT32 poolBlockMinHands; _parser0.parseINT32(poolBlockMinHands);
	AtfValidator::validateInt(_descr, "poolBlockMinHands", poolBlockMinHands, _checker, __FILE__, __LINE__);
	int szPoolBlockTimePenalty = Atf::LAtfVector< INT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("poolBlockTimePenalty"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "poolBlockTimePenalty", szPoolBlockTimePenalty, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser0.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT64 flags2; _parser0.parseUINT64(flags2);
	AtfValidator::validateUint(_descr, "flags2", flags2, _checker, __FILE__, __LINE__);
	bool isPM; _parser0.parseBOOL(isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser0.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	INT32 handsPerHour; _parser0.parseINT32(handsPerHour);
	AtfValidator::validateInt(_descr, "handsPerHour", handsPerHour, _checker, __FILE__, __LINE__);
	INT32 avgPotSize; _parser0.parseINT32(avgPotSize);
	AtfValidator::validateInt(_descr, "avgPotSize", avgPotSize, _checker, __FILE__, __LINE__);
	INT32 avgStackSize; _parser0.parseINT32(avgStackSize);
	AtfValidator::validateInt(_descr, "avgStackSize", avgStackSize, _checker, __FILE__, __LINE__);
	INT32 numPlayers; _parser0.parseINT32(numPlayers);
	AtfValidator::validateInt(_descr, "numPlayers", numPlayers, _checker, __FILE__, __LINE__);
	INT32 numTables; _parser0.parseINT32(numTables);
	AtfValidator::validateInt(_descr, "numTables", numTables, _checker, __FILE__, __LINE__);
	INT32 numFullTables; _parser0.parseINT32(numFullTables);
	AtfValidator::validateInt(_descr, "numFullTables", numFullTables, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	TableCommon::TableStakes::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tableStakes"), _fieldsWithUnparsedContent);
	if(_parser0.parseEnded()) return;
	int szVariableAntes = Atf::LAtfVector< INT64, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("variableAntes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "variableAntes", szVariableAntes, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("visibilityMaskEx"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TableTypeStaticDataStruct
//=================================================================

MLobby::cli::TableTypeStaticDataStruct::TableTypeStaticDataStruct()
{
	clear();
}

void MLobby::cli::TableTypeStaticDataStruct::clear()
{
	id = 0;
	isPlayMoney = 0;
	game = 0;
	isHiLo = 0;
	maxPlayers = 0;
	visibilityMask = 0;
	structure = 0;
	loBet = 0;
	hiBet = 0;
	ante = 0;
	cap = 0;
	currency.clear();
	minChipsLimit = 0;
	maxBuyIn = 0;
	countryRestrictionInverted = false;
	restrictedCountries.clear();
	visible = false;
	scalePM = 0;
	defaultBuyIn = 0;
	brandMask = 0;
	seatFinderId = 0;
	poolBlockMinHands = 0;
	poolBlockTimePenalty.clear();
	isPasswordProtected = false;
	isMorphLobby = false;
	tableStakes.clear();
	variableAntes.clear();
	specialName.clear();
	visibilityMaskEx.clear();
}

bool MLobby::cli::TableTypeStaticDataStruct::equals(const TableTypeStaticDataStruct& _o) const
{
	return id == _o.id &&
		isPlayMoney == _o.isPlayMoney &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		maxPlayers == _o.maxPlayers &&
		visibilityMask == _o.visibilityMask &&
		structure == _o.structure &&
		loBet == _o.loBet &&
		hiBet == _o.hiBet &&
		ante == _o.ante &&
		cap == _o.cap &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		minChipsLimit == _o.minChipsLimit &&
		maxBuyIn == _o.maxBuyIn &&
		countryRestrictionInverted == _o.countryRestrictionInverted &&
		restrictedCountries.equals(_o.restrictedCountries) &&
		visible == _o.visible &&
		scalePM == _o.scalePM &&
		defaultBuyIn == _o.defaultBuyIn &&
		brandMask == _o.brandMask &&
		seatFinderId == _o.seatFinderId &&
		poolBlockMinHands == _o.poolBlockMinHands &&
		poolBlockTimePenalty.equals(_o.poolBlockTimePenalty) &&
		isPasswordProtected == _o.isPasswordProtected &&
		isMorphLobby == _o.isMorphLobby &&
		tableStakes.equals(_o.tableStakes) &&
		variableAntes.equals(_o.variableAntes) &&
		Atf::atfPStringEquals(specialName, _o.specialName) &&
		visibilityMaskEx.equals(_o.visibilityMaskEx);
}

const char *MLobby::cli::TableTypeStaticDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("id=");
	_buf.appendUint(id);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendUint(maxPlayers);
	_buf.append(',');
	_buf.append("visibilityMask=");
	_buf.appendUint(visibilityMask);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("loBet=");
	_buf.appendUint(loBet);
	_buf.append(',');
	_buf.append("hiBet=");
	_buf.appendUint(hiBet);
	_buf.append(',');
	_buf.append("ante=");
	_buf.appendUint(ante);
	_buf.append(',');
	_buf.append("cap=");
	_buf.appendUint(cap);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("minChipsLimit=");
	_buf.appendUint(minChipsLimit);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendUint(maxBuyIn);
	_buf.append(',');
	_buf.append("countryRestrictionInverted=");
	_buf.appendUint(countryRestrictionInverted);
	_buf.append(',');
	_buf.append("restrictedCountries=");
	restrictedCountries.toTraceString(_buf);
	_buf.append(',');
	_buf.append("visible=");
	_buf.appendUint(visible);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("defaultBuyIn=");
	_buf.appendUint(defaultBuyIn);
	_buf.append(',');
	_buf.append("brandMask=");
	_buf.appendUint(brandMask);
	_buf.append(',');
	_buf.append("seatFinderId=");
	_buf.appendUint(seatFinderId);
	_buf.append(',');
	_buf.append("poolBlockMinHands=");
	_buf.appendInt(poolBlockMinHands);
	_buf.append(',');
	_buf.append("poolBlockTimePenalty=");
	poolBlockTimePenalty.toTraceString(_buf);
	_buf.append(',');
	_buf.append("isPasswordProtected=");
	_buf.appendUint(isPasswordProtected);
	_buf.append(',');
	_buf.append("isMorphLobby=");
	_buf.appendUint(isMorphLobby);
	_buf.append(',');
	_buf.append("tableStakes=");
	tableStakes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("variableAntes=");
	variableAntes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("specialName=");
	_buf.append(specialName);
	_buf.append(',');
	_buf.append("visibilityMaskEx=");
	visibilityMaskEx.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobby::cli::TableTypeStaticDataStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("id", id, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPlayers", maxPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("visibilityMask", visibilityMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("loBet", loBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("hiBet", hiBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("ante", ante, _buf);
	Atf::XmlElement::encodeAsXmlElement("cap", cap, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("minChipsLimit", minChipsLimit, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxBuyIn", maxBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("countryRestrictionInverted", countryRestrictionInverted, _buf);
	restrictedCountries.toXmlString("restrictedCountries", _buf);
	Atf::XmlElement::encodeAsXmlElement("visible", visible, _buf);
	Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
	Atf::XmlElement::encodeAsXmlElement("defaultBuyIn", defaultBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("brandMask", brandMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("seatFinderId", seatFinderId, _buf);
	Atf::XmlElement::encodeAsXmlElement("poolBlockMinHands", poolBlockMinHands, _buf);
	poolBlockTimePenalty.toXmlString("poolBlockTimePenalty", _buf);
	Atf::XmlElement::encodeAsXmlElement("isPasswordProtected", isPasswordProtected, _buf);
	Atf::XmlElement::encodeAsXmlElement("isMorphLobby", isMorphLobby, _buf);
	tableStakes.toXmlString("tableStakes", _buf);
	variableAntes.toXmlString("variableAntes", _buf);
	Atf::XmlElement::encodeAsXmlElement("specialName", specialName, _buf);
	visibilityMaskEx.toXmlString("visibilityMaskEx", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobby::cli::TableTypeStaticDataStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("id"))
		{
			id = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isPlayMoney"))
		{
			isPlayMoney = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("game"))
		{
			game = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxPlayers"))
		{
			maxPlayers = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("visibilityMask"))
		{
			visibilityMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("structure"))
		{
			structure = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("loBet"))
		{
			loBet = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("hiBet"))
		{
			hiBet = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("ante"))
		{
			ante = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("cap"))
		{
			cap = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("minChipsLimit"))
		{
			minChipsLimit = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxBuyIn"))
		{
			maxBuyIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("countryRestrictionInverted"))
		{
			countryRestrictionInverted = (*_value.ptr() == '1');
		}
		else if (_element.equals("restrictedCountries"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PString, 4 > >::FromXmlString(_value, restrictedCountries)) return false;
		}
		else if (_element.equals("visible"))
		{
			visible = (*_value.ptr() == '1');
		}
		else if (_element.equals("scalePM"))
		{
			scalePM = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("defaultBuyIn"))
		{
			defaultBuyIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("brandMask"))
		{
			brandMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("seatFinderId"))
		{
			seatFinderId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("poolBlockMinHands"))
		{
			poolBlockMinHands = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("poolBlockTimePenalty"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT32, 4 > >::FromXmlString(_value, poolBlockTimePenalty)) return false;
		}
		else if (_element.equals("isPasswordProtected"))
		{
			isPasswordProtected = (*_value.ptr() == '1');
		}
		else if (_element.equals("isMorphLobby"))
		{
			isMorphLobby = (*_value.ptr() == '1');
		}
		else if (_element.equals("tableStakes"))
		{
			if(!Atf::AtfTempl< TableCommon::TableStakes >::FromXmlString(_value, tableStakes)) return false;
		}
		else if (_element.equals("variableAntes"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT64, 4 > >::FromXmlString(_value, variableAntes)) return false;
		}
		else if (_element.equals("specialName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, specialName)) return false;
		}
		else if (_element.equals("visibilityMaskEx"))
		{
			if(!Atf::AtfTempl< PSiteMask >::FromXmlString(_value, visibilityMaskEx)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobby::cli::TableTypeStaticDataStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(TableTypeStaticDataStruct())) // not empty
	{
		_body.composeUINT32(id);
		_body.composeBYTE(isPlayMoney);
		_body.composeBYTE(game);
		_body.composeBYTE(isHiLo);
		_body.composeBYTE(maxPlayers);
		_body.composeUINT32(visibilityMask);
		_body.composeBYTE(structure);
		_body.composeUINT32(loBet);
		_body.composeUINT32(hiBet);
		_body.composeUINT32(ante);
		_body.composeUINT32(cap);
		_body.composeString(currency);
		_body.composeUINT32(minChipsLimit);
		_body.composeUINT32(maxBuyIn);
		_body.composeBOOL(countryRestrictionInverted);
		restrictedCountries.composeMsg(_body, _ignoreJSON);
		_body.composeBOOL(visible);
		_body.composeUINT32(scalePM);
		_body.composeUINT32(defaultBuyIn);
		_body.composeUINT32(brandMask);
		_body.composeUINT32(seatFinderId);
		_body.composeINT32(poolBlockMinHands);
		poolBlockTimePenalty.composeMsg(_body, _ignoreJSON);
		_body.composeBOOL(isPasswordProtected);
		_body.composeBOOL(isMorphLobby);
		tableStakes.composeMsg(_body, _ignoreJSON);
		variableAntes.composeMsg(_body, _ignoreJSON);
		_body.composeString(specialName);
		visibilityMaskEx.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::TableTypeStaticDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(id);
	_parser0.parseBYTE(isPlayMoney);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(isHiLo);
	_parser0.parseBYTE(maxPlayers);
	_parser0.parseUINT32(visibilityMask);
	_parser0.parseBYTE(structure);
	_parser0.parseUINT32(loBet);
	_parser0.parseUINT32(hiBet);
	_parser0.parseUINT32(ante);
	_parser0.parseUINT32(cap);
	_parser0.parseStringP(currency);
	_parser0.parseUINT32(minChipsLimit);
	_parser0.parseUINT32(maxBuyIn);
	_parser0.parseBOOL(countryRestrictionInverted);
	restrictedCountries.parseMsg(_parser0);
	_parser0.parseBOOL(visible);
	_parser0.parseUINT32(scalePM);
	_parser0.parseUINT32(defaultBuyIn);
	_parser0.parseUINT32(brandMask);
	_parser0.parseUINT32(seatFinderId);
	_parser0.parseINT32(poolBlockMinHands);
	poolBlockTimePenalty.parseMsg(_parser0);
	_parser0.parseBOOL(isPasswordProtected);
	_parser0.parseBOOL(isMorphLobby);
	tableStakes.parseMsg(_parser0);
	variableAntes.parseMsg(_parser0);
	_parser0.parseStringP(specialName);
	if(_parser0.parseEnded()) return;
	visibilityMaskEx.parseMsg(_parser0);
}

const char *MLobby::cli::TableTypeStaticDataStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("id", id);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("game", game);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("maxPlayers", maxPlayers);
	_jsonstr.compose("visibilityMask", visibilityMask);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("loBet", loBet);
	_jsonstr.compose("hiBet", hiBet);
	_jsonstr.compose("ante", ante);
	_jsonstr.compose("cap", cap);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("minChipsLimit", minChipsLimit);
	_jsonstr.compose("maxBuyIn", maxBuyIn);
	_jsonstr.compose("countryRestrictionInverted", countryRestrictionInverted);
	_jsonstr.compose("restrictedCountries", restrictedCountries);
	_jsonstr.compose("visible", visible);
	_jsonstr.compose("scalePM", scalePM);
	_jsonstr.compose("defaultBuyIn", defaultBuyIn);
	_jsonstr.compose("brandMask", brandMask);
	_jsonstr.compose("seatFinderId", seatFinderId);
	_jsonstr.compose("poolBlockMinHands", poolBlockMinHands);
	_jsonstr.compose("poolBlockTimePenalty", poolBlockTimePenalty);
	_jsonstr.compose("isPasswordProtected", isPasswordProtected);
	_jsonstr.compose("isMorphLobby", isMorphLobby);
	_jsonstr.compose("tableStakes", tableStakes);
	_jsonstr.compose("variableAntes", variableAntes);
	_jsonstr.compose("specialName", specialName);
	_jsonstr.compose("visibilityMaskEx", visibilityMaskEx);
	return _buf.c_str();
}

void MLobby::cli::TableTypeStaticDataStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("id", id);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("maxPlayers", maxPlayers);
	_jparser.parseByNameThrow("visibilityMask", visibilityMask);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("loBet", loBet);
	_jparser.parseByNameThrow("hiBet", hiBet);
	_jparser.parseByNameThrow("ante", ante);
	_jparser.parseByNameThrow("cap", cap);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("minChipsLimit", minChipsLimit);
	_jparser.parseByNameThrow("maxBuyIn", maxBuyIn);
	_jparser.parseByNameThrow("countryRestrictionInverted", countryRestrictionInverted);
	_jparser.parseByNameThrow("restrictedCountries", restrictedCountries);
	_jparser.parseByNameThrow("visible", visible);
	_jparser.parseByNameThrow("scalePM", scalePM);
	_jparser.parseByNameThrow("defaultBuyIn", defaultBuyIn);
	_jparser.parseByNameThrow("brandMask", brandMask);
	_jparser.parseByNameThrow("seatFinderId", seatFinderId);
	_jparser.parseByNameThrow("poolBlockMinHands", poolBlockMinHands);
	_jparser.parseByNameThrow("poolBlockTimePenalty", poolBlockTimePenalty);
	_jparser.parseByNameThrow("isPasswordProtected", isPasswordProtected);
	_jparser.parseByNameThrow("isMorphLobby", isMorphLobby);
	_jparser.parseByNameThrow("tableStakes", tableStakes);
	_jparser.parseByNameThrow("variableAntes", variableAntes);
	_jparser.parseByNameThrow("specialName", specialName);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("visibilityMaskEx", visibilityMaskEx);
}

/* static */ void MLobby::cli::TableTypeStaticDataStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 id; _jparser.validateByNameThrow("id", id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE maxPlayers; _jparser.validateByNameThrow("maxPlayers", maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	UINT32 visibilityMask; _jparser.validateByNameThrow("visibilityMask", visibilityMask);
	AtfValidator::validateInt(_descr, "visibilityMask", visibilityMask, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	UINT32 loBet; _jparser.validateByNameThrow("loBet", loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	UINT32 hiBet; _jparser.validateByNameThrow("hiBet", hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	UINT32 ante; _jparser.validateByNameThrow("ante", ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	UINT32 cap; _jparser.validateByNameThrow("cap", cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	UINT32 minChipsLimit; _jparser.validateByNameThrow("minChipsLimit", minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	UINT32 maxBuyIn; _jparser.validateByNameThrow("maxBuyIn", maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	bool countryRestrictionInverted; _jparser.validateByNameThrow("countryRestrictionInverted", countryRestrictionInverted);
	AtfValidator::validateInt(_descr, "countryRestrictionInverted", countryRestrictionInverted, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PString > restrictedCountries; _jparser.validateByNameThrow("restrictedCountries", restrictedCountries);
	AtfValidator::validateInt(_descr, "restrictedCountries", restrictedCountries.size(), _checker, __FILE__, __LINE__);
	bool visible; _jparser.validateByNameThrow("visible", visible);
	AtfValidator::validateInt(_descr, "visible", visible, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT32 defaultBuyIn; _jparser.validateByNameThrow("defaultBuyIn", defaultBuyIn);
	AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	UINT32 brandMask; _jparser.validateByNameThrow("brandMask", brandMask);
	AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
	UINT32 seatFinderId; _jparser.validateByNameThrow("seatFinderId", seatFinderId);
	AtfValidator::validateInt(_descr, "seatFinderId", seatFinderId, _checker, __FILE__, __LINE__);
	INT32 poolBlockMinHands; _jparser.validateByNameThrow("poolBlockMinHands", poolBlockMinHands);
	AtfValidator::validateInt(_descr, "poolBlockMinHands", poolBlockMinHands, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< INT32 > poolBlockTimePenalty; _jparser.validateByNameThrow("poolBlockTimePenalty", poolBlockTimePenalty);
	AtfValidator::validateInt(_descr, "poolBlockTimePenalty", poolBlockTimePenalty.size(), _checker, __FILE__, __LINE__);
	bool isPasswordProtected; _jparser.validateByNameThrow("isPasswordProtected", isPasswordProtected);
	AtfValidator::validateInt(_descr, "isPasswordProtected", isPasswordProtected, _checker, __FILE__, __LINE__);
	bool isMorphLobby; _jparser.validateByNameThrow("isMorphLobby", isMorphLobby);
	AtfValidator::validateInt(_descr, "isMorphLobby", isMorphLobby, _checker, __FILE__, __LINE__);
	TableCommon::TableStakes tableStakes; _jparser.validateByNameThrow("tableStakes", tableStakes);
	Atf::AtfVectorBase< INT64 > variableAntes; _jparser.validateByNameThrow("variableAntes", variableAntes);
	AtfValidator::validateInt(_descr, "variableAntes", variableAntes.size(), _checker, __FILE__, __LINE__);
	PString specialName; _jparser.validateByNameThrow("specialName", specialName);
	AtfValidator::validateInt(_descr, "specialName", specialName.length(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PSiteMask visibilityMaskEx; _jparser.validateByNameThrow("visibilityMaskEx", visibilityMaskEx);
}

/*static*/ void MLobby::cli::TableTypeStaticDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 id; _parser0.parseUINT32(id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser0.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser0.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE maxPlayers; _parser0.parseBYTE(maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	UINT32 visibilityMask; _parser0.parseUINT32(visibilityMask);
	AtfValidator::validateInt(_descr, "visibilityMask", visibilityMask, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	UINT32 loBet; _parser0.parseUINT32(loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	UINT32 hiBet; _parser0.parseUINT32(hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	UINT32 ante; _parser0.parseUINT32(ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	UINT32 cap; _parser0.parseUINT32(cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 minChipsLimit; _parser0.parseUINT32(minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	UINT32 maxBuyIn; _parser0.parseUINT32(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	bool countryRestrictionInverted; _parser0.parseBOOL(countryRestrictionInverted);
	AtfValidator::validateInt(_descr, "countryRestrictionInverted", countryRestrictionInverted, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szRestrictedCountries = Atf::LAtfVector< PString, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("restrictedCountries"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "restrictedCountries", szRestrictedCountries, _checker, __FILE__, __LINE__);
	bool visible; _parser0.parseBOOL(visible);
	AtfValidator::validateInt(_descr, "visible", visible, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser0.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT32 defaultBuyIn; _parser0.parseUINT32(defaultBuyIn);
	AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	UINT32 brandMask; _parser0.parseUINT32(brandMask);
	AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
	UINT32 seatFinderId; _parser0.parseUINT32(seatFinderId);
	AtfValidator::validateInt(_descr, "seatFinderId", seatFinderId, _checker, __FILE__, __LINE__);
	INT32 poolBlockMinHands; _parser0.parseINT32(poolBlockMinHands);
	AtfValidator::validateInt(_descr, "poolBlockMinHands", poolBlockMinHands, _checker, __FILE__, __LINE__);
	int szPoolBlockTimePenalty = Atf::LAtfVector< INT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("poolBlockTimePenalty"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "poolBlockTimePenalty", szPoolBlockTimePenalty, _checker, __FILE__, __LINE__);
	bool isPasswordProtected; _parser0.parseBOOL(isPasswordProtected);
	AtfValidator::validateInt(_descr, "isPasswordProtected", isPasswordProtected, _checker, __FILE__, __LINE__);
	bool isMorphLobby; _parser0.parseBOOL(isMorphLobby);
	AtfValidator::validateInt(_descr, "isMorphLobby", isMorphLobby, _checker, __FILE__, __LINE__);
	TableCommon::TableStakes::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tableStakes"), _fieldsWithUnparsedContent);
	int szVariableAntes = Atf::LAtfVector< INT64, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("variableAntes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "variableAntes", szVariableAntes, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "specialName"); size_t szSpecialName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "specialName", szSpecialName, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("visibilityMaskEx"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TableTypeDynaDataStruct
//=================================================================

MLobby::cli::TableTypeDynaDataStruct::TableTypeDynaDataStruct()
{
	clear();
}

void MLobby::cli::TableTypeDynaDataStruct::clear()
{
	numPlayers = 0;
	numTables = 0;
}

bool MLobby::cli::TableTypeDynaDataStruct::equals(const TableTypeDynaDataStruct& _o) const
{
	return numPlayers == _o.numPlayers &&
		numTables == _o.numTables;
}

const char *MLobby::cli::TableTypeDynaDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("numPlayers=");
	_buf.appendUint(numPlayers);
	_buf.append(',');
	_buf.append("numTables=");
	_buf.appendUint(numTables);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobby::cli::TableTypeDynaDataStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("numPlayers", numPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("numTables", numTables, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobby::cli::TableTypeDynaDataStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("numPlayers"))
		{
			numPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numTables"))
		{
			numTables = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobby::cli::TableTypeDynaDataStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(TableTypeDynaDataStruct())) // not empty
	{
		_body.composeUINT32(numPlayers);
		_body.composeUINT32(numTables);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::TableTypeDynaDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(numPlayers);
	_parser0.parseUINT32(numTables);
}

const char *MLobby::cli::TableTypeDynaDataStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("numPlayers", numPlayers);
	_jsonstr.compose("numTables", numTables);
	return _buf.c_str();
}

void MLobby::cli::TableTypeDynaDataStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("numPlayers", numPlayers);
	_jparser.parseByNameThrow("numTables", numTables);
}

/* static */ void MLobby::cli::TableTypeDynaDataStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 numPlayers; _jparser.validateByNameThrow("numPlayers", numPlayers);
	AtfValidator::validateInt(_descr, "numPlayers", numPlayers, _checker, __FILE__, __LINE__);
	UINT32 numTables; _jparser.validateByNameThrow("numTables", numTables);
	AtfValidator::validateInt(_descr, "numTables", numTables, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobby::cli::TableTypeDynaDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 numPlayers; _parser0.parseUINT32(numPlayers);
	AtfValidator::validateInt(_descr, "numPlayers", numPlayers, _checker, __FILE__, __LINE__);
	UINT32 numTables; _parser0.parseUINT32(numTables);
	AtfValidator::validateInt(_descr, "numTables", numTables, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TableTypeDataStruct
//=================================================================

MLobby::cli::TableTypeDataStruct::TableTypeDataStruct()
{
	clear();
}

void MLobby::cli::TableTypeDataStruct::clear()
{
	staticData.clear();
	dynamicData.clear();
}

bool MLobby::cli::TableTypeDataStruct::equals(const TableTypeDataStruct& _o) const
{
	return staticData.equals(_o.staticData) &&
		dynamicData.equals(_o.dynamicData);
}

const char *MLobby::cli::TableTypeDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("staticData=");
	staticData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("dynamicData=");
	dynamicData.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobby::cli::TableTypeDataStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	staticData.toXmlString("staticData", _buf);
	dynamicData.toXmlString("dynamicData", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobby::cli::TableTypeDataStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("staticData"))
		{
			if(!Atf::AtfTempl< TableTypeStaticDataStruct >::FromXmlString(_value, staticData)) return false;
		}
		else if (_element.equals("dynamicData"))
		{
			if(!Atf::AtfTempl< TableTypeDynaDataStruct >::FromXmlString(_value, dynamicData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobby::cli::TableTypeDataStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(TableTypeDataStruct())) // not empty
	{
		staticData.composeMsg(_body, _ignoreJSON);
		dynamicData.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::TableTypeDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	staticData.parseMsg(_parser0);
	dynamicData.parseMsg(_parser0);
}

const char *MLobby::cli::TableTypeDataStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("staticData", staticData);
	_jsonstr.compose("dynamicData", dynamicData);
	return _buf.c_str();
}

void MLobby::cli::TableTypeDataStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("staticData", staticData);
	_jparser.parseByNameThrow("dynamicData", dynamicData);
}

/* static */ void MLobby::cli::TableTypeDataStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TableTypeStaticDataStruct staticData; _jparser.validateByNameThrow("staticData", staticData);
	TableTypeDynaDataStruct dynamicData; _jparser.validateByNameThrow("dynamicData", dynamicData);
}

/*static*/ void MLobby::cli::TableTypeDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	TableTypeStaticDataStruct::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("staticData"), _fieldsWithUnparsedContent);
	TableTypeDynaDataStruct::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("dynamicData"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ZoomStaticDataStruct
//=================================================================

MLobby::cli::ZoomStaticDataStruct::ZoomStaticDataStruct()
{
	clear();
}

void MLobby::cli::ZoomStaticDataStruct::clear()
{
	id = 0;
	game = 0;
	structure = 0;
	isHiLo = 0;
	maxPlayersPerTable = 0;
	loBet = 0;
	hiBet = 0;
	ante = 0;
	cap = 0;
	currency.clear();
	minChipsLimit = 0;
	maxBuyIn = 0;
	visibilityMask = 0;
	defaultBuyIn = 0;
	specialName.clear();
	countryRestrictionInverted = false;
	restrictedCountries.clear();
	isPlayMoney = 0;
	isMorphLobby = false;
	scalePM = 0;
	server.clear();
	name.clear();
	replayerInstance.clear();
	isOneOnOne = 0;
	tableFlags = 0;
	chatLang = 0;
	quickLobbyVisible = false;
	blitzFlags = 0;
	brandMask = 0;
	serverObj.clear();
	tableStakes.clear();
	visibilityMaskEx.clear();
	tableFlags2 = 0;
}

bool MLobby::cli::ZoomStaticDataStruct::equals(const ZoomStaticDataStruct& _o) const
{
	return id == _o.id &&
		game == _o.game &&
		structure == _o.structure &&
		isHiLo == _o.isHiLo &&
		maxPlayersPerTable == _o.maxPlayersPerTable &&
		loBet == _o.loBet &&
		hiBet == _o.hiBet &&
		ante == _o.ante &&
		cap == _o.cap &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		minChipsLimit == _o.minChipsLimit &&
		maxBuyIn == _o.maxBuyIn &&
		visibilityMask == _o.visibilityMask &&
		defaultBuyIn == _o.defaultBuyIn &&
		Atf::atfPStringEquals(specialName, _o.specialName) &&
		countryRestrictionInverted == _o.countryRestrictionInverted &&
		restrictedCountries.equals(_o.restrictedCountries) &&
		isPlayMoney == _o.isPlayMoney &&
		isMorphLobby == _o.isMorphLobby &&
		scalePM == _o.scalePM &&
		Atf::atfPStringEquals(server, _o.server) &&
		Atf::atfPStringEquals(name, _o.name) &&
		Atf::atfPStringEquals(replayerInstance, _o.replayerInstance) &&
		isOneOnOne == _o.isOneOnOne &&
		tableFlags == _o.tableFlags &&
		chatLang == _o.chatLang &&
		quickLobbyVisible == _o.quickLobbyVisible &&
		blitzFlags == _o.blitzFlags &&
		brandMask == _o.brandMask &&
		Atf::atfPStringEquals(serverObj, _o.serverObj) &&
		tableStakes.equals(_o.tableStakes) &&
		visibilityMaskEx.equals(_o.visibilityMaskEx) &&
		tableFlags2 == _o.tableFlags2;
}

const char *MLobby::cli::ZoomStaticDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("id=");
	_buf.appendUint(id);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("maxPlayersPerTable=");
	_buf.appendUint(maxPlayersPerTable);
	_buf.append(',');
	_buf.append("loBet=");
	_buf.appendInt(loBet);
	_buf.append(',');
	_buf.append("hiBet=");
	_buf.appendInt(hiBet);
	_buf.append(',');
	_buf.append("ante=");
	_buf.appendInt(ante);
	_buf.append(',');
	_buf.append("cap=");
	_buf.appendInt(cap);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("minChipsLimit=");
	_buf.appendInt(minChipsLimit);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendInt(maxBuyIn);
	_buf.append(',');
	_buf.append("visibilityMask=");
	_buf.appendUint(visibilityMask);
	_buf.append(',');
	_buf.append("defaultBuyIn=");
	_buf.appendInt(defaultBuyIn);
	_buf.append(',');
	_buf.append("specialName=");
	_buf.append(specialName);
	_buf.append(',');
	_buf.append("countryRestrictionInverted=");
	_buf.appendUint(countryRestrictionInverted);
	_buf.append(',');
	_buf.append("restrictedCountries=");
	restrictedCountries.toTraceString(_buf);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("isMorphLobby=");
	_buf.appendUint(isMorphLobby);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("replayerInstance=");
	_buf.append(replayerInstance);
	_buf.append(',');
	_buf.append("isOneOnOne=");
	_buf.appendUint(isOneOnOne);
	_buf.append(',');
	_buf.append("tableFlags=");
	_buf.appendUint(tableFlags);
	_buf.append(',');
	_buf.append("chatLang=");
	_buf.appendUint(chatLang);
	_buf.append(',');
	_buf.append("quickLobbyVisible=");
	_buf.appendUint(quickLobbyVisible);
	_buf.append(',');
	_buf.append("blitzFlags=");
	_buf.appendUint(blitzFlags);
	_buf.append(',');
	_buf.append("brandMask=");
	_buf.appendUint(brandMask);
	_buf.append(',');
	_buf.append("serverObj=");
	_buf.append(serverObj);
	_buf.append(',');
	_buf.append("tableStakes=");
	tableStakes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("visibilityMaskEx=");
	visibilityMaskEx.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableFlags2=");
	_buf.appendUint64(tableFlags2);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobby::cli::ZoomStaticDataStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("id", id, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPlayersPerTable", maxPlayersPerTable, _buf);
	Atf::XmlElement::encodeAsXmlElement("loBet", loBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("hiBet", hiBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("ante", ante, _buf);
	Atf::XmlElement::encodeAsXmlElement("cap", cap, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("minChipsLimit", minChipsLimit, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxBuyIn", maxBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("visibilityMask", visibilityMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("defaultBuyIn", defaultBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("specialName", specialName, _buf);
	Atf::XmlElement::encodeAsXmlElement("countryRestrictionInverted", countryRestrictionInverted, _buf);
	restrictedCountries.toXmlString("restrictedCountries", _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("isMorphLobby", isMorphLobby, _buf);
	Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
	Atf::XmlElement::encodeAsXmlElement("server", server, _buf);
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	Atf::XmlElement::encodeAsXmlElement("replayerInstance", replayerInstance, _buf);
	Atf::XmlElement::encodeAsXmlElement("isOneOnOne", isOneOnOne, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableFlags", tableFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("chatLang", chatLang, _buf);
	Atf::XmlElement::encodeAsXmlElement("quickLobbyVisible", quickLobbyVisible, _buf);
	Atf::XmlElement::encodeAsXmlElement("blitzFlags", blitzFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("brandMask", brandMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("serverObj", serverObj, _buf);
	tableStakes.toXmlString("tableStakes", _buf);
	visibilityMaskEx.toXmlString("visibilityMaskEx", _buf);
	Atf::XmlElement::encodeAsXmlElement("tableFlags2", tableFlags2, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobby::cli::ZoomStaticDataStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("id"))
		{
			id = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("game"))
		{
			game = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("structure"))
		{
			structure = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxPlayersPerTable"))
		{
			maxPlayersPerTable = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("loBet"))
		{
			loBet = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("hiBet"))
		{
			hiBet = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("ante"))
		{
			ante = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("cap"))
		{
			cap = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("minChipsLimit"))
		{
			minChipsLimit = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxBuyIn"))
		{
			maxBuyIn = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("visibilityMask"))
		{
			visibilityMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("defaultBuyIn"))
		{
			defaultBuyIn = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("specialName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, specialName)) return false;
		}
		else if (_element.equals("countryRestrictionInverted"))
		{
			countryRestrictionInverted = (*_value.ptr() == '1');
		}
		else if (_element.equals("restrictedCountries"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PString, 4 > >::FromXmlString(_value, restrictedCountries)) return false;
		}
		else if (_element.equals("isPlayMoney"))
		{
			isPlayMoney = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isMorphLobby"))
		{
			isMorphLobby = (*_value.ptr() == '1');
		}
		else if (_element.equals("scalePM"))
		{
			scalePM = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("server"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, server)) return false;
		}
		else if (_element.equals("name"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
		}
		else if (_element.equals("replayerInstance"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, replayerInstance)) return false;
		}
		else if (_element.equals("isOneOnOne"))
		{
			isOneOnOne = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableFlags"))
		{
			tableFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("chatLang"))
		{
			chatLang = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("quickLobbyVisible"))
		{
			quickLobbyVisible = (*_value.ptr() == '1');
		}
		else if (_element.equals("blitzFlags"))
		{
			blitzFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("brandMask"))
		{
			brandMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("serverObj"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, serverObj)) return false;
		}
		else if (_element.equals("tableStakes"))
		{
			if(!Atf::AtfTempl< TableCommon::TableStakes >::FromXmlString(_value, tableStakes)) return false;
		}
		else if (_element.equals("visibilityMaskEx"))
		{
			if(!Atf::AtfTempl< PSiteMask >::FromXmlString(_value, visibilityMaskEx)) return false;
		}
		else if (_element.equals("tableFlags2"))
		{
			tableFlags2 = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobby::cli::ZoomStaticDataStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ZoomStaticDataStruct())) // not empty
	{
		_body.composeUINT32(id);
		_body.composeBYTE(game);
		_body.composeBYTE(structure);
		_body.composeBYTE(isHiLo);
		_body.composeBYTE(maxPlayersPerTable);
		_body.composeINT32(loBet);
		_body.composeINT32(hiBet);
		_body.composeINT32(ante);
		_body.composeINT32(cap);
		_body.composeString(currency);
		_body.composeINT32(minChipsLimit);
		_body.composeINT32(maxBuyIn);
		_body.composeUINT32(visibilityMask);
		_body.composeINT32(defaultBuyIn);
		_body.composeString(specialName);
		_body.composeBOOL(countryRestrictionInverted);
		restrictedCountries.composeMsg(_body, _ignoreJSON);
		_body.composeBYTE(isPlayMoney);
		_body.composeBOOL(isMorphLobby);
		_body.composeUINT32(scalePM);
		_body.composeString(server);
		_body.composeString(name);
		_body.composeString(replayerInstance);
		_body.composeBYTE(isOneOnOne);
		_body.composeUINT32(tableFlags);
		_body.composeUINT16(chatLang);
		_body.composeBOOL(quickLobbyVisible);
		_body.composeUINT32(blitzFlags);
		_body.composeUINT32(brandMask);
		_body.composeString(serverObj);
		tableStakes.composeMsg(_body, _ignoreJSON);
		visibilityMaskEx.composeMsg(_body, _ignoreJSON);
		_body.composeUINT64(tableFlags2);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::ZoomStaticDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(id);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(structure);
	_parser0.parseBYTE(isHiLo);
	_parser0.parseBYTE(maxPlayersPerTable);
	_parser0.parseINT32(loBet);
	_parser0.parseINT32(hiBet);
	_parser0.parseINT32(ante);
	_parser0.parseINT32(cap);
	_parser0.parseStringP(currency);
	_parser0.parseINT32(minChipsLimit);
	_parser0.parseINT32(maxBuyIn);
	_parser0.parseUINT32(visibilityMask);
	_parser0.parseINT32(defaultBuyIn);
	_parser0.parseStringP(specialName);
	_parser0.parseBOOL(countryRestrictionInverted);
	restrictedCountries.parseMsg(_parser0);
	_parser0.parseBYTE(isPlayMoney);
	_parser0.parseBOOL(isMorphLobby);
	_parser0.parseUINT32(scalePM);
	_parser0.parseStringP(server);
	_parser0.parseStringP(name);
	_parser0.parseStringP(replayerInstance);
	_parser0.parseBYTE(isOneOnOne);
	_parser0.parseUINT32(tableFlags);
	_parser0.parseUINT16(chatLang);
	_parser0.parseBOOL(quickLobbyVisible);
	_parser0.parseUINT32(blitzFlags);
	_parser0.parseUINT32(brandMask);
	_parser0.parseStringP(serverObj);
	if(_parser0.parseEnded()) return;
	tableStakes.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	visibilityMaskEx.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT64(tableFlags2);
}

const char *MLobby::cli::ZoomStaticDataStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("id", id);
	_jsonstr.compose("game", game);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("maxPlayersPerTable", maxPlayersPerTable);
	_jsonstr.compose("loBet", loBet);
	_jsonstr.compose("hiBet", hiBet);
	_jsonstr.compose("ante", ante);
	_jsonstr.compose("cap", cap);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("minChipsLimit", minChipsLimit);
	_jsonstr.compose("maxBuyIn", maxBuyIn);
	_jsonstr.compose("visibilityMask", visibilityMask);
	_jsonstr.compose("defaultBuyIn", defaultBuyIn);
	_jsonstr.compose("specialName", specialName);
	_jsonstr.compose("countryRestrictionInverted", countryRestrictionInverted);
	_jsonstr.compose("restrictedCountries", restrictedCountries);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("isMorphLobby", isMorphLobby);
	_jsonstr.compose("scalePM", scalePM);
	_jsonstr.compose("server", server);
	_jsonstr.compose("name", name);
	_jsonstr.compose("replayerInstance", replayerInstance);
	_jsonstr.compose("isOneOnOne", isOneOnOne);
	_jsonstr.compose("tableFlags", tableFlags);
	_jsonstr.compose("chatLang", chatLang);
	_jsonstr.compose("quickLobbyVisible", quickLobbyVisible);
	_jsonstr.compose("blitzFlags", blitzFlags);
	_jsonstr.compose("brandMask", brandMask);
	_jsonstr.compose("serverObj", serverObj);
	_jsonstr.compose("tableStakes", tableStakes);
	_jsonstr.compose("visibilityMaskEx", visibilityMaskEx);
	_jsonstr.compose("tableFlags2", tableFlags2);
	return _buf.c_str();
}

void MLobby::cli::ZoomStaticDataStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("id", id);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("maxPlayersPerTable", maxPlayersPerTable);
	_jparser.parseByNameThrow("loBet", loBet);
	_jparser.parseByNameThrow("hiBet", hiBet);
	_jparser.parseByNameThrow("ante", ante);
	_jparser.parseByNameThrow("cap", cap);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("minChipsLimit", minChipsLimit);
	_jparser.parseByNameThrow("maxBuyIn", maxBuyIn);
	_jparser.parseByNameThrow("visibilityMask", visibilityMask);
	_jparser.parseByNameThrow("defaultBuyIn", defaultBuyIn);
	_jparser.parseByNameThrow("specialName", specialName);
	_jparser.parseByNameThrow("countryRestrictionInverted", countryRestrictionInverted);
	_jparser.parseByNameThrow("restrictedCountries", restrictedCountries);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("isMorphLobby", isMorphLobby);
	_jparser.parseByNameThrow("scalePM", scalePM);
	_jparser.parseByNameThrow("server", server);
	_jparser.parseByNameThrow("name", name);
	_jparser.parseByNameThrow("replayerInstance", replayerInstance);
	_jparser.parseByNameThrow("isOneOnOne", isOneOnOne);
	_jparser.parseByNameThrow("tableFlags", tableFlags);
	_jparser.parseByNameThrow("chatLang", chatLang);
	_jparser.parseByNameThrow("quickLobbyVisible", quickLobbyVisible);
	_jparser.parseByNameThrow("blitzFlags", blitzFlags);
	_jparser.parseByNameThrow("brandMask", brandMask);
	_jparser.parseByNameThrow("serverObj", serverObj);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tableStakes", tableStakes);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("visibilityMaskEx", visibilityMaskEx);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tableFlags2", tableFlags2);
}

/* static */ void MLobby::cli::ZoomStaticDataStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 id; _jparser.validateByNameThrow("id", id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE maxPlayersPerTable; _jparser.validateByNameThrow("maxPlayersPerTable", maxPlayersPerTable);
	AtfValidator::validateInt(_descr, "maxPlayersPerTable", maxPlayersPerTable, _checker, __FILE__, __LINE__);
	INT32 loBet; _jparser.validateByNameThrow("loBet", loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	INT32 hiBet; _jparser.validateByNameThrow("hiBet", hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	INT32 ante; _jparser.validateByNameThrow("ante", ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	INT32 cap; _jparser.validateByNameThrow("cap", cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	INT32 minChipsLimit; _jparser.validateByNameThrow("minChipsLimit", minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	INT32 maxBuyIn; _jparser.validateByNameThrow("maxBuyIn", maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	UINT32 visibilityMask; _jparser.validateByNameThrow("visibilityMask", visibilityMask);
	AtfValidator::validateInt(_descr, "visibilityMask", visibilityMask, _checker, __FILE__, __LINE__);
	INT32 defaultBuyIn; _jparser.validateByNameThrow("defaultBuyIn", defaultBuyIn);
	AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	PString specialName; _jparser.validateByNameThrow("specialName", specialName);
	AtfValidator::validateInt(_descr, "specialName", specialName.length(), _checker, __FILE__, __LINE__);
	bool countryRestrictionInverted; _jparser.validateByNameThrow("countryRestrictionInverted", countryRestrictionInverted);
	AtfValidator::validateInt(_descr, "countryRestrictionInverted", countryRestrictionInverted, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PString > restrictedCountries; _jparser.validateByNameThrow("restrictedCountries", restrictedCountries);
	AtfValidator::validateInt(_descr, "restrictedCountries", restrictedCountries.size(), _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	bool isMorphLobby; _jparser.validateByNameThrow("isMorphLobby", isMorphLobby);
	AtfValidator::validateInt(_descr, "isMorphLobby", isMorphLobby, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	PString server; _jparser.validateByNameThrow("server", server);
	AtfValidator::validateInt(_descr, "server", server.length(), _checker, __FILE__, __LINE__);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateInt(_descr, "name", name.length(), _checker, __FILE__, __LINE__);
	PString replayerInstance; _jparser.validateByNameThrow("replayerInstance", replayerInstance);
	AtfValidator::validateInt(_descr, "replayerInstance", replayerInstance.length(), _checker, __FILE__, __LINE__);
	BYTE isOneOnOne; _jparser.validateByNameThrow("isOneOnOne", isOneOnOne);
	AtfValidator::validateInt(_descr, "isOneOnOne", isOneOnOne, _checker, __FILE__, __LINE__);
	UINT32 tableFlags; _jparser.validateByNameThrow("tableFlags", tableFlags);
	AtfValidator::validateInt(_descr, "tableFlags", tableFlags, _checker, __FILE__, __LINE__);
	UINT16 chatLang; _jparser.validateByNameThrow("chatLang", chatLang);
	AtfValidator::validateInt(_descr, "chatLang", chatLang, _checker, __FILE__, __LINE__);
	bool quickLobbyVisible; _jparser.validateByNameThrow("quickLobbyVisible", quickLobbyVisible);
	AtfValidator::validateInt(_descr, "quickLobbyVisible", quickLobbyVisible, _checker, __FILE__, __LINE__);
	UINT32 blitzFlags; _jparser.validateByNameThrow("blitzFlags", blitzFlags);
	AtfValidator::validateInt(_descr, "blitzFlags", blitzFlags, _checker, __FILE__, __LINE__);
	UINT32 brandMask; _jparser.validateByNameThrow("brandMask", brandMask);
	AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
	PString serverObj; _jparser.validateByNameThrow("serverObj", serverObj);
	AtfValidator::validateInt(_descr, "serverObj", serverObj.length(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	TableCommon::TableStakes tableStakes; _jparser.validateByNameThrow("tableStakes", tableStakes);
	if(_jparser.parseEnded()) return;
	PSiteMask visibilityMaskEx; _jparser.validateByNameThrow("visibilityMaskEx", visibilityMaskEx);
	if(_jparser.parseEnded()) return;
	UINT64 tableFlags2; _jparser.validateByNameThrow("tableFlags2", tableFlags2);
	AtfValidator::validateUint(_descr, "tableFlags2", tableFlags2, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobby::cli::ZoomStaticDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 id; _parser0.parseUINT32(id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser0.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE maxPlayersPerTable; _parser0.parseBYTE(maxPlayersPerTable);
	AtfValidator::validateInt(_descr, "maxPlayersPerTable", maxPlayersPerTable, _checker, __FILE__, __LINE__);
	INT32 loBet; _parser0.parseINT32(loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	INT32 hiBet; _parser0.parseINT32(hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	INT32 ante; _parser0.parseINT32(ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	INT32 cap; _parser0.parseINT32(cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT32 minChipsLimit; _parser0.parseINT32(minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	INT32 maxBuyIn; _parser0.parseINT32(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	UINT32 visibilityMask; _parser0.parseUINT32(visibilityMask);
	AtfValidator::validateInt(_descr, "visibilityMask", visibilityMask, _checker, __FILE__, __LINE__);
	INT32 defaultBuyIn; _parser0.parseINT32(defaultBuyIn);
	AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "specialName"); size_t szSpecialName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "specialName", szSpecialName, _checker, __FILE__, __LINE__);
	bool countryRestrictionInverted; _parser0.parseBOOL(countryRestrictionInverted);
	AtfValidator::validateInt(_descr, "countryRestrictionInverted", countryRestrictionInverted, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szRestrictedCountries = Atf::LAtfVector< PString, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("restrictedCountries"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "restrictedCountries", szRestrictedCountries, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser0.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	bool isMorphLobby; _parser0.parseBOOL(isMorphLobby);
	AtfValidator::validateInt(_descr, "isMorphLobby", isMorphLobby, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser0.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "replayerInstance"); size_t szReplayerInstance = strlen(_dummy);
	AtfValidator::validateInt(_descr, "replayerInstance", szReplayerInstance, _checker, __FILE__, __LINE__);
	BYTE isOneOnOne; _parser0.parseBYTE(isOneOnOne);
	AtfValidator::validateInt(_descr, "isOneOnOne", isOneOnOne, _checker, __FILE__, __LINE__);
	UINT32 tableFlags; _parser0.parseUINT32(tableFlags);
	AtfValidator::validateInt(_descr, "tableFlags", tableFlags, _checker, __FILE__, __LINE__);
	UINT16 chatLang; _parser0.parseUINT16(chatLang);
	AtfValidator::validateInt(_descr, "chatLang", chatLang, _checker, __FILE__, __LINE__);
	bool quickLobbyVisible; _parser0.parseBOOL(quickLobbyVisible);
	AtfValidator::validateInt(_descr, "quickLobbyVisible", quickLobbyVisible, _checker, __FILE__, __LINE__);
	UINT32 blitzFlags; _parser0.parseUINT32(blitzFlags);
	AtfValidator::validateInt(_descr, "blitzFlags", blitzFlags, _checker, __FILE__, __LINE__);
	UINT32 brandMask; _parser0.parseUINT32(brandMask);
	AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "serverObj"); size_t szServerObj = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObj", szServerObj, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	TableCommon::TableStakes::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tableStakes"), _fieldsWithUnparsedContent);
	if(_parser0.parseEnded()) return;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("visibilityMaskEx"), _fieldsWithUnparsedContent);
	if(_parser0.parseEnded()) return;
	UINT64 tableFlags2; _parser0.parseUINT64(tableFlags2);
	AtfValidator::validateUint(_descr, "tableFlags2", tableFlags2, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    EarlyBirdMultiplier
//=================================================================

MLobby::cli::EarlyBirdMultiplier::EarlyBirdMultiplier()
{
	clear();
}

void MLobby::cli::EarlyBirdMultiplier::clear()
{
	licenseId = 0;
	multiplier = 0;
}

bool MLobby::cli::EarlyBirdMultiplier::equals(const EarlyBirdMultiplier& _o) const
{
	return licenseId == _o.licenseId &&
		multiplier == _o.multiplier;
}

const char *MLobby::cli::EarlyBirdMultiplier::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("licenseId=");
	_buf.appendUint(licenseId);
	_buf.append(',');
	_buf.append("multiplier=");
	_buf.appendUint(multiplier);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobby::cli::EarlyBirdMultiplier::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("licenseId", licenseId, _buf);
	Atf::XmlElement::encodeAsXmlElement("multiplier", multiplier, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobby::cli::EarlyBirdMultiplier::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("licenseId"))
		{
			licenseId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("multiplier"))
		{
			multiplier = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobby::cli::EarlyBirdMultiplier::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(EarlyBirdMultiplier())) // not empty
	{
		_body.composeUINT32(licenseId);
		_body.composeUINT32(multiplier);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::EarlyBirdMultiplier::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(licenseId);
	_parser0.parseUINT32(multiplier);
}

const char *MLobby::cli::EarlyBirdMultiplier::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("licenseId", licenseId);
	_jsonstr.compose("multiplier", multiplier);
	return _buf.c_str();
}

void MLobby::cli::EarlyBirdMultiplier::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("licenseId", licenseId);
	_jparser.parseByNameThrow("multiplier", multiplier);
}

/* static */ void MLobby::cli::EarlyBirdMultiplier::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 licenseId; _jparser.validateByNameThrow("licenseId", licenseId);
	AtfValidator::validateInt(_descr, "licenseId", licenseId, _checker, __FILE__, __LINE__);
	UINT32 multiplier; _jparser.validateByNameThrow("multiplier", multiplier);
	AtfValidator::validateInt(_descr, "multiplier", multiplier, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobby::cli::EarlyBirdMultiplier::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 licenseId; _parser0.parseUINT32(licenseId);
	AtfValidator::validateInt(_descr, "licenseId", licenseId, _checker, __FILE__, __LINE__);
	UINT32 multiplier; _parser0.parseUINT32(multiplier);
	AtfValidator::validateInt(_descr, "multiplier", multiplier, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ZoomDynaDataStruct
//=================================================================

MLobby::cli::ZoomDynaDataStruct::ZoomDynaDataStruct()
{
	clear();
}

void MLobby::cli::ZoomDynaDataStruct::clear()
{
	handsPerHour = 0;
	avgPotSize = 0;
	avgStackSize = 0;
	numPlayers = 0;
	publProp = 0;
	avgPlayers = 0;
	avgVpip = 0;
	fppFactors.clear();
	earlyBirdMins = 0;
	earlyBirdMultipliers.clear();
}

bool MLobby::cli::ZoomDynaDataStruct::equals(const ZoomDynaDataStruct& _o) const
{
	return handsPerHour == _o.handsPerHour &&
		avgPotSize == _o.avgPotSize &&
		avgStackSize == _o.avgStackSize &&
		numPlayers == _o.numPlayers &&
		publProp == _o.publProp &&
		avgPlayers == _o.avgPlayers &&
		avgVpip == _o.avgVpip &&
		fppFactors.equals(_o.fppFactors) &&
		earlyBirdMins == _o.earlyBirdMins &&
		earlyBirdMultipliers.equals(_o.earlyBirdMultipliers);
}

const char *MLobby::cli::ZoomDynaDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("handsPerHour=");
	_buf.appendInt(handsPerHour);
	_buf.append(',');
	_buf.append("avgPotSize=");
	_buf.appendInt(avgPotSize);
	_buf.append(',');
	_buf.append("avgStackSize=");
	_buf.appendInt(avgStackSize);
	_buf.append(',');
	_buf.append("numPlayers=");
	_buf.appendInt(numPlayers);
	_buf.append(',');
	_buf.append("publProp=");
	_buf.appendUint(publProp);
	_buf.append(',');
	_buf.append("avgPlayers=");
	_buf.appendUint(avgPlayers);
	_buf.append(',');
	_buf.append("avgVpip=");
	_buf.appendUint(avgVpip);
	_buf.append(',');
	_buf.append("fppFactors=");
	fppFactors.toTraceString(_buf);
	_buf.append(',');
	_buf.append("earlyBirdMins=");
	_buf.appendInt(earlyBirdMins);
	_buf.append(',');
	_buf.append("earlyBirdMultipliers=");
	earlyBirdMultipliers.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobby::cli::ZoomDynaDataStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("handsPerHour", handsPerHour, _buf);
	Atf::XmlElement::encodeAsXmlElement("avgPotSize", avgPotSize, _buf);
	Atf::XmlElement::encodeAsXmlElement("avgStackSize", avgStackSize, _buf);
	Atf::XmlElement::encodeAsXmlElement("numPlayers", numPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("publProp", publProp, _buf);
	Atf::XmlElement::encodeAsXmlElement("avgPlayers", avgPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("avgVpip", avgVpip, _buf);
	fppFactors.toXmlString("fppFactors", _buf);
	Atf::XmlElement::encodeAsXmlElement("earlyBirdMins", earlyBirdMins, _buf);
	earlyBirdMultipliers.toXmlString("earlyBirdMultipliers", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobby::cli::ZoomDynaDataStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("handsPerHour"))
		{
			handsPerHour = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("avgPotSize"))
		{
			avgPotSize = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("avgStackSize"))
		{
			avgStackSize = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numPlayers"))
		{
			numPlayers = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("publProp"))
		{
			publProp = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("avgPlayers"))
		{
			avgPlayers = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("avgVpip"))
		{
			avgVpip = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("fppFactors"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< FppFactorStruct, 4 > >::FromXmlString(_value, fppFactors)) return false;
		}
		else if (_element.equals("earlyBirdMins"))
		{
			earlyBirdMins = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("earlyBirdMultipliers"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< EarlyBirdMultiplier, 4 > >::FromXmlString(_value, earlyBirdMultipliers)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobby::cli::ZoomDynaDataStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ZoomDynaDataStruct())) // not empty
	{
		_body.composeINT32(handsPerHour);
		_body.composeINT32(avgPotSize);
		_body.composeINT32(avgStackSize);
		_body.composeINT32(numPlayers);
		_body.composeBYTE(publProp);
		_body.composeBYTE(avgPlayers);
		_body.composeBYTE(avgVpip);
		fppFactors.composeMsg(_body, _ignoreJSON);
		_body.composeINT32(earlyBirdMins);
		earlyBirdMultipliers.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::ZoomDynaDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(handsPerHour);
	_parser0.parseINT32(avgPotSize);
	_parser0.parseINT32(avgStackSize);
	_parser0.parseINT32(numPlayers);
	_parser0.parseBYTE(publProp);
	_parser0.parseBYTE(avgPlayers);
	_parser0.parseBYTE(avgVpip);
	fppFactors.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT32(earlyBirdMins);
	if(_parser0.parseEnded()) return;
	earlyBirdMultipliers.parseMsg(_parser0);
}

const char *MLobby::cli::ZoomDynaDataStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("handsPerHour", handsPerHour);
	_jsonstr.compose("avgPotSize", avgPotSize);
	_jsonstr.compose("avgStackSize", avgStackSize);
	_jsonstr.compose("numPlayers", numPlayers);
	_jsonstr.compose("publProp", publProp);
	_jsonstr.compose("avgPlayers", avgPlayers);
	_jsonstr.compose("avgVpip", avgVpip);
	_jsonstr.compose("fppFactors", fppFactors);
	_jsonstr.compose("earlyBirdMins", earlyBirdMins);
	_jsonstr.compose("earlyBirdMultipliers", earlyBirdMultipliers);
	return _buf.c_str();
}

void MLobby::cli::ZoomDynaDataStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("handsPerHour", handsPerHour);
	_jparser.parseByNameThrow("avgPotSize", avgPotSize);
	_jparser.parseByNameThrow("avgStackSize", avgStackSize);
	_jparser.parseByNameThrow("numPlayers", numPlayers);
	_jparser.parseByNameThrow("publProp", publProp);
	_jparser.parseByNameThrow("avgPlayers", avgPlayers);
	_jparser.parseByNameThrow("avgVpip", avgVpip);
	_jparser.parseByNameThrow("fppFactors", fppFactors);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("earlyBirdMins", earlyBirdMins);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("earlyBirdMultipliers", earlyBirdMultipliers);
}

/* static */ void MLobby::cli::ZoomDynaDataStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 handsPerHour; _jparser.validateByNameThrow("handsPerHour", handsPerHour);
	AtfValidator::validateInt(_descr, "handsPerHour", handsPerHour, _checker, __FILE__, __LINE__);
	INT32 avgPotSize; _jparser.validateByNameThrow("avgPotSize", avgPotSize);
	AtfValidator::validateInt(_descr, "avgPotSize", avgPotSize, _checker, __FILE__, __LINE__);
	INT32 avgStackSize; _jparser.validateByNameThrow("avgStackSize", avgStackSize);
	AtfValidator::validateInt(_descr, "avgStackSize", avgStackSize, _checker, __FILE__, __LINE__);
	INT32 numPlayers; _jparser.validateByNameThrow("numPlayers", numPlayers);
	AtfValidator::validateInt(_descr, "numPlayers", numPlayers, _checker, __FILE__, __LINE__);
	BYTE publProp; _jparser.validateByNameThrow("publProp", publProp);
	AtfValidator::validateInt(_descr, "publProp", publProp, _checker, __FILE__, __LINE__);
	BYTE avgPlayers; _jparser.validateByNameThrow("avgPlayers", avgPlayers);
	AtfValidator::validateInt(_descr, "avgPlayers", avgPlayers, _checker, __FILE__, __LINE__);
	BYTE avgVpip; _jparser.validateByNameThrow("avgVpip", avgVpip);
	AtfValidator::validateInt(_descr, "avgVpip", avgVpip, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< FppFactorStruct > fppFactors; _jparser.validateByNameThrow("fppFactors", fppFactors);
	AtfValidator::validateInt(_descr, "fppFactors", fppFactors.size(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT32 earlyBirdMins; _jparser.validateByNameThrow("earlyBirdMins", earlyBirdMins);
	AtfValidator::validateInt(_descr, "earlyBirdMins", earlyBirdMins, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	Atf::AtfVectorBase< EarlyBirdMultiplier > earlyBirdMultipliers; _jparser.validateByNameThrow("earlyBirdMultipliers", earlyBirdMultipliers);
	AtfValidator::validateInt(_descr, "earlyBirdMultipliers", earlyBirdMultipliers.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MLobby::cli::ZoomDynaDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 handsPerHour; _parser0.parseINT32(handsPerHour);
	AtfValidator::validateInt(_descr, "handsPerHour", handsPerHour, _checker, __FILE__, __LINE__);
	INT32 avgPotSize; _parser0.parseINT32(avgPotSize);
	AtfValidator::validateInt(_descr, "avgPotSize", avgPotSize, _checker, __FILE__, __LINE__);
	INT32 avgStackSize; _parser0.parseINT32(avgStackSize);
	AtfValidator::validateInt(_descr, "avgStackSize", avgStackSize, _checker, __FILE__, __LINE__);
	INT32 numPlayers; _parser0.parseINT32(numPlayers);
	AtfValidator::validateInt(_descr, "numPlayers", numPlayers, _checker, __FILE__, __LINE__);
	BYTE publProp; _parser0.parseBYTE(publProp);
	AtfValidator::validateInt(_descr, "publProp", publProp, _checker, __FILE__, __LINE__);
	BYTE avgPlayers; _parser0.parseBYTE(avgPlayers);
	AtfValidator::validateInt(_descr, "avgPlayers", avgPlayers, _checker, __FILE__, __LINE__);
	BYTE avgVpip; _parser0.parseBYTE(avgVpip);
	AtfValidator::validateInt(_descr, "avgVpip", avgVpip, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szFppFactors = Atf::LAtfVector< FppFactorStruct, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("fppFactors"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "fppFactors", szFppFactors, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT32 earlyBirdMins; _parser0.parseINT32(earlyBirdMins);
	AtfValidator::validateInt(_descr, "earlyBirdMins", earlyBirdMins, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	int szEarlyBirdMultipliers = Atf::LAtfVector< EarlyBirdMultiplier, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("earlyBirdMultipliers"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "earlyBirdMultipliers", szEarlyBirdMultipliers, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ZoomDataStruct
//=================================================================

MLobby::cli::ZoomDataStruct::ZoomDataStruct()
{
	clear();
}

void MLobby::cli::ZoomDataStruct::clear()
{
	staticData.clear();
	dynamicData.clear();
}

bool MLobby::cli::ZoomDataStruct::equals(const ZoomDataStruct& _o) const
{
	return staticData.equals(_o.staticData) &&
		dynamicData.equals(_o.dynamicData);
}

const char *MLobby::cli::ZoomDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("staticData=");
	staticData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("dynamicData=");
	dynamicData.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobby::cli::ZoomDataStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	staticData.toXmlString("staticData", _buf);
	dynamicData.toXmlString("dynamicData", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobby::cli::ZoomDataStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("staticData"))
		{
			if(!Atf::AtfTempl< ZoomStaticDataStruct >::FromXmlString(_value, staticData)) return false;
		}
		else if (_element.equals("dynamicData"))
		{
			if(!Atf::AtfTempl< ZoomDynaDataStruct >::FromXmlString(_value, dynamicData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobby::cli::ZoomDataStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ZoomDataStruct())) // not empty
	{
		staticData.composeMsg(_body, _ignoreJSON);
		dynamicData.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::ZoomDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	staticData.parseMsg(_parser0);
	dynamicData.parseMsg(_parser0);
}

const char *MLobby::cli::ZoomDataStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("staticData", staticData);
	_jsonstr.compose("dynamicData", dynamicData);
	return _buf.c_str();
}

void MLobby::cli::ZoomDataStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("staticData", staticData);
	_jparser.parseByNameThrow("dynamicData", dynamicData);
}

/* static */ void MLobby::cli::ZoomDataStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	ZoomStaticDataStruct staticData; _jparser.validateByNameThrow("staticData", staticData);
	ZoomDynaDataStruct dynamicData; _jparser.validateByNameThrow("dynamicData", dynamicData);
}

/*static*/ void MLobby::cli::ZoomDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	ZoomStaticDataStruct::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("staticData"), _fieldsWithUnparsedContent);
	ZoomDynaDataStruct::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("dynamicData"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SeatFinderStaticDataStruct
//=================================================================

MLobby::cli::SeatFinderStaticDataStruct::SeatFinderStaticDataStruct()
{
	clear();
}

void MLobby::cli::SeatFinderStaticDataStruct::clear()
{
	id = 0;
	game = 0;
	structure = 0;
	isHiLo = 0;
	maxPlayersPerTable = 0;
	loBet = 0;
	hiBet = 0;
	ante = 0;
	cap = 0;
	currency.clear();
	minChipsLimit = 0;
	maxBuyIn = 0;
	visibilityMask = 0;
	defaultBuyIn = 0;
	specialName.clear();
	countryRestrictionInverted = false;
	restrictedCountries.clear();
	replayerAddress.clear();
	replayerInstance.clear();
	minPlayersPerTable = 0;
	isPasswordProtected = false;
	poolBlockMinHands = 0;
	poolBlockTimePenalty.clear();
	flags = 0;
	flags2 = 0;
	isPM = false;
	scalePM = 0;
	tableStakes.clear();
	variableAntes.clear();
	visibilityMaskEx.clear();
}

bool MLobby::cli::SeatFinderStaticDataStruct::equals(const SeatFinderStaticDataStruct& _o) const
{
	return id == _o.id &&
		game == _o.game &&
		structure == _o.structure &&
		isHiLo == _o.isHiLo &&
		maxPlayersPerTable == _o.maxPlayersPerTable &&
		loBet == _o.loBet &&
		hiBet == _o.hiBet &&
		ante == _o.ante &&
		cap == _o.cap &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		minChipsLimit == _o.minChipsLimit &&
		maxBuyIn == _o.maxBuyIn &&
		visibilityMask == _o.visibilityMask &&
		defaultBuyIn == _o.defaultBuyIn &&
		Atf::atfPStringEquals(specialName, _o.specialName) &&
		countryRestrictionInverted == _o.countryRestrictionInverted &&
		restrictedCountries.equals(_o.restrictedCountries) &&
		Atf::atfPStringEquals(replayerAddress, _o.replayerAddress) &&
		Atf::atfPStringEquals(replayerInstance, _o.replayerInstance) &&
		minPlayersPerTable == _o.minPlayersPerTable &&
		isPasswordProtected == _o.isPasswordProtected &&
		poolBlockMinHands == _o.poolBlockMinHands &&
		poolBlockTimePenalty.equals(_o.poolBlockTimePenalty) &&
		flags == _o.flags &&
		flags2 == _o.flags2 &&
		isPM == _o.isPM &&
		scalePM == _o.scalePM &&
		tableStakes.equals(_o.tableStakes) &&
		variableAntes.equals(_o.variableAntes) &&
		visibilityMaskEx.equals(_o.visibilityMaskEx);
}

const char *MLobby::cli::SeatFinderStaticDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("id=");
	_buf.appendUint(id);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("maxPlayersPerTable=");
	_buf.appendUint(maxPlayersPerTable);
	_buf.append(',');
	_buf.append("loBet=");
	_buf.appendInt(loBet);
	_buf.append(',');
	_buf.append("hiBet=");
	_buf.appendInt(hiBet);
	_buf.append(',');
	_buf.append("ante=");
	_buf.appendInt(ante);
	_buf.append(',');
	_buf.append("cap=");
	_buf.appendInt(cap);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("minChipsLimit=");
	_buf.appendInt(minChipsLimit);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendInt(maxBuyIn);
	_buf.append(',');
	_buf.append("visibilityMask=");
	_buf.appendUint(visibilityMask);
	_buf.append(',');
	_buf.append("defaultBuyIn=");
	_buf.appendInt(defaultBuyIn);
	_buf.append(',');
	_buf.append("specialName=");
	_buf.append(specialName);
	_buf.append(',');
	_buf.append("countryRestrictionInverted=");
	_buf.appendUint(countryRestrictionInverted);
	_buf.append(',');
	_buf.append("restrictedCountries=");
	restrictedCountries.toTraceString(_buf);
	_buf.append(',');
	_buf.append("replayerAddress=");
	_buf.append(replayerAddress);
	_buf.append(',');
	_buf.append("replayerInstance=");
	_buf.append(replayerInstance);
	_buf.append(',');
	_buf.append("minPlayersPerTable=");
	_buf.appendInt(minPlayersPerTable);
	_buf.append(',');
	_buf.append("isPasswordProtected=");
	_buf.appendUint(isPasswordProtected);
	_buf.append(',');
	_buf.append("poolBlockMinHands=");
	_buf.appendInt(poolBlockMinHands);
	_buf.append(',');
	_buf.append("poolBlockTimePenalty=");
	poolBlockTimePenalty.toTraceString(_buf);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("flags2=");
	_buf.appendUint64(flags2);
	_buf.append(',');
	_buf.append("isPM=");
	_buf.appendUint(isPM);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("tableStakes=");
	tableStakes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("variableAntes=");
	variableAntes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("visibilityMaskEx=");
	visibilityMaskEx.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobby::cli::SeatFinderStaticDataStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("id", id, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPlayersPerTable", maxPlayersPerTable, _buf);
	Atf::XmlElement::encodeAsXmlElement("loBet", loBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("hiBet", hiBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("ante", ante, _buf);
	Atf::XmlElement::encodeAsXmlElement("cap", cap, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("minChipsLimit", minChipsLimit, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxBuyIn", maxBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("visibilityMask", visibilityMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("defaultBuyIn", defaultBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("specialName", specialName, _buf);
	Atf::XmlElement::encodeAsXmlElement("countryRestrictionInverted", countryRestrictionInverted, _buf);
	restrictedCountries.toXmlString("restrictedCountries", _buf);
	Atf::XmlElement::encodeAsXmlElement("replayerAddress", replayerAddress, _buf);
	Atf::XmlElement::encodeAsXmlElement("replayerInstance", replayerInstance, _buf);
	Atf::XmlElement::encodeAsXmlElement("minPlayersPerTable", minPlayersPerTable, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPasswordProtected", isPasswordProtected, _buf);
	Atf::XmlElement::encodeAsXmlElement("poolBlockMinHands", poolBlockMinHands, _buf);
	poolBlockTimePenalty.toXmlString("poolBlockTimePenalty", _buf);
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags2", flags2, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPM", isPM, _buf);
	Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
	tableStakes.toXmlString("tableStakes", _buf);
	variableAntes.toXmlString("variableAntes", _buf);
	visibilityMaskEx.toXmlString("visibilityMaskEx", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobby::cli::SeatFinderStaticDataStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("id"))
		{
			id = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("game"))
		{
			game = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("structure"))
		{
			structure = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxPlayersPerTable"))
		{
			maxPlayersPerTable = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("loBet"))
		{
			loBet = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("hiBet"))
		{
			hiBet = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("ante"))
		{
			ante = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("cap"))
		{
			cap = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("minChipsLimit"))
		{
			minChipsLimit = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxBuyIn"))
		{
			maxBuyIn = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("visibilityMask"))
		{
			visibilityMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("defaultBuyIn"))
		{
			defaultBuyIn = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("specialName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, specialName)) return false;
		}
		else if (_element.equals("countryRestrictionInverted"))
		{
			countryRestrictionInverted = (*_value.ptr() == '1');
		}
		else if (_element.equals("restrictedCountries"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PString, 4 > >::FromXmlString(_value, restrictedCountries)) return false;
		}
		else if (_element.equals("replayerAddress"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, replayerAddress)) return false;
		}
		else if (_element.equals("replayerInstance"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, replayerInstance)) return false;
		}
		else if (_element.equals("minPlayersPerTable"))
		{
			minPlayersPerTable = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isPasswordProtected"))
		{
			isPasswordProtected = (*_value.ptr() == '1');
		}
		else if (_element.equals("poolBlockMinHands"))
		{
			poolBlockMinHands = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("poolBlockTimePenalty"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT32, 4 > >::FromXmlString(_value, poolBlockTimePenalty)) return false;
		}
		else if (_element.equals("flags"))
		{
			flags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("flags2"))
		{
			flags2 = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isPM"))
		{
			isPM = (*_value.ptr() == '1');
		}
		else if (_element.equals("scalePM"))
		{
			scalePM = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableStakes"))
		{
			if(!Atf::AtfTempl< TableCommon::TableStakes >::FromXmlString(_value, tableStakes)) return false;
		}
		else if (_element.equals("variableAntes"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT64, 4 > >::FromXmlString(_value, variableAntes)) return false;
		}
		else if (_element.equals("visibilityMaskEx"))
		{
			if(!Atf::AtfTempl< PSiteMask >::FromXmlString(_value, visibilityMaskEx)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobby::cli::SeatFinderStaticDataStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(SeatFinderStaticDataStruct())) // not empty
	{
		_body.composeUINT32(id);
		_body.composeBYTE(game);
		_body.composeBYTE(structure);
		_body.composeBYTE(isHiLo);
		_body.composeBYTE(maxPlayersPerTable);
		_body.composeINT32(loBet);
		_body.composeINT32(hiBet);
		_body.composeINT32(ante);
		_body.composeINT32(cap);
		_body.composeString(currency);
		_body.composeINT32(minChipsLimit);
		_body.composeINT32(maxBuyIn);
		_body.composeUINT32(visibilityMask);
		_body.composeINT32(defaultBuyIn);
		_body.composeString(specialName);
		_body.composeBOOL(countryRestrictionInverted);
		restrictedCountries.composeMsg(_body, _ignoreJSON);
		_body.composeString(replayerAddress);
		_body.composeString(replayerInstance);
		_body.composeINT8(minPlayersPerTable);
		_body.composeBOOL(isPasswordProtected);
		_body.composeINT32(poolBlockMinHands);
		poolBlockTimePenalty.composeMsg(_body, _ignoreJSON);
		_body.composeUINT32(flags);
		_body.composeUINT64(flags2);
		_body.composeBOOL(isPM);
		_body.composeUINT32(scalePM);
		tableStakes.composeMsg(_body, _ignoreJSON);
		variableAntes.composeMsg(_body, _ignoreJSON);
		visibilityMaskEx.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::SeatFinderStaticDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(id);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(structure);
	_parser0.parseBYTE(isHiLo);
	_parser0.parseBYTE(maxPlayersPerTable);
	_parser0.parseINT32(loBet);
	_parser0.parseINT32(hiBet);
	_parser0.parseINT32(ante);
	_parser0.parseINT32(cap);
	_parser0.parseStringP(currency);
	_parser0.parseINT32(minChipsLimit);
	_parser0.parseINT32(maxBuyIn);
	_parser0.parseUINT32(visibilityMask);
	_parser0.parseINT32(defaultBuyIn);
	_parser0.parseStringP(specialName);
	_parser0.parseBOOL(countryRestrictionInverted);
	restrictedCountries.parseMsg(_parser0);
	_parser0.parseStringP(replayerAddress);
	_parser0.parseStringP(replayerInstance);
	_parser0.parseINT8(minPlayersPerTable);
	_parser0.parseBOOL(isPasswordProtected);
	_parser0.parseINT32(poolBlockMinHands);
	poolBlockTimePenalty.parseMsg(_parser0);
	_parser0.parseUINT32(flags);
	_parser0.parseUINT64(flags2);
	_parser0.parseBOOL(isPM);
	_parser0.parseUINT32(scalePM);
	if(_parser0.parseEnded()) return;
	tableStakes.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	variableAntes.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	visibilityMaskEx.parseMsg(_parser0);
}

const char *MLobby::cli::SeatFinderStaticDataStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("id", id);
	_jsonstr.compose("game", game);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("maxPlayersPerTable", maxPlayersPerTable);
	_jsonstr.compose("loBet", loBet);
	_jsonstr.compose("hiBet", hiBet);
	_jsonstr.compose("ante", ante);
	_jsonstr.compose("cap", cap);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("minChipsLimit", minChipsLimit);
	_jsonstr.compose("maxBuyIn", maxBuyIn);
	_jsonstr.compose("visibilityMask", visibilityMask);
	_jsonstr.compose("defaultBuyIn", defaultBuyIn);
	_jsonstr.compose("specialName", specialName);
	_jsonstr.compose("countryRestrictionInverted", countryRestrictionInverted);
	_jsonstr.compose("restrictedCountries", restrictedCountries);
	_jsonstr.compose("replayerAddress", replayerAddress);
	_jsonstr.compose("replayerInstance", replayerInstance);
	_jsonstr.compose("minPlayersPerTable", minPlayersPerTable);
	_jsonstr.compose("isPasswordProtected", isPasswordProtected);
	_jsonstr.compose("poolBlockMinHands", poolBlockMinHands);
	_jsonstr.compose("poolBlockTimePenalty", poolBlockTimePenalty);
	_jsonstr.compose("flags", flags);
	_jsonstr.compose("flags2", flags2);
	_jsonstr.compose("isPM", isPM);
	_jsonstr.compose("scalePM", scalePM);
	_jsonstr.compose("tableStakes", tableStakes);
	_jsonstr.compose("variableAntes", variableAntes);
	_jsonstr.compose("visibilityMaskEx", visibilityMaskEx);
	return _buf.c_str();
}

void MLobby::cli::SeatFinderStaticDataStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("id", id);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("maxPlayersPerTable", maxPlayersPerTable);
	_jparser.parseByNameThrow("loBet", loBet);
	_jparser.parseByNameThrow("hiBet", hiBet);
	_jparser.parseByNameThrow("ante", ante);
	_jparser.parseByNameThrow("cap", cap);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("minChipsLimit", minChipsLimit);
	_jparser.parseByNameThrow("maxBuyIn", maxBuyIn);
	_jparser.parseByNameThrow("visibilityMask", visibilityMask);
	_jparser.parseByNameThrow("defaultBuyIn", defaultBuyIn);
	_jparser.parseByNameThrow("specialName", specialName);
	_jparser.parseByNameThrow("countryRestrictionInverted", countryRestrictionInverted);
	_jparser.parseByNameThrow("restrictedCountries", restrictedCountries);
	_jparser.parseByNameThrow("replayerAddress", replayerAddress);
	_jparser.parseByNameThrow("replayerInstance", replayerInstance);
	_jparser.parseByNameThrow("minPlayersPerTable", minPlayersPerTable);
	_jparser.parseByNameThrow("isPasswordProtected", isPasswordProtected);
	_jparser.parseByNameThrow("poolBlockMinHands", poolBlockMinHands);
	_jparser.parseByNameThrow("poolBlockTimePenalty", poolBlockTimePenalty);
	_jparser.parseByNameThrow("flags", flags);
	_jparser.parseByNameThrow("flags2", flags2);
	_jparser.parseByNameThrow("isPM", isPM);
	_jparser.parseByNameThrow("scalePM", scalePM);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tableStakes", tableStakes);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("variableAntes", variableAntes);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("visibilityMaskEx", visibilityMaskEx);
}

/* static */ void MLobby::cli::SeatFinderStaticDataStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 id; _jparser.validateByNameThrow("id", id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE maxPlayersPerTable; _jparser.validateByNameThrow("maxPlayersPerTable", maxPlayersPerTable);
	AtfValidator::validateInt(_descr, "maxPlayersPerTable", maxPlayersPerTable, _checker, __FILE__, __LINE__);
	INT32 loBet; _jparser.validateByNameThrow("loBet", loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	INT32 hiBet; _jparser.validateByNameThrow("hiBet", hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	INT32 ante; _jparser.validateByNameThrow("ante", ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	INT32 cap; _jparser.validateByNameThrow("cap", cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	INT32 minChipsLimit; _jparser.validateByNameThrow("minChipsLimit", minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	INT32 maxBuyIn; _jparser.validateByNameThrow("maxBuyIn", maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	UINT32 visibilityMask; _jparser.validateByNameThrow("visibilityMask", visibilityMask);
	AtfValidator::validateInt(_descr, "visibilityMask", visibilityMask, _checker, __FILE__, __LINE__);
	INT32 defaultBuyIn; _jparser.validateByNameThrow("defaultBuyIn", defaultBuyIn);
	AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	PString specialName; _jparser.validateByNameThrow("specialName", specialName);
	AtfValidator::validateInt(_descr, "specialName", specialName.length(), _checker, __FILE__, __LINE__);
	bool countryRestrictionInverted; _jparser.validateByNameThrow("countryRestrictionInverted", countryRestrictionInverted);
	AtfValidator::validateInt(_descr, "countryRestrictionInverted", countryRestrictionInverted, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PString > restrictedCountries; _jparser.validateByNameThrow("restrictedCountries", restrictedCountries);
	AtfValidator::validateInt(_descr, "restrictedCountries", restrictedCountries.size(), _checker, __FILE__, __LINE__);
	PString replayerAddress; _jparser.validateByNameThrow("replayerAddress", replayerAddress);
	AtfValidator::validateInt(_descr, "replayerAddress", replayerAddress.length(), _checker, __FILE__, __LINE__);
	PString replayerInstance; _jparser.validateByNameThrow("replayerInstance", replayerInstance);
	AtfValidator::validateInt(_descr, "replayerInstance", replayerInstance.length(), _checker, __FILE__, __LINE__);
	INT8 minPlayersPerTable; _jparser.validateByNameThrow("minPlayersPerTable", minPlayersPerTable);
	AtfValidator::validateInt(_descr, "minPlayersPerTable", minPlayersPerTable, _checker, __FILE__, __LINE__);
	bool isPasswordProtected; _jparser.validateByNameThrow("isPasswordProtected", isPasswordProtected);
	AtfValidator::validateInt(_descr, "isPasswordProtected", isPasswordProtected, _checker, __FILE__, __LINE__);
	INT32 poolBlockMinHands; _jparser.validateByNameThrow("poolBlockMinHands", poolBlockMinHands);
	AtfValidator::validateInt(_descr, "poolBlockMinHands", poolBlockMinHands, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< INT32 > poolBlockTimePenalty; _jparser.validateByNameThrow("poolBlockTimePenalty", poolBlockTimePenalty);
	AtfValidator::validateInt(_descr, "poolBlockTimePenalty", poolBlockTimePenalty.size(), _checker, __FILE__, __LINE__);
	UINT32 flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT64 flags2; _jparser.validateByNameThrow("flags2", flags2);
	AtfValidator::validateUint(_descr, "flags2", flags2, _checker, __FILE__, __LINE__);
	bool isPM; _jparser.validateByNameThrow("isPM", isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	TableCommon::TableStakes tableStakes; _jparser.validateByNameThrow("tableStakes", tableStakes);
	if(_jparser.parseEnded()) return;
	Atf::AtfVectorBase< INT64 > variableAntes; _jparser.validateByNameThrow("variableAntes", variableAntes);
	AtfValidator::validateInt(_descr, "variableAntes", variableAntes.size(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PSiteMask visibilityMaskEx; _jparser.validateByNameThrow("visibilityMaskEx", visibilityMaskEx);
}

/*static*/ void MLobby::cli::SeatFinderStaticDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 id; _parser0.parseUINT32(id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser0.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE maxPlayersPerTable; _parser0.parseBYTE(maxPlayersPerTable);
	AtfValidator::validateInt(_descr, "maxPlayersPerTable", maxPlayersPerTable, _checker, __FILE__, __LINE__);
	INT32 loBet; _parser0.parseINT32(loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	INT32 hiBet; _parser0.parseINT32(hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	INT32 ante; _parser0.parseINT32(ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	INT32 cap; _parser0.parseINT32(cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT32 minChipsLimit; _parser0.parseINT32(minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	INT32 maxBuyIn; _parser0.parseINT32(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	UINT32 visibilityMask; _parser0.parseUINT32(visibilityMask);
	AtfValidator::validateInt(_descr, "visibilityMask", visibilityMask, _checker, __FILE__, __LINE__);
	INT32 defaultBuyIn; _parser0.parseINT32(defaultBuyIn);
	AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "specialName"); size_t szSpecialName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "specialName", szSpecialName, _checker, __FILE__, __LINE__);
	bool countryRestrictionInverted; _parser0.parseBOOL(countryRestrictionInverted);
	AtfValidator::validateInt(_descr, "countryRestrictionInverted", countryRestrictionInverted, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szRestrictedCountries = Atf::LAtfVector< PString, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("restrictedCountries"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "restrictedCountries", szRestrictedCountries, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "replayerAddress"); size_t szReplayerAddress = strlen(_dummy);
	AtfValidator::validateInt(_descr, "replayerAddress", szReplayerAddress, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "replayerInstance"); size_t szReplayerInstance = strlen(_dummy);
	AtfValidator::validateInt(_descr, "replayerInstance", szReplayerInstance, _checker, __FILE__, __LINE__);
	INT8 minPlayersPerTable; _parser0.parseINT8(minPlayersPerTable);
	AtfValidator::validateInt(_descr, "minPlayersPerTable", minPlayersPerTable, _checker, __FILE__, __LINE__);
	bool isPasswordProtected; _parser0.parseBOOL(isPasswordProtected);
	AtfValidator::validateInt(_descr, "isPasswordProtected", isPasswordProtected, _checker, __FILE__, __LINE__);
	INT32 poolBlockMinHands; _parser0.parseINT32(poolBlockMinHands);
	AtfValidator::validateInt(_descr, "poolBlockMinHands", poolBlockMinHands, _checker, __FILE__, __LINE__);
	int szPoolBlockTimePenalty = Atf::LAtfVector< INT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("poolBlockTimePenalty"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "poolBlockTimePenalty", szPoolBlockTimePenalty, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser0.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT64 flags2; _parser0.parseUINT64(flags2);
	AtfValidator::validateUint(_descr, "flags2", flags2, _checker, __FILE__, __LINE__);
	bool isPM; _parser0.parseBOOL(isPM);
	AtfValidator::validateInt(_descr, "isPM", isPM, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser0.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	TableCommon::TableStakes::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tableStakes"), _fieldsWithUnparsedContent);
	if(_parser0.parseEnded()) return;
	int szVariableAntes = Atf::LAtfVector< INT64, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("variableAntes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "variableAntes", szVariableAntes, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("visibilityMaskEx"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SeatFinderDynaDataStruct
//=================================================================

MLobby::cli::SeatFinderDynaDataStruct::SeatFinderDynaDataStruct()
{
	clear();
}

void MLobby::cli::SeatFinderDynaDataStruct::clear()
{
	handsPerHour = 0;
	avgPotSize = 0;
	avgStackSize = 0;
	numPlayers = 0;
	numTables = 0;
	numFullTables = 0;
}

bool MLobby::cli::SeatFinderDynaDataStruct::equals(const SeatFinderDynaDataStruct& _o) const
{
	return handsPerHour == _o.handsPerHour &&
		avgPotSize == _o.avgPotSize &&
		avgStackSize == _o.avgStackSize &&
		numPlayers == _o.numPlayers &&
		numTables == _o.numTables &&
		numFullTables == _o.numFullTables;
}

const char *MLobby::cli::SeatFinderDynaDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("handsPerHour=");
	_buf.appendInt(handsPerHour);
	_buf.append(',');
	_buf.append("avgPotSize=");
	_buf.appendInt(avgPotSize);
	_buf.append(',');
	_buf.append("avgStackSize=");
	_buf.appendInt(avgStackSize);
	_buf.append(',');
	_buf.append("numPlayers=");
	_buf.appendInt(numPlayers);
	_buf.append(',');
	_buf.append("numTables=");
	_buf.appendInt(numTables);
	_buf.append(',');
	_buf.append("numFullTables=");
	_buf.appendInt(numFullTables);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobby::cli::SeatFinderDynaDataStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("handsPerHour", handsPerHour, _buf);
	Atf::XmlElement::encodeAsXmlElement("avgPotSize", avgPotSize, _buf);
	Atf::XmlElement::encodeAsXmlElement("avgStackSize", avgStackSize, _buf);
	Atf::XmlElement::encodeAsXmlElement("numPlayers", numPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("numTables", numTables, _buf);
	Atf::XmlElement::encodeAsXmlElement("numFullTables", numFullTables, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobby::cli::SeatFinderDynaDataStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("handsPerHour"))
		{
			handsPerHour = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("avgPotSize"))
		{
			avgPotSize = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("avgStackSize"))
		{
			avgStackSize = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numPlayers"))
		{
			numPlayers = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numTables"))
		{
			numTables = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numFullTables"))
		{
			numFullTables = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobby::cli::SeatFinderDynaDataStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(SeatFinderDynaDataStruct())) // not empty
	{
		_body.composeINT32(handsPerHour);
		_body.composeINT32(avgPotSize);
		_body.composeINT32(avgStackSize);
		_body.composeINT32(numPlayers);
		_body.composeINT32(numTables);
		_body.composeINT32(numFullTables);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::SeatFinderDynaDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(handsPerHour);
	_parser0.parseINT32(avgPotSize);
	_parser0.parseINT32(avgStackSize);
	_parser0.parseINT32(numPlayers);
	_parser0.parseINT32(numTables);
	_parser0.parseINT32(numFullTables);
}

const char *MLobby::cli::SeatFinderDynaDataStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("handsPerHour", handsPerHour);
	_jsonstr.compose("avgPotSize", avgPotSize);
	_jsonstr.compose("avgStackSize", avgStackSize);
	_jsonstr.compose("numPlayers", numPlayers);
	_jsonstr.compose("numTables", numTables);
	_jsonstr.compose("numFullTables", numFullTables);
	return _buf.c_str();
}

void MLobby::cli::SeatFinderDynaDataStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("handsPerHour", handsPerHour);
	_jparser.parseByNameThrow("avgPotSize", avgPotSize);
	_jparser.parseByNameThrow("avgStackSize", avgStackSize);
	_jparser.parseByNameThrow("numPlayers", numPlayers);
	_jparser.parseByNameThrow("numTables", numTables);
	_jparser.parseByNameThrow("numFullTables", numFullTables);
}

/* static */ void MLobby::cli::SeatFinderDynaDataStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 handsPerHour; _jparser.validateByNameThrow("handsPerHour", handsPerHour);
	AtfValidator::validateInt(_descr, "handsPerHour", handsPerHour, _checker, __FILE__, __LINE__);
	INT32 avgPotSize; _jparser.validateByNameThrow("avgPotSize", avgPotSize);
	AtfValidator::validateInt(_descr, "avgPotSize", avgPotSize, _checker, __FILE__, __LINE__);
	INT32 avgStackSize; _jparser.validateByNameThrow("avgStackSize", avgStackSize);
	AtfValidator::validateInt(_descr, "avgStackSize", avgStackSize, _checker, __FILE__, __LINE__);
	INT32 numPlayers; _jparser.validateByNameThrow("numPlayers", numPlayers);
	AtfValidator::validateInt(_descr, "numPlayers", numPlayers, _checker, __FILE__, __LINE__);
	INT32 numTables; _jparser.validateByNameThrow("numTables", numTables);
	AtfValidator::validateInt(_descr, "numTables", numTables, _checker, __FILE__, __LINE__);
	INT32 numFullTables; _jparser.validateByNameThrow("numFullTables", numFullTables);
	AtfValidator::validateInt(_descr, "numFullTables", numFullTables, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobby::cli::SeatFinderDynaDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 handsPerHour; _parser0.parseINT32(handsPerHour);
	AtfValidator::validateInt(_descr, "handsPerHour", handsPerHour, _checker, __FILE__, __LINE__);
	INT32 avgPotSize; _parser0.parseINT32(avgPotSize);
	AtfValidator::validateInt(_descr, "avgPotSize", avgPotSize, _checker, __FILE__, __LINE__);
	INT32 avgStackSize; _parser0.parseINT32(avgStackSize);
	AtfValidator::validateInt(_descr, "avgStackSize", avgStackSize, _checker, __FILE__, __LINE__);
	INT32 numPlayers; _parser0.parseINT32(numPlayers);
	AtfValidator::validateInt(_descr, "numPlayers", numPlayers, _checker, __FILE__, __LINE__);
	INT32 numTables; _parser0.parseINT32(numTables);
	AtfValidator::validateInt(_descr, "numTables", numTables, _checker, __FILE__, __LINE__);
	INT32 numFullTables; _parser0.parseINT32(numFullTables);
	AtfValidator::validateInt(_descr, "numFullTables", numFullTables, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SeatFinderDataStruct
//=================================================================

MLobby::cli::SeatFinderDataStruct::SeatFinderDataStruct()
{
	clear();
}

void MLobby::cli::SeatFinderDataStruct::clear()
{
	staticData.clear();
	dynamicData.clear();
}

bool MLobby::cli::SeatFinderDataStruct::equals(const SeatFinderDataStruct& _o) const
{
	return staticData.equals(_o.staticData) &&
		dynamicData.equals(_o.dynamicData);
}

const char *MLobby::cli::SeatFinderDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("staticData=");
	staticData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("dynamicData=");
	dynamicData.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MLobby::cli::SeatFinderDataStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	staticData.toXmlString("staticData", _buf);
	dynamicData.toXmlString("dynamicData", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MLobby::cli::SeatFinderDataStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("staticData"))
		{
			if(!Atf::AtfTempl< SeatFinderStaticDataStruct >::FromXmlString(_value, staticData)) return false;
		}
		else if (_element.equals("dynamicData"))
		{
			if(!Atf::AtfTempl< SeatFinderDynaDataStruct >::FromXmlString(_value, dynamicData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MLobby::cli::SeatFinderDataStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(SeatFinderDataStruct())) // not empty
	{
		staticData.composeMsg(_body, _ignoreJSON);
		dynamicData.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void MLobby::cli::SeatFinderDataStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	staticData.parseMsg(_parser0);
	dynamicData.parseMsg(_parser0);
}

const char *MLobby::cli::SeatFinderDataStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("staticData", staticData);
	_jsonstr.compose("dynamicData", dynamicData);
	return _buf.c_str();
}

void MLobby::cli::SeatFinderDataStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("staticData", staticData);
	_jparser.parseByNameThrow("dynamicData", dynamicData);
}

/* static */ void MLobby::cli::SeatFinderDataStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	SeatFinderStaticDataStruct staticData; _jparser.validateByNameThrow("staticData", staticData);
	SeatFinderDynaDataStruct dynamicData; _jparser.validateByNameThrow("dynamicData", dynamicData);
}

/*static*/ void MLobby::cli::SeatFinderDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	SeatFinderStaticDataStruct::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("staticData"), _fieldsWithUnparsedContent);
	SeatFinderDynaDataStruct::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("dynamicData"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES
//=================================================================

MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES::clear()
{
	filter.clear();
	maxItems = 0;
	excludedFinders.clear();
	context = 0;
	installId.clear();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES::equals(const Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES& _o) const
{
	return filter.equals(_o.filter) &&
		maxItems == _o.maxItems &&
		excludedFinders.equals(_o.excludedFinders) &&
		context == _o.context &&
		Atf::atfPStringEquals(installId, _o.installId);
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBY_FIND_MORPH_LOBBIES != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES*)_other));
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_MORPH_LOBBIES).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("maxItems=");
	_buf.appendUint(maxItems);
	_buf.append(',');
	_buf.append("excludedFinders=");
	excludedFinders.toTraceString(_buf);
	_buf.append(',');
	_buf.append("context=");
	_buf.appendUint(context);
	_buf.append(',');
	_buf.append("installId=");
	_buf.append(installId);
	return _buf.c_str();
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBY_FIND_MORPH_LOBBIES).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	filter.toXmlString("filter", _buf);
	Atf::XmlElement::encodeAsXmlElement("maxItems", maxItems, _buf);
	excludedFinders.toXmlString("excludedFinders", _buf);
	Atf::XmlElement::encodeAsXmlElement("context", context, _buf);
	Atf::XmlElement::encodeAsXmlElement("installId", installId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("filter"))
			{
				if(!Atf::AtfTempl< MorphLobbySelectionFilter >::FromXmlString(_value, filter)) return false;
			}
			else if (_element.equals("maxItems"))
			{
				maxItems = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("excludedFinders"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, excludedFinders)) return false;
			}
			else if (_element.equals("context"))
			{
				context = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("installId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, installId)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	filter.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(maxItems);
	excludedFinders.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(context);
	_msg.composeString(installId);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	_parser.parseUINT32(maxItems);
	excludedFinders.parseMsg(_parser);
	_parser.parseUINT32(context);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(installId);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("filter", filter);
	_jsonstr.compose("maxItems", maxItems);
	_jsonstr.compose("excludedFinders", excludedFinders);
	_jsonstr.compose("context", context);
	_jsonstr.compose("installId", installId);
	return _buf.c_str();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("filter", filter);
	_jparser.parseByNameThrow("maxItems", maxItems);
	_jparser.parseByNameThrow("excludedFinders", excludedFinders);
	_jparser.parseByNameThrow("context", context);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("installId", installId);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_MORPH_LOBBIES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	MorphLobbySelectionFilter filter; _jparser.validateByNameThrow("filter", filter);
	UINT32 maxItems; _jparser.validateByNameThrow("maxItems", maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT32 > excludedFinders; _jparser.validateByNameThrow("excludedFinders", excludedFinders);
	AtfValidator::validateIntMax(_descr, "excludedFinders", excludedFinders.size(), 1024, _checker, __FILE__, __LINE__);
	UINT32 context; _jparser.validateByNameThrow("context", context);
	AtfValidator::validateInt(_descr, "context", context, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString installId; _jparser.validateByNameThrow("installId", installId);
	AtfValidator::validateIntMax(_descr, "installId", installId.length(), 128, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_MORPH_LOBBIES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	PString _descbuf;
	MorphLobbySelectionFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	UINT32 maxItems; _parser.parseUINT32(maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
	int szExcludedFinders = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("excludedFinders"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "excludedFinders", szExcludedFinders, 1024, _checker, __FILE__, __LINE__);
	UINT32 context; _parser.parseUINT32(context);
	AtfValidator::validateInt(_descr, "context", context, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "installId"); size_t szInstallId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "installId", szInstallId, 128, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY
//=================================================================

MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY::clear()
{
	totalItems = 0;
	sf.clear();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY::equals(const Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY& _o) const
{
	return totalItems == _o.totalItems &&
		sf.equals(_o.sf);
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY*)_other));
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY).append(")");
	_buf.append(',');
	_buf.append("totalItems=");
	_buf.appendUint(totalItems);
	_buf.append(',');
	_buf.append("sf=");
	sf.toTraceString(_buf);
	return _buf.c_str();
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("totalItems", totalItems, _buf);
	sf.toXmlString("sf", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("totalItems"))
			{
				totalItems = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("sf"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SeatFinderStruct, 4 > >::FromXmlString(_value, sf)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(totalItems);
	sf.composeMsg(_msg, _ignoreJSON);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(totalItems);
	sf.parseMsg(_parser);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("totalItems", totalItems);
	_jsonstr.compose("sf", sf);
	return _buf.c_str();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("totalItems", totalItems);
	_jparser.parseByNameThrow("sf", sf);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 totalItems; _jparser.validateByNameThrow("totalItems", totalItems);
	AtfValidator::validateInt(_descr, "totalItems", totalItems, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SeatFinderStruct > sf; _jparser.validateByNameThrow("sf", sf);
	AtfValidator::validateInt(_descr, "sf", sf.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 totalItems; _parser.parseUINT32(totalItems);
	AtfValidator::validateInt(_descr, "totalItems", totalItems, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szSf = Atf::LAtfVector< SeatFinderStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sf"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sf", szSf, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES
//=================================================================

MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES::clear()
{
	filter.clear();
	maxItems = 0;
	excludedFinders.clear();
	context = 0;
	installId.clear();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES::equals(const Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES& _o) const
{
	return filter.equals(_o.filter) &&
		maxItems == _o.maxItems &&
		excludedFinders.equals(_o.excludedFinders) &&
		context == _o.context &&
		Atf::atfPStringEquals(installId, _o.installId);
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBY_FIND_HYBRID_GAMES != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES*)_other));
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_HYBRID_GAMES).append(")");
	_buf.append(',');
	_buf.append("filter=");
	filter.toTraceString(_buf);
	_buf.append(',');
	_buf.append("maxItems=");
	_buf.appendUint(maxItems);
	_buf.append(',');
	_buf.append("excludedFinders=");
	excludedFinders.toTraceString(_buf);
	_buf.append(',');
	_buf.append("context=");
	_buf.appendUint(context);
	_buf.append(',');
	_buf.append("installId=");
	_buf.append(installId);
	return _buf.c_str();
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBY_FIND_HYBRID_GAMES).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	filter.toXmlString("filter", _buf);
	Atf::XmlElement::encodeAsXmlElement("maxItems", maxItems, _buf);
	excludedFinders.toXmlString("excludedFinders", _buf);
	Atf::XmlElement::encodeAsXmlElement("context", context, _buf);
	Atf::XmlElement::encodeAsXmlElement("installId", installId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("filter"))
			{
				if(!Atf::AtfTempl< HybridLobbySelectionFilter >::FromXmlString(_value, filter)) return false;
			}
			else if (_element.equals("maxItems"))
			{
				maxItems = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("excludedFinders"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, excludedFinders)) return false;
			}
			else if (_element.equals("context"))
			{
				context = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("installId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, installId)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	filter.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(maxItems);
	excludedFinders.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(context);
	_msg.composeString(installId);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES::parseMsg(CommMsgParser& _parser)
{
	filter.parseMsg(_parser);
	_parser.parseUINT32(maxItems);
	excludedFinders.parseMsg(_parser);
	_parser.parseUINT32(context);
	_parser.parseStringP(installId);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("filter", filter);
	_jsonstr.compose("maxItems", maxItems);
	_jsonstr.compose("excludedFinders", excludedFinders);
	_jsonstr.compose("context", context);
	_jsonstr.compose("installId", installId);
	return _buf.c_str();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("filter", filter);
	_jparser.parseByNameThrow("maxItems", maxItems);
	_jparser.parseByNameThrow("excludedFinders", excludedFinders);
	_jparser.parseByNameThrow("context", context);
	_jparser.parseByNameThrow("installId", installId);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_HYBRID_GAMES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	HybridLobbySelectionFilter filter; _jparser.validateByNameThrow("filter", filter);
	UINT32 maxItems; _jparser.validateByNameThrow("maxItems", maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT32 > excludedFinders; _jparser.validateByNameThrow("excludedFinders", excludedFinders);
	AtfValidator::validateIntMax(_descr, "excludedFinders", excludedFinders.size(), 1024, _checker, __FILE__, __LINE__);
	UINT32 context; _jparser.validateByNameThrow("context", context);
	AtfValidator::validateInt(_descr, "context", context, _checker, __FILE__, __LINE__);
	PString installId; _jparser.validateByNameThrow("installId", installId);
	AtfValidator::validateIntMax(_descr, "installId", installId.length(), 128, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_HYBRID_GAMES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	PString _descbuf;
	HybridLobbySelectionFilter::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("filter"), _fieldsWithUnparsedContent);
	UINT32 maxItems; _parser.parseUINT32(maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
	int szExcludedFinders = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("excludedFinders"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "excludedFinders", szExcludedFinders, 1024, _checker, __FILE__, __LINE__);
	UINT32 context; _parser.parseUINT32(context);
	AtfValidator::validateInt(_descr, "context", context, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "installId"); size_t szInstallId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "installId", szInstallId, 128, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY
//=================================================================

MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY::clear()
{
	totalItems = 0;
	sfs.clear();
	blitzes.clear();
	tableTypes.clear();
	gameOrder.clear();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY::equals(const Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY& _o) const
{
	return totalItems == _o.totalItems &&
		sfs.equals(_o.sfs) &&
		blitzes.equals(_o.blitzes) &&
		tableTypes.equals(_o.tableTypes) &&
		gameOrder.equals(_o.gameOrder);
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY*)_other));
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY).append(")");
	_buf.append(',');
	_buf.append("totalItems=");
	_buf.appendUint(totalItems);
	_buf.append(',');
	_buf.append("sfs=");
	sfs.toTraceString(_buf);
	_buf.append(',');
	_buf.append("blitzes=");
	blitzes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableTypes=");
	tableTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameOrder=");
	gameOrder.toTraceString(_buf);
	return _buf.c_str();
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("totalItems", totalItems, _buf);
	sfs.toXmlString("sfs", _buf);
	blitzes.toXmlString("blitzes", _buf);
	tableTypes.toXmlString("tableTypes", _buf);
	gameOrder.toXmlString("gameOrder", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("totalItems"))
			{
				totalItems = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("sfs"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SeatFinderDataStruct, 4 > >::FromXmlString(_value, sfs)) return false;
			}
			else if (_element.equals("blitzes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ZoomDataStruct, 4 > >::FromXmlString(_value, blitzes)) return false;
			}
			else if (_element.equals("tableTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TableTypeDataStruct, 4 > >::FromXmlString(_value, tableTypes)) return false;
			}
			else if (_element.equals("gameOrder"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, gameOrder)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(totalItems);
	sfs.composeMsg(_msg, _ignoreJSON);
	blitzes.composeMsg(_msg, _ignoreJSON);
	tableTypes.composeMsg(_msg, _ignoreJSON);
	gameOrder.composeMsg(_msg, _ignoreJSON);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(totalItems);
	sfs.parseMsg(_parser);
	blitzes.parseMsg(_parser);
	tableTypes.parseMsg(_parser);
	gameOrder.parseMsg(_parser);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("totalItems", totalItems);
	_jsonstr.compose("sfs", sfs);
	_jsonstr.compose("blitzes", blitzes);
	_jsonstr.compose("tableTypes", tableTypes);
	_jsonstr.compose("gameOrder", gameOrder);
	return _buf.c_str();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("totalItems", totalItems);
	_jparser.parseByNameThrow("sfs", sfs);
	_jparser.parseByNameThrow("blitzes", blitzes);
	_jparser.parseByNameThrow("tableTypes", tableTypes);
	_jparser.parseByNameThrow("gameOrder", gameOrder);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 totalItems; _jparser.validateByNameThrow("totalItems", totalItems);
	AtfValidator::validateInt(_descr, "totalItems", totalItems, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SeatFinderDataStruct > sfs; _jparser.validateByNameThrow("sfs", sfs);
	AtfValidator::validateInt(_descr, "sfs", sfs.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< ZoomDataStruct > blitzes; _jparser.validateByNameThrow("blitzes", blitzes);
	AtfValidator::validateInt(_descr, "blitzes", blitzes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TableTypeDataStruct > tableTypes; _jparser.validateByNameThrow("tableTypes", tableTypes);
	AtfValidator::validateInt(_descr, "tableTypes", tableTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT32 > gameOrder; _jparser.validateByNameThrow("gameOrder", gameOrder);
	AtfValidator::validateInt(_descr, "gameOrder", gameOrder.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 totalItems; _parser.parseUINT32(totalItems);
	AtfValidator::validateInt(_descr, "totalItems", totalItems, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szSfs = Atf::LAtfVector< SeatFinderDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sfs"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sfs", szSfs, _checker, __FILE__, __LINE__);
	int szBlitzes = Atf::LAtfVector< ZoomDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("blitzes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "blitzes", szBlitzes, _checker, __FILE__, __LINE__);
	int szTableTypes = Atf::LAtfVector< TableTypeDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tableTypes", szTableTypes, _checker, __FILE__, __LINE__);
	int szGameOrder = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("gameOrder"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "gameOrder", szGameOrder, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE
//=================================================================

MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE::clear()
{
	tableTypeId = 0;
	maxItems = 0;
	order = 0;
	context = 0;
	installId.clear();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE::equals(const Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE& _o) const
{
	return tableTypeId == _o.tableTypeId &&
		maxItems == _o.maxItems &&
		order == _o.order &&
		context == _o.context &&
		Atf::atfPStringEquals(installId, _o.installId);
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBY_FIND_RING_GAME_BY_TYPE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE*)_other));
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_RING_GAME_BY_TYPE).append(")");
	_buf.append(',');
	_buf.append("tableTypeId=");
	_buf.appendUint(tableTypeId);
	_buf.append(',');
	_buf.append("maxItems=");
	_buf.appendUint(maxItems);
	_buf.append(',');
	_buf.append("order=");
	_buf.appendUint(order);
	_buf.append(',');
	_buf.append("context=");
	_buf.appendUint(context);
	_buf.append(',');
	_buf.append("installId=");
	_buf.append(installId);
	return _buf.c_str();
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBY_FIND_RING_GAME_BY_TYPE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("tableTypeId", tableTypeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxItems", maxItems, _buf);
	Atf::XmlElement::encodeAsXmlElement("order", order, _buf);
	Atf::XmlElement::encodeAsXmlElement("context", context, _buf);
	Atf::XmlElement::encodeAsXmlElement("installId", installId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tableTypeId"))
			{
				tableTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxItems"))
			{
				maxItems = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("order"))
			{
				order = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("context"))
			{
				context = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("installId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, installId)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(tableTypeId);
	_msg.composeUINT32(maxItems);
	_msg.composeUINT32(order);
	_msg.composeUINT32(context);
	_msg.composeString(installId);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tableTypeId);
	_parser.parseUINT32(maxItems);
	_parser.parseUINT32(order);
	_parser.parseUINT32(context);
	_parser.parseStringP(installId);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tableTypeId", tableTypeId);
	_jsonstr.compose("maxItems", maxItems);
	_jsonstr.compose("order", order);
	_jsonstr.compose("context", context);
	_jsonstr.compose("installId", installId);
	return _buf.c_str();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tableTypeId", tableTypeId);
	_jparser.parseByNameThrow("maxItems", maxItems);
	_jparser.parseByNameThrow("order", order);
	_jparser.parseByNameThrow("context", context);
	_jparser.parseByNameThrow("installId", installId);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_RING_GAME_BY_TYPE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tableTypeId; _jparser.validateByNameThrow("tableTypeId", tableTypeId);
	AtfValidator::validateInt(_descr, "tableTypeId", tableTypeId, _checker, __FILE__, __LINE__);
	UINT32 maxItems; _jparser.validateByNameThrow("maxItems", maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
	UINT32 order; _jparser.validateByNameThrow("order", order);
	AtfValidator::validateIntMax(_descr, "order", order, SelectionFilter::TableOrder_Last, _checker, __FILE__, __LINE__);
	UINT32 context; _jparser.validateByNameThrow("context", context);
	AtfValidator::validateInt(_descr, "context", context, _checker, __FILE__, __LINE__);
	PString installId; _jparser.validateByNameThrow("installId", installId);
	AtfValidator::validateIntMax(_descr, "installId", installId.length(), 128, _checker, __FILE__, __LINE__);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_RING_GAME_BY_TYPE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 tableTypeId; _parser.parseUINT32(tableTypeId);
	AtfValidator::validateInt(_descr, "tableTypeId", tableTypeId, _checker, __FILE__, __LINE__);
	UINT32 maxItems; _parser.parseUINT32(maxItems);
	AtfValidator::validateIntMax(_descr, "maxItems", maxItems, 500000, _checker, __FILE__, __LINE__);
	UINT32 order; _parser.parseUINT32(order);
	AtfValidator::validateIntMax(_descr, "order", order, SelectionFilter::TableOrder_Last, _checker, __FILE__, __LINE__);
	UINT32 context; _parser.parseUINT32(context);
	AtfValidator::validateInt(_descr, "context", context, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "installId"); size_t szInstallId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "installId", szInstallId, 128, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY
//=================================================================

MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY()
{
	clear();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY::clear()
{
	totalItems = 0;
	tables.clear();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY::equals(const Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY& _o) const
{
	return totalItems == _o.totalItems &&
		tables.equals(_o.tables);
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY*)_other));
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY).append(")");
	_buf.append(',');
	_buf.append("totalItems=");
	_buf.appendUint(totalItems);
	_buf.append(',');
	_buf.append("tables=");
	tables.toTraceString(_buf);
	return _buf.c_str();
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("totalItems", totalItems, _buf);
	tables.toXmlString("tables", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("totalItems"))
			{
				totalItems = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tables"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< RingDataStruct, 4 > >::FromXmlString(_value, tables)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(totalItems);
	tables.composeMsg(_msg, _ignoreJSON);
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(totalItems);
	tables.parseMsg(_parser);
}

const char *MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("totalItems", totalItems);
	_jsonstr.compose("tables", tables);
	return _buf.c_str();
}

void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("totalItems", totalItems);
	_jparser.parseByNameThrow("tables", tables);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 totalItems; _jparser.validateByNameThrow("totalItems", totalItems);
	AtfValidator::validateInt(_descr, "totalItems", totalItems, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< RingDataStruct > tables; _jparser.validateByNameThrow("tables", tables);
	AtfValidator::validateInt(_descr, "tables", tables.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MLobby::cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 totalItems; _parser.parseUINT32(totalItems);
	AtfValidator::validateInt(_descr, "totalItems", totalItems, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTables = Atf::LAtfVector< RingDataStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tables"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tables", szTables, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ Atf::MessageProtocol* MLobby::ProtocolFactory::createMessageProtocolObject(const char *_nameSpace, UINT32 _msgId)
{
	Atf::MessageProtocol *_obj = NULL;

	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_MLOBBY_FIND_BLITZ: _obj = new cli::Protocol_MSG_MLOBBY_FIND_BLITZ(); break;
			case MSG_MLOBBY_FIND_HYBRID_GAMES: _obj = new cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES(); break;
			case MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY: _obj = new cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY(); break;
			case MSG_MLOBBY_FIND_MORPH_LOBBIES: _obj = new cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES(); break;
			case MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY: _obj = new cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY(); break;
			case MSG_MLOBBY_FIND_RINGGAMES: _obj = new cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES(); break;
			case MSG_MLOBBY_FIND_RINGGAMES2: _obj = new cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2(); break;
			case MSG_MLOBBY_FIND_RINGGAMES2_REPLY: _obj = new cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2_REPLY(); break;
			case MSG_MLOBBY_FIND_RING_GAME_BY_TYPE: _obj = new cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE(); break;
			case MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY: _obj = new cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY(); break;
			case MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES: _obj = new cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES(); break;
			case MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2: _obj = new cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2(); break;
			case MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY: _obj = new cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY(); break;
			case MSG_MLOBBY_FIND_TABLE64: _obj = new cli::Protocol_MSG_MLOBBY_FIND_TABLE64(); break;
			case MSG_MLOBBY_FIND_TABLE64_2: _obj = new cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2(); break;
			case MSG_MLOBBY_FIND_TABLE64_2_REPLY: _obj = new cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2_REPLY(); break;
			case MSG_MLOBBY_FIND_TABLE_OLD: _obj = new cli::Protocol_MSG_MLOBBY_FIND_TABLE_OLD(); break;
			case MSG_MLOBBY_FIND_TOURNAMENTS: _obj = new cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS(); break;
			case MSG_MLOBBY_FIND_TOURNAMENTS2: _obj = new cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2(); break;
			case MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY: _obj = new cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY(); break;
		}
	}
	
	return _obj;
}

/* static */ bool MLobby::ProtocolFactory::validateProtocolMessageFromJSONString(const char *_nameSpace, UINT32 _msgId, const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_MLOBBY_FIND_BLITZ: cli::Protocol_MSG_MLOBBY_FIND_BLITZ::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_HYBRID_GAMES: cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY: cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_MORPH_LOBBIES: cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY: cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_RINGGAMES: cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_RINGGAMES2: cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_RINGGAMES2_REPLY: cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_RING_GAME_BY_TYPE: cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY: cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES: cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2: cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY: cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_TABLE64: cli::Protocol_MSG_MLOBBY_FIND_TABLE64::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_TABLE64_2: cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_TABLE64_2_REPLY: cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_TABLE_OLD: cli::Protocol_MSG_MLOBBY_FIND_TABLE_OLD::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_TOURNAMENTS: cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_TOURNAMENTS2: cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY: cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

/* static */ bool MLobby::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_MLOBBY_FIND_BLITZ: cli::Protocol_MSG_MLOBBY_FIND_BLITZ::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_HYBRID_GAMES: cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY: cli::Protocol_MSG_MLOBBY_FIND_HYBRID_GAMES_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_MORPH_LOBBIES: cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY: cli::Protocol_MSG_MLOBBY_FIND_MORPH_LOBBIES_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_RINGGAMES: cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_RINGGAMES2: cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_RINGGAMES2_REPLY: cli::Protocol_MSG_MLOBBY_FIND_RINGGAMES2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_RING_GAME_BY_TYPE: cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY: cli::Protocol_MSG_MLOBBY_FIND_RING_GAME_BY_TYPE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES: cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2: cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY: cli::Protocol_MSG_MLOBBY_FIND_SEATFINDERS_AND_BLITZES2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_TABLE64: cli::Protocol_MSG_MLOBBY_FIND_TABLE64::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_TABLE64_2: cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_TABLE64_2_REPLY: cli::Protocol_MSG_MLOBBY_FIND_TABLE64_2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_TABLE_OLD: cli::Protocol_MSG_MLOBBY_FIND_TABLE_OLD::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_TOURNAMENTS: cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_TOURNAMENTS2: cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY: cli::Protocol_MSG_MLOBBY_FIND_TOURNAMENTS2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

