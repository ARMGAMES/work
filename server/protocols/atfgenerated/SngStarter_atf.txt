#include "UserDefStructs.h"
#include "Common_atf${ATF_THIN_FILENAME_SUFFIX}.h"
#include "lobby.h"

#define ATF_SNG_MAX_REG_GAMES        100
#define ATF_SNG_MAX_BUYIN_REAL      (20000 * 100) // $20,000
#define ATF_SNG_MAX_BUYIN_PM        (PINT32_MAX / 2)   // no practical limit
#define ATF_SNG_MAX_BUYIN_FPP        PINT32_MAX        // no limit
#define ATF_SNG_MAX_ADMISSIONS       100
#define ATF_SNG_MAX_ADMISSION_PRICE (ATF_SNG_MAX_BUYIN_PM * ATF_MAX_PM_SCALE_LL)

#define ATF_SNG_MAX_PASSWORD_LEN 100


#define TOP_LEVEL_NAMESPACE SngStarter

namespace cli
{
	Message MSG_LOBBY_TOURN_REG_INFO
	{
		UINT32 scriptId;
		BYTE numGames min 1 max ATF_SNG_MAX_REG_GAMES;
		UINT32 tournRegInfoFlags parseEndOptB4Me; 
	};

	Message MSG_SNG_POOL_CHECKIN
	{
		PString userId maxlen ATF_USER_NAME_MAX_LENGTH;
		INT32 buyInRM min 0 max ATF_SNG_MAX_BUYIN_REAL;
		INT32 buyInPlay min 0 max ATF_SNG_MAX_BUYIN_PM;
		INT32 buyInFpp min 0 max ATF_SNG_MAX_BUYIN_FPP;
		PString tournPwd maxlen ATF_SNG_MAX_PASSWORD_LEN;
		BYTE useTicket min 0 max 1;
		INT32 buyInT min 0 max ATF_SNG_MAX_BUYIN_REAL;
		INT32 buyInW min 0 max 0;  // only 0 is allowed
		CommMsgBody currencyContext maxsize 10000; // we switched to an empty msgbody because trying to buy into a tournament with a user that does not have auto convert currency set and sending a non-empty currencyContext will return an error
		UINT32 scriptId;
		BYTE numGames min 1 max ATF_SNG_MAX_REG_GAMES;
		INT64 admissionPrice min 0 max ATF_SNG_MAX_ADMISSION_PRICE;
		vector<Common${ATF_THIN_NAMESPACE_SUFFIX}::AtfShared::UserTicketDataBase> admissions maxsize ATF_SNG_MAX_ADMISSIONS;
	};

	Message MSG_SNG_POOL_CHECKOUT
	{
		UINT32 scriptId;
	};

	Message MSG_SNG_POOL_WHERE_IS_PLAYER
	{
		PString userId maxlen 100; // client bug: can send email instead of userId, change limit to 100
	};
	
	Struct UserTicketDataATF
	{
		PString admissionId;
		UINT32 totalCount;
		UINT32 reserved;
	};
	
	Message MSG_LOBBY_TOURN_REG_INFO_REPLY
	{
		INT16 errCode;
		
		if( errCode != DBM_NO_ERROR )
		{
			PString errMsg;
		}
		else
		{
			UINT32 buyin;
			UINT32 rake;
			UINT32 fppBuyin;
			PString admission;
			BYTE pm;
			BYTE pwd;
			UINT32 chips;
			UINT32 playChips32;
			UINT32 fpp;
			UINT32 tickets;
			UINT32 tchips;
			UINT32 notused;
			PString preRegistrMessage;
			BYTE game;
			BYTE isHiLo;
			BYTE structure;
			PString currency;
			bool enoughMoneyInOtherCurrency;
			CommMsgBody currencyContext;
			CommMsgBody clientCurrencyContext;
			SrvTime whenStartAbs;
			PString name;
			UINT64 playChips;
			UINT32 scalePM;
			BYTE speedDisplay; 
			UINT32 minPlayers;
			UINT32 maxPlayers;
			BYTE maxPerTable;
			UINT32 tournFlags;
			UINT32 knockout;
			bool boolValue;
			INT64 admissionPrice;
			vector<UserTicketDataATF> effectiveAdmissions;
			UINT64 tournFlags2;
		}
	};
	
	Message MSG_SNG_POOL_CHECKIN_REPLY
	{
		UINT32 scriptId;
		INT16 errCode;
		
		if( errCode != DBM_NO_ERROR )
		{
			PString errMsg;
		}
		else
		{
			BYTE totalGamesNow;
			UINT32 tournId;
			PString sampleAddress;
			UINT32 buyIn;
			UINT32 fppBuyIn;
			UINT32 rake;
			BYTE game;
			BYTE hiLo;
			BYTE structure;
			BYTE isPlayMoney;
			PString icurrency;
			UINT32 scalePM;
			PString name;
		}
	};
	
	Message MSG_SNG_POOL_CHECKOUT_REPLY
	{
		UINT32 scriptId;
		INT16 errCode;
		BYTE cancelledGames;
	};
	
	MsgBodyStruct SngGameBody
	{
		UINT32 scriptId;
		BYTE numGames;
		UINT32 tournId;
		PString sampleAddress;
		UINT32 buyIn;
		UINT32 fppBuyIn;
		UINT32 rake;
		BYTE game;
		BYTE hiLo;
		BYTE structure;
		BYTE isPlayMoney;
		PString currency;
		UINT32 scalePM;
		PString name;
		UINT64 tournFlags2;
	};
	
	Message MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY
	{
		INT16 errCode;
		
		if( errCode != DBM_NO_ERROR )
		{
			PString errMsg;
		}
		else
		{
			vector<SngGameBody> sngs;
		}
	};
};
