/**
 * SngStarter_atf.cpp
 *
 * This file was auto-generated from SngStarter_atf.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: SngStarter_atf.txt
 */
 
#include "SngStarter_atf.h"

//=================================================================
//                Protocol_MSG_LOBBY_TOURN_REG_INFO
//=================================================================

SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::Protocol_MSG_LOBBY_TOURN_REG_INFO()
{
	clear();
}

void SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::clear()
{
	scriptId = 0;
	numGames = 0;
	tournRegInfoFlags = 0;
}

bool SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::equals(const Protocol_MSG_LOBBY_TOURN_REG_INFO& _o) const
{
	return scriptId == _o.scriptId &&
		numGames == _o.numGames &&
		tournRegInfoFlags == _o.tournRegInfoFlags;
}

bool SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_TOURN_REG_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_TOURN_REG_INFO*)_other));
}

const char *SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_TOURN_REG_INFO).append(")");
	_buf.append(',');
	_buf.append("scriptId=");
	_buf.appendUint(scriptId);
	_buf.append(',');
	_buf.append("numGames=");
	_buf.appendUint(numGames);
	_buf.append(',');
	_buf.append("tournRegInfoFlags=");
	_buf.appendUint(tournRegInfoFlags);
	return _buf.c_str();
}

const char *SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_TOURN_REG_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("scriptId", scriptId, _buf);
	Atf::XmlElement::encodeAsXmlElement("numGames", numGames, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournRegInfoFlags", tournRegInfoFlags, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("scriptId"))
			{
				scriptId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("numGames"))
			{
				numGames = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournRegInfoFlags"))
			{
				tournRegInfoFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(scriptId);
	_msg.composeBYTE(numGames);
	_msg.composeUINT32(tournRegInfoFlags);
}

void SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(scriptId);
	_parser.parseBYTE(numGames);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(tournRegInfoFlags);
}

const char *SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("scriptId", scriptId);
	_jsonstr.compose("numGames", numGames);
	_jsonstr.compose("tournRegInfoFlags", tournRegInfoFlags);
	return _buf.c_str();
}

void SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("scriptId", scriptId);
	_jparser.parseByNameThrow("numGames", numGames);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tournRegInfoFlags", tournRegInfoFlags);
}

/*static*/ void SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TOURN_REG_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 scriptId; _jparser.validateByNameThrow("scriptId", scriptId);
	AtfValidator::validateInt(_descr, "scriptId", scriptId, _checker, __FILE__, __LINE__);
	BYTE numGames; _jparser.validateByNameThrow("numGames", numGames);
	AtfValidator::validateIntRange(_descr, "numGames", numGames, 1, ATF_SNG_MAX_REG_GAMES, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 tournRegInfoFlags; _jparser.validateByNameThrow("tournRegInfoFlags", tournRegInfoFlags);
	AtfValidator::validateInt(_descr, "tournRegInfoFlags", tournRegInfoFlags, _checker, __FILE__, __LINE__);
}

/*static*/ void SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TOURN_REG_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 scriptId; _parser.parseUINT32(scriptId);
	AtfValidator::validateInt(_descr, "scriptId", scriptId, _checker, __FILE__, __LINE__);
	BYTE numGames; _parser.parseBYTE(numGames);
	AtfValidator::validateIntRange(_descr, "numGames", numGames, 1, ATF_SNG_MAX_REG_GAMES, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 tournRegInfoFlags; _parser.parseUINT32(tournRegInfoFlags);
	AtfValidator::validateInt(_descr, "tournRegInfoFlags", tournRegInfoFlags, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_SNG_POOL_CHECKIN
//=================================================================

SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN::Protocol_MSG_SNG_POOL_CHECKIN()
{
	clear();
}

void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN::clear()
{
	userId.clear();
	buyInRM = 0;
	buyInPlay = 0;
	buyInFpp = 0;
	tournPwd.clear();
	useTicket = 0;
	buyInT = 0;
	buyInW = 0;
	currencyContext.clear();
	scriptId = 0;
	numGames = 0;
	admissionPrice = 0;
	admissions.clear();
}

bool SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN::equals(const Protocol_MSG_SNG_POOL_CHECKIN& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		buyInRM == _o.buyInRM &&
		buyInPlay == _o.buyInPlay &&
		buyInFpp == _o.buyInFpp &&
		Atf::atfPStringEquals(tournPwd, _o.tournPwd) &&
		useTicket == _o.useTicket &&
		buyInT == _o.buyInT &&
		buyInW == _o.buyInW &&
		currencyContext.equals(_o.currencyContext) &&
		scriptId == _o.scriptId &&
		numGames == _o.numGames &&
		admissionPrice == _o.admissionPrice &&
		admissions.equals(_o.admissions);
}

bool SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_SNG_POOL_CHECKIN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_SNG_POOL_CHECKIN*)_other));
}

const char *SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_SNG_POOL_CHECKIN).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("buyInRM=");
	_buf.appendInt(buyInRM);
	_buf.append(',');
	_buf.append("buyInPlay=");
	_buf.appendInt(buyInPlay);
	_buf.append(',');
	_buf.append("buyInFpp=");
	_buf.appendInt(buyInFpp);
	_buf.append(',');
	_buf.append("tournPwd=");
	_buf.append(tournPwd);
	_buf.append(',');
	_buf.append("useTicket=");
	_buf.appendUint(useTicket);
	_buf.append(',');
	_buf.append("buyInT=");
	_buf.appendInt(buyInT);
	_buf.append(',');
	_buf.append("buyInW=");
	_buf.appendInt(buyInW);
	_buf.append(',');
	_buf.append("currencyContext=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(currencyContext, _buf); _buf.append('}');
	_buf.append(',');
	_buf.append("scriptId=");
	_buf.appendUint(scriptId);
	_buf.append(',');
	_buf.append("numGames=");
	_buf.appendUint(numGames);
	_buf.append(',');
	_buf.append("admissionPrice=");
	_buf.appendInt64(admissionPrice);
	_buf.append(',');
	_buf.append("admissions=");
	admissions.toTraceString(_buf);
	return _buf.c_str();
}

const char *SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_SNG_POOL_CHECKIN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyInRM", buyInRM, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyInPlay", buyInPlay, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyInFpp", buyInFpp, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournPwd", tournPwd, _buf);
	Atf::XmlElement::encodeAsXmlElement("useTicket", useTicket, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyInT", buyInT, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyInW", buyInW, _buf);
	Atf::XmlElement::encodeAsXmlElement("currencyContext", currencyContext, _buf);
	Atf::XmlElement::encodeAsXmlElement("scriptId", scriptId, _buf);
	Atf::XmlElement::encodeAsXmlElement("numGames", numGames, _buf);
	Atf::XmlElement::encodeAsXmlElement("admissionPrice", admissionPrice, _buf);
	admissions.toXmlString("admissions", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("buyInRM"))
			{
				buyInRM = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("buyInPlay"))
			{
				buyInPlay = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("buyInFpp"))
			{
				buyInFpp = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournPwd"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tournPwd)) return false;
			}
			else if (_element.equals("useTicket"))
			{
				useTicket = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("buyInT"))
			{
				buyInT = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("buyInW"))
			{
				buyInW = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currencyContext"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, currencyContext)) return false;
			}
			else if (_element.equals("scriptId"))
			{
				scriptId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("numGames"))
			{
				numGames = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("admissionPrice"))
			{
				admissionPrice = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("admissions"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< Common::AtfShared::UserTicketDataBase, 4 > >::FromXmlString(_value, admissions)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeINT32(buyInRM);
	_msg.composeINT32(buyInPlay);
	_msg.composeINT32(buyInFpp);
	_msg.composeString(tournPwd);
	_msg.composeBYTE(useTicket);
	_msg.composeINT32(buyInT);
	_msg.composeINT32(buyInW);
	_msg.composeMsgBody(currencyContext);
	_msg.composeUINT32(scriptId);
	_msg.composeBYTE(numGames);
	_msg.composeINT64(admissionPrice);
	admissions.composeMsg(_msg, _ignoreJSON);
}

void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseINT32(buyInRM);
	_parser.parseINT32(buyInPlay);
	_parser.parseINT32(buyInFpp);
	_parser.parseStringP(tournPwd);
	_parser.parseBYTE(useTicket);
	_parser.parseINT32(buyInT);
	_parser.parseINT32(buyInW);
	_parser.parseMsgBody(currencyContext);
	_parser.parseUINT32(scriptId);
	_parser.parseBYTE(numGames);
	_parser.parseINT64(admissionPrice);
	admissions.parseMsg(_parser);
}

const char *SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("buyInRM", buyInRM);
	_jsonstr.compose("buyInPlay", buyInPlay);
	_jsonstr.compose("buyInFpp", buyInFpp);
	_jsonstr.compose("tournPwd", tournPwd);
	_jsonstr.compose("useTicket", useTicket);
	_jsonstr.compose("buyInT", buyInT);
	_jsonstr.compose("buyInW", buyInW);
	_jsonstr.compose("currencyContext", currencyContext);
	_jsonstr.compose("scriptId", scriptId);
	_jsonstr.compose("numGames", numGames);
	_jsonstr.compose("admissionPrice", admissionPrice);
	_jsonstr.compose("admissions", admissions);
	return _buf.c_str();
}

void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("buyInRM", buyInRM);
	_jparser.parseByNameThrow("buyInPlay", buyInPlay);
	_jparser.parseByNameThrow("buyInFpp", buyInFpp);
	_jparser.parseByNameThrow("tournPwd", tournPwd);
	_jparser.parseByNameThrow("useTicket", useTicket);
	_jparser.parseByNameThrow("buyInT", buyInT);
	_jparser.parseByNameThrow("buyInW", buyInW);
	_jparser.parseByNameThrow("currencyContext", currencyContext);
	_jparser.parseByNameThrow("scriptId", scriptId);
	_jparser.parseByNameThrow("numGames", numGames);
	_jparser.parseByNameThrow("admissionPrice", admissionPrice);
	_jparser.parseByNameThrow("admissions", admissions);
}

/*static*/ void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_SNG_POOL_CHECKIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), ATF_USER_NAME_MAX_LENGTH, _checker, __FILE__, __LINE__);
	INT32 buyInRM; _jparser.validateByNameThrow("buyInRM", buyInRM);
	AtfValidator::validateIntRange(_descr, "buyInRM", buyInRM, 0, ATF_SNG_MAX_BUYIN_REAL, _checker, __FILE__, __LINE__);
	INT32 buyInPlay; _jparser.validateByNameThrow("buyInPlay", buyInPlay);
	AtfValidator::validateIntRange(_descr, "buyInPlay", buyInPlay, 0, ATF_SNG_MAX_BUYIN_PM, _checker, __FILE__, __LINE__);
	INT32 buyInFpp; _jparser.validateByNameThrow("buyInFpp", buyInFpp);
	AtfValidator::validateIntRange(_descr, "buyInFpp", buyInFpp, 0, ATF_SNG_MAX_BUYIN_FPP, _checker, __FILE__, __LINE__);
	PString tournPwd; _jparser.validateByNameThrow("tournPwd", tournPwd);
	AtfValidator::validateIntMax(_descr, "tournPwd", tournPwd.length(), ATF_SNG_MAX_PASSWORD_LEN, _checker, __FILE__, __LINE__);
	BYTE useTicket; _jparser.validateByNameThrow("useTicket", useTicket);
	AtfValidator::validateIntRange(_descr, "useTicket", useTicket, 0, 1, _checker, __FILE__, __LINE__);
	INT32 buyInT; _jparser.validateByNameThrow("buyInT", buyInT);
	AtfValidator::validateIntRange(_descr, "buyInT", buyInT, 0, ATF_SNG_MAX_BUYIN_REAL, _checker, __FILE__, __LINE__);
	INT32 buyInW; _jparser.validateByNameThrow("buyInW", buyInW);
	AtfValidator::validateIntRange(_descr, "buyInW", buyInW, 0, 0, _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody currencyContext; _jparser.validateByNameThrow("currencyContext", currencyContext);
	AtfValidator::validateIntMax(_descr, "currencyContext", currencyContext._size(), 10000, _checker, __FILE__, __LINE__);
	UINT32 scriptId; _jparser.validateByNameThrow("scriptId", scriptId);
	AtfValidator::validateInt(_descr, "scriptId", scriptId, _checker, __FILE__, __LINE__);
	BYTE numGames; _jparser.validateByNameThrow("numGames", numGames);
	AtfValidator::validateIntRange(_descr, "numGames", numGames, 1, ATF_SNG_MAX_REG_GAMES, _checker, __FILE__, __LINE__);
	INT64 admissionPrice; _jparser.validateByNameThrow("admissionPrice", admissionPrice);
	AtfValidator::validateIntRange(_descr, "admissionPrice", admissionPrice, 0, ATF_SNG_MAX_ADMISSION_PRICE, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< Common::AtfShared::UserTicketDataBase > admissions; _jparser.validateByNameThrow("admissions", admissions);
	AtfValidator::validateIntMax(_descr, "admissions", admissions.size(), ATF_SNG_MAX_ADMISSIONS, _checker, __FILE__, __LINE__);
}

/*static*/ void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_SNG_POOL_CHECKIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, ATF_USER_NAME_MAX_LENGTH, _checker, __FILE__, __LINE__);
	INT32 buyInRM; _parser.parseINT32(buyInRM);
	AtfValidator::validateIntRange(_descr, "buyInRM", buyInRM, 0, ATF_SNG_MAX_BUYIN_REAL, _checker, __FILE__, __LINE__);
	INT32 buyInPlay; _parser.parseINT32(buyInPlay);
	AtfValidator::validateIntRange(_descr, "buyInPlay", buyInPlay, 0, ATF_SNG_MAX_BUYIN_PM, _checker, __FILE__, __LINE__);
	INT32 buyInFpp; _parser.parseINT32(buyInFpp);
	AtfValidator::validateIntRange(_descr, "buyInFpp", buyInFpp, 0, ATF_SNG_MAX_BUYIN_FPP, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "tournPwd"); size_t szTournPwd = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "tournPwd", szTournPwd, ATF_SNG_MAX_PASSWORD_LEN, _checker, __FILE__, __LINE__);
	BYTE useTicket; _parser.parseBYTE(useTicket);
	AtfValidator::validateIntRange(_descr, "useTicket", useTicket, 0, 1, _checker, __FILE__, __LINE__);
	INT32 buyInT; _parser.parseINT32(buyInT);
	AtfValidator::validateIntRange(_descr, "buyInT", buyInT, 0, ATF_SNG_MAX_BUYIN_REAL, _checker, __FILE__, __LINE__);
	INT32 buyInW; _parser.parseINT32(buyInW);
	AtfValidator::validateIntRange(_descr, "buyInW", buyInW, 0, 0, _checker, __FILE__, __LINE__);
	size_t szCurrencyContext; _parser.skipMsgBody(szCurrencyContext);  /*currencyContext*/
	AtfValidator::validateIntMax(_descr, "currencyContext", szCurrencyContext, 10000, _checker, __FILE__, __LINE__);
	UINT32 scriptId; _parser.parseUINT32(scriptId);
	AtfValidator::validateInt(_descr, "scriptId", scriptId, _checker, __FILE__, __LINE__);
	BYTE numGames; _parser.parseBYTE(numGames);
	AtfValidator::validateIntRange(_descr, "numGames", numGames, 1, ATF_SNG_MAX_REG_GAMES, _checker, __FILE__, __LINE__);
	INT64 admissionPrice; _parser.parseINT64(admissionPrice);
	AtfValidator::validateIntRange(_descr, "admissionPrice", admissionPrice, 0, ATF_SNG_MAX_ADMISSION_PRICE, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szAdmissions = Atf::LAtfVector< Common::AtfShared::UserTicketDataBase, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("admissions"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "admissions", szAdmissions, ATF_SNG_MAX_ADMISSIONS, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_SNG_POOL_CHECKOUT
//=================================================================

SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT::Protocol_MSG_SNG_POOL_CHECKOUT()
{
	clear();
}

void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT::clear()
{
	scriptId = 0;
}

bool SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT::equals(const Protocol_MSG_SNG_POOL_CHECKOUT& _o) const
{
	return scriptId == _o.scriptId;
}

bool SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_SNG_POOL_CHECKOUT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_SNG_POOL_CHECKOUT*)_other));
}

const char *SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_SNG_POOL_CHECKOUT).append(")");
	_buf.append(',');
	_buf.append("scriptId=");
	_buf.appendUint(scriptId);
	return _buf.c_str();
}

const char *SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_SNG_POOL_CHECKOUT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("scriptId", scriptId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("scriptId"))
			{
				scriptId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(scriptId);
}

void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(scriptId);
}

const char *SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("scriptId", scriptId);
	return _buf.c_str();
}

void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("scriptId", scriptId);
}

/*static*/ void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_SNG_POOL_CHECKOUT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 scriptId; _jparser.validateByNameThrow("scriptId", scriptId);
	AtfValidator::validateInt(_descr, "scriptId", scriptId, _checker, __FILE__, __LINE__);
}

/*static*/ void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_SNG_POOL_CHECKOUT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 scriptId; _parser.parseUINT32(scriptId);
	AtfValidator::validateInt(_descr, "scriptId", scriptId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER
//=================================================================

SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER()
{
	clear();
}

void SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER::clear()
{
	userId.clear();
}

bool SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER::equals(const Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId);
}

bool SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_SNG_POOL_WHERE_IS_PLAYER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER*)_other));
}

const char *SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_SNG_POOL_WHERE_IS_PLAYER).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	return _buf.c_str();
}

const char *SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_SNG_POOL_WHERE_IS_PLAYER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
}

void SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
}

const char *SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	return _buf.c_str();
}

void SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
}

/*static*/ void SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_SNG_POOL_WHERE_IS_PLAYER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), 100, _checker, __FILE__, __LINE__);
}

/*static*/ void SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_SNG_POOL_WHERE_IS_PLAYER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, 100, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    UserTicketDataATF
//=================================================================

SngStarter::cli::UserTicketDataATF::UserTicketDataATF()
{
	clear();
}

void SngStarter::cli::UserTicketDataATF::clear()
{
	admissionId.clear();
	totalCount = 0;
	reserved = 0;
}

bool SngStarter::cli::UserTicketDataATF::equals(const UserTicketDataATF& _o) const
{
	return Atf::atfPStringEquals(admissionId, _o.admissionId) &&
		totalCount == _o.totalCount &&
		reserved == _o.reserved;
}

const char *SngStarter::cli::UserTicketDataATF::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("admissionId=");
	_buf.append(admissionId);
	_buf.append(',');
	_buf.append("totalCount=");
	_buf.appendUint(totalCount);
	_buf.append(',');
	_buf.append("reserved=");
	_buf.appendUint(reserved);
	_buf.append('}');
	return _buf.c_str();
}

const char *SngStarter::cli::UserTicketDataATF::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("admissionId", admissionId, _buf);
	Atf::XmlElement::encodeAsXmlElement("totalCount", totalCount, _buf);
	Atf::XmlElement::encodeAsXmlElement("reserved", reserved, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool SngStarter::cli::UserTicketDataATF::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("admissionId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, admissionId)) return false;
		}
		else if (_element.equals("totalCount"))
		{
			totalCount = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("reserved"))
		{
			reserved = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void SngStarter::cli::UserTicketDataATF::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(admissionId);
	_msg.composeUINT32(totalCount);
	_msg.composeUINT32(reserved);
}

void SngStarter::cli::UserTicketDataATF::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(admissionId);
	_parser.parseUINT32(totalCount);
	_parser.parseUINT32(reserved);
}

const char *SngStarter::cli::UserTicketDataATF::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("admissionId", admissionId);
	_jsonstr.compose("totalCount", totalCount);
	_jsonstr.compose("reserved", reserved);
	return _buf.c_str();
}

void SngStarter::cli::UserTicketDataATF::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("admissionId", admissionId);
	_jparser.parseByNameThrow("totalCount", totalCount);
	_jparser.parseByNameThrow("reserved", reserved);
}

/* static */ void SngStarter::cli::UserTicketDataATF::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString admissionId; _jparser.validateByNameThrow("admissionId", admissionId);
	AtfValidator::validateInt(_descr, "admissionId", admissionId.length(), _checker, __FILE__, __LINE__);
	UINT32 totalCount; _jparser.validateByNameThrow("totalCount", totalCount);
	AtfValidator::validateInt(_descr, "totalCount", totalCount, _checker, __FILE__, __LINE__);
	UINT32 reserved; _jparser.validateByNameThrow("reserved", reserved);
	AtfValidator::validateInt(_descr, "reserved", reserved, _checker, __FILE__, __LINE__);
}

/*static*/ void SngStarter::cli::UserTicketDataATF::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "admissionId"); size_t szAdmissionId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "admissionId", szAdmissionId, _checker, __FILE__, __LINE__);
	UINT32 totalCount; _parser.parseUINT32(totalCount);
	AtfValidator::validateInt(_descr, "totalCount", totalCount, _checker, __FILE__, __LINE__);
	UINT32 reserved; _parser.parseUINT32(reserved);
	AtfValidator::validateInt(_descr, "reserved", reserved, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY
//=================================================================

SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY()
{
	clear();
}

void SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::clear()
{
	errCode = 0;
	errMsg.clear();
	buyin = 0;
	rake = 0;
	fppBuyin = 0;
	admission.clear();
	pm = 0;
	pwd = 0;
	chips = 0;
	playChips32 = 0;
	fpp = 0;
	tickets = 0;
	tchips = 0;
	notused = 0;
	preRegistrMessage.clear();
	game = 0;
	isHiLo = 0;
	structure = 0;
	currency.clear();
	enoughMoneyInOtherCurrency = false;
	currencyContext.clear();
	clientCurrencyContext.clear();
	whenStartAbs.setNull();
	name.clear();
	playChips = 0;
	scalePM = 0;
	speedDisplay = 0;
	minPlayers = 0;
	maxPlayers = 0;
	maxPerTable = 0;
	tournFlags = 0;
	knockout = 0;
	boolValue = false;
	admissionPrice = 0;
	effectiveAdmissions.clear();
	tournFlags2 = 0;
}

bool SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::equals(const Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errMsg, _o.errMsg) &&
		buyin == _o.buyin &&
		rake == _o.rake &&
		fppBuyin == _o.fppBuyin &&
		Atf::atfPStringEquals(admission, _o.admission) &&
		pm == _o.pm &&
		pwd == _o.pwd &&
		chips == _o.chips &&
		playChips32 == _o.playChips32 &&
		fpp == _o.fpp &&
		tickets == _o.tickets &&
		tchips == _o.tchips &&
		notused == _o.notused &&
		Atf::atfPStringEquals(preRegistrMessage, _o.preRegistrMessage) &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		structure == _o.structure &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		enoughMoneyInOtherCurrency == _o.enoughMoneyInOtherCurrency &&
		currencyContext.equals(_o.currencyContext) &&
		clientCurrencyContext.equals(_o.clientCurrencyContext) &&
		whenStartAbs.equals(_o.whenStartAbs) &&
		Atf::atfPStringEquals(name, _o.name) &&
		playChips == _o.playChips &&
		scalePM == _o.scalePM &&
		speedDisplay == _o.speedDisplay &&
		minPlayers == _o.minPlayers &&
		maxPlayers == _o.maxPlayers &&
		maxPerTable == _o.maxPerTable &&
		tournFlags == _o.tournFlags &&
		knockout == _o.knockout &&
		boolValue == _o.boolValue &&
		admissionPrice == _o.admissionPrice &&
		effectiveAdmissions.equals(_o.effectiveAdmissions) &&
		tournFlags2 == _o.tournFlags2;
}

bool SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_TOURN_REG_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY*)_other));
}

const char *SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_TOURN_REG_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != DBM_NO_ERROR )
	{
		_buf.append(',');
		_buf.append("errMsg=");
		_buf.append(errMsg);
	}
	else
	{
		_buf.append(',');
		_buf.append("buyin=");
		_buf.appendUint(buyin);
		_buf.append(',');
		_buf.append("rake=");
		_buf.appendUint(rake);
		_buf.append(',');
		_buf.append("fppBuyin=");
		_buf.appendUint(fppBuyin);
		_buf.append(',');
		_buf.append("admission=");
		_buf.append(admission);
		_buf.append(',');
		_buf.append("pm=");
		_buf.appendUint(pm);
		_buf.append(',');
		_buf.append("pwd=");
		_buf.appendUint(pwd);
		_buf.append(',');
		_buf.append("chips=");
		_buf.appendUint(chips);
		_buf.append(',');
		_buf.append("playChips32=");
		_buf.appendUint(playChips32);
		_buf.append(',');
		_buf.append("fpp=");
		_buf.appendUint(fpp);
		_buf.append(',');
		_buf.append("tickets=");
		_buf.appendUint(tickets);
		_buf.append(',');
		_buf.append("tchips=");
		_buf.appendUint(tchips);
		_buf.append(',');
		_buf.append("notused=");
		_buf.appendUint(notused);
		_buf.append(',');
		_buf.append("preRegistrMessage=");
		_buf.append(preRegistrMessage);
		_buf.append(',');
		_buf.append("game=");
		_buf.appendUint(game);
		_buf.append(',');
		_buf.append("isHiLo=");
		_buf.appendUint(isHiLo);
		_buf.append(',');
		_buf.append("structure=");
		_buf.appendUint(structure);
		_buf.append(',');
		_buf.append("currency=");
		_buf.append(currency);
		_buf.append(',');
		_buf.append("enoughMoneyInOtherCurrency=");
		_buf.appendUint(enoughMoneyInOtherCurrency);
		_buf.append(',');
		_buf.append("currencyContext=");
		_buf.append('{'); Atf::XmlElement::encodeMsgBody(currencyContext, _buf); _buf.append('}');
		_buf.append(',');
		_buf.append("clientCurrencyContext=");
		_buf.append('{'); Atf::XmlElement::encodeMsgBody(clientCurrencyContext, _buf); _buf.append('}');
		_buf.append(',');
		_buf.append("whenStartAbs=");
		Atf::AtfTempl<SrvTime>::ToTraceString(_buf, whenStartAbs);
		_buf.append(',');
		_buf.append("name=");
		_buf.append(name);
		_buf.append(',');
		_buf.append("playChips=");
		_buf.appendUint64(playChips);
		_buf.append(',');
		_buf.append("scalePM=");
		_buf.appendUint(scalePM);
		_buf.append(',');
		_buf.append("speedDisplay=");
		_buf.appendUint(speedDisplay);
		_buf.append(',');
		_buf.append("minPlayers=");
		_buf.appendUint(minPlayers);
		_buf.append(',');
		_buf.append("maxPlayers=");
		_buf.appendUint(maxPlayers);
		_buf.append(',');
		_buf.append("maxPerTable=");
		_buf.appendUint(maxPerTable);
		_buf.append(',');
		_buf.append("tournFlags=");
		_buf.appendUint(tournFlags);
		_buf.append(',');
		_buf.append("knockout=");
		_buf.appendUint(knockout);
		_buf.append(',');
		_buf.append("boolValue=");
		_buf.appendUint(boolValue);
		_buf.append(',');
		_buf.append("admissionPrice=");
		_buf.appendInt64(admissionPrice);
		_buf.append(',');
		_buf.append("effectiveAdmissions=");
		effectiveAdmissions.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tournFlags2=");
		_buf.appendUint64(tournFlags2);
	}
	return _buf.c_str();
}

const char *SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_TOURN_REG_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode != DBM_NO_ERROR )
	{
		Atf::XmlElement::encodeAsXmlElement("errMsg", errMsg, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("buyin", buyin, _buf);
		Atf::XmlElement::encodeAsXmlElement("rake", rake, _buf);
		Atf::XmlElement::encodeAsXmlElement("fppBuyin", fppBuyin, _buf);
		Atf::XmlElement::encodeAsXmlElement("admission", admission, _buf);
		Atf::XmlElement::encodeAsXmlElement("pm", pm, _buf);
		Atf::XmlElement::encodeAsXmlElement("pwd", pwd, _buf);
		Atf::XmlElement::encodeAsXmlElement("chips", chips, _buf);
		Atf::XmlElement::encodeAsXmlElement("playChips32", playChips32, _buf);
		Atf::XmlElement::encodeAsXmlElement("fpp", fpp, _buf);
		Atf::XmlElement::encodeAsXmlElement("tickets", tickets, _buf);
		Atf::XmlElement::encodeAsXmlElement("tchips", tchips, _buf);
		Atf::XmlElement::encodeAsXmlElement("notused", notused, _buf);
		Atf::XmlElement::encodeAsXmlElement("preRegistrMessage", preRegistrMessage, _buf);
		Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
		Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
		Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
		Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
		Atf::XmlElement::encodeAsXmlElement("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _buf);
		Atf::XmlElement::encodeAsXmlElement("currencyContext", currencyContext, _buf);
		Atf::XmlElement::encodeAsXmlElement("clientCurrencyContext", clientCurrencyContext, _buf);
		Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "whenStartAbs", whenStartAbs);
		Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
		Atf::XmlElement::encodeAsXmlElement("playChips", playChips, _buf);
		Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
		Atf::XmlElement::encodeAsXmlElement("speedDisplay", speedDisplay, _buf);
		Atf::XmlElement::encodeAsXmlElement("minPlayers", minPlayers, _buf);
		Atf::XmlElement::encodeAsXmlElement("maxPlayers", maxPlayers, _buf);
		Atf::XmlElement::encodeAsXmlElement("maxPerTable", maxPerTable, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournFlags", tournFlags, _buf);
		Atf::XmlElement::encodeAsXmlElement("knockout", knockout, _buf);
		Atf::XmlElement::encodeAsXmlElement("boolValue", boolValue, _buf);
		Atf::XmlElement::encodeAsXmlElement("admissionPrice", admissionPrice, _buf);
		effectiveAdmissions.toXmlString("effectiveAdmissions", _buf);
		Atf::XmlElement::encodeAsXmlElement("tournFlags2", tournFlags2, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errMsg"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errMsg)) return false;
			}
			else if (_element.equals("buyin"))
			{
				buyin = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("rake"))
			{
				rake = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("fppBuyin"))
			{
				fppBuyin = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("admission"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, admission)) return false;
			}
			else if (_element.equals("pm"))
			{
				pm = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("pwd"))
			{
				pwd = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("chips"))
			{
				chips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("playChips32"))
			{
				playChips32 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("fpp"))
			{
				fpp = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tickets"))
			{
				tickets = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tchips"))
			{
				tchips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("notused"))
			{
				notused = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("preRegistrMessage"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, preRegistrMessage)) return false;
			}
			else if (_element.equals("game"))
			{
				game = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isHiLo"))
			{
				isHiLo = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("structure"))
			{
				structure = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else if (_element.equals("enoughMoneyInOtherCurrency"))
			{
				enoughMoneyInOtherCurrency = (*_value.ptr() == '1');
			}
			else if (_element.equals("currencyContext"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, currencyContext)) return false;
			}
			else if (_element.equals("clientCurrencyContext"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, clientCurrencyContext)) return false;
			}
			else if (_element.equals("whenStartAbs"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, whenStartAbs);
			}
			else if (_element.equals("name"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
			}
			else if (_element.equals("playChips"))
			{
				playChips = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("scalePM"))
			{
				scalePM = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("speedDisplay"))
			{
				speedDisplay = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minPlayers"))
			{
				minPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxPlayers"))
			{
				maxPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxPerTable"))
			{
				maxPerTable = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournFlags"))
			{
				tournFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("knockout"))
			{
				knockout = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("boolValue"))
			{
				boolValue = (*_value.ptr() == '1');
			}
			else if (_element.equals("admissionPrice"))
			{
				admissionPrice = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("effectiveAdmissions"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UserTicketDataATF, 4 > >::FromXmlString(_value, effectiveAdmissions)) return false;
			}
			else if (_element.equals("tournFlags2"))
			{
				tournFlags2 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode != DBM_NO_ERROR )
	{
		_msg.composeString(errMsg);
	}
	else
	{
		_msg.composeUINT32(buyin);
		_msg.composeUINT32(rake);
		_msg.composeUINT32(fppBuyin);
		_msg.composeString(admission);
		_msg.composeBYTE(pm);
		_msg.composeBYTE(pwd);
		_msg.composeUINT32(chips);
		_msg.composeUINT32(playChips32);
		_msg.composeUINT32(fpp);
		_msg.composeUINT32(tickets);
		_msg.composeUINT32(tchips);
		_msg.composeUINT32(notused);
		_msg.composeString(preRegistrMessage);
		_msg.composeBYTE(game);
		_msg.composeBYTE(isHiLo);
		_msg.composeBYTE(structure);
		_msg.composeString(currency);
		_msg.composeBOOL(enoughMoneyInOtherCurrency);
		_msg.composeMsgBody(currencyContext);
		_msg.composeMsgBody(clientCurrencyContext);
		_msg.composeSrvTime(whenStartAbs);
		_msg.composeString(name);
		_msg.composeUINT64(playChips);
		_msg.composeUINT32(scalePM);
		_msg.composeBYTE(speedDisplay);
		_msg.composeUINT32(minPlayers);
		_msg.composeUINT32(maxPlayers);
		_msg.composeBYTE(maxPerTable);
		_msg.composeUINT32(tournFlags);
		_msg.composeUINT32(knockout);
		_msg.composeBOOL(boolValue);
		_msg.composeINT64(admissionPrice);
		effectiveAdmissions.composeMsg(_msg, _ignoreJSON);
		_msg.composeUINT64(tournFlags2);
	}
}

void SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != DBM_NO_ERROR )
	{
		_parser.parseStringP(errMsg);
	}
	else
	{
		_parser.parseUINT32(buyin);
		_parser.parseUINT32(rake);
		_parser.parseUINT32(fppBuyin);
		_parser.parseStringP(admission);
		_parser.parseBYTE(pm);
		_parser.parseBYTE(pwd);
		_parser.parseUINT32(chips);
		_parser.parseUINT32(playChips32);
		_parser.parseUINT32(fpp);
		_parser.parseUINT32(tickets);
		_parser.parseUINT32(tchips);
		_parser.parseUINT32(notused);
		_parser.parseStringP(preRegistrMessage);
		_parser.parseBYTE(game);
		_parser.parseBYTE(isHiLo);
		_parser.parseBYTE(structure);
		_parser.parseStringP(currency);
		_parser.parseBOOL(enoughMoneyInOtherCurrency);
		_parser.parseMsgBody(currencyContext);
		_parser.parseMsgBody(clientCurrencyContext);
		_parser.parseSrvTime(whenStartAbs);
		_parser.parseStringP(name);
		_parser.parseUINT64(playChips);
		_parser.parseUINT32(scalePM);
		_parser.parseBYTE(speedDisplay);
		_parser.parseUINT32(minPlayers);
		_parser.parseUINT32(maxPlayers);
		_parser.parseBYTE(maxPerTable);
		_parser.parseUINT32(tournFlags);
		_parser.parseUINT32(knockout);
		_parser.parseBOOL(boolValue);
		_parser.parseINT64(admissionPrice);
		effectiveAdmissions.parseMsg(_parser);
		_parser.parseUINT64(tournFlags2);
	}
}

const char *SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode != DBM_NO_ERROR )
	{
		_jsonstr.compose("errMsg", errMsg);
	}
	else
	{
		_jsonstr.compose("buyin", buyin);
		_jsonstr.compose("rake", rake);
		_jsonstr.compose("fppBuyin", fppBuyin);
		_jsonstr.compose("admission", admission);
		_jsonstr.compose("pm", pm);
		_jsonstr.compose("pwd", pwd);
		_jsonstr.compose("chips", chips);
		_jsonstr.compose("playChips32", playChips32);
		_jsonstr.compose("fpp", fpp);
		_jsonstr.compose("tickets", tickets);
		_jsonstr.compose("tchips", tchips);
		_jsonstr.compose("notused", notused);
		_jsonstr.compose("preRegistrMessage", preRegistrMessage);
		_jsonstr.compose("game", game);
		_jsonstr.compose("isHiLo", isHiLo);
		_jsonstr.compose("structure", structure);
		_jsonstr.compose("currency", currency);
		_jsonstr.compose("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency);
		_jsonstr.compose("currencyContext", currencyContext);
		_jsonstr.compose("clientCurrencyContext", clientCurrencyContext);
		_jsonstr.compose("whenStartAbs", whenStartAbs);
		_jsonstr.compose("name", name);
		_jsonstr.compose("playChips", playChips);
		_jsonstr.compose("scalePM", scalePM);
		_jsonstr.compose("speedDisplay", speedDisplay);
		_jsonstr.compose("minPlayers", minPlayers);
		_jsonstr.compose("maxPlayers", maxPlayers);
		_jsonstr.compose("maxPerTable", maxPerTable);
		_jsonstr.compose("tournFlags", tournFlags);
		_jsonstr.compose("knockout", knockout);
		_jsonstr.compose("boolValue", boolValue);
		_jsonstr.compose("admissionPrice", admissionPrice);
		_jsonstr.compose("effectiveAdmissions", effectiveAdmissions);
		_jsonstr.compose("tournFlags2", tournFlags2);
	}
	return _buf.c_str();
}

void SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode != DBM_NO_ERROR )
	{
		_jparser.parseByNameThrow("errMsg", errMsg);
	}
	else
	{
		_jparser.parseByNameThrow("buyin", buyin);
		_jparser.parseByNameThrow("rake", rake);
		_jparser.parseByNameThrow("fppBuyin", fppBuyin);
		_jparser.parseByNameThrow("admission", admission);
		_jparser.parseByNameThrow("pm", pm);
		_jparser.parseByNameThrow("pwd", pwd);
		_jparser.parseByNameThrow("chips", chips);
		_jparser.parseByNameThrow("playChips32", playChips32);
		_jparser.parseByNameThrow("fpp", fpp);
		_jparser.parseByNameThrow("tickets", tickets);
		_jparser.parseByNameThrow("tchips", tchips);
		_jparser.parseByNameThrow("notused", notused);
		_jparser.parseByNameThrow("preRegistrMessage", preRegistrMessage);
		_jparser.parseByNameThrow("game", game);
		_jparser.parseByNameThrow("isHiLo", isHiLo);
		_jparser.parseByNameThrow("structure", structure);
		_jparser.parseByNameThrow("currency", currency);
		_jparser.parseByNameThrow("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency);
		_jparser.parseByNameThrow("currencyContext", currencyContext);
		_jparser.parseByNameThrow("clientCurrencyContext", clientCurrencyContext);
		_jparser.parseByNameThrow("whenStartAbs", whenStartAbs);
		_jparser.parseByNameThrow("name", name);
		_jparser.parseByNameThrow("playChips", playChips);
		_jparser.parseByNameThrow("scalePM", scalePM);
		_jparser.parseByNameThrow("speedDisplay", speedDisplay);
		_jparser.parseByNameThrow("minPlayers", minPlayers);
		_jparser.parseByNameThrow("maxPlayers", maxPlayers);
		_jparser.parseByNameThrow("maxPerTable", maxPerTable);
		_jparser.parseByNameThrow("tournFlags", tournFlags);
		_jparser.parseByNameThrow("knockout", knockout);
		_jparser.parseByNameThrow("boolValue", boolValue);
		_jparser.parseByNameThrow("admissionPrice", admissionPrice);
		_jparser.parseByNameThrow("effectiveAdmissions", effectiveAdmissions);
		_jparser.parseByNameThrow("tournFlags2", tournFlags2);
	}
}

/*static*/ void SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TOURN_REG_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != DBM_NO_ERROR )
	{
		PString errMsg; _jparser.validateByNameThrow("errMsg", errMsg);
		AtfValidator::validateInt(_descr, "errMsg", errMsg.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 buyin; _jparser.validateByNameThrow("buyin", buyin);
		AtfValidator::validateInt(_descr, "buyin", buyin, _checker, __FILE__, __LINE__);
		UINT32 rake; _jparser.validateByNameThrow("rake", rake);
		AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
		UINT32 fppBuyin; _jparser.validateByNameThrow("fppBuyin", fppBuyin);
		AtfValidator::validateInt(_descr, "fppBuyin", fppBuyin, _checker, __FILE__, __LINE__);
		PString admission; _jparser.validateByNameThrow("admission", admission);
		AtfValidator::validateInt(_descr, "admission", admission.length(), _checker, __FILE__, __LINE__);
		BYTE pm; _jparser.validateByNameThrow("pm", pm);
		AtfValidator::validateInt(_descr, "pm", pm, _checker, __FILE__, __LINE__);
		BYTE pwd; _jparser.validateByNameThrow("pwd", pwd);
		AtfValidator::validateInt(_descr, "pwd", pwd, _checker, __FILE__, __LINE__);
		UINT32 chips; _jparser.validateByNameThrow("chips", chips);
		AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
		UINT32 playChips32; _jparser.validateByNameThrow("playChips32", playChips32);
		AtfValidator::validateInt(_descr, "playChips32", playChips32, _checker, __FILE__, __LINE__);
		UINT32 fpp; _jparser.validateByNameThrow("fpp", fpp);
		AtfValidator::validateInt(_descr, "fpp", fpp, _checker, __FILE__, __LINE__);
		UINT32 tickets; _jparser.validateByNameThrow("tickets", tickets);
		AtfValidator::validateInt(_descr, "tickets", tickets, _checker, __FILE__, __LINE__);
		UINT32 tchips; _jparser.validateByNameThrow("tchips", tchips);
		AtfValidator::validateInt(_descr, "tchips", tchips, _checker, __FILE__, __LINE__);
		UINT32 notused; _jparser.validateByNameThrow("notused", notused);
		AtfValidator::validateInt(_descr, "notused", notused, _checker, __FILE__, __LINE__);
		PString preRegistrMessage; _jparser.validateByNameThrow("preRegistrMessage", preRegistrMessage);
		AtfValidator::validateInt(_descr, "preRegistrMessage", preRegistrMessage.length(), _checker, __FILE__, __LINE__);
		BYTE game; _jparser.validateByNameThrow("game", game);
		AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
		BYTE isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
		AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
		BYTE structure; _jparser.validateByNameThrow("structure", structure);
		AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
		PString currency; _jparser.validateByNameThrow("currency", currency);
		AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
		bool enoughMoneyInOtherCurrency; _jparser.validateByNameThrow("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency);
		AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _checker, __FILE__, __LINE__);
		Atf::CopyableMsgBody currencyContext; _jparser.validateByNameThrow("currencyContext", currencyContext);
		AtfValidator::validateInt(_descr, "currencyContext", currencyContext._size(), _checker, __FILE__, __LINE__);
		Atf::CopyableMsgBody clientCurrencyContext; _jparser.validateByNameThrow("clientCurrencyContext", clientCurrencyContext);
		AtfValidator::validateInt(_descr, "clientCurrencyContext", clientCurrencyContext._size(), _checker, __FILE__, __LINE__);
		SrvTime whenStartAbs; _jparser.validateByNameThrow("whenStartAbs", whenStartAbs);
		AtfValidator::validateSrvDateTime(_descr, "whenStartAbs", whenStartAbs, _checker, __FILE__, __LINE__);
		PString name; _jparser.validateByNameThrow("name", name);
		AtfValidator::validateInt(_descr, "name", name.length(), _checker, __FILE__, __LINE__);
		UINT64 playChips; _jparser.validateByNameThrow("playChips", playChips);
		AtfValidator::validateUint(_descr, "playChips", playChips, _checker, __FILE__, __LINE__);
		UINT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
		AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
		BYTE speedDisplay; _jparser.validateByNameThrow("speedDisplay", speedDisplay);
		AtfValidator::validateInt(_descr, "speedDisplay", speedDisplay, _checker, __FILE__, __LINE__);
		UINT32 minPlayers; _jparser.validateByNameThrow("minPlayers", minPlayers);
		AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
		UINT32 maxPlayers; _jparser.validateByNameThrow("maxPlayers", maxPlayers);
		AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
		BYTE maxPerTable; _jparser.validateByNameThrow("maxPerTable", maxPerTable);
		AtfValidator::validateInt(_descr, "maxPerTable", maxPerTable, _checker, __FILE__, __LINE__);
		UINT32 tournFlags; _jparser.validateByNameThrow("tournFlags", tournFlags);
		AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
		UINT32 knockout; _jparser.validateByNameThrow("knockout", knockout);
		AtfValidator::validateInt(_descr, "knockout", knockout, _checker, __FILE__, __LINE__);
		bool boolValue; _jparser.validateByNameThrow("boolValue", boolValue);
		AtfValidator::validateInt(_descr, "boolValue", boolValue, _checker, __FILE__, __LINE__);
		INT64 admissionPrice; _jparser.validateByNameThrow("admissionPrice", admissionPrice);
		AtfValidator::validateInt(_descr, "admissionPrice", admissionPrice, _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< UserTicketDataATF > effectiveAdmissions; _jparser.validateByNameThrow("effectiveAdmissions", effectiveAdmissions);
		AtfValidator::validateInt(_descr, "effectiveAdmissions", effectiveAdmissions.size(), _checker, __FILE__, __LINE__);
		UINT64 tournFlags2; _jparser.validateByNameThrow("tournFlags2", tournFlags2);
		AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void SngStarter::cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TOURN_REG_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != DBM_NO_ERROR )
	{
		_parser.parseStringN(_dummy, 0, "errMsg"); size_t szErrMsg = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errMsg", szErrMsg, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 buyin; _parser.parseUINT32(buyin);
		AtfValidator::validateInt(_descr, "buyin", buyin, _checker, __FILE__, __LINE__);
		UINT32 rake; _parser.parseUINT32(rake);
		AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
		UINT32 fppBuyin; _parser.parseUINT32(fppBuyin);
		AtfValidator::validateInt(_descr, "fppBuyin", fppBuyin, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "admission"); size_t szAdmission = strlen(_dummy);
		AtfValidator::validateInt(_descr, "admission", szAdmission, _checker, __FILE__, __LINE__);
		BYTE pm; _parser.parseBYTE(pm);
		AtfValidator::validateInt(_descr, "pm", pm, _checker, __FILE__, __LINE__);
		BYTE pwd; _parser.parseBYTE(pwd);
		AtfValidator::validateInt(_descr, "pwd", pwd, _checker, __FILE__, __LINE__);
		UINT32 chips; _parser.parseUINT32(chips);
		AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
		UINT32 playChips32; _parser.parseUINT32(playChips32);
		AtfValidator::validateInt(_descr, "playChips32", playChips32, _checker, __FILE__, __LINE__);
		UINT32 fpp; _parser.parseUINT32(fpp);
		AtfValidator::validateInt(_descr, "fpp", fpp, _checker, __FILE__, __LINE__);
		UINT32 tickets; _parser.parseUINT32(tickets);
		AtfValidator::validateInt(_descr, "tickets", tickets, _checker, __FILE__, __LINE__);
		UINT32 tchips; _parser.parseUINT32(tchips);
		AtfValidator::validateInt(_descr, "tchips", tchips, _checker, __FILE__, __LINE__);
		UINT32 notused; _parser.parseUINT32(notused);
		AtfValidator::validateInt(_descr, "notused", notused, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "preRegistrMessage"); size_t szPreRegistrMessage = strlen(_dummy);
		AtfValidator::validateInt(_descr, "preRegistrMessage", szPreRegistrMessage, _checker, __FILE__, __LINE__);
		BYTE game; _parser.parseBYTE(game);
		AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
		BYTE isHiLo; _parser.parseBYTE(isHiLo);
		AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
		BYTE structure; _parser.parseBYTE(structure);
		AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
		bool enoughMoneyInOtherCurrency; _parser.parseBOOL(enoughMoneyInOtherCurrency);
		AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _checker, __FILE__, __LINE__);
		size_t szCurrencyContext; _parser.skipMsgBody(szCurrencyContext);  /*currencyContext*/
		AtfValidator::validateInt(_descr, "currencyContext", szCurrencyContext, _checker, __FILE__, __LINE__);
		size_t szClientCurrencyContext; _parser.skipMsgBody(szClientCurrencyContext);  /*clientCurrencyContext*/
		AtfValidator::validateInt(_descr, "clientCurrencyContext", szClientCurrencyContext, _checker, __FILE__, __LINE__);
		SrvTime whenStartAbs; _parser.parseSrvTime(whenStartAbs);
		AtfValidator::validateSrvDateTime(_descr, "whenStartAbs", whenStartAbs, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
		UINT64 playChips; _parser.parseUINT64(playChips);
		AtfValidator::validateUint(_descr, "playChips", playChips, _checker, __FILE__, __LINE__);
		UINT32 scalePM; _parser.parseUINT32(scalePM);
		AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
		BYTE speedDisplay; _parser.parseBYTE(speedDisplay);
		AtfValidator::validateInt(_descr, "speedDisplay", speedDisplay, _checker, __FILE__, __LINE__);
		UINT32 minPlayers; _parser.parseUINT32(minPlayers);
		AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
		UINT32 maxPlayers; _parser.parseUINT32(maxPlayers);
		AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
		BYTE maxPerTable; _parser.parseBYTE(maxPerTable);
		AtfValidator::validateInt(_descr, "maxPerTable", maxPerTable, _checker, __FILE__, __LINE__);
		UINT32 tournFlags; _parser.parseUINT32(tournFlags);
		AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
		UINT32 knockout; _parser.parseUINT32(knockout);
		AtfValidator::validateInt(_descr, "knockout", knockout, _checker, __FILE__, __LINE__);
		bool boolValue; _parser.parseBOOL(boolValue);
		AtfValidator::validateInt(_descr, "boolValue", boolValue, _checker, __FILE__, __LINE__);
		INT64 admissionPrice; _parser.parseINT64(admissionPrice);
		AtfValidator::validateInt(_descr, "admissionPrice", admissionPrice, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szEffectiveAdmissions = Atf::LAtfVector< UserTicketDataATF, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("effectiveAdmissions"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "effectiveAdmissions", szEffectiveAdmissions, _checker, __FILE__, __LINE__);
		UINT64 tournFlags2; _parser.parseUINT64(tournFlags2);
		AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_SNG_POOL_CHECKIN_REPLY
//=================================================================

SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN_REPLY::Protocol_MSG_SNG_POOL_CHECKIN_REPLY()
{
	clear();
}

void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN_REPLY::clear()
{
	scriptId = 0;
	errCode = 0;
	errMsg.clear();
	totalGamesNow = 0;
	tournId = 0;
	sampleAddress.clear();
	buyIn = 0;
	fppBuyIn = 0;
	rake = 0;
	game = 0;
	hiLo = 0;
	structure = 0;
	isPlayMoney = 0;
	icurrency.clear();
	scalePM = 0;
	name.clear();
}

bool SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN_REPLY::equals(const Protocol_MSG_SNG_POOL_CHECKIN_REPLY& _o) const
{
	return scriptId == _o.scriptId &&
		errCode == _o.errCode &&
		Atf::atfPStringEquals(errMsg, _o.errMsg) &&
		totalGamesNow == _o.totalGamesNow &&
		tournId == _o.tournId &&
		Atf::atfPStringEquals(sampleAddress, _o.sampleAddress) &&
		buyIn == _o.buyIn &&
		fppBuyIn == _o.fppBuyIn &&
		rake == _o.rake &&
		game == _o.game &&
		hiLo == _o.hiLo &&
		structure == _o.structure &&
		isPlayMoney == _o.isPlayMoney &&
		Atf::atfPStringEquals(icurrency, _o.icurrency) &&
		scalePM == _o.scalePM &&
		Atf::atfPStringEquals(name, _o.name);
}

bool SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_SNG_POOL_CHECKIN_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_SNG_POOL_CHECKIN_REPLY*)_other));
}

const char *SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_SNG_POOL_CHECKIN_REPLY).append(")");
	_buf.append(',');
	_buf.append("scriptId=");
	_buf.appendUint(scriptId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != DBM_NO_ERROR )
	{
		_buf.append(',');
		_buf.append("errMsg=");
		_buf.append(errMsg);
	}
	else
	{
		_buf.append(',');
		_buf.append("totalGamesNow=");
		_buf.appendUint(totalGamesNow);
		_buf.append(',');
		_buf.append("tournId=");
		_buf.appendUint(tournId);
		_buf.append(',');
		_buf.append("sampleAddress=");
		_buf.append(sampleAddress);
		_buf.append(',');
		_buf.append("buyIn=");
		_buf.appendUint(buyIn);
		_buf.append(',');
		_buf.append("fppBuyIn=");
		_buf.appendUint(fppBuyIn);
		_buf.append(',');
		_buf.append("rake=");
		_buf.appendUint(rake);
		_buf.append(',');
		_buf.append("game=");
		_buf.appendUint(game);
		_buf.append(',');
		_buf.append("hiLo=");
		_buf.appendUint(hiLo);
		_buf.append(',');
		_buf.append("structure=");
		_buf.appendUint(structure);
		_buf.append(',');
		_buf.append("isPlayMoney=");
		_buf.appendUint(isPlayMoney);
		_buf.append(',');
		_buf.append("icurrency=");
		_buf.append(icurrency);
		_buf.append(',');
		_buf.append("scalePM=");
		_buf.appendUint(scalePM);
		_buf.append(',');
		_buf.append("name=");
		_buf.append(name);
	}
	return _buf.c_str();
}

const char *SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_SNG_POOL_CHECKIN_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("scriptId", scriptId, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode != DBM_NO_ERROR )
	{
		Atf::XmlElement::encodeAsXmlElement("errMsg", errMsg, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("totalGamesNow", totalGamesNow, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
		Atf::XmlElement::encodeAsXmlElement("sampleAddress", sampleAddress, _buf);
		Atf::XmlElement::encodeAsXmlElement("buyIn", buyIn, _buf);
		Atf::XmlElement::encodeAsXmlElement("fppBuyIn", fppBuyIn, _buf);
		Atf::XmlElement::encodeAsXmlElement("rake", rake, _buf);
		Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
		Atf::XmlElement::encodeAsXmlElement("hiLo", hiLo, _buf);
		Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
		Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
		Atf::XmlElement::encodeAsXmlElement("icurrency", icurrency, _buf);
		Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
		Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("scriptId"))
			{
				scriptId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errMsg"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errMsg)) return false;
			}
			else if (_element.equals("totalGamesNow"))
			{
				totalGamesNow = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournId"))
			{
				tournId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("sampleAddress"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, sampleAddress)) return false;
			}
			else if (_element.equals("buyIn"))
			{
				buyIn = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("fppBuyIn"))
			{
				fppBuyIn = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("rake"))
			{
				rake = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("game"))
			{
				game = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("hiLo"))
			{
				hiLo = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("structure"))
			{
				structure = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isPlayMoney"))
			{
				isPlayMoney = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("icurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, icurrency)) return false;
			}
			else if (_element.equals("scalePM"))
			{
				scalePM = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("name"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(scriptId);
	_msg.composeINT16(errCode);
	if( errCode != DBM_NO_ERROR )
	{
		_msg.composeString(errMsg);
	}
	else
	{
		_msg.composeBYTE(totalGamesNow);
		_msg.composeUINT32(tournId);
		_msg.composeString(sampleAddress);
		_msg.composeUINT32(buyIn);
		_msg.composeUINT32(fppBuyIn);
		_msg.composeUINT32(rake);
		_msg.composeBYTE(game);
		_msg.composeBYTE(hiLo);
		_msg.composeBYTE(structure);
		_msg.composeBYTE(isPlayMoney);
		_msg.composeString(icurrency);
		_msg.composeUINT32(scalePM);
		_msg.composeString(name);
	}
}

void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(scriptId);
	_parser.parseINT16(errCode);
	if( errCode != DBM_NO_ERROR )
	{
		_parser.parseStringP(errMsg);
	}
	else
	{
		_parser.parseBYTE(totalGamesNow);
		_parser.parseUINT32(tournId);
		_parser.parseStringP(sampleAddress);
		_parser.parseUINT32(buyIn);
		_parser.parseUINT32(fppBuyIn);
		_parser.parseUINT32(rake);
		_parser.parseBYTE(game);
		_parser.parseBYTE(hiLo);
		_parser.parseBYTE(structure);
		_parser.parseBYTE(isPlayMoney);
		_parser.parseStringP(icurrency);
		_parser.parseUINT32(scalePM);
		_parser.parseStringP(name);
	}
}

const char *SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("scriptId", scriptId);
	_jsonstr.compose("errCode", errCode);
	if( errCode != DBM_NO_ERROR )
	{
		_jsonstr.compose("errMsg", errMsg);
	}
	else
	{
		_jsonstr.compose("totalGamesNow", totalGamesNow);
		_jsonstr.compose("tournId", tournId);
		_jsonstr.compose("sampleAddress", sampleAddress);
		_jsonstr.compose("buyIn", buyIn);
		_jsonstr.compose("fppBuyIn", fppBuyIn);
		_jsonstr.compose("rake", rake);
		_jsonstr.compose("game", game);
		_jsonstr.compose("hiLo", hiLo);
		_jsonstr.compose("structure", structure);
		_jsonstr.compose("isPlayMoney", isPlayMoney);
		_jsonstr.compose("icurrency", icurrency);
		_jsonstr.compose("scalePM", scalePM);
		_jsonstr.compose("name", name);
	}
	return _buf.c_str();
}

void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("scriptId", scriptId);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode != DBM_NO_ERROR )
	{
		_jparser.parseByNameThrow("errMsg", errMsg);
	}
	else
	{
		_jparser.parseByNameThrow("totalGamesNow", totalGamesNow);
		_jparser.parseByNameThrow("tournId", tournId);
		_jparser.parseByNameThrow("sampleAddress", sampleAddress);
		_jparser.parseByNameThrow("buyIn", buyIn);
		_jparser.parseByNameThrow("fppBuyIn", fppBuyIn);
		_jparser.parseByNameThrow("rake", rake);
		_jparser.parseByNameThrow("game", game);
		_jparser.parseByNameThrow("hiLo", hiLo);
		_jparser.parseByNameThrow("structure", structure);
		_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
		_jparser.parseByNameThrow("icurrency", icurrency);
		_jparser.parseByNameThrow("scalePM", scalePM);
		_jparser.parseByNameThrow("name", name);
	}
}

/*static*/ void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_SNG_POOL_CHECKIN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	UINT32 scriptId; _jparser.validateByNameThrow("scriptId", scriptId);
	AtfValidator::validateInt(_descr, "scriptId", scriptId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != DBM_NO_ERROR )
	{
		PString errMsg; _jparser.validateByNameThrow("errMsg", errMsg);
		AtfValidator::validateInt(_descr, "errMsg", errMsg.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		BYTE totalGamesNow; _jparser.validateByNameThrow("totalGamesNow", totalGamesNow);
		AtfValidator::validateInt(_descr, "totalGamesNow", totalGamesNow, _checker, __FILE__, __LINE__);
		UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
		AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
		PString sampleAddress; _jparser.validateByNameThrow("sampleAddress", sampleAddress);
		AtfValidator::validateInt(_descr, "sampleAddress", sampleAddress.length(), _checker, __FILE__, __LINE__);
		UINT32 buyIn; _jparser.validateByNameThrow("buyIn", buyIn);
		AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
		UINT32 fppBuyIn; _jparser.validateByNameThrow("fppBuyIn", fppBuyIn);
		AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
		UINT32 rake; _jparser.validateByNameThrow("rake", rake);
		AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
		BYTE game; _jparser.validateByNameThrow("game", game);
		AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
		BYTE hiLo; _jparser.validateByNameThrow("hiLo", hiLo);
		AtfValidator::validateInt(_descr, "hiLo", hiLo, _checker, __FILE__, __LINE__);
		BYTE structure; _jparser.validateByNameThrow("structure", structure);
		AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
		BYTE isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
		AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
		PString icurrency; _jparser.validateByNameThrow("icurrency", icurrency);
		AtfValidator::validateInt(_descr, "icurrency", icurrency.length(), _checker, __FILE__, __LINE__);
		UINT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
		AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
		PString name; _jparser.validateByNameThrow("name", name);
		AtfValidator::validateInt(_descr, "name", name.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKIN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_SNG_POOL_CHECKIN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	UINT32 scriptId; _parser.parseUINT32(scriptId);
	AtfValidator::validateInt(_descr, "scriptId", scriptId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != DBM_NO_ERROR )
	{
		_parser.parseStringN(_dummy, 0, "errMsg"); size_t szErrMsg = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errMsg", szErrMsg, _checker, __FILE__, __LINE__);
	}
	else
	{
		BYTE totalGamesNow; _parser.parseBYTE(totalGamesNow);
		AtfValidator::validateInt(_descr, "totalGamesNow", totalGamesNow, _checker, __FILE__, __LINE__);
		UINT32 tournId; _parser.parseUINT32(tournId);
		AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "sampleAddress"); size_t szSampleAddress = strlen(_dummy);
		AtfValidator::validateInt(_descr, "sampleAddress", szSampleAddress, _checker, __FILE__, __LINE__);
		UINT32 buyIn; _parser.parseUINT32(buyIn);
		AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
		UINT32 fppBuyIn; _parser.parseUINT32(fppBuyIn);
		AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
		UINT32 rake; _parser.parseUINT32(rake);
		AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
		BYTE game; _parser.parseBYTE(game);
		AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
		BYTE hiLo; _parser.parseBYTE(hiLo);
		AtfValidator::validateInt(_descr, "hiLo", hiLo, _checker, __FILE__, __LINE__);
		BYTE structure; _parser.parseBYTE(structure);
		AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
		BYTE isPlayMoney; _parser.parseBYTE(isPlayMoney);
		AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "icurrency"); size_t szIcurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "icurrency", szIcurrency, _checker, __FILE__, __LINE__);
		UINT32 scalePM; _parser.parseUINT32(scalePM);
		AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_SNG_POOL_CHECKOUT_REPLY
//=================================================================

SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT_REPLY::Protocol_MSG_SNG_POOL_CHECKOUT_REPLY()
{
	clear();
}

void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT_REPLY::clear()
{
	scriptId = 0;
	errCode = 0;
	cancelledGames = 0;
}

bool SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT_REPLY::equals(const Protocol_MSG_SNG_POOL_CHECKOUT_REPLY& _o) const
{
	return scriptId == _o.scriptId &&
		errCode == _o.errCode &&
		cancelledGames == _o.cancelledGames;
}

bool SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_SNG_POOL_CHECKOUT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_SNG_POOL_CHECKOUT_REPLY*)_other));
}

const char *SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_SNG_POOL_CHECKOUT_REPLY).append(")");
	_buf.append(',');
	_buf.append("scriptId=");
	_buf.appendUint(scriptId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("cancelledGames=");
	_buf.appendUint(cancelledGames);
	return _buf.c_str();
}

const char *SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_SNG_POOL_CHECKOUT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("scriptId", scriptId, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("cancelledGames", cancelledGames, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("scriptId"))
			{
				scriptId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("cancelledGames"))
			{
				cancelledGames = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(scriptId);
	_msg.composeINT16(errCode);
	_msg.composeBYTE(cancelledGames);
}

void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(scriptId);
	_parser.parseINT16(errCode);
	_parser.parseBYTE(cancelledGames);
}

const char *SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("scriptId", scriptId);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("cancelledGames", cancelledGames);
	return _buf.c_str();
}

void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("scriptId", scriptId);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("cancelledGames", cancelledGames);
}

/*static*/ void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_SNG_POOL_CHECKOUT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 scriptId; _jparser.validateByNameThrow("scriptId", scriptId);
	AtfValidator::validateInt(_descr, "scriptId", scriptId, _checker, __FILE__, __LINE__);
	INT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	BYTE cancelledGames; _jparser.validateByNameThrow("cancelledGames", cancelledGames);
	AtfValidator::validateInt(_descr, "cancelledGames", cancelledGames, _checker, __FILE__, __LINE__);
}

/*static*/ void SngStarter::cli::Protocol_MSG_SNG_POOL_CHECKOUT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_SNG_POOL_CHECKOUT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 scriptId; _parser.parseUINT32(scriptId);
	AtfValidator::validateInt(_descr, "scriptId", scriptId, _checker, __FILE__, __LINE__);
	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	BYTE cancelledGames; _parser.parseBYTE(cancelledGames);
	AtfValidator::validateInt(_descr, "cancelledGames", cancelledGames, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    SngGameBody
//=================================================================

SngStarter::cli::SngGameBody::SngGameBody()
{
	clear();
}

void SngStarter::cli::SngGameBody::clear()
{
	scriptId = 0;
	numGames = 0;
	tournId = 0;
	sampleAddress.clear();
	buyIn = 0;
	fppBuyIn = 0;
	rake = 0;
	game = 0;
	hiLo = 0;
	structure = 0;
	isPlayMoney = 0;
	currency.clear();
	scalePM = 0;
	name.clear();
	tournFlags2 = 0;
}

bool SngStarter::cli::SngGameBody::equals(const SngGameBody& _o) const
{
	return scriptId == _o.scriptId &&
		numGames == _o.numGames &&
		tournId == _o.tournId &&
		Atf::atfPStringEquals(sampleAddress, _o.sampleAddress) &&
		buyIn == _o.buyIn &&
		fppBuyIn == _o.fppBuyIn &&
		rake == _o.rake &&
		game == _o.game &&
		hiLo == _o.hiLo &&
		structure == _o.structure &&
		isPlayMoney == _o.isPlayMoney &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		scalePM == _o.scalePM &&
		Atf::atfPStringEquals(name, _o.name) &&
		tournFlags2 == _o.tournFlags2;
}

const char *SngStarter::cli::SngGameBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("scriptId=");
	_buf.appendUint(scriptId);
	_buf.append(',');
	_buf.append("numGames=");
	_buf.appendUint(numGames);
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("sampleAddress=");
	_buf.append(sampleAddress);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendUint(buyIn);
	_buf.append(',');
	_buf.append("fppBuyIn=");
	_buf.appendUint(fppBuyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendUint(rake);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("hiLo=");
	_buf.appendUint(hiLo);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("tournFlags2=");
	_buf.appendUint64(tournFlags2);
	_buf.append('}');
	return _buf.c_str();
}

const char *SngStarter::cli::SngGameBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("scriptId", scriptId, _buf);
	Atf::XmlElement::encodeAsXmlElement("numGames", numGames, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
	Atf::XmlElement::encodeAsXmlElement("sampleAddress", sampleAddress, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyIn", buyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("fppBuyIn", fppBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("rake", rake, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("hiLo", hiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournFlags2", tournFlags2, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool SngStarter::cli::SngGameBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("scriptId"))
		{
			scriptId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numGames"))
		{
			numGames = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournId"))
		{
			tournId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("sampleAddress"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, sampleAddress)) return false;
		}
		else if (_element.equals("buyIn"))
		{
			buyIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("fppBuyIn"))
		{
			fppBuyIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rake"))
		{
			rake = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("game"))
		{
			game = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("hiLo"))
		{
			hiLo = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("structure"))
		{
			structure = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isPlayMoney"))
		{
			isPlayMoney = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("scalePM"))
		{
			scalePM = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("name"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
		}
		else if (_element.equals("tournFlags2"))
		{
			tournFlags2 = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void SngStarter::cli::SngGameBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(SngGameBody())) // not empty
	{
		_body.composeUINT32(scriptId);
		_body.composeBYTE(numGames);
		_body.composeUINT32(tournId);
		_body.composeString(sampleAddress);
		_body.composeUINT32(buyIn);
		_body.composeUINT32(fppBuyIn);
		_body.composeUINT32(rake);
		_body.composeBYTE(game);
		_body.composeBYTE(hiLo);
		_body.composeBYTE(structure);
		_body.composeBYTE(isPlayMoney);
		_body.composeString(currency);
		_body.composeUINT32(scalePM);
		_body.composeString(name);
		_body.composeUINT64(tournFlags2);
	}

	_msg.composeMsgBody(_body);
}

void SngStarter::cli::SngGameBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(scriptId);
	_parser0.parseBYTE(numGames);
	_parser0.parseUINT32(tournId);
	_parser0.parseStringP(sampleAddress);
	_parser0.parseUINT32(buyIn);
	_parser0.parseUINT32(fppBuyIn);
	_parser0.parseUINT32(rake);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(hiLo);
	_parser0.parseBYTE(structure);
	_parser0.parseBYTE(isPlayMoney);
	_parser0.parseStringP(currency);
	_parser0.parseUINT32(scalePM);
	_parser0.parseStringP(name);
	_parser0.parseUINT64(tournFlags2);
}

const char *SngStarter::cli::SngGameBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("scriptId", scriptId);
	_jsonstr.compose("numGames", numGames);
	_jsonstr.compose("tournId", tournId);
	_jsonstr.compose("sampleAddress", sampleAddress);
	_jsonstr.compose("buyIn", buyIn);
	_jsonstr.compose("fppBuyIn", fppBuyIn);
	_jsonstr.compose("rake", rake);
	_jsonstr.compose("game", game);
	_jsonstr.compose("hiLo", hiLo);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("scalePM", scalePM);
	_jsonstr.compose("name", name);
	_jsonstr.compose("tournFlags2", tournFlags2);
	return _buf.c_str();
}

void SngStarter::cli::SngGameBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("scriptId", scriptId);
	_jparser.parseByNameThrow("numGames", numGames);
	_jparser.parseByNameThrow("tournId", tournId);
	_jparser.parseByNameThrow("sampleAddress", sampleAddress);
	_jparser.parseByNameThrow("buyIn", buyIn);
	_jparser.parseByNameThrow("fppBuyIn", fppBuyIn);
	_jparser.parseByNameThrow("rake", rake);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("hiLo", hiLo);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("scalePM", scalePM);
	_jparser.parseByNameThrow("name", name);
	_jparser.parseByNameThrow("tournFlags2", tournFlags2);
}

/* static */ void SngStarter::cli::SngGameBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 scriptId; _jparser.validateByNameThrow("scriptId", scriptId);
	AtfValidator::validateInt(_descr, "scriptId", scriptId, _checker, __FILE__, __LINE__);
	BYTE numGames; _jparser.validateByNameThrow("numGames", numGames);
	AtfValidator::validateInt(_descr, "numGames", numGames, _checker, __FILE__, __LINE__);
	UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	PString sampleAddress; _jparser.validateByNameThrow("sampleAddress", sampleAddress);
	AtfValidator::validateInt(_descr, "sampleAddress", sampleAddress.length(), _checker, __FILE__, __LINE__);
	UINT32 buyIn; _jparser.validateByNameThrow("buyIn", buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT32 fppBuyIn; _jparser.validateByNameThrow("fppBuyIn", fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	UINT32 rake; _jparser.validateByNameThrow("rake", rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE hiLo; _jparser.validateByNameThrow("hiLo", hiLo);
	AtfValidator::validateInt(_descr, "hiLo", hiLo, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	UINT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateInt(_descr, "name", name.length(), _checker, __FILE__, __LINE__);
	UINT64 tournFlags2; _jparser.validateByNameThrow("tournFlags2", tournFlags2);
	AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
}

/*static*/ void SngStarter::cli::SngGameBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 scriptId; _parser0.parseUINT32(scriptId);
	AtfValidator::validateInt(_descr, "scriptId", scriptId, _checker, __FILE__, __LINE__);
	BYTE numGames; _parser0.parseBYTE(numGames);
	AtfValidator::validateInt(_descr, "numGames", numGames, _checker, __FILE__, __LINE__);
	UINT32 tournId; _parser0.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "sampleAddress"); size_t szSampleAddress = strlen(_dummy);
	AtfValidator::validateInt(_descr, "sampleAddress", szSampleAddress, _checker, __FILE__, __LINE__);
	UINT32 buyIn; _parser0.parseUINT32(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT32 fppBuyIn; _parser0.parseUINT32(fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	UINT32 rake; _parser0.parseUINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE hiLo; _parser0.parseBYTE(hiLo);
	AtfValidator::validateInt(_descr, "hiLo", hiLo, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser0.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser0.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	UINT64 tournFlags2; _parser0.parseUINT64(tournFlags2);
	AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY
//=================================================================

SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY()
{
	clear();
}

void SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY::clear()
{
	errCode = 0;
	errMsg.clear();
	sngs.clear();
}

bool SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY::equals(const Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errMsg, _o.errMsg) &&
		sngs.equals(_o.sngs);
}

bool SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY*)_other));
}

const char *SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != DBM_NO_ERROR )
	{
		_buf.append(',');
		_buf.append("errMsg=");
		_buf.append(errMsg);
	}
	else
	{
		_buf.append(',');
		_buf.append("sngs=");
		sngs.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode != DBM_NO_ERROR )
	{
		Atf::XmlElement::encodeAsXmlElement("errMsg", errMsg, _buf);
	}
	else
	{
		sngs.toXmlString("sngs", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errMsg"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errMsg)) return false;
			}
			else if (_element.equals("sngs"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SngGameBody, 4 > >::FromXmlString(_value, sngs)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode != DBM_NO_ERROR )
	{
		_msg.composeString(errMsg);
	}
	else
	{
		sngs.composeMsg(_msg, _ignoreJSON);
	}
}

void SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != DBM_NO_ERROR )
	{
		_parser.parseStringP(errMsg);
	}
	else
	{
		sngs.parseMsg(_parser);
	}
}

const char *SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode != DBM_NO_ERROR )
	{
		_jsonstr.compose("errMsg", errMsg);
	}
	else
	{
		_jsonstr.compose("sngs", sngs);
	}
	return _buf.c_str();
}

void SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode != DBM_NO_ERROR )
	{
		_jparser.parseByNameThrow("errMsg", errMsg);
	}
	else
	{
		_jparser.parseByNameThrow("sngs", sngs);
	}
}

/*static*/ void SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != DBM_NO_ERROR )
	{
		PString errMsg; _jparser.validateByNameThrow("errMsg", errMsg);
		AtfValidator::validateInt(_descr, "errMsg", errMsg.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< SngGameBody > sngs; _jparser.validateByNameThrow("sngs", sngs);
		AtfValidator::validateInt(_descr, "sngs", sngs.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void SngStarter::cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != DBM_NO_ERROR )
	{
		_parser.parseStringN(_dummy, 0, "errMsg"); size_t szErrMsg = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errMsg", szErrMsg, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szSngs = Atf::LAtfVector< SngGameBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sngs"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "sngs", szSngs, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ Atf::MessageProtocol* SngStarter::ProtocolFactory::createMessageProtocolObject(const char *_nameSpace, UINT32 _msgId)
{
	Atf::MessageProtocol *_obj = NULL;

	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_TOURN_REG_INFO: _obj = new cli::Protocol_MSG_LOBBY_TOURN_REG_INFO(); break;
			case MSG_LOBBY_TOURN_REG_INFO_REPLY: _obj = new cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY(); break;
			case MSG_SNG_POOL_CHECKIN: _obj = new cli::Protocol_MSG_SNG_POOL_CHECKIN(); break;
			case MSG_SNG_POOL_CHECKIN_REPLY: _obj = new cli::Protocol_MSG_SNG_POOL_CHECKIN_REPLY(); break;
			case MSG_SNG_POOL_CHECKOUT: _obj = new cli::Protocol_MSG_SNG_POOL_CHECKOUT(); break;
			case MSG_SNG_POOL_CHECKOUT_REPLY: _obj = new cli::Protocol_MSG_SNG_POOL_CHECKOUT_REPLY(); break;
			case MSG_SNG_POOL_WHERE_IS_PLAYER: _obj = new cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER(); break;
			case MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY: _obj = new cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY(); break;
		}
	}
	
	return _obj;
}

/* static */ bool SngStarter::ProtocolFactory::validateProtocolMessageFromJSONString(const char *_nameSpace, UINT32 _msgId, const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_TOURN_REG_INFO: cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_TOURN_REG_INFO_REPLY: cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_SNG_POOL_CHECKIN: cli::Protocol_MSG_SNG_POOL_CHECKIN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_SNG_POOL_CHECKIN_REPLY: cli::Protocol_MSG_SNG_POOL_CHECKIN_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_SNG_POOL_CHECKOUT: cli::Protocol_MSG_SNG_POOL_CHECKOUT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_SNG_POOL_CHECKOUT_REPLY: cli::Protocol_MSG_SNG_POOL_CHECKOUT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_SNG_POOL_WHERE_IS_PLAYER: cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY: cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

/* static */ bool SngStarter::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_TOURN_REG_INFO: cli::Protocol_MSG_LOBBY_TOURN_REG_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_TOURN_REG_INFO_REPLY: cli::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_SNG_POOL_CHECKIN: cli::Protocol_MSG_SNG_POOL_CHECKIN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_SNG_POOL_CHECKIN_REPLY: cli::Protocol_MSG_SNG_POOL_CHECKIN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_SNG_POOL_CHECKOUT: cli::Protocol_MSG_SNG_POOL_CHECKOUT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_SNG_POOL_CHECKOUT_REPLY: cli::Protocol_MSG_SNG_POOL_CHECKOUT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_SNG_POOL_WHERE_IS_PLAYER: cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY: cli::Protocol_MSG_SNG_POOL_WHERE_IS_PLAYER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

