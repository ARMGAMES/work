/**
 * lobby_atf.cpp
 *
 * This file was auto-generated from lobby_atf.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor lobby_atf.txt
 */
 
#include "lobby_atf.h"

//=================================================================
//                Protocol_MSG_LOBBY_SUBMIT_STARCODE
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE::Protocol_MSG_LOBBY_SUBMIT_STARCODE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE::Protocol_MSG_LOBBY_SUBMIT_STARCODE(Protocol_MSG_LOBBY_SUBMIT_STARCODE&& _o)
	: starCode(std::move(_o.starCode))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE& Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE::operator=(Protocol_MSG_LOBBY_SUBMIT_STARCODE&& _o)
{
	if(this != &_o)
	{
		starCode = std::move(_o.starCode);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE::clear()
{
	starCode.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE::equals(const Protocol_MSG_LOBBY_SUBMIT_STARCODE& _o) const
{
	return Atf::atfPStringEquals(starCode, _o.starCode);
}

bool Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_SUBMIT_STARCODE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_SUBMIT_STARCODE*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SUBMIT_STARCODE).append(")");
	_buf.append(',');
	_buf.append("starCode=");
	_buf.append(starCode);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_SUBMIT_STARCODE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("starCode", starCode, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("starCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, starCode)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(starCode);
}

void Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(starCode);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("starCode", starCode);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("starCode", starCode);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SUBMIT_STARCODE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString starCode; _jparser.validateByNameThrow("starCode", starCode);
	AtfValidator::validateIntMax(_descr, "starCode", starCode.length(), 10000, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SUBMIT_STARCODE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "starCode"); size_t szStarCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "starCode", szStarCode, 10000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY::Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY::Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY(Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, successDescr(std::move(_o.successDescr))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY& Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY::operator=(Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		successDescr = std::move(_o.successDescr);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	successDescr.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY::equals(const Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(successDescr, _o.successDescr);
}

bool Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_SUBMIT_STARCODE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SUBMIT_STARCODE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("successDescr=");
		_buf.append(successDescr);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_SUBMIT_STARCODE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("successDescr", successDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("successDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, successDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(successDescr);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(successDescr);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("successDescr", successDescr);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("successDescr", successDescr);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SUBMIT_STARCODE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString successDescr; _jparser.validateByNameThrow("successDescr", successDescr);
		AtfValidator::validateInt(_descr, "successDescr", successDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SUBMIT_STARCODE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "successDescr"); size_t szSuccessDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "successDescr", szSuccessDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT(Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, doConvertBuyIn(std::move(_o.doConvertBuyIn))
	, doConvertWinnings(std::move(_o.doConvertWinnings))
{
}

Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT& Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT::operator=(Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		doConvertBuyIn = std::move(_o.doConvertBuyIn);
		doConvertWinnings = std::move(_o.doConvertWinnings);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT::clear()
{
	notUsedStr.clear();
	doConvertBuyIn = false;
	doConvertWinnings = false;
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT::equals(const Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT& _o) const
{
	return Atf::atfPStringEquals(notUsedStr, _o.notUsedStr) &&
		doConvertBuyIn == _o.doConvertBuyIn &&
		doConvertWinnings == _o.doConvertWinnings;
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_CLIENT_CURR_CONV_OPT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CLIENT_CURR_CONV_OPT).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("doConvertBuyIn=");
	_buf.appendUint(doConvertBuyIn);
	_buf.append(',');
	_buf.append("doConvertWinnings=");
	_buf.appendUint(doConvertWinnings);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_CLIENT_CURR_CONV_OPT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsedStr", notUsedStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("doConvertBuyIn", doConvertBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("doConvertWinnings", doConvertWinnings, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedStr)) return false;
			}
			else if (_element.equals("doConvertBuyIn"))
			{
				doConvertBuyIn = (*_value.ptr() == '1');
			}
			else if (_element.equals("doConvertWinnings"))
			{
				doConvertWinnings = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsedStr);
	_msg.composeBOOL(doConvertBuyIn);
	_msg.composeBOOL(doConvertWinnings);
}

void Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseBOOL(doConvertBuyIn);
	_parser.parseBOOL(doConvertWinnings);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsedStr", notUsedStr);
	_jsonstr.compose("doConvertBuyIn", doConvertBuyIn);
	_jsonstr.compose("doConvertWinnings", doConvertWinnings);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsedStr", notUsedStr);
	_jparser.parseByNameThrow("doConvertBuyIn", doConvertBuyIn);
	_jparser.parseByNameThrow("doConvertWinnings", doConvertWinnings);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLIENT_CURR_CONV_OPT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsedStr; _jparser.validateByNameThrow("notUsedStr", notUsedStr);
	AtfValidator::validateIntMax(_descr, "notUsedStr", notUsedStr.length(), 20, _checker, __FILE__, __LINE__);
	bool doConvertBuyIn; _jparser.validateByNameThrow("doConvertBuyIn", doConvertBuyIn);
	AtfValidator::validateInt(_descr, "doConvertBuyIn", doConvertBuyIn, _checker, __FILE__, __LINE__);
	bool doConvertWinnings; _jparser.validateByNameThrow("doConvertWinnings", doConvertWinnings);
	AtfValidator::validateInt(_descr, "doConvertWinnings", doConvertWinnings, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLIENT_CURR_CONV_OPT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	bool doConvertBuyIn; _parser.parseBOOL(doConvertBuyIn);
	AtfValidator::validateInt(_descr, "doConvertBuyIn", doConvertBuyIn, _checker, __FILE__, __LINE__);
	bool doConvertWinnings; _parser.parseBOOL(doConvertWinnings);
	AtfValidator::validateInt(_descr, "doConvertWinnings", doConvertWinnings, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY(Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, flags2(std::move(_o.flags2))
{
}

Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY& Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY::operator=(Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		flags2 = std::move(_o.flags2);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	flags2 = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY::equals(const Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		flags2 == _o.flags2;
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("flags2=");
		_buf.appendUint64(flags2);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("flags2", flags2, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("flags2"))
			{
				flags2 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT64(flags2);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT64(flags2);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("flags2", flags2);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("flags2", flags2);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT64 flags2; _jparser.validateByNameThrow("flags2", flags2);
		AtfValidator::validateUint(_descr, "flags2", flags2, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT64 flags2; _parser.parseUINT64(flags2);
		AtfValidator::validateUint(_descr, "flags2", flags2, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION(Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION&& _o)
	: redirectorUrl(std::move(_o.redirectorUrl))
{
}

Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION& Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::operator=(Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION&& _o)
{
	if(this != &_o)
	{
		redirectorUrl = std::move(_o.redirectorUrl);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::clear()
{
	redirectorUrl.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::equals(const Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION& _o) const
{
	return Atf::atfPStringEquals(redirectorUrl, _o.redirectorUrl);
}

bool Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_INIT_NETVERIFY_SESSION != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_INIT_NETVERIFY_SESSION).append(")");
	_buf.append(',');
	_buf.append("redirectorUrl=");
	_buf.append(redirectorUrl);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_INIT_NETVERIFY_SESSION).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("redirectorUrl", redirectorUrl, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("redirectorUrl"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, redirectorUrl)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(redirectorUrl);
}

void Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(redirectorUrl);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("redirectorUrl", redirectorUrl);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("redirectorUrl", redirectorUrl);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_INIT_NETVERIFY_SESSION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString redirectorUrl; _jparser.validateByNameThrow("redirectorUrl", redirectorUrl);
	AtfValidator::validateIntMax(_descr, "redirectorUrl", redirectorUrl.length(), 10000, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_INIT_NETVERIFY_SESSION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "redirectorUrl"); size_t szRedirectorUrl = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "redirectorUrl", szRedirectorUrl, 10000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY(Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, url(std::move(_o.url))
{
}

Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY& Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::operator=(Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		url = std::move(_o.url);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	url.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::equals(const Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(url, _o.url);
}

bool Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("url=");
		_buf.append(url);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("url", url, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("url"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, url)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(url);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(url);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("url", url);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("url", url);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString url; _jparser.validateByNameThrow("url", url);
		AtfValidator::validateInt(_descr, "url", url.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "url"); size_t szUrl = strlen(_dummy);
		AtfValidator::validateInt(_descr, "url", szUrl, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT(Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, startDate(std::move(_o.startDate))
	, endDate(std::move(_o.endDate))
	, password(std::move(_o.password))
	, includeFPP(std::move(_o.includeFPP))
	, reportFormat(std::move(_o.reportFormat))
	, isHtmlForClient(std::move(_o.isHtmlForClient))
	, reportFlags(std::move(_o.reportFlags))
{
}

Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT& Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::operator=(Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		startDate = std::move(_o.startDate);
		endDate = std::move(_o.endDate);
		password = std::move(_o.password);
		includeFPP = std::move(_o.includeFPP);
		reportFormat = std::move(_o.reportFormat);
		isHtmlForClient = std::move(_o.isHtmlForClient);
		reportFlags = std::move(_o.reportFlags);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::clear()
{
	notUsedStr.clear();
	startDate.setNull();
	endDate.setNull();
	password.clear();
	includeFPP = false;
	reportFormat = 0;
	isHtmlForClient = false;
	reportFlags = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::equals(const Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT& _o) const
{
	return Atf::atfPStringEquals(notUsedStr, _o.notUsedStr) &&
		startDate.equals(_o.startDate) &&
		endDate.equals(_o.endDate) &&
		Atf::atfPStringEquals(password, _o.password) &&
		includeFPP == _o.includeFPP &&
		reportFormat == _o.reportFormat &&
		isHtmlForClient == _o.isHtmlForClient &&
		reportFlags == _o.reportFlags;
}

bool Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_PLAYING_HISTORY_AUDIT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_PLAYING_HISTORY_AUDIT).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("startDate=");
	Atf::AtfTempl<SrvDate>::ToTraceString(_buf, startDate);
	_buf.append(',');
	_buf.append("endDate=");
	Atf::AtfTempl<SrvDate>::ToTraceString(_buf, endDate);
	_buf.append(',');
	_buf.append("password=");
	_buf.append(password);
	_buf.append(',');
	_buf.append("includeFPP=");
	_buf.appendUint(includeFPP);
	_buf.append(',');
	_buf.append("reportFormat=");
	_buf.appendUint(reportFormat);
	_buf.append(',');
	_buf.append("isHtmlForClient=");
	_buf.appendUint(isHtmlForClient);
	_buf.append(',');
	_buf.append("reportFlags=");
	_buf.appendUint(reportFlags);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_PLAYING_HISTORY_AUDIT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsedStr", notUsedStr, _buf);
	Atf::AtfTempl<SrvDate>::ToXmlString(_buf, "startDate", startDate);
	Atf::AtfTempl<SrvDate>::ToXmlString(_buf, "endDate", endDate);
	Atf::XmlElement::encodeAsXmlElement("password", password, _buf);
	Atf::XmlElement::encodeAsXmlElement("includeFPP", includeFPP, _buf);
	Atf::XmlElement::encodeAsXmlElement("reportFormat", reportFormat, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHtmlForClient", isHtmlForClient, _buf);
	Atf::XmlElement::encodeAsXmlElement("reportFlags", reportFlags, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedStr)) return false;
			}
			else if (_element.equals("startDate"))
			{
				Atf::AtfTempl<SrvDate>::FromXmlString(_value, startDate);
			}
			else if (_element.equals("endDate"))
			{
				Atf::AtfTempl<SrvDate>::FromXmlString(_value, endDate);
			}
			else if (_element.equals("password"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, password)) return false;
			}
			else if (_element.equals("includeFPP"))
			{
				includeFPP = (*_value.ptr() == '1');
			}
			else if (_element.equals("reportFormat"))
			{
				reportFormat = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isHtmlForClient"))
			{
				isHtmlForClient = (*_value.ptr() == '1');
			}
			else if (_element.equals("reportFlags"))
			{
				reportFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsedStr);
	_msg.composeSrvDate(startDate);
	_msg.composeSrvDate(endDate);
	_msg.composeString(password);
	_msg.composeBOOL(includeFPP);
	_msg.composeUINT32(reportFormat);
	_msg.composeBOOL(isHtmlForClient);
	_msg.composeUINT32(reportFlags);
}

void Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseSrvDate(startDate);
	_parser.parseSrvDate(endDate);
	_parser.parseStringP(password);
	_parser.parseBOOL(includeFPP);
	_parser.parseUINT32(reportFormat);
	_parser.parseBOOL(isHtmlForClient);
	_parser.parseUINT32(reportFlags);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsedStr", notUsedStr);
	_jsonstr.compose("startDate", startDate);
	_jsonstr.compose("endDate", endDate);
	_jsonstr.compose("password", password);
	_jsonstr.compose("includeFPP", includeFPP);
	_jsonstr.compose("reportFormat", reportFormat);
	_jsonstr.compose("isHtmlForClient", isHtmlForClient);
	_jsonstr.compose("reportFlags", reportFlags);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsedStr", notUsedStr);
	_jparser.parseByNameThrow("startDate", startDate);
	_jparser.parseByNameThrow("endDate", endDate);
	_jparser.parseByNameThrow("password", password);
	_jparser.parseByNameThrow("includeFPP", includeFPP);
	_jparser.parseByNameThrow("reportFormat", reportFormat);
	_jparser.parseByNameThrow("isHtmlForClient", isHtmlForClient);
	_jparser.parseByNameThrow("reportFlags", reportFlags);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_PLAYING_HISTORY_AUDIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsedStr; _jparser.validateByNameThrow("notUsedStr", notUsedStr);
	AtfValidator::validateIntMax(_descr, "notUsedStr", notUsedStr.length(), 20, _checker, __FILE__, __LINE__);
	SrvDate startDate; _jparser.validateByNameThrow("startDate", startDate);
	AtfValidator::validateSrvDateTime(_descr, "startDate", startDate, _checker, __FILE__, __LINE__);
	SrvDate endDate; _jparser.validateByNameThrow("endDate", endDate);
	AtfValidator::validateSrvDateTime(_descr, "endDate", endDate, _checker, __FILE__, __LINE__);
	PString password; _jparser.validateByNameThrow("password", password);
	AtfValidator::validateIntMax(_descr, "password", password.length(), 1000, _checker, __FILE__, __LINE__);
	bool includeFPP; _jparser.validateByNameThrow("includeFPP", includeFPP);
	AtfValidator::validateInt(_descr, "includeFPP", includeFPP, _checker, __FILE__, __LINE__);
	UINT32 reportFormat; _jparser.validateByNameThrow("reportFormat", reportFormat);
	AtfValidator::validateIntMax(_descr, "reportFormat", reportFormat, 100, _checker, __FILE__, __LINE__);
	bool isHtmlForClient; _jparser.validateByNameThrow("isHtmlForClient", isHtmlForClient);
	AtfValidator::validateInt(_descr, "isHtmlForClient", isHtmlForClient, _checker, __FILE__, __LINE__);
	UINT32 reportFlags; _jparser.validateByNameThrow("reportFlags", reportFlags);
	AtfValidator::validateInt(_descr, "reportFlags", reportFlags, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_PLAYING_HISTORY_AUDIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	SrvDate startDate; _parser.parseSrvDate(startDate);
	AtfValidator::validateSrvDateTime(_descr, "startDate", startDate, _checker, __FILE__, __LINE__);
	SrvDate endDate; _parser.parseSrvDate(endDate);
	AtfValidator::validateSrvDateTime(_descr, "endDate", endDate, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "password"); size_t szPassword = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "password", szPassword, 1000, _checker, __FILE__, __LINE__);
	bool includeFPP; _parser.parseBOOL(includeFPP);
	AtfValidator::validateInt(_descr, "includeFPP", includeFPP, _checker, __FILE__, __LINE__);
	UINT32 reportFormat; _parser.parseUINT32(reportFormat);
	AtfValidator::validateIntMax(_descr, "reportFormat", reportFormat, 100, _checker, __FILE__, __LINE__);
	bool isHtmlForClient; _parser.parseBOOL(isHtmlForClient);
	AtfValidator::validateInt(_descr, "isHtmlForClient", isHtmlForClient, _checker, __FILE__, __LINE__);
	UINT32 reportFlags; _parser.parseUINT32(reportFlags);
	AtfValidator::validateInt(_descr, "reportFlags", reportFlags, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY(Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY& Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::operator=(Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::equals(const Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT(Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, startDate(std::move(_o.startDate))
	, endDate(std::move(_o.endDate))
	, password(std::move(_o.password))
	, reportFormat(std::move(_o.reportFormat))
{
}

Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT& Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::operator=(Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		startDate = std::move(_o.startDate);
		endDate = std::move(_o.endDate);
		password = std::move(_o.password);
		reportFormat = std::move(_o.reportFormat);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::clear()
{
	notUsedStr.clear();
	startDate.setNull();
	endDate.setNull();
	password.clear();
	reportFormat = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::equals(const Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT& _o) const
{
	return Atf::atfPStringEquals(notUsedStr, _o.notUsedStr) &&
		startDate.equals(_o.startDate) &&
		endDate.equals(_o.endDate) &&
		Atf::atfPStringEquals(password, _o.password) &&
		reportFormat == _o.reportFormat;
}

bool Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("startDate=");
	Atf::AtfTempl<SrvDate>::ToTraceString(_buf, startDate);
	_buf.append(',');
	_buf.append("endDate=");
	Atf::AtfTempl<SrvDate>::ToTraceString(_buf, endDate);
	_buf.append(',');
	_buf.append("password=");
	_buf.append(password);
	_buf.append(',');
	_buf.append("reportFormat=");
	_buf.appendUint(reportFormat);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsedStr", notUsedStr, _buf);
	Atf::AtfTempl<SrvDate>::ToXmlString(_buf, "startDate", startDate);
	Atf::AtfTempl<SrvDate>::ToXmlString(_buf, "endDate", endDate);
	Atf::XmlElement::encodeAsXmlElement("password", password, _buf);
	Atf::XmlElement::encodeAsXmlElement("reportFormat", reportFormat, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedStr)) return false;
			}
			else if (_element.equals("startDate"))
			{
				Atf::AtfTempl<SrvDate>::FromXmlString(_value, startDate);
			}
			else if (_element.equals("endDate"))
			{
				Atf::AtfTempl<SrvDate>::FromXmlString(_value, endDate);
			}
			else if (_element.equals("password"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, password)) return false;
			}
			else if (_element.equals("reportFormat"))
			{
				reportFormat = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsedStr);
	_msg.composeSrvDate(startDate);
	_msg.composeSrvDate(endDate);
	_msg.composeString(password);
	_msg.composeUINT32(reportFormat);
}

void Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseSrvDate(startDate);
	_parser.parseSrvDate(endDate);
	_parser.parseStringP(password);
	_parser.parseUINT32(reportFormat);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsedStr", notUsedStr);
	_jsonstr.compose("startDate", startDate);
	_jsonstr.compose("endDate", endDate);
	_jsonstr.compose("password", password);
	_jsonstr.compose("reportFormat", reportFormat);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsedStr", notUsedStr);
	_jparser.parseByNameThrow("startDate", startDate);
	_jparser.parseByNameThrow("endDate", endDate);
	_jparser.parseByNameThrow("password", password);
	_jparser.parseByNameThrow("reportFormat", reportFormat);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsedStr; _jparser.validateByNameThrow("notUsedStr", notUsedStr);
	AtfValidator::validateIntMax(_descr, "notUsedStr", notUsedStr.length(), 20, _checker, __FILE__, __LINE__);
	SrvDate startDate; _jparser.validateByNameThrow("startDate", startDate);
	AtfValidator::validateSrvDateTime(_descr, "startDate", startDate, _checker, __FILE__, __LINE__);
	SrvDate endDate; _jparser.validateByNameThrow("endDate", endDate);
	AtfValidator::validateSrvDateTime(_descr, "endDate", endDate, _checker, __FILE__, __LINE__);
	PString password; _jparser.validateByNameThrow("password", password);
	AtfValidator::validateIntMax(_descr, "password", password.length(), 1000, _checker, __FILE__, __LINE__);
	UINT32 reportFormat; _jparser.validateByNameThrow("reportFormat", reportFormat);
	AtfValidator::validateIntMax(_descr, "reportFormat", reportFormat, 100, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	SrvDate startDate; _parser.parseSrvDate(startDate);
	AtfValidator::validateSrvDateTime(_descr, "startDate", startDate, _checker, __FILE__, __LINE__);
	SrvDate endDate; _parser.parseSrvDate(endDate);
	AtfValidator::validateSrvDateTime(_descr, "endDate", endDate, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "password"); size_t szPassword = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "password", szPassword, 1000, _checker, __FILE__, __LINE__);
	UINT32 reportFormat; _parser.parseUINT32(reportFormat);
	AtfValidator::validateIntMax(_descr, "reportFormat", reportFormat, 100, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY(Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY& Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY::operator=(Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY::equals(const Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != 0 )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode != 0 )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode != 0 )
	{
		_msg.composeString(errDescr);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != 0 )
	{
		_parser.parseStringP(errDescr);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode != 0 )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode != 0 )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CHALLENGE_QUESTION
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::Protocol_MSG_LOBBY_CHALLENGE_QUESTION()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::clear()
{
	locale = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::equals(const Protocol_MSG_LOBBY_CHALLENGE_QUESTION& _o) const
{
	return locale == _o.locale;
}

bool Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_CHALLENGE_QUESTION != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_CHALLENGE_QUESTION*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CHALLENGE_QUESTION).append(")");
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_CHALLENGE_QUESTION).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("locale"))
			{
				locale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(locale);
}

void Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(locale);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("locale", locale);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("locale", locale);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CHALLENGE_QUESTION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CHALLENGE_QUESTION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    ChallengeQuestion
//=================================================================

Lobby::cli::ChallengeQuestion::ChallengeQuestion()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::ChallengeQuestion::ChallengeQuestion(ChallengeQuestion&& _o)
	: id(std::move(_o.id))
	, txt(std::move(_o.txt))
{
}

Lobby::cli::ChallengeQuestion& Lobby::cli::ChallengeQuestion::operator=(ChallengeQuestion&& _o)
{
	if(this != &_o)
	{
		id = std::move(_o.id);
		txt = std::move(_o.txt);
	}
	return *this;
}

#endif

void Lobby::cli::ChallengeQuestion::clear()
{
	id = 0;
	txt.clear();
}

bool Lobby::cli::ChallengeQuestion::equals(const ChallengeQuestion& _o) const
{
	return id == _o.id &&
		Atf::atfPStringEquals(txt, _o.txt);
}

const char *Lobby::cli::ChallengeQuestion::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("id=");
	_buf.appendUint(id);
	_buf.append(',');
	_buf.append("txt=");
	_buf.append(txt);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::ChallengeQuestion::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("id", id, _buf);
	Atf::XmlElement::encodeAsXmlElement("txt", txt, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::ChallengeQuestion::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("id"))
		{
			id = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("txt"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, txt)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::ChallengeQuestion::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(id);
	_msg.composeString(txt);
}

void Lobby::cli::ChallengeQuestion::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(id);
	_parser.parseStringP(txt);
}

const char *Lobby::cli::ChallengeQuestion::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("id", id);
	_jsonstr.compose("txt", txt);
	return _buf.c_str();
}

void Lobby::cli::ChallengeQuestion::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("id", id);
	_jparser.parseByNameThrow("txt", txt);
}

/* static */ void Lobby::cli::ChallengeQuestion::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 id; _jparser.validateByNameThrow("id", id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	PString txt; _jparser.validateByNameThrow("txt", txt);
	AtfValidator::validateInt(_descr, "txt", txt.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::ChallengeQuestion::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 id; _parser.parseUINT32(id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "txt"); size_t szTxt = strlen(_dummy);
	AtfValidator::validateInt(_descr, "txt", szTxt, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY(Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, challenges(std::move(_o.challenges))
{
}

Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY& Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::operator=(Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		challenges = std::move(_o.challenges);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	challenges.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::equals(const Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		challenges.equals(_o.challenges);
}

bool Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_CHALLENGE_QUESTION_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CHALLENGE_QUESTION_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("challenges=");
		challenges.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_CHALLENGE_QUESTION_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		challenges.toXmlString("challenges", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("challenges"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ChallengeQuestion, 2 > >::FromXmlString(_value, challenges)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		challenges.composeMsg(_msg, _ignoreJSON);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		challenges.parseMsg(_parser);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("challenges", challenges);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("challenges", challenges);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CHALLENGE_QUESTION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< ChallengeQuestion > challenges; _jparser.validateByNameThrow("challenges", challenges);
		AtfValidator::validateInt(_descr, "challenges", challenges.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CHALLENGE_QUESTION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szChallenges = Atf::LAtfVector< ChallengeQuestion, 2 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("challenges"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "challenges", szChallenges, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT::clear()
{
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT::equals(const Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT& _o) const
{
	return true;
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_PLAYING_TIME_LIMIT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_PLAYING_TIME_LIMIT).append(")");
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_PLAYING_TIME_LIMIT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT::parseMsg(CommMsgParser& _parser)
{
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_PLAYING_TIME_LIMIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_PLAYING_TIME_LIMIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY(Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, limit(std::move(_o.limit))
	, autoLimiHour(std::move(_o.autoLimiHour))
{
}

Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY& Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY::operator=(Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		limit = std::move(_o.limit);
		autoLimiHour = std::move(_o.autoLimiHour);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	limit = 0;
	autoLimiHour = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY::equals(const Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		limit == _o.limit &&
		autoLimiHour == _o.autoLimiHour;
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("limit=");
		_buf.appendInt(limit);
		_buf.append(',');
		_buf.append("autoLimiHour=");
		_buf.appendUint(autoLimiHour);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("limit", limit, _buf);
		Atf::XmlElement::encodeAsXmlElement("autoLimiHour", autoLimiHour, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("limit"))
			{
				limit = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("autoLimiHour"))
			{
				autoLimiHour = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeINT32(limit);
		_msg.composeUINT32(autoLimiHour);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseINT32(limit);
		_parser.parseUINT32(autoLimiHour);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("limit", limit);
		_jsonstr.compose("autoLimiHour", autoLimiHour);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("limit", limit);
		_jparser.parseByNameThrow("autoLimiHour", autoLimiHour);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 limit; _jparser.validateByNameThrow("limit", limit);
		AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
		UINT32 autoLimiHour; _jparser.validateByNameThrow("autoLimiHour", autoLimiHour);
		AtfValidator::validateInt(_descr, "autoLimiHour", autoLimiHour, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 limit; _parser.parseINT32(limit);
		AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
		UINT32 autoLimiHour; _parser.parseUINT32(autoLimiHour);
		AtfValidator::validateInt(_descr, "autoLimiHour", autoLimiHour, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT::clear()
{
	limit = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT::equals(const Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT& _o) const
{
	return limit == _o.limit;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_SET_PLAYING_TIME_LIMIT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SET_PLAYING_TIME_LIMIT).append(")");
	_buf.append(',');
	_buf.append("limit=");
	_buf.appendInt(limit);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_SET_PLAYING_TIME_LIMIT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("limit", limit, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("limit"))
			{
				limit = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(limit);
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(limit);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("limit", limit);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("limit", limit);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_PLAYING_TIME_LIMIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 limit; _jparser.validateByNameThrow("limit", limit);
	AtfValidator::validateIntRange(_descr, "limit", limit, -1, 100000000, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_PLAYING_TIME_LIMIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 limit; _parser.parseINT32(limit);
	AtfValidator::validateIntRange(_descr, "limit", limit, -1, 100000000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY(Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, effectiveNow(std::move(_o.effectiveNow))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY& Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY::operator=(Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		effectiveNow = std::move(_o.effectiveNow);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	effectiveNow = false;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY::equals(const Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		effectiveNow == _o.effectiveNow;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("effectiveNow=");
		_buf.appendUint(effectiveNow);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("effectiveNow", effectiveNow, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("effectiveNow"))
			{
				effectiveNow = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeBOOL(effectiveNow);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseBOOL(effectiveNow);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("effectiveNow", effectiveNow);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("effectiveNow", effectiveNow);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		bool effectiveNow; _jparser.validateByNameThrow("effectiveNow", effectiveNow);
		AtfValidator::validateInt(_descr, "effectiveNow", effectiveNow, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool effectiveNow; _parser.parseBOOL(effectiveNow);
		AtfValidator::validateInt(_descr, "effectiveNow", effectiveNow, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL::clear()
{
}

bool Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL::equals(const Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL& _o) const
{
	return true;
}

bool Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_RESEND_ACTIVATION_EMAIL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_RESEND_ACTIVATION_EMAIL).append(")");
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_RESEND_ACTIVATION_EMAIL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL::parseMsg(CommMsgParser& _parser)
{
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_RESEND_ACTIVATION_EMAIL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_RESEND_ACTIVATION_EMAIL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY(Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY& Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY::operator=(Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY::equals(const Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc);
}

bool Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION(Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION&& _o)
	: unusedStr(std::move(_o.unusedStr))
	, newCode(std::move(_o.newCode))
{
}

Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION& Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION::operator=(Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION&& _o)
{
	if(this != &_o)
	{
		unusedStr = std::move(_o.unusedStr);
		newCode = std::move(_o.newCode);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION::clear()
{
	unusedStr.clear();
	newCode = false;
}

bool Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION::equals(const Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION& _o) const
{
	return Atf::atfPStringEquals(unusedStr, _o.unusedStr) &&
		newCode == _o.newCode;
}

bool Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_RESEND_MOBILE_VALIDATION != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_RESEND_MOBILE_VALIDATION).append(")");
	_buf.append(',');
	_buf.append("unusedStr=");
	_buf.append(unusedStr);
	_buf.append(',');
	_buf.append("newCode=");
	_buf.appendUint(newCode);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_RESEND_MOBILE_VALIDATION).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("unusedStr", unusedStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("newCode", newCode, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("unusedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, unusedStr)) return false;
			}
			else if (_element.equals("newCode"))
			{
				newCode = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(unusedStr);
	_msg.composeBOOL(newCode);
}

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(unusedStr);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(newCode);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("unusedStr", unusedStr);
	_jsonstr.compose("newCode", newCode);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("unusedStr", unusedStr);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("newCode", newCode);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_RESEND_MOBILE_VALIDATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString unusedStr; _jparser.validateByNameThrow("unusedStr", unusedStr);
	AtfValidator::validateIntMax(_descr, "unusedStr", unusedStr.length(), 20, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool newCode; _jparser.validateByNameThrow("newCode", newCode);
	AtfValidator::validateInt(_descr, "newCode", newCode, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_RESEND_MOBILE_VALIDATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "unusedStr"); size_t szUnusedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "unusedStr", szUnusedStr, 20, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool newCode; _parser.parseBOOL(newCode);
	AtfValidator::validateInt(_descr, "newCode", newCode, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY(Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY& Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY::operator=(Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY::equals(const Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc);
}

bool Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errDesc=");
	_buf.append(errDesc);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errDesc);
}

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(errDesc);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errDesc", errDesc);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errDesc", errDesc);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
	AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::clear()
{
	optionType = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::equals(const Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS& _o) const
{
	return optionType == _o.optionType;
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_CLIENT_OPTIONS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_CLIENT_OPTIONS).append(")");
	_buf.append(',');
	_buf.append("optionType=");
	_buf.appendUint(optionType);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_CLIENT_OPTIONS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("optionType", optionType, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("optionType"))
			{
				optionType = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(optionType);
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(optionType);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("optionType", optionType);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("optionType", optionType);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_CLIENT_OPTIONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	UINT32 optionType; _jparser.validateByNameThrow("optionType", optionType);
	AtfValidator::validateIntRange(_descr, "optionType", optionType, eClientCustomOptionsBegin, eClientCustomOptionsEnd, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_CLIENT_OPTIONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(_parser.parseEnded()) return;
	UINT32 optionType; _parser.parseUINT32(optionType);
	AtfValidator::validateIntRange(_descr, "optionType", optionType, eClientCustomOptionsBegin, eClientCustomOptionsEnd, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY(Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, encodedPropStr(std::move(_o.encodedPropStr))
{
}

Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY& Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::operator=(Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		encodedPropStr = std::move(_o.encodedPropStr);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	encodedPropStr.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::equals(const Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		encodedPropStr.size() == _o.encodedPropStr.size() && memcmp(encodedPropStr.ptr(), _o.encodedPropStr.ptr(), encodedPropStr.size()) == 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("encodedPropStr=");
		Atf::AtfTempl<PBlock>::ToTraceString(_buf, encodedPropStr);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("encodedPropStr", encodedPropStr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("encodedPropStr"))
			{
				Atf::XmlElement::_movePBlockWithNullStrip(_value, encodedPropStr);
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		CommMsgBody _msg0;
		_msg0._composeVarBlock(encodedPropStr.ptr(), encodedPropStr.size());
		_msg.composeMsgBody(_msg0);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		parseAnonymousMsgBody0(_parser);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("encodedPropStr", encodedPropStr);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("encodedPropStr", encodedPropStr);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PBlock encodedPropStr; _jparser.validateByNameThrow("encodedPropStr", encodedPropStr);
		AtfValidator::validateInt(_descr, "encodedPropStr", encodedPropStr.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parsePBlock(encodedPropStr);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const BYTE* encodedPropStr; size_t szEncodedPropStr; _parser0._parseVarBlock(encodedPropStr, szEncodedPropStr);  /*encodedPropStr*/
	AtfValidator::validateInt(_descr, "encodedPropStr", szEncodedPropStr, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS(Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS&& _o)
	: body(std::move(_o.body))
	, propType(std::move(_o.propType))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS& Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::operator=(Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS&& _o)
{
	if(this != &_o)
	{
		body = std::move(_o.body);
		propType = std::move(_o.propType);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::clear()
{
	body.clear();
	propType = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::equals(const Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS& _o) const
{
	return body.equals(_o.body) &&
		propType == _o.propType;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_SET_CLIENT_OPTIONS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SET_CLIENT_OPTIONS).append(")");
	_buf.append(',');
	_buf.append("body=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(body, _buf); _buf.append('}');
	_buf.append(',');
	_buf.append("propType=");
	_buf.appendUint(propType);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_SET_CLIENT_OPTIONS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("body", body, _buf);
	Atf::XmlElement::encodeAsXmlElement("propType", propType, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("body"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, body)) return false;
			}
			else if (_element.equals("propType"))
			{
				propType = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeMsgBody(body);
	_msg.composeUINT32(propType);
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseMsgBody(body);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(propType);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("body", body);
	_jsonstr.compose("propType", propType);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("body", body);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("propType", propType);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_CLIENT_OPTIONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::CopyableMsgBody body; _jparser.validateByNameThrow("body", body);
	AtfValidator::validateIntMax(_descr, "body", body._size(), USER_PROPERTYSTR_LEN, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 propType; _jparser.validateByNameThrow("propType", propType);
	AtfValidator::validateIntRange(_descr, "propType", propType, eClientCustomOptionsBegin, eClientCustomOptionsEnd, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_CLIENT_OPTIONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	size_t szBody; _parser.skipMsgBody(szBody);  /*body*/
	AtfValidator::validateIntMax(_descr, "body", szBody, USER_PROPERTYSTR_LEN, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 propType; _parser.parseUINT32(propType);
	AtfValidator::validateIntRange(_descr, "propType", propType, eClientCustomOptionsBegin, eClientCustomOptionsEnd, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY(Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY& Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::operator=(Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::equals(const Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc);
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    WaitOnTable
//=================================================================

Lobby::cli::WaitOnTable::WaitOnTable()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::WaitOnTable::WaitOnTable(WaitOnTable&& _o)
	: tableId32(std::move(_o.tableId32))
	, clubId(std::move(_o.clubId))
	, server(std::move(_o.server))
	, serverObject(std::move(_o.serverObject))
	, tableName(std::move(_o.tableName))
	, specialName(std::move(_o.specialName))
	, game(std::move(_o.game))
	, limit(std::move(_o.limit))
	, isHiLo(std::move(_o.isHiLo))
	, currency(std::move(_o.currency))
	, stakeLo(std::move(_o.stakeLo))
	, stakeHi(std::move(_o.stakeHi))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, numPlayers(std::move(_o.numPlayers))
	, maxPlayers(std::move(_o.maxPlayers))
	, isOneOnOne(std::move(_o.isOneOnOne))
	, waitListSize(std::move(_o.waitListSize))
	, waitListPos(std::move(_o.waitListPos))
	, scalePM(std::move(_o.scalePM))
	, tableId(std::move(_o.tableId))
{
}

Lobby::cli::WaitOnTable& Lobby::cli::WaitOnTable::operator=(WaitOnTable&& _o)
{
	if(this != &_o)
	{
		tableId32 = std::move(_o.tableId32);
		clubId = std::move(_o.clubId);
		server = std::move(_o.server);
		serverObject = std::move(_o.serverObject);
		tableName = std::move(_o.tableName);
		specialName = std::move(_o.specialName);
		game = std::move(_o.game);
		limit = std::move(_o.limit);
		isHiLo = std::move(_o.isHiLo);
		currency = std::move(_o.currency);
		stakeLo = std::move(_o.stakeLo);
		stakeHi = std::move(_o.stakeHi);
		isPlayMoney = std::move(_o.isPlayMoney);
		numPlayers = std::move(_o.numPlayers);
		maxPlayers = std::move(_o.maxPlayers);
		isOneOnOne = std::move(_o.isOneOnOne);
		waitListSize = std::move(_o.waitListSize);
		waitListPos = std::move(_o.waitListPos);
		scalePM = std::move(_o.scalePM);
		tableId = std::move(_o.tableId);
	}
	return *this;
}

#endif

void Lobby::cli::WaitOnTable::clear()
{
	tableId32 = 0;
	clubId = 0;
	server.clear();
	serverObject.clear();
	tableName.clear();
	specialName.clear();
	game = 0;
	limit = 0;
	isHiLo = false;
	currency.clear();
	stakeLo = 0;
	stakeHi = 0;
	isPlayMoney = false;
	numPlayers = 0;
	maxPlayers = 0;
	isOneOnOne = false;
	waitListSize = 0;
	waitListPos = 0;
	scalePM = 0;
	tableId = 0;
}

bool Lobby::cli::WaitOnTable::equals(const WaitOnTable& _o) const
{
	return tableId32 == _o.tableId32 &&
		clubId == _o.clubId &&
		Atf::atfPStringEquals(server, _o.server) &&
		Atf::atfPStringEquals(serverObject, _o.serverObject) &&
		Atf::atfPStringEquals(tableName, _o.tableName) &&
		Atf::atfPStringEquals(specialName, _o.specialName) &&
		game == _o.game &&
		limit == _o.limit &&
		isHiLo == _o.isHiLo &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		stakeLo == _o.stakeLo &&
		stakeHi == _o.stakeHi &&
		isPlayMoney == _o.isPlayMoney &&
		numPlayers == _o.numPlayers &&
		maxPlayers == _o.maxPlayers &&
		isOneOnOne == _o.isOneOnOne &&
		waitListSize == _o.waitListSize &&
		waitListPos == _o.waitListPos &&
		scalePM == _o.scalePM &&
		tableId == _o.tableId;
}

const char *Lobby::cli::WaitOnTable::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tableId32=");
	_buf.appendUint(tableId32);
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("serverObject=");
	_buf.append(serverObject);
	_buf.append(',');
	_buf.append("tableName=");
	_buf.append(tableName);
	_buf.append(',');
	_buf.append("specialName=");
	_buf.append(specialName);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("limit=");
	_buf.appendUint(limit);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("stakeLo=");
	_buf.appendUint(stakeLo);
	_buf.append(',');
	_buf.append("stakeHi=");
	_buf.appendUint(stakeHi);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("numPlayers=");
	_buf.appendUint(numPlayers);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendUint(maxPlayers);
	_buf.append(',');
	_buf.append("isOneOnOne=");
	_buf.appendUint(isOneOnOne);
	_buf.append(',');
	_buf.append("waitListSize=");
	_buf.appendUint(waitListSize);
	_buf.append(',');
	_buf.append("waitListPos=");
	_buf.appendUint(waitListPos);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::WaitOnTable::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("tableId32", tableId32, _buf);
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	Atf::XmlElement::encodeAsXmlElement("server", server, _buf);
	Atf::XmlElement::encodeAsXmlElement("serverObject", serverObject, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableName", tableName, _buf);
	Atf::XmlElement::encodeAsXmlElement("specialName", specialName, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("limit", limit, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("stakeLo", stakeLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("stakeHi", stakeHi, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("numPlayers", numPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPlayers", maxPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("isOneOnOne", isOneOnOne, _buf);
	Atf::XmlElement::encodeAsXmlElement("waitListSize", waitListSize, _buf);
	Atf::XmlElement::encodeAsXmlElement("waitListPos", waitListPos, _buf);
	Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableId", tableId, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::WaitOnTable::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("tableId32"))
		{
			tableId32 = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("clubId"))
		{
			clubId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("server"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, server)) return false;
		}
		else if (_element.equals("serverObject"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, serverObject)) return false;
		}
		else if (_element.equals("tableName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, tableName)) return false;
		}
		else if (_element.equals("specialName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, specialName)) return false;
		}
		else if (_element.equals("game"))
		{
			game = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("limit"))
		{
			limit = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (*_value.ptr() == '1');
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("stakeLo"))
		{
			stakeLo = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("stakeHi"))
		{
			stakeHi = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isPlayMoney"))
		{
			isPlayMoney = (*_value.ptr() == '1');
		}
		else if (_element.equals("numPlayers"))
		{
			numPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxPlayers"))
		{
			maxPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isOneOnOne"))
		{
			isOneOnOne = (*_value.ptr() == '1');
		}
		else if (_element.equals("waitListSize"))
		{
			waitListSize = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("waitListPos"))
		{
			waitListPos = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("scalePM"))
		{
			scalePM = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableId"))
		{
			tableId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::WaitOnTable::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(WaitOnTable())) // not empty
	{
		_body.composeUINT32(tableId32);
		_body.composeUINT32(clubId);
		_body.composeString(server);
		_body.composeString(serverObject);
		_body.composeString(tableName);
		_body.composeString(specialName);
		_body.composeBYTE(game);
		_body.composeBYTE(limit);
		_body.composeBOOL(isHiLo);
		_body.composeString(currency);
		_body.composeUINT32(stakeLo);
		_body.composeUINT32(stakeHi);
		_body.composeBOOL(isPlayMoney);
		_body.composeUINT32(numPlayers);
		_body.composeUINT32(maxPlayers);
		_body.composeBOOL(isOneOnOne);
		_body.composeUINT32(waitListSize);
		_body.composeUINT32(waitListPos);
		_body.composeUINT32(scalePM);
		_body.composeUINT64(tableId);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::cli::WaitOnTable::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(tableId32);
	_parser0.parseUINT32(clubId);
	_parser0.parseStringP(server);
	_parser0.parseStringP(serverObject);
	_parser0.parseStringP(tableName);
	_parser0.parseStringP(specialName);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(limit);
	_parser0.parseBOOL(isHiLo);
	_parser0.parseStringP(currency);
	_parser0.parseUINT32(stakeLo);
	_parser0.parseUINT32(stakeHi);
	_parser0.parseBOOL(isPlayMoney);
	_parser0.parseUINT32(numPlayers);
	_parser0.parseUINT32(maxPlayers);
	_parser0.parseBOOL(isOneOnOne);
	_parser0.parseUINT32(waitListSize);
	_parser0.parseUINT32(waitListPos);
	_parser0.parseUINT32(scalePM);
	_parser0.parseUINT64(tableId);
}

const char *Lobby::cli::WaitOnTable::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tableId32", tableId32);
	_jsonstr.compose("clubId", clubId);
	_jsonstr.compose("server", server);
	_jsonstr.compose("serverObject", serverObject);
	_jsonstr.compose("tableName", tableName);
	_jsonstr.compose("specialName", specialName);
	_jsonstr.compose("game", game);
	_jsonstr.compose("limit", limit);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("stakeLo", stakeLo);
	_jsonstr.compose("stakeHi", stakeHi);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("numPlayers", numPlayers);
	_jsonstr.compose("maxPlayers", maxPlayers);
	_jsonstr.compose("isOneOnOne", isOneOnOne);
	_jsonstr.compose("waitListSize", waitListSize);
	_jsonstr.compose("waitListPos", waitListPos);
	_jsonstr.compose("scalePM", scalePM);
	_jsonstr.compose("tableId", tableId);
	return _buf.c_str();
}

void Lobby::cli::WaitOnTable::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tableId32", tableId32);
	_jparser.parseByNameThrow("clubId", clubId);
	_jparser.parseByNameThrow("server", server);
	_jparser.parseByNameThrow("serverObject", serverObject);
	_jparser.parseByNameThrow("tableName", tableName);
	_jparser.parseByNameThrow("specialName", specialName);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("limit", limit);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("stakeLo", stakeLo);
	_jparser.parseByNameThrow("stakeHi", stakeHi);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("numPlayers", numPlayers);
	_jparser.parseByNameThrow("maxPlayers", maxPlayers);
	_jparser.parseByNameThrow("isOneOnOne", isOneOnOne);
	_jparser.parseByNameThrow("waitListSize", waitListSize);
	_jparser.parseByNameThrow("waitListPos", waitListPos);
	_jparser.parseByNameThrow("scalePM", scalePM);
	_jparser.parseByNameThrow("tableId", tableId);
}

/* static */ void Lobby::cli::WaitOnTable::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tableId32; _jparser.validateByNameThrow("tableId32", tableId32);
	AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	PString server; _jparser.validateByNameThrow("server", server);
	AtfValidator::validateInt(_descr, "server", server.length(), _checker, __FILE__, __LINE__);
	PString serverObject; _jparser.validateByNameThrow("serverObject", serverObject);
	AtfValidator::validateInt(_descr, "serverObject", serverObject.length(), _checker, __FILE__, __LINE__);
	PString tableName; _jparser.validateByNameThrow("tableName", tableName);
	AtfValidator::validateInt(_descr, "tableName", tableName.length(), _checker, __FILE__, __LINE__);
	PString specialName; _jparser.validateByNameThrow("specialName", specialName);
	AtfValidator::validateInt(_descr, "specialName", specialName.length(), _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE limit; _jparser.validateByNameThrow("limit", limit);
	AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
	bool isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	UINT32 stakeLo; _jparser.validateByNameThrow("stakeLo", stakeLo);
	AtfValidator::validateInt(_descr, "stakeLo", stakeLo, _checker, __FILE__, __LINE__);
	UINT32 stakeHi; _jparser.validateByNameThrow("stakeHi", stakeHi);
	AtfValidator::validateInt(_descr, "stakeHi", stakeHi, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 numPlayers; _jparser.validateByNameThrow("numPlayers", numPlayers);
	AtfValidator::validateInt(_descr, "numPlayers", numPlayers, _checker, __FILE__, __LINE__);
	UINT32 maxPlayers; _jparser.validateByNameThrow("maxPlayers", maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	bool isOneOnOne; _jparser.validateByNameThrow("isOneOnOne", isOneOnOne);
	AtfValidator::validateInt(_descr, "isOneOnOne", isOneOnOne, _checker, __FILE__, __LINE__);
	UINT32 waitListSize; _jparser.validateByNameThrow("waitListSize", waitListSize);
	AtfValidator::validateInt(_descr, "waitListSize", waitListSize, _checker, __FILE__, __LINE__);
	UINT32 waitListPos; _jparser.validateByNameThrow("waitListPos", waitListPos);
	AtfValidator::validateInt(_descr, "waitListPos", waitListPos, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT64 tableId; _jparser.validateByNameThrow("tableId", tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::WaitOnTable::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 tableId32; _parser0.parseUINT32(tableId32);
	AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
	UINT32 clubId; _parser0.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "serverObject"); size_t szServerObject = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObject", szServerObject, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "tableName"); size_t szTableName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tableName", szTableName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "specialName"); size_t szSpecialName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "specialName", szSpecialName, _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE limit; _parser0.parseBYTE(limit);
	AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
	bool isHiLo; _parser0.parseBOOL(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 stakeLo; _parser0.parseUINT32(stakeLo);
	AtfValidator::validateInt(_descr, "stakeLo", stakeLo, _checker, __FILE__, __LINE__);
	UINT32 stakeHi; _parser0.parseUINT32(stakeHi);
	AtfValidator::validateInt(_descr, "stakeHi", stakeHi, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _parser0.parseBOOL(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 numPlayers; _parser0.parseUINT32(numPlayers);
	AtfValidator::validateInt(_descr, "numPlayers", numPlayers, _checker, __FILE__, __LINE__);
	UINT32 maxPlayers; _parser0.parseUINT32(maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	bool isOneOnOne; _parser0.parseBOOL(isOneOnOne);
	AtfValidator::validateInt(_descr, "isOneOnOne", isOneOnOne, _checker, __FILE__, __LINE__);
	UINT32 waitListSize; _parser0.parseUINT32(waitListSize);
	AtfValidator::validateInt(_descr, "waitListSize", waitListSize, _checker, __FILE__, __LINE__);
	UINT32 waitListPos; _parser0.parseUINT32(waitListPos);
	AtfValidator::validateInt(_descr, "waitListPos", waitListPos, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser0.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT64 tableId; _parser0.parseUINT64(tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBY_WAIT_ON_TABLES
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES::Protocol_MSG_LOBBY_WAIT_ON_TABLES()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES::clear()
{
}

bool Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES::equals(const Protocol_MSG_LOBBY_WAIT_ON_TABLES& _o) const
{
	return true;
}

bool Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_WAIT_ON_TABLES != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_WAIT_ON_TABLES*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_WAIT_ON_TABLES).append(")");
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_WAIT_ON_TABLES).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES::parseMsg(CommMsgParser& _parser)
{
}

const char *Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_WAIT_ON_TABLES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_WAIT_ON_TABLES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY::Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY::Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY(Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, waitOnTables(std::move(_o.waitOnTables))
{
}

Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY& Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY::operator=(Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		waitOnTables = std::move(_o.waitOnTables);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	waitOnTables.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY::equals(const Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		waitOnTables.equals(_o.waitOnTables);
}

bool Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_WAIT_ON_TABLES_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_WAIT_ON_TABLES_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("waitOnTables=");
		waitOnTables.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_WAIT_ON_TABLES_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		waitOnTables.toXmlString("waitOnTables", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("waitOnTables"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< WaitOnTable, 4 > >::FromXmlString(_value, waitOnTables)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		waitOnTables.composeMsg(_msg, _ignoreJSON);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		waitOnTables.parseMsg(_parser);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("waitOnTables", waitOnTables);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("waitOnTables", waitOnTables);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_WAIT_ON_TABLES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< WaitOnTable > waitOnTables; _jparser.validateByNameThrow("waitOnTables", waitOnTables);
		AtfValidator::validateInt(_descr, "waitOnTables", waitOnTables.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_WAIT_ON_TABLES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szWaitOnTables = Atf::LAtfVector< WaitOnTable, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("waitOnTables"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "waitOnTables", szWaitOnTables, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND(Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND&& _o)
	: tournamentName(std::move(_o.tournamentName))
	, tableName(std::move(_o.tableName))
	, nick(std::move(_o.nick))
	, handText(std::move(_o.handText))
	, heroTheme(std::move(_o.heroTheme))
	, opponentTheme(std::move(_o.opponentTheme))
	, longText(std::move(_o.longText))
	, shortText(std::move(_o.shortText))
	, showHoleCards(std::move(_o.showHoleCards))
	, showRealTableName(std::move(_o.showRealTableName))
	, showAmountInBB(std::move(_o.showAmountInBB))
	, showRealNicks(std::move(_o.showRealNicks))
	, showHandId(std::move(_o.showHandId))
	, showHeroNick(std::move(_o.showHeroNick))
	, typeOfShow(std::move(_o.typeOfShow))
	, language(std::move(_o.language))
	, methodOfShare(std::move(_o.methodOfShare))
	, client(std::move(_o.client))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND& Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND::operator=(Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND&& _o)
{
	if(this != &_o)
	{
		tournamentName = std::move(_o.tournamentName);
		tableName = std::move(_o.tableName);
		nick = std::move(_o.nick);
		handText = std::move(_o.handText);
		heroTheme = std::move(_o.heroTheme);
		opponentTheme = std::move(_o.opponentTheme);
		longText = std::move(_o.longText);
		shortText = std::move(_o.shortText);
		showHoleCards = std::move(_o.showHoleCards);
		showRealTableName = std::move(_o.showRealTableName);
		showAmountInBB = std::move(_o.showAmountInBB);
		showRealNicks = std::move(_o.showRealNicks);
		showHandId = std::move(_o.showHandId);
		showHeroNick = std::move(_o.showHeroNick);
		typeOfShow = std::move(_o.typeOfShow);
		language = std::move(_o.language);
		methodOfShare = std::move(_o.methodOfShare);
		client = std::move(_o.client);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND::clear()
{
	tournamentName.clear();
	tableName.clear();
	nick.clear();
	handText.clear();
	heroTheme.clear();
	opponentTheme.clear();
	longText.clear();
	shortText.clear();
	showHoleCards = false;
	showRealTableName = false;
	showAmountInBB = false;
	showRealNicks = false;
	showHandId = false;
	showHeroNick = false;
	typeOfShow.clear();
	language.clear();
	methodOfShare.clear();
	client.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND::equals(const Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND& _o) const
{
	return Atf::atfPStringEquals(tournamentName, _o.tournamentName) &&
		Atf::atfPStringEquals(tableName, _o.tableName) &&
		Atf::atfPStringEquals(nick, _o.nick) &&
		Atf::atfPStringEquals(handText, _o.handText) &&
		Atf::atfPStringEquals(heroTheme, _o.heroTheme) &&
		Atf::atfPStringEquals(opponentTheme, _o.opponentTheme) &&
		Atf::atfPStringEquals(longText, _o.longText) &&
		Atf::atfPStringEquals(shortText, _o.shortText) &&
		showHoleCards == _o.showHoleCards &&
		showRealTableName == _o.showRealTableName &&
		showAmountInBB == _o.showAmountInBB &&
		showRealNicks == _o.showRealNicks &&
		showHandId == _o.showHandId &&
		showHeroNick == _o.showHeroNick &&
		Atf::atfPStringEquals(typeOfShow, _o.typeOfShow) &&
		Atf::atfPStringEquals(language, _o.language) &&
		Atf::atfPStringEquals(methodOfShare, _o.methodOfShare) &&
		Atf::atfPStringEquals(client, _o.client);
}

bool Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_SOCIAL_SHARE_HAND != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SOCIAL_SHARE_HAND).append(")");
	_buf.append(',');
	_buf.append("tournamentName=");
	_buf.append(tournamentName);
	_buf.append(',');
	_buf.append("tableName=");
	_buf.append(tableName);
	_buf.append(',');
	_buf.append("nick=");
	_buf.append(nick);
	_buf.append(',');
	_buf.append("handText=");
	_buf.append(handText);
	_buf.append(',');
	_buf.append("heroTheme=");
	_buf.append(heroTheme);
	_buf.append(',');
	_buf.append("opponentTheme=");
	_buf.append(opponentTheme);
	_buf.append(',');
	_buf.append("longText=");
	_buf.append(longText);
	_buf.append(',');
	_buf.append("shortText=");
	_buf.append(shortText);
	_buf.append(',');
	_buf.append("showHoleCards=");
	_buf.appendUint(showHoleCards);
	_buf.append(',');
	_buf.append("showRealTableName=");
	_buf.appendUint(showRealTableName);
	_buf.append(',');
	_buf.append("showAmountInBB=");
	_buf.appendUint(showAmountInBB);
	_buf.append(',');
	_buf.append("showRealNicks=");
	_buf.appendUint(showRealNicks);
	_buf.append(',');
	_buf.append("showHandId=");
	_buf.appendUint(showHandId);
	_buf.append(',');
	_buf.append("showHeroNick=");
	_buf.appendUint(showHeroNick);
	_buf.append(',');
	_buf.append("typeOfShow=");
	_buf.append(typeOfShow);
	_buf.append(',');
	_buf.append("language=");
	_buf.append(language);
	_buf.append(',');
	_buf.append("methodOfShare=");
	_buf.append(methodOfShare);
	_buf.append(',');
	_buf.append("client=");
	_buf.append(client);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_SOCIAL_SHARE_HAND).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("tournamentName", tournamentName, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableName", tableName, _buf);
	Atf::XmlElement::encodeAsXmlElement("nick", nick, _buf);
	Atf::XmlElement::encodeAsXmlElement("handText", handText, _buf);
	Atf::XmlElement::encodeAsXmlElement("heroTheme", heroTheme, _buf);
	Atf::XmlElement::encodeAsXmlElement("opponentTheme", opponentTheme, _buf);
	Atf::XmlElement::encodeAsXmlElement("longText", longText, _buf);
	Atf::XmlElement::encodeAsXmlElement("shortText", shortText, _buf);
	Atf::XmlElement::encodeAsXmlElement("showHoleCards", showHoleCards, _buf);
	Atf::XmlElement::encodeAsXmlElement("showRealTableName", showRealTableName, _buf);
	Atf::XmlElement::encodeAsXmlElement("showAmountInBB", showAmountInBB, _buf);
	Atf::XmlElement::encodeAsXmlElement("showRealNicks", showRealNicks, _buf);
	Atf::XmlElement::encodeAsXmlElement("showHandId", showHandId, _buf);
	Atf::XmlElement::encodeAsXmlElement("showHeroNick", showHeroNick, _buf);
	Atf::XmlElement::encodeAsXmlElement("typeOfShow", typeOfShow, _buf);
	Atf::XmlElement::encodeAsXmlElement("language", language, _buf);
	Atf::XmlElement::encodeAsXmlElement("methodOfShare", methodOfShare, _buf);
	Atf::XmlElement::encodeAsXmlElement("client", client, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tournamentName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tournamentName)) return false;
			}
			else if (_element.equals("tableName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tableName)) return false;
			}
			else if (_element.equals("nick"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, nick)) return false;
			}
			else if (_element.equals("handText"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, handText)) return false;
			}
			else if (_element.equals("heroTheme"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, heroTheme)) return false;
			}
			else if (_element.equals("opponentTheme"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, opponentTheme)) return false;
			}
			else if (_element.equals("longText"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, longText)) return false;
			}
			else if (_element.equals("shortText"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, shortText)) return false;
			}
			else if (_element.equals("showHoleCards"))
			{
				showHoleCards = (*_value.ptr() == '1');
			}
			else if (_element.equals("showRealTableName"))
			{
				showRealTableName = (*_value.ptr() == '1');
			}
			else if (_element.equals("showAmountInBB"))
			{
				showAmountInBB = (*_value.ptr() == '1');
			}
			else if (_element.equals("showRealNicks"))
			{
				showRealNicks = (*_value.ptr() == '1');
			}
			else if (_element.equals("showHandId"))
			{
				showHandId = (*_value.ptr() == '1');
			}
			else if (_element.equals("showHeroNick"))
			{
				showHeroNick = (*_value.ptr() == '1');
			}
			else if (_element.equals("typeOfShow"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, typeOfShow)) return false;
			}
			else if (_element.equals("language"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, language)) return false;
			}
			else if (_element.equals("methodOfShare"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, methodOfShare)) return false;
			}
			else if (_element.equals("client"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, client)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(tournamentName);
	_msg.composeString(tableName);
	_msg.composeString(nick);
	_msg.composeString(handText);
	_msg.composeString(heroTheme);
	_msg.composeString(opponentTheme);
	_msg.composeString(longText);
	_msg.composeString(shortText);
	_msg.composeBOOL(showHoleCards);
	_msg.composeBOOL(showRealTableName);
	_msg.composeBOOL(showAmountInBB);
	_msg.composeBOOL(showRealNicks);
	_msg.composeBOOL(showHandId);
	_msg.composeBOOL(showHeroNick);
	_msg.composeString(typeOfShow);
	_msg.composeString(language);
	_msg.composeString(methodOfShare);
	_msg.composeString(client);
}

void Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(tournamentName);
	_parser.parseStringP(tableName);
	_parser.parseStringP(nick);
	_parser.parseStringP(handText);
	_parser.parseStringP(heroTheme);
	_parser.parseStringP(opponentTheme);
	_parser.parseStringP(longText);
	_parser.parseStringP(shortText);
	_parser.parseBOOL(showHoleCards);
	_parser.parseBOOL(showRealTableName);
	_parser.parseBOOL(showAmountInBB);
	_parser.parseBOOL(showRealNicks);
	_parser.parseBOOL(showHandId);
	_parser.parseBOOL(showHeroNick);
	_parser.parseStringP(typeOfShow);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(language);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(methodOfShare);
	_parser.parseStringP(client);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tournamentName", tournamentName);
	_jsonstr.compose("tableName", tableName);
	_jsonstr.compose("nick", nick);
	_jsonstr.compose("handText", handText);
	_jsonstr.compose("heroTheme", heroTheme);
	_jsonstr.compose("opponentTheme", opponentTheme);
	_jsonstr.compose("longText", longText);
	_jsonstr.compose("shortText", shortText);
	_jsonstr.compose("showHoleCards", showHoleCards);
	_jsonstr.compose("showRealTableName", showRealTableName);
	_jsonstr.compose("showAmountInBB", showAmountInBB);
	_jsonstr.compose("showRealNicks", showRealNicks);
	_jsonstr.compose("showHandId", showHandId);
	_jsonstr.compose("showHeroNick", showHeroNick);
	_jsonstr.compose("typeOfShow", typeOfShow);
	_jsonstr.compose("language", language);
	_jsonstr.compose("methodOfShare", methodOfShare);
	_jsonstr.compose("client", client);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tournamentName", tournamentName);
	_jparser.parseByNameThrow("tableName", tableName);
	_jparser.parseByNameThrow("nick", nick);
	_jparser.parseByNameThrow("handText", handText);
	_jparser.parseByNameThrow("heroTheme", heroTheme);
	_jparser.parseByNameThrow("opponentTheme", opponentTheme);
	_jparser.parseByNameThrow("longText", longText);
	_jparser.parseByNameThrow("shortText", shortText);
	_jparser.parseByNameThrow("showHoleCards", showHoleCards);
	_jparser.parseByNameThrow("showRealTableName", showRealTableName);
	_jparser.parseByNameThrow("showAmountInBB", showAmountInBB);
	_jparser.parseByNameThrow("showRealNicks", showRealNicks);
	_jparser.parseByNameThrow("showHandId", showHandId);
	_jparser.parseByNameThrow("showHeroNick", showHeroNick);
	_jparser.parseByNameThrow("typeOfShow", typeOfShow);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("language", language);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("methodOfShare", methodOfShare);
	_jparser.parseByNameThrow("client", client);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SOCIAL_SHARE_HAND";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString tournamentName; _jparser.validateByNameThrow("tournamentName", tournamentName);
	AtfValidator::validateIntMax(_descr, "tournamentName", tournamentName.length(), 1000, _checker, __FILE__, __LINE__);
	PString tableName; _jparser.validateByNameThrow("tableName", tableName);
	AtfValidator::validateIntMax(_descr, "tableName", tableName.length(), 1000, _checker, __FILE__, __LINE__);
	PString nick; _jparser.validateByNameThrow("nick", nick);
	AtfValidator::validateIntMax(_descr, "nick", nick.length(), 1000, _checker, __FILE__, __LINE__);
	PString handText; _jparser.validateByNameThrow("handText", handText);
	AtfValidator::validateIntMax(_descr, "handText", handText.length(), 100000, _checker, __FILE__, __LINE__);
	PString heroTheme; _jparser.validateByNameThrow("heroTheme", heroTheme);
	AtfValidator::validateIntMax(_descr, "heroTheme", heroTheme.length(), 1000, _checker, __FILE__, __LINE__);
	PString opponentTheme; _jparser.validateByNameThrow("opponentTheme", opponentTheme);
	AtfValidator::validateIntMax(_descr, "opponentTheme", opponentTheme.length(), 1000, _checker, __FILE__, __LINE__);
	PString longText; _jparser.validateByNameThrow("longText", longText);
	AtfValidator::validateIntMax(_descr, "longText", longText.length(), 1000, _checker, __FILE__, __LINE__);
	PString shortText; _jparser.validateByNameThrow("shortText", shortText);
	AtfValidator::validateIntMax(_descr, "shortText", shortText.length(), 256, _checker, __FILE__, __LINE__);
	bool showHoleCards; _jparser.validateByNameThrow("showHoleCards", showHoleCards);
	AtfValidator::validateInt(_descr, "showHoleCards", showHoleCards, _checker, __FILE__, __LINE__);
	bool showRealTableName; _jparser.validateByNameThrow("showRealTableName", showRealTableName);
	AtfValidator::validateInt(_descr, "showRealTableName", showRealTableName, _checker, __FILE__, __LINE__);
	bool showAmountInBB; _jparser.validateByNameThrow("showAmountInBB", showAmountInBB);
	AtfValidator::validateInt(_descr, "showAmountInBB", showAmountInBB, _checker, __FILE__, __LINE__);
	bool showRealNicks; _jparser.validateByNameThrow("showRealNicks", showRealNicks);
	AtfValidator::validateInt(_descr, "showRealNicks", showRealNicks, _checker, __FILE__, __LINE__);
	bool showHandId; _jparser.validateByNameThrow("showHandId", showHandId);
	AtfValidator::validateInt(_descr, "showHandId", showHandId, _checker, __FILE__, __LINE__);
	bool showHeroNick; _jparser.validateByNameThrow("showHeroNick", showHeroNick);
	AtfValidator::validateInt(_descr, "showHeroNick", showHeroNick, _checker, __FILE__, __LINE__);
	PString typeOfShow; _jparser.validateByNameThrow("typeOfShow", typeOfShow);
	AtfValidator::validateIntMax(_descr, "typeOfShow", typeOfShow.length(), 1000, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString language; _jparser.validateByNameThrow("language", language);
	AtfValidator::validateIntMax(_descr, "language", language.length(), 128, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString methodOfShare; _jparser.validateByNameThrow("methodOfShare", methodOfShare);
	AtfValidator::validateIntMax(_descr, "methodOfShare", methodOfShare.length(), 1000, _checker, __FILE__, __LINE__);
	PString client; _jparser.validateByNameThrow("client", client);
	AtfValidator::validateIntMax(_descr, "client", client.length(), 1000, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SOCIAL_SHARE_HAND";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "tournamentName"); size_t szTournamentName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "tournamentName", szTournamentName, 1000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "tableName"); size_t szTableName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "tableName", szTableName, 1000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "nick"); size_t szNick = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "nick", szNick, 1000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "handText"); size_t szHandText = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "handText", szHandText, 100000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "heroTheme"); size_t szHeroTheme = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "heroTheme", szHeroTheme, 1000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "opponentTheme"); size_t szOpponentTheme = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "opponentTheme", szOpponentTheme, 1000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "longText"); size_t szLongText = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "longText", szLongText, 1000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "shortText"); size_t szShortText = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "shortText", szShortText, 256, _checker, __FILE__, __LINE__);
	bool showHoleCards; _parser.parseBOOL(showHoleCards);
	AtfValidator::validateInt(_descr, "showHoleCards", showHoleCards, _checker, __FILE__, __LINE__);
	bool showRealTableName; _parser.parseBOOL(showRealTableName);
	AtfValidator::validateInt(_descr, "showRealTableName", showRealTableName, _checker, __FILE__, __LINE__);
	bool showAmountInBB; _parser.parseBOOL(showAmountInBB);
	AtfValidator::validateInt(_descr, "showAmountInBB", showAmountInBB, _checker, __FILE__, __LINE__);
	bool showRealNicks; _parser.parseBOOL(showRealNicks);
	AtfValidator::validateInt(_descr, "showRealNicks", showRealNicks, _checker, __FILE__, __LINE__);
	bool showHandId; _parser.parseBOOL(showHandId);
	AtfValidator::validateInt(_descr, "showHandId", showHandId, _checker, __FILE__, __LINE__);
	bool showHeroNick; _parser.parseBOOL(showHeroNick);
	AtfValidator::validateInt(_descr, "showHeroNick", showHeroNick, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "typeOfShow"); size_t szTypeOfShow = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "typeOfShow", szTypeOfShow, 1000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "language"); size_t szLanguage = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "language", szLanguage, 128, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "methodOfShare"); size_t szMethodOfShare = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "methodOfShare", szMethodOfShare, 1000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "client"); size_t szClient = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "client", szClient, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY(Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, encUrl(std::move(_o.encUrl))
	, psapiUrl(std::move(_o.psapiUrl))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY& Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY::operator=(Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		encUrl = std::move(_o.encUrl);
		psapiUrl = std::move(_o.psapiUrl);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	encUrl.clear();
	psapiUrl.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY::equals(const Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		Atf::atfPStringEquals(encUrl, _o.encUrl) &&
		Atf::atfPStringEquals(psapiUrl, _o.psapiUrl);
}

bool Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("encUrl=");
		_buf.append(encUrl);
		_buf.append(',');
		_buf.append("psapiUrl=");
		_buf.append(psapiUrl);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("encUrl", encUrl, _buf);
		Atf::XmlElement::encodeAsXmlElement("psapiUrl", psapiUrl, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("encUrl"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, encUrl)) return false;
			}
			else if (_element.equals("psapiUrl"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, psapiUrl)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeString(encUrl);
		_msg.composeString(psapiUrl);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseStringP(encUrl);
		_parser.parseStringP(psapiUrl);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("encUrl", encUrl);
		_jsonstr.compose("psapiUrl", psapiUrl);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("encUrl", encUrl);
		_jparser.parseByNameThrow("psapiUrl", psapiUrl);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString encUrl; _jparser.validateByNameThrow("encUrl", encUrl);
		AtfValidator::validateInt(_descr, "encUrl", encUrl.length(), _checker, __FILE__, __LINE__);
		PString psapiUrl; _jparser.validateByNameThrow("psapiUrl", psapiUrl);
		AtfValidator::validateInt(_descr, "psapiUrl", psapiUrl.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "encUrl"); size_t szEncUrl = strlen(_dummy);
		AtfValidator::validateInt(_descr, "encUrl", szEncUrl, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "psapiUrl"); size_t szPsapiUrl = strlen(_dummy);
		AtfValidator::validateInt(_descr, "psapiUrl", szPsapiUrl, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_BE_AVC_VALIDATE
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE::Protocol_MSG_LOBBY_BE_AVC_VALIDATE()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE::clear()
{
	avc = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE::equals(const Protocol_MSG_LOBBY_BE_AVC_VALIDATE& _o) const
{
	return avc == _o.avc;
}

bool Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_BE_AVC_VALIDATE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_BE_AVC_VALIDATE*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_BE_AVC_VALIDATE).append(")");
	_buf.append(',');
	_buf.append("avc=");
	_buf.appendUint(avc);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_BE_AVC_VALIDATE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("avc", avc, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("avc"))
			{
				avc = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(avc);
}

void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(avc);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("avc", avc);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("avc", avc);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_BE_AVC_VALIDATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 avc; _jparser.validateByNameThrow("avc", avc);
	AtfValidator::validateInt(_descr, "avc", avc, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_BE_AVC_VALIDATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 avc; _parser.parseUINT32(avc);
	AtfValidator::validateInt(_descr, "avc", avc, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY::Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY::Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY(Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY& Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY::operator=(Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY::equals(const Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc);
}

bool Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_BE_AVC_VALIDATE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_BE_AVC_VALIDATE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_BE_AVC_VALIDATE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_BE_AVC_VALIDATE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_BE_AVC_VALIDATE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_BE_AVC_RESEND
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND::Protocol_MSG_LOBBY_BE_AVC_RESEND()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND::clear()
{
}

bool Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND::equals(const Protocol_MSG_LOBBY_BE_AVC_RESEND& _o) const
{
	return true;
}

bool Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_BE_AVC_RESEND != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_BE_AVC_RESEND*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_BE_AVC_RESEND).append(")");
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_BE_AVC_RESEND).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND::parseMsg(CommMsgParser& _parser)
{
}

const char *Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_BE_AVC_RESEND";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_BE_AVC_RESEND";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY::Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY::Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY(Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY& Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY::operator=(Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY::equals(const Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc);
}

bool Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_BE_AVC_RESEND_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_BE_AVC_RESEND_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_BE_AVC_RESEND_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_BE_AVC_RESEND_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_BE_AVC_RESEND_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN::Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN::Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN(Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN&& _o)
	: installIdDeprecated(std::move(_o.installIdDeprecated))
	, siteId(std::move(_o.siteId))
	, platformId(std::move(_o.platformId))
	, extraData(std::move(_o.extraData))
{
}

Lobby::cli::Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN& Lobby::cli::Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN::operator=(Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN&& _o)
{
	if(this != &_o)
	{
		installIdDeprecated = std::move(_o.installIdDeprecated);
		siteId = std::move(_o.siteId);
		platformId = std::move(_o.platformId);
		extraData = std::move(_o.extraData);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN::clear()
{
	installIdDeprecated.clear();
	siteId = 0;
	platformId = 0;
	extraData.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN::equals(const Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN& _o) const
{
	return Atf::atfPStringEquals(installIdDeprecated, _o.installIdDeprecated) &&
		siteId == _o.siteId &&
		platformId == _o.platformId &&
		extraData.equals(_o.extraData);
}

bool Lobby::cli::Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_REPORT_FIRST_LOGIN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_REPORT_FIRST_LOGIN).append(")");
	_buf.append(',');
	_buf.append("installIdDeprecated=");
	_buf.append(installIdDeprecated);
	_buf.append(',');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("platformId=");
	_buf.appendUint(platformId);
	_buf.append(',');
	_buf.append("extraData=");
	extraData.toTraceString(_buf);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_REPORT_FIRST_LOGIN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("installIdDeprecated", installIdDeprecated, _buf);
	Atf::XmlElement::encodeAsXmlElement("siteId", siteId, _buf);
	Atf::XmlElement::encodeAsXmlElement("platformId", platformId, _buf);
	extraData.toXmlString("extraData", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("installIdDeprecated"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, installIdDeprecated)) return false;
			}
			else if (_element.equals("siteId"))
			{
				siteId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("platformId"))
			{
				platformId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("extraData"))
			{
				if(!Atf::AtfTempl< Common::AtfShared::LoginExtra >::FromXmlString(_value, extraData)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(installIdDeprecated);
	_msg.composeUINT32(siteId);
	_msg.composeUINT32(platformId);
	extraData.composeMsg(_msg, _ignoreJSON);
}

void Lobby::cli::Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(installIdDeprecated);
	_parser.parseUINT32(siteId);
	_parser.parseUINT32(platformId);
	if(_parser.parseEnded()) return;
	extraData.parseMsg(_parser);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("installIdDeprecated", installIdDeprecated);
	_jsonstr.compose("siteId", siteId);
	_jsonstr.compose("platformId", platformId);
	_jsonstr.compose("extraData", extraData);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("installIdDeprecated", installIdDeprecated);
	_jparser.parseByNameThrow("siteId", siteId);
	_jparser.parseByNameThrow("platformId", platformId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("extraData", extraData);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_REPORT_FIRST_LOGIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString installIdDeprecated; _jparser.validateByNameThrow("installIdDeprecated", installIdDeprecated);
	AtfValidator::validateIntMax(_descr, "installIdDeprecated", installIdDeprecated.length(), 40, _checker, __FILE__, __LINE__);
	UINT32 siteId; _jparser.validateByNameThrow("siteId", siteId);
	AtfValidator::validateIntMax(_descr, "siteId", siteId, PokerStars_Last, _checker, __FILE__, __LINE__);
	UINT32 platformId; _jparser.validateByNameThrow("platformId", platformId);
	AtfValidator::validateIntMax(_descr, "platformId", platformId, Client_Last, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	Common::AtfShared::LoginExtra extraData; _jparser.validateByNameThrow("extraData", extraData);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_REPORT_FIRST_LOGIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "installIdDeprecated"); size_t szInstallIdDeprecated = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "installIdDeprecated", szInstallIdDeprecated, 40, _checker, __FILE__, __LINE__);
	UINT32 siteId; _parser.parseUINT32(siteId);
	AtfValidator::validateIntMax(_descr, "siteId", siteId, PokerStars_Last, _checker, __FILE__, __LINE__);
	UINT32 platformId; _parser.parseUINT32(platformId);
	AtfValidator::validateIntMax(_descr, "platformId", platformId, Client_Last, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PString _descbuf;
	Common::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("extraData"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_IP_CHECK
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_IP_CHECK::Protocol_MSG_LOBBY_IP_CHECK()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_IP_CHECK::clear()
{
	code = 0;
	lobbyIp = 0;
	pingIp = 0;
	errCode = 0;
	myIpi = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_IP_CHECK::equals(const Protocol_MSG_LOBBY_IP_CHECK& _o) const
{
	return code == _o.code &&
		lobbyIp == _o.lobbyIp &&
		pingIp == _o.pingIp &&
		errCode == _o.errCode &&
		myIpi == _o.myIpi;
}

bool Lobby::cli::Protocol_MSG_LOBBY_IP_CHECK::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_IP_CHECK != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_IP_CHECK*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_IP_CHECK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_IP_CHECK).append(")");
	_buf.append(',');
	_buf.append("code=");
	_buf.appendUint(code);
	if (code == 0)
	{
		_buf.append(',');
		_buf.append("lobbyIp=");
		_buf.appendUint(lobbyIp);
		_buf.append(',');
		_buf.append("pingIp=");
		_buf.appendUint(pingIp);
	}
	else
	{
		_buf.append(',');
		_buf.append("errCode=");
		_buf.appendUint(errCode);
		_buf.append(',');
		_buf.append("myIpi=");
		_buf.appendUint(myIpi);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_IP_CHECK::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_IP_CHECK::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_IP_CHECK).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("code", code, _buf);
	if (code == 0)
	{
		Atf::XmlElement::encodeAsXmlElement("lobbyIp", lobbyIp, _buf);
		Atf::XmlElement::encodeAsXmlElement("pingIp", pingIp, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
		Atf::XmlElement::encodeAsXmlElement("myIpi", myIpi, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_IP_CHECK::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("code"))
			{
				code = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("lobbyIp"))
			{
				lobbyIp = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("pingIp"))
			{
				pingIp = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errCode"))
			{
				errCode = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("myIpi"))
			{
				myIpi = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_IP_CHECK::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(code);
	if (code == 0)
	{
		_msg.composeUINT32(lobbyIp);
		_msg.composeUINT32(pingIp);
	}
	else
	{
		_msg.composeUINT32(errCode);
		_msg.composeUINT32(myIpi);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_IP_CHECK::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(code);
	if (code == 0)
	{
		_parser.parseUINT32(lobbyIp);
		_parser.parseUINT32(pingIp);
	}
	else
	{
		_parser.parseUINT32(errCode);
		_parser.parseUINT32(myIpi);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_IP_CHECK::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("code", code);
	if (code == 0)
	{
		_jsonstr.compose("lobbyIp", lobbyIp);
		_jsonstr.compose("pingIp", pingIp);
	}
	else
	{
		_jsonstr.compose("errCode", errCode);
		_jsonstr.compose("myIpi", myIpi);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_IP_CHECK::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("code", code);
	if (code == 0)
	{
		_jparser.parseByNameThrow("lobbyIp", lobbyIp);
		_jparser.parseByNameThrow("pingIp", pingIp);
	}
	else
	{
		_jparser.parseByNameThrow("errCode", errCode);
		_jparser.parseByNameThrow("myIpi", myIpi);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_IP_CHECK::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_IP_CHECK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE code = 0;
	_jparser.validateByNameThrow("code", code);
	AtfValidator::validateIntMax(_descr, "code", code, 6, _checker, __FILE__, __LINE__);
	if (code == 0)
	{
		UINT32 lobbyIp; _jparser.validateByNameThrow("lobbyIp", lobbyIp);
		AtfValidator::validateInt(_descr, "lobbyIp", lobbyIp, _checker, __FILE__, __LINE__);
		UINT32 pingIp; _jparser.validateByNameThrow("pingIp", pingIp);
		AtfValidator::validateInt(_descr, "pingIp", pingIp, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 errCode; _jparser.validateByNameThrow("errCode", errCode);
		AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
		UINT32 myIpi; _jparser.validateByNameThrow("myIpi", myIpi);
		AtfValidator::validateInt(_descr, "myIpi", myIpi, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_IP_CHECK::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_IP_CHECK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE code = 0;
	_parser.parseBYTE(code);
	AtfValidator::validateIntMax(_descr, "code", code, 6, _checker, __FILE__, __LINE__);
	if (code == 0)
	{
		UINT32 lobbyIp; _parser.parseUINT32(lobbyIp);
		AtfValidator::validateInt(_descr, "lobbyIp", lobbyIp, _checker, __FILE__, __LINE__);
		UINT32 pingIp; _parser.parseUINT32(pingIp);
		AtfValidator::validateInt(_descr, "pingIp", pingIp, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 errCode; _parser.parseUINT32(errCode);
		AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
		UINT32 myIpi; _parser.parseUINT32(myIpi);
		AtfValidator::validateInt(_descr, "myIpi", myIpi, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    TableSize
//=================================================================

Lobby::cli::TableSize::TableSize()
{
	clear();
}

void Lobby::cli::TableSize::clear()
{
	min = 0;
	max = 0;
}

bool Lobby::cli::TableSize::equals(const TableSize& _o) const
{
	return min == _o.min &&
		max == _o.max;
}

const char *Lobby::cli::TableSize::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("min=");
	_buf.appendUint(min);
	_buf.append(',');
	_buf.append("max=");
	_buf.appendUint(max);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::TableSize::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("min", min, _buf);
	Atf::XmlElement::encodeAsXmlElement("max", max, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::TableSize::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("min"))
		{
			min = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("max"))
		{
			max = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::TableSize::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(min);
	_msg.composeBYTE(max);
}

void Lobby::cli::TableSize::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(min);
	_parser.parseBYTE(max);
}

const char *Lobby::cli::TableSize::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("min", min);
	_jsonstr.compose("max", max);
	return _buf.c_str();
}

void Lobby::cli::TableSize::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("min", min);
	_jparser.parseByNameThrow("max", max);
}

/* static */ void Lobby::cli::TableSize::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE min; _jparser.validateByNameThrow("min", min);
	AtfValidator::validateInt(_descr, "min", min, _checker, __FILE__, __LINE__);
	BYTE max; _jparser.validateByNameThrow("max", max);
	AtfValidator::validateInt(_descr, "max", max, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::TableSize::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	BYTE min; _parser.parseBYTE(min);
	AtfValidator::validateInt(_descr, "min", min, _checker, __FILE__, __LINE__);
	BYTE max; _parser.parseBYTE(max);
	AtfValidator::validateInt(_descr, "max", max, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG
//=================================================================

Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG(Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG&& _o)
	: sngId(std::move(_o.sngId))
	, game(std::move(_o.game))
	, hiLo(std::move(_o.hiLo))
	, structure(std::move(_o.structure))
	, speed(std::move(_o.speed))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, currency(std::move(_o.currency))
	, minPlayersFrom(std::move(_o.minPlayersFrom))
	, minPlayersTo(std::move(_o.minPlayersTo))
	, minBuyIn(std::move(_o.minBuyIn))
	, maxBuyIn(std::move(_o.maxBuyIn))
	, flags(std::move(_o.flags))
	, tableSizes(std::move(_o.tableSizes))
{
}

Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG& Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG::operator=(Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG&& _o)
{
	if(this != &_o)
	{
		sngId = std::move(_o.sngId);
		game = std::move(_o.game);
		hiLo = std::move(_o.hiLo);
		structure = std::move(_o.structure);
		speed = std::move(_o.speed);
		isPlayMoney = std::move(_o.isPlayMoney);
		currency = std::move(_o.currency);
		minPlayersFrom = std::move(_o.minPlayersFrom);
		minPlayersTo = std::move(_o.minPlayersTo);
		minBuyIn = std::move(_o.minBuyIn);
		maxBuyIn = std::move(_o.maxBuyIn);
		flags = std::move(_o.flags);
		tableSizes = std::move(_o.tableSizes);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG::clear()
{
	sngId = 0;
	game = 0;
	hiLo = 0;
	structure = 0;
	speed = 0;
	isPlayMoney = false;
	currency.clear();
	minPlayersFrom = 0;
	minPlayersTo = 0;
	minBuyIn = 0;
	maxBuyIn = 0;
	flags = 0;
	tableSizes.clear();
}

bool Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG::equals(const Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG& _o) const
{
	return sngId == _o.sngId &&
		game == _o.game &&
		hiLo == _o.hiLo &&
		structure == _o.structure &&
		speed == _o.speed &&
		isPlayMoney == _o.isPlayMoney &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		minPlayersFrom == _o.minPlayersFrom &&
		minPlayersTo == _o.minPlayersTo &&
		minBuyIn == _o.minBuyIn &&
		maxBuyIn == _o.maxBuyIn &&
		flags == _o.flags &&
		tableSizes.equals(_o.tableSizes);
}

bool Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CLI_LOBBY_FIND_QUICKSTART_SNG != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG*)_other));
}

const char *Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CLI_LOBBY_FIND_QUICKSTART_SNG).append(")");
	_buf.append(',');
	_buf.append("sngId=");
	_buf.appendUint(sngId);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("hiLo=");
	_buf.appendUint(hiLo);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("speed=");
	_buf.appendUint(speed);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("minPlayersFrom=");
	_buf.appendUint(minPlayersFrom);
	_buf.append(',');
	_buf.append("minPlayersTo=");
	_buf.appendUint(minPlayersTo);
	_buf.append(',');
	_buf.append("minBuyIn=");
	_buf.appendUint(minBuyIn);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendUint(maxBuyIn);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("tableSizes=");
	tableSizes.toTraceString(_buf);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CLI_LOBBY_FIND_QUICKSTART_SNG).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("sngId", sngId, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("hiLo", hiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("speed", speed, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("minPlayersFrom", minPlayersFrom, _buf);
	Atf::XmlElement::encodeAsXmlElement("minPlayersTo", minPlayersTo, _buf);
	Atf::XmlElement::encodeAsXmlElement("minBuyIn", minBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxBuyIn", maxBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	tableSizes.toXmlString("tableSizes", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("sngId"))
			{
				sngId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("game"))
			{
				game = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("hiLo"))
			{
				hiLo = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("structure"))
			{
				structure = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("speed"))
			{
				speed = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isPlayMoney"))
			{
				isPlayMoney = (*_value.ptr() == '1');
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else if (_element.equals("minPlayersFrom"))
			{
				minPlayersFrom = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minPlayersTo"))
			{
				minPlayersTo = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minBuyIn"))
			{
				minBuyIn = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxBuyIn"))
			{
				maxBuyIn = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("flags"))
			{
				flags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tableSizes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TableSize, 4 > >::FromXmlString(_value, tableSizes)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(sngId);
	_msg.composeBYTE(game);
	_msg.composeBYTE(hiLo);
	_msg.composeBYTE(structure);
	_msg.composeBYTE(speed);
	_msg.composeBOOL(isPlayMoney);
	_msg.composeString(currency);
	_msg.composeUINT32(minPlayersFrom);
	_msg.composeUINT32(minPlayersTo);
	_msg.composeUINT32(minBuyIn);
	_msg.composeUINT32(maxBuyIn);
	_msg.composeUINT32(flags);
	tableSizes.composeMsg(_msg, _ignoreJSON);
}

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(sngId);
	_parser.parseBYTE(game);
	_parser.parseBYTE(hiLo);
	_parser.parseBYTE(structure);
	_parser.parseBYTE(speed);
	_parser.parseBOOL(isPlayMoney);
	_parser.parseStringP(currency);
	_parser.parseUINT32(minPlayersFrom);
	_parser.parseUINT32(minPlayersTo);
	_parser.parseUINT32(minBuyIn);
	_parser.parseUINT32(maxBuyIn);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(flags);
	tableSizes.parseMsg(_parser);
}

const char *Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("sngId", sngId);
	_jsonstr.compose("game", game);
	_jsonstr.compose("hiLo", hiLo);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("speed", speed);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("minPlayersFrom", minPlayersFrom);
	_jsonstr.compose("minPlayersTo", minPlayersTo);
	_jsonstr.compose("minBuyIn", minBuyIn);
	_jsonstr.compose("maxBuyIn", maxBuyIn);
	_jsonstr.compose("flags", flags);
	_jsonstr.compose("tableSizes", tableSizes);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("sngId", sngId);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("hiLo", hiLo);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("speed", speed);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("minPlayersFrom", minPlayersFrom);
	_jparser.parseByNameThrow("minPlayersTo", minPlayersTo);
	_jparser.parseByNameThrow("minBuyIn", minBuyIn);
	_jparser.parseByNameThrow("maxBuyIn", maxBuyIn);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("flags", flags);
	_jparser.parseByNameThrow("tableSizes", tableSizes);
}

/*static*/ void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CLI_LOBBY_FIND_QUICKSTART_SNG";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 sngId; _jparser.validateByNameThrow("sngId", sngId);
	AtfValidator::validateInt(_descr, "sngId", sngId, _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateIntRange(_descr, "game", game, HandTypeNone, HandType_Last, _checker, __FILE__, __LINE__);
	BYTE hiLo; _jparser.validateByNameThrow("hiLo", hiLo);
	AtfValidator::validateIntMax(_descr, "hiLo", hiLo, 1, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateIntRange(_descr, "structure", structure, StructLimit, PotStruct_Last, _checker, __FILE__, __LINE__);
	BYTE speed; _jparser.validateByNameThrow("speed", speed);
	AtfValidator::validateIntMax(_descr, "speed", speed, SpeedDisplay_LastSlot-1, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateIntMax(_descr, "currency", currency.length(), 7, _checker, __FILE__, __LINE__);
	UINT32 minPlayersFrom; _jparser.validateByNameThrow("minPlayersFrom", minPlayersFrom);
	AtfValidator::validateIntMax(_descr, "minPlayersFrom", minPlayersFrom, 1000000, _checker, __FILE__, __LINE__);
	UINT32 minPlayersTo; _jparser.validateByNameThrow("minPlayersTo", minPlayersTo);
	AtfValidator::validateIntMax(_descr, "minPlayersTo", minPlayersTo, 1000000, _checker, __FILE__, __LINE__);
	UINT32 minBuyIn; _jparser.validateByNameThrow("minBuyIn", minBuyIn);
	AtfValidator::validateIntMax(_descr, "minBuyIn", minBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 maxBuyIn; _jparser.validateByNameThrow("maxBuyIn", maxBuyIn);
	AtfValidator::validateIntMax(_descr, "maxBuyIn", maxBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TableSize > tableSizes; _jparser.validateByNameThrow("tableSizes", tableSizes);
	AtfValidator::validateIntMax(_descr, "tableSizes", tableSizes.size(), 10240, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CLI_LOBBY_FIND_QUICKSTART_SNG";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 sngId; _parser.parseUINT32(sngId);
	AtfValidator::validateInt(_descr, "sngId", sngId, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateIntRange(_descr, "game", game, HandTypeNone, HandType_Last, _checker, __FILE__, __LINE__);
	BYTE hiLo; _parser.parseBYTE(hiLo);
	AtfValidator::validateIntMax(_descr, "hiLo", hiLo, 1, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateIntRange(_descr, "structure", structure, StructLimit, PotStruct_Last, _checker, __FILE__, __LINE__);
	BYTE speed; _parser.parseBYTE(speed);
	AtfValidator::validateIntMax(_descr, "speed", speed, SpeedDisplay_LastSlot-1, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, 7, _checker, __FILE__, __LINE__);
	UINT32 minPlayersFrom; _parser.parseUINT32(minPlayersFrom);
	AtfValidator::validateIntMax(_descr, "minPlayersFrom", minPlayersFrom, 1000000, _checker, __FILE__, __LINE__);
	UINT32 minPlayersTo; _parser.parseUINT32(minPlayersTo);
	AtfValidator::validateIntMax(_descr, "minPlayersTo", minPlayersTo, 1000000, _checker, __FILE__, __LINE__);
	UINT32 minBuyIn; _parser.parseUINT32(minBuyIn);
	AtfValidator::validateIntMax(_descr, "minBuyIn", minBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 maxBuyIn; _parser.parseUINT32(maxBuyIn);
	AtfValidator::validateIntMax(_descr, "maxBuyIn", maxBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 flags; _parser.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTableSizes = Atf::LAtfVector< TableSize, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableSizes"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "tableSizes", szTableSizes, 10240, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY(Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY&& _o)
	: sngId(std::move(_o.sngId))
	, errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, tournId(std::move(_o.tournId))
	, server(std::move(_o.server))
	, tournFlags(std::move(_o.tournFlags))
	, tournFlagsServInt(std::move(_o.tournFlagsServInt))
	, isStarted(std::move(_o.isStarted))
{
}

Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY& Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY::operator=(Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY&& _o)
{
	if(this != &_o)
	{
		sngId = std::move(_o.sngId);
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		tournId = std::move(_o.tournId);
		server = std::move(_o.server);
		tournFlags = std::move(_o.tournFlags);
		tournFlagsServInt = std::move(_o.tournFlagsServInt);
		isStarted = std::move(_o.isStarted);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY::clear()
{
	sngId = 0;
	errCode = 0;
	errDesc.clear();
	tournId = 0;
	server.clear();
	tournFlags = 0;
	tournFlagsServInt = 0;
	isStarted = false;
}

bool Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY::equals(const Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY& _o) const
{
	return sngId == _o.sngId &&
		errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		tournId == _o.tournId &&
		Atf::atfPStringEquals(server, _o.server) &&
		tournFlags == _o.tournFlags &&
		tournFlagsServInt == _o.tournFlagsServInt &&
		isStarted == _o.isStarted;
}

bool Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY).append(")");
	_buf.append(',');
	_buf.append("sngId=");
	_buf.appendUint(sngId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("tournId=");
		_buf.appendUint(tournId);
		_buf.append(',');
		_buf.append("server=");
		_buf.append(server);
		_buf.append(',');
		_buf.append("tournFlags=");
		_buf.appendUint(tournFlags);
		_buf.append(',');
		_buf.append("tournFlagsServInt=");
		_buf.appendUint(tournFlagsServInt);
		_buf.append(',');
		_buf.append("isStarted=");
		_buf.appendUint(isStarted);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("sngId", sngId, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
		Atf::XmlElement::encodeAsXmlElement("server", server, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournFlags", tournFlags, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournFlagsServInt", tournFlagsServInt, _buf);
		Atf::XmlElement::encodeAsXmlElement("isStarted", isStarted, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("sngId"))
			{
				sngId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("tournId"))
			{
				tournId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("server"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, server)) return false;
			}
			else if (_element.equals("tournFlags"))
			{
				tournFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournFlagsServInt"))
			{
				tournFlagsServInt = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isStarted"))
			{
				isStarted = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(sngId);
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeUINT32(tournId);
		_msg.composeString(server);
		_msg.composeUINT32(tournFlags);
		_msg.composeUINT32(tournFlagsServInt);
		_msg.composeBOOL(isStarted);
	}
}

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(sngId);
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseUINT32(tournId);
		_parser.parseStringP(server);
		_parser.parseUINT32(tournFlags);
		_parser.parseUINT32(tournFlagsServInt);
		_parser.parseBOOL(isStarted);
	}
}

const char *Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("sngId", sngId);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("tournId", tournId);
		_jsonstr.compose("server", server);
		_jsonstr.compose("tournFlags", tournFlags);
		_jsonstr.compose("tournFlagsServInt", tournFlagsServInt);
		_jsonstr.compose("isStarted", isStarted);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("sngId", sngId);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("tournId", tournId);
		_jparser.parseByNameThrow("server", server);
		_jparser.parseByNameThrow("tournFlags", tournFlags);
		_jparser.parseByNameThrow("tournFlagsServInt", tournFlagsServInt);
		_jparser.parseByNameThrow("isStarted", isStarted);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	UINT32 sngId; _jparser.validateByNameThrow("sngId", sngId);
	AtfValidator::validateInt(_descr, "sngId", sngId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
		AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
		PString server; _jparser.validateByNameThrow("server", server);
		AtfValidator::validateInt(_descr, "server", server.length(), _checker, __FILE__, __LINE__);
		UINT32 tournFlags; _jparser.validateByNameThrow("tournFlags", tournFlags);
		AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
		UINT32 tournFlagsServInt; _jparser.validateByNameThrow("tournFlagsServInt", tournFlagsServInt);
		AtfValidator::validateInt(_descr, "tournFlagsServInt", tournFlagsServInt, _checker, __FILE__, __LINE__);
		bool isStarted; _jparser.validateByNameThrow("isStarted", isStarted);
		AtfValidator::validateInt(_descr, "isStarted", isStarted, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	UINT32 sngId; _parser.parseUINT32(sngId);
	AtfValidator::validateInt(_descr, "sngId", sngId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 tournId; _parser.parseUINT32(tournId);
		AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
		UINT32 tournFlags; _parser.parseUINT32(tournFlags);
		AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
		UINT32 tournFlagsServInt; _parser.parseUINT32(tournFlagsServInt);
		AtfValidator::validateInt(_descr, "tournFlagsServInt", tournFlagsServInt, _checker, __FILE__, __LINE__);
		bool isStarted; _parser.parseBOOL(isStarted);
		AtfValidator::validateInt(_descr, "isStarted", isStarted, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    DurationSize
//=================================================================

Lobby::cli::DurationSize::DurationSize()
{
	clear();
}

void Lobby::cli::DurationSize::clear()
{
	minD = 0;
	maxD = 0;
}

bool Lobby::cli::DurationSize::equals(const DurationSize& _o) const
{
	return minD == _o.minD &&
		maxD == _o.maxD;
}

const char *Lobby::cli::DurationSize::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("minD=");
	_buf.appendUint(minD);
	_buf.append(',');
	_buf.append("maxD=");
	_buf.appendUint(maxD);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::DurationSize::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("minD", minD, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxD", maxD, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::DurationSize::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("minD"))
		{
			minD = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxD"))
		{
			maxD = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::DurationSize::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT16(minD);
	_msg.composeUINT16(maxD);
}

void Lobby::cli::DurationSize::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT16(minD);
	_parser.parseUINT16(maxD);
}

const char *Lobby::cli::DurationSize::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("minD", minD);
	_jsonstr.compose("maxD", maxD);
	return _buf.c_str();
}

void Lobby::cli::DurationSize::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("minD", minD);
	_jparser.parseByNameThrow("maxD", maxD);
}

/* static */ void Lobby::cli::DurationSize::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT16 minD; _jparser.validateByNameThrow("minD", minD);
	AtfValidator::validateInt(_descr, "minD", minD, _checker, __FILE__, __LINE__);
	UINT16 maxD; _jparser.validateByNameThrow("maxD", maxD);
	AtfValidator::validateInt(_descr, "maxD", maxD, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::DurationSize::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT16 minD; _parser.parseUINT16(minD);
	AtfValidator::validateInt(_descr, "minD", minD, _checker, __FILE__, __LINE__);
	UINT16 maxD; _parser.parseUINT16(maxD);
	AtfValidator::validateInt(_descr, "maxD", maxD, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2
//=================================================================

Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2(Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2&& _o)
	: sngId(std::move(_o.sngId))
	, game(std::move(_o.game))
	, hiLo(std::move(_o.hiLo))
	, structure(std::move(_o.structure))
	, minPlayersFrom(std::move(_o.minPlayersFrom))
	, minPlayersTo(std::move(_o.minPlayersTo))
	, minBuyIn(std::move(_o.minBuyIn))
	, maxBuyIn(std::move(_o.maxBuyIn))
	, flags(std::move(_o.flags))
	, tableSizes(std::move(_o.tableSizes))
	, durationSizes(std::move(_o.durationSizes))
{
}

Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2& Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2::operator=(Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2&& _o)
{
	if(this != &_o)
	{
		sngId = std::move(_o.sngId);
		game = std::move(_o.game);
		hiLo = std::move(_o.hiLo);
		structure = std::move(_o.structure);
		minPlayersFrom = std::move(_o.minPlayersFrom);
		minPlayersTo = std::move(_o.minPlayersTo);
		minBuyIn = std::move(_o.minBuyIn);
		maxBuyIn = std::move(_o.maxBuyIn);
		flags = std::move(_o.flags);
		tableSizes = std::move(_o.tableSizes);
		durationSizes = std::move(_o.durationSizes);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2::clear()
{
	sngId = 0;
	game = 0;
	hiLo = 0;
	structure = 0;
	minPlayersFrom = 0;
	minPlayersTo = 0;
	minBuyIn = 0;
	maxBuyIn = 0;
	flags = 0;
	tableSizes.clear();
	durationSizes.clear();
}

bool Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2::equals(const Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2& _o) const
{
	return sngId == _o.sngId &&
		game == _o.game &&
		hiLo == _o.hiLo &&
		structure == _o.structure &&
		minPlayersFrom == _o.minPlayersFrom &&
		minPlayersTo == _o.minPlayersTo &&
		minBuyIn == _o.minBuyIn &&
		maxBuyIn == _o.maxBuyIn &&
		flags == _o.flags &&
		tableSizes.equals(_o.tableSizes) &&
		durationSizes.equals(_o.durationSizes);
}

bool Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2*)_other));
}

const char *Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2).append(")");
	_buf.append(',');
	_buf.append("sngId=");
	_buf.appendUint(sngId);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("hiLo=");
	_buf.appendUint(hiLo);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("minPlayersFrom=");
	_buf.appendUint(minPlayersFrom);
	_buf.append(',');
	_buf.append("minPlayersTo=");
	_buf.appendUint(minPlayersTo);
	_buf.append(',');
	_buf.append("minBuyIn=");
	_buf.appendUint64(minBuyIn);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendUint64(maxBuyIn);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("tableSizes=");
	tableSizes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("durationSizes=");
	durationSizes.toTraceString(_buf);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("sngId", sngId, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("hiLo", hiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("minPlayersFrom", minPlayersFrom, _buf);
	Atf::XmlElement::encodeAsXmlElement("minPlayersTo", minPlayersTo, _buf);
	Atf::XmlElement::encodeAsXmlElement("minBuyIn", minBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxBuyIn", maxBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	tableSizes.toXmlString("tableSizes", _buf);
	durationSizes.toXmlString("durationSizes", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("sngId"))
			{
				sngId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("game"))
			{
				game = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("hiLo"))
			{
				hiLo = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("structure"))
			{
				structure = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minPlayersFrom"))
			{
				minPlayersFrom = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minPlayersTo"))
			{
				minPlayersTo = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minBuyIn"))
			{
				minBuyIn = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxBuyIn"))
			{
				maxBuyIn = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("flags"))
			{
				flags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tableSizes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TableSize, 4 > >::FromXmlString(_value, tableSizes)) return false;
			}
			else if (_element.equals("durationSizes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< DurationSize, 4 > >::FromXmlString(_value, durationSizes)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(sngId);
	_msg.composeBYTE(game);
	_msg.composeBYTE(hiLo);
	_msg.composeBYTE(structure);
	_msg.composeUINT32(minPlayersFrom);
	_msg.composeUINT32(minPlayersTo);
	_msg.composeUINT64(minBuyIn);
	_msg.composeUINT64(maxBuyIn);
	_msg.composeUINT32(flags);
	tableSizes.composeMsg(_msg, _ignoreJSON);
	durationSizes.composeMsg(_msg, _ignoreJSON);
}

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(sngId);
	_parser.parseBYTE(game);
	_parser.parseBYTE(hiLo);
	_parser.parseBYTE(structure);
	_parser.parseUINT32(minPlayersFrom);
	_parser.parseUINT32(minPlayersTo);
	_parser.parseUINT64(minBuyIn);
	_parser.parseUINT64(maxBuyIn);
	_parser.parseUINT32(flags);
	tableSizes.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	durationSizes.parseMsg(_parser);
}

const char *Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("sngId", sngId);
	_jsonstr.compose("game", game);
	_jsonstr.compose("hiLo", hiLo);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("minPlayersFrom", minPlayersFrom);
	_jsonstr.compose("minPlayersTo", minPlayersTo);
	_jsonstr.compose("minBuyIn", minBuyIn);
	_jsonstr.compose("maxBuyIn", maxBuyIn);
	_jsonstr.compose("flags", flags);
	_jsonstr.compose("tableSizes", tableSizes);
	_jsonstr.compose("durationSizes", durationSizes);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("sngId", sngId);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("hiLo", hiLo);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("minPlayersFrom", minPlayersFrom);
	_jparser.parseByNameThrow("minPlayersTo", minPlayersTo);
	_jparser.parseByNameThrow("minBuyIn", minBuyIn);
	_jparser.parseByNameThrow("maxBuyIn", maxBuyIn);
	_jparser.parseByNameThrow("flags", flags);
	_jparser.parseByNameThrow("tableSizes", tableSizes);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("durationSizes", durationSizes);
}

/*static*/ void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 sngId; _jparser.validateByNameThrow("sngId", sngId);
	AtfValidator::validateInt(_descr, "sngId", sngId, _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateIntRange(_descr, "game", game, HandTypeNone, HandType_Last, _checker, __FILE__, __LINE__);
	BYTE hiLo; _jparser.validateByNameThrow("hiLo", hiLo);
	AtfValidator::validateIntMax(_descr, "hiLo", hiLo, 1, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateIntRange(_descr, "structure", structure, StructLimit, PotStruct_Last, _checker, __FILE__, __LINE__);
	UINT32 minPlayersFrom; _jparser.validateByNameThrow("minPlayersFrom", minPlayersFrom);
	AtfValidator::validateIntMax(_descr, "minPlayersFrom", minPlayersFrom, 1000000, _checker, __FILE__, __LINE__);
	UINT32 minPlayersTo; _jparser.validateByNameThrow("minPlayersTo", minPlayersTo);
	AtfValidator::validateIntMax(_descr, "minPlayersTo", minPlayersTo, 1000000, _checker, __FILE__, __LINE__);
	UINT64 minBuyIn; _jparser.validateByNameThrow("minBuyIn", minBuyIn);
	AtfValidator::validateUintMax(_descr, "minBuyIn", minBuyIn, 1000000000000ull, _checker, __FILE__, __LINE__);
	UINT64 maxBuyIn; _jparser.validateByNameThrow("maxBuyIn", maxBuyIn);
	AtfValidator::validateUintMax(_descr, "maxBuyIn", maxBuyIn, 1000000000000ull, _checker, __FILE__, __LINE__);
	UINT32 flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateIntMax(_descr, "flags", flags, (qsftSpeedDisplayLast*2-1), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TableSize > tableSizes; _jparser.validateByNameThrow("tableSizes", tableSizes);
	AtfValidator::validateIntMax(_descr, "tableSizes", tableSizes.size(), 10240, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	Atf::AtfVectorBase< DurationSize > durationSizes; _jparser.validateByNameThrow("durationSizes", durationSizes);
	AtfValidator::validateIntMax(_descr, "durationSizes", durationSizes.size(), 10240, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 sngId; _parser.parseUINT32(sngId);
	AtfValidator::validateInt(_descr, "sngId", sngId, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateIntRange(_descr, "game", game, HandTypeNone, HandType_Last, _checker, __FILE__, __LINE__);
	BYTE hiLo; _parser.parseBYTE(hiLo);
	AtfValidator::validateIntMax(_descr, "hiLo", hiLo, 1, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateIntRange(_descr, "structure", structure, StructLimit, PotStruct_Last, _checker, __FILE__, __LINE__);
	UINT32 minPlayersFrom; _parser.parseUINT32(minPlayersFrom);
	AtfValidator::validateIntMax(_descr, "minPlayersFrom", minPlayersFrom, 1000000, _checker, __FILE__, __LINE__);
	UINT32 minPlayersTo; _parser.parseUINT32(minPlayersTo);
	AtfValidator::validateIntMax(_descr, "minPlayersTo", minPlayersTo, 1000000, _checker, __FILE__, __LINE__);
	UINT64 minBuyIn; _parser.parseUINT64(minBuyIn);
	AtfValidator::validateUintMax(_descr, "minBuyIn", minBuyIn, 1000000000000ull, _checker, __FILE__, __LINE__);
	UINT64 maxBuyIn; _parser.parseUINT64(maxBuyIn);
	AtfValidator::validateUintMax(_descr, "maxBuyIn", maxBuyIn, 1000000000000ull, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser.parseUINT32(flags);
	AtfValidator::validateIntMax(_descr, "flags", flags, (qsftSpeedDisplayLast*2-1), _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTableSizes = Atf::LAtfVector< TableSize, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableSizes"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "tableSizes", szTableSizes, 10240, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	int szDurationSizes = Atf::LAtfVector< DurationSize, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("durationSizes"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "durationSizes", szDurationSizes, 10240, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY(Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY&& _o)
	: sngId(std::move(_o.sngId))
	, errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, tournId(std::move(_o.tournId))
	, server(std::move(_o.server))
	, tournFlags(std::move(_o.tournFlags))
	, tournFlagsServInt(std::move(_o.tournFlagsServInt))
	, sngScriptId(std::move(_o.sngScriptId))
	, isStarted(std::move(_o.isStarted))
{
}

Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY& Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY::operator=(Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY&& _o)
{
	if(this != &_o)
	{
		sngId = std::move(_o.sngId);
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		tournId = std::move(_o.tournId);
		server = std::move(_o.server);
		tournFlags = std::move(_o.tournFlags);
		tournFlagsServInt = std::move(_o.tournFlagsServInt);
		sngScriptId = std::move(_o.sngScriptId);
		isStarted = std::move(_o.isStarted);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY::clear()
{
	sngId = 0;
	errCode = 0;
	errDesc.clear();
	tournId = 0;
	server.clear();
	tournFlags = 0;
	tournFlagsServInt = 0;
	sngScriptId = 0;
	isStarted = false;
}

bool Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY::equals(const Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY& _o) const
{
	return sngId == _o.sngId &&
		errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		tournId == _o.tournId &&
		Atf::atfPStringEquals(server, _o.server) &&
		tournFlags == _o.tournFlags &&
		tournFlagsServInt == _o.tournFlagsServInt &&
		sngScriptId == _o.sngScriptId &&
		isStarted == _o.isStarted;
}

bool Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY).append(")");
	_buf.append(',');
	_buf.append("sngId=");
	_buf.appendUint(sngId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("tournId=");
		_buf.appendUint(tournId);
		_buf.append(',');
		_buf.append("server=");
		_buf.append(server);
		_buf.append(',');
		_buf.append("tournFlags=");
		_buf.appendUint(tournFlags);
		_buf.append(',');
		_buf.append("tournFlagsServInt=");
		_buf.appendUint(tournFlagsServInt);
		_buf.append(',');
		_buf.append("sngScriptId=");
		_buf.appendUint(sngScriptId);
		_buf.append(',');
		_buf.append("isStarted=");
		_buf.appendUint(isStarted);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("sngId", sngId, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
		Atf::XmlElement::encodeAsXmlElement("server", server, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournFlags", tournFlags, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournFlagsServInt", tournFlagsServInt, _buf);
		Atf::XmlElement::encodeAsXmlElement("sngScriptId", sngScriptId, _buf);
		Atf::XmlElement::encodeAsXmlElement("isStarted", isStarted, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("sngId"))
			{
				sngId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("tournId"))
			{
				tournId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("server"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, server)) return false;
			}
			else if (_element.equals("tournFlags"))
			{
				tournFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournFlagsServInt"))
			{
				tournFlagsServInt = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("sngScriptId"))
			{
				sngScriptId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isStarted"))
			{
				isStarted = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(sngId);
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeUINT32(tournId);
		_msg.composeString(server);
		_msg.composeUINT32(tournFlags);
		_msg.composeUINT32(tournFlagsServInt);
		_msg.composeUINT32(sngScriptId);
		_msg.composeBOOL(isStarted);
	}
}

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(sngId);
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseUINT32(tournId);
		_parser.parseStringP(server);
		_parser.parseUINT32(tournFlags);
		_parser.parseUINT32(tournFlagsServInt);
		_parser.parseUINT32(sngScriptId);
		_parser.parseBOOL(isStarted);
	}
}

const char *Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("sngId", sngId);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("tournId", tournId);
		_jsonstr.compose("server", server);
		_jsonstr.compose("tournFlags", tournFlags);
		_jsonstr.compose("tournFlagsServInt", tournFlagsServInt);
		_jsonstr.compose("sngScriptId", sngScriptId);
		_jsonstr.compose("isStarted", isStarted);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("sngId", sngId);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("tournId", tournId);
		_jparser.parseByNameThrow("server", server);
		_jparser.parseByNameThrow("tournFlags", tournFlags);
		_jparser.parseByNameThrow("tournFlagsServInt", tournFlagsServInt);
		_jparser.parseByNameThrow("sngScriptId", sngScriptId);
		_jparser.parseByNameThrow("isStarted", isStarted);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	UINT32 sngId; _jparser.validateByNameThrow("sngId", sngId);
	AtfValidator::validateInt(_descr, "sngId", sngId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
		AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
		PString server; _jparser.validateByNameThrow("server", server);
		AtfValidator::validateInt(_descr, "server", server.length(), _checker, __FILE__, __LINE__);
		UINT32 tournFlags; _jparser.validateByNameThrow("tournFlags", tournFlags);
		AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
		UINT32 tournFlagsServInt; _jparser.validateByNameThrow("tournFlagsServInt", tournFlagsServInt);
		AtfValidator::validateInt(_descr, "tournFlagsServInt", tournFlagsServInt, _checker, __FILE__, __LINE__);
		UINT32 sngScriptId; _jparser.validateByNameThrow("sngScriptId", sngScriptId);
		AtfValidator::validateInt(_descr, "sngScriptId", sngScriptId, _checker, __FILE__, __LINE__);
		bool isStarted; _jparser.validateByNameThrow("isStarted", isStarted);
		AtfValidator::validateInt(_descr, "isStarted", isStarted, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	UINT32 sngId; _parser.parseUINT32(sngId);
	AtfValidator::validateInt(_descr, "sngId", sngId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 tournId; _parser.parseUINT32(tournId);
		AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
		UINT32 tournFlags; _parser.parseUINT32(tournFlags);
		AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
		UINT32 tournFlagsServInt; _parser.parseUINT32(tournFlagsServInt);
		AtfValidator::validateInt(_descr, "tournFlagsServInt", tournFlagsServInt, _checker, __FILE__, __LINE__);
		UINT32 sngScriptId; _parser.parseUINT32(sngScriptId);
		AtfValidator::validateInt(_descr, "sngScriptId", sngScriptId, _checker, __FILE__, __LINE__);
		bool isStarted; _parser.parseBOOL(isStarted);
		AtfValidator::validateInt(_descr, "isStarted", isStarted, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3
//=================================================================

Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3(Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3&& _o)
	: sngId(std::move(_o.sngId))
	, game(std::move(_o.game))
	, hiLo(std::move(_o.hiLo))
	, structure(std::move(_o.structure))
	, minPlayersFrom(std::move(_o.minPlayersFrom))
	, minPlayersTo(std::move(_o.minPlayersTo))
	, minBuyIn(std::move(_o.minBuyIn))
	, maxBuyIn(std::move(_o.maxBuyIn))
	, flags(std::move(_o.flags))
	, tableSizes(std::move(_o.tableSizes))
	, durationSizes(std::move(_o.durationSizes))
{
}

Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3& Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3::operator=(Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3&& _o)
{
	if(this != &_o)
	{
		sngId = std::move(_o.sngId);
		game = std::move(_o.game);
		hiLo = std::move(_o.hiLo);
		structure = std::move(_o.structure);
		minPlayersFrom = std::move(_o.minPlayersFrom);
		minPlayersTo = std::move(_o.minPlayersTo);
		minBuyIn = std::move(_o.minBuyIn);
		maxBuyIn = std::move(_o.maxBuyIn);
		flags = std::move(_o.flags);
		tableSizes = std::move(_o.tableSizes);
		durationSizes = std::move(_o.durationSizes);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3::clear()
{
	sngId = 0;
	game = 0;
	hiLo = 0;
	structure = 0;
	minPlayersFrom = 0;
	minPlayersTo = 0;
	minBuyIn = 0;
	maxBuyIn = 0;
	flags = 0;
	tableSizes.clear();
	durationSizes.clear();
}

bool Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3::equals(const Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3& _o) const
{
	return sngId == _o.sngId &&
		game == _o.game &&
		hiLo == _o.hiLo &&
		structure == _o.structure &&
		minPlayersFrom == _o.minPlayersFrom &&
		minPlayersTo == _o.minPlayersTo &&
		minBuyIn == _o.minBuyIn &&
		maxBuyIn == _o.maxBuyIn &&
		flags == _o.flags &&
		tableSizes.equals(_o.tableSizes) &&
		durationSizes.equals(_o.durationSizes);
}

bool Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3*)_other));
}

const char *Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3).append(")");
	_buf.append(',');
	_buf.append("sngId=");
	_buf.appendUint(sngId);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("hiLo=");
	_buf.appendUint(hiLo);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("minPlayersFrom=");
	_buf.appendUint(minPlayersFrom);
	_buf.append(',');
	_buf.append("minPlayersTo=");
	_buf.appendUint(minPlayersTo);
	_buf.append(',');
	_buf.append("minBuyIn=");
	_buf.appendUint64(minBuyIn);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendUint64(maxBuyIn);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("tableSizes=");
	tableSizes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("durationSizes=");
	durationSizes.toTraceString(_buf);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("sngId", sngId, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("hiLo", hiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("minPlayersFrom", minPlayersFrom, _buf);
	Atf::XmlElement::encodeAsXmlElement("minPlayersTo", minPlayersTo, _buf);
	Atf::XmlElement::encodeAsXmlElement("minBuyIn", minBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxBuyIn", maxBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	tableSizes.toXmlString("tableSizes", _buf);
	durationSizes.toXmlString("durationSizes", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("sngId"))
			{
				sngId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("game"))
			{
				game = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("hiLo"))
			{
				hiLo = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("structure"))
			{
				structure = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minPlayersFrom"))
			{
				minPlayersFrom = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minPlayersTo"))
			{
				minPlayersTo = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minBuyIn"))
			{
				minBuyIn = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxBuyIn"))
			{
				maxBuyIn = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("flags"))
			{
				flags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tableSizes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TableSize, 4 > >::FromXmlString(_value, tableSizes)) return false;
			}
			else if (_element.equals("durationSizes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< DurationSize, 4 > >::FromXmlString(_value, durationSizes)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(sngId);
	_msg.composeBYTE(game);
	_msg.composeBYTE(hiLo);
	_msg.composeBYTE(structure);
	_msg.composeUINT32(minPlayersFrom);
	_msg.composeUINT32(minPlayersTo);
	_msg.composeUINT64(minBuyIn);
	_msg.composeUINT64(maxBuyIn);
	_msg.composeUINT32(flags);
	tableSizes.composeMsg(_msg, _ignoreJSON);
	durationSizes.composeMsg(_msg, _ignoreJSON);
}

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(sngId);
	_parser.parseBYTE(game);
	_parser.parseBYTE(hiLo);
	_parser.parseBYTE(structure);
	_parser.parseUINT32(minPlayersFrom);
	_parser.parseUINT32(minPlayersTo);
	_parser.parseUINT64(minBuyIn);
	_parser.parseUINT64(maxBuyIn);
	_parser.parseUINT32(flags);
	tableSizes.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	durationSizes.parseMsg(_parser);
}

const char *Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("sngId", sngId);
	_jsonstr.compose("game", game);
	_jsonstr.compose("hiLo", hiLo);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("minPlayersFrom", minPlayersFrom);
	_jsonstr.compose("minPlayersTo", minPlayersTo);
	_jsonstr.compose("minBuyIn", minBuyIn);
	_jsonstr.compose("maxBuyIn", maxBuyIn);
	_jsonstr.compose("flags", flags);
	_jsonstr.compose("tableSizes", tableSizes);
	_jsonstr.compose("durationSizes", durationSizes);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("sngId", sngId);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("hiLo", hiLo);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("minPlayersFrom", minPlayersFrom);
	_jparser.parseByNameThrow("minPlayersTo", minPlayersTo);
	_jparser.parseByNameThrow("minBuyIn", minBuyIn);
	_jparser.parseByNameThrow("maxBuyIn", maxBuyIn);
	_jparser.parseByNameThrow("flags", flags);
	_jparser.parseByNameThrow("tableSizes", tableSizes);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("durationSizes", durationSizes);
}

/*static*/ void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 sngId; _jparser.validateByNameThrow("sngId", sngId);
	AtfValidator::validateInt(_descr, "sngId", sngId, _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateIntRange(_descr, "game", game, HandTypeNone, HandType_Last, _checker, __FILE__, __LINE__);
	BYTE hiLo; _jparser.validateByNameThrow("hiLo", hiLo);
	AtfValidator::validateIntMax(_descr, "hiLo", hiLo, 1, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateIntMax(_descr, "structure", structure, PotStruct_Last, _checker, __FILE__, __LINE__);
	UINT32 minPlayersFrom; _jparser.validateByNameThrow("minPlayersFrom", minPlayersFrom);
	AtfValidator::validateIntMax(_descr, "minPlayersFrom", minPlayersFrom, 1000000, _checker, __FILE__, __LINE__);
	UINT32 minPlayersTo; _jparser.validateByNameThrow("minPlayersTo", minPlayersTo);
	AtfValidator::validateIntMax(_descr, "minPlayersTo", minPlayersTo, 1000000, _checker, __FILE__, __LINE__);
	UINT64 minBuyIn; _jparser.validateByNameThrow("minBuyIn", minBuyIn);
	AtfValidator::validateUintMax(_descr, "minBuyIn", minBuyIn, 1000000000000ull, _checker, __FILE__, __LINE__);
	UINT64 maxBuyIn; _jparser.validateByNameThrow("maxBuyIn", maxBuyIn);
	AtfValidator::validateUintMax(_descr, "maxBuyIn", maxBuyIn, 1000000000000ull, _checker, __FILE__, __LINE__);
	UINT32 flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateIntMax(_descr, "flags", flags, (qsftSpeedDisplayLast*2-1), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TableSize > tableSizes; _jparser.validateByNameThrow("tableSizes", tableSizes);
	AtfValidator::validateIntMax(_descr, "tableSizes", tableSizes.size(), 10240, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	Atf::AtfVectorBase< DurationSize > durationSizes; _jparser.validateByNameThrow("durationSizes", durationSizes);
	AtfValidator::validateIntMax(_descr, "durationSizes", durationSizes.size(), 10240, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 sngId; _parser.parseUINT32(sngId);
	AtfValidator::validateInt(_descr, "sngId", sngId, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateIntRange(_descr, "game", game, HandTypeNone, HandType_Last, _checker, __FILE__, __LINE__);
	BYTE hiLo; _parser.parseBYTE(hiLo);
	AtfValidator::validateIntMax(_descr, "hiLo", hiLo, 1, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateIntMax(_descr, "structure", structure, PotStruct_Last, _checker, __FILE__, __LINE__);
	UINT32 minPlayersFrom; _parser.parseUINT32(minPlayersFrom);
	AtfValidator::validateIntMax(_descr, "minPlayersFrom", minPlayersFrom, 1000000, _checker, __FILE__, __LINE__);
	UINT32 minPlayersTo; _parser.parseUINT32(minPlayersTo);
	AtfValidator::validateIntMax(_descr, "minPlayersTo", minPlayersTo, 1000000, _checker, __FILE__, __LINE__);
	UINT64 minBuyIn; _parser.parseUINT64(minBuyIn);
	AtfValidator::validateUintMax(_descr, "minBuyIn", minBuyIn, 1000000000000ull, _checker, __FILE__, __LINE__);
	UINT64 maxBuyIn; _parser.parseUINT64(maxBuyIn);
	AtfValidator::validateUintMax(_descr, "maxBuyIn", maxBuyIn, 1000000000000ull, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser.parseUINT32(flags);
	AtfValidator::validateIntMax(_descr, "flags", flags, (qsftSpeedDisplayLast*2-1), _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTableSizes = Atf::LAtfVector< TableSize, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableSizes"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "tableSizes", szTableSizes, 10240, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	int szDurationSizes = Atf::LAtfVector< DurationSize, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("durationSizes"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "durationSizes", szDurationSizes, 10240, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY(Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY&& _o)
	: sngId(std::move(_o.sngId))
	, errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, tournId(std::move(_o.tournId))
	, server(std::move(_o.server))
	, tournFlags(std::move(_o.tournFlags))
	, tournFlagsServInt(std::move(_o.tournFlagsServInt))
	, sngScriptId(std::move(_o.sngScriptId))
	, isStarted(std::move(_o.isStarted))
{
}

Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY& Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY::operator=(Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY&& _o)
{
	if(this != &_o)
	{
		sngId = std::move(_o.sngId);
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		tournId = std::move(_o.tournId);
		server = std::move(_o.server);
		tournFlags = std::move(_o.tournFlags);
		tournFlagsServInt = std::move(_o.tournFlagsServInt);
		sngScriptId = std::move(_o.sngScriptId);
		isStarted = std::move(_o.isStarted);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY::clear()
{
	sngId = 0;
	errCode = 0;
	errDesc.clear();
	tournId = 0;
	server.clear();
	tournFlags = 0;
	tournFlagsServInt = 0;
	sngScriptId = 0;
	isStarted = false;
}

bool Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY::equals(const Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY& _o) const
{
	return sngId == _o.sngId &&
		errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		tournId == _o.tournId &&
		Atf::atfPStringEquals(server, _o.server) &&
		tournFlags == _o.tournFlags &&
		tournFlagsServInt == _o.tournFlagsServInt &&
		sngScriptId == _o.sngScriptId &&
		isStarted == _o.isStarted;
}

bool Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY).append(")");
	_buf.append(',');
	_buf.append("sngId=");
	_buf.appendUint(sngId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("tournId=");
		_buf.appendUint(tournId);
		_buf.append(',');
		_buf.append("server=");
		_buf.append(server);
		_buf.append(',');
		_buf.append("tournFlags=");
		_buf.appendUint(tournFlags);
		_buf.append(',');
		_buf.append("tournFlagsServInt=");
		_buf.appendUint(tournFlagsServInt);
		_buf.append(',');
		_buf.append("sngScriptId=");
		_buf.appendUint(sngScriptId);
		_buf.append(',');
		_buf.append("isStarted=");
		_buf.appendUint(isStarted);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("sngId", sngId, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
		Atf::XmlElement::encodeAsXmlElement("server", server, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournFlags", tournFlags, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournFlagsServInt", tournFlagsServInt, _buf);
		Atf::XmlElement::encodeAsXmlElement("sngScriptId", sngScriptId, _buf);
		Atf::XmlElement::encodeAsXmlElement("isStarted", isStarted, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("sngId"))
			{
				sngId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("tournId"))
			{
				tournId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("server"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, server)) return false;
			}
			else if (_element.equals("tournFlags"))
			{
				tournFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournFlagsServInt"))
			{
				tournFlagsServInt = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("sngScriptId"))
			{
				sngScriptId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isStarted"))
			{
				isStarted = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(sngId);
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeUINT32(tournId);
		_msg.composeString(server);
		_msg.composeUINT32(tournFlags);
		_msg.composeUINT32(tournFlagsServInt);
		_msg.composeUINT32(sngScriptId);
		_msg.composeBOOL(isStarted);
	}
}

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(sngId);
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseUINT32(tournId);
		_parser.parseStringP(server);
		_parser.parseUINT32(tournFlags);
		_parser.parseUINT32(tournFlagsServInt);
		_parser.parseUINT32(sngScriptId);
		_parser.parseBOOL(isStarted);
	}
}

const char *Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("sngId", sngId);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("tournId", tournId);
		_jsonstr.compose("server", server);
		_jsonstr.compose("tournFlags", tournFlags);
		_jsonstr.compose("tournFlagsServInt", tournFlagsServInt);
		_jsonstr.compose("sngScriptId", sngScriptId);
		_jsonstr.compose("isStarted", isStarted);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("sngId", sngId);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("tournId", tournId);
		_jparser.parseByNameThrow("server", server);
		_jparser.parseByNameThrow("tournFlags", tournFlags);
		_jparser.parseByNameThrow("tournFlagsServInt", tournFlagsServInt);
		_jparser.parseByNameThrow("sngScriptId", sngScriptId);
		_jparser.parseByNameThrow("isStarted", isStarted);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	UINT32 sngId; _jparser.validateByNameThrow("sngId", sngId);
	AtfValidator::validateInt(_descr, "sngId", sngId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
		AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
		PString server; _jparser.validateByNameThrow("server", server);
		AtfValidator::validateInt(_descr, "server", server.length(), _checker, __FILE__, __LINE__);
		UINT32 tournFlags; _jparser.validateByNameThrow("tournFlags", tournFlags);
		AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
		UINT32 tournFlagsServInt; _jparser.validateByNameThrow("tournFlagsServInt", tournFlagsServInt);
		AtfValidator::validateInt(_descr, "tournFlagsServInt", tournFlagsServInt, _checker, __FILE__, __LINE__);
		UINT32 sngScriptId; _jparser.validateByNameThrow("sngScriptId", sngScriptId);
		AtfValidator::validateInt(_descr, "sngScriptId", sngScriptId, _checker, __FILE__, __LINE__);
		bool isStarted; _jparser.validateByNameThrow("isStarted", isStarted);
		AtfValidator::validateInt(_descr, "isStarted", isStarted, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	UINT32 sngId; _parser.parseUINT32(sngId);
	AtfValidator::validateInt(_descr, "sngId", sngId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 tournId; _parser.parseUINT32(tournId);
		AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
		UINT32 tournFlags; _parser.parseUINT32(tournFlags);
		AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
		UINT32 tournFlagsServInt; _parser.parseUINT32(tournFlagsServInt);
		AtfValidator::validateInt(_descr, "tournFlagsServInt", tournFlagsServInt, _checker, __FILE__, __LINE__);
		UINT32 sngScriptId; _parser.parseUINT32(sngScriptId);
		AtfValidator::validateInt(_descr, "sngScriptId", sngScriptId, _checker, __FILE__, __LINE__);
		bool isStarted; _parser.parseBOOL(isStarted);
		AtfValidator::validateInt(_descr, "isStarted", isStarted, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT(Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT&& _o)
	: tournStatType(std::move(_o.tournStatType))
	, tournIds(std::move(_o.tournIds))
	, handIds(std::move(_o.handIds))
{
}

Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT& Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT::operator=(Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT&& _o)
{
	if(this != &_o)
	{
		tournStatType = std::move(_o.tournStatType);
		tournIds = std::move(_o.tournIds);
		handIds = std::move(_o.handIds);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT::clear()
{
	tournStatType = 0;
	tournIds.clear();
	handIds.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT::equals(const Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT& _o) const
{
	return tournStatType == _o.tournStatType &&
		tournIds.equals(_o.tournIds) &&
		handIds.equals(_o.handIds);
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT).append(")");
	_buf.append(',');
	_buf.append("tournStatType=");
	_buf.appendUint(tournStatType);
	_buf.append(',');
	_buf.append("tournIds=");
	tournIds.toTraceString(_buf);
	_buf.append(',');
	_buf.append("handIds=");
	handIds.toTraceString(_buf);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("tournStatType", tournStatType, _buf);
	tournIds.toXmlString("tournIds", _buf);
	handIds.toXmlString("handIds", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tournStatType"))
			{
				tournStatType = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournIds"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, tournIds)) return false;
			}
			else if (_element.equals("handIds"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT64, 4 > >::FromXmlString(_value, handIds)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(tournStatType);
	tournIds.composeMsg(_msg, _ignoreJSON);
	handIds.composeMsg(_msg, _ignoreJSON);
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(tournStatType);
	tournIds.parseMsg(_parser);
	handIds.parseMsg(_parser);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tournStatType", tournStatType);
	_jsonstr.compose("tournIds", tournIds);
	_jsonstr.compose("handIds", handIds);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tournStatType", tournStatType);
	_jparser.parseByNameThrow("tournIds", tournIds);
	_jparser.parseByNameThrow("handIds", handIds);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE tournStatType; _jparser.validateByNameThrow("tournStatType", tournStatType);
	AtfValidator::validateInt(_descr, "tournStatType", tournStatType, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT32 > tournIds; _jparser.validateByNameThrow("tournIds", tournIds);
	AtfValidator::validateIntMax(_descr, "tournIds", tournIds.size(), 10240, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT64 > handIds; _jparser.validateByNameThrow("handIds", handIds);
	AtfValidator::validateIntMax(_descr, "handIds", handIds.size(), 10240, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE tournStatType; _parser.parseBYTE(tournStatType);
	AtfValidator::validateInt(_descr, "tournStatType", tournStatType, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTournIds = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournIds"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "tournIds", szTournIds, 10240, _checker, __FILE__, __LINE__);
	int szHandIds = Atf::LAtfVector< UINT64, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("handIds"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "handIds", szHandIds, 10240, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY(Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY& Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY::operator=(Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY::equals(const Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc);
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_USER_CAPS
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS::Protocol_MSG_LOBBY_GET_USER_CAPS()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS::clear()
{
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS::equals(const Protocol_MSG_LOBBY_GET_USER_CAPS& _o) const
{
	return true;
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_USER_CAPS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_USER_CAPS*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_USER_CAPS).append(")");
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_USER_CAPS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS::parseMsg(CommMsgParser& _parser)
{
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_USER_CAPS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_USER_CAPS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY(Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, maxTablesLimitPM(std::move(_o.maxTablesLimitPM))
	, maxTablesLimitRM(std::move(_o.maxTablesLimitRM))
{
}

Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY& Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::operator=(Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		maxTablesLimitPM = std::move(_o.maxTablesLimitPM);
		maxTablesLimitRM = std::move(_o.maxTablesLimitRM);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	maxTablesLimitPM = 0;
	maxTablesLimitRM = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::equals(const Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		maxTablesLimitPM == _o.maxTablesLimitPM &&
		maxTablesLimitRM == _o.maxTablesLimitRM;
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_USER_CAPS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_USER_CAPS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("maxTablesLimitPM=");
		_buf.appendUint(maxTablesLimitPM);
		_buf.append(',');
		_buf.append("maxTablesLimitRM=");
		_buf.appendUint(maxTablesLimitRM);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_USER_CAPS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("maxTablesLimitPM", maxTablesLimitPM, _buf);
		Atf::XmlElement::encodeAsXmlElement("maxTablesLimitRM", maxTablesLimitRM, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("maxTablesLimitPM"))
			{
				maxTablesLimitPM = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxTablesLimitRM"))
			{
				maxTablesLimitRM = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeUINT32(maxTablesLimitPM);
		_msg.composeUINT32(maxTablesLimitRM);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseUINT32(maxTablesLimitPM);
		_parser.parseUINT32(maxTablesLimitRM);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("maxTablesLimitPM", maxTablesLimitPM);
		_jsonstr.compose("maxTablesLimitRM", maxTablesLimitRM);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("maxTablesLimitPM", maxTablesLimitPM);
		_jparser.parseByNameThrow("maxTablesLimitRM", maxTablesLimitRM);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_USER_CAPS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 maxTablesLimitPM; _jparser.validateByNameThrow("maxTablesLimitPM", maxTablesLimitPM);
		AtfValidator::validateInt(_descr, "maxTablesLimitPM", maxTablesLimitPM, _checker, __FILE__, __LINE__);
		UINT32 maxTablesLimitRM; _jparser.validateByNameThrow("maxTablesLimitRM", maxTablesLimitRM);
		AtfValidator::validateInt(_descr, "maxTablesLimitRM", maxTablesLimitRM, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_USER_CAPS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 maxTablesLimitPM; _parser.parseUINT32(maxTablesLimitPM);
		AtfValidator::validateInt(_descr, "maxTablesLimitPM", maxTablesLimitPM, _checker, __FILE__, __LINE__);
		UINT32 maxTablesLimitRM; _parser.parseUINT32(maxTablesLimitRM);
		AtfValidator::validateInt(_descr, "maxTablesLimitRM", maxTablesLimitRM, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_DISABLE_SNG_AUTO_UNREG
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_DISABLE_SNG_AUTO_UNREG::Protocol_MSG_LOBBY_DISABLE_SNG_AUTO_UNREG()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_DISABLE_SNG_AUTO_UNREG::clear()
{
	setPriv = false;
}

bool Lobby::cli::Protocol_MSG_LOBBY_DISABLE_SNG_AUTO_UNREG::equals(const Protocol_MSG_LOBBY_DISABLE_SNG_AUTO_UNREG& _o) const
{
	return setPriv == _o.setPriv;
}

bool Lobby::cli::Protocol_MSG_LOBBY_DISABLE_SNG_AUTO_UNREG::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_DISABLE_SNG_AUTO_UNREG != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_DISABLE_SNG_AUTO_UNREG*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_DISABLE_SNG_AUTO_UNREG::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_DISABLE_SNG_AUTO_UNREG).append(")");
	_buf.append(',');
	_buf.append("setPriv=");
	_buf.appendUint(setPriv);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_DISABLE_SNG_AUTO_UNREG::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_DISABLE_SNG_AUTO_UNREG::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_DISABLE_SNG_AUTO_UNREG).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("setPriv", setPriv, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_DISABLE_SNG_AUTO_UNREG::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("setPriv"))
			{
				setPriv = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_DISABLE_SNG_AUTO_UNREG::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(setPriv);
}

void Lobby::cli::Protocol_MSG_LOBBY_DISABLE_SNG_AUTO_UNREG::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(setPriv);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_DISABLE_SNG_AUTO_UNREG::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("setPriv", setPriv);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_DISABLE_SNG_AUTO_UNREG::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("setPriv", setPriv);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_DISABLE_SNG_AUTO_UNREG::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_DISABLE_SNG_AUTO_UNREG";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool setPriv; _jparser.validateByNameThrow("setPriv", setPriv);
	AtfValidator::validateInt(_descr, "setPriv", setPriv, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_DISABLE_SNG_AUTO_UNREG::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_DISABLE_SNG_AUTO_UNREG";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	bool setPriv; _parser.parseBOOL(setPriv);
	AtfValidator::validateInt(_descr, "setPriv", setPriv, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::clear()
{
	onlyTargetBanner = false;
	newsTypeMask = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::equals(const Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP& _o) const
{
	return onlyTargetBanner == _o.onlyTargetBanner &&
		newsTypeMask == _o.newsTypeMask;
}

bool Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_TARGET_NEWS_DESKTOP != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_TARGET_NEWS_DESKTOP).append(")");
	_buf.append(',');
	_buf.append("onlyTargetBanner=");
	_buf.appendUint(onlyTargetBanner);
	_buf.append(',');
	_buf.append("newsTypeMask=");
	_buf.appendUint(newsTypeMask);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_TARGET_NEWS_DESKTOP).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("onlyTargetBanner", onlyTargetBanner, _buf);
	Atf::XmlElement::encodeAsXmlElement("newsTypeMask", newsTypeMask, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("onlyTargetBanner"))
			{
				onlyTargetBanner = (*_value.ptr() == '1');
			}
			else if (_element.equals("newsTypeMask"))
			{
				newsTypeMask = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(onlyTargetBanner);
	_msg.composeUINT32(newsTypeMask);
}

void Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(onlyTargetBanner);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(newsTypeMask);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("onlyTargetBanner", onlyTargetBanner);
	_jsonstr.compose("newsTypeMask", newsTypeMask);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("onlyTargetBanner", onlyTargetBanner);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("newsTypeMask", newsTypeMask);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TARGET_NEWS_DESKTOP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	bool onlyTargetBanner; _jparser.validateByNameThrow("onlyTargetBanner", onlyTargetBanner);
	AtfValidator::validateInt(_descr, "onlyTargetBanner", onlyTargetBanner, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 newsTypeMask; _jparser.validateByNameThrow("newsTypeMask", newsTypeMask);
	AtfValidator::validateIntRange(_descr, "newsTypeMask", newsTypeMask, eTargetNewsGeneral, eTargetNewsAll, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TARGET_NEWS_DESKTOP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(_parser.parseEnded()) return;
	bool onlyTargetBanner; _parser.parseBOOL(onlyTargetBanner);
	AtfValidator::validateInt(_descr, "onlyTargetBanner", onlyTargetBanner, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 newsTypeMask; _parser.parseUINT32(newsTypeMask);
	AtfValidator::validateIntRange(_descr, "newsTypeMask", newsTypeMask, eTargetNewsGeneral, eTargetNewsAll, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::clear()
{
	clientDownloadSource = 0;
	newsProductMask = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::equals(const Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE& _o) const
{
	return clientDownloadSource == _o.clientDownloadSource &&
		newsProductMask == _o.newsProductMask;
}

bool Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_TARGET_NEWS_MOBILE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_TARGET_NEWS_MOBILE).append(")");
	_buf.append(',');
	_buf.append("clientDownloadSource=");
	_buf.appendUint(clientDownloadSource);
	_buf.append(',');
	_buf.append("newsProductMask=");
	_buf.appendUint(newsProductMask);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_TARGET_NEWS_MOBILE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clientDownloadSource", clientDownloadSource, _buf);
	Atf::XmlElement::encodeAsXmlElement("newsProductMask", newsProductMask, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clientDownloadSource"))
			{
				clientDownloadSource = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("newsProductMask"))
			{
				newsProductMask = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clientDownloadSource);
	_msg.composeUINT32(newsProductMask);
}

void Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clientDownloadSource);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(newsProductMask);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clientDownloadSource", clientDownloadSource);
	_jsonstr.compose("newsProductMask", newsProductMask);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clientDownloadSource", clientDownloadSource);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("newsProductMask", newsProductMask);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TARGET_NEWS_MOBILE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clientDownloadSource; _jparser.validateByNameThrow("clientDownloadSource", clientDownloadSource);
	AtfValidator::validateInt(_descr, "clientDownloadSource", clientDownloadSource, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 newsProductMask; _jparser.validateByNameThrow("newsProductMask", newsProductMask);
	AtfValidator::validateIntRange(_descr, "newsProductMask", newsProductMask, eTargetNewsGeneral, eTargetNewsAll, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TARGET_NEWS_MOBILE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clientDownloadSource; _parser.parseUINT32(clientDownloadSource);
	AtfValidator::validateInt(_descr, "clientDownloadSource", clientDownloadSource, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 newsProductMask; _parser.parseUINT32(newsProductMask);
	AtfValidator::validateIntRange(_descr, "newsProductMask", newsProductMask, eTargetNewsGeneral, eTargetNewsAll, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CLI_LOBBY_CONFIRM_POPUP
//=================================================================

Lobby::cli::Protocol_MSG_CLI_LOBBY_CONFIRM_POPUP::Protocol_MSG_CLI_LOBBY_CONFIRM_POPUP()
{
	clear();
}

void Lobby::cli::Protocol_MSG_CLI_LOBBY_CONFIRM_POPUP::clear()
{
	confirmId = 0;
	understood = false;
}

bool Lobby::cli::Protocol_MSG_CLI_LOBBY_CONFIRM_POPUP::equals(const Protocol_MSG_CLI_LOBBY_CONFIRM_POPUP& _o) const
{
	return confirmId == _o.confirmId &&
		understood == _o.understood;
}

bool Lobby::cli::Protocol_MSG_CLI_LOBBY_CONFIRM_POPUP::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CLI_LOBBY_CONFIRM_POPUP != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CLI_LOBBY_CONFIRM_POPUP*)_other));
}

const char *Lobby::cli::Protocol_MSG_CLI_LOBBY_CONFIRM_POPUP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CLI_LOBBY_CONFIRM_POPUP).append(")");
	_buf.append(',');
	_buf.append("confirmId=");
	_buf.appendUint(confirmId);
	_buf.append(',');
	_buf.append("understood=");
	_buf.appendUint(understood);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_CLI_LOBBY_CONFIRM_POPUP::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_CLI_LOBBY_CONFIRM_POPUP::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CLI_LOBBY_CONFIRM_POPUP).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("confirmId", confirmId, _buf);
	Atf::XmlElement::encodeAsXmlElement("understood", understood, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_CLI_LOBBY_CONFIRM_POPUP::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("confirmId"))
			{
				confirmId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("understood"))
			{
				understood = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_CLI_LOBBY_CONFIRM_POPUP::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(confirmId);
	_msg.composeBOOL(understood);
}

void Lobby::cli::Protocol_MSG_CLI_LOBBY_CONFIRM_POPUP::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(confirmId);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(understood);
}

const char *Lobby::cli::Protocol_MSG_CLI_LOBBY_CONFIRM_POPUP::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("confirmId", confirmId);
	_jsonstr.compose("understood", understood);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_CLI_LOBBY_CONFIRM_POPUP::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("confirmId", confirmId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("understood", understood);
}

/*static*/ void Lobby::cli::Protocol_MSG_CLI_LOBBY_CONFIRM_POPUP::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CLI_LOBBY_CONFIRM_POPUP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 confirmId; _jparser.validateByNameThrow("confirmId", confirmId);
	AtfValidator::validateInt(_descr, "confirmId", confirmId, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool understood; _jparser.validateByNameThrow("understood", understood);
	AtfValidator::validateInt(_descr, "understood", understood, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_CLI_LOBBY_CONFIRM_POPUP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CLI_LOBBY_CONFIRM_POPUP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 confirmId; _parser.parseUINT32(confirmId);
	AtfValidator::validateInt(_descr, "confirmId", confirmId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool understood; _parser.parseBOOL(understood);
	AtfValidator::validateInt(_descr, "understood", understood, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF(Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF&& _o)
	: internalRef(std::move(_o.internalRef))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF& Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF::operator=(Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF&& _o)
{
	if(this != &_o)
	{
		internalRef = std::move(_o.internalRef);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF::clear()
{
	internalRef.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF::equals(const Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF& _o) const
{
	return Atf::atfPStringEquals(internalRef, _o.internalRef);
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF).append(")");
	_buf.append(',');
	_buf.append("internalRef=");
	_buf.append(internalRef);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("internalRef", internalRef, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("internalRef"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, internalRef)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(internalRef);
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(internalRef);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("internalRef", internalRef);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("internalRef", internalRef);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString internalRef; _jparser.validateByNameThrow("internalRef", internalRef);
	AtfValidator::validateIntMax(_descr, "internalRef", internalRef.length(), 500, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "internalRef"); size_t szInternalRef = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "internalRef", szInternalRef, 500, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY(Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, tournamentId(std::move(_o.tournamentId))
	, server(std::move(_o.server))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY& Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY::operator=(Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		tournamentId = std::move(_o.tournamentId);
		server = std::move(_o.server);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	tournamentId = 0;
	server.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY::equals(const Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		tournamentId == _o.tournamentId &&
		Atf::atfPStringEquals(server, _o.server);
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("tournamentId=");
		_buf.appendUint(tournamentId);
		_buf.append(',');
		_buf.append("server=");
		_buf.append(server);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("tournamentId", tournamentId, _buf);
		Atf::XmlElement::encodeAsXmlElement("server", server, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("tournamentId"))
			{
				tournamentId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("server"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, server)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeUINT32(tournamentId);
		_msg.composeString(server);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseUINT32(tournamentId);
		_parser.parseStringP(server);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("tournamentId", tournamentId);
		_jsonstr.compose("server", server);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("tournamentId", tournamentId);
		_jparser.parseByNameThrow("server", server);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 tournamentId; _jparser.validateByNameThrow("tournamentId", tournamentId);
		AtfValidator::validateInt(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
		PString server; _jparser.validateByNameThrow("server", server);
		AtfValidator::validateInt(_descr, "server", server.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 tournamentId; _parser.parseUINT32(tournamentId);
		AtfValidator::validateInt(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES::clear()
{
	tournId = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES::equals(const Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES& _o) const
{
	return tournId == _o.tournId;
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_SIMILAR_SATELLITES != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_SIMILAR_SATELLITES).append(")");
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_SIMILAR_SATELLITES).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tournId"))
			{
				tournId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(tournId);
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tournId);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tournId", tournId);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tournId", tournId);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_SIMILAR_SATELLITES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_SIMILAR_SATELLITES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    SatelliteTourn
//=================================================================

Lobby::cli::SatelliteTourn::SatelliteTourn()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::SatelliteTourn::SatelliteTourn(SatelliteTourn&& _o)
	: tournamentId(std::move(_o.tournamentId))
	, whenStart(std::move(_o.whenStart))
	, game(std::move(_o.game))
	, structure(std::move(_o.structure))
	, isHiLo(std::move(_o.isHiLo))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, currency(std::move(_o.currency))
	, scalePM(std::move(_o.scalePM))
	, buyIn(std::move(_o.buyIn))
	, rake(std::move(_o.rake))
	, knockout(std::move(_o.knockout))
	, fppBuyIn(std::move(_o.fppBuyIn))
	, admissionPrice(std::move(_o.admissionPrice))
	, admissionId(std::move(_o.admissionId))
	, status(std::move(_o.status))
	, statusBits(std::move(_o.statusBits))
	, tournFlags(std::move(_o.tournFlags))
	, tournFlags2(std::move(_o.tournFlags2))
	, servIntFlags(std::move(_o.servIntFlags))
	, maxPlayers(std::move(_o.maxPlayers))
	, players(std::move(_o.players))
	, server(std::move(_o.server))
	, serverObj(std::move(_o.serverObj))
{
}

Lobby::cli::SatelliteTourn& Lobby::cli::SatelliteTourn::operator=(SatelliteTourn&& _o)
{
	if(this != &_o)
	{
		tournamentId = std::move(_o.tournamentId);
		whenStart = std::move(_o.whenStart);
		game = std::move(_o.game);
		structure = std::move(_o.structure);
		isHiLo = std::move(_o.isHiLo);
		isPlayMoney = std::move(_o.isPlayMoney);
		currency = std::move(_o.currency);
		scalePM = std::move(_o.scalePM);
		buyIn = std::move(_o.buyIn);
		rake = std::move(_o.rake);
		knockout = std::move(_o.knockout);
		fppBuyIn = std::move(_o.fppBuyIn);
		admissionPrice = std::move(_o.admissionPrice);
		admissionId = std::move(_o.admissionId);
		status = std::move(_o.status);
		statusBits = std::move(_o.statusBits);
		tournFlags = std::move(_o.tournFlags);
		tournFlags2 = std::move(_o.tournFlags2);
		servIntFlags = std::move(_o.servIntFlags);
		maxPlayers = std::move(_o.maxPlayers);
		players = std::move(_o.players);
		server = std::move(_o.server);
		serverObj = std::move(_o.serverObj);
	}
	return *this;
}

#endif

void Lobby::cli::SatelliteTourn::clear()
{
	tournamentId = 0;
	whenStart.setNull();
	game = 0;
	structure = 0;
	isHiLo = 0;
	isPlayMoney = 0;
	currency.clear();
	scalePM = 0;
	buyIn = 0;
	rake = 0;
	knockout = 0;
	fppBuyIn = 0;
	admissionPrice = 0;
	admissionId.clear();
	status = 0;
	statusBits = 0;
	tournFlags = 0;
	tournFlags2 = 0;
	servIntFlags = 0;
	maxPlayers = 0;
	players = 0;
	server.clear();
	serverObj.clear();
}

bool Lobby::cli::SatelliteTourn::equals(const SatelliteTourn& _o) const
{
	return tournamentId == _o.tournamentId &&
		whenStart.equals(_o.whenStart) &&
		game == _o.game &&
		structure == _o.structure &&
		isHiLo == _o.isHiLo &&
		isPlayMoney == _o.isPlayMoney &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		scalePM == _o.scalePM &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		knockout == _o.knockout &&
		fppBuyIn == _o.fppBuyIn &&
		admissionPrice == _o.admissionPrice &&
		Atf::atfPStringEquals(admissionId, _o.admissionId) &&
		status == _o.status &&
		statusBits == _o.statusBits &&
		tournFlags == _o.tournFlags &&
		tournFlags2 == _o.tournFlags2 &&
		servIntFlags == _o.servIntFlags &&
		maxPlayers == _o.maxPlayers &&
		players == _o.players &&
		Atf::atfPStringEquals(server, _o.server) &&
		Atf::atfPStringEquals(serverObj, _o.serverObj);
}

const char *Lobby::cli::SatelliteTourn::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournamentId=");
	_buf.appendUint(tournamentId);
	_buf.append(',');
	_buf.append("whenStart=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, whenStart);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendUint(buyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendUint(rake);
	_buf.append(',');
	_buf.append("knockout=");
	_buf.appendUint(knockout);
	_buf.append(',');
	_buf.append("fppBuyIn=");
	_buf.appendUint(fppBuyIn);
	_buf.append(',');
	_buf.append("admissionPrice=");
	_buf.appendUint64(admissionPrice);
	_buf.append(',');
	_buf.append("admissionId=");
	_buf.append(admissionId);
	_buf.append(',');
	_buf.append("status=");
	_buf.appendUint(status);
	_buf.append(',');
	_buf.append("statusBits=");
	_buf.appendUint(statusBits);
	_buf.append(',');
	_buf.append("tournFlags=");
	_buf.appendUint(tournFlags);
	_buf.append(',');
	_buf.append("tournFlags2=");
	_buf.appendUint64(tournFlags2);
	_buf.append(',');
	_buf.append("servIntFlags=");
	_buf.appendUint(servIntFlags);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendUint(maxPlayers);
	_buf.append(',');
	_buf.append("players=");
	_buf.appendUint(players);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("serverObj=");
	_buf.append(serverObj);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::SatelliteTourn::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("tournamentId", tournamentId, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "whenStart", whenStart);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyIn", buyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("rake", rake, _buf);
	Atf::XmlElement::encodeAsXmlElement("knockout", knockout, _buf);
	Atf::XmlElement::encodeAsXmlElement("fppBuyIn", fppBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("admissionPrice", admissionPrice, _buf);
	Atf::XmlElement::encodeAsXmlElement("admissionId", admissionId, _buf);
	Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
	Atf::XmlElement::encodeAsXmlElement("statusBits", statusBits, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournFlags", tournFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournFlags2", tournFlags2, _buf);
	Atf::XmlElement::encodeAsXmlElement("servIntFlags", servIntFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPlayers", maxPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("players", players, _buf);
	Atf::XmlElement::encodeAsXmlElement("server", server, _buf);
	Atf::XmlElement::encodeAsXmlElement("serverObj", serverObj, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::SatelliteTourn::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("tournamentId"))
		{
			tournamentId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("whenStart"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, whenStart);
		}
		else if (_element.equals("game"))
		{
			game = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("structure"))
		{
			structure = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isPlayMoney"))
		{
			isPlayMoney = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("scalePM"))
		{
			scalePM = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("buyIn"))
		{
			buyIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rake"))
		{
			rake = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("knockout"))
		{
			knockout = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("fppBuyIn"))
		{
			fppBuyIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("admissionPrice"))
		{
			admissionPrice = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("admissionId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, admissionId)) return false;
		}
		else if (_element.equals("status"))
		{
			status = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("statusBits"))
		{
			statusBits = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournFlags"))
		{
			tournFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournFlags2"))
		{
			tournFlags2 = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("servIntFlags"))
		{
			servIntFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxPlayers"))
		{
			maxPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("players"))
		{
			players = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("server"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, server)) return false;
		}
		else if (_element.equals("serverObj"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, serverObj)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::SatelliteTourn::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(SatelliteTourn())) // not empty
	{
		_body.composeUINT32(tournamentId);
		_body.composeSrvTime(whenStart);
		_body.composeBYTE(game);
		_body.composeBYTE(structure);
		_body.composeBYTE(isHiLo);
		_body.composeBYTE(isPlayMoney);
		_body.composeString(currency);
		_body.composeUINT32(scalePM);
		_body.composeUINT32(buyIn);
		_body.composeUINT32(rake);
		_body.composeUINT32(knockout);
		_body.composeUINT32(fppBuyIn);
		_body.composeUINT64(admissionPrice);
		_body.composeString(admissionId);
		_body.composeUINT32(status);
		_body.composeUINT32(statusBits);
		_body.composeUINT32(tournFlags);
		_body.composeUINT64(tournFlags2);
		_body.composeUINT32(servIntFlags);
		_body.composeUINT32(maxPlayers);
		_body.composeUINT32(players);
		_body.composeString(server);
		_body.composeString(serverObj);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::cli::SatelliteTourn::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(tournamentId);
	_parser0.parseSrvTime(whenStart);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(structure);
	_parser0.parseBYTE(isHiLo);
	_parser0.parseBYTE(isPlayMoney);
	_parser0.parseStringP(currency);
	_parser0.parseUINT32(scalePM);
	_parser0.parseUINT32(buyIn);
	_parser0.parseUINT32(rake);
	_parser0.parseUINT32(knockout);
	_parser0.parseUINT32(fppBuyIn);
	_parser0.parseUINT64(admissionPrice);
	_parser0.parseStringP(admissionId);
	_parser0.parseUINT32(status);
	_parser0.parseUINT32(statusBits);
	_parser0.parseUINT32(tournFlags);
	_parser0.parseUINT64(tournFlags2);
	_parser0.parseUINT32(servIntFlags);
	_parser0.parseUINT32(maxPlayers);
	_parser0.parseUINT32(players);
	_parser0.parseStringP(server);
	_parser0.parseStringP(serverObj);
}

const char *Lobby::cli::SatelliteTourn::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tournamentId", tournamentId);
	_jsonstr.compose("whenStart", whenStart);
	_jsonstr.compose("game", game);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("scalePM", scalePM);
	_jsonstr.compose("buyIn", buyIn);
	_jsonstr.compose("rake", rake);
	_jsonstr.compose("knockout", knockout);
	_jsonstr.compose("fppBuyIn", fppBuyIn);
	_jsonstr.compose("admissionPrice", admissionPrice);
	_jsonstr.compose("admissionId", admissionId);
	_jsonstr.compose("status", status);
	_jsonstr.compose("statusBits", statusBits);
	_jsonstr.compose("tournFlags", tournFlags);
	_jsonstr.compose("tournFlags2", tournFlags2);
	_jsonstr.compose("servIntFlags", servIntFlags);
	_jsonstr.compose("maxPlayers", maxPlayers);
	_jsonstr.compose("players", players);
	_jsonstr.compose("server", server);
	_jsonstr.compose("serverObj", serverObj);
	return _buf.c_str();
}

void Lobby::cli::SatelliteTourn::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tournamentId", tournamentId);
	_jparser.parseByNameThrow("whenStart", whenStart);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("scalePM", scalePM);
	_jparser.parseByNameThrow("buyIn", buyIn);
	_jparser.parseByNameThrow("rake", rake);
	_jparser.parseByNameThrow("knockout", knockout);
	_jparser.parseByNameThrow("fppBuyIn", fppBuyIn);
	_jparser.parseByNameThrow("admissionPrice", admissionPrice);
	_jparser.parseByNameThrow("admissionId", admissionId);
	_jparser.parseByNameThrow("status", status);
	_jparser.parseByNameThrow("statusBits", statusBits);
	_jparser.parseByNameThrow("tournFlags", tournFlags);
	_jparser.parseByNameThrow("tournFlags2", tournFlags2);
	_jparser.parseByNameThrow("servIntFlags", servIntFlags);
	_jparser.parseByNameThrow("maxPlayers", maxPlayers);
	_jparser.parseByNameThrow("players", players);
	_jparser.parseByNameThrow("server", server);
	_jparser.parseByNameThrow("serverObj", serverObj);
}

/* static */ void Lobby::cli::SatelliteTourn::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tournamentId; _jparser.validateByNameThrow("tournamentId", tournamentId);
	AtfValidator::validateInt(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
	SrvTime whenStart; _jparser.validateByNameThrow("whenStart", whenStart);
	AtfValidator::validateSrvDateTime(_descr, "whenStart", whenStart, _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	UINT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT32 buyIn; _jparser.validateByNameThrow("buyIn", buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT32 rake; _jparser.validateByNameThrow("rake", rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	UINT32 knockout; _jparser.validateByNameThrow("knockout", knockout);
	AtfValidator::validateInt(_descr, "knockout", knockout, _checker, __FILE__, __LINE__);
	UINT32 fppBuyIn; _jparser.validateByNameThrow("fppBuyIn", fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	UINT64 admissionPrice; _jparser.validateByNameThrow("admissionPrice", admissionPrice);
	AtfValidator::validateUint(_descr, "admissionPrice", admissionPrice, _checker, __FILE__, __LINE__);
	PString admissionId; _jparser.validateByNameThrow("admissionId", admissionId);
	AtfValidator::validateInt(_descr, "admissionId", admissionId.length(), _checker, __FILE__, __LINE__);
	UINT32 status; _jparser.validateByNameThrow("status", status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	UINT32 statusBits; _jparser.validateByNameThrow("statusBits", statusBits);
	AtfValidator::validateInt(_descr, "statusBits", statusBits, _checker, __FILE__, __LINE__);
	UINT32 tournFlags; _jparser.validateByNameThrow("tournFlags", tournFlags);
	AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
	UINT64 tournFlags2; _jparser.validateByNameThrow("tournFlags2", tournFlags2);
	AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	UINT32 servIntFlags; _jparser.validateByNameThrow("servIntFlags", servIntFlags);
	AtfValidator::validateInt(_descr, "servIntFlags", servIntFlags, _checker, __FILE__, __LINE__);
	UINT32 maxPlayers; _jparser.validateByNameThrow("maxPlayers", maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	UINT32 players; _jparser.validateByNameThrow("players", players);
	AtfValidator::validateInt(_descr, "players", players, _checker, __FILE__, __LINE__);
	PString server; _jparser.validateByNameThrow("server", server);
	AtfValidator::validateInt(_descr, "server", server.length(), _checker, __FILE__, __LINE__);
	PString serverObj; _jparser.validateByNameThrow("serverObj", serverObj);
	AtfValidator::validateInt(_descr, "serverObj", serverObj.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::SatelliteTourn::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 tournamentId; _parser0.parseUINT32(tournamentId);
	AtfValidator::validateInt(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
	SrvTime whenStart; _parser0.parseSrvTime(whenStart);
	AtfValidator::validateSrvDateTime(_descr, "whenStart", whenStart, _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser0.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser0.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser0.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT32 buyIn; _parser0.parseUINT32(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT32 rake; _parser0.parseUINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	UINT32 knockout; _parser0.parseUINT32(knockout);
	AtfValidator::validateInt(_descr, "knockout", knockout, _checker, __FILE__, __LINE__);
	UINT32 fppBuyIn; _parser0.parseUINT32(fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	UINT64 admissionPrice; _parser0.parseUINT64(admissionPrice);
	AtfValidator::validateUint(_descr, "admissionPrice", admissionPrice, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "admissionId"); size_t szAdmissionId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "admissionId", szAdmissionId, _checker, __FILE__, __LINE__);
	UINT32 status; _parser0.parseUINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	UINT32 statusBits; _parser0.parseUINT32(statusBits);
	AtfValidator::validateInt(_descr, "statusBits", statusBits, _checker, __FILE__, __LINE__);
	UINT32 tournFlags; _parser0.parseUINT32(tournFlags);
	AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
	UINT64 tournFlags2; _parser0.parseUINT64(tournFlags2);
	AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	UINT32 servIntFlags; _parser0.parseUINT32(servIntFlags);
	AtfValidator::validateInt(_descr, "servIntFlags", servIntFlags, _checker, __FILE__, __LINE__);
	UINT32 maxPlayers; _parser0.parseUINT32(maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	UINT32 players; _parser0.parseUINT32(players);
	AtfValidator::validateInt(_descr, "players", players, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "serverObj"); size_t szServerObj = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObj", szServerObj, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY(Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, satelliteTourns(std::move(_o.satelliteTourns))
{
}

Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY& Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY::operator=(Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		satelliteTourns = std::move(_o.satelliteTourns);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	satelliteTourns.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY::equals(const Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		satelliteTourns.equals(_o.satelliteTourns);
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("satelliteTourns=");
		satelliteTourns.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		satelliteTourns.toXmlString("satelliteTourns", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("satelliteTourns"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SatelliteTourn, 4 > >::FromXmlString(_value, satelliteTourns)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		satelliteTourns.composeMsg(_msg, _ignoreJSON);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		satelliteTourns.parseMsg(_parser);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("satelliteTourns", satelliteTourns);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("satelliteTourns", satelliteTourns);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< SatelliteTourn > satelliteTourns; _jparser.validateByNameThrow("satelliteTourns", satelliteTourns);
		AtfValidator::validateInt(_descr, "satelliteTourns", satelliteTourns.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szSatelliteTourns = Atf::LAtfVector< SatelliteTourn, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("satelliteTourns"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "satelliteTourns", szSatelliteTourns, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_JOIN_SEATFINDER
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER::Protocol_MSG_LOBBY_JOIN_SEATFINDER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER::Protocol_MSG_LOBBY_JOIN_SEATFINDER(Protocol_MSG_LOBBY_JOIN_SEATFINDER&& _o)
	: seatFinderId(std::move(_o.seatFinderId))
	, buyIn(std::move(_o.buyIn))
	, password(std::move(_o.password))
	, autoRebuyOpt(std::move(_o.autoRebuyOpt))
	, autoRebuyBigBets(std::move(_o.autoRebuyBigBets))
	, fallUnderBigBets(std::move(_o.fallUnderBigBets))
	, fallUnderPercents(std::move(_o.fallUnderPercents))
{
}

Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER& Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER::operator=(Protocol_MSG_LOBBY_JOIN_SEATFINDER&& _o)
{
	if(this != &_o)
	{
		seatFinderId = std::move(_o.seatFinderId);
		buyIn = std::move(_o.buyIn);
		password = std::move(_o.password);
		autoRebuyOpt = std::move(_o.autoRebuyOpt);
		autoRebuyBigBets = std::move(_o.autoRebuyBigBets);
		fallUnderBigBets = std::move(_o.fallUnderBigBets);
		fallUnderPercents = std::move(_o.fallUnderPercents);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER::clear()
{
	seatFinderId = 0;
	buyIn = 0;
	password.clear();
	autoRebuyOpt = 0;
	autoRebuyBigBets = 0;
	fallUnderBigBets = 0;
	fallUnderPercents = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER::equals(const Protocol_MSG_LOBBY_JOIN_SEATFINDER& _o) const
{
	return seatFinderId == _o.seatFinderId &&
		buyIn == _o.buyIn &&
		Atf::atfPStringEquals(password, _o.password) &&
		autoRebuyOpt == _o.autoRebuyOpt &&
		autoRebuyBigBets == _o.autoRebuyBigBets &&
		fallUnderBigBets == _o.fallUnderBigBets &&
		fallUnderPercents == _o.fallUnderPercents;
}

bool Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_JOIN_SEATFINDER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_JOIN_SEATFINDER*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_JOIN_SEATFINDER).append(")");
	_buf.append(',');
	_buf.append("seatFinderId=");
	_buf.appendUint(seatFinderId);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendInt(buyIn);
	_buf.append(',');
	_buf.append("password=");
	_buf.append(password);
	_buf.append(',');
	_buf.append("autoRebuyOpt=");
	_buf.appendInt(autoRebuyOpt);
	_buf.append(',');
	_buf.append("autoRebuyBigBets=");
	_buf.appendInt(autoRebuyBigBets);
	_buf.append(',');
	_buf.append("fallUnderBigBets=");
	_buf.appendInt(fallUnderBigBets);
	_buf.append(',');
	_buf.append("fallUnderPercents=");
	_buf.appendInt(fallUnderPercents);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_JOIN_SEATFINDER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("seatFinderId", seatFinderId, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyIn", buyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("password", password, _buf);
	Atf::XmlElement::encodeAsXmlElement("autoRebuyOpt", autoRebuyOpt, _buf);
	Atf::XmlElement::encodeAsXmlElement("autoRebuyBigBets", autoRebuyBigBets, _buf);
	Atf::XmlElement::encodeAsXmlElement("fallUnderBigBets", fallUnderBigBets, _buf);
	Atf::XmlElement::encodeAsXmlElement("fallUnderPercents", fallUnderPercents, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("seatFinderId"))
			{
				seatFinderId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("buyIn"))
			{
				buyIn = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("password"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, password)) return false;
			}
			else if (_element.equals("autoRebuyOpt"))
			{
				autoRebuyOpt = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("autoRebuyBigBets"))
			{
				autoRebuyBigBets = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("fallUnderBigBets"))
			{
				fallUnderBigBets = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("fallUnderPercents"))
			{
				fallUnderPercents = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(seatFinderId);
	_msg.composeINT32(buyIn);
	_msg.composeString(password);
	_msg.composeINT8(autoRebuyOpt);
	_msg.composeINT16(autoRebuyBigBets);
	_msg.composeINT16(fallUnderBigBets);
	_msg.composeINT16(fallUnderPercents);
}

void Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(seatFinderId);
	_parser.parseINT32(buyIn);
	_parser.parseStringP(password);
	_parser.parseINT8(autoRebuyOpt);
	_parser.parseINT16(autoRebuyBigBets);
	_parser.parseINT16(fallUnderBigBets);
	_parser.parseINT16(fallUnderPercents);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("seatFinderId", seatFinderId);
	_jsonstr.compose("buyIn", buyIn);
	_jsonstr.compose("password", password);
	_jsonstr.compose("autoRebuyOpt", autoRebuyOpt);
	_jsonstr.compose("autoRebuyBigBets", autoRebuyBigBets);
	_jsonstr.compose("fallUnderBigBets", fallUnderBigBets);
	_jsonstr.compose("fallUnderPercents", fallUnderPercents);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("seatFinderId", seatFinderId);
	_jparser.parseByNameThrow("buyIn", buyIn);
	_jparser.parseByNameThrow("password", password);
	_jparser.parseByNameThrow("autoRebuyOpt", autoRebuyOpt);
	_jparser.parseByNameThrow("autoRebuyBigBets", autoRebuyBigBets);
	_jparser.parseByNameThrow("fallUnderBigBets", fallUnderBigBets);
	_jparser.parseByNameThrow("fallUnderPercents", fallUnderPercents);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_JOIN_SEATFINDER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 seatFinderId; _jparser.validateByNameThrow("seatFinderId", seatFinderId);
	AtfValidator::validateInt(_descr, "seatFinderId", seatFinderId, _checker, __FILE__, __LINE__);
	INT32 buyIn; _jparser.validateByNameThrow("buyIn", buyIn);
	AtfValidator::validateIntRange(_descr, "buyIn", buyIn, 0, 2000000000, _checker, __FILE__, __LINE__);
	PString password; _jparser.validateByNameThrow("password", password);
	AtfValidator::validateIntMax(_descr, "password", password.length(), 1000, _checker, __FILE__, __LINE__);
	INT8 autoRebuyOpt; _jparser.validateByNameThrow("autoRebuyOpt", autoRebuyOpt);
	AtfValidator::validateIntRange(_descr, "autoRebuyOpt", autoRebuyOpt, _autoRebuyDisabled, _autoRebuyBigBets, _checker, __FILE__, __LINE__);
	INT16 autoRebuyBigBets; _jparser.validateByNameThrow("autoRebuyBigBets", autoRebuyBigBets);
	AtfValidator::validateIntRange(_descr, "autoRebuyBigBets", autoRebuyBigBets, 0, 1000, _checker, __FILE__, __LINE__);
	INT16 fallUnderBigBets; _jparser.validateByNameThrow("fallUnderBigBets", fallUnderBigBets);
	AtfValidator::validateIntRange(_descr, "fallUnderBigBets", fallUnderBigBets, 0, 1000, _checker, __FILE__, __LINE__);
	INT16 fallUnderPercents; _jparser.validateByNameThrow("fallUnderPercents", fallUnderPercents);
	AtfValidator::validateIntRange(_descr, "fallUnderPercents", fallUnderPercents, 0, 100, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_JOIN_SEATFINDER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 seatFinderId; _parser.parseUINT32(seatFinderId);
	AtfValidator::validateInt(_descr, "seatFinderId", seatFinderId, _checker, __FILE__, __LINE__);
	INT32 buyIn; _parser.parseINT32(buyIn);
	AtfValidator::validateIntRange(_descr, "buyIn", buyIn, 0, 2000000000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "password"); size_t szPassword = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "password", szPassword, 1000, _checker, __FILE__, __LINE__);
	INT8 autoRebuyOpt; _parser.parseINT8(autoRebuyOpt);
	AtfValidator::validateIntRange(_descr, "autoRebuyOpt", autoRebuyOpt, _autoRebuyDisabled, _autoRebuyBigBets, _checker, __FILE__, __LINE__);
	INT16 autoRebuyBigBets; _parser.parseINT16(autoRebuyBigBets);
	AtfValidator::validateIntRange(_descr, "autoRebuyBigBets", autoRebuyBigBets, 0, 1000, _checker, __FILE__, __LINE__);
	INT16 fallUnderBigBets; _parser.parseINT16(fallUnderBigBets);
	AtfValidator::validateIntRange(_descr, "fallUnderBigBets", fallUnderBigBets, 0, 1000, _checker, __FILE__, __LINE__);
	INT16 fallUnderPercents; _parser.parseINT16(fallUnderPercents);
	AtfValidator::validateIntRange(_descr, "fallUnderPercents", fallUnderPercents, 0, 100, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY::Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY::Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY(Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, seatFinderId(std::move(_o.seatFinderId))
	, placeInList(std::move(_o.placeInList))
{
}

Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY& Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY::operator=(Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		seatFinderId = std::move(_o.seatFinderId);
		placeInList = std::move(_o.placeInList);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	seatFinderId = 0;
	placeInList = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY::equals(const Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		seatFinderId == _o.seatFinderId &&
		placeInList == _o.placeInList;
}

bool Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_JOIN_SEATFINDER_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_JOIN_SEATFINDER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
		_buf.append(',');
		_buf.append("seatFinderId=");
		_buf.appendUint(seatFinderId);
	}
	else
	{
		_buf.append(',');
		_buf.append("seatFinderId=");
		_buf.appendUint(seatFinderId);
		_buf.append(',');
		_buf.append("placeInList=");
		_buf.appendInt(placeInList);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_JOIN_SEATFINDER_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
		Atf::XmlElement::encodeAsXmlElement("seatFinderId", seatFinderId, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("seatFinderId", seatFinderId, _buf);
		Atf::XmlElement::encodeAsXmlElement("placeInList", placeInList, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("seatFinderId"))
			{
				seatFinderId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("placeInList"))
			{
				placeInList = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
		_msg.composeUINT32(seatFinderId);
	}
	else
	{
		_msg.composeUINT32(seatFinderId);
		_msg.composeINT32(placeInList);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
		_parser.parseUINT32(seatFinderId);
	}
	else
	{
		_parser.parseUINT32(seatFinderId);
		_parser.parseINT32(placeInList);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
		_jsonstr.compose("seatFinderId", seatFinderId);
	}
	else
	{
		_jsonstr.compose("seatFinderId", seatFinderId);
		_jsonstr.compose("placeInList", placeInList);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
		_jparser.parseByNameThrow("seatFinderId", seatFinderId);
	}
	else
	{
		_jparser.parseByNameThrow("seatFinderId", seatFinderId);
		_jparser.parseByNameThrow("placeInList", placeInList);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_JOIN_SEATFINDER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
		UINT32 seatFinderId; _jparser.validateByNameThrow("seatFinderId", seatFinderId);
		AtfValidator::validateInt(_descr, "seatFinderId", seatFinderId, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 seatFinderId; _jparser.validateByNameThrow("seatFinderId", seatFinderId);
		AtfValidator::validateInt(_descr, "seatFinderId", seatFinderId, _checker, __FILE__, __LINE__);
		INT32 placeInList; _jparser.validateByNameThrow("placeInList", placeInList);
		AtfValidator::validateInt(_descr, "placeInList", placeInList, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_JOIN_SEATFINDER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
		UINT32 seatFinderId; _parser.parseUINT32(seatFinderId);
		AtfValidator::validateInt(_descr, "seatFinderId", seatFinderId, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 seatFinderId; _parser.parseUINT32(seatFinderId);
		AtfValidator::validateInt(_descr, "seatFinderId", seatFinderId, _checker, __FILE__, __LINE__);
		INT32 placeInList; _parser.parseINT32(placeInList);
		AtfValidator::validateInt(_descr, "placeInList", placeInList, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_UNJOIN_SEATFINDER
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER::clear()
{
	seatFinderId = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER::equals(const Protocol_MSG_LOBBY_UNJOIN_SEATFINDER& _o) const
{
	return seatFinderId == _o.seatFinderId;
}

bool Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_UNJOIN_SEATFINDER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_UNJOIN_SEATFINDER*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_UNJOIN_SEATFINDER).append(")");
	_buf.append(',');
	_buf.append("seatFinderId=");
	_buf.appendUint(seatFinderId);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_UNJOIN_SEATFINDER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("seatFinderId", seatFinderId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("seatFinderId"))
			{
				seatFinderId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(seatFinderId);
}

void Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(seatFinderId);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("seatFinderId", seatFinderId);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("seatFinderId", seatFinderId);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_UNJOIN_SEATFINDER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 seatFinderId; _jparser.validateByNameThrow("seatFinderId", seatFinderId);
	AtfValidator::validateInt(_descr, "seatFinderId", seatFinderId, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_UNJOIN_SEATFINDER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 seatFinderId; _parser.parseUINT32(seatFinderId);
	AtfValidator::validateInt(_descr, "seatFinderId", seatFinderId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY(Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, seatFinderId(std::move(_o.seatFinderId))
{
}

Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY& Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY::operator=(Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		seatFinderId = std::move(_o.seatFinderId);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	seatFinderId = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY::equals(const Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		seatFinderId == _o.seatFinderId;
}

bool Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_UNJOIN_SEATFINDER_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_UNJOIN_SEATFINDER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
		_buf.append(',');
		_buf.append("seatFinderId=");
		_buf.appendUint(seatFinderId);
	}
	else
	{
		_buf.append(',');
		_buf.append("seatFinderId=");
		_buf.appendUint(seatFinderId);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_UNJOIN_SEATFINDER_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
		Atf::XmlElement::encodeAsXmlElement("seatFinderId", seatFinderId, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("seatFinderId", seatFinderId, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("seatFinderId"))
			{
				seatFinderId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
		_msg.composeUINT32(seatFinderId);
	}
	else
	{
		_msg.composeUINT32(seatFinderId);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
		_parser.parseUINT32(seatFinderId);
	}
	else
	{
		_parser.parseUINT32(seatFinderId);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
		_jsonstr.compose("seatFinderId", seatFinderId);
	}
	else
	{
		_jsonstr.compose("seatFinderId", seatFinderId);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
		_jparser.parseByNameThrow("seatFinderId", seatFinderId);
	}
	else
	{
		_jparser.parseByNameThrow("seatFinderId", seatFinderId);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_UNJOIN_SEATFINDER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
		UINT32 seatFinderId; _jparser.validateByNameThrow("seatFinderId", seatFinderId);
		AtfValidator::validateInt(_descr, "seatFinderId", seatFinderId, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 seatFinderId; _jparser.validateByNameThrow("seatFinderId", seatFinderId);
		AtfValidator::validateInt(_descr, "seatFinderId", seatFinderId, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_UNJOIN_SEATFINDER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
		UINT32 seatFinderId; _parser.parseUINT32(seatFinderId);
		AtfValidator::validateInt(_descr, "seatFinderId", seatFinderId, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 seatFinderId; _parser.parseUINT32(seatFinderId);
		AtfValidator::validateInt(_descr, "seatFinderId", seatFinderId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS::clear()
{
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS::equals(const Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS& _o) const
{
	return true;
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_JOINED_SEATFINDERS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_JOINED_SEATFINDERS).append(")");
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_JOINED_SEATFINDERS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS::parseMsg(CommMsgParser& _parser)
{
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_JOINED_SEATFINDERS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_JOINED_SEATFINDERS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    SeatFinder
//=================================================================

Lobby::cli::SeatFinder::SeatFinder()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::SeatFinder::SeatFinder(SeatFinder&& _o)
	: seatFinderId(std::move(_o.seatFinderId))
	, placeInList(std::move(_o.placeInList))
	, game(std::move(_o.game))
	, structure(std::move(_o.structure))
	, isHiLo(std::move(_o.isHiLo))
	, isRealMoney(std::move(_o.isRealMoney))
	, currency(std::move(_o.currency))
	, loBet(std::move(_o.loBet))
	, hiBet(std::move(_o.hiBet))
{
}

Lobby::cli::SeatFinder& Lobby::cli::SeatFinder::operator=(SeatFinder&& _o)
{
	if(this != &_o)
	{
		seatFinderId = std::move(_o.seatFinderId);
		placeInList = std::move(_o.placeInList);
		game = std::move(_o.game);
		structure = std::move(_o.structure);
		isHiLo = std::move(_o.isHiLo);
		isRealMoney = std::move(_o.isRealMoney);
		currency = std::move(_o.currency);
		loBet = std::move(_o.loBet);
		hiBet = std::move(_o.hiBet);
	}
	return *this;
}

#endif

void Lobby::cli::SeatFinder::clear()
{
	seatFinderId = 0;
	placeInList = 0;
	game = 0;
	structure = 0;
	isHiLo = 0;
	isRealMoney = 0;
	currency.clear();
	loBet = 0;
	hiBet = 0;
}

bool Lobby::cli::SeatFinder::equals(const SeatFinder& _o) const
{
	return seatFinderId == _o.seatFinderId &&
		placeInList == _o.placeInList &&
		game == _o.game &&
		structure == _o.structure &&
		isHiLo == _o.isHiLo &&
		isRealMoney == _o.isRealMoney &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		loBet == _o.loBet &&
		hiBet == _o.hiBet;
}

const char *Lobby::cli::SeatFinder::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("seatFinderId=");
	_buf.appendUint(seatFinderId);
	_buf.append(',');
	_buf.append("placeInList=");
	_buf.appendInt(placeInList);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("isRealMoney=");
	_buf.appendUint(isRealMoney);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("loBet=");
	_buf.appendInt(loBet);
	_buf.append(',');
	_buf.append("hiBet=");
	_buf.appendInt(hiBet);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::SeatFinder::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("seatFinderId", seatFinderId, _buf);
	Atf::XmlElement::encodeAsXmlElement("placeInList", placeInList, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("isRealMoney", isRealMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("loBet", loBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("hiBet", hiBet, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::SeatFinder::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("seatFinderId"))
		{
			seatFinderId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("placeInList"))
		{
			placeInList = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("game"))
		{
			game = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("structure"))
		{
			structure = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isRealMoney"))
		{
			isRealMoney = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("loBet"))
		{
			loBet = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("hiBet"))
		{
			hiBet = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::SeatFinder::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(seatFinderId);
	_msg.composeINT32(placeInList);
	_msg.composeBYTE(game);
	_msg.composeBYTE(structure);
	_msg.composeBYTE(isHiLo);
	_msg.composeBYTE(isRealMoney);
	_msg.composeString(currency);
	_msg.composeINT32(loBet);
	_msg.composeINT32(hiBet);
}

void Lobby::cli::SeatFinder::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(seatFinderId);
	_parser.parseINT32(placeInList);
	_parser.parseBYTE(game);
	_parser.parseBYTE(structure);
	_parser.parseBYTE(isHiLo);
	_parser.parseBYTE(isRealMoney);
	_parser.parseStringP(currency);
	_parser.parseINT32(loBet);
	_parser.parseINT32(hiBet);
}

const char *Lobby::cli::SeatFinder::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("seatFinderId", seatFinderId);
	_jsonstr.compose("placeInList", placeInList);
	_jsonstr.compose("game", game);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("isRealMoney", isRealMoney);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("loBet", loBet);
	_jsonstr.compose("hiBet", hiBet);
	return _buf.c_str();
}

void Lobby::cli::SeatFinder::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("seatFinderId", seatFinderId);
	_jparser.parseByNameThrow("placeInList", placeInList);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("isRealMoney", isRealMoney);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("loBet", loBet);
	_jparser.parseByNameThrow("hiBet", hiBet);
}

/* static */ void Lobby::cli::SeatFinder::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 seatFinderId; _jparser.validateByNameThrow("seatFinderId", seatFinderId);
	AtfValidator::validateInt(_descr, "seatFinderId", seatFinderId, _checker, __FILE__, __LINE__);
	INT32 placeInList; _jparser.validateByNameThrow("placeInList", placeInList);
	AtfValidator::validateInt(_descr, "placeInList", placeInList, _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE isRealMoney; _jparser.validateByNameThrow("isRealMoney", isRealMoney);
	AtfValidator::validateInt(_descr, "isRealMoney", isRealMoney, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	INT32 loBet; _jparser.validateByNameThrow("loBet", loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	INT32 hiBet; _jparser.validateByNameThrow("hiBet", hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::SeatFinder::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 seatFinderId; _parser.parseUINT32(seatFinderId);
	AtfValidator::validateInt(_descr, "seatFinderId", seatFinderId, _checker, __FILE__, __LINE__);
	INT32 placeInList; _parser.parseINT32(placeInList);
	AtfValidator::validateInt(_descr, "placeInList", placeInList, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE isRealMoney; _parser.parseBYTE(isRealMoney);
	AtfValidator::validateInt(_descr, "isRealMoney", isRealMoney, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT32 loBet; _parser.parseINT32(loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	INT32 hiBet; _parser.parseINT32(hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY(Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY&& _o)
	: seatFinders(std::move(_o.seatFinders))
{
}

Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY& Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY::operator=(Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY&& _o)
{
	if(this != &_o)
	{
		seatFinders = std::move(_o.seatFinders);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY::clear()
{
	seatFinders.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY::equals(const Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY& _o) const
{
	return seatFinders.equals(_o.seatFinders);
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY).append(")");
	_buf.append(',');
	_buf.append("seatFinders=");
	seatFinders.toTraceString(_buf);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	seatFinders.toXmlString("seatFinders", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("seatFinders"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SeatFinder, 4 > >::FromXmlString(_value, seatFinders)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	seatFinders.composeMsg(_msg, _ignoreJSON);
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY::parseMsg(CommMsgParser& _parser)
{
	seatFinders.parseMsg(_parser);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("seatFinders", seatFinders);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("seatFinders", seatFinders);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< SeatFinder > seatFinders; _jparser.validateByNameThrow("seatFinders", seatFinders);
	AtfValidator::validateInt(_descr, "seatFinders", seatFinders.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szSeatFinders = Atf::LAtfVector< SeatFinder, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("seatFinders"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "seatFinders", szSeatFinders, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS::clear()
{
	seatFinderId = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS::equals(const Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS& _o) const
{
	return seatFinderId == _o.seatFinderId;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_SEATFINDER_CHECK_CHIPS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SEATFINDER_CHECK_CHIPS).append(")");
	_buf.append(',');
	_buf.append("seatFinderId=");
	_buf.appendUint(seatFinderId);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_SEATFINDER_CHECK_CHIPS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("seatFinderId", seatFinderId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("seatFinderId"))
			{
				seatFinderId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(seatFinderId);
}

void Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(seatFinderId);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("seatFinderId", seatFinderId);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("seatFinderId", seatFinderId);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SEATFINDER_CHECK_CHIPS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 seatFinderId; _jparser.validateByNameThrow("seatFinderId", seatFinderId);
	AtfValidator::validateInt(_descr, "seatFinderId", seatFinderId, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SEATFINDER_CHECK_CHIPS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 seatFinderId; _parser.parseUINT32(seatFinderId);
	AtfValidator::validateInt(_descr, "seatFinderId", seatFinderId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    SeatFinderCli_MsgBodyStruct
//=================================================================

Lobby::cli::SeatFinderCli_MsgBodyStruct::SeatFinderCli_MsgBodyStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::SeatFinderCli_MsgBodyStruct::SeatFinderCli_MsgBodyStruct(SeatFinderCli_MsgBodyStruct&& _o)
	: id(std::move(_o.id))
	, currency(std::move(_o.currency))
	, isHiLo(std::move(_o.isHiLo))
	, loBet(std::move(_o.loBet))
	, hiBet(std::move(_o.hiBet))
	, cap(std::move(_o.cap))
	, game(std::move(_o.game))
	, limit(std::move(_o.limit))
	, minBuyIn(std::move(_o.minBuyIn))
	, maxBuyIn(std::move(_o.maxBuyIn))
	, ante(std::move(_o.ante))
	, isFast(std::move(_o.isFast))
	, maxPlayers(std::move(_o.maxPlayers))
	, chipsQuantum(std::move(_o.chipsQuantum))
	, scalePM(std::move(_o.scalePM))
	, tableStakes(std::move(_o.tableStakes))
	, variableAntes(std::move(_o.variableAntes))
{
}

Lobby::cli::SeatFinderCli_MsgBodyStruct& Lobby::cli::SeatFinderCli_MsgBodyStruct::operator=(SeatFinderCli_MsgBodyStruct&& _o)
{
	if(this != &_o)
	{
		id = std::move(_o.id);
		currency = std::move(_o.currency);
		isHiLo = std::move(_o.isHiLo);
		loBet = std::move(_o.loBet);
		hiBet = std::move(_o.hiBet);
		cap = std::move(_o.cap);
		game = std::move(_o.game);
		limit = std::move(_o.limit);
		minBuyIn = std::move(_o.minBuyIn);
		maxBuyIn = std::move(_o.maxBuyIn);
		ante = std::move(_o.ante);
		isFast = std::move(_o.isFast);
		maxPlayers = std::move(_o.maxPlayers);
		chipsQuantum = std::move(_o.chipsQuantum);
		scalePM = std::move(_o.scalePM);
		tableStakes = std::move(_o.tableStakes);
		variableAntes = std::move(_o.variableAntes);
	}
	return *this;
}

#endif

void Lobby::cli::SeatFinderCli_MsgBodyStruct::clear()
{
	id = 0;
	currency.clear();
	isHiLo = 0;
	loBet = 0;
	hiBet = 0;
	cap = 0;
	game = 0;
	limit = 0;
	minBuyIn = 0;
	maxBuyIn = 0;
	ante = 0;
	isFast = false;
	maxPlayers = 0;
	chipsQuantum = 0;
	scalePM = 0;
	tableStakes.clear();
	variableAntes.clear();
}

bool Lobby::cli::SeatFinderCli_MsgBodyStruct::equals(const SeatFinderCli_MsgBodyStruct& _o) const
{
	return id == _o.id &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		isHiLo == _o.isHiLo &&
		loBet == _o.loBet &&
		hiBet == _o.hiBet &&
		cap == _o.cap &&
		game == _o.game &&
		limit == _o.limit &&
		minBuyIn == _o.minBuyIn &&
		maxBuyIn == _o.maxBuyIn &&
		ante == _o.ante &&
		isFast == _o.isFast &&
		maxPlayers == _o.maxPlayers &&
		chipsQuantum == _o.chipsQuantum &&
		scalePM == _o.scalePM &&
		tableStakes.equals(_o.tableStakes) &&
		variableAntes.equals(_o.variableAntes);
}

const char *Lobby::cli::SeatFinderCli_MsgBodyStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("id=");
	_buf.appendUint(id);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendInt(isHiLo);
	_buf.append(',');
	_buf.append("loBet=");
	_buf.appendInt(loBet);
	_buf.append(',');
	_buf.append("hiBet=");
	_buf.appendInt(hiBet);
	_buf.append(',');
	_buf.append("cap=");
	_buf.appendInt(cap);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendInt(game);
	_buf.append(',');
	_buf.append("limit=");
	_buf.appendInt(limit);
	_buf.append(',');
	_buf.append("minBuyIn=");
	_buf.appendInt(minBuyIn);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendInt(maxBuyIn);
	_buf.append(',');
	_buf.append("ante=");
	_buf.appendInt(ante);
	_buf.append(',');
	_buf.append("isFast=");
	_buf.appendUint(isFast);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendInt(maxPlayers);
	_buf.append(',');
	_buf.append("chipsQuantum=");
	_buf.appendInt(chipsQuantum);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendInt(scalePM);
	_buf.append(',');
	_buf.append("tableStakes=");
	tableStakes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("variableAntes=");
	variableAntes.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::SeatFinderCli_MsgBodyStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("id", id, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("loBet", loBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("hiBet", hiBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("cap", cap, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("limit", limit, _buf);
	Atf::XmlElement::encodeAsXmlElement("minBuyIn", minBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxBuyIn", maxBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("ante", ante, _buf);
	Atf::XmlElement::encodeAsXmlElement("isFast", isFast, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPlayers", maxPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("chipsQuantum", chipsQuantum, _buf);
	Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
	tableStakes.toXmlString("tableStakes", _buf);
	variableAntes.toXmlString("variableAntes", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::SeatFinderCli_MsgBodyStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("id"))
		{
			id = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("loBet"))
		{
			loBet = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("hiBet"))
		{
			hiBet = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("cap"))
		{
			cap = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("game"))
		{
			game = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("limit"))
		{
			limit = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minBuyIn"))
		{
			minBuyIn = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxBuyIn"))
		{
			maxBuyIn = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("ante"))
		{
			ante = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isFast"))
		{
			isFast = (*_value.ptr() == '1');
		}
		else if (_element.equals("maxPlayers"))
		{
			maxPlayers = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("chipsQuantum"))
		{
			chipsQuantum = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("scalePM"))
		{
			scalePM = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableStakes"))
		{
			if(!Atf::AtfTempl< TableCommon::TableStakes >::FromXmlString(_value, tableStakes)) return false;
		}
		else if (_element.equals("variableAntes"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT64, 4 > >::FromXmlString(_value, variableAntes)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::SeatFinderCli_MsgBodyStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(SeatFinderCli_MsgBodyStruct())) // not empty
	{
		_body.composeUINT32(id);
		_body.composeString(currency);
		_body.composeINT8(isHiLo);
		_body.composeINT32(loBet);
		_body.composeINT32(hiBet);
		_body.composeINT32(cap);
		_body.composeINT8(game);
		_body.composeINT8(limit);
		_body.composeINT32(minBuyIn);
		_body.composeINT32(maxBuyIn);
		_body.composeINT32(ante);
		_body.composeBOOL(isFast);
		_body.composeINT8(maxPlayers);
		_body.composeINT32(chipsQuantum);
		_body.composeINT32(scalePM);
		tableStakes.composeMsg(_body, _ignoreJSON);
		variableAntes.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::cli::SeatFinderCli_MsgBodyStruct::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(id);
	_parser0.parseStringP(currency);
	_parser0.parseINT8(isHiLo);
	_parser0.parseINT32(loBet);
	_parser0.parseINT32(hiBet);
	_parser0.parseINT32(cap);
	_parser0.parseINT8(game);
	_parser0.parseINT8(limit);
	_parser0.parseINT32(minBuyIn);
	_parser0.parseINT32(maxBuyIn);
	_parser0.parseINT32(ante);
	_parser0.parseBOOL(isFast);
	_parser0.parseINT8(maxPlayers);
	_parser0.parseINT32(chipsQuantum);
	_parser0.parseINT32(scalePM);
	if(_parser0.parseEnded()) return;
	tableStakes.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	variableAntes.parseMsg(_parser0);
}

const char *Lobby::cli::SeatFinderCli_MsgBodyStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("id", id);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("loBet", loBet);
	_jsonstr.compose("hiBet", hiBet);
	_jsonstr.compose("cap", cap);
	_jsonstr.compose("game", game);
	_jsonstr.compose("limit", limit);
	_jsonstr.compose("minBuyIn", minBuyIn);
	_jsonstr.compose("maxBuyIn", maxBuyIn);
	_jsonstr.compose("ante", ante);
	_jsonstr.compose("isFast", isFast);
	_jsonstr.compose("maxPlayers", maxPlayers);
	_jsonstr.compose("chipsQuantum", chipsQuantum);
	_jsonstr.compose("scalePM", scalePM);
	_jsonstr.compose("tableStakes", tableStakes);
	_jsonstr.compose("variableAntes", variableAntes);
	return _buf.c_str();
}

void Lobby::cli::SeatFinderCli_MsgBodyStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("id", id);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("loBet", loBet);
	_jparser.parseByNameThrow("hiBet", hiBet);
	_jparser.parseByNameThrow("cap", cap);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("limit", limit);
	_jparser.parseByNameThrow("minBuyIn", minBuyIn);
	_jparser.parseByNameThrow("maxBuyIn", maxBuyIn);
	_jparser.parseByNameThrow("ante", ante);
	_jparser.parseByNameThrow("isFast", isFast);
	_jparser.parseByNameThrow("maxPlayers", maxPlayers);
	_jparser.parseByNameThrow("chipsQuantum", chipsQuantum);
	_jparser.parseByNameThrow("scalePM", scalePM);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tableStakes", tableStakes);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("variableAntes", variableAntes);
}

/* static */ void Lobby::cli::SeatFinderCli_MsgBodyStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 id; _jparser.validateByNameThrow("id", id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	INT8 isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	INT32 loBet; _jparser.validateByNameThrow("loBet", loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	INT32 hiBet; _jparser.validateByNameThrow("hiBet", hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	INT32 cap; _jparser.validateByNameThrow("cap", cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	INT8 game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	INT8 limit; _jparser.validateByNameThrow("limit", limit);
	AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
	INT32 minBuyIn; _jparser.validateByNameThrow("minBuyIn", minBuyIn);
	AtfValidator::validateInt(_descr, "minBuyIn", minBuyIn, _checker, __FILE__, __LINE__);
	INT32 maxBuyIn; _jparser.validateByNameThrow("maxBuyIn", maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	INT32 ante; _jparser.validateByNameThrow("ante", ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	bool isFast; _jparser.validateByNameThrow("isFast", isFast);
	AtfValidator::validateInt(_descr, "isFast", isFast, _checker, __FILE__, __LINE__);
	INT8 maxPlayers; _jparser.validateByNameThrow("maxPlayers", maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	INT32 chipsQuantum; _jparser.validateByNameThrow("chipsQuantum", chipsQuantum);
	AtfValidator::validateInt(_descr, "chipsQuantum", chipsQuantum, _checker, __FILE__, __LINE__);
	INT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	TableCommon::TableStakes tableStakes; _jparser.validateByNameThrow("tableStakes", tableStakes);
	if(_jparser.parseEnded()) return;
	Atf::AtfVectorBase< INT64 > variableAntes; _jparser.validateByNameThrow("variableAntes", variableAntes);
	AtfValidator::validateInt(_descr, "variableAntes", variableAntes.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::SeatFinderCli_MsgBodyStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 id; _parser0.parseUINT32(id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT8 isHiLo; _parser0.parseINT8(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	INT32 loBet; _parser0.parseINT32(loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	INT32 hiBet; _parser0.parseINT32(hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	INT32 cap; _parser0.parseINT32(cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	INT8 game; _parser0.parseINT8(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	INT8 limit; _parser0.parseINT8(limit);
	AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
	INT32 minBuyIn; _parser0.parseINT32(minBuyIn);
	AtfValidator::validateInt(_descr, "minBuyIn", minBuyIn, _checker, __FILE__, __LINE__);
	INT32 maxBuyIn; _parser0.parseINT32(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	INT32 ante; _parser0.parseINT32(ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	bool isFast; _parser0.parseBOOL(isFast);
	AtfValidator::validateInt(_descr, "isFast", isFast, _checker, __FILE__, __LINE__);
	INT8 maxPlayers; _parser0.parseINT8(maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	INT32 chipsQuantum; _parser0.parseINT32(chipsQuantum);
	AtfValidator::validateInt(_descr, "chipsQuantum", chipsQuantum, _checker, __FILE__, __LINE__);
	INT32 scalePM; _parser0.parseINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PString _descbuf;
	TableCommon::TableStakes::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tableStakes"), _fieldsWithUnparsedContent);
	if(_parser0.parseEnded()) return;
	int szVariableAntes = Atf::LAtfVector< INT64, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("variableAntes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "variableAntes", szVariableAntes, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY(Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, availChips(std::move(_o.availChips))
	, defaultBuyIn(std::move(_o.defaultBuyIn))
	, seatFinderCli(std::move(_o.seatFinderCli))
	, userRollId(std::move(_o.userRollId))
	, clientServiceFlag(std::move(_o.clientServiceFlag))
	, playChips(std::move(_o.playChips))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY& Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY::operator=(Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		availChips = std::move(_o.availChips);
		defaultBuyIn = std::move(_o.defaultBuyIn);
		seatFinderCli = std::move(_o.seatFinderCli);
		userRollId = std::move(_o.userRollId);
		clientServiceFlag = std::move(_o.clientServiceFlag);
		playChips = std::move(_o.playChips);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	availChips = 0;
	defaultBuyIn = 0;
	seatFinderCli.clear();
	userRollId = 0;
	clientServiceFlag = 0;
	playChips = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY::equals(const Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		availChips == _o.availChips &&
		defaultBuyIn == _o.defaultBuyIn &&
		seatFinderCli.equals(_o.seatFinderCli) &&
		userRollId == _o.userRollId &&
		clientServiceFlag == _o.clientServiceFlag &&
		playChips == _o.playChips;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("availChips=");
		_buf.appendInt(availChips);
		_buf.append(',');
		_buf.append("defaultBuyIn=");
		_buf.appendInt(defaultBuyIn);
		_buf.append(',');
		_buf.append("seatFinderCli=");
		seatFinderCli.toTraceString(_buf);
		_buf.append(',');
		_buf.append("userRollId=");
		_buf.appendInt(userRollId);
		_buf.append(',');
		_buf.append("clientServiceFlag=");
		_buf.appendUint(clientServiceFlag);
		_buf.append(',');
		_buf.append("playChips=");
		_buf.appendInt64(playChips);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("availChips", availChips, _buf);
		Atf::XmlElement::encodeAsXmlElement("defaultBuyIn", defaultBuyIn, _buf);
		seatFinderCli.toXmlString("seatFinderCli", _buf);
		Atf::XmlElement::encodeAsXmlElement("userRollId", userRollId, _buf);
		Atf::XmlElement::encodeAsXmlElement("clientServiceFlag", clientServiceFlag, _buf);
		Atf::XmlElement::encodeAsXmlElement("playChips", playChips, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("availChips"))
			{
				availChips = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("defaultBuyIn"))
			{
				defaultBuyIn = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("seatFinderCli"))
			{
				if(!Atf::AtfTempl< SeatFinderCli_MsgBodyStruct >::FromXmlString(_value, seatFinderCli)) return false;
			}
			else if (_element.equals("userRollId"))
			{
				userRollId = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientServiceFlag"))
			{
				clientServiceFlag = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("playChips"))
			{
				playChips = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(availChips);
		_msg.composeINT32(defaultBuyIn);
		seatFinderCli.composeMsg(_msg, _ignoreJSON);
		_msg.composeINT32(userRollId);
		_msg.composeBYTE(clientServiceFlag);
		_msg.composeINT64(playChips);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(availChips);
		_parser.parseINT32(defaultBuyIn);
		seatFinderCli.parseMsg(_parser);
		_parser.parseINT32(userRollId);
		_parser.parseBYTE(clientServiceFlag);
		_parser.parseINT64(playChips);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("availChips", availChips);
		_jsonstr.compose("defaultBuyIn", defaultBuyIn);
		_jsonstr.compose("seatFinderCli", seatFinderCli);
		_jsonstr.compose("userRollId", userRollId);
		_jsonstr.compose("clientServiceFlag", clientServiceFlag);
		_jsonstr.compose("playChips", playChips);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("availChips", availChips);
		_jparser.parseByNameThrow("defaultBuyIn", defaultBuyIn);
		_jparser.parseByNameThrow("seatFinderCli", seatFinderCli);
		_jparser.parseByNameThrow("userRollId", userRollId);
		_jparser.parseByNameThrow("clientServiceFlag", clientServiceFlag);
		_jparser.parseByNameThrow("playChips", playChips);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 availChips; _jparser.validateByNameThrow("availChips", availChips);
		AtfValidator::validateInt(_descr, "availChips", availChips, _checker, __FILE__, __LINE__);
		INT32 defaultBuyIn; _jparser.validateByNameThrow("defaultBuyIn", defaultBuyIn);
		AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
		SeatFinderCli_MsgBodyStruct seatFinderCli; _jparser.validateByNameThrow("seatFinderCli", seatFinderCli);
		INT32 userRollId; _jparser.validateByNameThrow("userRollId", userRollId);
		AtfValidator::validateInt(_descr, "userRollId", userRollId, _checker, __FILE__, __LINE__);
		BYTE clientServiceFlag; _jparser.validateByNameThrow("clientServiceFlag", clientServiceFlag);
		AtfValidator::validateInt(_descr, "clientServiceFlag", clientServiceFlag, _checker, __FILE__, __LINE__);
		INT64 playChips; _jparser.validateByNameThrow("playChips", playChips);
		AtfValidator::validateInt(_descr, "playChips", playChips, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 availChips; _parser.parseINT32(availChips);
		AtfValidator::validateInt(_descr, "availChips", availChips, _checker, __FILE__, __LINE__);
		INT32 defaultBuyIn; _parser.parseINT32(defaultBuyIn);
		AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
		PString _descbuf;
		SeatFinderCli_MsgBodyStruct::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("seatFinderCli"), _fieldsWithUnparsedContent);
		INT32 userRollId; _parser.parseINT32(userRollId);
		AtfValidator::validateInt(_descr, "userRollId", userRollId, _checker, __FILE__, __LINE__);
		BYTE clientServiceFlag; _parser.parseBYTE(clientServiceFlag);
		AtfValidator::validateInt(_descr, "clientServiceFlag", clientServiceFlag, _checker, __FILE__, __LINE__);
		INT64 playChips; _parser.parseINT64(playChips);
		AtfValidator::validateInt(_descr, "playChips", playChips, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_UPDATE_DOB
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB::Protocol_MSG_LOBBY_UPDATE_DOB()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB::Protocol_MSG_LOBBY_UPDATE_DOB(Protocol_MSG_LOBBY_UPDATE_DOB&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, dob(std::move(_o.dob))
{
}

Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB& Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB::operator=(Protocol_MSG_LOBBY_UPDATE_DOB&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		dob = std::move(_o.dob);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB::clear()
{
	notUsedStr.clear();
	dob.setNull();
}

bool Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB::equals(const Protocol_MSG_LOBBY_UPDATE_DOB& _o) const
{
	return Atf::atfPStringEquals(notUsedStr, _o.notUsedStr) &&
		dob.equals(_o.dob);
}

bool Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_UPDATE_DOB != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_UPDATE_DOB*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_UPDATE_DOB).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("dob=");
	Atf::AtfTempl<SrvDate>::ToTraceString(_buf, dob);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_UPDATE_DOB).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsedStr", notUsedStr, _buf);
	Atf::AtfTempl<SrvDate>::ToXmlString(_buf, "dob", dob);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedStr)) return false;
			}
			else if (_element.equals("dob"))
			{
				Atf::AtfTempl<SrvDate>::FromXmlString(_value, dob);
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsedStr);
	_msg.composeSrvDate(dob);
}

void Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseSrvDate(dob);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsedStr", notUsedStr);
	_jsonstr.compose("dob", dob);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsedStr", notUsedStr);
	_jparser.parseByNameThrow("dob", dob);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_UPDATE_DOB";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsedStr; _jparser.validateByNameThrow("notUsedStr", notUsedStr);
	AtfValidator::validateIntMax(_descr, "notUsedStr", notUsedStr.length(), 20, _checker, __FILE__, __LINE__);
	SrvDate dob; _jparser.validateByNameThrow("dob", dob);
	AtfValidator::validateSrvDateTime(_descr, "dob", dob, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_UPDATE_DOB";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	SrvDate dob; _parser.parseSrvDate(dob);
	AtfValidator::validateSrvDateTime(_descr, "dob", dob, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_UPDATE_DOB_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB_REPLY::Protocol_MSG_LOBBY_UPDATE_DOB_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB_REPLY::Protocol_MSG_LOBBY_UPDATE_DOB_REPLY(Protocol_MSG_LOBBY_UPDATE_DOB_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB_REPLY& Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB_REPLY::operator=(Protocol_MSG_LOBBY_UPDATE_DOB_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB_REPLY::equals(const Protocol_MSG_LOBBY_UPDATE_DOB_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc);
}

bool Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_UPDATE_DOB_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_UPDATE_DOB_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_UPDATE_DOB_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errDesc=");
	_buf.append(errDesc);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_UPDATE_DOB_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errDesc);
}

void Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(errDesc);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errDesc", errDesc);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errDesc", errDesc);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_UPDATE_DOB_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
	AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_UPDATE_DOB_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_UPDATE_DOB_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_TOURN
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN::Protocol_MSG_LOBBY_FIND_TOURN()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN::clear()
{
	id = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN::equals(const Protocol_MSG_LOBBY_FIND_TOURN& _o) const
{
	return id == _o.id;
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_FIND_TOURN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_FIND_TOURN*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_TOURN).append(")");
	_buf.append(',');
	_buf.append("id=");
	_buf.appendUint(id);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_FIND_TOURN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("id", id, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("id"))
			{
				id = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(id);
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(id);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("id", id);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("id", id);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TOURN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 id; _jparser.validateByNameThrow("id", id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TOURN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 id; _parser.parseUINT32(id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_TOURN_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REPLY::Protocol_MSG_LOBBY_FIND_TOURN_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REPLY::Protocol_MSG_LOBBY_FIND_TOURN_REPLY(Protocol_MSG_LOBBY_FIND_TOURN_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, tournamentId(std::move(_o.tournamentId))
	, server(std::move(_o.server))
	, tournFlags(std::move(_o.tournFlags))
	, tournFlags2(std::move(_o.tournFlags2))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REPLY& Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REPLY::operator=(Protocol_MSG_LOBBY_FIND_TOURN_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		tournamentId = std::move(_o.tournamentId);
		server = std::move(_o.server);
		tournFlags = std::move(_o.tournFlags);
		tournFlags2 = std::move(_o.tournFlags2);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	tournamentId = 0;
	server.clear();
	tournFlags = 0;
	tournFlags2 = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REPLY::equals(const Protocol_MSG_LOBBY_FIND_TOURN_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		tournamentId == _o.tournamentId &&
		Atf::atfPStringEquals(server, _o.server) &&
		tournFlags == _o.tournFlags &&
		tournFlags2 == _o.tournFlags2;
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_FIND_TOURN_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_FIND_TOURN_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_TOURN_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("tournamentId=");
		_buf.appendUint(tournamentId);
		_buf.append(',');
		_buf.append("server=");
		_buf.append(server);
		_buf.append(',');
		_buf.append("tournFlags=");
		_buf.appendUint(tournFlags);
		_buf.append(',');
		_buf.append("tournFlags2=");
		_buf.appendUint64(tournFlags2);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_FIND_TOURN_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("tournamentId", tournamentId, _buf);
		Atf::XmlElement::encodeAsXmlElement("server", server, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournFlags", tournFlags, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournFlags2", tournFlags2, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("tournamentId"))
			{
				tournamentId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("server"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, server)) return false;
			}
			else if (_element.equals("tournFlags"))
			{
				tournFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournFlags2"))
			{
				tournFlags2 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(tournamentId);
		_msg.composeString(server);
		_msg.composeUINT32(tournFlags);
		_msg.composeUINT64(tournFlags2);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(tournamentId);
		_parser.parseStringP(server);
		_parser.parseUINT32(tournFlags);
		_parser.parseUINT64(tournFlags2);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("tournamentId", tournamentId);
		_jsonstr.compose("server", server);
		_jsonstr.compose("tournFlags", tournFlags);
		_jsonstr.compose("tournFlags2", tournFlags2);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("tournamentId", tournamentId);
		_jparser.parseByNameThrow("server", server);
		_jparser.parseByNameThrow("tournFlags", tournFlags);
		_jparser.parseByNameThrow("tournFlags2", tournFlags2);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TOURN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 tournamentId; _jparser.validateByNameThrow("tournamentId", tournamentId);
		AtfValidator::validateInt(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
		PString server; _jparser.validateByNameThrow("server", server);
		AtfValidator::validateInt(_descr, "server", server.length(), _checker, __FILE__, __LINE__);
		UINT32 tournFlags; _jparser.validateByNameThrow("tournFlags", tournFlags);
		AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
		UINT64 tournFlags2; _jparser.validateByNameThrow("tournFlags2", tournFlags2);
		AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TOURN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 tournamentId; _parser.parseUINT32(tournamentId);
		AtfValidator::validateInt(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
		UINT32 tournFlags; _parser.parseUINT32(tournFlags);
		AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
		UINT64 tournFlags2; _parser.parseUINT64(tournFlags2);
		AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_WEB_FIND_TOURN
//=================================================================

Lobby::cli::Protocol_MSG_WEB_FIND_TOURN::Protocol_MSG_WEB_FIND_TOURN()
{
	clear();
}

void Lobby::cli::Protocol_MSG_WEB_FIND_TOURN::clear()
{
	id = 0;
}

bool Lobby::cli::Protocol_MSG_WEB_FIND_TOURN::equals(const Protocol_MSG_WEB_FIND_TOURN& _o) const
{
	return id == _o.id;
}

bool Lobby::cli::Protocol_MSG_WEB_FIND_TOURN::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_WEB_FIND_TOURN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_WEB_FIND_TOURN*)_other));
}

const char *Lobby::cli::Protocol_MSG_WEB_FIND_TOURN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_WEB_FIND_TOURN).append(")");
	_buf.append(',');
	_buf.append("id=");
	_buf.appendUint(id);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_WEB_FIND_TOURN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_WEB_FIND_TOURN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_WEB_FIND_TOURN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("id", id, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_WEB_FIND_TOURN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("id"))
			{
				id = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_WEB_FIND_TOURN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(id);
}

void Lobby::cli::Protocol_MSG_WEB_FIND_TOURN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(id);
}

const char *Lobby::cli::Protocol_MSG_WEB_FIND_TOURN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("id", id);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_WEB_FIND_TOURN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("id", id);
}

/*static*/ void Lobby::cli::Protocol_MSG_WEB_FIND_TOURN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_WEB_FIND_TOURN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 id; _jparser.validateByNameThrow("id", id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_WEB_FIND_TOURN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_WEB_FIND_TOURN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 id; _parser.parseUINT32(id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_WEB_FIND_TOURN_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_WEB_FIND_TOURN_REPLY::Protocol_MSG_WEB_FIND_TOURN_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_WEB_FIND_TOURN_REPLY::Protocol_MSG_WEB_FIND_TOURN_REPLY(Protocol_MSG_WEB_FIND_TOURN_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, tournamentId(std::move(_o.tournamentId))
	, server(std::move(_o.server))
	, tournFlags(std::move(_o.tournFlags))
	, tournFlags2(std::move(_o.tournFlags2))
{
}

Lobby::cli::Protocol_MSG_WEB_FIND_TOURN_REPLY& Lobby::cli::Protocol_MSG_WEB_FIND_TOURN_REPLY::operator=(Protocol_MSG_WEB_FIND_TOURN_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		tournamentId = std::move(_o.tournamentId);
		server = std::move(_o.server);
		tournFlags = std::move(_o.tournFlags);
		tournFlags2 = std::move(_o.tournFlags2);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_WEB_FIND_TOURN_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	tournamentId = 0;
	server.clear();
	tournFlags = 0;
	tournFlags2 = 0;
}

bool Lobby::cli::Protocol_MSG_WEB_FIND_TOURN_REPLY::equals(const Protocol_MSG_WEB_FIND_TOURN_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		tournamentId == _o.tournamentId &&
		Atf::atfPStringEquals(server, _o.server) &&
		tournFlags == _o.tournFlags &&
		tournFlags2 == _o.tournFlags2;
}

bool Lobby::cli::Protocol_MSG_WEB_FIND_TOURN_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_WEB_FIND_TOURN_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_WEB_FIND_TOURN_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_WEB_FIND_TOURN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_WEB_FIND_TOURN_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("tournamentId=");
		_buf.appendUint(tournamentId);
		_buf.append(',');
		_buf.append("server=");
		_buf.append(server);
		_buf.append(',');
		_buf.append("tournFlags=");
		_buf.appendUint(tournFlags);
		_buf.append(',');
		_buf.append("tournFlags2=");
		_buf.appendUint64(tournFlags2);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_WEB_FIND_TOURN_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_WEB_FIND_TOURN_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_WEB_FIND_TOURN_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("tournamentId", tournamentId, _buf);
		Atf::XmlElement::encodeAsXmlElement("server", server, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournFlags", tournFlags, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournFlags2", tournFlags2, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_WEB_FIND_TOURN_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("tournamentId"))
			{
				tournamentId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("server"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, server)) return false;
			}
			else if (_element.equals("tournFlags"))
			{
				tournFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournFlags2"))
			{
				tournFlags2 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_WEB_FIND_TOURN_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(tournamentId);
		_msg.composeString(server);
		_msg.composeUINT32(tournFlags);
		_msg.composeUINT64(tournFlags2);
	}
}

void Lobby::cli::Protocol_MSG_WEB_FIND_TOURN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(tournamentId);
		_parser.parseStringP(server);
		_parser.parseUINT32(tournFlags);
		_parser.parseUINT64(tournFlags2);
	}
}

const char *Lobby::cli::Protocol_MSG_WEB_FIND_TOURN_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("tournamentId", tournamentId);
		_jsonstr.compose("server", server);
		_jsonstr.compose("tournFlags", tournFlags);
		_jsonstr.compose("tournFlags2", tournFlags2);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_WEB_FIND_TOURN_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("tournamentId", tournamentId);
		_jparser.parseByNameThrow("server", server);
		_jparser.parseByNameThrow("tournFlags", tournFlags);
		_jparser.parseByNameThrow("tournFlags2", tournFlags2);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_WEB_FIND_TOURN_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_WEB_FIND_TOURN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 tournamentId; _jparser.validateByNameThrow("tournamentId", tournamentId);
		AtfValidator::validateInt(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
		PString server; _jparser.validateByNameThrow("server", server);
		AtfValidator::validateInt(_descr, "server", server.length(), _checker, __FILE__, __LINE__);
		UINT32 tournFlags; _jparser.validateByNameThrow("tournFlags", tournFlags);
		AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
		UINT64 tournFlags2; _jparser.validateByNameThrow("tournFlags2", tournFlags2);
		AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_WEB_FIND_TOURN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_WEB_FIND_TOURN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 tournamentId; _parser.parseUINT32(tournamentId);
		AtfValidator::validateInt(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
		UINT32 tournFlags; _parser.parseUINT32(tournFlags);
		AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
		UINT64 tournFlags2; _parser.parseUINT64(tournFlags2);
		AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    Text
//=================================================================

Lobby::cli::Text::Text()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Text::Text(Text&& _o)
	: text1(std::move(_o.text1))
	, text2(std::move(_o.text2))
{
}

Lobby::cli::Text& Lobby::cli::Text::operator=(Text&& _o)
{
	if(this != &_o)
	{
		text1 = std::move(_o.text1);
		text2 = std::move(_o.text2);
	}
	return *this;
}

#endif

void Lobby::cli::Text::clear()
{
	text1.clear();
	text2.clear();
}

bool Lobby::cli::Text::equals(const Text& _o) const
{
	return Atf::atfPStringEquals(text1, _o.text1) &&
		Atf::atfPStringEquals(text2, _o.text2);
}

const char *Lobby::cli::Text::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("text1=");
	_buf.append(text1);
	_buf.append(',');
	_buf.append("text2=");
	_buf.append(text2);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::Text::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("text1", text1, _buf);
	Atf::XmlElement::encodeAsXmlElement("text2", text2, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::Text::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("text1"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, text1)) return false;
		}
		else if (_element.equals("text2"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, text2)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::Text::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(text1);
	_msg.composeString(text2);
}

void Lobby::cli::Text::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(text1);
	_parser.parseStringP(text2);
}

const char *Lobby::cli::Text::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("text1", text1);
	_jsonstr.compose("text2", text2);
	return _buf.c_str();
}

void Lobby::cli::Text::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("text1", text1);
	_jparser.parseByNameThrow("text2", text2);
}

/* static */ void Lobby::cli::Text::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString text1; _jparser.validateByNameThrow("text1", text1);
	AtfValidator::validateIntMax(_descr, "text1", text1.length(), 10000, _checker, __FILE__, __LINE__);
	PString text2; _jparser.validateByNameThrow("text2", text2);
	AtfValidator::validateIntMax(_descr, "text2", text2.length(), 10000, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Text::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "text1"); size_t szText1 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "text1", szText1, 10000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "text2"); size_t szText2 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "text2", szText2, 10000, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    Name
//=================================================================

Lobby::cli::Name::Name()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Name::Name(Name&& _o)
	: name(std::move(_o.name))
{
}

Lobby::cli::Name& Lobby::cli::Name::operator=(Name&& _o)
{
	if(this != &_o)
	{
		name = std::move(_o.name);
	}
	return *this;
}

#endif

void Lobby::cli::Name::clear()
{
	name.clear();
}

bool Lobby::cli::Name::equals(const Name& _o) const
{
	return Atf::atfPStringEquals(name, _o.name);
}

const char *Lobby::cli::Name::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("name=");
	_buf.append(name);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::Name::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::Name::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("name"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::Name::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(name);
}

void Lobby::cli::Name::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(name);
}

const char *Lobby::cli::Name::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("name", name);
	return _buf.c_str();
}

void Lobby::cli::Name::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("name", name);
}

/* static */ void Lobby::cli::Name::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateIntMax(_descr, "name", name.length(), 10000, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Name::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "name", szName, 10000, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_CHAT_COMPL
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_CHAT_COMPL::Protocol_MSG_LOBBY_CHAT_COMPL()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_CHAT_COMPL::Protocol_MSG_LOBBY_CHAT_COMPL(Protocol_MSG_LOBBY_CHAT_COMPL&& _o)
	: handId(std::move(_o.handId))
	, tableName(std::move(_o.tableName))
	, comment(std::move(_o.comment))
	, tableId32(std::move(_o.tableId32))
	, texts(std::move(_o.texts))
	, names(std::move(_o.names))
	, tournId(std::move(_o.tournId))
	, finalTableText(std::move(_o.finalTableText))
	, zoomReplayId(std::move(_o.zoomReplayId))
	, tableId(std::move(_o.tableId))
{
}

Lobby::cli::Protocol_MSG_LOBBY_CHAT_COMPL& Lobby::cli::Protocol_MSG_LOBBY_CHAT_COMPL::operator=(Protocol_MSG_LOBBY_CHAT_COMPL&& _o)
{
	if(this != &_o)
	{
		handId = std::move(_o.handId);
		tableName = std::move(_o.tableName);
		comment = std::move(_o.comment);
		tableId32 = std::move(_o.tableId32);
		texts = std::move(_o.texts);
		names = std::move(_o.names);
		tournId = std::move(_o.tournId);
		finalTableText = std::move(_o.finalTableText);
		zoomReplayId = std::move(_o.zoomReplayId);
		tableId = std::move(_o.tableId);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_CHAT_COMPL::clear()
{
	handId = 0;
	tableName.clear();
	comment.clear();
	tableId32 = 0;
	texts.clear();
	names.clear();
	tournId = 0;
	finalTableText.clear();
	zoomReplayId = 0;
	tableId = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_CHAT_COMPL::equals(const Protocol_MSG_LOBBY_CHAT_COMPL& _o) const
{
	return handId == _o.handId &&
		Atf::atfPStringEquals(tableName, _o.tableName) &&
		Atf::atfPStringEquals(comment, _o.comment) &&
		tableId32 == _o.tableId32 &&
		texts.equals(_o.texts) &&
		names.equals(_o.names) &&
		tournId == _o.tournId &&
		Atf::atfPStringEquals(finalTableText, _o.finalTableText) &&
		zoomReplayId == _o.zoomReplayId &&
		tableId == _o.tableId;
}

bool Lobby::cli::Protocol_MSG_LOBBY_CHAT_COMPL::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_CHAT_COMPL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_CHAT_COMPL*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CHAT_COMPL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CHAT_COMPL).append(")");
	_buf.append(',');
	_buf.append("handId=");
	_buf.appendUint64(handId);
	_buf.append(',');
	_buf.append("tableName=");
	_buf.append(tableName);
	_buf.append(',');
	_buf.append("comment=");
	_buf.append(comment);
	_buf.append(',');
	_buf.append("tableId32=");
	_buf.appendUint(tableId32);
	_buf.append(',');
	_buf.append("texts=");
	texts.toTraceString(_buf);
	_buf.append(',');
	_buf.append("names=");
	names.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("finalTableText=");
	_buf.append(finalTableText);
	_buf.append(',');
	_buf.append("zoomReplayId=");
	_buf.appendUint(zoomReplayId);
	_buf.append(',');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CHAT_COMPL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CHAT_COMPL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_CHAT_COMPL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("handId", handId, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableName", tableName, _buf);
	Atf::XmlElement::encodeAsXmlElement("comment", comment, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableId32", tableId32, _buf);
	texts.toXmlString("texts", _buf);
	names.toXmlString("names", _buf);
	Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
	Atf::XmlElement::encodeAsXmlElement("finalTableText", finalTableText, _buf);
	Atf::XmlElement::encodeAsXmlElement("zoomReplayId", zoomReplayId, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableId", tableId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_CHAT_COMPL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("handId"))
			{
				handId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tableName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tableName)) return false;
			}
			else if (_element.equals("comment"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, comment)) return false;
			}
			else if (_element.equals("tableId32"))
			{
				tableId32 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("texts"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< Text, 4 > >::FromXmlString(_value, texts)) return false;
			}
			else if (_element.equals("names"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< Name, 4 > >::FromXmlString(_value, names)) return false;
			}
			else if (_element.equals("tournId"))
			{
				tournId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("finalTableText"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, finalTableText)) return false;
			}
			else if (_element.equals("zoomReplayId"))
			{
				zoomReplayId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tableId"))
			{
				tableId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_CHAT_COMPL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(handId);
	_msg.composeString(tableName);
	_msg.composeString(comment);
	_msg.composeUINT32(tableId32);
	texts.composeMsg(_msg, _ignoreJSON);
	names.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(tournId);
	_msg.composeString(finalTableText);
	_msg.composeUINT32(zoomReplayId);
	_msg.composeUINT64(tableId);
}

void Lobby::cli::Protocol_MSG_LOBBY_CHAT_COMPL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(handId);
	_parser.parseStringP(tableName);
	_parser.parseStringP(comment);
	_parser.parseUINT32(tableId32);
	texts.parseMsg(_parser);
	names.parseMsg(_parser);
	_parser.parseUINT32(tournId);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(finalTableText);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(zoomReplayId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(tableId);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CHAT_COMPL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("handId", handId);
	_jsonstr.compose("tableName", tableName);
	_jsonstr.compose("comment", comment);
	_jsonstr.compose("tableId32", tableId32);
	_jsonstr.compose("texts", texts);
	_jsonstr.compose("names", names);
	_jsonstr.compose("tournId", tournId);
	_jsonstr.compose("finalTableText", finalTableText);
	_jsonstr.compose("zoomReplayId", zoomReplayId);
	_jsonstr.compose("tableId", tableId);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_CHAT_COMPL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("handId", handId);
	_jparser.parseByNameThrow("tableName", tableName);
	_jparser.parseByNameThrow("comment", comment);
	_jparser.parseByNameThrow("tableId32", tableId32);
	_jparser.parseByNameThrow("texts", texts);
	_jparser.parseByNameThrow("names", names);
	_jparser.parseByNameThrow("tournId", tournId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("finalTableText", finalTableText);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("zoomReplayId", zoomReplayId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tableId", tableId);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CHAT_COMPL::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CHAT_COMPL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT64 handId; _jparser.validateByNameThrow("handId", handId);
	AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
	PString tableName; _jparser.validateByNameThrow("tableName", tableName);
	AtfValidator::validateIntMax(_descr, "tableName", tableName.length(), TABLE_NAME_LEN, _checker, __FILE__, __LINE__);
	PString comment; _jparser.validateByNameThrow("comment", comment);
	AtfValidator::validateIntMax(_descr, "comment", comment.length(), 1000, _checker, __FILE__, __LINE__);
	UINT32 tableId32; _jparser.validateByNameThrow("tableId32", tableId32);
	AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< Text > texts; _jparser.validateByNameThrow("texts", texts);
	AtfValidator::validateIntMax(_descr, "texts", texts.size(), 10000, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< Name > names; _jparser.validateByNameThrow("names", names);
	AtfValidator::validateIntMax(_descr, "names", names.size(), 10000, _checker, __FILE__, __LINE__);
	UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString finalTableText; _jparser.validateByNameThrow("finalTableText", finalTableText);
	AtfValidator::validateIntMax(_descr, "finalTableText", finalTableText.length(), 10000, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 zoomReplayId; _jparser.validateByNameThrow("zoomReplayId", zoomReplayId);
	AtfValidator::validateInt(_descr, "zoomReplayId", zoomReplayId, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT64 tableId; _jparser.validateByNameThrow("tableId", tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CHAT_COMPL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CHAT_COMPL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT64 handId; _parser.parseUINT64(handId);
	AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "tableName"); size_t szTableName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "tableName", szTableName, TABLE_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "comment"); size_t szComment = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "comment", szComment, 1000, _checker, __FILE__, __LINE__);
	UINT32 tableId32; _parser.parseUINT32(tableId32);
	AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTexts = Atf::LAtfVector< Text, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("texts"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "texts", szTexts, 10000, _checker, __FILE__, __LINE__);
	int szNames = Atf::LAtfVector< Name, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("names"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "names", szNames, 10000, _checker, __FILE__, __LINE__);
	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "finalTableText"); size_t szFinalTableText = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "finalTableText", szFinalTableText, 10000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 zoomReplayId; _parser.parseUINT32(zoomReplayId);
	AtfValidator::validateInt(_descr, "zoomReplayId", zoomReplayId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 tableId; _parser.parseUINT64(tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CLI_BOUNCED
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED::Protocol_MSG_LOBBY_CLI_BOUNCED()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED::Protocol_MSG_LOBBY_CLI_BOUNCED(Protocol_MSG_LOBBY_CLI_BOUNCED&& _o)
	: email(std::move(_o.email))
{
}

Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED& Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED::operator=(Protocol_MSG_LOBBY_CLI_BOUNCED&& _o)
{
	if(this != &_o)
	{
		email = std::move(_o.email);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED::clear()
{
	email.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED::equals(const Protocol_MSG_LOBBY_CLI_BOUNCED& _o) const
{
	return Atf::atfPStringEquals(email, _o.email);
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_CLI_BOUNCED != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_CLI_BOUNCED*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CLI_BOUNCED).append(")");
	_buf.append(',');
	_buf.append("email=");
	_buf.append(email);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_CLI_BOUNCED).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("email", email, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("email"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, email)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(email);
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(email);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("email", email);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("email", email);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLI_BOUNCED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString email; _jparser.validateByNameThrow("email", email);
	AtfValidator::validateInt(_descr, "email", email.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLI_BOUNCED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
	AtfValidator::validateInt(_descr, "email", szEmail, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY::Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY::Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY(Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, reset(std::move(_o.reset))
	, sendValidationCode(std::move(_o.sendValidationCode))
{
}

Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY& Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY::operator=(Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		reset = std::move(_o.reset);
		sendValidationCode = std::move(_o.sendValidationCode);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY::clear()
{
	notUsedStr.clear();
	reset = 0;
	sendValidationCode = false;
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY::equals(const Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY& _o) const
{
	return Atf::atfPStringEquals(notUsedStr, _o.notUsedStr) &&
		reset == _o.reset &&
		sendValidationCode == _o.sendValidationCode;
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_CLI_BOUNCED_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CLI_BOUNCED_REPLY).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("reset=");
	_buf.appendUint(reset);
	_buf.append(',');
	_buf.append("sendValidationCode=");
	_buf.appendUint(sendValidationCode);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_CLI_BOUNCED_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsedStr", notUsedStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("reset", reset, _buf);
	Atf::XmlElement::encodeAsXmlElement("sendValidationCode", sendValidationCode, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedStr)) return false;
			}
			else if (_element.equals("reset"))
			{
				reset = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("sendValidationCode"))
			{
				sendValidationCode = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsedStr);
	_msg.composeBYTE(reset);
	_msg.composeBOOL(sendValidationCode);
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseBYTE(reset);
	_parser.parseBOOL(sendValidationCode);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsedStr", notUsedStr);
	_jsonstr.compose("reset", reset);
	_jsonstr.compose("sendValidationCode", sendValidationCode);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsedStr", notUsedStr);
	_jparser.parseByNameThrow("reset", reset);
	_jparser.parseByNameThrow("sendValidationCode", sendValidationCode);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLI_BOUNCED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsedStr; _jparser.validateByNameThrow("notUsedStr", notUsedStr);
	AtfValidator::validateIntMax(_descr, "notUsedStr", notUsedStr.length(), 20, _checker, __FILE__, __LINE__);
	BYTE reset; _jparser.validateByNameThrow("reset", reset);
	AtfValidator::validateIntMax(_descr, "reset", reset, 1, _checker, __FILE__, __LINE__);
	bool sendValidationCode; _jparser.validateByNameThrow("sendValidationCode", sendValidationCode);
	AtfValidator::validateInt(_descr, "sendValidationCode", sendValidationCode, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLI_BOUNCED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	BYTE reset; _parser.parseBYTE(reset);
	AtfValidator::validateIntMax(_descr, "reset", reset, 1, _checker, __FILE__, __LINE__);
	bool sendValidationCode; _parser.parseBOOL(sendValidationCode);
	AtfValidator::validateInt(_descr, "sendValidationCode", sendValidationCode, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CREATE_USERTOURN
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_CREATE_USERTOURN::Protocol_MSG_LOBBY_CREATE_USERTOURN()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_CREATE_USERTOURN::Protocol_MSG_LOBBY_CREATE_USERTOURN(Protocol_MSG_LOBBY_CREATE_USERTOURN&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, password(std::move(_o.password))
	, game(std::move(_o.game))
	, isHL(std::move(_o.isHL))
	, limit(std::move(_o.limit))
	, mon(std::move(_o.mon))
	, day(std::move(_o.day))
	, hour(std::move(_o.hour))
	, minute(std::move(_o.minute))
	, buyIn(std::move(_o.buyIn))
	, rake(std::move(_o.rake))
	, message(std::move(_o.message))
	, name(std::move(_o.name))
	, olymp(std::move(_o.olymp))
{
}

Lobby::cli::Protocol_MSG_LOBBY_CREATE_USERTOURN& Lobby::cli::Protocol_MSG_LOBBY_CREATE_USERTOURN::operator=(Protocol_MSG_LOBBY_CREATE_USERTOURN&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		password = std::move(_o.password);
		game = std::move(_o.game);
		isHL = std::move(_o.isHL);
		limit = std::move(_o.limit);
		mon = std::move(_o.mon);
		day = std::move(_o.day);
		hour = std::move(_o.hour);
		minute = std::move(_o.minute);
		buyIn = std::move(_o.buyIn);
		rake = std::move(_o.rake);
		message = std::move(_o.message);
		name = std::move(_o.name);
		olymp = std::move(_o.olymp);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_CREATE_USERTOURN::clear()
{
	notUsedStr.clear();
	password.clear();
	game = 0;
	isHL = 0;
	limit = 0;
	mon = 0;
	day = 0;
	hour = 0;
	minute = 0;
	buyIn = 0;
	rake = 0;
	message.clear();
	name.clear();
	olymp = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_CREATE_USERTOURN::equals(const Protocol_MSG_LOBBY_CREATE_USERTOURN& _o) const
{
	return Atf::atfPStringEquals(notUsedStr, _o.notUsedStr) &&
		Atf::atfPStringEquals(password, _o.password) &&
		game == _o.game &&
		isHL == _o.isHL &&
		limit == _o.limit &&
		mon == _o.mon &&
		day == _o.day &&
		hour == _o.hour &&
		minute == _o.minute &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		Atf::atfPStringEquals(message, _o.message) &&
		Atf::atfPStringEquals(name, _o.name) &&
		olymp == _o.olymp;
}

bool Lobby::cli::Protocol_MSG_LOBBY_CREATE_USERTOURN::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_CREATE_USERTOURN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_CREATE_USERTOURN*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CREATE_USERTOURN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CREATE_USERTOURN).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("password=");
	_buf.append(password);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("isHL=");
	_buf.appendUint(isHL);
	_buf.append(',');
	_buf.append("limit=");
	_buf.appendUint(limit);
	_buf.append(',');
	_buf.append("mon=");
	_buf.appendUint(mon);
	_buf.append(',');
	_buf.append("day=");
	_buf.appendUint(day);
	_buf.append(',');
	_buf.append("hour=");
	_buf.appendUint(hour);
	_buf.append(',');
	_buf.append("minute=");
	_buf.appendUint(minute);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendInt(buyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendInt(rake);
	_buf.append(',');
	_buf.append("message=");
	_buf.append(message);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("olymp=");
	_buf.appendUint(olymp);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CREATE_USERTOURN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CREATE_USERTOURN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_CREATE_USERTOURN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsedStr", notUsedStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("password", password, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHL", isHL, _buf);
	Atf::XmlElement::encodeAsXmlElement("limit", limit, _buf);
	Atf::XmlElement::encodeAsXmlElement("mon", mon, _buf);
	Atf::XmlElement::encodeAsXmlElement("day", day, _buf);
	Atf::XmlElement::encodeAsXmlElement("hour", hour, _buf);
	Atf::XmlElement::encodeAsXmlElement("minute", minute, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyIn", buyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("rake", rake, _buf);
	Atf::XmlElement::encodeAsXmlElement("message", message, _buf);
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	Atf::XmlElement::encodeAsXmlElement("olymp", olymp, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_CREATE_USERTOURN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedStr)) return false;
			}
			else if (_element.equals("password"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, password)) return false;
			}
			else if (_element.equals("game"))
			{
				game = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isHL"))
			{
				isHL = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("limit"))
			{
				limit = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("mon"))
			{
				mon = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("day"))
			{
				day = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("hour"))
			{
				hour = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minute"))
			{
				minute = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("buyIn"))
			{
				buyIn = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("rake"))
			{
				rake = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("message"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, message)) return false;
			}
			else if (_element.equals("name"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
			}
			else if (_element.equals("olymp"))
			{
				olymp = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_CREATE_USERTOURN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsedStr);
	_msg.composeString(password);
	_msg.composeBYTE(game);
	_msg.composeBYTE(isHL);
	_msg.composeBYTE(limit);
	_msg.composeBYTE(mon);
	_msg.composeBYTE(day);
	_msg.composeBYTE(hour);
	_msg.composeBYTE(minute);
	_msg.composeINT32(buyIn);
	_msg.composeINT32(rake);
	_msg.composeString(message);
	_msg.composeString(name);
	_msg.composeBYTE(olymp);
}

void Lobby::cli::Protocol_MSG_LOBBY_CREATE_USERTOURN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseStringP(password);
	_parser.parseBYTE(game);
	_parser.parseBYTE(isHL);
	_parser.parseBYTE(limit);
	_parser.parseBYTE(mon);
	_parser.parseBYTE(day);
	_parser.parseBYTE(hour);
	_parser.parseBYTE(minute);
	_parser.parseINT32(buyIn);
	_parser.parseINT32(rake);
	_parser.parseStringP(message);
	_parser.parseStringP(name);
	_parser.parseBYTE(olymp);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CREATE_USERTOURN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsedStr", notUsedStr);
	_jsonstr.compose("password", password);
	_jsonstr.compose("game", game);
	_jsonstr.compose("isHL", isHL);
	_jsonstr.compose("limit", limit);
	_jsonstr.compose("mon", mon);
	_jsonstr.compose("day", day);
	_jsonstr.compose("hour", hour);
	_jsonstr.compose("minute", minute);
	_jsonstr.compose("buyIn", buyIn);
	_jsonstr.compose("rake", rake);
	_jsonstr.compose("message", message);
	_jsonstr.compose("name", name);
	_jsonstr.compose("olymp", olymp);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_CREATE_USERTOURN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsedStr", notUsedStr);
	_jparser.parseByNameThrow("password", password);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("isHL", isHL);
	_jparser.parseByNameThrow("limit", limit);
	_jparser.parseByNameThrow("mon", mon);
	_jparser.parseByNameThrow("day", day);
	_jparser.parseByNameThrow("hour", hour);
	_jparser.parseByNameThrow("minute", minute);
	_jparser.parseByNameThrow("buyIn", buyIn);
	_jparser.parseByNameThrow("rake", rake);
	_jparser.parseByNameThrow("message", message);
	_jparser.parseByNameThrow("name", name);
	_jparser.parseByNameThrow("olymp", olymp);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CREATE_USERTOURN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CREATE_USERTOURN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsedStr; _jparser.validateByNameThrow("notUsedStr", notUsedStr);
	AtfValidator::validateIntMax(_descr, "notUsedStr", notUsedStr.length(), 20, _checker, __FILE__, __LINE__);
	PString password; _jparser.validateByNameThrow("password", password);
	AtfValidator::validateIntMax(_descr, "password", password.length(), 1000, _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateIntMax(_descr, "game", game, HandType_Last, _checker, __FILE__, __LINE__);
	BYTE isHL; _jparser.validateByNameThrow("isHL", isHL);
	AtfValidator::validateIntMax(_descr, "isHL", isHL, 1, _checker, __FILE__, __LINE__);
	BYTE limit; _jparser.validateByNameThrow("limit", limit);
	AtfValidator::validateIntMax(_descr, "limit", limit, PotStruct_Last, _checker, __FILE__, __LINE__);
	BYTE mon; _jparser.validateByNameThrow("mon", mon);
	AtfValidator::validateIntMax(_descr, "mon", mon, 12, _checker, __FILE__, __LINE__);
	BYTE day; _jparser.validateByNameThrow("day", day);
	AtfValidator::validateIntMax(_descr, "day", day, 31, _checker, __FILE__, __LINE__);
	BYTE hour; _jparser.validateByNameThrow("hour", hour);
	AtfValidator::validateIntMax(_descr, "hour", hour, 23, _checker, __FILE__, __LINE__);
	BYTE minute; _jparser.validateByNameThrow("minute", minute);
	AtfValidator::validateIntMax(_descr, "minute", minute, 59, _checker, __FILE__, __LINE__);
	INT32 buyIn; _jparser.validateByNameThrow("buyIn", buyIn);
	AtfValidator::validateIntRange(_descr, "buyIn", buyIn, -2000000000, 20000000, _checker, __FILE__, __LINE__);
	INT32 rake; _jparser.validateByNameThrow("rake", rake);
	AtfValidator::validateIntRange(_descr, "rake", rake, -2000000000, 20000000, _checker, __FILE__, __LINE__);
	PString message; _jparser.validateByNameThrow("message", message);
	AtfValidator::validateIntMax(_descr, "message", message.length(), 1000, _checker, __FILE__, __LINE__);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateIntMax(_descr, "name", name.length(), 200, _checker, __FILE__, __LINE__);
	BYTE olymp; _jparser.validateByNameThrow("olymp", olymp);
	AtfValidator::validateIntMax(_descr, "olymp", olymp, 1, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CREATE_USERTOURN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CREATE_USERTOURN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "password"); size_t szPassword = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "password", szPassword, 1000, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateIntMax(_descr, "game", game, HandType_Last, _checker, __FILE__, __LINE__);
	BYTE isHL; _parser.parseBYTE(isHL);
	AtfValidator::validateIntMax(_descr, "isHL", isHL, 1, _checker, __FILE__, __LINE__);
	BYTE limit; _parser.parseBYTE(limit);
	AtfValidator::validateIntMax(_descr, "limit", limit, PotStruct_Last, _checker, __FILE__, __LINE__);
	BYTE mon; _parser.parseBYTE(mon);
	AtfValidator::validateIntMax(_descr, "mon", mon, 12, _checker, __FILE__, __LINE__);
	BYTE day; _parser.parseBYTE(day);
	AtfValidator::validateIntMax(_descr, "day", day, 31, _checker, __FILE__, __LINE__);
	BYTE hour; _parser.parseBYTE(hour);
	AtfValidator::validateIntMax(_descr, "hour", hour, 23, _checker, __FILE__, __LINE__);
	BYTE minute; _parser.parseBYTE(minute);
	AtfValidator::validateIntMax(_descr, "minute", minute, 59, _checker, __FILE__, __LINE__);
	INT32 buyIn; _parser.parseINT32(buyIn);
	AtfValidator::validateIntRange(_descr, "buyIn", buyIn, -2000000000, 20000000, _checker, __FILE__, __LINE__);
	INT32 rake; _parser.parseINT32(rake);
	AtfValidator::validateIntRange(_descr, "rake", rake, -2000000000, 20000000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "message"); size_t szMessage = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "message", szMessage, 1000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "name", szName, 200, _checker, __FILE__, __LINE__);
	BYTE olymp; _parser.parseBYTE(olymp);
	AtfValidator::validateIntMax(_descr, "olymp", olymp, 1, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    TournamentCreationError
//=================================================================

Lobby::cli::TournamentCreationError::TournamentCreationError()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::TournamentCreationError::TournamentCreationError(TournamentCreationError&& _o)
	: userId(std::move(_o.userId))
	, error_code(std::move(_o.error_code))
	, errDescr(std::move(_o.errDescr))
{
}

Lobby::cli::TournamentCreationError& Lobby::cli::TournamentCreationError::operator=(TournamentCreationError&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		error_code = std::move(_o.error_code);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void Lobby::cli::TournamentCreationError::clear()
{
	userId.clear();
	error_code = 0;
	errDescr.clear();
}

bool Lobby::cli::TournamentCreationError::equals(const TournamentCreationError& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		error_code == _o.error_code &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

const char *Lobby::cli::TournamentCreationError::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("error_code=");
	_buf.appendUint(error_code);
	_buf.append(',');
	_buf.append("errDescr=");
	_buf.append(errDescr);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::TournamentCreationError::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("error_code", error_code, _buf);
	Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::TournamentCreationError::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("userId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
		}
		else if (_element.equals("error_code"))
		{
			error_code = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("errDescr"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::TournamentCreationError::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeUINT32(error_code);
	_msg.composeString(errDescr);
}

void Lobby::cli::TournamentCreationError::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseUINT32(error_code);
	_parser.parseStringP(errDescr);
}

const char *Lobby::cli::TournamentCreationError::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("error_code", error_code);
	_jsonstr.compose("errDescr", errDescr);
	return _buf.c_str();
}

void Lobby::cli::TournamentCreationError::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("error_code", error_code);
	_jparser.parseByNameThrow("errDescr", errDescr);
}

/* static */ void Lobby::cli::TournamentCreationError::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateInt(_descr, "userId", userId.length(), _checker, __FILE__, __LINE__);
	UINT32 error_code; _jparser.validateByNameThrow("error_code", error_code);
	AtfValidator::validateInt(_descr, "error_code", error_code, _checker, __FILE__, __LINE__);
	PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
	AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::TournamentCreationError::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	UINT32 error_code; _parser.parseUINT32(error_code);
	AtfValidator::validateInt(_descr, "error_code", error_code, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY::Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY::Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY(Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, tournId(std::move(_o.tournId))
	, timeLeft(std::move(_o.timeLeft))
	, errors(std::move(_o.errors))
	, warning(std::move(_o.warning))
	, restartWarning(std::move(_o.restartWarning))
{
}

Lobby::cli::Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY& Lobby::cli::Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY::operator=(Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		tournId = std::move(_o.tournId);
		timeLeft = std::move(_o.timeLeft);
		errors = std::move(_o.errors);
		warning = std::move(_o.warning);
		restartWarning = std::move(_o.restartWarning);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	tournId = 0;
	timeLeft = 0;
	errors.clear();
	warning.clear();
	restartWarning.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY::equals(const Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		tournId == _o.tournId &&
		timeLeft == _o.timeLeft &&
		errors.equals(_o.errors) &&
		Atf::atfPStringEquals(warning, _o.warning) &&
		Atf::atfPStringEquals(restartWarning, _o.restartWarning);
}

bool Lobby::cli::Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_CREATE_TOURNAMENT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CREATE_TOURNAMENT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != 0 )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("tournId=");
		_buf.appendUint(tournId);
		_buf.append(',');
		_buf.append("timeLeft=");
		_buf.appendUint(timeLeft);
		_buf.append(',');
		_buf.append("errors=");
		errors.toTraceString(_buf);
		_buf.append(',');
		_buf.append("warning=");
		_buf.append(warning);
		_buf.append(',');
		_buf.append("restartWarning=");
		_buf.append(restartWarning);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_CREATE_TOURNAMENT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode != 0 )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
		Atf::XmlElement::encodeAsXmlElement("timeLeft", timeLeft, _buf);
		errors.toXmlString("errors", _buf);
		Atf::XmlElement::encodeAsXmlElement("warning", warning, _buf);
		Atf::XmlElement::encodeAsXmlElement("restartWarning", restartWarning, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("tournId"))
			{
				tournId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("timeLeft"))
			{
				timeLeft = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errors"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TournamentCreationError, 4 > >::FromXmlString(_value, errors)) return false;
			}
			else if (_element.equals("warning"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, warning)) return false;
			}
			else if (_element.equals("restartWarning"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, restartWarning)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode != 0 )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(tournId);
		_msg.composeUINT32(timeLeft);
		errors.composeMsg(_msg, _ignoreJSON);
		_msg.composeString(warning);
		_msg.composeString(restartWarning);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != 0 )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(tournId);
		_parser.parseUINT32(timeLeft);
		errors.parseMsg(_parser);
		_parser.parseStringP(warning);
		_parser.parseStringP(restartWarning);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode != 0 )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("tournId", tournId);
		_jsonstr.compose("timeLeft", timeLeft);
		_jsonstr.compose("errors", errors);
		_jsonstr.compose("warning", warning);
		_jsonstr.compose("restartWarning", restartWarning);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode != 0 )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("tournId", tournId);
		_jparser.parseByNameThrow("timeLeft", timeLeft);
		_jparser.parseByNameThrow("errors", errors);
		_jparser.parseByNameThrow("warning", warning);
		_jparser.parseByNameThrow("restartWarning", restartWarning);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CREATE_TOURNAMENT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
		AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
		UINT32 timeLeft; _jparser.validateByNameThrow("timeLeft", timeLeft);
		AtfValidator::validateInt(_descr, "timeLeft", timeLeft, _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< TournamentCreationError > errors; _jparser.validateByNameThrow("errors", errors);
		AtfValidator::validateInt(_descr, "errors", errors.size(), _checker, __FILE__, __LINE__);
		PString warning; _jparser.validateByNameThrow("warning", warning);
		AtfValidator::validateInt(_descr, "warning", warning.length(), _checker, __FILE__, __LINE__);
		PString restartWarning; _jparser.validateByNameThrow("restartWarning", restartWarning);
		AtfValidator::validateInt(_descr, "restartWarning", restartWarning.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CREATE_TOURNAMENT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 tournId; _parser.parseUINT32(tournId);
		AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
		UINT32 timeLeft; _parser.parseUINT32(timeLeft);
		AtfValidator::validateInt(_descr, "timeLeft", timeLeft, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szErrors = Atf::LAtfVector< TournamentCreationError, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("errors"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "errors", szErrors, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "warning"); size_t szWarning = strlen(_dummy);
		AtfValidator::validateInt(_descr, "warning", szWarning, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "restartWarning"); size_t szRestartWarning = strlen(_dummy);
		AtfValidator::validateInt(_descr, "restartWarning", szRestartWarning, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_REGISTER_TOURN_USER
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER::Protocol_MSG_LOBBY_REGISTER_TOURN_USER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER::Protocol_MSG_LOBBY_REGISTER_TOURN_USER(Protocol_MSG_LOBBY_REGISTER_TOURN_USER&& _o)
	: tournId(std::move(_o.tournId))
	, notUsedStr(std::move(_o.notUsedStr))
	, buyInRM(std::move(_o.buyInRM))
	, buyInPlay(std::move(_o.buyInPlay))
	, buyInFpp(std::move(_o.buyInFpp))
	, tournPwd(std::move(_o.tournPwd))
	, useTicket(std::move(_o.useTicket))
	, buyInT(std::move(_o.buyInT))
	, buyInW(std::move(_o.buyInW))
	, currencyContext(std::move(_o.currencyContext))
	, isoCode(std::move(_o.isoCode))
	, game(std::move(_o.game))
	, highLo(std::move(_o.highLo))
	, structure(std::move(_o.structure))
	, startTime(std::move(_o.startTime))
	, allowLateRegistration(std::move(_o.allowLateRegistration))
	, preferRegistrationIntoLateTarget(std::move(_o.preferRegistrationIntoLateTarget))
{
}

Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER& Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER::operator=(Protocol_MSG_LOBBY_REGISTER_TOURN_USER&& _o)
{
	if(this != &_o)
	{
		tournId = std::move(_o.tournId);
		notUsedStr = std::move(_o.notUsedStr);
		buyInRM = std::move(_o.buyInRM);
		buyInPlay = std::move(_o.buyInPlay);
		buyInFpp = std::move(_o.buyInFpp);
		tournPwd = std::move(_o.tournPwd);
		useTicket = std::move(_o.useTicket);
		buyInT = std::move(_o.buyInT);
		buyInW = std::move(_o.buyInW);
		currencyContext = std::move(_o.currencyContext);
		isoCode = std::move(_o.isoCode);
		game = std::move(_o.game);
		highLo = std::move(_o.highLo);
		structure = std::move(_o.structure);
		startTime = std::move(_o.startTime);
		allowLateRegistration = std::move(_o.allowLateRegistration);
		preferRegistrationIntoLateTarget = std::move(_o.preferRegistrationIntoLateTarget);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER::clear()
{
	tournId = 0;
	notUsedStr.clear();
	buyInRM = 0;
	buyInPlay = 0;
	buyInFpp = 0;
	tournPwd.clear();
	useTicket = 0;
	buyInT = 0;
	buyInW = 0;
	currencyContext.clear();
	isoCode.clear();
	game = 0;
	highLo = 0;
	structure = 0;
	startTime.setNull();
	allowLateRegistration = false;
	preferRegistrationIntoLateTarget = false;
}

bool Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER::equals(const Protocol_MSG_LOBBY_REGISTER_TOURN_USER& _o) const
{
	return tournId == _o.tournId &&
		Atf::atfPStringEquals(notUsedStr, _o.notUsedStr) &&
		buyInRM == _o.buyInRM &&
		buyInPlay == _o.buyInPlay &&
		buyInFpp == _o.buyInFpp &&
		Atf::atfPStringEquals(tournPwd, _o.tournPwd) &&
		useTicket == _o.useTicket &&
		buyInT == _o.buyInT &&
		buyInW == _o.buyInW &&
		currencyContext.equals(_o.currencyContext) &&
		Atf::atfPStringEquals(isoCode, _o.isoCode) &&
		game == _o.game &&
		highLo == _o.highLo &&
		structure == _o.structure &&
		startTime.equals(_o.startTime) &&
		allowLateRegistration == _o.allowLateRegistration &&
		preferRegistrationIntoLateTarget == _o.preferRegistrationIntoLateTarget;
}

bool Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_REGISTER_TOURN_USER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_REGISTER_TOURN_USER*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_REGISTER_TOURN_USER).append(")");
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("buyInRM=");
	_buf.appendUint(buyInRM);
	_buf.append(',');
	_buf.append("buyInPlay=");
	_buf.appendUint(buyInPlay);
	_buf.append(',');
	_buf.append("buyInFpp=");
	_buf.appendUint(buyInFpp);
	_buf.append(',');
	_buf.append("tournPwd=");
	_buf.append(tournPwd);
	_buf.append(',');
	_buf.append("useTicket=");
	_buf.appendUint(useTicket);
	_buf.append(',');
	_buf.append("buyInT=");
	_buf.appendUint(buyInT);
	_buf.append(',');
	_buf.append("buyInW=");
	_buf.appendUint(buyInW);
	_buf.append(',');
	_buf.append("currencyContext=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(currencyContext, _buf); _buf.append('}');
	_buf.append(',');
	_buf.append("isoCode=");
	_buf.append(isoCode);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("highLo=");
	_buf.appendUint(highLo);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("startTime=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, startTime);
	_buf.append(',');
	_buf.append("allowLateRegistration=");
	_buf.appendUint(allowLateRegistration);
	_buf.append(',');
	_buf.append("preferRegistrationIntoLateTarget=");
	_buf.appendUint(preferRegistrationIntoLateTarget);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_REGISTER_TOURN_USER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
	Atf::XmlElement::encodeAsXmlElement("notUsedStr", notUsedStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyInRM", buyInRM, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyInPlay", buyInPlay, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyInFpp", buyInFpp, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournPwd", tournPwd, _buf);
	Atf::XmlElement::encodeAsXmlElement("useTicket", useTicket, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyInT", buyInT, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyInW", buyInW, _buf);
	Atf::XmlElement::encodeAsXmlElement("currencyContext", currencyContext, _buf);
	Atf::XmlElement::encodeAsXmlElement("isoCode", isoCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("highLo", highLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "startTime", startTime);
	Atf::XmlElement::encodeAsXmlElement("allowLateRegistration", allowLateRegistration, _buf);
	Atf::XmlElement::encodeAsXmlElement("preferRegistrationIntoLateTarget", preferRegistrationIntoLateTarget, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tournId"))
			{
				tournId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("notUsedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedStr)) return false;
			}
			else if (_element.equals("buyInRM"))
			{
				buyInRM = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("buyInPlay"))
			{
				buyInPlay = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("buyInFpp"))
			{
				buyInFpp = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournPwd"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tournPwd)) return false;
			}
			else if (_element.equals("useTicket"))
			{
				useTicket = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("buyInT"))
			{
				buyInT = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("buyInW"))
			{
				buyInW = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currencyContext"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, currencyContext)) return false;
			}
			else if (_element.equals("isoCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, isoCode)) return false;
			}
			else if (_element.equals("game"))
			{
				game = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("highLo"))
			{
				highLo = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("structure"))
			{
				structure = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("startTime"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, startTime);
			}
			else if (_element.equals("allowLateRegistration"))
			{
				allowLateRegistration = (*_value.ptr() == '1');
			}
			else if (_element.equals("preferRegistrationIntoLateTarget"))
			{
				preferRegistrationIntoLateTarget = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(tournId);
	_msg.composeString(notUsedStr);
	_msg.composeUINT32(buyInRM);
	_msg.composeUINT32(buyInPlay);
	_msg.composeUINT32(buyInFpp);
	_msg.composeString(tournPwd);
	_msg.composeBYTE(useTicket);
	_msg.composeUINT32(buyInT);
	_msg.composeUINT32(buyInW);
	_msg.composeMsgBody(currencyContext);
	_msg.composeString(isoCode);
	_msg.composeBYTE(game);
	_msg.composeBYTE(highLo);
	_msg.composeBYTE(structure);
	_msg.composeSrvTime(startTime);
	_msg.composeBOOL(allowLateRegistration);
	_msg.composeBOOL(preferRegistrationIntoLateTarget);
}

void Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tournId);
	_parser.parseStringP(notUsedStr);
	_parser.parseUINT32(buyInRM);
	_parser.parseUINT32(buyInPlay);
	_parser.parseUINT32(buyInFpp);
	_parser.parseStringP(tournPwd);
	_parser.parseBYTE(useTicket);
	_parser.parseUINT32(buyInT);
	_parser.parseUINT32(buyInW);
	if(_parser.parseEnded()) return;
	_parser.parseMsgBody(currencyContext);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(isoCode);
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(game);
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(highLo);
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(structure);
	if(_parser.parseEnded()) return;
	_parser.parseSrvTime(startTime);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(allowLateRegistration);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(preferRegistrationIntoLateTarget);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tournId", tournId);
	_jsonstr.compose("notUsedStr", notUsedStr);
	_jsonstr.compose("buyInRM", buyInRM);
	_jsonstr.compose("buyInPlay", buyInPlay);
	_jsonstr.compose("buyInFpp", buyInFpp);
	_jsonstr.compose("tournPwd", tournPwd);
	_jsonstr.compose("useTicket", useTicket);
	_jsonstr.compose("buyInT", buyInT);
	_jsonstr.compose("buyInW", buyInW);
	_jsonstr.compose("currencyContext", currencyContext);
	_jsonstr.compose("isoCode", isoCode);
	_jsonstr.compose("game", game);
	_jsonstr.compose("highLo", highLo);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("startTime", startTime);
	_jsonstr.compose("allowLateRegistration", allowLateRegistration);
	_jsonstr.compose("preferRegistrationIntoLateTarget", preferRegistrationIntoLateTarget);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tournId", tournId);
	_jparser.parseByNameThrow("notUsedStr", notUsedStr);
	_jparser.parseByNameThrow("buyInRM", buyInRM);
	_jparser.parseByNameThrow("buyInPlay", buyInPlay);
	_jparser.parseByNameThrow("buyInFpp", buyInFpp);
	_jparser.parseByNameThrow("tournPwd", tournPwd);
	_jparser.parseByNameThrow("useTicket", useTicket);
	_jparser.parseByNameThrow("buyInT", buyInT);
	_jparser.parseByNameThrow("buyInW", buyInW);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("currencyContext", currencyContext);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("isoCode", isoCode);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("game", game);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("highLo", highLo);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("structure", structure);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("startTime", startTime);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("allowLateRegistration", allowLateRegistration);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("preferRegistrationIntoLateTarget", preferRegistrationIntoLateTarget);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_REGISTER_TOURN_USER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	PString notUsedStr; _jparser.validateByNameThrow("notUsedStr", notUsedStr);
	AtfValidator::validateIntMax(_descr, "notUsedStr", notUsedStr.length(), 20, _checker, __FILE__, __LINE__);
	UINT32 buyInRM; _jparser.validateByNameThrow("buyInRM", buyInRM);
	AtfValidator::validateIntMax(_descr, "buyInRM", buyInRM, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 buyInPlay; _jparser.validateByNameThrow("buyInPlay", buyInPlay);
	AtfValidator::validateInt(_descr, "buyInPlay", buyInPlay, _checker, __FILE__, __LINE__);
	UINT32 buyInFpp; _jparser.validateByNameThrow("buyInFpp", buyInFpp);
	AtfValidator::validateIntMax(_descr, "buyInFpp", buyInFpp, 2000000000, _checker, __FILE__, __LINE__);
	PString tournPwd; _jparser.validateByNameThrow("tournPwd", tournPwd);
	AtfValidator::validateIntMax(_descr, "tournPwd", tournPwd.length(), 1000, _checker, __FILE__, __LINE__);
	BYTE useTicket; _jparser.validateByNameThrow("useTicket", useTicket);
	AtfValidator::validateIntMax(_descr, "useTicket", useTicket, 1, _checker, __FILE__, __LINE__);
	UINT32 buyInT; _jparser.validateByNameThrow("buyInT", buyInT);
	AtfValidator::validateIntMax(_descr, "buyInT", buyInT, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 buyInW; _jparser.validateByNameThrow("buyInW", buyInW);
	AtfValidator::validateIntMax(_descr, "buyInW", buyInW, 0, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	Atf::CopyableMsgBody currencyContext; _jparser.validateByNameThrow("currencyContext", currencyContext);
	AtfValidator::validateIntMax(_descr, "currencyContext", currencyContext._size(), 10000, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString isoCode; _jparser.validateByNameThrow("isoCode", isoCode);
	AtfValidator::validateIntMax(_descr, "isoCode", isoCode.length(), 10, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	BYTE highLo; _jparser.validateByNameThrow("highLo", highLo);
	AtfValidator::validateInt(_descr, "highLo", highLo, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	SrvTime startTime; _jparser.validateByNameThrow("startTime", startTime);
	AtfValidator::validateSrvDateTime(_descr, "startTime", startTime, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool allowLateRegistration; _jparser.validateByNameThrow("allowLateRegistration", allowLateRegistration);
	AtfValidator::validateInt(_descr, "allowLateRegistration", allowLateRegistration, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool preferRegistrationIntoLateTarget; _jparser.validateByNameThrow("preferRegistrationIntoLateTarget", preferRegistrationIntoLateTarget);
	AtfValidator::validateInt(_descr, "preferRegistrationIntoLateTarget", preferRegistrationIntoLateTarget, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_REGISTER_TOURN_USER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	UINT32 buyInRM; _parser.parseUINT32(buyInRM);
	AtfValidator::validateIntMax(_descr, "buyInRM", buyInRM, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 buyInPlay; _parser.parseUINT32(buyInPlay);
	AtfValidator::validateInt(_descr, "buyInPlay", buyInPlay, _checker, __FILE__, __LINE__);
	UINT32 buyInFpp; _parser.parseUINT32(buyInFpp);
	AtfValidator::validateIntMax(_descr, "buyInFpp", buyInFpp, 2000000000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "tournPwd"); size_t szTournPwd = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "tournPwd", szTournPwd, 1000, _checker, __FILE__, __LINE__);
	BYTE useTicket; _parser.parseBYTE(useTicket);
	AtfValidator::validateIntMax(_descr, "useTicket", useTicket, 1, _checker, __FILE__, __LINE__);
	UINT32 buyInT; _parser.parseUINT32(buyInT);
	AtfValidator::validateIntMax(_descr, "buyInT", buyInT, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 buyInW; _parser.parseUINT32(buyInW);
	AtfValidator::validateIntMax(_descr, "buyInW", buyInW, 0, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	size_t szCurrencyContext; _parser.skipMsgBody(szCurrencyContext);  /*currencyContext*/
	AtfValidator::validateIntMax(_descr, "currencyContext", szCurrencyContext, 10000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "isoCode"); size_t szIsoCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "isoCode", szIsoCode, 10, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	BYTE highLo; _parser.parseBYTE(highLo);
	AtfValidator::validateInt(_descr, "highLo", highLo, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	SrvTime startTime; _parser.parseSrvTime(startTime);
	AtfValidator::validateSrvDateTime(_descr, "startTime", startTime, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool allowLateRegistration; _parser.parseBOOL(allowLateRegistration);
	AtfValidator::validateInt(_descr, "allowLateRegistration", allowLateRegistration, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool preferRegistrationIntoLateTarget; _parser.parseBOOL(preferRegistrationIntoLateTarget);
	AtfValidator::validateInt(_descr, "preferRegistrationIntoLateTarget", preferRegistrationIntoLateTarget, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY::Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY::Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY(Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, allIn(std::move(_o.allIn))
	, text(std::move(_o.text))
	, tournId(std::move(_o.tournId))
	, seatAvail(std::move(_o.seatAvail))
	, srv(std::move(_o.srv))
	, socialToken(std::move(_o.socialToken))
	, clientNotification(std::move(_o.clientNotification))
{
}

Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY& Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY::operator=(Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		allIn = std::move(_o.allIn);
		text = std::move(_o.text);
		tournId = std::move(_o.tournId);
		seatAvail = std::move(_o.seatAvail);
		srv = std::move(_o.srv);
		socialToken = std::move(_o.socialToken);
		clientNotification = std::move(_o.clientNotification);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	allIn = 0;
	text.clear();
	tournId = 0;
	seatAvail = false;
	srv.clear();
	socialToken.clear();
	clientNotification.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY::equals(const Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		allIn == _o.allIn &&
		Atf::atfPStringEquals(text, _o.text) &&
		tournId == _o.tournId &&
		seatAvail == _o.seatAvail &&
		Atf::atfPStringEquals(srv, _o.srv) &&
		Atf::atfPStringEquals(socialToken, _o.socialToken) &&
		Atf::atfPStringEquals(clientNotification, _o.clientNotification);
}

bool Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_REGISTER_TOURN_USER_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_REGISTER_TOURN_USER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errDesc=");
	_buf.append(errDesc);
	if( !errCode || errCode == ALREADY_REGISTERED )
	{
		_buf.append(',');
		_buf.append("allIn=");
		_buf.appendInt(allIn);
		_buf.append(',');
		_buf.append("text=");
		_buf.append(text);
		_buf.append(',');
		_buf.append("tournId=");
		_buf.appendUint(tournId);
	}
	if( !errCode )
	{
		_buf.append(',');
		_buf.append("seatAvail=");
		_buf.appendUint(seatAvail);
		_buf.append(',');
		_buf.append("srv=");
		_buf.append(srv);
		_buf.append(',');
		_buf.append("socialToken=");
		_buf.append(socialToken);
		_buf.append(',');
		_buf.append("clientNotification=");
		_buf.append(clientNotification);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_REGISTER_TOURN_USER_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	if( !errCode || errCode == ALREADY_REGISTERED )
	{
		Atf::XmlElement::encodeAsXmlElement("allIn", allIn, _buf);
		Atf::XmlElement::encodeAsXmlElement("text", text, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
	}
	if( !errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("seatAvail", seatAvail, _buf);
		Atf::XmlElement::encodeAsXmlElement("srv", srv, _buf);
		Atf::XmlElement::encodeAsXmlElement("socialToken", socialToken, _buf);
		Atf::XmlElement::encodeAsXmlElement("clientNotification", clientNotification, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("allIn"))
			{
				allIn = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("text"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, text)) return false;
			}
			else if (_element.equals("tournId"))
			{
				tournId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("seatAvail"))
			{
				seatAvail = (*_value.ptr() == '1');
			}
			else if (_element.equals("srv"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, srv)) return false;
			}
			else if (_element.equals("socialToken"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, socialToken)) return false;
			}
			else if (_element.equals("clientNotification"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, clientNotification)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errDesc);
	if( !errCode || errCode == ALREADY_REGISTERED )
	{
		_msg.composeINT16(allIn);
		_msg.composeString(text);
		_msg.composeUINT32(tournId);
	}
	if( !errCode )
	{
		_msg.composeBOOL(seatAvail);
		_msg.composeString(srv);
		_msg.composeString(socialToken);
		_msg.composeString(clientNotification);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(errDesc);
	if( !errCode || errCode == ALREADY_REGISTERED )
	{
		_parser.parseINT16(allIn);
		_parser.parseStringP(text);
		_parser.parseUINT32(tournId);
	}
	if( !errCode )
	{
		_parser.parseBOOL(seatAvail);
		_parser.parseStringP(srv);
		_parser.parseStringP(socialToken);
		_parser.parseStringP(clientNotification);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errDesc", errDesc);
	if( !errCode || errCode == ALREADY_REGISTERED )
	{
		_jsonstr.compose("allIn", allIn);
		_jsonstr.compose("text", text);
		_jsonstr.compose("tournId", tournId);
	}
	if( !errCode )
	{
		_jsonstr.compose("seatAvail", seatAvail);
		_jsonstr.compose("srv", srv);
		_jsonstr.compose("socialToken", socialToken);
		_jsonstr.compose("clientNotification", clientNotification);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errDesc", errDesc);
	if( !errCode || errCode == ALREADY_REGISTERED )
	{
		_jparser.parseByNameThrow("allIn", allIn);
		_jparser.parseByNameThrow("text", text);
		_jparser.parseByNameThrow("tournId", tournId);
	}
	if( !errCode )
	{
		_jparser.parseByNameThrow("seatAvail", seatAvail);
		_jparser.parseByNameThrow("srv", srv);
		_jparser.parseByNameThrow("socialToken", socialToken);
		_jparser.parseByNameThrow("clientNotification", clientNotification);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_REGISTER_TOURN_USER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
	AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	if( !errCode || errCode == ALREADY_REGISTERED )
	{
		INT16 allIn; _jparser.validateByNameThrow("allIn", allIn);
		AtfValidator::validateInt(_descr, "allIn", allIn, _checker, __FILE__, __LINE__);
		PString text; _jparser.validateByNameThrow("text", text);
		AtfValidator::validateInt(_descr, "text", text.length(), _checker, __FILE__, __LINE__);
		UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
		AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	}
	if( !errCode )
	{
		bool seatAvail; _jparser.validateByNameThrow("seatAvail", seatAvail);
		AtfValidator::validateInt(_descr, "seatAvail", seatAvail, _checker, __FILE__, __LINE__);
		PString srv; _jparser.validateByNameThrow("srv", srv);
		AtfValidator::validateInt(_descr, "srv", srv.length(), _checker, __FILE__, __LINE__);
		PString socialToken; _jparser.validateByNameThrow("socialToken", socialToken);
		AtfValidator::validateInt(_descr, "socialToken", socialToken.length(), _checker, __FILE__, __LINE__);
		PString clientNotification; _jparser.validateByNameThrow("clientNotification", clientNotification);
		AtfValidator::validateInt(_descr, "clientNotification", clientNotification.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_REGISTER_TOURN_USER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	if( !errCode || errCode == ALREADY_REGISTERED )
	{
		INT16 allIn; _parser.parseINT16(allIn);
		AtfValidator::validateInt(_descr, "allIn", allIn, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "text"); size_t szText = strlen(_dummy);
		AtfValidator::validateInt(_descr, "text", szText, _checker, __FILE__, __LINE__);
		UINT32 tournId; _parser.parseUINT32(tournId);
		AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	}
	if( !errCode )
	{
		bool seatAvail; _parser.parseBOOL(seatAvail);
		AtfValidator::validateInt(_descr, "seatAvail", seatAvail, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "srv"); size_t szSrv = strlen(_dummy);
		AtfValidator::validateInt(_descr, "srv", szSrv, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "socialToken"); size_t szSocialToken = strlen(_dummy);
		AtfValidator::validateInt(_descr, "socialToken", szSocialToken, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "clientNotification"); size_t szClientNotification = strlen(_dummy);
		AtfValidator::validateInt(_descr, "clientNotification", szClientNotification, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS::Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS::Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS(Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, setPriv(std::move(_o.setPriv))
{
}

Lobby::cli::Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS& Lobby::cli::Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS::operator=(Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		setPriv = std::move(_o.setPriv);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS::clear()
{
	notUsedStr.clear();
	setPriv = false;
}

bool Lobby::cli::Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS::equals(const Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS& _o) const
{
	return Atf::atfPStringEquals(notUsedStr, _o.notUsedStr) &&
		setPriv == _o.setPriv;
}

bool Lobby::cli::Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_PUBLISH_VIP_STATUS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_PUBLISH_VIP_STATUS).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("setPriv=");
	_buf.appendUint(setPriv);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_PUBLISH_VIP_STATUS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsedStr", notUsedStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("setPriv", setPriv, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedStr)) return false;
			}
			else if (_element.equals("setPriv"))
			{
				setPriv = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsedStr);
	_msg.composeBOOL(setPriv);
}

void Lobby::cli::Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseBOOL(setPriv);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsedStr", notUsedStr);
	_jsonstr.compose("setPriv", setPriv);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsedStr", notUsedStr);
	_jparser.parseByNameThrow("setPriv", setPriv);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_PUBLISH_VIP_STATUS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsedStr; _jparser.validateByNameThrow("notUsedStr", notUsedStr);
	AtfValidator::validateIntMax(_descr, "notUsedStr", notUsedStr.length(), 20, _checker, __FILE__, __LINE__);
	bool setPriv; _jparser.validateByNameThrow("setPriv", setPriv);
	AtfValidator::validateInt(_descr, "setPriv", setPriv, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_PUBLISH_VIP_STATUS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	bool setPriv; _parser.parseBOOL(setPriv);
	AtfValidator::validateInt(_descr, "setPriv", setPriv, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_HIDE_MOBILE_ICON
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_HIDE_MOBILE_ICON::Protocol_MSG_LOBBY_HIDE_MOBILE_ICON()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_HIDE_MOBILE_ICON::clear()
{
	setPriv = false;
}

bool Lobby::cli::Protocol_MSG_LOBBY_HIDE_MOBILE_ICON::equals(const Protocol_MSG_LOBBY_HIDE_MOBILE_ICON& _o) const
{
	return setPriv == _o.setPriv;
}

bool Lobby::cli::Protocol_MSG_LOBBY_HIDE_MOBILE_ICON::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_HIDE_MOBILE_ICON != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_HIDE_MOBILE_ICON*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_HIDE_MOBILE_ICON::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_HIDE_MOBILE_ICON).append(")");
	_buf.append(',');
	_buf.append("setPriv=");
	_buf.appendUint(setPriv);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_HIDE_MOBILE_ICON::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_HIDE_MOBILE_ICON::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_HIDE_MOBILE_ICON).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("setPriv", setPriv, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_HIDE_MOBILE_ICON::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("setPriv"))
			{
				setPriv = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_HIDE_MOBILE_ICON::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(setPriv);
}

void Lobby::cli::Protocol_MSG_LOBBY_HIDE_MOBILE_ICON::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(setPriv);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_HIDE_MOBILE_ICON::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("setPriv", setPriv);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_HIDE_MOBILE_ICON::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("setPriv", setPriv);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_HIDE_MOBILE_ICON::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_HIDE_MOBILE_ICON";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool setPriv; _jparser.validateByNameThrow("setPriv", setPriv);
	AtfValidator::validateInt(_descr, "setPriv", setPriv, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_HIDE_MOBILE_ICON::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_HIDE_MOBILE_ICON";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	bool setPriv; _parser.parseBOOL(setPriv);
	AtfValidator::validateInt(_descr, "setPriv", setPriv, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SET_TABLE_LIMITS2
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2(Protocol_MSG_LOBBY_SET_TABLE_LIMITS2&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, currency(std::move(_o.currency))
	, limit1(std::move(_o.limit1))
	, limitType1(std::move(_o.limitType1))
	, limit2(std::move(_o.limit2))
	, limitType2(std::move(_o.limitType2))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2& Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2::operator=(Protocol_MSG_LOBBY_SET_TABLE_LIMITS2&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		currency = std::move(_o.currency);
		limit1 = std::move(_o.limit1);
		limitType1 = std::move(_o.limitType1);
		limit2 = std::move(_o.limit2);
		limitType2 = std::move(_o.limitType2);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2::clear()
{
	notUsedStr.clear();
	currency.clear();
	limit1 = 0;
	limitType1 = 0;
	limit2 = 0;
	limitType2 = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2::equals(const Protocol_MSG_LOBBY_SET_TABLE_LIMITS2& _o) const
{
	return Atf::atfPStringEquals(notUsedStr, _o.notUsedStr) &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		limit1 == _o.limit1 &&
		limitType1 == _o.limitType1 &&
		limit2 == _o.limit2 &&
		limitType2 == _o.limitType2;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_SET_TABLE_LIMITS2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_SET_TABLE_LIMITS2*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SET_TABLE_LIMITS2).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("limit1=");
	_buf.appendInt(limit1);
	_buf.append(',');
	_buf.append("limitType1=");
	_buf.appendUint(limitType1);
	_buf.append(',');
	_buf.append("limit2=");
	_buf.appendInt(limit2);
	_buf.append(',');
	_buf.append("limitType2=");
	_buf.appendUint(limitType2);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_SET_TABLE_LIMITS2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsedStr", notUsedStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("limit1", limit1, _buf);
	Atf::XmlElement::encodeAsXmlElement("limitType1", limitType1, _buf);
	Atf::XmlElement::encodeAsXmlElement("limit2", limit2, _buf);
	Atf::XmlElement::encodeAsXmlElement("limitType2", limitType2, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedStr)) return false;
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else if (_element.equals("limit1"))
			{
				limit1 = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("limitType1"))
			{
				limitType1 = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("limit2"))
			{
				limit2 = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("limitType2"))
			{
				limitType2 = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsedStr);
	_msg.composeString(currency);
	_msg.composeINT32(limit1);
	_msg.composeBYTE(limitType1);
	_msg.composeINT32(limit2);
	_msg.composeBYTE(limitType2);
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseStringP(currency);
	_parser.parseINT32(limit1);
	_parser.parseBYTE(limitType1);
	_parser.parseINT32(limit2);
	_parser.parseBYTE(limitType2);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsedStr", notUsedStr);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("limit1", limit1);
	_jsonstr.compose("limitType1", limitType1);
	_jsonstr.compose("limit2", limit2);
	_jsonstr.compose("limitType2", limitType2);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsedStr", notUsedStr);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("limit1", limit1);
	_jparser.parseByNameThrow("limitType1", limitType1);
	_jparser.parseByNameThrow("limit2", limit2);
	_jparser.parseByNameThrow("limitType2", limitType2);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_TABLE_LIMITS2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsedStr; _jparser.validateByNameThrow("notUsedStr", notUsedStr);
	AtfValidator::validateIntMax(_descr, "notUsedStr", notUsedStr.length(), 20, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateIntMax(_descr, "currency", currency.length(), 5, _checker, __FILE__, __LINE__);
	INT32 limit1; _jparser.validateByNameThrow("limit1", limit1);
	AtfValidator::validateIntMin(_descr, "limit1", limit1, -1, _checker, __FILE__, __LINE__);
	BYTE limitType1; _jparser.validateByNameThrow("limitType1", limitType1);
	AtfValidator::validateIntRange(_descr, "limitType1", limitType1, eTableLimitTypeAny, (numLimitTypes-1), _checker, __FILE__, __LINE__);
	INT32 limit2; _jparser.validateByNameThrow("limit2", limit2);
	AtfValidator::validateIntMin(_descr, "limit2", limit2, -1, _checker, __FILE__, __LINE__);
	BYTE limitType2; _jparser.validateByNameThrow("limitType2", limitType2);
	AtfValidator::validateIntRange(_descr, "limitType2", limitType2, eTableLimitTypeAny, (numLimitTypes-1), _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_TABLE_LIMITS2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, 5, _checker, __FILE__, __LINE__);
	INT32 limit1; _parser.parseINT32(limit1);
	AtfValidator::validateIntMin(_descr, "limit1", limit1, -1, _checker, __FILE__, __LINE__);
	BYTE limitType1; _parser.parseBYTE(limitType1);
	AtfValidator::validateIntRange(_descr, "limitType1", limitType1, eTableLimitTypeAny, (numLimitTypes-1), _checker, __FILE__, __LINE__);
	INT32 limit2; _parser.parseINT32(limit2);
	AtfValidator::validateIntMin(_descr, "limit2", limit2, -1, _checker, __FILE__, __LINE__);
	BYTE limitType2; _parser.parseBYTE(limitType2);
	AtfValidator::validateIntRange(_descr, "limitType2", limitType2, eTableLimitTypeAny, (numLimitTypes-1), _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY(Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, limitType1(std::move(_o.limitType1))
	, errorCode1(std::move(_o.errorCode1))
	, errDescr1(std::move(_o.errDescr1))
	, effectiveNow1(std::move(_o.effectiveNow1))
	, limitType2(std::move(_o.limitType2))
	, errorCode2(std::move(_o.errorCode2))
	, errDescr2(std::move(_o.errDescr2))
	, effectiveNow2(std::move(_o.effectiveNow2))
	, limit(std::move(_o.limit))
	, waitingIncreaseLimitDays1(std::move(_o.waitingIncreaseLimitDays1))
	, waitingIncreaseLimitDays2(std::move(_o.waitingIncreaseLimitDays2))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY& Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY::operator=(Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		limitType1 = std::move(_o.limitType1);
		errorCode1 = std::move(_o.errorCode1);
		errDescr1 = std::move(_o.errDescr1);
		effectiveNow1 = std::move(_o.effectiveNow1);
		limitType2 = std::move(_o.limitType2);
		errorCode2 = std::move(_o.errorCode2);
		errDescr2 = std::move(_o.errDescr2);
		effectiveNow2 = std::move(_o.effectiveNow2);
		limit = std::move(_o.limit);
		waitingIncreaseLimitDays1 = std::move(_o.waitingIncreaseLimitDays1);
		waitingIncreaseLimitDays2 = std::move(_o.waitingIncreaseLimitDays2);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY::clear()
{
	errCode = 0;
	limitType1 = 0;
	errorCode1 = 0;
	errDescr1.clear();
	effectiveNow1 = false;
	limitType2 = 0;
	errorCode2 = 0;
	errDescr2.clear();
	effectiveNow2 = false;
	limit = 0;
	waitingIncreaseLimitDays1 = 0;
	waitingIncreaseLimitDays2 = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY::equals(const Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		limitType1 == _o.limitType1 &&
		errorCode1 == _o.errorCode1 &&
		Atf::atfPStringEquals(errDescr1, _o.errDescr1) &&
		effectiveNow1 == _o.effectiveNow1 &&
		limitType2 == _o.limitType2 &&
		errorCode2 == _o.errorCode2 &&
		Atf::atfPStringEquals(errDescr2, _o.errDescr2) &&
		effectiveNow2 == _o.effectiveNow2 &&
		limit == _o.limit &&
		waitingIncreaseLimitDays1 == _o.waitingIncreaseLimitDays1 &&
		waitingIncreaseLimitDays2 == _o.waitingIncreaseLimitDays2;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_SET_TABLE_LIMITS2_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SET_TABLE_LIMITS2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("limitType1=");
	_buf.appendUint(limitType1);
	_buf.append(',');
	_buf.append("errorCode1=");
	_buf.appendInt(errorCode1);
	if(errorCode1)
	{
		_buf.append(',');
		_buf.append("errDescr1=");
		_buf.append(errDescr1);
	}
	else
	{
		_buf.append(',');
		_buf.append("effectiveNow1=");
		_buf.appendUint(effectiveNow1);
	}
	_buf.append(',');
	_buf.append("limitType2=");
	_buf.appendUint(limitType2);
	_buf.append(',');
	_buf.append("errorCode2=");
	_buf.appendInt(errorCode2);
	if(errorCode2)
	{
		_buf.append(',');
		_buf.append("errDescr2=");
		_buf.append(errDescr2);
	}
	else
	{
		_buf.append(',');
		_buf.append("effectiveNow2=");
		_buf.appendUint(effectiveNow2);
	}
	_buf.append(',');
	_buf.append("limit=");
	_buf.appendUint(limit);
	_buf.append(',');
	_buf.append("waitingIncreaseLimitDays1=");
	_buf.appendUint(waitingIncreaseLimitDays1);
	_buf.append(',');
	_buf.append("waitingIncreaseLimitDays2=");
	_buf.appendUint(waitingIncreaseLimitDays2);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_SET_TABLE_LIMITS2_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("limitType1", limitType1, _buf);
	Atf::XmlElement::encodeAsXmlElement("errorCode1", errorCode1, _buf);
	if(errorCode1)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr1", errDescr1, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("effectiveNow1", effectiveNow1, _buf);
	}
	Atf::XmlElement::encodeAsXmlElement("limitType2", limitType2, _buf);
	Atf::XmlElement::encodeAsXmlElement("errorCode2", errorCode2, _buf);
	if(errorCode2)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr2", errDescr2, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("effectiveNow2", effectiveNow2, _buf);
	}
	Atf::XmlElement::encodeAsXmlElement("limit", limit, _buf);
	Atf::XmlElement::encodeAsXmlElement("waitingIncreaseLimitDays1", waitingIncreaseLimitDays1, _buf);
	Atf::XmlElement::encodeAsXmlElement("waitingIncreaseLimitDays2", waitingIncreaseLimitDays2, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("limitType1"))
			{
				limitType1 = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errorCode1"))
			{
				errorCode1 = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr1"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr1)) return false;
			}
			else if (_element.equals("effectiveNow1"))
			{
				effectiveNow1 = (*_value.ptr() == '1');
			}
			else if (_element.equals("limitType2"))
			{
				limitType2 = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errorCode2"))
			{
				errorCode2 = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr2"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr2)) return false;
			}
			else if (_element.equals("effectiveNow2"))
			{
				effectiveNow2 = (*_value.ptr() == '1');
			}
			else if (_element.equals("limit"))
			{
				limit = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("waitingIncreaseLimitDays1"))
			{
				waitingIncreaseLimitDays1 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("waitingIncreaseLimitDays2"))
			{
				waitingIncreaseLimitDays2 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	_msg.composeBYTE(limitType1);
	_msg.composeINT16(errorCode1);
	if(errorCode1)
	{
		_msg.composeString(errDescr1);
	}
	else
	{
		_msg.composeBOOL(effectiveNow1);
	}
	_msg.composeBYTE(limitType2);
	_msg.composeINT16(errorCode2);
	if(errorCode2)
	{
		_msg.composeString(errDescr2);
	}
	else
	{
		_msg.composeBOOL(effectiveNow2);
	}
	_msg.composeUINT32(limit);
	_msg.composeUINT32(waitingIncreaseLimitDays1);
	_msg.composeUINT32(waitingIncreaseLimitDays2);
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseBYTE(limitType1);
	_parser.parseINT16(errorCode1);
	if(errorCode1)
	{
		_parser.parseStringP(errDescr1);
	}
	else
	{
		_parser.parseBOOL(effectiveNow1);
	}
	_parser.parseBYTE(limitType2);
	_parser.parseINT16(errorCode2);
	if(errorCode2)
	{
		_parser.parseStringP(errDescr2);
	}
	else
	{
		_parser.parseBOOL(effectiveNow2);
	}
	_parser.parseUINT32(limit);
	_parser.parseUINT32(waitingIncreaseLimitDays1);
	_parser.parseUINT32(waitingIncreaseLimitDays2);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("limitType1", limitType1);
	_jsonstr.compose("errorCode1", errorCode1);
	if(errorCode1)
	{
		_jsonstr.compose("errDescr1", errDescr1);
	}
	else
	{
		_jsonstr.compose("effectiveNow1", effectiveNow1);
	}
	_jsonstr.compose("limitType2", limitType2);
	_jsonstr.compose("errorCode2", errorCode2);
	if(errorCode2)
	{
		_jsonstr.compose("errDescr2", errDescr2);
	}
	else
	{
		_jsonstr.compose("effectiveNow2", effectiveNow2);
	}
	_jsonstr.compose("limit", limit);
	_jsonstr.compose("waitingIncreaseLimitDays1", waitingIncreaseLimitDays1);
	_jsonstr.compose("waitingIncreaseLimitDays2", waitingIncreaseLimitDays2);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("limitType1", limitType1);
	_jparser.parseByNameThrow("errorCode1", errorCode1);
	if(errorCode1)
	{
		_jparser.parseByNameThrow("errDescr1", errDescr1);
	}
	else
	{
		_jparser.parseByNameThrow("effectiveNow1", effectiveNow1);
	}
	_jparser.parseByNameThrow("limitType2", limitType2);
	_jparser.parseByNameThrow("errorCode2", errorCode2);
	if(errorCode2)
	{
		_jparser.parseByNameThrow("errDescr2", errDescr2);
	}
	else
	{
		_jparser.parseByNameThrow("effectiveNow2", effectiveNow2);
	}
	_jparser.parseByNameThrow("limit", limit);
	_jparser.parseByNameThrow("waitingIncreaseLimitDays1", waitingIncreaseLimitDays1);
	_jparser.parseByNameThrow("waitingIncreaseLimitDays2", waitingIncreaseLimitDays2);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_TABLE_LIMITS2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errorCode1 = 0;
	INT16 errorCode2 = 0;
	INT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	BYTE limitType1; _jparser.validateByNameThrow("limitType1", limitType1);
	AtfValidator::validateInt(_descr, "limitType1", limitType1, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("errorCode1", errorCode1);
	AtfValidator::validateInt(_descr, "errorCode1", errorCode1, _checker, __FILE__, __LINE__);
	if(errorCode1)
	{
		PString errDescr1; _jparser.validateByNameThrow("errDescr1", errDescr1);
		AtfValidator::validateInt(_descr, "errDescr1", errDescr1.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		bool effectiveNow1; _jparser.validateByNameThrow("effectiveNow1", effectiveNow1);
		AtfValidator::validateInt(_descr, "effectiveNow1", effectiveNow1, _checker, __FILE__, __LINE__);
	}
	BYTE limitType2; _jparser.validateByNameThrow("limitType2", limitType2);
	AtfValidator::validateInt(_descr, "limitType2", limitType2, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("errorCode2", errorCode2);
	AtfValidator::validateInt(_descr, "errorCode2", errorCode2, _checker, __FILE__, __LINE__);
	if(errorCode2)
	{
		PString errDescr2; _jparser.validateByNameThrow("errDescr2", errDescr2);
		AtfValidator::validateInt(_descr, "errDescr2", errDescr2.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		bool effectiveNow2; _jparser.validateByNameThrow("effectiveNow2", effectiveNow2);
		AtfValidator::validateInt(_descr, "effectiveNow2", effectiveNow2, _checker, __FILE__, __LINE__);
	}
	UINT32 limit; _jparser.validateByNameThrow("limit", limit);
	AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
	UINT32 waitingIncreaseLimitDays1; _jparser.validateByNameThrow("waitingIncreaseLimitDays1", waitingIncreaseLimitDays1);
	AtfValidator::validateInt(_descr, "waitingIncreaseLimitDays1", waitingIncreaseLimitDays1, _checker, __FILE__, __LINE__);
	UINT32 waitingIncreaseLimitDays2; _jparser.validateByNameThrow("waitingIncreaseLimitDays2", waitingIncreaseLimitDays2);
	AtfValidator::validateInt(_descr, "waitingIncreaseLimitDays2", waitingIncreaseLimitDays2, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_TABLE_LIMITS2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errorCode1 = 0;
	INT16 errorCode2 = 0;
	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	BYTE limitType1; _parser.parseBYTE(limitType1);
	AtfValidator::validateInt(_descr, "limitType1", limitType1, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errorCode1);
	AtfValidator::validateInt(_descr, "errorCode1", errorCode1, _checker, __FILE__, __LINE__);
	if(errorCode1)
	{
		_parser.parseStringN(_dummy, 0, "errDescr1"); size_t szErrDescr1 = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr1", szErrDescr1, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool effectiveNow1; _parser.parseBOOL(effectiveNow1);
		AtfValidator::validateInt(_descr, "effectiveNow1", effectiveNow1, _checker, __FILE__, __LINE__);
	}
	BYTE limitType2; _parser.parseBYTE(limitType2);
	AtfValidator::validateInt(_descr, "limitType2", limitType2, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errorCode2);
	AtfValidator::validateInt(_descr, "errorCode2", errorCode2, _checker, __FILE__, __LINE__);
	if(errorCode2)
	{
		_parser.parseStringN(_dummy, 0, "errDescr2"); size_t szErrDescr2 = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr2", szErrDescr2, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool effectiveNow2; _parser.parseBOOL(effectiveNow2);
		AtfValidator::validateInt(_descr, "effectiveNow2", effectiveNow2, _checker, __FILE__, __LINE__);
	}
	UINT32 limit; _parser.parseUINT32(limit);
	AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
	UINT32 waitingIncreaseLimitDays1; _parser.parseUINT32(waitingIncreaseLimitDays1);
	AtfValidator::validateInt(_descr, "waitingIncreaseLimitDays1", waitingIncreaseLimitDays1, _checker, __FILE__, __LINE__);
	UINT32 waitingIncreaseLimitDays2; _parser.parseUINT32(waitingIncreaseLimitDays2);
	AtfValidator::validateInt(_descr, "waitingIncreaseLimitDays2", waitingIncreaseLimitDays2, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SET_TOURN_LIMITS
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS::Protocol_MSG_LOBBY_SET_TOURN_LIMITS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS::Protocol_MSG_LOBBY_SET_TOURN_LIMITS(Protocol_MSG_LOBBY_SET_TOURN_LIMITS&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, currency(std::move(_o.currency))
	, limit1(std::move(_o.limit1))
	, limitType1(std::move(_o.limitType1))
	, limit2(std::move(_o.limit2))
	, limitType2(std::move(_o.limitType2))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS& Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS::operator=(Protocol_MSG_LOBBY_SET_TOURN_LIMITS&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		currency = std::move(_o.currency);
		limit1 = std::move(_o.limit1);
		limitType1 = std::move(_o.limitType1);
		limit2 = std::move(_o.limit2);
		limitType2 = std::move(_o.limitType2);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS::clear()
{
	notUsedStr.clear();
	currency.clear();
	limit1 = 0;
	limitType1 = 0;
	limit2 = 0;
	limitType2 = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS::equals(const Protocol_MSG_LOBBY_SET_TOURN_LIMITS& _o) const
{
	return Atf::atfPStringEquals(notUsedStr, _o.notUsedStr) &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		limit1 == _o.limit1 &&
		limitType1 == _o.limitType1 &&
		limit2 == _o.limit2 &&
		limitType2 == _o.limitType2;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_SET_TOURN_LIMITS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_SET_TOURN_LIMITS*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SET_TOURN_LIMITS).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("limit1=");
	_buf.appendInt(limit1);
	_buf.append(',');
	_buf.append("limitType1=");
	_buf.appendUint(limitType1);
	_buf.append(',');
	_buf.append("limit2=");
	_buf.appendInt(limit2);
	_buf.append(',');
	_buf.append("limitType2=");
	_buf.appendUint(limitType2);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_SET_TOURN_LIMITS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsedStr", notUsedStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("limit1", limit1, _buf);
	Atf::XmlElement::encodeAsXmlElement("limitType1", limitType1, _buf);
	Atf::XmlElement::encodeAsXmlElement("limit2", limit2, _buf);
	Atf::XmlElement::encodeAsXmlElement("limitType2", limitType2, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedStr)) return false;
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else if (_element.equals("limit1"))
			{
				limit1 = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("limitType1"))
			{
				limitType1 = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("limit2"))
			{
				limit2 = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("limitType2"))
			{
				limitType2 = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsedStr);
	_msg.composeString(currency);
	_msg.composeINT32(limit1);
	_msg.composeBYTE(limitType1);
	_msg.composeINT32(limit2);
	_msg.composeBYTE(limitType2);
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseStringP(currency);
	_parser.parseINT32(limit1);
	_parser.parseBYTE(limitType1);
	_parser.parseINT32(limit2);
	_parser.parseBYTE(limitType2);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsedStr", notUsedStr);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("limit1", limit1);
	_jsonstr.compose("limitType1", limitType1);
	_jsonstr.compose("limit2", limit2);
	_jsonstr.compose("limitType2", limitType2);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsedStr", notUsedStr);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("limit1", limit1);
	_jparser.parseByNameThrow("limitType1", limitType1);
	_jparser.parseByNameThrow("limit2", limit2);
	_jparser.parseByNameThrow("limitType2", limitType2);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_TOURN_LIMITS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsedStr; _jparser.validateByNameThrow("notUsedStr", notUsedStr);
	AtfValidator::validateIntMax(_descr, "notUsedStr", notUsedStr.length(), 20, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateIntMax(_descr, "currency", currency.length(), 5, _checker, __FILE__, __LINE__);
	INT32 limit1; _jparser.validateByNameThrow("limit1", limit1);
	AtfValidator::validateIntMin(_descr, "limit1", limit1, -1, _checker, __FILE__, __LINE__);
	BYTE limitType1; _jparser.validateByNameThrow("limitType1", limitType1);
	AtfValidator::validateIntRange(_descr, "limitType1", limitType1, eTableLimitTypeAny, (numLimitTypes-1), _checker, __FILE__, __LINE__);
	INT32 limit2; _jparser.validateByNameThrow("limit2", limit2);
	AtfValidator::validateIntMin(_descr, "limit2", limit2, -1, _checker, __FILE__, __LINE__);
	BYTE limitType2; _jparser.validateByNameThrow("limitType2", limitType2);
	AtfValidator::validateIntRange(_descr, "limitType2", limitType2, eTableLimitTypeAny, (numLimitTypes-1), _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_TOURN_LIMITS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, 5, _checker, __FILE__, __LINE__);
	INT32 limit1; _parser.parseINT32(limit1);
	AtfValidator::validateIntMin(_descr, "limit1", limit1, -1, _checker, __FILE__, __LINE__);
	BYTE limitType1; _parser.parseBYTE(limitType1);
	AtfValidator::validateIntRange(_descr, "limitType1", limitType1, eTableLimitTypeAny, (numLimitTypes-1), _checker, __FILE__, __LINE__);
	INT32 limit2; _parser.parseINT32(limit2);
	AtfValidator::validateIntMin(_descr, "limit2", limit2, -1, _checker, __FILE__, __LINE__);
	BYTE limitType2; _parser.parseBYTE(limitType2);
	AtfValidator::validateIntRange(_descr, "limitType2", limitType2, eTableLimitTypeAny, (numLimitTypes-1), _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY::Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY::Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY(Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, limitType1(std::move(_o.limitType1))
	, errorCode1(std::move(_o.errorCode1))
	, errDescr1(std::move(_o.errDescr1))
	, effectiveNow1(std::move(_o.effectiveNow1))
	, limitType2(std::move(_o.limitType2))
	, errorCode2(std::move(_o.errorCode2))
	, errDescr2(std::move(_o.errDescr2))
	, effectiveNow2(std::move(_o.effectiveNow2))
	, limit(std::move(_o.limit))
	, waitingIncreaseLimitDays1(std::move(_o.waitingIncreaseLimitDays1))
	, waitingIncreaseLimitDays2(std::move(_o.waitingIncreaseLimitDays2))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY& Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY::operator=(Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		limitType1 = std::move(_o.limitType1);
		errorCode1 = std::move(_o.errorCode1);
		errDescr1 = std::move(_o.errDescr1);
		effectiveNow1 = std::move(_o.effectiveNow1);
		limitType2 = std::move(_o.limitType2);
		errorCode2 = std::move(_o.errorCode2);
		errDescr2 = std::move(_o.errDescr2);
		effectiveNow2 = std::move(_o.effectiveNow2);
		limit = std::move(_o.limit);
		waitingIncreaseLimitDays1 = std::move(_o.waitingIncreaseLimitDays1);
		waitingIncreaseLimitDays2 = std::move(_o.waitingIncreaseLimitDays2);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY::clear()
{
	errCode = 0;
	limitType1 = 0;
	errorCode1 = 0;
	errDescr1.clear();
	effectiveNow1 = false;
	limitType2 = 0;
	errorCode2 = 0;
	errDescr2.clear();
	effectiveNow2 = false;
	limit = 0;
	waitingIncreaseLimitDays1 = 0;
	waitingIncreaseLimitDays2 = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY::equals(const Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		limitType1 == _o.limitType1 &&
		errorCode1 == _o.errorCode1 &&
		Atf::atfPStringEquals(errDescr1, _o.errDescr1) &&
		effectiveNow1 == _o.effectiveNow1 &&
		limitType2 == _o.limitType2 &&
		errorCode2 == _o.errorCode2 &&
		Atf::atfPStringEquals(errDescr2, _o.errDescr2) &&
		effectiveNow2 == _o.effectiveNow2 &&
		limit == _o.limit &&
		waitingIncreaseLimitDays1 == _o.waitingIncreaseLimitDays1 &&
		waitingIncreaseLimitDays2 == _o.waitingIncreaseLimitDays2;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_SET_TOURN_LIMITS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SET_TOURN_LIMITS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("limitType1=");
	_buf.appendUint(limitType1);
	_buf.append(',');
	_buf.append("errorCode1=");
	_buf.appendInt(errorCode1);
	if(errorCode1)
	{
		_buf.append(',');
		_buf.append("errDescr1=");
		_buf.append(errDescr1);
	}
	else
	{
		_buf.append(',');
		_buf.append("effectiveNow1=");
		_buf.appendUint(effectiveNow1);
	}
	_buf.append(',');
	_buf.append("limitType2=");
	_buf.appendUint(limitType2);
	_buf.append(',');
	_buf.append("errorCode2=");
	_buf.appendInt(errorCode2);
	if(errorCode2)
	{
		_buf.append(',');
		_buf.append("errDescr2=");
		_buf.append(errDescr2);
	}
	else
	{
		_buf.append(',');
		_buf.append("effectiveNow2=");
		_buf.appendUint(effectiveNow2);
	}
	_buf.append(',');
	_buf.append("limit=");
	_buf.appendUint(limit);
	_buf.append(',');
	_buf.append("waitingIncreaseLimitDays1=");
	_buf.appendUint(waitingIncreaseLimitDays1);
	_buf.append(',');
	_buf.append("waitingIncreaseLimitDays2=");
	_buf.appendUint(waitingIncreaseLimitDays2);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_SET_TOURN_LIMITS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("limitType1", limitType1, _buf);
	Atf::XmlElement::encodeAsXmlElement("errorCode1", errorCode1, _buf);
	if(errorCode1)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr1", errDescr1, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("effectiveNow1", effectiveNow1, _buf);
	}
	Atf::XmlElement::encodeAsXmlElement("limitType2", limitType2, _buf);
	Atf::XmlElement::encodeAsXmlElement("errorCode2", errorCode2, _buf);
	if(errorCode2)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr2", errDescr2, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("effectiveNow2", effectiveNow2, _buf);
	}
	Atf::XmlElement::encodeAsXmlElement("limit", limit, _buf);
	Atf::XmlElement::encodeAsXmlElement("waitingIncreaseLimitDays1", waitingIncreaseLimitDays1, _buf);
	Atf::XmlElement::encodeAsXmlElement("waitingIncreaseLimitDays2", waitingIncreaseLimitDays2, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("limitType1"))
			{
				limitType1 = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errorCode1"))
			{
				errorCode1 = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr1"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr1)) return false;
			}
			else if (_element.equals("effectiveNow1"))
			{
				effectiveNow1 = (*_value.ptr() == '1');
			}
			else if (_element.equals("limitType2"))
			{
				limitType2 = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errorCode2"))
			{
				errorCode2 = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr2"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr2)) return false;
			}
			else if (_element.equals("effectiveNow2"))
			{
				effectiveNow2 = (*_value.ptr() == '1');
			}
			else if (_element.equals("limit"))
			{
				limit = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("waitingIncreaseLimitDays1"))
			{
				waitingIncreaseLimitDays1 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("waitingIncreaseLimitDays2"))
			{
				waitingIncreaseLimitDays2 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	_msg.composeBYTE(limitType1);
	_msg.composeINT16(errorCode1);
	if(errorCode1)
	{
		_msg.composeString(errDescr1);
	}
	else
	{
		_msg.composeBOOL(effectiveNow1);
	}
	_msg.composeBYTE(limitType2);
	_msg.composeINT16(errorCode2);
	if(errorCode2)
	{
		_msg.composeString(errDescr2);
	}
	else
	{
		_msg.composeBOOL(effectiveNow2);
	}
	_msg.composeUINT32(limit);
	_msg.composeUINT32(waitingIncreaseLimitDays1);
	_msg.composeUINT32(waitingIncreaseLimitDays2);
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseBYTE(limitType1);
	_parser.parseINT16(errorCode1);
	if(errorCode1)
	{
		_parser.parseStringP(errDescr1);
	}
	else
	{
		_parser.parseBOOL(effectiveNow1);
	}
	_parser.parseBYTE(limitType2);
	_parser.parseINT16(errorCode2);
	if(errorCode2)
	{
		_parser.parseStringP(errDescr2);
	}
	else
	{
		_parser.parseBOOL(effectiveNow2);
	}
	_parser.parseUINT32(limit);
	_parser.parseUINT32(waitingIncreaseLimitDays1);
	_parser.parseUINT32(waitingIncreaseLimitDays2);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("limitType1", limitType1);
	_jsonstr.compose("errorCode1", errorCode1);
	if(errorCode1)
	{
		_jsonstr.compose("errDescr1", errDescr1);
	}
	else
	{
		_jsonstr.compose("effectiveNow1", effectiveNow1);
	}
	_jsonstr.compose("limitType2", limitType2);
	_jsonstr.compose("errorCode2", errorCode2);
	if(errorCode2)
	{
		_jsonstr.compose("errDescr2", errDescr2);
	}
	else
	{
		_jsonstr.compose("effectiveNow2", effectiveNow2);
	}
	_jsonstr.compose("limit", limit);
	_jsonstr.compose("waitingIncreaseLimitDays1", waitingIncreaseLimitDays1);
	_jsonstr.compose("waitingIncreaseLimitDays2", waitingIncreaseLimitDays2);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("limitType1", limitType1);
	_jparser.parseByNameThrow("errorCode1", errorCode1);
	if(errorCode1)
	{
		_jparser.parseByNameThrow("errDescr1", errDescr1);
	}
	else
	{
		_jparser.parseByNameThrow("effectiveNow1", effectiveNow1);
	}
	_jparser.parseByNameThrow("limitType2", limitType2);
	_jparser.parseByNameThrow("errorCode2", errorCode2);
	if(errorCode2)
	{
		_jparser.parseByNameThrow("errDescr2", errDescr2);
	}
	else
	{
		_jparser.parseByNameThrow("effectiveNow2", effectiveNow2);
	}
	_jparser.parseByNameThrow("limit", limit);
	_jparser.parseByNameThrow("waitingIncreaseLimitDays1", waitingIncreaseLimitDays1);
	_jparser.parseByNameThrow("waitingIncreaseLimitDays2", waitingIncreaseLimitDays2);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_TOURN_LIMITS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errorCode1 = 0;
	INT16 errorCode2 = 0;
	INT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	BYTE limitType1; _jparser.validateByNameThrow("limitType1", limitType1);
	AtfValidator::validateInt(_descr, "limitType1", limitType1, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("errorCode1", errorCode1);
	AtfValidator::validateInt(_descr, "errorCode1", errorCode1, _checker, __FILE__, __LINE__);
	if(errorCode1)
	{
		PString errDescr1; _jparser.validateByNameThrow("errDescr1", errDescr1);
		AtfValidator::validateInt(_descr, "errDescr1", errDescr1.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		bool effectiveNow1; _jparser.validateByNameThrow("effectiveNow1", effectiveNow1);
		AtfValidator::validateInt(_descr, "effectiveNow1", effectiveNow1, _checker, __FILE__, __LINE__);
	}
	BYTE limitType2; _jparser.validateByNameThrow("limitType2", limitType2);
	AtfValidator::validateInt(_descr, "limitType2", limitType2, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("errorCode2", errorCode2);
	AtfValidator::validateInt(_descr, "errorCode2", errorCode2, _checker, __FILE__, __LINE__);
	if(errorCode2)
	{
		PString errDescr2; _jparser.validateByNameThrow("errDescr2", errDescr2);
		AtfValidator::validateInt(_descr, "errDescr2", errDescr2.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		bool effectiveNow2; _jparser.validateByNameThrow("effectiveNow2", effectiveNow2);
		AtfValidator::validateInt(_descr, "effectiveNow2", effectiveNow2, _checker, __FILE__, __LINE__);
	}
	UINT32 limit; _jparser.validateByNameThrow("limit", limit);
	AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
	UINT32 waitingIncreaseLimitDays1; _jparser.validateByNameThrow("waitingIncreaseLimitDays1", waitingIncreaseLimitDays1);
	AtfValidator::validateInt(_descr, "waitingIncreaseLimitDays1", waitingIncreaseLimitDays1, _checker, __FILE__, __LINE__);
	UINT32 waitingIncreaseLimitDays2; _jparser.validateByNameThrow("waitingIncreaseLimitDays2", waitingIncreaseLimitDays2);
	AtfValidator::validateInt(_descr, "waitingIncreaseLimitDays2", waitingIncreaseLimitDays2, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_TOURN_LIMITS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errorCode1 = 0;
	INT16 errorCode2 = 0;
	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	BYTE limitType1; _parser.parseBYTE(limitType1);
	AtfValidator::validateInt(_descr, "limitType1", limitType1, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errorCode1);
	AtfValidator::validateInt(_descr, "errorCode1", errorCode1, _checker, __FILE__, __LINE__);
	if(errorCode1)
	{
		_parser.parseStringN(_dummy, 0, "errDescr1"); size_t szErrDescr1 = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr1", szErrDescr1, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool effectiveNow1; _parser.parseBOOL(effectiveNow1);
		AtfValidator::validateInt(_descr, "effectiveNow1", effectiveNow1, _checker, __FILE__, __LINE__);
	}
	BYTE limitType2; _parser.parseBYTE(limitType2);
	AtfValidator::validateInt(_descr, "limitType2", limitType2, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errorCode2);
	AtfValidator::validateInt(_descr, "errorCode2", errorCode2, _checker, __FILE__, __LINE__);
	if(errorCode2)
	{
		_parser.parseStringN(_dummy, 0, "errDescr2"); size_t szErrDescr2 = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr2", szErrDescr2, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool effectiveNow2; _parser.parseBOOL(effectiveNow2);
		AtfValidator::validateInt(_descr, "effectiveNow2", effectiveNow2, _checker, __FILE__, __LINE__);
	}
	UINT32 limit; _parser.parseUINT32(limit);
	AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
	UINT32 waitingIncreaseLimitDays1; _parser.parseUINT32(waitingIncreaseLimitDays1);
	AtfValidator::validateInt(_descr, "waitingIncreaseLimitDays1", waitingIncreaseLimitDays1, _checker, __FILE__, __LINE__);
	UINT32 waitingIncreaseLimitDays2; _parser.parseUINT32(waitingIncreaseLimitDays2);
	AtfValidator::validateInt(_descr, "waitingIncreaseLimitDays2", waitingIncreaseLimitDays2, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_IT_DOCUMENT
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT::Protocol_MSG_LOBBY_IT_DOCUMENT()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT::clear()
{
}

bool Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT::equals(const Protocol_MSG_LOBBY_IT_DOCUMENT& _o) const
{
	return true;
}

bool Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_IT_DOCUMENT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_IT_DOCUMENT*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_IT_DOCUMENT).append(")");
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_IT_DOCUMENT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT::parseMsg(CommMsgParser& _parser)
{
}

const char *Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_IT_DOCUMENT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_IT_DOCUMENT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY::Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY::Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY(Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, sqlErr(std::move(_o.sqlErr))
{
}

Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY& Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY::operator=(Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		sqlErr = std::move(_o.sqlErr);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY::clear()
{
	errCode = 0;
	sqlErr.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY::equals(const Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(sqlErr, _o.sqlErr);
}

bool Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_IT_DOCUMENT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_IT_DOCUMENT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("sqlErr=");
	_buf.append(sqlErr);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_IT_DOCUMENT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("sqlErr", sqlErr, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("sqlErr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, sqlErr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(sqlErr);
}

void Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(sqlErr);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("sqlErr", sqlErr);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("sqlErr", sqlErr);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_IT_DOCUMENT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString sqlErr; _jparser.validateByNameThrow("sqlErr", sqlErr);
	AtfValidator::validateInt(_descr, "sqlErr", sqlErr.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_IT_DOCUMENT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "sqlErr"); size_t szSqlErr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "sqlErr", szSqlErr, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT::Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT::Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT(Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT&& _o)
	: tournId(std::move(_o.tournId))
	, buyInRM(std::move(_o.buyInRM))
	, buyInPlay(std::move(_o.buyInPlay))
	, buyInFpp(std::move(_o.buyInFpp))
	, buyInT(std::move(_o.buyInT))
	, buyInW(std::move(_o.buyInW))
	, currencyContext(std::move(_o.currencyContext))
	, dummy32(std::move(_o.dummy32))
	, dummy64(std::move(_o.dummy64))
	, useTicket(std::move(_o.useTicket))
{
}

Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT& Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT::operator=(Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT&& _o)
{
	if(this != &_o)
	{
		tournId = std::move(_o.tournId);
		buyInRM = std::move(_o.buyInRM);
		buyInPlay = std::move(_o.buyInPlay);
		buyInFpp = std::move(_o.buyInFpp);
		buyInT = std::move(_o.buyInT);
		buyInW = std::move(_o.buyInW);
		currencyContext = std::move(_o.currencyContext);
		dummy32 = std::move(_o.dummy32);
		dummy64 = std::move(_o.dummy64);
		useTicket = std::move(_o.useTicket);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT::clear()
{
	tournId = 0;
	buyInRM = 0;
	buyInPlay = 0;
	buyInFpp = 0;
	buyInT = 0;
	buyInW = 0;
	currencyContext.clear();
	dummy32 = 0;
	dummy64 = 0;
	useTicket = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT::equals(const Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT& _o) const
{
	return tournId == _o.tournId &&
		buyInRM == _o.buyInRM &&
		buyInPlay == _o.buyInPlay &&
		buyInFpp == _o.buyInFpp &&
		buyInT == _o.buyInT &&
		buyInW == _o.buyInW &&
		currencyContext.equals(_o.currencyContext) &&
		dummy32 == _o.dummy32 &&
		dummy64 == _o.dummy64 &&
		useTicket == _o.useTicket;
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_CLI_REMATCH_ACCEPT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CLI_REMATCH_ACCEPT).append(")");
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("buyInRM=");
	_buf.appendUint(buyInRM);
	_buf.append(',');
	_buf.append("buyInPlay=");
	_buf.appendUint(buyInPlay);
	_buf.append(',');
	_buf.append("buyInFpp=");
	_buf.appendUint(buyInFpp);
	_buf.append(',');
	_buf.append("buyInT=");
	_buf.appendUint(buyInT);
	_buf.append(',');
	_buf.append("buyInW=");
	_buf.appendUint(buyInW);
	_buf.append(',');
	_buf.append("currencyContext=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(currencyContext, _buf); _buf.append('}');
	_buf.append(',');
	_buf.append("dummy32=");
	_buf.appendUint(dummy32);
	_buf.append(',');
	_buf.append("dummy64=");
	_buf.appendUint64(dummy64);
	_buf.append(',');
	_buf.append("useTicket=");
	_buf.appendUint(useTicket);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_CLI_REMATCH_ACCEPT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyInRM", buyInRM, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyInPlay", buyInPlay, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyInFpp", buyInFpp, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyInT", buyInT, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyInW", buyInW, _buf);
	Atf::XmlElement::encodeAsXmlElement("currencyContext", currencyContext, _buf);
	Atf::XmlElement::encodeAsXmlElement("dummy32", dummy32, _buf);
	Atf::XmlElement::encodeAsXmlElement("dummy64", dummy64, _buf);
	Atf::XmlElement::encodeAsXmlElement("useTicket", useTicket, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tournId"))
			{
				tournId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("buyInRM"))
			{
				buyInRM = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("buyInPlay"))
			{
				buyInPlay = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("buyInFpp"))
			{
				buyInFpp = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("buyInT"))
			{
				buyInT = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("buyInW"))
			{
				buyInW = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currencyContext"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, currencyContext)) return false;
			}
			else if (_element.equals("dummy32"))
			{
				dummy32 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("dummy64"))
			{
				dummy64 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("useTicket"))
			{
				useTicket = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(tournId);
	_msg.composeUINT32(buyInRM);
	_msg.composeUINT32(buyInPlay);
	_msg.composeUINT32(buyInFpp);
	_msg.composeUINT32(buyInT);
	_msg.composeUINT32(buyInW);
	_msg.composeMsgBody(currencyContext);
	_msg.composeUINT32(dummy32);
	_msg.composeUINT64(dummy64);
	_msg.composeBYTE(useTicket);
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tournId);
	_parser.parseUINT32(buyInRM);
	_parser.parseUINT32(buyInPlay);
	_parser.parseUINT32(buyInFpp);
	_parser.parseUINT32(buyInT);
	_parser.parseUINT32(buyInW);
	_parser.parseMsgBody(currencyContext);
	_parser.parseUINT32(dummy32);
	_parser.parseUINT64(dummy64);
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(useTicket);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tournId", tournId);
	_jsonstr.compose("buyInRM", buyInRM);
	_jsonstr.compose("buyInPlay", buyInPlay);
	_jsonstr.compose("buyInFpp", buyInFpp);
	_jsonstr.compose("buyInT", buyInT);
	_jsonstr.compose("buyInW", buyInW);
	_jsonstr.compose("currencyContext", currencyContext);
	_jsonstr.compose("dummy32", dummy32);
	_jsonstr.compose("dummy64", dummy64);
	_jsonstr.compose("useTicket", useTicket);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tournId", tournId);
	_jparser.parseByNameThrow("buyInRM", buyInRM);
	_jparser.parseByNameThrow("buyInPlay", buyInPlay);
	_jparser.parseByNameThrow("buyInFpp", buyInFpp);
	_jparser.parseByNameThrow("buyInT", buyInT);
	_jparser.parseByNameThrow("buyInW", buyInW);
	_jparser.parseByNameThrow("currencyContext", currencyContext);
	_jparser.parseByNameThrow("dummy32", dummy32);
	_jparser.parseByNameThrow("dummy64", dummy64);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("useTicket", useTicket);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLI_REMATCH_ACCEPT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	UINT32 buyInRM; _jparser.validateByNameThrow("buyInRM", buyInRM);
	AtfValidator::validateIntMax(_descr, "buyInRM", buyInRM, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 buyInPlay; _jparser.validateByNameThrow("buyInPlay", buyInPlay);
	AtfValidator::validateInt(_descr, "buyInPlay", buyInPlay, _checker, __FILE__, __LINE__);
	UINT32 buyInFpp; _jparser.validateByNameThrow("buyInFpp", buyInFpp);
	AtfValidator::validateIntMax(_descr, "buyInFpp", buyInFpp, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 buyInT; _jparser.validateByNameThrow("buyInT", buyInT);
	AtfValidator::validateIntMax(_descr, "buyInT", buyInT, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 buyInW; _jparser.validateByNameThrow("buyInW", buyInW);
	AtfValidator::validateIntMax(_descr, "buyInW", buyInW, 0, _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody currencyContext; _jparser.validateByNameThrow("currencyContext", currencyContext);
	AtfValidator::validateIntMax(_descr, "currencyContext", currencyContext._size(), 10000, _checker, __FILE__, __LINE__);
	UINT32 dummy32; _jparser.validateByNameThrow("dummy32", dummy32);
	AtfValidator::validateInt(_descr, "dummy32", dummy32, _checker, __FILE__, __LINE__);
	UINT64 dummy64; _jparser.validateByNameThrow("dummy64", dummy64);
	AtfValidator::validateUint(_descr, "dummy64", dummy64, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	BYTE useTicket; _jparser.validateByNameThrow("useTicket", useTicket);
	AtfValidator::validateIntMax(_descr, "useTicket", useTicket, 1, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLI_REMATCH_ACCEPT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	UINT32 buyInRM; _parser.parseUINT32(buyInRM);
	AtfValidator::validateIntMax(_descr, "buyInRM", buyInRM, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 buyInPlay; _parser.parseUINT32(buyInPlay);
	AtfValidator::validateInt(_descr, "buyInPlay", buyInPlay, _checker, __FILE__, __LINE__);
	UINT32 buyInFpp; _parser.parseUINT32(buyInFpp);
	AtfValidator::validateIntMax(_descr, "buyInFpp", buyInFpp, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 buyInT; _parser.parseUINT32(buyInT);
	AtfValidator::validateIntMax(_descr, "buyInT", buyInT, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 buyInW; _parser.parseUINT32(buyInW);
	AtfValidator::validateIntMax(_descr, "buyInW", buyInW, 0, _checker, __FILE__, __LINE__);
	size_t szCurrencyContext; _parser.skipMsgBody(szCurrencyContext);  /*currencyContext*/
	AtfValidator::validateIntMax(_descr, "currencyContext", szCurrencyContext, 10000, _checker, __FILE__, __LINE__);
	UINT32 dummy32; _parser.parseUINT32(dummy32);
	AtfValidator::validateInt(_descr, "dummy32", dummy32, _checker, __FILE__, __LINE__);
	UINT64 dummy64; _parser.parseUINT64(dummy64);
	AtfValidator::validateUint(_descr, "dummy64", dummy64, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	BYTE useTicket; _parser.parseBYTE(useTicket);
	AtfValidator::validateIntMax(_descr, "useTicket", useTicket, 1, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CLI_REMATCH_DECLINE
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_DECLINE::Protocol_MSG_LOBBY_CLI_REMATCH_DECLINE()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_DECLINE::clear()
{
	tournId = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_DECLINE::equals(const Protocol_MSG_LOBBY_CLI_REMATCH_DECLINE& _o) const
{
	return tournId == _o.tournId;
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_DECLINE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_CLI_REMATCH_DECLINE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_CLI_REMATCH_DECLINE*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_DECLINE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CLI_REMATCH_DECLINE).append(")");
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_DECLINE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_DECLINE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_CLI_REMATCH_DECLINE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_DECLINE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tournId"))
			{
				tournId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_DECLINE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(tournId);
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_DECLINE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tournId);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_DECLINE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tournId", tournId);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_DECLINE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tournId", tournId);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_DECLINE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLI_REMATCH_DECLINE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CLI_REMATCH_DECLINE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLI_REMATCH_DECLINE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_MIGRATION_GET_INFO
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO::Protocol_MSG_LOBBY_MIGRATION_GET_INFO()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO::Protocol_MSG_LOBBY_MIGRATION_GET_INFO(Protocol_MSG_LOBBY_MIGRATION_GET_INFO&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, type(std::move(_o.type))
{
}

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO& Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO::operator=(Protocol_MSG_LOBBY_MIGRATION_GET_INFO&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		type = std::move(_o.type);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO::clear()
{
	notUsedStr.clear();
	type = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO::equals(const Protocol_MSG_LOBBY_MIGRATION_GET_INFO& _o) const
{
	return Atf::atfPStringEquals(notUsedStr, _o.notUsedStr) &&
		type == _o.type;
}

bool Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_MIGRATION_GET_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_MIGRATION_GET_INFO*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_MIGRATION_GET_INFO).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("type=");
	_buf.appendUint(type);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_MIGRATION_GET_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsedStr", notUsedStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("type", type, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedStr)) return false;
			}
			else if (_element.equals("type"))
			{
				type = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsedStr);
	_msg.composeUINT32(type);
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseUINT32(type);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsedStr", notUsedStr);
	_jsonstr.compose("type", type);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsedStr", notUsedStr);
	_jparser.parseByNameThrow("type", type);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_MIGRATION_GET_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsedStr; _jparser.validateByNameThrow("notUsedStr", notUsedStr);
	AtfValidator::validateIntMax(_descr, "notUsedStr", notUsedStr.length(), 20, _checker, __FILE__, __LINE__);
	UINT32 type; _jparser.validateByNameThrow("type", type);
	AtfValidator::validateIntRange(_descr, "type", type, eMigrationTypeTransfer, eMigrationTypeLast, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_MIGRATION_GET_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	UINT32 type; _parser.parseUINT32(type);
	AtfValidator::validateIntRange(_descr, "type", type, eMigrationTypeTransfer, eMigrationTypeLast, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY::Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY::Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY(Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, linkedUserId(std::move(_o.linkedUserId))
	, linkedUserCity(std::move(_o.linkedUserCity))
	, cashBalance(std::move(_o.cashBalance))
	, tBalance(std::move(_o.tBalance))
	, wBalance(std::move(_o.wBalance))
	, fppBalance(std::move(_o.fppBalance))
	, monthlyVpp(std::move(_o.monthlyVpp))
	, yearlyVpp(std::move(_o.yearlyVpp))
	, tickets(std::move(_o.tickets))
	, bonuses(std::move(_o.bonuses))
	, exchangeRate(std::move(_o.exchangeRate))
	, migrationType(std::move(_o.migrationType))
	, bonusEligible(std::move(_o.bonusEligible))
	, birthDate(std::move(_o.birthDate))
{
}

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY& Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY::operator=(Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		linkedUserId = std::move(_o.linkedUserId);
		linkedUserCity = std::move(_o.linkedUserCity);
		cashBalance = std::move(_o.cashBalance);
		tBalance = std::move(_o.tBalance);
		wBalance = std::move(_o.wBalance);
		fppBalance = std::move(_o.fppBalance);
		monthlyVpp = std::move(_o.monthlyVpp);
		yearlyVpp = std::move(_o.yearlyVpp);
		tickets = std::move(_o.tickets);
		bonuses = std::move(_o.bonuses);
		exchangeRate = std::move(_o.exchangeRate);
		migrationType = std::move(_o.migrationType);
		bonusEligible = std::move(_o.bonusEligible);
		birthDate = std::move(_o.birthDate);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	linkedUserId.clear();
	linkedUserCity.clear();
	cashBalance = 0;
	tBalance = 0;
	wBalance = 0;
	fppBalance = 0;
	monthlyVpp = 0;
	yearlyVpp = 0;
	tickets = 0;
	bonuses = 0;
	exchangeRate = 0;
	migrationType = 0;
	bonusEligible = false;
	birthDate.setNull();
}

bool Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY::equals(const Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(linkedUserId, _o.linkedUserId) &&
		Atf::atfPStringEquals(linkedUserCity, _o.linkedUserCity) &&
		cashBalance == _o.cashBalance &&
		tBalance == _o.tBalance &&
		wBalance == _o.wBalance &&
		fppBalance == _o.fppBalance &&
		monthlyVpp == _o.monthlyVpp &&
		yearlyVpp == _o.yearlyVpp &&
		tickets == _o.tickets &&
		bonuses == _o.bonuses &&
		exchangeRate == _o.exchangeRate &&
		migrationType == _o.migrationType &&
		bonusEligible == _o.bonusEligible &&
		birthDate.equals(_o.birthDate);
}

bool Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_MIGRATION_GET_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_MIGRATION_GET_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("linkedUserId=");
		_buf.append(linkedUserId);
		_buf.append(',');
		_buf.append("linkedUserCity=");
		_buf.append(linkedUserCity);
		_buf.append(',');
		_buf.append("cashBalance=");
		_buf.appendInt(cashBalance);
		_buf.append(',');
		_buf.append("tBalance=");
		_buf.appendInt(tBalance);
		_buf.append(',');
		_buf.append("wBalance=");
		_buf.appendInt(wBalance);
		_buf.append(',');
		_buf.append("fppBalance=");
		_buf.appendInt(fppBalance);
		_buf.append(',');
		_buf.append("monthlyVpp=");
		_buf.appendInt(monthlyVpp);
		_buf.append(',');
		_buf.append("yearlyVpp=");
		_buf.appendInt(yearlyVpp);
		_buf.append(',');
		_buf.append("tickets=");
		_buf.appendInt(tickets);
		_buf.append(',');
		_buf.append("bonuses=");
		_buf.appendInt(bonuses);
		_buf.append(',');
		_buf.append("exchangeRate=");
		_buf.appendInt(exchangeRate);
		_buf.append(',');
		_buf.append("migrationType=");
		_buf.appendInt(migrationType);
		_buf.append(',');
		_buf.append("bonusEligible=");
		_buf.appendUint(bonusEligible);
		_buf.append(',');
		_buf.append("birthDate=");
		Atf::AtfTempl<SrvDate>::ToTraceString(_buf, birthDate);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_MIGRATION_GET_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("linkedUserId", linkedUserId, _buf);
		Atf::XmlElement::encodeAsXmlElement("linkedUserCity", linkedUserCity, _buf);
		Atf::XmlElement::encodeAsXmlElement("cashBalance", cashBalance, _buf);
		Atf::XmlElement::encodeAsXmlElement("tBalance", tBalance, _buf);
		Atf::XmlElement::encodeAsXmlElement("wBalance", wBalance, _buf);
		Atf::XmlElement::encodeAsXmlElement("fppBalance", fppBalance, _buf);
		Atf::XmlElement::encodeAsXmlElement("monthlyVpp", monthlyVpp, _buf);
		Atf::XmlElement::encodeAsXmlElement("yearlyVpp", yearlyVpp, _buf);
		Atf::XmlElement::encodeAsXmlElement("tickets", tickets, _buf);
		Atf::XmlElement::encodeAsXmlElement("bonuses", bonuses, _buf);
		Atf::XmlElement::encodeAsXmlElement("exchangeRate", exchangeRate, _buf);
		Atf::XmlElement::encodeAsXmlElement("migrationType", migrationType, _buf);
		Atf::XmlElement::encodeAsXmlElement("bonusEligible", bonusEligible, _buf);
		Atf::AtfTempl<SrvDate>::ToXmlString(_buf, "birthDate", birthDate);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("linkedUserId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, linkedUserId)) return false;
			}
			else if (_element.equals("linkedUserCity"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, linkedUserCity)) return false;
			}
			else if (_element.equals("cashBalance"))
			{
				cashBalance = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tBalance"))
			{
				tBalance = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("wBalance"))
			{
				wBalance = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("fppBalance"))
			{
				fppBalance = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("monthlyVpp"))
			{
				monthlyVpp = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("yearlyVpp"))
			{
				yearlyVpp = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tickets"))
			{
				tickets = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("bonuses"))
			{
				bonuses = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("exchangeRate"))
			{
				exchangeRate = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("migrationType"))
			{
				migrationType = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("bonusEligible"))
			{
				bonusEligible = (*_value.ptr() == '1');
			}
			else if (_element.equals("birthDate"))
			{
				Atf::AtfTempl<SrvDate>::FromXmlString(_value, birthDate);
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(linkedUserId);
		_msg.composeString(linkedUserCity);
		_msg.composeINT32(cashBalance);
		_msg.composeINT32(tBalance);
		_msg.composeINT32(wBalance);
		_msg.composeINT32(fppBalance);
		_msg.composeINT32(monthlyVpp);
		_msg.composeINT32(yearlyVpp);
		_msg.composeINT32(tickets);
		_msg.composeINT32(bonuses);
		_msg.composeINT32(exchangeRate);
		_msg.composeINT32(migrationType);
		_msg.composeBOOL(bonusEligible);
		_msg.composeSrvDate(birthDate);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(linkedUserId);
		_parser.parseStringP(linkedUserCity);
		_parser.parseINT32(cashBalance);
		_parser.parseINT32(tBalance);
		_parser.parseINT32(wBalance);
		_parser.parseINT32(fppBalance);
		_parser.parseINT32(monthlyVpp);
		_parser.parseINT32(yearlyVpp);
		_parser.parseINT32(tickets);
		_parser.parseINT32(bonuses);
		_parser.parseINT32(exchangeRate);
		_parser.parseINT32(migrationType);
		_parser.parseBOOL(bonusEligible);
		_parser.parseSrvDate(birthDate);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("linkedUserId", linkedUserId);
		_jsonstr.compose("linkedUserCity", linkedUserCity);
		_jsonstr.compose("cashBalance", cashBalance);
		_jsonstr.compose("tBalance", tBalance);
		_jsonstr.compose("wBalance", wBalance);
		_jsonstr.compose("fppBalance", fppBalance);
		_jsonstr.compose("monthlyVpp", monthlyVpp);
		_jsonstr.compose("yearlyVpp", yearlyVpp);
		_jsonstr.compose("tickets", tickets);
		_jsonstr.compose("bonuses", bonuses);
		_jsonstr.compose("exchangeRate", exchangeRate);
		_jsonstr.compose("migrationType", migrationType);
		_jsonstr.compose("bonusEligible", bonusEligible);
		_jsonstr.compose("birthDate", birthDate);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("linkedUserId", linkedUserId);
		_jparser.parseByNameThrow("linkedUserCity", linkedUserCity);
		_jparser.parseByNameThrow("cashBalance", cashBalance);
		_jparser.parseByNameThrow("tBalance", tBalance);
		_jparser.parseByNameThrow("wBalance", wBalance);
		_jparser.parseByNameThrow("fppBalance", fppBalance);
		_jparser.parseByNameThrow("monthlyVpp", monthlyVpp);
		_jparser.parseByNameThrow("yearlyVpp", yearlyVpp);
		_jparser.parseByNameThrow("tickets", tickets);
		_jparser.parseByNameThrow("bonuses", bonuses);
		_jparser.parseByNameThrow("exchangeRate", exchangeRate);
		_jparser.parseByNameThrow("migrationType", migrationType);
		_jparser.parseByNameThrow("bonusEligible", bonusEligible);
		_jparser.parseByNameThrow("birthDate", birthDate);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_MIGRATION_GET_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString linkedUserId; _jparser.validateByNameThrow("linkedUserId", linkedUserId);
		AtfValidator::validateInt(_descr, "linkedUserId", linkedUserId.length(), _checker, __FILE__, __LINE__);
		PString linkedUserCity; _jparser.validateByNameThrow("linkedUserCity", linkedUserCity);
		AtfValidator::validateInt(_descr, "linkedUserCity", linkedUserCity.length(), _checker, __FILE__, __LINE__);
		INT32 cashBalance; _jparser.validateByNameThrow("cashBalance", cashBalance);
		AtfValidator::validateInt(_descr, "cashBalance", cashBalance, _checker, __FILE__, __LINE__);
		INT32 tBalance; _jparser.validateByNameThrow("tBalance", tBalance);
		AtfValidator::validateInt(_descr, "tBalance", tBalance, _checker, __FILE__, __LINE__);
		INT32 wBalance; _jparser.validateByNameThrow("wBalance", wBalance);
		AtfValidator::validateInt(_descr, "wBalance", wBalance, _checker, __FILE__, __LINE__);
		INT32 fppBalance; _jparser.validateByNameThrow("fppBalance", fppBalance);
		AtfValidator::validateInt(_descr, "fppBalance", fppBalance, _checker, __FILE__, __LINE__);
		INT32 monthlyVpp; _jparser.validateByNameThrow("monthlyVpp", monthlyVpp);
		AtfValidator::validateInt(_descr, "monthlyVpp", monthlyVpp, _checker, __FILE__, __LINE__);
		INT32 yearlyVpp; _jparser.validateByNameThrow("yearlyVpp", yearlyVpp);
		AtfValidator::validateInt(_descr, "yearlyVpp", yearlyVpp, _checker, __FILE__, __LINE__);
		INT32 tickets; _jparser.validateByNameThrow("tickets", tickets);
		AtfValidator::validateInt(_descr, "tickets", tickets, _checker, __FILE__, __LINE__);
		INT32 bonuses; _jparser.validateByNameThrow("bonuses", bonuses);
		AtfValidator::validateInt(_descr, "bonuses", bonuses, _checker, __FILE__, __LINE__);
		INT32 exchangeRate; _jparser.validateByNameThrow("exchangeRate", exchangeRate);
		AtfValidator::validateInt(_descr, "exchangeRate", exchangeRate, _checker, __FILE__, __LINE__);
		INT32 migrationType; _jparser.validateByNameThrow("migrationType", migrationType);
		AtfValidator::validateInt(_descr, "migrationType", migrationType, _checker, __FILE__, __LINE__);
		bool bonusEligible; _jparser.validateByNameThrow("bonusEligible", bonusEligible);
		AtfValidator::validateInt(_descr, "bonusEligible", bonusEligible, _checker, __FILE__, __LINE__);
		SrvDate birthDate; _jparser.validateByNameThrow("birthDate", birthDate);
		AtfValidator::validateSrvDateTime(_descr, "birthDate", birthDate, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_MIGRATION_GET_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "linkedUserId"); size_t szLinkedUserId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "linkedUserId", szLinkedUserId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "linkedUserCity"); size_t szLinkedUserCity = strlen(_dummy);
		AtfValidator::validateInt(_descr, "linkedUserCity", szLinkedUserCity, _checker, __FILE__, __LINE__);
		INT32 cashBalance; _parser.parseINT32(cashBalance);
		AtfValidator::validateInt(_descr, "cashBalance", cashBalance, _checker, __FILE__, __LINE__);
		INT32 tBalance; _parser.parseINT32(tBalance);
		AtfValidator::validateInt(_descr, "tBalance", tBalance, _checker, __FILE__, __LINE__);
		INT32 wBalance; _parser.parseINT32(wBalance);
		AtfValidator::validateInt(_descr, "wBalance", wBalance, _checker, __FILE__, __LINE__);
		INT32 fppBalance; _parser.parseINT32(fppBalance);
		AtfValidator::validateInt(_descr, "fppBalance", fppBalance, _checker, __FILE__, __LINE__);
		INT32 monthlyVpp; _parser.parseINT32(monthlyVpp);
		AtfValidator::validateInt(_descr, "monthlyVpp", monthlyVpp, _checker, __FILE__, __LINE__);
		INT32 yearlyVpp; _parser.parseINT32(yearlyVpp);
		AtfValidator::validateInt(_descr, "yearlyVpp", yearlyVpp, _checker, __FILE__, __LINE__);
		INT32 tickets; _parser.parseINT32(tickets);
		AtfValidator::validateInt(_descr, "tickets", tickets, _checker, __FILE__, __LINE__);
		INT32 bonuses; _parser.parseINT32(bonuses);
		AtfValidator::validateInt(_descr, "bonuses", bonuses, _checker, __FILE__, __LINE__);
		INT32 exchangeRate; _parser.parseINT32(exchangeRate);
		AtfValidator::validateInt(_descr, "exchangeRate", exchangeRate, _checker, __FILE__, __LINE__);
		INT32 migrationType; _parser.parseINT32(migrationType);
		AtfValidator::validateInt(_descr, "migrationType", migrationType, _checker, __FILE__, __LINE__);
		bool bonusEligible; _parser.parseBOOL(bonusEligible);
		AtfValidator::validateInt(_descr, "bonusEligible", bonusEligible, _checker, __FILE__, __LINE__);
		SrvDate birthDate; _parser.parseSrvDate(birthDate);
		AtfValidator::validateSrvDateTime(_descr, "birthDate", birthDate, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_MIGRATION_LINK
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK::Protocol_MSG_LOBBY_MIGRATION_LINK()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK::Protocol_MSG_LOBBY_MIGRATION_LINK(Protocol_MSG_LOBBY_MIGRATION_LINK&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, type(std::move(_o.type))
	, linkedUser(std::move(_o.linkedUser))
	, dob(std::move(_o.dob))
{
}

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK& Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK::operator=(Protocol_MSG_LOBBY_MIGRATION_LINK&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		type = std::move(_o.type);
		linkedUser = std::move(_o.linkedUser);
		dob = std::move(_o.dob);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK::clear()
{
	notUsedStr.clear();
	type = 0;
	linkedUser.clear();
	dob.setNull();
}

bool Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK::equals(const Protocol_MSG_LOBBY_MIGRATION_LINK& _o) const
{
	return Atf::atfPStringEquals(notUsedStr, _o.notUsedStr) &&
		type == _o.type &&
		Atf::atfPStringEquals(linkedUser, _o.linkedUser) &&
		dob.equals(_o.dob);
}

bool Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_MIGRATION_LINK != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_MIGRATION_LINK*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_MIGRATION_LINK).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("type=");
	_buf.appendUint(type);
	_buf.append(',');
	_buf.append("linkedUser=");
	_buf.append(linkedUser);
	_buf.append(',');
	_buf.append("dob=");
	Atf::AtfTempl<SrvDate>::ToTraceString(_buf, dob);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_MIGRATION_LINK).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsedStr", notUsedStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("type", type, _buf);
	Atf::XmlElement::encodeAsXmlElement("linkedUser", linkedUser, _buf);
	Atf::AtfTempl<SrvDate>::ToXmlString(_buf, "dob", dob);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedStr)) return false;
			}
			else if (_element.equals("type"))
			{
				type = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("linkedUser"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, linkedUser)) return false;
			}
			else if (_element.equals("dob"))
			{
				Atf::AtfTempl<SrvDate>::FromXmlString(_value, dob);
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsedStr);
	_msg.composeUINT32(type);
	_msg.composeString(linkedUser);
	_msg.composeSrvDate(dob);
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseUINT32(type);
	_parser.parseStringP(linkedUser);
	_parser.parseSrvDate(dob);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsedStr", notUsedStr);
	_jsonstr.compose("type", type);
	_jsonstr.compose("linkedUser", linkedUser);
	_jsonstr.compose("dob", dob);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsedStr", notUsedStr);
	_jparser.parseByNameThrow("type", type);
	_jparser.parseByNameThrow("linkedUser", linkedUser);
	_jparser.parseByNameThrow("dob", dob);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_MIGRATION_LINK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsedStr; _jparser.validateByNameThrow("notUsedStr", notUsedStr);
	AtfValidator::validateIntMax(_descr, "notUsedStr", notUsedStr.length(), 20, _checker, __FILE__, __LINE__);
	UINT32 type; _jparser.validateByNameThrow("type", type);
	AtfValidator::validateIntRange(_descr, "type", type, eMigrationTypeTransfer, eMigrationTypeLast, _checker, __FILE__, __LINE__);
	PString linkedUser; _jparser.validateByNameThrow("linkedUser", linkedUser);
	AtfValidator::validateIntMax(_descr, "linkedUser", linkedUser.length(), 20, _checker, __FILE__, __LINE__);
	SrvDate dob; _jparser.validateByNameThrow("dob", dob);
	AtfValidator::validateSrvDateTime(_descr, "dob", dob, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_MIGRATION_LINK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	UINT32 type; _parser.parseUINT32(type);
	AtfValidator::validateIntRange(_descr, "type", type, eMigrationTypeTransfer, eMigrationTypeLast, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "linkedUser"); size_t szLinkedUser = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "linkedUser", szLinkedUser, 20, _checker, __FILE__, __LINE__);
	SrvDate dob; _parser.parseSrvDate(dob);
	AtfValidator::validateSrvDateTime(_descr, "dob", dob, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY::Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY::Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY(Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, linkedUserId(std::move(_o.linkedUserId))
	, linkedUserCity(std::move(_o.linkedUserCity))
	, cashBalance(std::move(_o.cashBalance))
	, tBalance(std::move(_o.tBalance))
	, wBalance(std::move(_o.wBalance))
	, fppBalance(std::move(_o.fppBalance))
	, monthlyVpp(std::move(_o.monthlyVpp))
	, yearlyVpp(std::move(_o.yearlyVpp))
	, tickets(std::move(_o.tickets))
	, bonuses(std::move(_o.bonuses))
	, exchangeRate(std::move(_o.exchangeRate))
	, migrationType(std::move(_o.migrationType))
	, bonusEligible(std::move(_o.bonusEligible))
	, birthDate(std::move(_o.birthDate))
{
}

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY& Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY::operator=(Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		linkedUserId = std::move(_o.linkedUserId);
		linkedUserCity = std::move(_o.linkedUserCity);
		cashBalance = std::move(_o.cashBalance);
		tBalance = std::move(_o.tBalance);
		wBalance = std::move(_o.wBalance);
		fppBalance = std::move(_o.fppBalance);
		monthlyVpp = std::move(_o.monthlyVpp);
		yearlyVpp = std::move(_o.yearlyVpp);
		tickets = std::move(_o.tickets);
		bonuses = std::move(_o.bonuses);
		exchangeRate = std::move(_o.exchangeRate);
		migrationType = std::move(_o.migrationType);
		bonusEligible = std::move(_o.bonusEligible);
		birthDate = std::move(_o.birthDate);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	linkedUserId.clear();
	linkedUserCity.clear();
	cashBalance = 0;
	tBalance = 0;
	wBalance = 0;
	fppBalance = 0;
	monthlyVpp = 0;
	yearlyVpp = 0;
	tickets = 0;
	bonuses = 0;
	exchangeRate = 0;
	migrationType = 0;
	bonusEligible = false;
	birthDate.setNull();
}

bool Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY::equals(const Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(linkedUserId, _o.linkedUserId) &&
		Atf::atfPStringEquals(linkedUserCity, _o.linkedUserCity) &&
		cashBalance == _o.cashBalance &&
		tBalance == _o.tBalance &&
		wBalance == _o.wBalance &&
		fppBalance == _o.fppBalance &&
		monthlyVpp == _o.monthlyVpp &&
		yearlyVpp == _o.yearlyVpp &&
		tickets == _o.tickets &&
		bonuses == _o.bonuses &&
		exchangeRate == _o.exchangeRate &&
		migrationType == _o.migrationType &&
		bonusEligible == _o.bonusEligible &&
		birthDate.equals(_o.birthDate);
}

bool Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_MIGRATION_LINK_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_MIGRATION_LINK_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("linkedUserId=");
		_buf.append(linkedUserId);
		_buf.append(',');
		_buf.append("linkedUserCity=");
		_buf.append(linkedUserCity);
		_buf.append(',');
		_buf.append("cashBalance=");
		_buf.appendInt(cashBalance);
		_buf.append(',');
		_buf.append("tBalance=");
		_buf.appendInt(tBalance);
		_buf.append(',');
		_buf.append("wBalance=");
		_buf.appendInt(wBalance);
		_buf.append(',');
		_buf.append("fppBalance=");
		_buf.appendInt(fppBalance);
		_buf.append(',');
		_buf.append("monthlyVpp=");
		_buf.appendInt(monthlyVpp);
		_buf.append(',');
		_buf.append("yearlyVpp=");
		_buf.appendInt(yearlyVpp);
		_buf.append(',');
		_buf.append("tickets=");
		_buf.appendInt(tickets);
		_buf.append(',');
		_buf.append("bonuses=");
		_buf.appendInt(bonuses);
		_buf.append(',');
		_buf.append("exchangeRate=");
		_buf.appendInt(exchangeRate);
		_buf.append(',');
		_buf.append("migrationType=");
		_buf.appendInt(migrationType);
		_buf.append(',');
		_buf.append("bonusEligible=");
		_buf.appendUint(bonusEligible);
		_buf.append(',');
		_buf.append("birthDate=");
		Atf::AtfTempl<SrvDate>::ToTraceString(_buf, birthDate);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_MIGRATION_LINK_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("linkedUserId", linkedUserId, _buf);
		Atf::XmlElement::encodeAsXmlElement("linkedUserCity", linkedUserCity, _buf);
		Atf::XmlElement::encodeAsXmlElement("cashBalance", cashBalance, _buf);
		Atf::XmlElement::encodeAsXmlElement("tBalance", tBalance, _buf);
		Atf::XmlElement::encodeAsXmlElement("wBalance", wBalance, _buf);
		Atf::XmlElement::encodeAsXmlElement("fppBalance", fppBalance, _buf);
		Atf::XmlElement::encodeAsXmlElement("monthlyVpp", monthlyVpp, _buf);
		Atf::XmlElement::encodeAsXmlElement("yearlyVpp", yearlyVpp, _buf);
		Atf::XmlElement::encodeAsXmlElement("tickets", tickets, _buf);
		Atf::XmlElement::encodeAsXmlElement("bonuses", bonuses, _buf);
		Atf::XmlElement::encodeAsXmlElement("exchangeRate", exchangeRate, _buf);
		Atf::XmlElement::encodeAsXmlElement("migrationType", migrationType, _buf);
		Atf::XmlElement::encodeAsXmlElement("bonusEligible", bonusEligible, _buf);
		Atf::AtfTempl<SrvDate>::ToXmlString(_buf, "birthDate", birthDate);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("linkedUserId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, linkedUserId)) return false;
			}
			else if (_element.equals("linkedUserCity"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, linkedUserCity)) return false;
			}
			else if (_element.equals("cashBalance"))
			{
				cashBalance = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tBalance"))
			{
				tBalance = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("wBalance"))
			{
				wBalance = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("fppBalance"))
			{
				fppBalance = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("monthlyVpp"))
			{
				monthlyVpp = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("yearlyVpp"))
			{
				yearlyVpp = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tickets"))
			{
				tickets = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("bonuses"))
			{
				bonuses = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("exchangeRate"))
			{
				exchangeRate = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("migrationType"))
			{
				migrationType = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("bonusEligible"))
			{
				bonusEligible = (*_value.ptr() == '1');
			}
			else if (_element.equals("birthDate"))
			{
				Atf::AtfTempl<SrvDate>::FromXmlString(_value, birthDate);
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(linkedUserId);
		_msg.composeString(linkedUserCity);
		_msg.composeINT32(cashBalance);
		_msg.composeINT32(tBalance);
		_msg.composeINT32(wBalance);
		_msg.composeINT32(fppBalance);
		_msg.composeINT32(monthlyVpp);
		_msg.composeINT32(yearlyVpp);
		_msg.composeINT32(tickets);
		_msg.composeINT32(bonuses);
		_msg.composeINT32(exchangeRate);
		_msg.composeINT32(migrationType);
		_msg.composeBOOL(bonusEligible);
		_msg.composeSrvDate(birthDate);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(linkedUserId);
		_parser.parseStringP(linkedUserCity);
		_parser.parseINT32(cashBalance);
		_parser.parseINT32(tBalance);
		_parser.parseINT32(wBalance);
		_parser.parseINT32(fppBalance);
		_parser.parseINT32(monthlyVpp);
		_parser.parseINT32(yearlyVpp);
		_parser.parseINT32(tickets);
		_parser.parseINT32(bonuses);
		_parser.parseINT32(exchangeRate);
		_parser.parseINT32(migrationType);
		_parser.parseBOOL(bonusEligible);
		_parser.parseSrvDate(birthDate);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("linkedUserId", linkedUserId);
		_jsonstr.compose("linkedUserCity", linkedUserCity);
		_jsonstr.compose("cashBalance", cashBalance);
		_jsonstr.compose("tBalance", tBalance);
		_jsonstr.compose("wBalance", wBalance);
		_jsonstr.compose("fppBalance", fppBalance);
		_jsonstr.compose("monthlyVpp", monthlyVpp);
		_jsonstr.compose("yearlyVpp", yearlyVpp);
		_jsonstr.compose("tickets", tickets);
		_jsonstr.compose("bonuses", bonuses);
		_jsonstr.compose("exchangeRate", exchangeRate);
		_jsonstr.compose("migrationType", migrationType);
		_jsonstr.compose("bonusEligible", bonusEligible);
		_jsonstr.compose("birthDate", birthDate);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("linkedUserId", linkedUserId);
		_jparser.parseByNameThrow("linkedUserCity", linkedUserCity);
		_jparser.parseByNameThrow("cashBalance", cashBalance);
		_jparser.parseByNameThrow("tBalance", tBalance);
		_jparser.parseByNameThrow("wBalance", wBalance);
		_jparser.parseByNameThrow("fppBalance", fppBalance);
		_jparser.parseByNameThrow("monthlyVpp", monthlyVpp);
		_jparser.parseByNameThrow("yearlyVpp", yearlyVpp);
		_jparser.parseByNameThrow("tickets", tickets);
		_jparser.parseByNameThrow("bonuses", bonuses);
		_jparser.parseByNameThrow("exchangeRate", exchangeRate);
		_jparser.parseByNameThrow("migrationType", migrationType);
		_jparser.parseByNameThrow("bonusEligible", bonusEligible);
		_jparser.parseByNameThrow("birthDate", birthDate);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_MIGRATION_LINK_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString linkedUserId; _jparser.validateByNameThrow("linkedUserId", linkedUserId);
		AtfValidator::validateInt(_descr, "linkedUserId", linkedUserId.length(), _checker, __FILE__, __LINE__);
		PString linkedUserCity; _jparser.validateByNameThrow("linkedUserCity", linkedUserCity);
		AtfValidator::validateInt(_descr, "linkedUserCity", linkedUserCity.length(), _checker, __FILE__, __LINE__);
		INT32 cashBalance; _jparser.validateByNameThrow("cashBalance", cashBalance);
		AtfValidator::validateInt(_descr, "cashBalance", cashBalance, _checker, __FILE__, __LINE__);
		INT32 tBalance; _jparser.validateByNameThrow("tBalance", tBalance);
		AtfValidator::validateInt(_descr, "tBalance", tBalance, _checker, __FILE__, __LINE__);
		INT32 wBalance; _jparser.validateByNameThrow("wBalance", wBalance);
		AtfValidator::validateInt(_descr, "wBalance", wBalance, _checker, __FILE__, __LINE__);
		INT32 fppBalance; _jparser.validateByNameThrow("fppBalance", fppBalance);
		AtfValidator::validateInt(_descr, "fppBalance", fppBalance, _checker, __FILE__, __LINE__);
		INT32 monthlyVpp; _jparser.validateByNameThrow("monthlyVpp", monthlyVpp);
		AtfValidator::validateInt(_descr, "monthlyVpp", monthlyVpp, _checker, __FILE__, __LINE__);
		INT32 yearlyVpp; _jparser.validateByNameThrow("yearlyVpp", yearlyVpp);
		AtfValidator::validateInt(_descr, "yearlyVpp", yearlyVpp, _checker, __FILE__, __LINE__);
		INT32 tickets; _jparser.validateByNameThrow("tickets", tickets);
		AtfValidator::validateInt(_descr, "tickets", tickets, _checker, __FILE__, __LINE__);
		INT32 bonuses; _jparser.validateByNameThrow("bonuses", bonuses);
		AtfValidator::validateInt(_descr, "bonuses", bonuses, _checker, __FILE__, __LINE__);
		INT32 exchangeRate; _jparser.validateByNameThrow("exchangeRate", exchangeRate);
		AtfValidator::validateInt(_descr, "exchangeRate", exchangeRate, _checker, __FILE__, __LINE__);
		INT32 migrationType; _jparser.validateByNameThrow("migrationType", migrationType);
		AtfValidator::validateInt(_descr, "migrationType", migrationType, _checker, __FILE__, __LINE__);
		bool bonusEligible; _jparser.validateByNameThrow("bonusEligible", bonusEligible);
		AtfValidator::validateInt(_descr, "bonusEligible", bonusEligible, _checker, __FILE__, __LINE__);
		SrvDate birthDate; _jparser.validateByNameThrow("birthDate", birthDate);
		AtfValidator::validateSrvDateTime(_descr, "birthDate", birthDate, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_MIGRATION_LINK_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "linkedUserId"); size_t szLinkedUserId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "linkedUserId", szLinkedUserId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "linkedUserCity"); size_t szLinkedUserCity = strlen(_dummy);
		AtfValidator::validateInt(_descr, "linkedUserCity", szLinkedUserCity, _checker, __FILE__, __LINE__);
		INT32 cashBalance; _parser.parseINT32(cashBalance);
		AtfValidator::validateInt(_descr, "cashBalance", cashBalance, _checker, __FILE__, __LINE__);
		INT32 tBalance; _parser.parseINT32(tBalance);
		AtfValidator::validateInt(_descr, "tBalance", tBalance, _checker, __FILE__, __LINE__);
		INT32 wBalance; _parser.parseINT32(wBalance);
		AtfValidator::validateInt(_descr, "wBalance", wBalance, _checker, __FILE__, __LINE__);
		INT32 fppBalance; _parser.parseINT32(fppBalance);
		AtfValidator::validateInt(_descr, "fppBalance", fppBalance, _checker, __FILE__, __LINE__);
		INT32 monthlyVpp; _parser.parseINT32(monthlyVpp);
		AtfValidator::validateInt(_descr, "monthlyVpp", monthlyVpp, _checker, __FILE__, __LINE__);
		INT32 yearlyVpp; _parser.parseINT32(yearlyVpp);
		AtfValidator::validateInt(_descr, "yearlyVpp", yearlyVpp, _checker, __FILE__, __LINE__);
		INT32 tickets; _parser.parseINT32(tickets);
		AtfValidator::validateInt(_descr, "tickets", tickets, _checker, __FILE__, __LINE__);
		INT32 bonuses; _parser.parseINT32(bonuses);
		AtfValidator::validateInt(_descr, "bonuses", bonuses, _checker, __FILE__, __LINE__);
		INT32 exchangeRate; _parser.parseINT32(exchangeRate);
		AtfValidator::validateInt(_descr, "exchangeRate", exchangeRate, _checker, __FILE__, __LINE__);
		INT32 migrationType; _parser.parseINT32(migrationType);
		AtfValidator::validateInt(_descr, "migrationType", migrationType, _checker, __FILE__, __LINE__);
		bool bonusEligible; _parser.parseBOOL(bonusEligible);
		AtfValidator::validateInt(_descr, "bonusEligible", bonusEligible, _checker, __FILE__, __LINE__);
		SrvDate birthDate; _parser.parseSrvDate(birthDate);
		AtfValidator::validateSrvDateTime(_descr, "birthDate", birthDate, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_MIGRATION_TRANSFER
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER::Protocol_MSG_LOBBY_MIGRATION_TRANSFER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER::Protocol_MSG_LOBBY_MIGRATION_TRANSFER(Protocol_MSG_LOBBY_MIGRATION_TRANSFER&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, cashBalance(std::move(_o.cashBalance))
	, tBalance(std::move(_o.tBalance))
	, wBalance(std::move(_o.wBalance))
	, fppBalance(std::move(_o.fppBalance))
	, exchangeRate(std::move(_o.exchangeRate))
{
}

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER& Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER::operator=(Protocol_MSG_LOBBY_MIGRATION_TRANSFER&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		cashBalance = std::move(_o.cashBalance);
		tBalance = std::move(_o.tBalance);
		wBalance = std::move(_o.wBalance);
		fppBalance = std::move(_o.fppBalance);
		exchangeRate = std::move(_o.exchangeRate);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER::clear()
{
	notUsedStr.clear();
	cashBalance = 0;
	tBalance = 0;
	wBalance = 0;
	fppBalance = 0;
	exchangeRate = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER::equals(const Protocol_MSG_LOBBY_MIGRATION_TRANSFER& _o) const
{
	return Atf::atfPStringEquals(notUsedStr, _o.notUsedStr) &&
		cashBalance == _o.cashBalance &&
		tBalance == _o.tBalance &&
		wBalance == _o.wBalance &&
		fppBalance == _o.fppBalance &&
		exchangeRate == _o.exchangeRate;
}

bool Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_MIGRATION_TRANSFER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_MIGRATION_TRANSFER*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_MIGRATION_TRANSFER).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("cashBalance=");
	_buf.appendUint(cashBalance);
	_buf.append(',');
	_buf.append("tBalance=");
	_buf.appendUint(tBalance);
	_buf.append(',');
	_buf.append("wBalance=");
	_buf.appendUint(wBalance);
	_buf.append(',');
	_buf.append("fppBalance=");
	_buf.appendUint(fppBalance);
	_buf.append(',');
	_buf.append("exchangeRate=");
	_buf.appendUint(exchangeRate);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_MIGRATION_TRANSFER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsedStr", notUsedStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("cashBalance", cashBalance, _buf);
	Atf::XmlElement::encodeAsXmlElement("tBalance", tBalance, _buf);
	Atf::XmlElement::encodeAsXmlElement("wBalance", wBalance, _buf);
	Atf::XmlElement::encodeAsXmlElement("fppBalance", fppBalance, _buf);
	Atf::XmlElement::encodeAsXmlElement("exchangeRate", exchangeRate, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedStr)) return false;
			}
			else if (_element.equals("cashBalance"))
			{
				cashBalance = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tBalance"))
			{
				tBalance = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("wBalance"))
			{
				wBalance = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("fppBalance"))
			{
				fppBalance = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("exchangeRate"))
			{
				exchangeRate = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsedStr);
	_msg.composeUINT32(cashBalance);
	_msg.composeUINT32(tBalance);
	_msg.composeUINT32(wBalance);
	_msg.composeUINT32(fppBalance);
	_msg.composeUINT32(exchangeRate);
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseUINT32(cashBalance);
	_parser.parseUINT32(tBalance);
	_parser.parseUINT32(wBalance);
	_parser.parseUINT32(fppBalance);
	_parser.parseUINT32(exchangeRate);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsedStr", notUsedStr);
	_jsonstr.compose("cashBalance", cashBalance);
	_jsonstr.compose("tBalance", tBalance);
	_jsonstr.compose("wBalance", wBalance);
	_jsonstr.compose("fppBalance", fppBalance);
	_jsonstr.compose("exchangeRate", exchangeRate);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsedStr", notUsedStr);
	_jparser.parseByNameThrow("cashBalance", cashBalance);
	_jparser.parseByNameThrow("tBalance", tBalance);
	_jparser.parseByNameThrow("wBalance", wBalance);
	_jparser.parseByNameThrow("fppBalance", fppBalance);
	_jparser.parseByNameThrow("exchangeRate", exchangeRate);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_MIGRATION_TRANSFER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsedStr; _jparser.validateByNameThrow("notUsedStr", notUsedStr);
	AtfValidator::validateIntMax(_descr, "notUsedStr", notUsedStr.length(), 20, _checker, __FILE__, __LINE__);
	UINT32 cashBalance; _jparser.validateByNameThrow("cashBalance", cashBalance);
	AtfValidator::validateIntMax(_descr, "cashBalance", cashBalance, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	UINT32 tBalance; _jparser.validateByNameThrow("tBalance", tBalance);
	AtfValidator::validateIntMax(_descr, "tBalance", tBalance, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	UINT32 wBalance; _jparser.validateByNameThrow("wBalance", wBalance);
	AtfValidator::validateIntMax(_descr, "wBalance", wBalance, 0, _checker, __FILE__, __LINE__);
	UINT32 fppBalance; _jparser.validateByNameThrow("fppBalance", fppBalance);
	AtfValidator::validateIntMax(_descr, "fppBalance", fppBalance, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	UINT32 exchangeRate; _jparser.validateByNameThrow("exchangeRate", exchangeRate);
	AtfValidator::validateInt(_descr, "exchangeRate", exchangeRate, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_MIGRATION_TRANSFER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	UINT32 cashBalance; _parser.parseUINT32(cashBalance);
	AtfValidator::validateIntMax(_descr, "cashBalance", cashBalance, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	UINT32 tBalance; _parser.parseUINT32(tBalance);
	AtfValidator::validateIntMax(_descr, "tBalance", tBalance, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	UINT32 wBalance; _parser.parseUINT32(wBalance);
	AtfValidator::validateIntMax(_descr, "wBalance", wBalance, 0, _checker, __FILE__, __LINE__);
	UINT32 fppBalance; _parser.parseUINT32(fppBalance);
	AtfValidator::validateIntMax(_descr, "fppBalance", fppBalance, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	UINT32 exchangeRate; _parser.parseUINT32(exchangeRate);
	AtfValidator::validateInt(_descr, "exchangeRate", exchangeRate, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY::Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY::Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY(Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, cashAmtEuro(std::move(_o.cashAmtEuro))
	, fppAmt(std::move(_o.fppAmt))
	, linkedUserId(std::move(_o.linkedUserId))
	, city(std::move(_o.city))
{
}

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY& Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY::operator=(Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		cashAmtEuro = std::move(_o.cashAmtEuro);
		fppAmt = std::move(_o.fppAmt);
		linkedUserId = std::move(_o.linkedUserId);
		city = std::move(_o.city);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	cashAmtEuro = 0;
	fppAmt = 0;
	linkedUserId.clear();
	city.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY::equals(const Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		cashAmtEuro == _o.cashAmtEuro &&
		fppAmt == _o.fppAmt &&
		Atf::atfPStringEquals(linkedUserId, _o.linkedUserId) &&
		Atf::atfPStringEquals(city, _o.city);
}

bool Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_MIGRATION_TRANSFER_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_MIGRATION_TRANSFER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("cashAmtEuro=");
		_buf.appendInt(cashAmtEuro);
		_buf.append(',');
		_buf.append("fppAmt=");
		_buf.appendUint(fppAmt);
		_buf.append(',');
		_buf.append("linkedUserId=");
		_buf.append(linkedUserId);
		_buf.append(',');
		_buf.append("city=");
		_buf.append(city);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_MIGRATION_TRANSFER_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("cashAmtEuro", cashAmtEuro, _buf);
		Atf::XmlElement::encodeAsXmlElement("fppAmt", fppAmt, _buf);
		Atf::XmlElement::encodeAsXmlElement("linkedUserId", linkedUserId, _buf);
		Atf::XmlElement::encodeAsXmlElement("city", city, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("cashAmtEuro"))
			{
				cashAmtEuro = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("fppAmt"))
			{
				fppAmt = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("linkedUserId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, linkedUserId)) return false;
			}
			else if (_element.equals("city"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, city)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(cashAmtEuro);
		_msg.composeUINT32(fppAmt);
		_msg.composeString(linkedUserId);
		_msg.composeString(city);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(cashAmtEuro);
		_parser.parseUINT32(fppAmt);
		_parser.parseStringP(linkedUserId);
		_parser.parseStringP(city);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("cashAmtEuro", cashAmtEuro);
		_jsonstr.compose("fppAmt", fppAmt);
		_jsonstr.compose("linkedUserId", linkedUserId);
		_jsonstr.compose("city", city);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("cashAmtEuro", cashAmtEuro);
		_jparser.parseByNameThrow("fppAmt", fppAmt);
		_jparser.parseByNameThrow("linkedUserId", linkedUserId);
		_jparser.parseByNameThrow("city", city);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_MIGRATION_TRANSFER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 cashAmtEuro; _jparser.validateByNameThrow("cashAmtEuro", cashAmtEuro);
		AtfValidator::validateInt(_descr, "cashAmtEuro", cashAmtEuro, _checker, __FILE__, __LINE__);
		UINT32 fppAmt; _jparser.validateByNameThrow("fppAmt", fppAmt);
		AtfValidator::validateInt(_descr, "fppAmt", fppAmt, _checker, __FILE__, __LINE__);
		PString linkedUserId; _jparser.validateByNameThrow("linkedUserId", linkedUserId);
		AtfValidator::validateInt(_descr, "linkedUserId", linkedUserId.length(), _checker, __FILE__, __LINE__);
		PString city; _jparser.validateByNameThrow("city", city);
		AtfValidator::validateInt(_descr, "city", city.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_MIGRATION_TRANSFER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 cashAmtEuro; _parser.parseINT32(cashAmtEuro);
		AtfValidator::validateInt(_descr, "cashAmtEuro", cashAmtEuro, _checker, __FILE__, __LINE__);
		UINT32 fppAmt; _parser.parseUINT32(fppAmt);
		AtfValidator::validateInt(_descr, "fppAmt", fppAmt, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "linkedUserId"); size_t szLinkedUserId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "linkedUserId", szLinkedUserId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
		AtfValidator::validateInt(_descr, "city", szCity, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_MIGRATION_CONVERT
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT::Protocol_MSG_LOBBY_MIGRATION_CONVERT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT::Protocol_MSG_LOBBY_MIGRATION_CONVERT(Protocol_MSG_LOBBY_MIGRATION_CONVERT&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, exchangeRate(std::move(_o.exchangeRate))
{
}

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT& Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT::operator=(Protocol_MSG_LOBBY_MIGRATION_CONVERT&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		exchangeRate = std::move(_o.exchangeRate);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT::clear()
{
	notUsedStr.clear();
	exchangeRate = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT::equals(const Protocol_MSG_LOBBY_MIGRATION_CONVERT& _o) const
{
	return Atf::atfPStringEquals(notUsedStr, _o.notUsedStr) &&
		exchangeRate == _o.exchangeRate;
}

bool Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_MIGRATION_CONVERT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_MIGRATION_CONVERT*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_MIGRATION_CONVERT).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("exchangeRate=");
	_buf.appendUint(exchangeRate);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_MIGRATION_CONVERT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsedStr", notUsedStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("exchangeRate", exchangeRate, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedStr)) return false;
			}
			else if (_element.equals("exchangeRate"))
			{
				exchangeRate = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsedStr);
	_msg.composeUINT32(exchangeRate);
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseUINT32(exchangeRate);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsedStr", notUsedStr);
	_jsonstr.compose("exchangeRate", exchangeRate);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsedStr", notUsedStr);
	_jparser.parseByNameThrow("exchangeRate", exchangeRate);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_MIGRATION_CONVERT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsedStr; _jparser.validateByNameThrow("notUsedStr", notUsedStr);
	AtfValidator::validateIntMax(_descr, "notUsedStr", notUsedStr.length(), 20, _checker, __FILE__, __LINE__);
	UINT32 exchangeRate; _jparser.validateByNameThrow("exchangeRate", exchangeRate);
	AtfValidator::validateInt(_descr, "exchangeRate", exchangeRate, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_MIGRATION_CONVERT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	UINT32 exchangeRate; _parser.parseUINT32(exchangeRate);
	AtfValidator::validateInt(_descr, "exchangeRate", exchangeRate, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY::Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY::Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY(Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY& Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY::operator=(Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY::equals(const Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_MIGRATION_CONVERT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_MIGRATION_CONVERT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_MIGRATION_CONVERT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_MIGRATION_CONVERT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_MIGRATION_CONVERT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SET_PROMO_IMAGE
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE::Protocol_MSG_LOBBY_SET_PROMO_IMAGE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE::Protocol_MSG_LOBBY_SET_PROMO_IMAGE(Protocol_MSG_LOBBY_SET_PROMO_IMAGE&& _o)
	: doSet(std::move(_o.doSet))
	, promoImageCode(std::move(_o.promoImageCode))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE& Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE::operator=(Protocol_MSG_LOBBY_SET_PROMO_IMAGE&& _o)
{
	if(this != &_o)
	{
		doSet = std::move(_o.doSet);
		promoImageCode = std::move(_o.promoImageCode);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE::clear()
{
	doSet = false;
	promoImageCode.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE::equals(const Protocol_MSG_LOBBY_SET_PROMO_IMAGE& _o) const
{
	return doSet == _o.doSet &&
		Atf::atfPStringEquals(promoImageCode, _o.promoImageCode);
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_SET_PROMO_IMAGE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_SET_PROMO_IMAGE*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SET_PROMO_IMAGE).append(")");
	_buf.append(',');
	_buf.append("doSet=");
	_buf.appendUint(doSet);
	_buf.append(',');
	_buf.append("promoImageCode=");
	_buf.append(promoImageCode);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_SET_PROMO_IMAGE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("doSet", doSet, _buf);
	Atf::XmlElement::encodeAsXmlElement("promoImageCode", promoImageCode, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("doSet"))
			{
				doSet = (*_value.ptr() == '1');
			}
			else if (_element.equals("promoImageCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, promoImageCode)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(doSet);
	_msg.composeString(promoImageCode);
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(doSet);
	_parser.parseStringP(promoImageCode);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("doSet", doSet);
	_jsonstr.compose("promoImageCode", promoImageCode);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("doSet", doSet);
	_jparser.parseByNameThrow("promoImageCode", promoImageCode);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_PROMO_IMAGE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool doSet; _jparser.validateByNameThrow("doSet", doSet);
	AtfValidator::validateInt(_descr, "doSet", doSet, _checker, __FILE__, __LINE__);
	PString promoImageCode; _jparser.validateByNameThrow("promoImageCode", promoImageCode);
	AtfValidator::validateIntMax(_descr, "promoImageCode", promoImageCode.length(), 10000, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_PROMO_IMAGE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	bool doSet; _parser.parseBOOL(doSet);
	AtfValidator::validateInt(_descr, "doSet", doSet, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "promoImageCode"); size_t szPromoImageCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "promoImageCode", szPromoImageCode, 10000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY::Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY::Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY(Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY& Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY::operator=(Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY::equals(const Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_SET_PROMO_IMAGE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SET_PROMO_IMAGE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_SET_PROMO_IMAGE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_PROMO_IMAGE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_PROMO_IMAGE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_PROMO_IMAGE
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE::Protocol_MSG_LOBBY_GET_PROMO_IMAGE()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE::clear()
{
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE::equals(const Protocol_MSG_LOBBY_GET_PROMO_IMAGE& _o) const
{
	return true;
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_PROMO_IMAGE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_PROMO_IMAGE*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_PROMO_IMAGE).append(")");
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_PROMO_IMAGE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE::parseMsg(CommMsgParser& _parser)
{
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_PROMO_IMAGE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_PROMO_IMAGE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY::Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY::Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY(Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, promoImageCode(std::move(_o.promoImageCode))
{
}

Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY& Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY::operator=(Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		promoImageCode = std::move(_o.promoImageCode);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	promoImageCode.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY::equals(const Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(promoImageCode, _o.promoImageCode);
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_PROMO_IMAGE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_PROMO_IMAGE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("promoImageCode=");
		_buf.append(promoImageCode);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_PROMO_IMAGE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("promoImageCode", promoImageCode, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("promoImageCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, promoImageCode)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(promoImageCode);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(promoImageCode);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("promoImageCode", promoImageCode);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("promoImageCode", promoImageCode);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_PROMO_IMAGE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString promoImageCode; _jparser.validateByNameThrow("promoImageCode", promoImageCode);
		AtfValidator::validateInt(_descr, "promoImageCode", promoImageCode.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_PROMO_IMAGE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "promoImageCode"); size_t szPromoImageCode = strlen(_dummy);
		AtfValidator::validateInt(_descr, "promoImageCode", szPromoImageCode, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FR_AVC_VALIDATE
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE::Protocol_MSG_LOBBY_FR_AVC_VALIDATE()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE::clear()
{
	avc = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE::equals(const Protocol_MSG_LOBBY_FR_AVC_VALIDATE& _o) const
{
	return avc == _o.avc;
}

bool Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_FR_AVC_VALIDATE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_FR_AVC_VALIDATE*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FR_AVC_VALIDATE).append(")");
	_buf.append(',');
	_buf.append("avc=");
	_buf.appendUint(avc);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_FR_AVC_VALIDATE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("avc", avc, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("avc"))
			{
				avc = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(avc);
}

void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(avc);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("avc", avc);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("avc", avc);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FR_AVC_VALIDATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 avc; _jparser.validateByNameThrow("avc", avc);
	AtfValidator::validateInt(_descr, "avc", avc, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FR_AVC_VALIDATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 avc; _parser.parseUINT32(avc);
	AtfValidator::validateInt(_descr, "avc", avc, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY::Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY::Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY(Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, fullyValidated(std::move(_o.fullyValidated))
	, is1stTime(std::move(_o.is1stTime))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY& Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY::operator=(Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		fullyValidated = std::move(_o.fullyValidated);
		is1stTime = std::move(_o.is1stTime);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	fullyValidated = false;
	is1stTime = false;
}

bool Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY::equals(const Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		fullyValidated == _o.fullyValidated &&
		is1stTime == _o.is1stTime;
}

bool Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_FR_AVC_VALIDATE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FR_AVC_VALIDATE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("fullyValidated=");
		_buf.appendUint(fullyValidated);
		_buf.append(',');
		_buf.append("is1stTime=");
		_buf.appendUint(is1stTime);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_FR_AVC_VALIDATE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("fullyValidated", fullyValidated, _buf);
		Atf::XmlElement::encodeAsXmlElement("is1stTime", is1stTime, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("fullyValidated"))
			{
				fullyValidated = (*_value.ptr() == '1');
			}
			else if (_element.equals("is1stTime"))
			{
				is1stTime = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeBOOL(fullyValidated);
		_msg.composeBOOL(is1stTime);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseBOOL(fullyValidated);
		_parser.parseBOOL(is1stTime);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("fullyValidated", fullyValidated);
		_jsonstr.compose("is1stTime", is1stTime);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("fullyValidated", fullyValidated);
		_jparser.parseByNameThrow("is1stTime", is1stTime);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FR_AVC_VALIDATE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		bool fullyValidated; _jparser.validateByNameThrow("fullyValidated", fullyValidated);
		AtfValidator::validateInt(_descr, "fullyValidated", fullyValidated, _checker, __FILE__, __LINE__);
		bool is1stTime; _jparser.validateByNameThrow("is1stTime", is1stTime);
		AtfValidator::validateInt(_descr, "is1stTime", is1stTime, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FR_AVC_VALIDATE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool fullyValidated; _parser.parseBOOL(fullyValidated);
		AtfValidator::validateInt(_descr, "fullyValidated", fullyValidated, _checker, __FILE__, __LINE__);
		bool is1stTime; _parser.parseBOOL(is1stTime);
		AtfValidator::validateInt(_descr, "is1stTime", is1stTime, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FR_AVC_RESEND
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND::Protocol_MSG_LOBBY_FR_AVC_RESEND()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND::clear()
{
}

bool Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND::equals(const Protocol_MSG_LOBBY_FR_AVC_RESEND& _o) const
{
	return true;
}

bool Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_FR_AVC_RESEND != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_FR_AVC_RESEND*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FR_AVC_RESEND).append(")");
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_FR_AVC_RESEND).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND::parseMsg(CommMsgParser& _parser)
{
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FR_AVC_RESEND";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FR_AVC_RESEND";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY::Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY::Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY(Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY& Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY::operator=(Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY::equals(const Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_FR_AVC_RESEND_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FR_AVC_RESEND_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_FR_AVC_RESEND_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FR_AVC_RESEND_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FR_AVC_RESEND_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP::Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP::Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP(Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, setPriv(std::move(_o.setPriv))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP& Lobby::cli::Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP::operator=(Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		setPriv = std::move(_o.setPriv);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP::clear()
{
	notUsedStr.clear();
	setPriv = false;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP::equals(const Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP& _o) const
{
	return Atf::atfPStringEquals(notUsedStr, _o.notUsedStr) &&
		setPriv == _o.setPriv;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("setPriv=");
	_buf.appendUint(setPriv);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsedStr", notUsedStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("setPriv", setPriv, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedStr)) return false;
			}
			else if (_element.equals("setPriv"))
			{
				setPriv = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsedStr);
	_msg.composeBOOL(setPriv);
}

void Lobby::cli::Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseBOOL(setPriv);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsedStr", notUsedStr);
	_jsonstr.compose("setPriv", setPriv);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsedStr", notUsedStr);
	_jparser.parseByNameThrow("setPriv", setPriv);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsedStr; _jparser.validateByNameThrow("notUsedStr", notUsedStr);
	AtfValidator::validateIntMax(_descr, "notUsedStr", notUsedStr.length(), 20, _checker, __FILE__, __LINE__);
	bool setPriv; _jparser.validateByNameThrow("setPriv", setPriv);
	AtfValidator::validateInt(_descr, "setPriv", setPriv, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	bool setPriv; _parser.parseBOOL(setPriv);
	AtfValidator::validateInt(_descr, "setPriv", setPriv, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CANCEL_RESERVED_SEAT
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_CANCEL_RESERVED_SEAT::Protocol_MSG_LOBBY_CANCEL_RESERVED_SEAT()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_CANCEL_RESERVED_SEAT::clear()
{
	tableId32 = 0;
	seat = 0;
	tableId = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_CANCEL_RESERVED_SEAT::equals(const Protocol_MSG_LOBBY_CANCEL_RESERVED_SEAT& _o) const
{
	return tableId32 == _o.tableId32 &&
		seat == _o.seat &&
		tableId == _o.tableId;
}

bool Lobby::cli::Protocol_MSG_LOBBY_CANCEL_RESERVED_SEAT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_CANCEL_RESERVED_SEAT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_CANCEL_RESERVED_SEAT*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CANCEL_RESERVED_SEAT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CANCEL_RESERVED_SEAT).append(")");
	_buf.append(',');
	_buf.append("tableId32=");
	_buf.appendUint(tableId32);
	_buf.append(',');
	_buf.append("seat=");
	_buf.appendUint(seat);
	_buf.append(',');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CANCEL_RESERVED_SEAT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CANCEL_RESERVED_SEAT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_CANCEL_RESERVED_SEAT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("tableId32", tableId32, _buf);
	Atf::XmlElement::encodeAsXmlElement("seat", seat, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableId", tableId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_CANCEL_RESERVED_SEAT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tableId32"))
			{
				tableId32 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("seat"))
			{
				seat = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tableId"))
			{
				tableId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_CANCEL_RESERVED_SEAT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(tableId32);
	_msg.composeBYTE(seat);
	_msg.composeUINT64(tableId);
}

void Lobby::cli::Protocol_MSG_LOBBY_CANCEL_RESERVED_SEAT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tableId32);
	_parser.parseBYTE(seat);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(tableId);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CANCEL_RESERVED_SEAT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tableId32", tableId32);
	_jsonstr.compose("seat", seat);
	_jsonstr.compose("tableId", tableId);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_CANCEL_RESERVED_SEAT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tableId32", tableId32);
	_jparser.parseByNameThrow("seat", seat);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tableId", tableId);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CANCEL_RESERVED_SEAT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CANCEL_RESERVED_SEAT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tableId32; _jparser.validateByNameThrow("tableId32", tableId32);
	AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
	BYTE seat; _jparser.validateByNameThrow("seat", seat);
	AtfValidator::validateIntMax(_descr, "seat", seat, 10, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT64 tableId; _jparser.validateByNameThrow("tableId", tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CANCEL_RESERVED_SEAT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CANCEL_RESERVED_SEAT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 tableId32; _parser.parseUINT32(tableId32);
	AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
	BYTE seat; _parser.parseBYTE(seat);
	AtfValidator::validateIntMax(_descr, "seat", seat, 10, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 tableId; _parser.parseUINT64(tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE::clear()
{
	tableId32 = 0;
	minPlayers = 0;
	clientReqId = 0;
	searchFlags = 0;
	currTableId = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE::equals(const Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE& _o) const
{
	return tableId32 == _o.tableId32 &&
		minPlayers == _o.minPlayers &&
		clientReqId == _o.clientReqId &&
		searchFlags == _o.searchFlags &&
		currTableId == _o.currTableId;
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_FIND_SIMILAR_TABLE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_SIMILAR_TABLE).append(")");
	_buf.append(',');
	_buf.append("tableId32=");
	_buf.appendUint(tableId32);
	_buf.append(',');
	_buf.append("minPlayers=");
	_buf.appendUint(minPlayers);
	_buf.append(',');
	_buf.append("clientReqId=");
	_buf.appendUint(clientReqId);
	_buf.append(',');
	_buf.append("searchFlags=");
	_buf.appendUint(searchFlags);
	_buf.append(',');
	_buf.append("currTableId=");
	_buf.appendUint64(currTableId);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_FIND_SIMILAR_TABLE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("tableId32", tableId32, _buf);
	Atf::XmlElement::encodeAsXmlElement("minPlayers", minPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientReqId", clientReqId, _buf);
	Atf::XmlElement::encodeAsXmlElement("searchFlags", searchFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("currTableId", currTableId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tableId32"))
			{
				tableId32 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minPlayers"))
			{
				minPlayers = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientReqId"))
			{
				clientReqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("searchFlags"))
			{
				searchFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currTableId"))
			{
				currTableId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(tableId32);
	_msg.composeBYTE(minPlayers);
	_msg.composeUINT32(clientReqId);
	_msg.composeUINT32(searchFlags);
	_msg.composeUINT64(currTableId);
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tableId32);
	_parser.parseBYTE(minPlayers);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(clientReqId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(searchFlags);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(currTableId);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tableId32", tableId32);
	_jsonstr.compose("minPlayers", minPlayers);
	_jsonstr.compose("clientReqId", clientReqId);
	_jsonstr.compose("searchFlags", searchFlags);
	_jsonstr.compose("currTableId", currTableId);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tableId32", tableId32);
	_jparser.parseByNameThrow("minPlayers", minPlayers);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("clientReqId", clientReqId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("searchFlags", searchFlags);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("currTableId", currTableId);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_SIMILAR_TABLE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tableId32; _jparser.validateByNameThrow("tableId32", tableId32);
	AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
	BYTE minPlayers; _jparser.validateByNameThrow("minPlayers", minPlayers);
	AtfValidator::validateIntMax(_descr, "minPlayers", minPlayers, 10, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 clientReqId; _jparser.validateByNameThrow("clientReqId", clientReqId);
	AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 searchFlags; _jparser.validateByNameThrow("searchFlags", searchFlags);
	AtfValidator::validateIntRange(_descr, "searchFlags", searchFlags, eSeatManFlags_None, eSeatManFlags_Last, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT64 currTableId; _jparser.validateByNameThrow("currTableId", currTableId);
	AtfValidator::validateUint(_descr, "currTableId", currTableId, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_SIMILAR_TABLE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 tableId32; _parser.parseUINT32(tableId32);
	AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
	BYTE minPlayers; _parser.parseBYTE(minPlayers);
	AtfValidator::validateIntMax(_descr, "minPlayers", minPlayers, 10, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 clientReqId; _parser.parseUINT32(clientReqId);
	AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 searchFlags; _parser.parseUINT32(searchFlags);
	AtfValidator::validateIntRange(_descr, "searchFlags", searchFlags, eSeatManFlags_None, eSeatManFlags_Last, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 currTableId; _parser.parseUINT64(currTableId);
	AtfValidator::validateUint(_descr, "currTableId", currTableId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY(Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, clientReqId(std::move(_o.clientReqId))
	, searchFlags(std::move(_o.searchFlags))
	, server(std::move(_o.server))
	, tableId(std::move(_o.tableId))
	, seat(std::move(_o.seat))
	, useDecrSearch(std::move(_o.useDecrSearch))
	, numOfPlayersInDecrSearchTable(std::move(_o.numOfPlayersInDecrSearchTable))
	, waitingForSeatReservationTimeout(std::move(_o.waitingForSeatReservationTimeout))
	, isThereDealing(std::move(_o.isThereDealing))
	, tableId64(std::move(_o.tableId64))
	, serverObject(std::move(_o.serverObject))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY& Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY::operator=(Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		clientReqId = std::move(_o.clientReqId);
		searchFlags = std::move(_o.searchFlags);
		server = std::move(_o.server);
		tableId = std::move(_o.tableId);
		seat = std::move(_o.seat);
		useDecrSearch = std::move(_o.useDecrSearch);
		numOfPlayersInDecrSearchTable = std::move(_o.numOfPlayersInDecrSearchTable);
		waitingForSeatReservationTimeout = std::move(_o.waitingForSeatReservationTimeout);
		isThereDealing = std::move(_o.isThereDealing);
		tableId64 = std::move(_o.tableId64);
		serverObject = std::move(_o.serverObject);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	clientReqId = 0;
	searchFlags = 0;
	server.clear();
	tableId = 0;
	seat = 0;
	useDecrSearch = 0;
	numOfPlayersInDecrSearchTable = 0;
	waitingForSeatReservationTimeout = 0;
	isThereDealing = false;
	tableId64 = 0;
	serverObject.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY::equals(const Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		clientReqId == _o.clientReqId &&
		searchFlags == _o.searchFlags &&
		Atf::atfPStringEquals(server, _o.server) &&
		tableId == _o.tableId &&
		seat == _o.seat &&
		useDecrSearch == _o.useDecrSearch &&
		numOfPlayersInDecrSearchTable == _o.numOfPlayersInDecrSearchTable &&
		waitingForSeatReservationTimeout == _o.waitingForSeatReservationTimeout &&
		isThereDealing == _o.isThereDealing &&
		tableId64 == _o.tableId64 &&
		Atf::atfPStringEquals(serverObject, _o.serverObject);
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
		_buf.append(',');
		_buf.append("clientReqId=");
		_buf.appendUint(clientReqId);
		_buf.append(',');
		_buf.append("searchFlags=");
		_buf.appendUint(searchFlags);
	}
	else
	{
		_buf.append(',');
		_buf.append("server=");
		_buf.append(server);
		_buf.append(',');
		_buf.append("tableId=");
		_buf.appendUint(tableId);
		_buf.append(',');
		_buf.append("seat=");
		_buf.appendUint(seat);
		_buf.append(',');
		_buf.append("clientReqId=");
		_buf.appendUint(clientReqId);
		_buf.append(',');
		_buf.append("useDecrSearch=");
		_buf.appendUint(useDecrSearch);
		_buf.append(',');
		_buf.append("numOfPlayersInDecrSearchTable=");
		_buf.appendUint(numOfPlayersInDecrSearchTable);
		_buf.append(',');
		_buf.append("waitingForSeatReservationTimeout=");
		_buf.appendUint(waitingForSeatReservationTimeout);
		_buf.append(',');
		_buf.append("isThereDealing=");
		_buf.appendUint(isThereDealing);
		_buf.append(',');
		_buf.append("tableId64=");
		_buf.appendUint64(tableId64);
		_buf.append(',');
		_buf.append("serverObject=");
		_buf.append(serverObject);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
		Atf::XmlElement::encodeAsXmlElement("clientReqId", clientReqId, _buf);
		Atf::XmlElement::encodeAsXmlElement("searchFlags", searchFlags, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("server", server, _buf);
		Atf::XmlElement::encodeAsXmlElement("tableId", tableId, _buf);
		Atf::XmlElement::encodeAsXmlElement("seat", seat, _buf);
		Atf::XmlElement::encodeAsXmlElement("clientReqId", clientReqId, _buf);
		Atf::XmlElement::encodeAsXmlElement("useDecrSearch", useDecrSearch, _buf);
		Atf::XmlElement::encodeAsXmlElement("numOfPlayersInDecrSearchTable", numOfPlayersInDecrSearchTable, _buf);
		Atf::XmlElement::encodeAsXmlElement("waitingForSeatReservationTimeout", waitingForSeatReservationTimeout, _buf);
		Atf::XmlElement::encodeAsXmlElement("isThereDealing", isThereDealing, _buf);
		Atf::XmlElement::encodeAsXmlElement("tableId64", tableId64, _buf);
		Atf::XmlElement::encodeAsXmlElement("serverObject", serverObject, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("clientReqId"))
			{
				clientReqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("searchFlags"))
			{
				searchFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("server"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, server)) return false;
			}
			else if (_element.equals("tableId"))
			{
				tableId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("seat"))
			{
				seat = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("useDecrSearch"))
			{
				useDecrSearch = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("numOfPlayersInDecrSearchTable"))
			{
				numOfPlayersInDecrSearchTable = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("waitingForSeatReservationTimeout"))
			{
				waitingForSeatReservationTimeout = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isThereDealing"))
			{
				isThereDealing = (*_value.ptr() == '1');
			}
			else if (_element.equals("tableId64"))
			{
				tableId64 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("serverObject"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, serverObject)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
		_msg.composeUINT32(clientReqId);
		_msg.composeUINT32(searchFlags);
	}
	else
	{
		_msg.composeString(server);
		_msg.composeUINT32(tableId);
		_msg.composeBYTE(seat);
		_msg.composeUINT32(clientReqId);
		_msg.composeUINT32(useDecrSearch);
		_msg.composeBYTE(numOfPlayersInDecrSearchTable);
		_msg.composeUINT16(waitingForSeatReservationTimeout);
		_msg.composeBOOL(isThereDealing);
		_msg.composeUINT64(tableId64);
		_msg.composeString(serverObject);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
		_parser.parseUINT32(clientReqId);
		_parser.parseUINT32(searchFlags);
	}
	else
	{
		_parser.parseStringP(server);
		_parser.parseUINT32(tableId);
		_parser.parseBYTE(seat);
		_parser.parseUINT32(clientReqId);
		_parser.parseUINT32(useDecrSearch);
		_parser.parseBYTE(numOfPlayersInDecrSearchTable);
		_parser.parseUINT16(waitingForSeatReservationTimeout);
		_parser.parseBOOL(isThereDealing);
		_parser.parseUINT64(tableId64);
		_parser.parseStringP(serverObject);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
		_jsonstr.compose("clientReqId", clientReqId);
		_jsonstr.compose("searchFlags", searchFlags);
	}
	else
	{
		_jsonstr.compose("server", server);
		_jsonstr.compose("tableId", tableId);
		_jsonstr.compose("seat", seat);
		_jsonstr.compose("clientReqId", clientReqId);
		_jsonstr.compose("useDecrSearch", useDecrSearch);
		_jsonstr.compose("numOfPlayersInDecrSearchTable", numOfPlayersInDecrSearchTable);
		_jsonstr.compose("waitingForSeatReservationTimeout", waitingForSeatReservationTimeout);
		_jsonstr.compose("isThereDealing", isThereDealing);
		_jsonstr.compose("tableId64", tableId64);
		_jsonstr.compose("serverObject", serverObject);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
		_jparser.parseByNameThrow("clientReqId", clientReqId);
		_jparser.parseByNameThrow("searchFlags", searchFlags);
	}
	else
	{
		_jparser.parseByNameThrow("server", server);
		_jparser.parseByNameThrow("tableId", tableId);
		_jparser.parseByNameThrow("seat", seat);
		_jparser.parseByNameThrow("clientReqId", clientReqId);
		_jparser.parseByNameThrow("useDecrSearch", useDecrSearch);
		_jparser.parseByNameThrow("numOfPlayersInDecrSearchTable", numOfPlayersInDecrSearchTable);
		_jparser.parseByNameThrow("waitingForSeatReservationTimeout", waitingForSeatReservationTimeout);
		_jparser.parseByNameThrow("isThereDealing", isThereDealing);
		_jparser.parseByNameThrow("tableId64", tableId64);
		_jparser.parseByNameThrow("serverObject", serverObject);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
		UINT32 clientReqId; _jparser.validateByNameThrow("clientReqId", clientReqId);
		AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
		UINT32 searchFlags; _jparser.validateByNameThrow("searchFlags", searchFlags);
		AtfValidator::validateInt(_descr, "searchFlags", searchFlags, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString server; _jparser.validateByNameThrow("server", server);
		AtfValidator::validateInt(_descr, "server", server.length(), _checker, __FILE__, __LINE__);
		UINT32 tableId; _jparser.validateByNameThrow("tableId", tableId);
		AtfValidator::validateInt(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
		BYTE seat; _jparser.validateByNameThrow("seat", seat);
		AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
		UINT32 clientReqId; _jparser.validateByNameThrow("clientReqId", clientReqId);
		AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
		UINT32 useDecrSearch; _jparser.validateByNameThrow("useDecrSearch", useDecrSearch);
		AtfValidator::validateInt(_descr, "useDecrSearch", useDecrSearch, _checker, __FILE__, __LINE__);
		BYTE numOfPlayersInDecrSearchTable; _jparser.validateByNameThrow("numOfPlayersInDecrSearchTable", numOfPlayersInDecrSearchTable);
		AtfValidator::validateInt(_descr, "numOfPlayersInDecrSearchTable", numOfPlayersInDecrSearchTable, _checker, __FILE__, __LINE__);
		UINT16 waitingForSeatReservationTimeout; _jparser.validateByNameThrow("waitingForSeatReservationTimeout", waitingForSeatReservationTimeout);
		AtfValidator::validateInt(_descr, "waitingForSeatReservationTimeout", waitingForSeatReservationTimeout, _checker, __FILE__, __LINE__);
		bool isThereDealing; _jparser.validateByNameThrow("isThereDealing", isThereDealing);
		AtfValidator::validateInt(_descr, "isThereDealing", isThereDealing, _checker, __FILE__, __LINE__);
		UINT64 tableId64; _jparser.validateByNameThrow("tableId64", tableId64);
		AtfValidator::validateUint(_descr, "tableId64", tableId64, _checker, __FILE__, __LINE__);
		PString serverObject; _jparser.validateByNameThrow("serverObject", serverObject);
		AtfValidator::validateInt(_descr, "serverObject", serverObject.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
		UINT32 clientReqId; _parser.parseUINT32(clientReqId);
		AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
		UINT32 searchFlags; _parser.parseUINT32(searchFlags);
		AtfValidator::validateInt(_descr, "searchFlags", searchFlags, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
		UINT32 tableId; _parser.parseUINT32(tableId);
		AtfValidator::validateInt(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
		BYTE seat; _parser.parseBYTE(seat);
		AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
		UINT32 clientReqId; _parser.parseUINT32(clientReqId);
		AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
		UINT32 useDecrSearch; _parser.parseUINT32(useDecrSearch);
		AtfValidator::validateInt(_descr, "useDecrSearch", useDecrSearch, _checker, __FILE__, __LINE__);
		BYTE numOfPlayersInDecrSearchTable; _parser.parseBYTE(numOfPlayersInDecrSearchTable);
		AtfValidator::validateInt(_descr, "numOfPlayersInDecrSearchTable", numOfPlayersInDecrSearchTable, _checker, __FILE__, __LINE__);
		UINT16 waitingForSeatReservationTimeout; _parser.parseUINT16(waitingForSeatReservationTimeout);
		AtfValidator::validateInt(_descr, "waitingForSeatReservationTimeout", waitingForSeatReservationTimeout, _checker, __FILE__, __LINE__);
		bool isThereDealing; _parser.parseBOOL(isThereDealing);
		AtfValidator::validateInt(_descr, "isThereDealing", isThereDealing, _checker, __FILE__, __LINE__);
		UINT64 tableId64; _parser.parseUINT64(tableId64);
		AtfValidator::validateUint(_descr, "tableId64", tableId64, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "serverObject"); size_t szServerObject = strlen(_dummy);
		AtfValidator::validateInt(_descr, "serverObject", szServerObject, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_STOP
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_STOP::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_STOP()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_STOP::clear()
{
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_STOP::equals(const Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_STOP& _o) const
{
	return true;
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_STOP::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_FIND_SIMILAR_TABLE_STOP != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_STOP*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_STOP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_SIMILAR_TABLE_STOP).append(")");
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_STOP::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_STOP::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_FIND_SIMILAR_TABLE_STOP).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_STOP::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_STOP::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_STOP::parseMsg(CommMsgParser& _parser)
{
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_STOP::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_STOP::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_STOP::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_SIMILAR_TABLE_STOP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_STOP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_SIMILAR_TABLE_STOP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE::clear()
{
	typeId = 0;
	minPlayers = 0;
	clientReqId = 0;
	searchFlags = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE::equals(const Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE& _o) const
{
	return typeId == _o.typeId &&
		minPlayers == _o.minPlayers &&
		clientReqId == _o.clientReqId &&
		searchFlags == _o.searchFlags;
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE).append(")");
	_buf.append(',');
	_buf.append("typeId=");
	_buf.appendUint(typeId);
	_buf.append(',');
	_buf.append("minPlayers=");
	_buf.appendUint(minPlayers);
	_buf.append(',');
	_buf.append("clientReqId=");
	_buf.appendUint(clientReqId);
	_buf.append(',');
	_buf.append("searchFlags=");
	_buf.appendUint(searchFlags);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("typeId", typeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("minPlayers", minPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientReqId", clientReqId, _buf);
	Atf::XmlElement::encodeAsXmlElement("searchFlags", searchFlags, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("typeId"))
			{
				typeId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minPlayers"))
			{
				minPlayers = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientReqId"))
			{
				clientReqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("searchFlags"))
			{
				searchFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(typeId);
	_msg.composeBYTE(minPlayers);
	_msg.composeUINT32(clientReqId);
	_msg.composeUINT32(searchFlags);
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(typeId);
	_parser.parseBYTE(minPlayers);
	_parser.parseUINT32(clientReqId);
	_parser.parseUINT32(searchFlags);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("typeId", typeId);
	_jsonstr.compose("minPlayers", minPlayers);
	_jsonstr.compose("clientReqId", clientReqId);
	_jsonstr.compose("searchFlags", searchFlags);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("typeId", typeId);
	_jparser.parseByNameThrow("minPlayers", minPlayers);
	_jparser.parseByNameThrow("clientReqId", clientReqId);
	_jparser.parseByNameThrow("searchFlags", searchFlags);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 typeId; _jparser.validateByNameThrow("typeId", typeId);
	AtfValidator::validateInt(_descr, "typeId", typeId, _checker, __FILE__, __LINE__);
	BYTE minPlayers; _jparser.validateByNameThrow("minPlayers", minPlayers);
	AtfValidator::validateIntMax(_descr, "minPlayers", minPlayers, 10, _checker, __FILE__, __LINE__);
	UINT32 clientReqId; _jparser.validateByNameThrow("clientReqId", clientReqId);
	AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
	UINT32 searchFlags; _jparser.validateByNameThrow("searchFlags", searchFlags);
	AtfValidator::validateIntRange(_descr, "searchFlags", searchFlags, eSeatManFlags_None, eSeatManFlags_Last, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 typeId; _parser.parseUINT32(typeId);
	AtfValidator::validateInt(_descr, "typeId", typeId, _checker, __FILE__, __LINE__);
	BYTE minPlayers; _parser.parseBYTE(minPlayers);
	AtfValidator::validateIntMax(_descr, "minPlayers", minPlayers, 10, _checker, __FILE__, __LINE__);
	UINT32 clientReqId; _parser.parseUINT32(clientReqId);
	AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
	UINT32 searchFlags; _parser.parseUINT32(searchFlags);
	AtfValidator::validateIntRange(_descr, "searchFlags", searchFlags, eSeatManFlags_None, eSeatManFlags_Last, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::clear()
{
	typeId = 0;
	clientReqId = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::equals(const Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE& _o) const
{
	return typeId == _o.typeId &&
		clientReqId == _o.clientReqId;
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_FIND_TABLE_TO_OBSERVE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_TABLE_TO_OBSERVE).append(")");
	_buf.append(',');
	_buf.append("typeId=");
	_buf.appendUint(typeId);
	_buf.append(',');
	_buf.append("clientReqId=");
	_buf.appendUint(clientReqId);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_FIND_TABLE_TO_OBSERVE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("typeId", typeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientReqId", clientReqId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("typeId"))
			{
				typeId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientReqId"))
			{
				clientReqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(typeId);
	_msg.composeUINT32(clientReqId);
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(typeId);
	_parser.parseUINT32(clientReqId);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("typeId", typeId);
	_jsonstr.compose("clientReqId", clientReqId);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("typeId", typeId);
	_jparser.parseByNameThrow("clientReqId", clientReqId);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TABLE_TO_OBSERVE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 typeId; _jparser.validateByNameThrow("typeId", typeId);
	AtfValidator::validateInt(_descr, "typeId", typeId, _checker, __FILE__, __LINE__);
	UINT32 clientReqId; _jparser.validateByNameThrow("clientReqId", clientReqId);
	AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TABLE_TO_OBSERVE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 typeId; _parser.parseUINT32(typeId);
	AtfValidator::validateInt(_descr, "typeId", typeId, _checker, __FILE__, __LINE__);
	UINT32 clientReqId; _parser.parseUINT32(clientReqId);
	AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY(Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, clientReqId(std::move(_o.clientReqId))
	, server(std::move(_o.server))
	, tableId(std::move(_o.tableId))
	, tableId64(std::move(_o.tableId64))
	, serverObject(std::move(_o.serverObject))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY& Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::operator=(Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		clientReqId = std::move(_o.clientReqId);
		server = std::move(_o.server);
		tableId = std::move(_o.tableId);
		tableId64 = std::move(_o.tableId64);
		serverObject = std::move(_o.serverObject);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	clientReqId = 0;
	server.clear();
	tableId = 0;
	tableId64 = 0;
	serverObject.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::equals(const Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		clientReqId == _o.clientReqId &&
		Atf::atfPStringEquals(server, _o.server) &&
		tableId == _o.tableId &&
		tableId64 == _o.tableId64 &&
		Atf::atfPStringEquals(serverObject, _o.serverObject);
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
		_buf.append(',');
		_buf.append("clientReqId=");
		_buf.appendUint(clientReqId);
	}
	else
	{
		_buf.append(',');
		_buf.append("server=");
		_buf.append(server);
		_buf.append(',');
		_buf.append("tableId=");
		_buf.appendUint(tableId);
		_buf.append(',');
		_buf.append("clientReqId=");
		_buf.appendUint(clientReqId);
		_buf.append(',');
		_buf.append("tableId64=");
		_buf.appendUint64(tableId64);
		_buf.append(',');
		_buf.append("serverObject=");
		_buf.append(serverObject);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
		Atf::XmlElement::encodeAsXmlElement("clientReqId", clientReqId, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("server", server, _buf);
		Atf::XmlElement::encodeAsXmlElement("tableId", tableId, _buf);
		Atf::XmlElement::encodeAsXmlElement("clientReqId", clientReqId, _buf);
		Atf::XmlElement::encodeAsXmlElement("tableId64", tableId64, _buf);
		Atf::XmlElement::encodeAsXmlElement("serverObject", serverObject, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("clientReqId"))
			{
				clientReqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("server"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, server)) return false;
			}
			else if (_element.equals("tableId"))
			{
				tableId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tableId64"))
			{
				tableId64 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("serverObject"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, serverObject)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
		_msg.composeUINT32(clientReqId);
	}
	else
	{
		_msg.composeString(server);
		_msg.composeUINT32(tableId);
		_msg.composeUINT32(clientReqId);
		_msg.composeUINT64(tableId64);
		_msg.composeString(serverObject);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
		_parser.parseUINT32(clientReqId);
	}
	else
	{
		_parser.parseStringP(server);
		_parser.parseUINT32(tableId);
		_parser.parseUINT32(clientReqId);
		_parser.parseUINT64(tableId64);
		_parser.parseStringP(serverObject);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
		_jsonstr.compose("clientReqId", clientReqId);
	}
	else
	{
		_jsonstr.compose("server", server);
		_jsonstr.compose("tableId", tableId);
		_jsonstr.compose("clientReqId", clientReqId);
		_jsonstr.compose("tableId64", tableId64);
		_jsonstr.compose("serverObject", serverObject);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
		_jparser.parseByNameThrow("clientReqId", clientReqId);
	}
	else
	{
		_jparser.parseByNameThrow("server", server);
		_jparser.parseByNameThrow("tableId", tableId);
		_jparser.parseByNameThrow("clientReqId", clientReqId);
		_jparser.parseByNameThrow("tableId64", tableId64);
		_jparser.parseByNameThrow("serverObject", serverObject);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
		UINT32 clientReqId; _jparser.validateByNameThrow("clientReqId", clientReqId);
		AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString server; _jparser.validateByNameThrow("server", server);
		AtfValidator::validateInt(_descr, "server", server.length(), _checker, __FILE__, __LINE__);
		UINT32 tableId; _jparser.validateByNameThrow("tableId", tableId);
		AtfValidator::validateInt(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
		UINT32 clientReqId; _jparser.validateByNameThrow("clientReqId", clientReqId);
		AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
		UINT64 tableId64; _jparser.validateByNameThrow("tableId64", tableId64);
		AtfValidator::validateUint(_descr, "tableId64", tableId64, _checker, __FILE__, __LINE__);
		PString serverObject; _jparser.validateByNameThrow("serverObject", serverObject);
		AtfValidator::validateInt(_descr, "serverObject", serverObject.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
		UINT32 clientReqId; _parser.parseUINT32(clientReqId);
		AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
		UINT32 tableId; _parser.parseUINT32(tableId);
		AtfValidator::validateInt(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
		UINT32 clientReqId; _parser.parseUINT32(clientReqId);
		AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
		UINT64 tableId64; _parser.parseUINT64(tableId64);
		AtfValidator::validateUint(_descr, "tableId64", tableId64, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "serverObject"); size_t szServerObject = strlen(_dummy);
		AtfValidator::validateInt(_descr, "serverObject", szServerObject, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    BuyInRange
//=================================================================

Lobby::cli::BuyInRange::BuyInRange()
{
	clear();
}

void Lobby::cli::BuyInRange::clear()
{
	bottomMin = 0;
	topMin = 0;
	bottomMax = 0;
	topMax = 0;
}

bool Lobby::cli::BuyInRange::equals(const BuyInRange& _o) const
{
	return bottomMin == _o.bottomMin &&
		topMin == _o.topMin &&
		bottomMax == _o.bottomMax &&
		topMax == _o.topMax;
}

const char *Lobby::cli::BuyInRange::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("bottomMin=");
	_buf.appendUint(bottomMin);
	_buf.append(',');
	_buf.append("topMin=");
	_buf.appendUint(topMin);
	_buf.append(',');
	_buf.append("bottomMax=");
	_buf.appendUint(bottomMax);
	_buf.append(',');
	_buf.append("topMax=");
	_buf.appendUint(topMax);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::BuyInRange::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("bottomMin", bottomMin, _buf);
	Atf::XmlElement::encodeAsXmlElement("topMin", topMin, _buf);
	Atf::XmlElement::encodeAsXmlElement("bottomMax", bottomMax, _buf);
	Atf::XmlElement::encodeAsXmlElement("topMax", topMax, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::BuyInRange::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("bottomMin"))
		{
			bottomMin = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("topMin"))
		{
			topMin = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("bottomMax"))
		{
			bottomMax = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("topMax"))
		{
			topMax = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::BuyInRange::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT16(bottomMin);
	_msg.composeUINT16(topMin);
	_msg.composeUINT16(bottomMax);
	_msg.composeUINT16(topMax);
}

void Lobby::cli::BuyInRange::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT16(bottomMin);
	_parser.parseUINT16(topMin);
	_parser.parseUINT16(bottomMax);
	_parser.parseUINT16(topMax);
}

const char *Lobby::cli::BuyInRange::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("bottomMin", bottomMin);
	_jsonstr.compose("topMin", topMin);
	_jsonstr.compose("bottomMax", bottomMax);
	_jsonstr.compose("topMax", topMax);
	return _buf.c_str();
}

void Lobby::cli::BuyInRange::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("bottomMin", bottomMin);
	_jparser.parseByNameThrow("topMin", topMin);
	_jparser.parseByNameThrow("bottomMax", bottomMax);
	_jparser.parseByNameThrow("topMax", topMax);
}

/* static */ void Lobby::cli::BuyInRange::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT16 bottomMin; _jparser.validateByNameThrow("bottomMin", bottomMin);
	AtfValidator::validateInt(_descr, "bottomMin", bottomMin, _checker, __FILE__, __LINE__);
	UINT16 topMin; _jparser.validateByNameThrow("topMin", topMin);
	AtfValidator::validateInt(_descr, "topMin", topMin, _checker, __FILE__, __LINE__);
	UINT16 bottomMax; _jparser.validateByNameThrow("bottomMax", bottomMax);
	AtfValidator::validateInt(_descr, "bottomMax", bottomMax, _checker, __FILE__, __LINE__);
	UINT16 topMax; _jparser.validateByNameThrow("topMax", topMax);
	AtfValidator::validateInt(_descr, "topMax", topMax, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::BuyInRange::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT16 bottomMin; _parser.parseUINT16(bottomMin);
	AtfValidator::validateInt(_descr, "bottomMin", bottomMin, _checker, __FILE__, __LINE__);
	UINT16 topMin; _parser.parseUINT16(topMin);
	AtfValidator::validateInt(_descr, "topMin", topMin, _checker, __FILE__, __LINE__);
	UINT16 bottomMax; _parser.parseUINT16(bottomMax);
	AtfValidator::validateInt(_descr, "bottomMax", bottomMax, _checker, __FILE__, __LINE__);
	UINT16 topMax; _parser.parseUINT16(topMax);
	AtfValidator::validateInt(_descr, "topMax", topMax, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    BuyInRanges
//=================================================================

Lobby::cli::BuyInRanges::BuyInRanges()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::BuyInRanges::BuyInRanges(BuyInRanges&& _o)
	: isRevert(std::move(_o.isRevert))
	, buyInRanges(std::move(_o.buyInRanges))
{
}

Lobby::cli::BuyInRanges& Lobby::cli::BuyInRanges::operator=(BuyInRanges&& _o)
{
	if(this != &_o)
	{
		isRevert = std::move(_o.isRevert);
		buyInRanges = std::move(_o.buyInRanges);
	}
	return *this;
}

#endif

void Lobby::cli::BuyInRanges::clear()
{
	isRevert = false;
	buyInRanges.clear();
}

bool Lobby::cli::BuyInRanges::equals(const BuyInRanges& _o) const
{
	return isRevert == _o.isRevert &&
		buyInRanges.equals(_o.buyInRanges);
}

const char *Lobby::cli::BuyInRanges::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("isRevert=");
	_buf.appendUint(isRevert);
	_buf.append(',');
	_buf.append("buyInRanges=");
	buyInRanges.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::BuyInRanges::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("isRevert", isRevert, _buf);
	buyInRanges.toXmlString("buyInRanges", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::BuyInRanges::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("isRevert"))
		{
			isRevert = (*_value.ptr() == '1');
		}
		else if (_element.equals("buyInRanges"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< BuyInRange, 4 > >::FromXmlString(_value, buyInRanges)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::BuyInRanges::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(isRevert);
	buyInRanges.composeMsg(_msg, _ignoreJSON);
}

void Lobby::cli::BuyInRanges::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(isRevert);
	buyInRanges.parseMsg(_parser);
}

const char *Lobby::cli::BuyInRanges::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("isRevert", isRevert);
	_jsonstr.compose("buyInRanges", buyInRanges);
	return _buf.c_str();
}

void Lobby::cli::BuyInRanges::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("isRevert", isRevert);
	_jparser.parseByNameThrow("buyInRanges", buyInRanges);
}

/* static */ void Lobby::cli::BuyInRanges::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool isRevert; _jparser.validateByNameThrow("isRevert", isRevert);
	AtfValidator::validateInt(_descr, "isRevert", isRevert, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< BuyInRange > buyInRanges; _jparser.validateByNameThrow("buyInRanges", buyInRanges);
	AtfValidator::validateIntMax(_descr, "buyInRanges", buyInRanges.size(), 10240, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::BuyInRanges::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	bool isRevert; _parser.parseBOOL(isRevert);
	AtfValidator::validateInt(_descr, "isRevert", isRevert, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szBuyInRanges = Atf::LAtfVector< BuyInRange, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("buyInRanges"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "buyInRanges", szBuyInRanges, 10240, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    SeatManAdvSearchCriteria
//=================================================================

Lobby::cli::SeatManAdvSearchCriteria::SeatManAdvSearchCriteria()
{
	clear();
}

void Lobby::cli::SeatManAdvSearchCriteria::clear()
{
	minAvgPot = 0;
	minAvgStack = 0;
	minPlayersFlop = 0;
	minVpip = 0;
	minHandsHour = 0;
}

bool Lobby::cli::SeatManAdvSearchCriteria::equals(const SeatManAdvSearchCriteria& _o) const
{
	return minAvgPot == _o.minAvgPot &&
		minAvgStack == _o.minAvgStack &&
		minPlayersFlop == _o.minPlayersFlop &&
		minVpip == _o.minVpip &&
		minHandsHour == _o.minHandsHour;
}

const char *Lobby::cli::SeatManAdvSearchCriteria::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("minAvgPot=");
	_buf.appendUint(minAvgPot);
	_buf.append(',');
	_buf.append("minAvgStack=");
	_buf.appendUint(minAvgStack);
	_buf.append(',');
	_buf.append("minPlayersFlop=");
	_buf.appendUint(minPlayersFlop);
	_buf.append(',');
	_buf.append("minVpip=");
	_buf.appendUint(minVpip);
	_buf.append(',');
	_buf.append("minHandsHour=");
	_buf.appendUint(minHandsHour);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::SeatManAdvSearchCriteria::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("minAvgPot", minAvgPot, _buf);
	Atf::XmlElement::encodeAsXmlElement("minAvgStack", minAvgStack, _buf);
	Atf::XmlElement::encodeAsXmlElement("minPlayersFlop", minPlayersFlop, _buf);
	Atf::XmlElement::encodeAsXmlElement("minVpip", minVpip, _buf);
	Atf::XmlElement::encodeAsXmlElement("minHandsHour", minHandsHour, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::SeatManAdvSearchCriteria::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("minAvgPot"))
		{
			minAvgPot = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minAvgStack"))
		{
			minAvgStack = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minPlayersFlop"))
		{
			minPlayersFlop = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minVpip"))
		{
			minVpip = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minHandsHour"))
		{
			minHandsHour = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::SeatManAdvSearchCriteria::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(minAvgPot);
	_msg.composeUINT32(minAvgStack);
	_msg.composeBYTE(minPlayersFlop);
	_msg.composeBYTE(minVpip);
	_msg.composeUINT16(minHandsHour);
}

void Lobby::cli::SeatManAdvSearchCriteria::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(minAvgPot);
	_parser.parseUINT32(minAvgStack);
	_parser.parseBYTE(minPlayersFlop);
	_parser.parseBYTE(minVpip);
	_parser.parseUINT16(minHandsHour);
}

const char *Lobby::cli::SeatManAdvSearchCriteria::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("minAvgPot", minAvgPot);
	_jsonstr.compose("minAvgStack", minAvgStack);
	_jsonstr.compose("minPlayersFlop", minPlayersFlop);
	_jsonstr.compose("minVpip", minVpip);
	_jsonstr.compose("minHandsHour", minHandsHour);
	return _buf.c_str();
}

void Lobby::cli::SeatManAdvSearchCriteria::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("minAvgPot", minAvgPot);
	_jparser.parseByNameThrow("minAvgStack", minAvgStack);
	_jparser.parseByNameThrow("minPlayersFlop", minPlayersFlop);
	_jparser.parseByNameThrow("minVpip", minVpip);
	_jparser.parseByNameThrow("minHandsHour", minHandsHour);
}

/* static */ void Lobby::cli::SeatManAdvSearchCriteria::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 minAvgPot; _jparser.validateByNameThrow("minAvgPot", minAvgPot);
	AtfValidator::validateInt(_descr, "minAvgPot", minAvgPot, _checker, __FILE__, __LINE__);
	UINT32 minAvgStack; _jparser.validateByNameThrow("minAvgStack", minAvgStack);
	AtfValidator::validateInt(_descr, "minAvgStack", minAvgStack, _checker, __FILE__, __LINE__);
	BYTE minPlayersFlop; _jparser.validateByNameThrow("minPlayersFlop", minPlayersFlop);
	AtfValidator::validateInt(_descr, "minPlayersFlop", minPlayersFlop, _checker, __FILE__, __LINE__);
	BYTE minVpip; _jparser.validateByNameThrow("minVpip", minVpip);
	AtfValidator::validateInt(_descr, "minVpip", minVpip, _checker, __FILE__, __LINE__);
	UINT16 minHandsHour; _jparser.validateByNameThrow("minHandsHour", minHandsHour);
	AtfValidator::validateInt(_descr, "minHandsHour", minHandsHour, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::SeatManAdvSearchCriteria::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 minAvgPot; _parser.parseUINT32(minAvgPot);
	AtfValidator::validateInt(_descr, "minAvgPot", minAvgPot, _checker, __FILE__, __LINE__);
	UINT32 minAvgStack; _parser.parseUINT32(minAvgStack);
	AtfValidator::validateInt(_descr, "minAvgStack", minAvgStack, _checker, __FILE__, __LINE__);
	BYTE minPlayersFlop; _parser.parseBYTE(minPlayersFlop);
	AtfValidator::validateInt(_descr, "minPlayersFlop", minPlayersFlop, _checker, __FILE__, __LINE__);
	BYTE minVpip; _parser.parseBYTE(minVpip);
	AtfValidator::validateInt(_descr, "minVpip", minVpip, _checker, __FILE__, __LINE__);
	UINT16 minHandsHour; _parser.parseUINT16(minHandsHour);
	AtfValidator::validateInt(_descr, "minHandsHour", minHandsHour, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE(Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE&& _o)
	: minPlayers(std::move(_o.minPlayers))
	, game(std::move(_o.game))
	, hiLo(std::move(_o.hiLo))
	, structure(std::move(_o.structure))
	, maxPlayersMin(std::move(_o.maxPlayersMin))
	, maxPlayersMax(std::move(_o.maxPlayersMax))
	, minLoBet32(std::move(_o.minLoBet32))
	, minHiBet32(std::move(_o.minHiBet32))
	, maxLoBet32(std::move(_o.maxLoBet32))
	, maxHiBet32(std::move(_o.maxHiBet32))
	, capOn(std::move(_o.capOn))
	, speedBM(std::move(_o.speedBM))
	, currencyBM(std::move(_o.currencyBM))
	, buyInRanges(std::move(_o.buyInRanges))
	, seatManAdvSearchCriteria(std::move(_o.seatManAdvSearchCriteria))
	, clientReqId(std::move(_o.clientReqId))
	, searchFlags(std::move(_o.searchFlags))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE& Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE::operator=(Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE&& _o)
{
	if(this != &_o)
	{
		minPlayers = std::move(_o.minPlayers);
		game = std::move(_o.game);
		hiLo = std::move(_o.hiLo);
		structure = std::move(_o.structure);
		maxPlayersMin = std::move(_o.maxPlayersMin);
		maxPlayersMax = std::move(_o.maxPlayersMax);
		minLoBet32 = std::move(_o.minLoBet32);
		minHiBet32 = std::move(_o.minHiBet32);
		maxLoBet32 = std::move(_o.maxLoBet32);
		maxHiBet32 = std::move(_o.maxHiBet32);
		capOn = std::move(_o.capOn);
		speedBM = std::move(_o.speedBM);
		currencyBM = std::move(_o.currencyBM);
		buyInRanges = std::move(_o.buyInRanges);
		seatManAdvSearchCriteria = std::move(_o.seatManAdvSearchCriteria);
		clientReqId = std::move(_o.clientReqId);
		searchFlags = std::move(_o.searchFlags);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE::clear()
{
	minPlayers = 0;
	game = 0;
	hiLo = 0;
	structure = 0;
	maxPlayersMin = 0;
	maxPlayersMax = 0;
	minLoBet32 = 0;
	minHiBet32 = 0;
	maxLoBet32 = 0;
	maxHiBet32 = 0;
	capOn = false;
	speedBM = 0;
	currencyBM = 0;
	buyInRanges.clear();
	seatManAdvSearchCriteria.clear();
	clientReqId = 0;
	searchFlags = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE::equals(const Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE& _o) const
{
	return minPlayers == _o.minPlayers &&
		game == _o.game &&
		hiLo == _o.hiLo &&
		structure == _o.structure &&
		maxPlayersMin == _o.maxPlayersMin &&
		maxPlayersMax == _o.maxPlayersMax &&
		minLoBet32 == _o.minLoBet32 &&
		minHiBet32 == _o.minHiBet32 &&
		maxLoBet32 == _o.maxLoBet32 &&
		maxHiBet32 == _o.maxHiBet32 &&
		capOn == _o.capOn &&
		speedBM == _o.speedBM &&
		currencyBM == _o.currencyBM &&
		buyInRanges.equals(_o.buyInRanges) &&
		seatManAdvSearchCriteria.equals(_o.seatManAdvSearchCriteria) &&
		clientReqId == _o.clientReqId &&
		searchFlags == _o.searchFlags;
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_FIND_SEAT_MANAGER_TABLE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_SEAT_MANAGER_TABLE).append(")");
	_buf.append(',');
	_buf.append("minPlayers=");
	_buf.appendUint(minPlayers);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("hiLo=");
	_buf.appendUint(hiLo);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("maxPlayersMin=");
	_buf.appendUint(maxPlayersMin);
	_buf.append(',');
	_buf.append("maxPlayersMax=");
	_buf.appendUint(maxPlayersMax);
	_buf.append(',');
	_buf.append("minLoBet32=");
	_buf.appendUint(minLoBet32);
	_buf.append(',');
	_buf.append("minHiBet32=");
	_buf.appendUint(minHiBet32);
	_buf.append(',');
	_buf.append("maxLoBet32=");
	_buf.appendUint(maxLoBet32);
	_buf.append(',');
	_buf.append("maxHiBet32=");
	_buf.appendUint(maxHiBet32);
	_buf.append(',');
	_buf.append("capOn=");
	_buf.appendUint(capOn);
	_buf.append(',');
	_buf.append("speedBM=");
	_buf.appendUint(speedBM);
	_buf.append(',');
	_buf.append("currencyBM=");
	_buf.appendUint(currencyBM);
	_buf.append(',');
	_buf.append("buyInRanges=");
	buyInRanges.toTraceString(_buf);
	_buf.append(',');
	_buf.append("seatManAdvSearchCriteria=");
	seatManAdvSearchCriteria.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clientReqId=");
	_buf.appendUint(clientReqId);
	_buf.append(',');
	_buf.append("searchFlags=");
	_buf.appendUint(searchFlags);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_FIND_SEAT_MANAGER_TABLE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("minPlayers", minPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("hiLo", hiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPlayersMin", maxPlayersMin, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPlayersMax", maxPlayersMax, _buf);
	Atf::XmlElement::encodeAsXmlElement("minLoBet32", minLoBet32, _buf);
	Atf::XmlElement::encodeAsXmlElement("minHiBet32", minHiBet32, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxLoBet32", maxLoBet32, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxHiBet32", maxHiBet32, _buf);
	Atf::XmlElement::encodeAsXmlElement("capOn", capOn, _buf);
	Atf::XmlElement::encodeAsXmlElement("speedBM", speedBM, _buf);
	Atf::XmlElement::encodeAsXmlElement("currencyBM", currencyBM, _buf);
	buyInRanges.toXmlString("buyInRanges", _buf);
	seatManAdvSearchCriteria.toXmlString("seatManAdvSearchCriteria", _buf);
	Atf::XmlElement::encodeAsXmlElement("clientReqId", clientReqId, _buf);
	Atf::XmlElement::encodeAsXmlElement("searchFlags", searchFlags, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("minPlayers"))
			{
				minPlayers = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("game"))
			{
				game = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("hiLo"))
			{
				hiLo = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("structure"))
			{
				structure = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxPlayersMin"))
			{
				maxPlayersMin = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxPlayersMax"))
			{
				maxPlayersMax = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minLoBet32"))
			{
				minLoBet32 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minHiBet32"))
			{
				minHiBet32 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxLoBet32"))
			{
				maxLoBet32 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxHiBet32"))
			{
				maxHiBet32 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("capOn"))
			{
				capOn = (*_value.ptr() == '1');
			}
			else if (_element.equals("speedBM"))
			{
				speedBM = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currencyBM"))
			{
				currencyBM = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("buyInRanges"))
			{
				if(!Atf::AtfTempl< BuyInRanges >::FromXmlString(_value, buyInRanges)) return false;
			}
			else if (_element.equals("seatManAdvSearchCriteria"))
			{
				if(!Atf::AtfTempl< SeatManAdvSearchCriteria >::FromXmlString(_value, seatManAdvSearchCriteria)) return false;
			}
			else if (_element.equals("clientReqId"))
			{
				clientReqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("searchFlags"))
			{
				searchFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(minPlayers);
	_msg.composeBYTE(game);
	_msg.composeBYTE(hiLo);
	_msg.composeBYTE(structure);
	_msg.composeBYTE(maxPlayersMin);
	_msg.composeBYTE(maxPlayersMax);
	_msg.composeUINT32(minLoBet32);
	_msg.composeUINT32(minHiBet32);
	_msg.composeUINT32(maxLoBet32);
	_msg.composeUINT32(maxHiBet32);
	_msg.composeBOOL(capOn);
	_msg.composeBYTE(speedBM);
	_msg.composeUINT32(currencyBM);
	buyInRanges.composeMsg(_msg, _ignoreJSON);
	seatManAdvSearchCriteria.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(clientReqId);
	_msg.composeUINT32(searchFlags);
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(minPlayers);
	_parser.parseBYTE(game);
	_parser.parseBYTE(hiLo);
	_parser.parseBYTE(structure);
	_parser.parseBYTE(maxPlayersMin);
	_parser.parseBYTE(maxPlayersMax);
	_parser.parseUINT32(minLoBet32);
	_parser.parseUINT32(minHiBet32);
	_parser.parseUINT32(maxLoBet32);
	_parser.parseUINT32(maxHiBet32);
	_parser.parseBOOL(capOn);
	_parser.parseBYTE(speedBM);
	_parser.parseUINT32(currencyBM);
	buyInRanges.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	seatManAdvSearchCriteria.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(clientReqId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(searchFlags);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("minPlayers", minPlayers);
	_jsonstr.compose("game", game);
	_jsonstr.compose("hiLo", hiLo);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("maxPlayersMin", maxPlayersMin);
	_jsonstr.compose("maxPlayersMax", maxPlayersMax);
	_jsonstr.compose("minLoBet32", minLoBet32);
	_jsonstr.compose("minHiBet32", minHiBet32);
	_jsonstr.compose("maxLoBet32", maxLoBet32);
	_jsonstr.compose("maxHiBet32", maxHiBet32);
	_jsonstr.compose("capOn", capOn);
	_jsonstr.compose("speedBM", speedBM);
	_jsonstr.compose("currencyBM", currencyBM);
	_jsonstr.compose("buyInRanges", buyInRanges);
	_jsonstr.compose("seatManAdvSearchCriteria", seatManAdvSearchCriteria);
	_jsonstr.compose("clientReqId", clientReqId);
	_jsonstr.compose("searchFlags", searchFlags);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("minPlayers", minPlayers);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("hiLo", hiLo);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("maxPlayersMin", maxPlayersMin);
	_jparser.parseByNameThrow("maxPlayersMax", maxPlayersMax);
	_jparser.parseByNameThrow("minLoBet32", minLoBet32);
	_jparser.parseByNameThrow("minHiBet32", minHiBet32);
	_jparser.parseByNameThrow("maxLoBet32", maxLoBet32);
	_jparser.parseByNameThrow("maxHiBet32", maxHiBet32);
	_jparser.parseByNameThrow("capOn", capOn);
	_jparser.parseByNameThrow("speedBM", speedBM);
	_jparser.parseByNameThrow("currencyBM", currencyBM);
	_jparser.parseByNameThrow("buyInRanges", buyInRanges);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("seatManAdvSearchCriteria", seatManAdvSearchCriteria);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("clientReqId", clientReqId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("searchFlags", searchFlags);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_SEAT_MANAGER_TABLE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE minPlayers; _jparser.validateByNameThrow("minPlayers", minPlayers);
	AtfValidator::validateIntMax(_descr, "minPlayers", minPlayers, 10, _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateIntRange(_descr, "game", game, 1, HandType_Last, _checker, __FILE__, __LINE__);
	BYTE hiLo; _jparser.validateByNameThrow("hiLo", hiLo);
	AtfValidator::validateIntMax(_descr, "hiLo", hiLo, 1, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateIntRange(_descr, "structure", structure, StructLimit, PotStruct_Last, _checker, __FILE__, __LINE__);
	BYTE maxPlayersMin; _jparser.validateByNameThrow("maxPlayersMin", maxPlayersMin);
	AtfValidator::validateIntRange(_descr, "maxPlayersMin", maxPlayersMin, 2, 1000000, _checker, __FILE__, __LINE__);
	BYTE maxPlayersMax; _jparser.validateByNameThrow("maxPlayersMax", maxPlayersMax);
	AtfValidator::validateIntRange(_descr, "maxPlayersMax", maxPlayersMax, 2, 1000000, _checker, __FILE__, __LINE__);
	UINT32 minLoBet32; _jparser.validateByNameThrow("minLoBet32", minLoBet32);
	AtfValidator::validateIntMax(_descr, "minLoBet32", minLoBet32, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 minHiBet32; _jparser.validateByNameThrow("minHiBet32", minHiBet32);
	AtfValidator::validateIntMax(_descr, "minHiBet32", minHiBet32, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 maxLoBet32; _jparser.validateByNameThrow("maxLoBet32", maxLoBet32);
	AtfValidator::validateIntMax(_descr, "maxLoBet32", maxLoBet32, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 maxHiBet32; _jparser.validateByNameThrow("maxHiBet32", maxHiBet32);
	AtfValidator::validateIntMax(_descr, "maxHiBet32", maxHiBet32, 2000000000, _checker, __FILE__, __LINE__);
	bool capOn; _jparser.validateByNameThrow("capOn", capOn);
	AtfValidator::validateInt(_descr, "capOn", capOn, _checker, __FILE__, __LINE__);
	BYTE speedBM; _jparser.validateByNameThrow("speedBM", speedBM);
	AtfValidator::validateIntMax(_descr, "speedBM", speedBM, eSeatManSpeed_Last, _checker, __FILE__, __LINE__);
	UINT32 currencyBM; _jparser.validateByNameThrow("currencyBM", currencyBM);
	AtfValidator::validateIntMax(_descr, "currencyBM", currencyBM, eSeatManCurrency_Last, _checker, __FILE__, __LINE__);
	BuyInRanges buyInRanges; _jparser.validateByNameThrow("buyInRanges", buyInRanges);
	if(_jparser.parseEnded()) return;
	SeatManAdvSearchCriteria seatManAdvSearchCriteria; _jparser.validateByNameThrow("seatManAdvSearchCriteria", seatManAdvSearchCriteria);
	if(_jparser.parseEnded()) return;
	UINT32 clientReqId; _jparser.validateByNameThrow("clientReqId", clientReqId);
	AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 searchFlags; _jparser.validateByNameThrow("searchFlags", searchFlags);
	AtfValidator::validateIntRange(_descr, "searchFlags", searchFlags, eSeatManFlags_None, eSeatManFlags_Last, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_SEAT_MANAGER_TABLE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE minPlayers; _parser.parseBYTE(minPlayers);
	AtfValidator::validateIntMax(_descr, "minPlayers", minPlayers, 10, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateIntRange(_descr, "game", game, 1, HandType_Last, _checker, __FILE__, __LINE__);
	BYTE hiLo; _parser.parseBYTE(hiLo);
	AtfValidator::validateIntMax(_descr, "hiLo", hiLo, 1, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateIntRange(_descr, "structure", structure, StructLimit, PotStruct_Last, _checker, __FILE__, __LINE__);
	BYTE maxPlayersMin; _parser.parseBYTE(maxPlayersMin);
	AtfValidator::validateIntRange(_descr, "maxPlayersMin", maxPlayersMin, 2, 1000000, _checker, __FILE__, __LINE__);
	BYTE maxPlayersMax; _parser.parseBYTE(maxPlayersMax);
	AtfValidator::validateIntRange(_descr, "maxPlayersMax", maxPlayersMax, 2, 1000000, _checker, __FILE__, __LINE__);
	UINT32 minLoBet32; _parser.parseUINT32(minLoBet32);
	AtfValidator::validateIntMax(_descr, "minLoBet32", minLoBet32, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 minHiBet32; _parser.parseUINT32(minHiBet32);
	AtfValidator::validateIntMax(_descr, "minHiBet32", minHiBet32, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 maxLoBet32; _parser.parseUINT32(maxLoBet32);
	AtfValidator::validateIntMax(_descr, "maxLoBet32", maxLoBet32, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 maxHiBet32; _parser.parseUINT32(maxHiBet32);
	AtfValidator::validateIntMax(_descr, "maxHiBet32", maxHiBet32, 2000000000, _checker, __FILE__, __LINE__);
	bool capOn; _parser.parseBOOL(capOn);
	AtfValidator::validateInt(_descr, "capOn", capOn, _checker, __FILE__, __LINE__);
	BYTE speedBM; _parser.parseBYTE(speedBM);
	AtfValidator::validateIntMax(_descr, "speedBM", speedBM, eSeatManSpeed_Last, _checker, __FILE__, __LINE__);
	UINT32 currencyBM; _parser.parseUINT32(currencyBM);
	AtfValidator::validateIntMax(_descr, "currencyBM", currencyBM, eSeatManCurrency_Last, _checker, __FILE__, __LINE__);
	PString _descbuf;
	BuyInRanges::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("buyInRanges"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	SeatManAdvSearchCriteria::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("seatManAdvSearchCriteria"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	UINT32 clientReqId; _parser.parseUINT32(clientReqId);
	AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 searchFlags; _parser.parseUINT32(searchFlags);
	AtfValidator::validateIntRange(_descr, "searchFlags", searchFlags, eSeatManFlags_None, eSeatManFlags_Last, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY(Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, clientReqId(std::move(_o.clientReqId))
	, searchFlags(std::move(_o.searchFlags))
	, server(std::move(_o.server))
	, tableId(std::move(_o.tableId))
	, seat(std::move(_o.seat))
	, useDecrSearch(std::move(_o.useDecrSearch))
	, numOfPlayersInDecrSearchTable(std::move(_o.numOfPlayersInDecrSearchTable))
	, waitingForSeatReservationTimeout(std::move(_o.waitingForSeatReservationTimeout))
	, isThereDealing(std::move(_o.isThereDealing))
	, tableId64(std::move(_o.tableId64))
	, serverObject(std::move(_o.serverObject))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY& Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY::operator=(Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		clientReqId = std::move(_o.clientReqId);
		searchFlags = std::move(_o.searchFlags);
		server = std::move(_o.server);
		tableId = std::move(_o.tableId);
		seat = std::move(_o.seat);
		useDecrSearch = std::move(_o.useDecrSearch);
		numOfPlayersInDecrSearchTable = std::move(_o.numOfPlayersInDecrSearchTable);
		waitingForSeatReservationTimeout = std::move(_o.waitingForSeatReservationTimeout);
		isThereDealing = std::move(_o.isThereDealing);
		tableId64 = std::move(_o.tableId64);
		serverObject = std::move(_o.serverObject);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	clientReqId = 0;
	searchFlags = 0;
	server.clear();
	tableId = 0;
	seat = 0;
	useDecrSearch = 0;
	numOfPlayersInDecrSearchTable = 0;
	waitingForSeatReservationTimeout = 0;
	isThereDealing = false;
	tableId64 = 0;
	serverObject.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY::equals(const Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		clientReqId == _o.clientReqId &&
		searchFlags == _o.searchFlags &&
		Atf::atfPStringEquals(server, _o.server) &&
		tableId == _o.tableId &&
		seat == _o.seat &&
		useDecrSearch == _o.useDecrSearch &&
		numOfPlayersInDecrSearchTable == _o.numOfPlayersInDecrSearchTable &&
		waitingForSeatReservationTimeout == _o.waitingForSeatReservationTimeout &&
		isThereDealing == _o.isThereDealing &&
		tableId64 == _o.tableId64 &&
		Atf::atfPStringEquals(serverObject, _o.serverObject);
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
		_buf.append(',');
		_buf.append("clientReqId=");
		_buf.appendUint(clientReqId);
		_buf.append(',');
		_buf.append("searchFlags=");
		_buf.appendUint(searchFlags);
	}
	else
	{
		_buf.append(',');
		_buf.append("server=");
		_buf.append(server);
		_buf.append(',');
		_buf.append("tableId=");
		_buf.appendUint(tableId);
		_buf.append(',');
		_buf.append("seat=");
		_buf.appendUint(seat);
		_buf.append(',');
		_buf.append("clientReqId=");
		_buf.appendUint(clientReqId);
		_buf.append(',');
		_buf.append("useDecrSearch=");
		_buf.appendUint(useDecrSearch);
		_buf.append(',');
		_buf.append("numOfPlayersInDecrSearchTable=");
		_buf.appendUint(numOfPlayersInDecrSearchTable);
		_buf.append(',');
		_buf.append("waitingForSeatReservationTimeout=");
		_buf.appendUint(waitingForSeatReservationTimeout);
		_buf.append(',');
		_buf.append("isThereDealing=");
		_buf.appendUint(isThereDealing);
		_buf.append(',');
		_buf.append("tableId64=");
		_buf.appendUint64(tableId64);
		_buf.append(',');
		_buf.append("serverObject=");
		_buf.append(serverObject);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
		Atf::XmlElement::encodeAsXmlElement("clientReqId", clientReqId, _buf);
		Atf::XmlElement::encodeAsXmlElement("searchFlags", searchFlags, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("server", server, _buf);
		Atf::XmlElement::encodeAsXmlElement("tableId", tableId, _buf);
		Atf::XmlElement::encodeAsXmlElement("seat", seat, _buf);
		Atf::XmlElement::encodeAsXmlElement("clientReqId", clientReqId, _buf);
		Atf::XmlElement::encodeAsXmlElement("useDecrSearch", useDecrSearch, _buf);
		Atf::XmlElement::encodeAsXmlElement("numOfPlayersInDecrSearchTable", numOfPlayersInDecrSearchTable, _buf);
		Atf::XmlElement::encodeAsXmlElement("waitingForSeatReservationTimeout", waitingForSeatReservationTimeout, _buf);
		Atf::XmlElement::encodeAsXmlElement("isThereDealing", isThereDealing, _buf);
		Atf::XmlElement::encodeAsXmlElement("tableId64", tableId64, _buf);
		Atf::XmlElement::encodeAsXmlElement("serverObject", serverObject, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("clientReqId"))
			{
				clientReqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("searchFlags"))
			{
				searchFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("server"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, server)) return false;
			}
			else if (_element.equals("tableId"))
			{
				tableId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("seat"))
			{
				seat = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("useDecrSearch"))
			{
				useDecrSearch = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("numOfPlayersInDecrSearchTable"))
			{
				numOfPlayersInDecrSearchTable = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("waitingForSeatReservationTimeout"))
			{
				waitingForSeatReservationTimeout = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isThereDealing"))
			{
				isThereDealing = (*_value.ptr() == '1');
			}
			else if (_element.equals("tableId64"))
			{
				tableId64 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("serverObject"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, serverObject)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
		_msg.composeUINT32(clientReqId);
		_msg.composeUINT32(searchFlags);
	}
	else
	{
		_msg.composeString(server);
		_msg.composeUINT32(tableId);
		_msg.composeBYTE(seat);
		_msg.composeUINT32(clientReqId);
		_msg.composeUINT32(useDecrSearch);
		_msg.composeBYTE(numOfPlayersInDecrSearchTable);
		_msg.composeUINT16(waitingForSeatReservationTimeout);
		_msg.composeBOOL(isThereDealing);
		_msg.composeUINT64(tableId64);
		_msg.composeString(serverObject);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
		_parser.parseUINT32(clientReqId);
		_parser.parseUINT32(searchFlags);
	}
	else
	{
		_parser.parseStringP(server);
		_parser.parseUINT32(tableId);
		_parser.parseBYTE(seat);
		_parser.parseUINT32(clientReqId);
		_parser.parseUINT32(useDecrSearch);
		_parser.parseBYTE(numOfPlayersInDecrSearchTable);
		_parser.parseUINT16(waitingForSeatReservationTimeout);
		_parser.parseBOOL(isThereDealing);
		_parser.parseUINT64(tableId64);
		_parser.parseStringP(serverObject);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
		_jsonstr.compose("clientReqId", clientReqId);
		_jsonstr.compose("searchFlags", searchFlags);
	}
	else
	{
		_jsonstr.compose("server", server);
		_jsonstr.compose("tableId", tableId);
		_jsonstr.compose("seat", seat);
		_jsonstr.compose("clientReqId", clientReqId);
		_jsonstr.compose("useDecrSearch", useDecrSearch);
		_jsonstr.compose("numOfPlayersInDecrSearchTable", numOfPlayersInDecrSearchTable);
		_jsonstr.compose("waitingForSeatReservationTimeout", waitingForSeatReservationTimeout);
		_jsonstr.compose("isThereDealing", isThereDealing);
		_jsonstr.compose("tableId64", tableId64);
		_jsonstr.compose("serverObject", serverObject);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
		_jparser.parseByNameThrow("clientReqId", clientReqId);
		_jparser.parseByNameThrow("searchFlags", searchFlags);
	}
	else
	{
		_jparser.parseByNameThrow("server", server);
		_jparser.parseByNameThrow("tableId", tableId);
		_jparser.parseByNameThrow("seat", seat);
		_jparser.parseByNameThrow("clientReqId", clientReqId);
		_jparser.parseByNameThrow("useDecrSearch", useDecrSearch);
		_jparser.parseByNameThrow("numOfPlayersInDecrSearchTable", numOfPlayersInDecrSearchTable);
		_jparser.parseByNameThrow("waitingForSeatReservationTimeout", waitingForSeatReservationTimeout);
		_jparser.parseByNameThrow("isThereDealing", isThereDealing);
		_jparser.parseByNameThrow("tableId64", tableId64);
		_jparser.parseByNameThrow("serverObject", serverObject);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
		UINT32 clientReqId; _jparser.validateByNameThrow("clientReqId", clientReqId);
		AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
		UINT32 searchFlags; _jparser.validateByNameThrow("searchFlags", searchFlags);
		AtfValidator::validateInt(_descr, "searchFlags", searchFlags, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString server; _jparser.validateByNameThrow("server", server);
		AtfValidator::validateInt(_descr, "server", server.length(), _checker, __FILE__, __LINE__);
		UINT32 tableId; _jparser.validateByNameThrow("tableId", tableId);
		AtfValidator::validateInt(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
		BYTE seat; _jparser.validateByNameThrow("seat", seat);
		AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
		UINT32 clientReqId; _jparser.validateByNameThrow("clientReqId", clientReqId);
		AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
		UINT32 useDecrSearch; _jparser.validateByNameThrow("useDecrSearch", useDecrSearch);
		AtfValidator::validateInt(_descr, "useDecrSearch", useDecrSearch, _checker, __FILE__, __LINE__);
		BYTE numOfPlayersInDecrSearchTable; _jparser.validateByNameThrow("numOfPlayersInDecrSearchTable", numOfPlayersInDecrSearchTable);
		AtfValidator::validateInt(_descr, "numOfPlayersInDecrSearchTable", numOfPlayersInDecrSearchTable, _checker, __FILE__, __LINE__);
		UINT16 waitingForSeatReservationTimeout; _jparser.validateByNameThrow("waitingForSeatReservationTimeout", waitingForSeatReservationTimeout);
		AtfValidator::validateInt(_descr, "waitingForSeatReservationTimeout", waitingForSeatReservationTimeout, _checker, __FILE__, __LINE__);
		bool isThereDealing; _jparser.validateByNameThrow("isThereDealing", isThereDealing);
		AtfValidator::validateInt(_descr, "isThereDealing", isThereDealing, _checker, __FILE__, __LINE__);
		UINT64 tableId64; _jparser.validateByNameThrow("tableId64", tableId64);
		AtfValidator::validateUint(_descr, "tableId64", tableId64, _checker, __FILE__, __LINE__);
		PString serverObject; _jparser.validateByNameThrow("serverObject", serverObject);
		AtfValidator::validateInt(_descr, "serverObject", serverObject.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
		UINT32 clientReqId; _parser.parseUINT32(clientReqId);
		AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
		UINT32 searchFlags; _parser.parseUINT32(searchFlags);
		AtfValidator::validateInt(_descr, "searchFlags", searchFlags, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
		UINT32 tableId; _parser.parseUINT32(tableId);
		AtfValidator::validateInt(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
		BYTE seat; _parser.parseBYTE(seat);
		AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
		UINT32 clientReqId; _parser.parseUINT32(clientReqId);
		AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
		UINT32 useDecrSearch; _parser.parseUINT32(useDecrSearch);
		AtfValidator::validateInt(_descr, "useDecrSearch", useDecrSearch, _checker, __FILE__, __LINE__);
		BYTE numOfPlayersInDecrSearchTable; _parser.parseBYTE(numOfPlayersInDecrSearchTable);
		AtfValidator::validateInt(_descr, "numOfPlayersInDecrSearchTable", numOfPlayersInDecrSearchTable, _checker, __FILE__, __LINE__);
		UINT16 waitingForSeatReservationTimeout; _parser.parseUINT16(waitingForSeatReservationTimeout);
		AtfValidator::validateInt(_descr, "waitingForSeatReservationTimeout", waitingForSeatReservationTimeout, _checker, __FILE__, __LINE__);
		bool isThereDealing; _parser.parseBOOL(isThereDealing);
		AtfValidator::validateInt(_descr, "isThereDealing", isThereDealing, _checker, __FILE__, __LINE__);
		UINT64 tableId64; _parser.parseUINT64(tableId64);
		AtfValidator::validateUint(_descr, "tableId64", tableId64, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "serverObject"); size_t szServerObject = strlen(_dummy);
		AtfValidator::validateInt(_descr, "serverObject", szServerObject, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2(Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2&& _o)
	: minPlayers(std::move(_o.minPlayers))
	, game(std::move(_o.game))
	, hiLo(std::move(_o.hiLo))
	, structure(std::move(_o.structure))
	, maxPlayersMin(std::move(_o.maxPlayersMin))
	, maxPlayersMax(std::move(_o.maxPlayersMax))
	, minLoBet(std::move(_o.minLoBet))
	, minHiBet(std::move(_o.minHiBet))
	, maxLoBet(std::move(_o.maxLoBet))
	, maxHiBet(std::move(_o.maxHiBet))
	, capOn(std::move(_o.capOn))
	, speedBM(std::move(_o.speedBM))
	, currencyBM(std::move(_o.currencyBM))
	, buyInRanges(std::move(_o.buyInRanges))
	, seatManAdvSearchCriteria(std::move(_o.seatManAdvSearchCriteria))
	, clientReqId(std::move(_o.clientReqId))
	, searchFlags(std::move(_o.searchFlags))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2& Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2::operator=(Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2&& _o)
{
	if(this != &_o)
	{
		minPlayers = std::move(_o.minPlayers);
		game = std::move(_o.game);
		hiLo = std::move(_o.hiLo);
		structure = std::move(_o.structure);
		maxPlayersMin = std::move(_o.maxPlayersMin);
		maxPlayersMax = std::move(_o.maxPlayersMax);
		minLoBet = std::move(_o.minLoBet);
		minHiBet = std::move(_o.minHiBet);
		maxLoBet = std::move(_o.maxLoBet);
		maxHiBet = std::move(_o.maxHiBet);
		capOn = std::move(_o.capOn);
		speedBM = std::move(_o.speedBM);
		currencyBM = std::move(_o.currencyBM);
		buyInRanges = std::move(_o.buyInRanges);
		seatManAdvSearchCriteria = std::move(_o.seatManAdvSearchCriteria);
		clientReqId = std::move(_o.clientReqId);
		searchFlags = std::move(_o.searchFlags);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2::clear()
{
	minPlayers = 0;
	game = 0;
	hiLo = 0;
	structure = 0;
	maxPlayersMin = 0;
	maxPlayersMax = 0;
	minLoBet = 0;
	minHiBet = 0;
	maxLoBet = 0;
	maxHiBet = 0;
	capOn = false;
	speedBM = 0;
	currencyBM = 0;
	buyInRanges.clear();
	seatManAdvSearchCriteria.clear();
	clientReqId = 0;
	searchFlags = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2::equals(const Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2& _o) const
{
	return minPlayers == _o.minPlayers &&
		game == _o.game &&
		hiLo == _o.hiLo &&
		structure == _o.structure &&
		maxPlayersMin == _o.maxPlayersMin &&
		maxPlayersMax == _o.maxPlayersMax &&
		minLoBet == _o.minLoBet &&
		minHiBet == _o.minHiBet &&
		maxLoBet == _o.maxLoBet &&
		maxHiBet == _o.maxHiBet &&
		capOn == _o.capOn &&
		speedBM == _o.speedBM &&
		currencyBM == _o.currencyBM &&
		buyInRanges.equals(_o.buyInRanges) &&
		seatManAdvSearchCriteria.equals(_o.seatManAdvSearchCriteria) &&
		clientReqId == _o.clientReqId &&
		searchFlags == _o.searchFlags;
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2).append(")");
	_buf.append(',');
	_buf.append("minPlayers=");
	_buf.appendUint(minPlayers);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("hiLo=");
	_buf.appendUint(hiLo);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("maxPlayersMin=");
	_buf.appendUint(maxPlayersMin);
	_buf.append(',');
	_buf.append("maxPlayersMax=");
	_buf.appendUint(maxPlayersMax);
	_buf.append(',');
	_buf.append("minLoBet=");
	_buf.appendInt64(minLoBet);
	_buf.append(',');
	_buf.append("minHiBet=");
	_buf.appendInt64(minHiBet);
	_buf.append(',');
	_buf.append("maxLoBet=");
	_buf.appendInt64(maxLoBet);
	_buf.append(',');
	_buf.append("maxHiBet=");
	_buf.appendInt64(maxHiBet);
	_buf.append(',');
	_buf.append("capOn=");
	_buf.appendUint(capOn);
	_buf.append(',');
	_buf.append("speedBM=");
	_buf.appendUint(speedBM);
	_buf.append(',');
	_buf.append("currencyBM=");
	_buf.appendUint(currencyBM);
	_buf.append(',');
	_buf.append("buyInRanges=");
	buyInRanges.toTraceString(_buf);
	_buf.append(',');
	_buf.append("seatManAdvSearchCriteria=");
	seatManAdvSearchCriteria.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clientReqId=");
	_buf.appendUint(clientReqId);
	_buf.append(',');
	_buf.append("searchFlags=");
	_buf.appendUint(searchFlags);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("minPlayers", minPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("hiLo", hiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPlayersMin", maxPlayersMin, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPlayersMax", maxPlayersMax, _buf);
	Atf::XmlElement::encodeAsXmlElement("minLoBet", minLoBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("minHiBet", minHiBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxLoBet", maxLoBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxHiBet", maxHiBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("capOn", capOn, _buf);
	Atf::XmlElement::encodeAsXmlElement("speedBM", speedBM, _buf);
	Atf::XmlElement::encodeAsXmlElement("currencyBM", currencyBM, _buf);
	buyInRanges.toXmlString("buyInRanges", _buf);
	seatManAdvSearchCriteria.toXmlString("seatManAdvSearchCriteria", _buf);
	Atf::XmlElement::encodeAsXmlElement("clientReqId", clientReqId, _buf);
	Atf::XmlElement::encodeAsXmlElement("searchFlags", searchFlags, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("minPlayers"))
			{
				minPlayers = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("game"))
			{
				game = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("hiLo"))
			{
				hiLo = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("structure"))
			{
				structure = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxPlayersMin"))
			{
				maxPlayersMin = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxPlayersMax"))
			{
				maxPlayersMax = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minLoBet"))
			{
				minLoBet = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minHiBet"))
			{
				minHiBet = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxLoBet"))
			{
				maxLoBet = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxHiBet"))
			{
				maxHiBet = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("capOn"))
			{
				capOn = (*_value.ptr() == '1');
			}
			else if (_element.equals("speedBM"))
			{
				speedBM = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currencyBM"))
			{
				currencyBM = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("buyInRanges"))
			{
				if(!Atf::AtfTempl< BuyInRanges >::FromXmlString(_value, buyInRanges)) return false;
			}
			else if (_element.equals("seatManAdvSearchCriteria"))
			{
				if(!Atf::AtfTempl< SeatManAdvSearchCriteria >::FromXmlString(_value, seatManAdvSearchCriteria)) return false;
			}
			else if (_element.equals("clientReqId"))
			{
				clientReqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("searchFlags"))
			{
				searchFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(minPlayers);
	_msg.composeBYTE(game);
	_msg.composeBYTE(hiLo);
	_msg.composeBYTE(structure);
	_msg.composeBYTE(maxPlayersMin);
	_msg.composeBYTE(maxPlayersMax);
	_msg.composeINT64(minLoBet);
	_msg.composeINT64(minHiBet);
	_msg.composeINT64(maxLoBet);
	_msg.composeINT64(maxHiBet);
	_msg.composeBOOL(capOn);
	_msg.composeBYTE(speedBM);
	_msg.composeUINT32(currencyBM);
	buyInRanges.composeMsg(_msg, _ignoreJSON);
	seatManAdvSearchCriteria.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(clientReqId);
	_msg.composeUINT32(searchFlags);
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(minPlayers);
	_parser.parseBYTE(game);
	_parser.parseBYTE(hiLo);
	_parser.parseBYTE(structure);
	_parser.parseBYTE(maxPlayersMin);
	_parser.parseBYTE(maxPlayersMax);
	_parser.parseINT64(minLoBet);
	_parser.parseINT64(minHiBet);
	_parser.parseINT64(maxLoBet);
	_parser.parseINT64(maxHiBet);
	_parser.parseBOOL(capOn);
	_parser.parseBYTE(speedBM);
	_parser.parseUINT32(currencyBM);
	buyInRanges.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	seatManAdvSearchCriteria.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(clientReqId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(searchFlags);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("minPlayers", minPlayers);
	_jsonstr.compose("game", game);
	_jsonstr.compose("hiLo", hiLo);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("maxPlayersMin", maxPlayersMin);
	_jsonstr.compose("maxPlayersMax", maxPlayersMax);
	_jsonstr.compose("minLoBet", minLoBet);
	_jsonstr.compose("minHiBet", minHiBet);
	_jsonstr.compose("maxLoBet", maxLoBet);
	_jsonstr.compose("maxHiBet", maxHiBet);
	_jsonstr.compose("capOn", capOn);
	_jsonstr.compose("speedBM", speedBM);
	_jsonstr.compose("currencyBM", currencyBM);
	_jsonstr.compose("buyInRanges", buyInRanges);
	_jsonstr.compose("seatManAdvSearchCriteria", seatManAdvSearchCriteria);
	_jsonstr.compose("clientReqId", clientReqId);
	_jsonstr.compose("searchFlags", searchFlags);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("minPlayers", minPlayers);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("hiLo", hiLo);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("maxPlayersMin", maxPlayersMin);
	_jparser.parseByNameThrow("maxPlayersMax", maxPlayersMax);
	_jparser.parseByNameThrow("minLoBet", minLoBet);
	_jparser.parseByNameThrow("minHiBet", minHiBet);
	_jparser.parseByNameThrow("maxLoBet", maxLoBet);
	_jparser.parseByNameThrow("maxHiBet", maxHiBet);
	_jparser.parseByNameThrow("capOn", capOn);
	_jparser.parseByNameThrow("speedBM", speedBM);
	_jparser.parseByNameThrow("currencyBM", currencyBM);
	_jparser.parseByNameThrow("buyInRanges", buyInRanges);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("seatManAdvSearchCriteria", seatManAdvSearchCriteria);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("clientReqId", clientReqId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("searchFlags", searchFlags);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE minPlayers; _jparser.validateByNameThrow("minPlayers", minPlayers);
	AtfValidator::validateIntMax(_descr, "minPlayers", minPlayers, 10, _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateIntRange(_descr, "game", game, 1, HandType_Last, _checker, __FILE__, __LINE__);
	BYTE hiLo; _jparser.validateByNameThrow("hiLo", hiLo);
	AtfValidator::validateIntMax(_descr, "hiLo", hiLo, 1, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateIntRange(_descr, "structure", structure, 0, PotStruct_Last, _checker, __FILE__, __LINE__);
	BYTE maxPlayersMin; _jparser.validateByNameThrow("maxPlayersMin", maxPlayersMin);
	AtfValidator::validateIntRange(_descr, "maxPlayersMin", maxPlayersMin, 2, 1000000, _checker, __FILE__, __LINE__);
	BYTE maxPlayersMax; _jparser.validateByNameThrow("maxPlayersMax", maxPlayersMax);
	AtfValidator::validateIntRange(_descr, "maxPlayersMax", maxPlayersMax, 2, 1000000, _checker, __FILE__, __LINE__);
	INT64 minLoBet; _jparser.validateByNameThrow("minLoBet", minLoBet);
	AtfValidator::validateIntMax(_descr, "minLoBet", minLoBet, 2000000000, _checker, __FILE__, __LINE__);
	INT64 minHiBet; _jparser.validateByNameThrow("minHiBet", minHiBet);
	AtfValidator::validateIntMax(_descr, "minHiBet", minHiBet, 2000000000, _checker, __FILE__, __LINE__);
	INT64 maxLoBet; _jparser.validateByNameThrow("maxLoBet", maxLoBet);
	AtfValidator::validateIntMax(_descr, "maxLoBet", maxLoBet, 2000000000, _checker, __FILE__, __LINE__);
	INT64 maxHiBet; _jparser.validateByNameThrow("maxHiBet", maxHiBet);
	AtfValidator::validateIntMax(_descr, "maxHiBet", maxHiBet, 2000000000, _checker, __FILE__, __LINE__);
	bool capOn; _jparser.validateByNameThrow("capOn", capOn);
	AtfValidator::validateInt(_descr, "capOn", capOn, _checker, __FILE__, __LINE__);
	BYTE speedBM; _jparser.validateByNameThrow("speedBM", speedBM);
	AtfValidator::validateIntMax(_descr, "speedBM", speedBM, (eSeatManSpeed_Last*2-1), _checker, __FILE__, __LINE__);
	UINT32 currencyBM; _jparser.validateByNameThrow("currencyBM", currencyBM);
	AtfValidator::validateIntMax(_descr, "currencyBM", currencyBM, eSeatManCurrency_Last, _checker, __FILE__, __LINE__);
	BuyInRanges buyInRanges; _jparser.validateByNameThrow("buyInRanges", buyInRanges);
	if(_jparser.parseEnded()) return;
	SeatManAdvSearchCriteria seatManAdvSearchCriteria; _jparser.validateByNameThrow("seatManAdvSearchCriteria", seatManAdvSearchCriteria);
	if(_jparser.parseEnded()) return;
	UINT32 clientReqId; _jparser.validateByNameThrow("clientReqId", clientReqId);
	AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 searchFlags; _jparser.validateByNameThrow("searchFlags", searchFlags);
	AtfValidator::validateIntRange(_descr, "searchFlags", searchFlags, eSeatManFlags_None, eSeatManFlags_Last, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE minPlayers; _parser.parseBYTE(minPlayers);
	AtfValidator::validateIntMax(_descr, "minPlayers", minPlayers, 10, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateIntRange(_descr, "game", game, 1, HandType_Last, _checker, __FILE__, __LINE__);
	BYTE hiLo; _parser.parseBYTE(hiLo);
	AtfValidator::validateIntMax(_descr, "hiLo", hiLo, 1, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateIntRange(_descr, "structure", structure, 0, PotStruct_Last, _checker, __FILE__, __LINE__);
	BYTE maxPlayersMin; _parser.parseBYTE(maxPlayersMin);
	AtfValidator::validateIntRange(_descr, "maxPlayersMin", maxPlayersMin, 2, 1000000, _checker, __FILE__, __LINE__);
	BYTE maxPlayersMax; _parser.parseBYTE(maxPlayersMax);
	AtfValidator::validateIntRange(_descr, "maxPlayersMax", maxPlayersMax, 2, 1000000, _checker, __FILE__, __LINE__);
	INT64 minLoBet; _parser.parseINT64(minLoBet);
	AtfValidator::validateIntMax(_descr, "minLoBet", minLoBet, 2000000000, _checker, __FILE__, __LINE__);
	INT64 minHiBet; _parser.parseINT64(minHiBet);
	AtfValidator::validateIntMax(_descr, "minHiBet", minHiBet, 2000000000, _checker, __FILE__, __LINE__);
	INT64 maxLoBet; _parser.parseINT64(maxLoBet);
	AtfValidator::validateIntMax(_descr, "maxLoBet", maxLoBet, 2000000000, _checker, __FILE__, __LINE__);
	INT64 maxHiBet; _parser.parseINT64(maxHiBet);
	AtfValidator::validateIntMax(_descr, "maxHiBet", maxHiBet, 2000000000, _checker, __FILE__, __LINE__);
	bool capOn; _parser.parseBOOL(capOn);
	AtfValidator::validateInt(_descr, "capOn", capOn, _checker, __FILE__, __LINE__);
	BYTE speedBM; _parser.parseBYTE(speedBM);
	AtfValidator::validateIntMax(_descr, "speedBM", speedBM, (eSeatManSpeed_Last*2-1), _checker, __FILE__, __LINE__);
	UINT32 currencyBM; _parser.parseUINT32(currencyBM);
	AtfValidator::validateIntMax(_descr, "currencyBM", currencyBM, eSeatManCurrency_Last, _checker, __FILE__, __LINE__);
	PString _descbuf;
	BuyInRanges::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("buyInRanges"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	SeatManAdvSearchCriteria::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("seatManAdvSearchCriteria"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	UINT32 clientReqId; _parser.parseUINT32(clientReqId);
	AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 searchFlags; _parser.parseUINT32(searchFlags);
	AtfValidator::validateIntRange(_descr, "searchFlags", searchFlags, eSeatManFlags_None, eSeatManFlags_Last, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_BUYIN_LIMIT
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT::clear()
{
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT::equals(const Protocol_MSG_LOBBY_GET_BUYIN_LIMIT& _o) const
{
	return true;
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_BUYIN_LIMIT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_BUYIN_LIMIT*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_BUYIN_LIMIT).append(")");
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_BUYIN_LIMIT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT::parseMsg(CommMsgParser& _parser)
{
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_BUYIN_LIMIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_BUYIN_LIMIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY(Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, limit(std::move(_o.limit))
	, autoLimitHour(std::move(_o.autoLimitHour))
{
}

Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY& Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY::operator=(Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		limit = std::move(_o.limit);
		autoLimitHour = std::move(_o.autoLimitHour);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	limit = 0;
	autoLimitHour = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY::equals(const Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		limit == _o.limit &&
		autoLimitHour == _o.autoLimitHour;
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_BUYIN_LIMIT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_BUYIN_LIMIT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("limit=");
		_buf.appendInt(limit);
		_buf.append(',');
		_buf.append("autoLimitHour=");
		_buf.appendUint(autoLimitHour);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_BUYIN_LIMIT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("limit", limit, _buf);
		Atf::XmlElement::encodeAsXmlElement("autoLimitHour", autoLimitHour, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("limit"))
			{
				limit = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("autoLimitHour"))
			{
				autoLimitHour = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(limit);
		_msg.composeUINT32(autoLimitHour);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(limit);
		_parser.parseUINT32(autoLimitHour);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("limit", limit);
		_jsonstr.compose("autoLimitHour", autoLimitHour);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("limit", limit);
		_jparser.parseByNameThrow("autoLimitHour", autoLimitHour);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_BUYIN_LIMIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 limit; _jparser.validateByNameThrow("limit", limit);
		AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
		UINT32 autoLimitHour; _jparser.validateByNameThrow("autoLimitHour", autoLimitHour);
		AtfValidator::validateInt(_descr, "autoLimitHour", autoLimitHour, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_BUYIN_LIMIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 limit; _parser.parseINT32(limit);
		AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
		UINT32 autoLimitHour; _parser.parseUINT32(autoLimitHour);
		AtfValidator::validateInt(_descr, "autoLimitHour", autoLimitHour, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SET_BUYIN_LIMIT
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT::clear()
{
	limit = 0;
	flags = 0;
	flagsEx = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT::equals(const Protocol_MSG_LOBBY_SET_BUYIN_LIMIT& _o) const
{
	return limit == _o.limit &&
		flags == _o.flags &&
		flagsEx == _o.flagsEx;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_SET_BUYIN_LIMIT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_SET_BUYIN_LIMIT*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SET_BUYIN_LIMIT).append(")");
	_buf.append(',');
	_buf.append("limit=");
	_buf.appendInt(limit);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("flagsEx=");
	_buf.appendUint64(flagsEx);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_SET_BUYIN_LIMIT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("limit", limit, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	Atf::XmlElement::encodeAsXmlElement("flagsEx", flagsEx, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("limit"))
			{
				limit = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("flags"))
			{
				flags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("flagsEx"))
			{
				flagsEx = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(limit);
	_msg.composeUINT32(flags);
	_msg.composeUINT64(flagsEx);
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(limit);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(flags);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(flagsEx);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("limit", limit);
	_jsonstr.compose("flags", flags);
	_jsonstr.compose("flagsEx", flagsEx);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("limit", limit);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("flags", flags);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("flagsEx", flagsEx);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_BUYIN_LIMIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 limit; _jparser.validateByNameThrow("limit", limit);
	AtfValidator::validateIntMin(_descr, "limit", limit, -1, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT64 flagsEx; _jparser.validateByNameThrow("flagsEx", flagsEx);
	AtfValidator::validateUint(_descr, "flagsEx", flagsEx, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_BUYIN_LIMIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 limit; _parser.parseINT32(limit);
	AtfValidator::validateIntMin(_descr, "limit", limit, -1, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 flags; _parser.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 flagsEx; _parser.parseUINT64(flagsEx);
	AtfValidator::validateUint(_descr, "flagsEx", flagsEx, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY(Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, effectiveNow(std::move(_o.effectiveNow))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY& Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY::operator=(Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		effectiveNow = std::move(_o.effectiveNow);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	effectiveNow = false;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY::equals(const Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		effectiveNow == _o.effectiveNow;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_SET_BUYIN_LIMIT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SET_BUYIN_LIMIT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("effectiveNow=");
		_buf.appendUint(effectiveNow);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_SET_BUYIN_LIMIT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("effectiveNow", effectiveNow, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("effectiveNow"))
			{
				effectiveNow = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeBOOL(effectiveNow);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseBOOL(effectiveNow);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("effectiveNow", effectiveNow);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("effectiveNow", effectiveNow);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_BUYIN_LIMIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		bool effectiveNow; _jparser.validateByNameThrow("effectiveNow", effectiveNow);
		AtfValidator::validateInt(_descr, "effectiveNow", effectiveNow, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_BUYIN_LIMIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool effectiveNow; _parser.parseBOOL(effectiveNow);
		AtfValidator::validateInt(_descr, "effectiveNow", effectiveNow, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX::clear()
{
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX::equals(const Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX& _o) const
{
	return true;
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_BUYIN_LIMIT_EX != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_BUYIN_LIMIT_EX).append(")");
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_BUYIN_LIMIT_EX).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX::parseMsg(CommMsgParser& _parser)
{
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_BUYIN_LIMIT_EX";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_BUYIN_LIMIT_EX";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    LimitEx
//=================================================================

Lobby::cli::LimitEx::LimitEx()
{
	clear();
}

void Lobby::cli::LimitEx::clear()
{
	limitType = 0;
	amount = 0;
}

bool Lobby::cli::LimitEx::equals(const LimitEx& _o) const
{
	return limitType == _o.limitType &&
		amount == _o.amount;
}

const char *Lobby::cli::LimitEx::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("limitType=");
	_buf.appendInt(limitType);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendInt(amount);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::LimitEx::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("limitType", limitType, _buf);
	Atf::XmlElement::encodeAsXmlElement("amount", amount, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::LimitEx::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("limitType"))
		{
			limitType = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("amount"))
		{
			amount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::LimitEx::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(LimitEx())) // not empty
	{
		_body.composeINT32(limitType);
		_body.composeINT32(amount);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::cli::LimitEx::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(limitType);
	_parser0.parseINT32(amount);
}

const char *Lobby::cli::LimitEx::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("limitType", limitType);
	_jsonstr.compose("amount", amount);
	return _buf.c_str();
}

void Lobby::cli::LimitEx::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("limitType", limitType);
	_jparser.parseByNameThrow("amount", amount);
}

/* static */ void Lobby::cli::LimitEx::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 limitType; _jparser.validateByNameThrow("limitType", limitType);
	AtfValidator::validateIntRange(_descr, "limitType", limitType, 0, 1000, _checker, __FILE__, __LINE__);
	INT32 amount; _jparser.validateByNameThrow("amount", amount);
	AtfValidator::validateIntMin(_descr, "amount", amount, -1, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::LimitEx::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 limitType; _parser0.parseINT32(limitType);
	AtfValidator::validateIntRange(_descr, "limitType", limitType, 0, 1000, _checker, __FILE__, __LINE__);
	INT32 amount; _parser0.parseINT32(amount);
	AtfValidator::validateIntMin(_descr, "amount", amount, -1, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY(Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, limitEx(std::move(_o.limitEx))
{
}

Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY& Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY::operator=(Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		limitEx = std::move(_o.limitEx);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	limitEx.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY::equals(const Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		limitEx.equals(_o.limitEx);
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("limitEx=");
		limitEx.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		limitEx.toXmlString("limitEx", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("limitEx"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< LimitEx, 2 > >::FromXmlString(_value, limitEx)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		limitEx.composeMsg(_msg, _ignoreJSON);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		limitEx.parseMsg(_parser);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("limitEx", limitEx);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("limitEx", limitEx);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< LimitEx > limitEx; _jparser.validateByNameThrow("limitEx", limitEx);
		AtfValidator::validateInt(_descr, "limitEx", limitEx.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szLimitEx = Atf::LAtfVector< LimitEx, 2 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("limitEx"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "limitEx", szLimitEx, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX(Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX&& _o)
	: limitEx(std::move(_o.limitEx))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX& Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX::operator=(Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX&& _o)
{
	if(this != &_o)
	{
		limitEx = std::move(_o.limitEx);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX::clear()
{
	limitEx.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX::equals(const Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX& _o) const
{
	return limitEx.equals(_o.limitEx);
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_SET_BUYIN_LIMIT_EX != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SET_BUYIN_LIMIT_EX).append(")");
	_buf.append(',');
	_buf.append("limitEx=");
	limitEx.toTraceString(_buf);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_SET_BUYIN_LIMIT_EX).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	limitEx.toXmlString("limitEx", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("limitEx"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< LimitEx, 2 > >::FromXmlString(_value, limitEx)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	limitEx.composeMsg(_msg, _ignoreJSON);
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX::parseMsg(CommMsgParser& _parser)
{
	limitEx.parseMsg(_parser);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("limitEx", limitEx);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("limitEx", limitEx);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_BUYIN_LIMIT_EX";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< LimitEx > limitEx; _jparser.validateByNameThrow("limitEx", limitEx);
	AtfValidator::validateIntMax(_descr, "limitEx", limitEx.size(), 10000, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_BUYIN_LIMIT_EX";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szLimitEx = Atf::LAtfVector< LimitEx, 2 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("limitEx"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "limitEx", szLimitEx, 10000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    LimitExReply
//=================================================================

Lobby::cli::LimitExReply::LimitExReply()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::LimitExReply::LimitExReply(LimitExReply&& _o)
	: limitType(std::move(_o.limitType))
	, errCodeLimit(std::move(_o.errCodeLimit))
	, errMsg(std::move(_o.errMsg))
	, amount(std::move(_o.amount))
	, effectiveNow(std::move(_o.effectiveNow))
{
}

Lobby::cli::LimitExReply& Lobby::cli::LimitExReply::operator=(LimitExReply&& _o)
{
	if(this != &_o)
	{
		limitType = std::move(_o.limitType);
		errCodeLimit = std::move(_o.errCodeLimit);
		errMsg = std::move(_o.errMsg);
		amount = std::move(_o.amount);
		effectiveNow = std::move(_o.effectiveNow);
	}
	return *this;
}

#endif

void Lobby::cli::LimitExReply::clear()
{
	limitType = 0;
	errCodeLimit = 0;
	errMsg.clear();
	amount = 0;
	effectiveNow = false;
}

bool Lobby::cli::LimitExReply::equals(const LimitExReply& _o) const
{
	return limitType == _o.limitType &&
		errCodeLimit == _o.errCodeLimit &&
		Atf::atfPStringEquals(errMsg, _o.errMsg) &&
		amount == _o.amount &&
		effectiveNow == _o.effectiveNow;
}

const char *Lobby::cli::LimitExReply::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("limitType=");
	_buf.appendInt(limitType);
	_buf.append(',');
	_buf.append("errCodeLimit=");
	_buf.appendInt(errCodeLimit);
	if(errCodeLimit)
	{
		_buf.append(',');
		_buf.append("errMsg=");
		_buf.append(errMsg);
	}
	else
	{
		_buf.append(',');
		_buf.append("amount=");
		_buf.appendInt(amount);
		_buf.append(',');
		_buf.append("effectiveNow=");
		_buf.appendUint(effectiveNow);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::LimitExReply::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("limitType", limitType, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCodeLimit", errCodeLimit, _buf);
	if(errCodeLimit)
	{
		Atf::XmlElement::encodeAsXmlElement("errMsg", errMsg, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("amount", amount, _buf);
		Atf::XmlElement::encodeAsXmlElement("effectiveNow", effectiveNow, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::LimitExReply::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("limitType"))
		{
			limitType = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("errCodeLimit"))
		{
			errCodeLimit = (INT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("errMsg"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, errMsg)) return false;
		}
		else if (_element.equals("amount"))
		{
			amount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("effectiveNow"))
		{
			effectiveNow = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::LimitExReply::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(LimitExReply())) // not empty
	{
		_body.composeINT32(limitType);
		_body.composeINT16(errCodeLimit);
		if(errCodeLimit)
		{
			_body.composeString(errMsg);
		}
		else
		{
			_body.composeINT32(amount);
			_body.composeBOOL(effectiveNow);
		}
	}

	_msg.composeMsgBody(_body);
}

void Lobby::cli::LimitExReply::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(limitType);
	_parser0.parseINT16(errCodeLimit);
	if(errCodeLimit)
	{
		_parser0.parseStringP(errMsg);
	}
	else
	{
		_parser0.parseINT32(amount);
		_parser0.parseBOOL(effectiveNow);
	}
}

const char *Lobby::cli::LimitExReply::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("limitType", limitType);
	_jsonstr.compose("errCodeLimit", errCodeLimit);
	if(errCodeLimit)
	{
		_jsonstr.compose("errMsg", errMsg);
	}
	else
	{
		_jsonstr.compose("amount", amount);
		_jsonstr.compose("effectiveNow", effectiveNow);
	}
	return _buf.c_str();
}

void Lobby::cli::LimitExReply::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("limitType", limitType);
	_jparser.parseByNameThrow("errCodeLimit", errCodeLimit);
	if(errCodeLimit)
	{
		_jparser.parseByNameThrow("errMsg", errMsg);
	}
	else
	{
		_jparser.parseByNameThrow("amount", amount);
		_jparser.parseByNameThrow("effectiveNow", effectiveNow);
	}
}

/* static */ void Lobby::cli::LimitExReply::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCodeLimit = 0;
	INT32 limitType; _jparser.validateByNameThrow("limitType", limitType);
	AtfValidator::validateInt(_descr, "limitType", limitType, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("errCodeLimit", errCodeLimit);
	AtfValidator::validateInt(_descr, "errCodeLimit", errCodeLimit, _checker, __FILE__, __LINE__);
	if(errCodeLimit)
	{
		PString errMsg; _jparser.validateByNameThrow("errMsg", errMsg);
		AtfValidator::validateInt(_descr, "errMsg", errMsg.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 amount; _jparser.validateByNameThrow("amount", amount);
		AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
		bool effectiveNow; _jparser.validateByNameThrow("effectiveNow", effectiveNow);
		AtfValidator::validateInt(_descr, "effectiveNow", effectiveNow, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::LimitExReply::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	INT16 errCodeLimit = 0;
	INT32 limitType; _parser0.parseINT32(limitType);
	AtfValidator::validateInt(_descr, "limitType", limitType, _checker, __FILE__, __LINE__);
	_parser0.parseINT16(errCodeLimit);
	AtfValidator::validateInt(_descr, "errCodeLimit", errCodeLimit, _checker, __FILE__, __LINE__);
	if(errCodeLimit)
	{
		_parser0.parseStringN(_dummy, 0, "errMsg"); size_t szErrMsg = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errMsg", szErrMsg, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 amount; _parser0.parseINT32(amount);
		AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
		bool effectiveNow; _parser0.parseBOOL(effectiveNow);
		AtfValidator::validateInt(_descr, "effectiveNow", effectiveNow, _checker, __FILE__, __LINE__);
	}
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY(Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, limitExReply(std::move(_o.limitExReply))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY& Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY::operator=(Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		limitExReply = std::move(_o.limitExReply);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	limitExReply.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY::equals(const Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		limitExReply.equals(_o.limitExReply);
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("limitExReply=");
		limitExReply.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		limitExReply.toXmlString("limitExReply", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("limitExReply"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< LimitExReply, 4 > >::FromXmlString(_value, limitExReply)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		limitExReply.composeMsg(_msg, _ignoreJSON);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		limitExReply.parseMsg(_parser);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("limitExReply", limitExReply);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("limitExReply", limitExReply);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< LimitExReply > limitExReply; _jparser.validateByNameThrow("limitExReply", limitExReply);
		AtfValidator::validateInt(_descr, "limitExReply", limitExReply.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szLimitExReply = Atf::LAtfVector< LimitExReply, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("limitExReply"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "limitExReply", szLimitExReply, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_HISTORY_REQUEST
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST::Protocol_MSG_LOBBY_HISTORY_REQUEST()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST::Protocol_MSG_LOBBY_HISTORY_REQUEST(Protocol_MSG_LOBBY_HISTORY_REQUEST&& _o)
	: notUsed(std::move(_o.notUsed))
	, type(std::move(_o.type))
	, numRequested(std::move(_o.numRequested))
	, handId(std::move(_o.handId))
	, handId64(std::move(_o.handId64))
	, locale(std::move(_o.locale))
{
}

Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST& Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST::operator=(Protocol_MSG_LOBBY_HISTORY_REQUEST&& _o)
{
	if(this != &_o)
	{
		notUsed = std::move(_o.notUsed);
		type = std::move(_o.type);
		numRequested = std::move(_o.numRequested);
		handId = std::move(_o.handId);
		handId64 = std::move(_o.handId64);
		locale = std::move(_o.locale);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST::clear()
{
	notUsed.clear();
	type = 0;
	numRequested = 0;
	handId = 0;
	handId64 = 0;
	locale = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST::equals(const Protocol_MSG_LOBBY_HISTORY_REQUEST& _o) const
{
	return Atf::atfPStringEquals(notUsed, _o.notUsed) &&
		type == _o.type &&
		numRequested == _o.numRequested &&
		handId == _o.handId &&
		handId64 == _o.handId64 &&
		locale == _o.locale;
}

bool Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_HISTORY_REQUEST != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_HISTORY_REQUEST*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_HISTORY_REQUEST).append(")");
	_buf.append(',');
	_buf.append("notUsed=");
	_buf.append(notUsed);
	_buf.append(',');
	_buf.append("type=");
	_buf.appendInt(type);
	if(type == HAND_HISTORY_LAST_HANDS)
	{
		_buf.append(',');
		_buf.append("numRequested=");
		_buf.appendUint(numRequested);
	}
	else if (type == HAND_HISTORY_LAST_SECONDS)
	{
		_buf.append(',');
		_buf.append("numRequested=");
		_buf.appendUint(numRequested);
	}
	else if (type == HAND_HISTORY_TOURNAMENT)
	{
		_buf.append(',');
		_buf.append("numRequested=");
		_buf.appendUint(numRequested);
	}
	else if (type == HAND_HISTORY_HAND_IDS)
	{
		_buf.append(',');
		_buf.append("numRequested=");
		_buf.appendUint(numRequested);
		_buf.append(',');
		_buf.append("handId=");
		_buf.appendUint(handId);
		_buf.append(',');
		_buf.append("handId64=");
		_buf.appendUint64(handId64);
	}
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_HISTORY_REQUEST).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsed", notUsed, _buf);
	Atf::XmlElement::encodeAsXmlElement("type", type, _buf);
	if(type == HAND_HISTORY_LAST_HANDS)
	{
		Atf::XmlElement::encodeAsXmlElement("numRequested", numRequested, _buf);
	}
	else if (type == HAND_HISTORY_LAST_SECONDS)
	{
		Atf::XmlElement::encodeAsXmlElement("numRequested", numRequested, _buf);
	}
	else if (type == HAND_HISTORY_TOURNAMENT)
	{
		Atf::XmlElement::encodeAsXmlElement("numRequested", numRequested, _buf);
	}
	else if (type == HAND_HISTORY_HAND_IDS)
	{
		Atf::XmlElement::encodeAsXmlElement("numRequested", numRequested, _buf);
		Atf::XmlElement::encodeAsXmlElement("handId", handId, _buf);
		Atf::XmlElement::encodeAsXmlElement("handId64", handId64, _buf);
	}
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsed"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsed)) return false;
			}
			else if (_element.equals("type"))
			{
				type = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("numRequested"))
			{
				numRequested = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("handId"))
			{
				handId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("handId64"))
			{
				handId64 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("locale"))
			{
				locale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsed);
	_msg.composeINT8(type);
	if(type == HAND_HISTORY_LAST_HANDS)
	{
		_msg.composeUINT32(numRequested);
	}
	else if (type == HAND_HISTORY_LAST_SECONDS)
	{
		_msg.composeUINT32(numRequested);
	}
	else if (type == HAND_HISTORY_TOURNAMENT)
	{
		_msg.composeUINT32(numRequested);
	}
	else if (type == HAND_HISTORY_HAND_IDS)
	{
		_msg.composeUINT32(numRequested);
		_msg.composeUINT32(handId);
		_msg.composeUINT64(handId64);
	}
	_msg.composeUINT32(locale);
}

void Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsed);
	_parser.parseINT8(type);
	if(type == HAND_HISTORY_LAST_HANDS)
	{
		_parser.parseUINT32(numRequested);
	}
	else if (type == HAND_HISTORY_LAST_SECONDS)
	{
		_parser.parseUINT32(numRequested);
	}
	else if (type == HAND_HISTORY_TOURNAMENT)
	{
		_parser.parseUINT32(numRequested);
	}
	else if (type == HAND_HISTORY_HAND_IDS)
	{
		_parser.parseUINT32(numRequested);
		_parser.parseUINT32(handId);
		if(_parser.parseEnded()) return;
		_parser.parseUINT64(handId64);
	}
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(locale);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsed", notUsed);
	_jsonstr.compose("type", type);
	if(type == HAND_HISTORY_LAST_HANDS)
	{
		_jsonstr.compose("numRequested", numRequested);
	}
	else if (type == HAND_HISTORY_LAST_SECONDS)
	{
		_jsonstr.compose("numRequested", numRequested);
	}
	else if (type == HAND_HISTORY_TOURNAMENT)
	{
		_jsonstr.compose("numRequested", numRequested);
	}
	else if (type == HAND_HISTORY_HAND_IDS)
	{
		_jsonstr.compose("numRequested", numRequested);
		_jsonstr.compose("handId", handId);
		_jsonstr.compose("handId64", handId64);
	}
	_jsonstr.compose("locale", locale);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsed", notUsed);
	_jparser.parseByNameThrow("type", type);
	if(type == HAND_HISTORY_LAST_HANDS)
	{
		_jparser.parseByNameThrow("numRequested", numRequested);
	}
	else if (type == HAND_HISTORY_LAST_SECONDS)
	{
		_jparser.parseByNameThrow("numRequested", numRequested);
	}
	else if (type == HAND_HISTORY_TOURNAMENT)
	{
		_jparser.parseByNameThrow("numRequested", numRequested);
	}
	else if (type == HAND_HISTORY_HAND_IDS)
	{
		_jparser.parseByNameThrow("numRequested", numRequested);
		_jparser.parseByNameThrow("handId", handId);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("handId64", handId64);
	}
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("locale", locale);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_HISTORY_REQUEST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT8 type = 0;
	PString notUsed; _jparser.validateByNameThrow("notUsed", notUsed);
	AtfValidator::validateIntMax(_descr, "notUsed", notUsed.length(), 20, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("type", type);
	AtfValidator::validateIntRange(_descr, "type", type, HAND_HISTORY_LAST_HANDS, HAND_HISTORY_TOURNAMENT, _checker, __FILE__, __LINE__);
	if(type == HAND_HISTORY_LAST_HANDS)
	{
		UINT32 numRequested; _jparser.validateByNameThrow("numRequested", numRequested);
		AtfValidator::validateIntRange(_descr, "numRequested", numRequested, 1, MAX_HANDS_ALLOWED, _checker, __FILE__, __LINE__);
	}
	else if (type == HAND_HISTORY_LAST_SECONDS)
	{
		UINT32 numRequested; _jparser.validateByNameThrow("numRequested", numRequested);
		AtfValidator::validateIntRange(_descr, "numRequested", numRequested, 1, 604800, _checker, __FILE__, __LINE__);
	}
	else if (type == HAND_HISTORY_TOURNAMENT)
	{
		UINT32 numRequested; _jparser.validateByNameThrow("numRequested", numRequested);
		AtfValidator::validateInt(_descr, "numRequested", numRequested, _checker, __FILE__, __LINE__);
	}
	else if (type == HAND_HISTORY_HAND_IDS)
	{
		UINT32 numRequested; _jparser.validateByNameThrow("numRequested", numRequested);
		AtfValidator::validateIntRange(_descr, "numRequested", numRequested, 1, 1, _checker, __FILE__, __LINE__);
		UINT32 handId; _jparser.validateByNameThrow("handId", handId);
		AtfValidator::validateInt(_descr, "handId", handId, _checker, __FILE__, __LINE__);
		if(_jparser.parseEnded()) return;
		UINT64 handId64; _jparser.validateByNameThrow("handId64", handId64);
		AtfValidator::validateUint(_descr, "handId64", handId64, _checker, __FILE__, __LINE__);
	}
	if(_jparser.parseEnded()) return;
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntRange(_descr, "locale", locale, LOCALE_DEFAULT, MAX_LOCALES, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_HISTORY_REQUEST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT8 type = 0;
	_parser.parseStringN(_dummy, 0, "notUsed"); size_t szNotUsed = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsed", szNotUsed, 20, _checker, __FILE__, __LINE__);
	_parser.parseINT8(type);
	AtfValidator::validateIntRange(_descr, "type", type, HAND_HISTORY_LAST_HANDS, HAND_HISTORY_TOURNAMENT, _checker, __FILE__, __LINE__);
	if(type == HAND_HISTORY_LAST_HANDS)
	{
		UINT32 numRequested; _parser.parseUINT32(numRequested);
		AtfValidator::validateIntRange(_descr, "numRequested", numRequested, 1, MAX_HANDS_ALLOWED, _checker, __FILE__, __LINE__);
	}
	else if (type == HAND_HISTORY_LAST_SECONDS)
	{
		UINT32 numRequested; _parser.parseUINT32(numRequested);
		AtfValidator::validateIntRange(_descr, "numRequested", numRequested, 1, 604800, _checker, __FILE__, __LINE__);
	}
	else if (type == HAND_HISTORY_TOURNAMENT)
	{
		UINT32 numRequested; _parser.parseUINT32(numRequested);
		AtfValidator::validateInt(_descr, "numRequested", numRequested, _checker, __FILE__, __LINE__);
	}
	else if (type == HAND_HISTORY_HAND_IDS)
	{
		UINT32 numRequested; _parser.parseUINT32(numRequested);
		AtfValidator::validateIntRange(_descr, "numRequested", numRequested, 1, 1, _checker, __FILE__, __LINE__);
		UINT32 handId; _parser.parseUINT32(handId);
		AtfValidator::validateInt(_descr, "handId", handId, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		UINT64 handId64; _parser.parseUINT64(handId64);
		AtfValidator::validateUint(_descr, "handId64", handId64, _checker, __FILE__, __LINE__);
	}
	if(_parser.parseEnded()) return;
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntRange(_descr, "locale", locale, LOCALE_DEFAULT, MAX_LOCALES, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY::Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY::Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY(Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, email(std::move(_o.email))
{
}

Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY& Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY::operator=(Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		email = std::move(_o.email);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	email.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY::equals(const Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(email, _o.email);
}

bool Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_HISTORY_REQUEST_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_HISTORY_REQUEST_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("email=");
		_buf.append(email);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_HISTORY_REQUEST_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("email", email, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("email"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, email)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(email);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(email);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("email", email);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("email", email);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_HISTORY_REQUEST_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString email; _jparser.validateByNameThrow("email", email);
		AtfValidator::validateInt(_descr, "email", email.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_HISTORY_REQUEST_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
		AtfValidator::validateInt(_descr, "email", szEmail, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT(Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT&& _o)
	: notUsed(std::move(_o.notUsed))
	, unique(std::move(_o.unique))
{
}

Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT& Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT::operator=(Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT&& _o)
{
	if(this != &_o)
	{
		notUsed = std::move(_o.notUsed);
		unique = std::move(_o.unique);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT::clear()
{
	notUsed.clear();
	unique = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT::equals(const Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT& _o) const
{
	return Atf::atfPStringEquals(notUsed, _o.notUsed) &&
		unique == _o.unique;
}

bool Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_ACTIVATE_ACCOUNT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_ACTIVATE_ACCOUNT).append(")");
	_buf.append(',');
	_buf.append("notUsed=");
	_buf.append(notUsed);
	_buf.append(',');
	_buf.append("unique=");
	_buf.appendUint(unique);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_ACTIVATE_ACCOUNT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsed", notUsed, _buf);
	Atf::XmlElement::encodeAsXmlElement("unique", unique, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsed"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsed)) return false;
			}
			else if (_element.equals("unique"))
			{
				unique = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsed);
	_msg.composeUINT32(unique);
}

void Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsed);
	_parser.parseUINT32(unique);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsed", notUsed);
	_jsonstr.compose("unique", unique);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsed", notUsed);
	_jparser.parseByNameThrow("unique", unique);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_ACTIVATE_ACCOUNT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsed; _jparser.validateByNameThrow("notUsed", notUsed);
	AtfValidator::validateIntMax(_descr, "notUsed", notUsed.length(), 20, _checker, __FILE__, __LINE__);
	UINT32 unique; _jparser.validateByNameThrow("unique", unique);
	AtfValidator::validateInt(_descr, "unique", unique, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_ACTIVATE_ACCOUNT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsed"); size_t szNotUsed = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsed", szNotUsed, 20, _checker, __FILE__, __LINE__);
	UINT32 unique; _parser.parseUINT32(unique);
	AtfValidator::validateInt(_descr, "unique", unique, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY(Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, firstTimeActivation(std::move(_o.firstTimeActivation))
	, siteId(std::move(_o.siteId))
	, promoName(std::move(_o.promoName))
	, usePromoDeposit(std::move(_o.usePromoDeposit))
	, email(std::move(_o.email))
	, country(std::move(_o.country))
	, locale(std::move(_o.locale))
{
}

Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY& Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY::operator=(Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		firstTimeActivation = std::move(_o.firstTimeActivation);
		siteId = std::move(_o.siteId);
		promoName = std::move(_o.promoName);
		usePromoDeposit = std::move(_o.usePromoDeposit);
		email = std::move(_o.email);
		country = std::move(_o.country);
		locale = std::move(_o.locale);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	firstTimeActivation = false;
	siteId = 0;
	promoName.clear();
	usePromoDeposit = false;
	email.clear();
	country.clear();
	locale = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY::equals(const Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		firstTimeActivation == _o.firstTimeActivation &&
		siteId == _o.siteId &&
		Atf::atfPStringEquals(promoName, _o.promoName) &&
		usePromoDeposit == _o.usePromoDeposit &&
		Atf::atfPStringEquals(email, _o.email) &&
		Atf::atfPStringEquals(country, _o.country) &&
		locale == _o.locale;
}

bool Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("firstTimeActivation=");
		_buf.appendUint(firstTimeActivation);
		_buf.append(',');
		_buf.append("siteId=");
		_buf.appendUint(siteId);
		_buf.append(',');
		_buf.append("promoName=");
		_buf.append(promoName);
		_buf.append(',');
		_buf.append("usePromoDeposit=");
		_buf.appendUint(usePromoDeposit);
		_buf.append(',');
		_buf.append("email=");
		_buf.append(email);
		_buf.append(',');
		_buf.append("country=");
		_buf.append(country);
		_buf.append(',');
		_buf.append("locale=");
		_buf.appendUint(locale);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("firstTimeActivation", firstTimeActivation, _buf);
		Atf::XmlElement::encodeAsXmlElement("siteId", siteId, _buf);
		Atf::XmlElement::encodeAsXmlElement("promoName", promoName, _buf);
		Atf::XmlElement::encodeAsXmlElement("usePromoDeposit", usePromoDeposit, _buf);
		Atf::XmlElement::encodeAsXmlElement("email", email, _buf);
		Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
		Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("firstTimeActivation"))
			{
				firstTimeActivation = (*_value.ptr() == '1');
			}
			else if (_element.equals("siteId"))
			{
				siteId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("promoName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, promoName)) return false;
			}
			else if (_element.equals("usePromoDeposit"))
			{
				usePromoDeposit = (*_value.ptr() == '1');
			}
			else if (_element.equals("email"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, email)) return false;
			}
			else if (_element.equals("country"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
			}
			else if (_element.equals("locale"))
			{
				locale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeBOOL(firstTimeActivation);
		_msg.composeUINT32(siteId);
		_msg.composeString(promoName);
		_msg.composeBOOL(usePromoDeposit);
		_msg.composeString(email);
		_msg.composeString(country);
		_msg.composeUINT32(locale);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseBOOL(firstTimeActivation);
		_parser.parseUINT32(siteId);
		_parser.parseStringP(promoName);
		_parser.parseBOOL(usePromoDeposit);
		_parser.parseStringP(email);
		_parser.parseStringP(country);
		_parser.parseUINT32(locale);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("firstTimeActivation", firstTimeActivation);
		_jsonstr.compose("siteId", siteId);
		_jsonstr.compose("promoName", promoName);
		_jsonstr.compose("usePromoDeposit", usePromoDeposit);
		_jsonstr.compose("email", email);
		_jsonstr.compose("country", country);
		_jsonstr.compose("locale", locale);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("firstTimeActivation", firstTimeActivation);
		_jparser.parseByNameThrow("siteId", siteId);
		_jparser.parseByNameThrow("promoName", promoName);
		_jparser.parseByNameThrow("usePromoDeposit", usePromoDeposit);
		_jparser.parseByNameThrow("email", email);
		_jparser.parseByNameThrow("country", country);
		_jparser.parseByNameThrow("locale", locale);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		bool firstTimeActivation; _jparser.validateByNameThrow("firstTimeActivation", firstTimeActivation);
		AtfValidator::validateInt(_descr, "firstTimeActivation", firstTimeActivation, _checker, __FILE__, __LINE__);
		UINT32 siteId; _jparser.validateByNameThrow("siteId", siteId);
		AtfValidator::validateInt(_descr, "siteId", siteId, _checker, __FILE__, __LINE__);
		PString promoName; _jparser.validateByNameThrow("promoName", promoName);
		AtfValidator::validateInt(_descr, "promoName", promoName.length(), _checker, __FILE__, __LINE__);
		bool usePromoDeposit; _jparser.validateByNameThrow("usePromoDeposit", usePromoDeposit);
		AtfValidator::validateInt(_descr, "usePromoDeposit", usePromoDeposit, _checker, __FILE__, __LINE__);
		PString email; _jparser.validateByNameThrow("email", email);
		AtfValidator::validateInt(_descr, "email", email.length(), _checker, __FILE__, __LINE__);
		PString country; _jparser.validateByNameThrow("country", country);
		AtfValidator::validateInt(_descr, "country", country.length(), _checker, __FILE__, __LINE__);
		UINT32 locale; _jparser.validateByNameThrow("locale", locale);
		AtfValidator::validateInt(_descr, "locale", locale, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool firstTimeActivation; _parser.parseBOOL(firstTimeActivation);
		AtfValidator::validateInt(_descr, "firstTimeActivation", firstTimeActivation, _checker, __FILE__, __LINE__);
		UINT32 siteId; _parser.parseUINT32(siteId);
		AtfValidator::validateInt(_descr, "siteId", siteId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "promoName"); size_t szPromoName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "promoName", szPromoName, _checker, __FILE__, __LINE__);
		bool usePromoDeposit; _parser.parseBOOL(usePromoDeposit);
		AtfValidator::validateInt(_descr, "usePromoDeposit", usePromoDeposit, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
		AtfValidator::validateInt(_descr, "email", szEmail, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
		AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
		UINT32 locale; _parser.parseUINT32(locale);
		AtfValidator::validateInt(_descr, "locale", locale, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CANCEL_USERTOURN
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN::Protocol_MSG_LOBBY_CANCEL_USERTOURN()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN::Protocol_MSG_LOBBY_CANCEL_USERTOURN(Protocol_MSG_LOBBY_CANCEL_USERTOURN&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, tournId(std::move(_o.tournId))
{
}

Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN& Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN::operator=(Protocol_MSG_LOBBY_CANCEL_USERTOURN&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		tournId = std::move(_o.tournId);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN::clear()
{
	notUsedStr.clear();
	tournId = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN::equals(const Protocol_MSG_LOBBY_CANCEL_USERTOURN& _o) const
{
	return Atf::atfPStringEquals(notUsedStr, _o.notUsedStr) &&
		tournId == _o.tournId;
}

bool Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_CANCEL_USERTOURN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_CANCEL_USERTOURN*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CANCEL_USERTOURN).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_CANCEL_USERTOURN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsedStr", notUsedStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedStr)) return false;
			}
			else if (_element.equals("tournId"))
			{
				tournId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsedStr);
	_msg.composeUINT32(tournId);
}

void Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseUINT32(tournId);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsedStr", notUsedStr);
	_jsonstr.compose("tournId", tournId);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsedStr", notUsedStr);
	_jparser.parseByNameThrow("tournId", tournId);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CANCEL_USERTOURN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsedStr; _jparser.validateByNameThrow("notUsedStr", notUsedStr);
	AtfValidator::validateIntMax(_descr, "notUsedStr", notUsedStr.length(), 20, _checker, __FILE__, __LINE__);
	UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CANCEL_USERTOURN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY::Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY::Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY(Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY& Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY::operator=(Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY::equals(const Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_CANCEL_USERTOURN_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CANCEL_USERTOURN_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errDescr=");
	_buf.append(errDescr);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_CANCEL_USERTOURN_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errDescr);
}

void Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(errDescr);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errDescr", errDescr);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errDescr", errDescr);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CANCEL_USERTOURN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
	AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CANCEL_USERTOURN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CLIENT_QUEST
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_CLIENT_QUEST::Protocol_MSG_LOBBY_CLIENT_QUEST()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_CLIENT_QUEST::Protocol_MSG_LOBBY_CLIENT_QUEST(Protocol_MSG_LOBBY_CLIENT_QUEST&& _o)
	: type(std::move(_o.type))
	, descr(std::move(_o.descr))
	, fpp(std::move(_o.fpp))
{
}

Lobby::cli::Protocol_MSG_LOBBY_CLIENT_QUEST& Lobby::cli::Protocol_MSG_LOBBY_CLIENT_QUEST::operator=(Protocol_MSG_LOBBY_CLIENT_QUEST&& _o)
{
	if(this != &_o)
	{
		type = std::move(_o.type);
		descr = std::move(_o.descr);
		fpp = std::move(_o.fpp);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_CLIENT_QUEST::clear()
{
	type = 0;
	descr.clear();
	fpp = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLIENT_QUEST::equals(const Protocol_MSG_LOBBY_CLIENT_QUEST& _o) const
{
	return type == _o.type &&
		Atf::atfPStringEquals(descr, _o.descr) &&
		fpp == _o.fpp;
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLIENT_QUEST::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_CLIENT_QUEST != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_CLIENT_QUEST*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLIENT_QUEST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CLIENT_QUEST).append(")");
	_buf.append(',');
	_buf.append("type=");
	_buf.appendUint(type);
	_buf.append(',');
	_buf.append("descr=");
	_buf.append(descr);
	_buf.append(',');
	_buf.append("fpp=");
	_buf.appendUint(fpp);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLIENT_QUEST::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLIENT_QUEST::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_CLIENT_QUEST).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("type", type, _buf);
	Atf::XmlElement::encodeAsXmlElement("descr", descr, _buf);
	Atf::XmlElement::encodeAsXmlElement("fpp", fpp, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLIENT_QUEST::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("type"))
			{
				type = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("descr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, descr)) return false;
			}
			else if (_element.equals("fpp"))
			{
				fpp = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_CLIENT_QUEST::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(type);
	_msg.composeString(descr);
	_msg.composeUINT32(fpp);
}

void Lobby::cli::Protocol_MSG_LOBBY_CLIENT_QUEST::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(type);
	_parser.parseStringP(descr);
	_parser.parseUINT32(fpp);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLIENT_QUEST::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("type", type);
	_jsonstr.compose("descr", descr);
	_jsonstr.compose("fpp", fpp);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_CLIENT_QUEST::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("type", type);
	_jparser.parseByNameThrow("descr", descr);
	_jparser.parseByNameThrow("fpp", fpp);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CLIENT_QUEST::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLIENT_QUEST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 type; _jparser.validateByNameThrow("type", type);
	AtfValidator::validateIntMax(_descr, "type", type, 1000000, _checker, __FILE__, __LINE__);
	PString descr; _jparser.validateByNameThrow("descr", descr);
	AtfValidator::validateIntMax(_descr, "descr", descr.length(), 200, _checker, __FILE__, __LINE__);
	UINT32 fpp; _jparser.validateByNameThrow("fpp", fpp);
	AtfValidator::validateIntMax(_descr, "fpp", fpp, 2000000000, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CLIENT_QUEST::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLIENT_QUEST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 type; _parser.parseUINT32(type);
	AtfValidator::validateIntMax(_descr, "type", type, 1000000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "descr"); size_t szDescr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "descr", szDescr, 200, _checker, __FILE__, __LINE__);
	UINT32 fpp; _parser.parseUINT32(fpp);
	AtfValidator::validateIntMax(_descr, "fpp", fpp, 2000000000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_DONT_SHOW_WHERE
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE::Protocol_MSG_LOBBY_DONT_SHOW_WHERE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE::Protocol_MSG_LOBBY_DONT_SHOW_WHERE(Protocol_MSG_LOBBY_DONT_SHOW_WHERE&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, b(std::move(_o.b))
{
}

Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE& Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE::operator=(Protocol_MSG_LOBBY_DONT_SHOW_WHERE&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		b = std::move(_o.b);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE::clear()
{
	notUsedStr.clear();
	b = false;
}

bool Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE::equals(const Protocol_MSG_LOBBY_DONT_SHOW_WHERE& _o) const
{
	return Atf::atfPStringEquals(notUsedStr, _o.notUsedStr) &&
		b == _o.b;
}

bool Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_DONT_SHOW_WHERE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_DONT_SHOW_WHERE*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_DONT_SHOW_WHERE).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("b=");
	_buf.appendUint(b);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_DONT_SHOW_WHERE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsedStr", notUsedStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("b", b, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedStr)) return false;
			}
			else if (_element.equals("b"))
			{
				b = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsedStr);
	_msg.composeBOOL(b);
}

void Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseBOOL(b);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsedStr", notUsedStr);
	_jsonstr.compose("b", b);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsedStr", notUsedStr);
	_jparser.parseByNameThrow("b", b);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_DONT_SHOW_WHERE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsedStr; _jparser.validateByNameThrow("notUsedStr", notUsedStr);
	AtfValidator::validateIntMax(_descr, "notUsedStr", notUsedStr.length(), 20, _checker, __FILE__, __LINE__);
	bool b; _jparser.validateByNameThrow("b", b);
	AtfValidator::validateInt(_descr, "b", b, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_DONT_SHOW_WHERE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	bool b; _parser.parseBOOL(b);
	AtfValidator::validateInt(_descr, "b", b, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY::Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY::Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY(Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY&& _o)
	: err_code(std::move(_o.err_code))
	, errDescr(std::move(_o.errDescr))
	, dontShowWhere(std::move(_o.dontShowWhere))
{
}

Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY& Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY::operator=(Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY&& _o)
{
	if(this != &_o)
	{
		err_code = std::move(_o.err_code);
		errDescr = std::move(_o.errDescr);
		dontShowWhere = std::move(_o.dontShowWhere);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY::clear()
{
	err_code = 0;
	errDescr.clear();
	dontShowWhere = false;
}

bool Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY::equals(const Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY& _o) const
{
	return err_code == _o.err_code &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		dontShowWhere == _o.dontShowWhere;
}

bool Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_DONT_SHOW_WHERE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_DONT_SHOW_WHERE_REPLY).append(")");
	_buf.append(',');
	_buf.append("err_code=");
	_buf.appendInt(err_code);
	_buf.append(',');
	_buf.append("errDescr=");
	_buf.append(errDescr);
	_buf.append(',');
	_buf.append("dontShowWhere=");
	_buf.appendUint(dontShowWhere);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_DONT_SHOW_WHERE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("err_code", err_code, _buf);
	Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	Atf::XmlElement::encodeAsXmlElement("dontShowWhere", dontShowWhere, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("err_code"))
			{
				err_code = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("dontShowWhere"))
			{
				dontShowWhere = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(err_code);
	_msg.composeString(errDescr);
	_msg.composeBOOL(dontShowWhere);
}

void Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(err_code);
	_parser.parseStringP(errDescr);
	_parser.parseBOOL(dontShowWhere);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("err_code", err_code);
	_jsonstr.compose("errDescr", errDescr);
	_jsonstr.compose("dontShowWhere", dontShowWhere);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("err_code", err_code);
	_jparser.parseByNameThrow("errDescr", errDescr);
	_jparser.parseByNameThrow("dontShowWhere", dontShowWhere);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_DONT_SHOW_WHERE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 err_code; _jparser.validateByNameThrow("err_code", err_code);
	AtfValidator::validateInt(_descr, "err_code", err_code, _checker, __FILE__, __LINE__);
	PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
	AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	bool dontShowWhere; _jparser.validateByNameThrow("dontShowWhere", dontShowWhere);
	AtfValidator::validateInt(_descr, "dontShowWhere", dontShowWhere, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_DONT_SHOW_WHERE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 err_code; _parser.parseINT16(err_code);
	AtfValidator::validateInt(_descr, "err_code", err_code, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	bool dontShowWhere; _parser.parseBOOL(dontShowWhere);
	AtfValidator::validateInt(_descr, "dontShowWhere", dontShowWhere, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO::Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO::Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO(Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, setPriv(std::move(_o.setPriv))
{
}

Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO& Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO::operator=(Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		setPriv = std::move(_o.setPriv);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO::clear()
{
	notUsedStr.clear();
	setPriv = false;
}

bool Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO::equals(const Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO& _o) const
{
	return Atf::atfPStringEquals(notUsedStr, _o.notUsedStr) &&
		setPriv == _o.setPriv;
}

bool Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_DONT_SHOW_PERSONAL_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_DONT_SHOW_PERSONAL_INFO).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("setPriv=");
	_buf.appendUint(setPriv);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_DONT_SHOW_PERSONAL_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsedStr", notUsedStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("setPriv", setPriv, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedStr)) return false;
			}
			else if (_element.equals("setPriv"))
			{
				setPriv = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsedStr);
	_msg.composeBOOL(setPriv);
}

void Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseBOOL(setPriv);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsedStr", notUsedStr);
	_jsonstr.compose("setPriv", setPriv);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsedStr", notUsedStr);
	_jparser.parseByNameThrow("setPriv", setPriv);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_DONT_SHOW_PERSONAL_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsedStr; _jparser.validateByNameThrow("notUsedStr", notUsedStr);
	AtfValidator::validateIntMax(_descr, "notUsedStr", notUsedStr.length(), 20, _checker, __FILE__, __LINE__);
	bool setPriv; _jparser.validateByNameThrow("setPriv", setPriv);
	AtfValidator::validateInt(_descr, "setPriv", setPriv, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_DONT_SHOW_PERSONAL_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	bool setPriv; _parser.parseBOOL(setPriv);
	AtfValidator::validateInt(_descr, "setPriv", setPriv, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS(Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, b(std::move(_o.b))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS& Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS::operator=(Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		b = std::move(_o.b);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS::clear()
{
	notUsedStr.clear();
	b = false;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS::equals(const Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS& _o) const
{
	return Atf::atfPStringEquals(notUsedStr, _o.notUsedStr) &&
		b == _o.b;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_SET_TOURN_EMAIL_FLAGS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SET_TOURN_EMAIL_FLAGS).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("b=");
	_buf.appendUint(b);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_SET_TOURN_EMAIL_FLAGS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsedStr", notUsedStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("b", b, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedStr)) return false;
			}
			else if (_element.equals("b"))
			{
				b = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsedStr);
	_msg.composeBOOL(b);
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseBOOL(b);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsedStr", notUsedStr);
	_jsonstr.compose("b", b);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsedStr", notUsedStr);
	_jparser.parseByNameThrow("b", b);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_TOURN_EMAIL_FLAGS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsedStr; _jparser.validateByNameThrow("notUsedStr", notUsedStr);
	AtfValidator::validateIntMax(_descr, "notUsedStr", notUsedStr.length(), 20, _checker, __FILE__, __LINE__);
	bool b; _jparser.validateByNameThrow("b", b);
	AtfValidator::validateInt(_descr, "b", b, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_TOURN_EMAIL_FLAGS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	bool b; _parser.parseBOOL(b);
	AtfValidator::validateInt(_descr, "b", b, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY(Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY&& _o)
	: err_code(std::move(_o.err_code))
	, errDescr(std::move(_o.errDescr))
	, dontShowWhere(std::move(_o.dontShowWhere))
{
}

Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY& Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY::operator=(Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY&& _o)
{
	if(this != &_o)
	{
		err_code = std::move(_o.err_code);
		errDescr = std::move(_o.errDescr);
		dontShowWhere = std::move(_o.dontShowWhere);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY::clear()
{
	err_code = 0;
	errDescr.clear();
	dontShowWhere = false;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY::equals(const Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY& _o) const
{
	return err_code == _o.err_code &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		dontShowWhere == _o.dontShowWhere;
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY).append(")");
	_buf.append(',');
	_buf.append("err_code=");
	_buf.appendInt(err_code);
	_buf.append(',');
	_buf.append("errDescr=");
	_buf.append(errDescr);
	_buf.append(',');
	_buf.append("dontShowWhere=");
	_buf.appendUint(dontShowWhere);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("err_code", err_code, _buf);
	Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	Atf::XmlElement::encodeAsXmlElement("dontShowWhere", dontShowWhere, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("err_code"))
			{
				err_code = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("dontShowWhere"))
			{
				dontShowWhere = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(err_code);
	_msg.composeString(errDescr);
	_msg.composeBOOL(dontShowWhere);
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(err_code);
	_parser.parseStringP(errDescr);
	_parser.parseBOOL(dontShowWhere);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("err_code", err_code);
	_jsonstr.compose("errDescr", errDescr);
	_jsonstr.compose("dontShowWhere", dontShowWhere);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("err_code", err_code);
	_jparser.parseByNameThrow("errDescr", errDescr);
	_jparser.parseByNameThrow("dontShowWhere", dontShowWhere);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 err_code; _jparser.validateByNameThrow("err_code", err_code);
	AtfValidator::validateInt(_descr, "err_code", err_code, _checker, __FILE__, __LINE__);
	PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
	AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	bool dontShowWhere; _jparser.validateByNameThrow("dontShowWhere", dontShowWhere);
	AtfValidator::validateInt(_descr, "dontShowWhere", dontShowWhere, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 err_code; _parser.parseINT16(err_code);
	AtfValidator::validateInt(_descr, "err_code", err_code, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	bool dontShowWhere; _parser.parseBOOL(dontShowWhere);
	AtfValidator::validateInt(_descr, "dontShowWhere", dontShowWhere, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    TournTicketInfoBody
//=================================================================

Lobby::cli::TournTicketInfoBody::TournTicketInfoBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::TournTicketInfoBody::TournTicketInfoBody(TournTicketInfoBody&& _o)
	: ticketId(std::move(_o.ticketId))
	, admissionCode(std::move(_o.admissionCode))
	, isMulti(std::move(_o.isMulti))
	, ticketTypeValue(std::move(_o.ticketTypeValue))
	, issued(std::move(_o.issued))
	, expDate(std::move(_o.expDate))
	, currency(std::move(_o.currency))
	, numTourns(std::move(_o.numTourns))
	, ticketTypeFlags(std::move(_o.ticketTypeFlags))
{
}

Lobby::cli::TournTicketInfoBody& Lobby::cli::TournTicketInfoBody::operator=(TournTicketInfoBody&& _o)
{
	if(this != &_o)
	{
		ticketId = std::move(_o.ticketId);
		admissionCode = std::move(_o.admissionCode);
		isMulti = std::move(_o.isMulti);
		ticketTypeValue = std::move(_o.ticketTypeValue);
		issued = std::move(_o.issued);
		expDate = std::move(_o.expDate);
		currency = std::move(_o.currency);
		numTourns = std::move(_o.numTourns);
		ticketTypeFlags = std::move(_o.ticketTypeFlags);
	}
	return *this;
}

#endif

void Lobby::cli::TournTicketInfoBody::clear()
{
	ticketId = 0;
	admissionCode.clear();
	isMulti = false;
	ticketTypeValue = 0;
	issued.setNull();
	expDate.setNull();
	currency.clear();
	numTourns = 0;
	ticketTypeFlags = 0;
}

bool Lobby::cli::TournTicketInfoBody::equals(const TournTicketInfoBody& _o) const
{
	return ticketId == _o.ticketId &&
		Atf::atfPStringEquals(admissionCode, _o.admissionCode) &&
		isMulti == _o.isMulti &&
		ticketTypeValue == _o.ticketTypeValue &&
		issued.equals(_o.issued) &&
		expDate.equals(_o.expDate) &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		numTourns == _o.numTourns &&
		ticketTypeFlags == _o.ticketTypeFlags;
}

const char *Lobby::cli::TournTicketInfoBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("ticketId=");
	_buf.appendUint(ticketId);
	_buf.append(',');
	_buf.append("admissionCode=");
	_buf.append(admissionCode);
	_buf.append(',');
	_buf.append("isMulti=");
	_buf.appendUint(isMulti);
	_buf.append(',');
	_buf.append("ticketTypeValue=");
	_buf.appendUint(ticketTypeValue);
	_buf.append(',');
	_buf.append("issued=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, issued);
	_buf.append(',');
	_buf.append("expDate=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, expDate);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("numTourns=");
	_buf.appendInt(numTourns);
	_buf.append(',');
	_buf.append("ticketTypeFlags=");
	_buf.appendUint(ticketTypeFlags);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::TournTicketInfoBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("ticketId", ticketId, _buf);
	Atf::XmlElement::encodeAsXmlElement("admissionCode", admissionCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("isMulti", isMulti, _buf);
	Atf::XmlElement::encodeAsXmlElement("ticketTypeValue", ticketTypeValue, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "issued", issued);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "expDate", expDate);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("numTourns", numTourns, _buf);
	Atf::XmlElement::encodeAsXmlElement("ticketTypeFlags", ticketTypeFlags, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::TournTicketInfoBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("ticketId"))
		{
			ticketId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("admissionCode"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, admissionCode)) return false;
		}
		else if (_element.equals("isMulti"))
		{
			isMulti = (*_value.ptr() == '1');
		}
		else if (_element.equals("ticketTypeValue"))
		{
			ticketTypeValue = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("issued"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, issued);
		}
		else if (_element.equals("expDate"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, expDate);
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("numTourns"))
		{
			numTourns = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("ticketTypeFlags"))
		{
			ticketTypeFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::TournTicketInfoBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(TournTicketInfoBody())) // not empty
	{
		_body.composeUINT32(ticketId);
		_body.composeString(admissionCode);
		_body.composeBOOL(isMulti);
		_body.composeUINT32(ticketTypeValue);
		_body.composeSrvTime(issued);
		_body.composeSrvTime(expDate);
		_body.composeString(currency);
		_body.composeINT32(numTourns);
		_body.composeUINT32(ticketTypeFlags);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::cli::TournTicketInfoBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(ticketId);
	_parser0.parseStringP(admissionCode);
	_parser0.parseBOOL(isMulti);
	_parser0.parseUINT32(ticketTypeValue);
	_parser0.parseSrvTime(issued);
	_parser0.parseSrvTime(expDate);
	_parser0.parseStringP(currency);
	_parser0.parseINT32(numTourns);
	_parser0.parseUINT32(ticketTypeFlags);
}

const char *Lobby::cli::TournTicketInfoBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("ticketId", ticketId);
	_jsonstr.compose("admissionCode", admissionCode);
	_jsonstr.compose("isMulti", isMulti);
	_jsonstr.compose("ticketTypeValue", ticketTypeValue);
	_jsonstr.compose("issued", issued);
	_jsonstr.compose("expDate", expDate);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("numTourns", numTourns);
	_jsonstr.compose("ticketTypeFlags", ticketTypeFlags);
	return _buf.c_str();
}

void Lobby::cli::TournTicketInfoBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("ticketId", ticketId);
	_jparser.parseByNameThrow("admissionCode", admissionCode);
	_jparser.parseByNameThrow("isMulti", isMulti);
	_jparser.parseByNameThrow("ticketTypeValue", ticketTypeValue);
	_jparser.parseByNameThrow("issued", issued);
	_jparser.parseByNameThrow("expDate", expDate);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("numTourns", numTourns);
	_jparser.parseByNameThrow("ticketTypeFlags", ticketTypeFlags);
}

/* static */ void Lobby::cli::TournTicketInfoBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 ticketId; _jparser.validateByNameThrow("ticketId", ticketId);
	AtfValidator::validateInt(_descr, "ticketId", ticketId, _checker, __FILE__, __LINE__);
	PString admissionCode; _jparser.validateByNameThrow("admissionCode", admissionCode);
	AtfValidator::validateInt(_descr, "admissionCode", admissionCode.length(), _checker, __FILE__, __LINE__);
	bool isMulti; _jparser.validateByNameThrow("isMulti", isMulti);
	AtfValidator::validateInt(_descr, "isMulti", isMulti, _checker, __FILE__, __LINE__);
	UINT32 ticketTypeValue; _jparser.validateByNameThrow("ticketTypeValue", ticketTypeValue);
	AtfValidator::validateInt(_descr, "ticketTypeValue", ticketTypeValue, _checker, __FILE__, __LINE__);
	CommSrvTime issued; _jparser.validateByNameThrow("issued", issued);
	AtfValidator::validateSrvDateTime(_descr, "issued", issued, _checker, __FILE__, __LINE__);
	CommSrvTime expDate; _jparser.validateByNameThrow("expDate", expDate);
	AtfValidator::validateSrvDateTime(_descr, "expDate", expDate, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	INT32 numTourns; _jparser.validateByNameThrow("numTourns", numTourns);
	AtfValidator::validateInt(_descr, "numTourns", numTourns, _checker, __FILE__, __LINE__);
	UINT32 ticketTypeFlags; _jparser.validateByNameThrow("ticketTypeFlags", ticketTypeFlags);
	AtfValidator::validateInt(_descr, "ticketTypeFlags", ticketTypeFlags, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::TournTicketInfoBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 ticketId; _parser0.parseUINT32(ticketId);
	AtfValidator::validateInt(_descr, "ticketId", ticketId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "admissionCode"); size_t szAdmissionCode = strlen(_dummy);
	AtfValidator::validateInt(_descr, "admissionCode", szAdmissionCode, _checker, __FILE__, __LINE__);
	bool isMulti; _parser0.parseBOOL(isMulti);
	AtfValidator::validateInt(_descr, "isMulti", isMulti, _checker, __FILE__, __LINE__);
	UINT32 ticketTypeValue; _parser0.parseUINT32(ticketTypeValue);
	AtfValidator::validateInt(_descr, "ticketTypeValue", ticketTypeValue, _checker, __FILE__, __LINE__);
	CommSrvTime issued; _parser0.parseSrvTime(issued);
	AtfValidator::validateSrvDateTime(_descr, "issued", issued, _checker, __FILE__, __LINE__);
	CommSrvTime expDate; _parser0.parseSrvTime(expDate);
	AtfValidator::validateSrvDateTime(_descr, "expDate", expDate, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT32 numTourns; _parser0.parseINT32(numTourns);
	AtfValidator::validateInt(_descr, "numTourns", numTourns, _checker, __FILE__, __LINE__);
	UINT32 ticketTypeFlags; _parser0.parseUINT32(ticketTypeFlags);
	AtfValidator::validateInt(_descr, "ticketTypeFlags", ticketTypeFlags, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBY_USER_TOURNTICKETS2
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2::Protocol_MSG_LOBBY_USER_TOURNTICKETS2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2::Protocol_MSG_LOBBY_USER_TOURNTICKETS2(Protocol_MSG_LOBBY_USER_TOURNTICKETS2&& _o)
	: unusedStr(std::move(_o.unusedStr))
{
}

Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2& Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2::operator=(Protocol_MSG_LOBBY_USER_TOURNTICKETS2&& _o)
{
	if(this != &_o)
	{
		unusedStr = std::move(_o.unusedStr);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2::clear()
{
	unusedStr.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2::equals(const Protocol_MSG_LOBBY_USER_TOURNTICKETS2& _o) const
{
	return Atf::atfPStringEquals(unusedStr, _o.unusedStr);
}

bool Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_USER_TOURNTICKETS2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_USER_TOURNTICKETS2*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_USER_TOURNTICKETS2).append(")");
	_buf.append(',');
	_buf.append("unusedStr=");
	_buf.append(unusedStr);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_USER_TOURNTICKETS2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("unusedStr", unusedStr, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("unusedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, unusedStr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(unusedStr);
}

void Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseStringP(unusedStr);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("unusedStr", unusedStr);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("unusedStr", unusedStr);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_USER_TOURNTICKETS2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	PString unusedStr; _jparser.validateByNameThrow("unusedStr", unusedStr);
	AtfValidator::validateIntMax(_descr, "unusedStr", unusedStr.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_USER_TOURNTICKETS2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "unusedStr"); size_t szUnusedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "unusedStr", szUnusedStr, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY::Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY::Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY(Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, tickets(std::move(_o.tickets))
{
}

Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY& Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY::operator=(Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		tickets = std::move(_o.tickets);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	tickets.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY::equals(const Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		tickets.equals(_o.tickets);
}

bool Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_USER_TOURNTICKETS2_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_USER_TOURNTICKETS2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("tickets=");
		tickets.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_USER_TOURNTICKETS2_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		tickets.toXmlString("tickets", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("tickets"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TournTicketInfoBody, 4 > >::FromXmlString(_value, tickets)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		tickets.composeMsg(_msg, _ignoreJSON);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		tickets.parseMsg(_parser);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("tickets", tickets);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("tickets", tickets);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_USER_TOURNTICKETS2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< TournTicketInfoBody > tickets; _jparser.validateByNameThrow("tickets", tickets);
		AtfValidator::validateInt(_descr, "tickets", tickets.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_USER_TOURNTICKETS2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szTickets = Atf::LAtfVector< TournTicketInfoBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tickets"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tickets", szTickets, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    SingleTournamentBody
//=================================================================

Lobby::cli::SingleTournamentBody::SingleTournamentBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::SingleTournamentBody::SingleTournamentBody(SingleTournamentBody&& _o)
	: tournamentId(std::move(_o.tournamentId))
	, status(std::move(_o.status))
	, tournFlags(std::move(_o.tournFlags))
	, whenStart(std::move(_o.whenStart))
	, entrants(std::move(_o.entrants))
	, minPlayers(std::move(_o.minPlayers))
	, buyIn(std::move(_o.buyIn))
	, game(std::move(_o.game))
	, isHiLo(std::move(_o.isHiLo))
	, structure(std::move(_o.structure))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, server(std::move(_o.server))
	, rake(std::move(_o.rake))
	, knockout(std::move(_o.knockout))
	, fppBuyIn(std::move(_o.fppBuyIn))
	, isRestricted(std::move(_o.isRestricted))
	, currency(std::move(_o.currency))
	, statusBits(std::move(_o.statusBits))
	, name(std::move(_o.name))
	, tournFlags2(std::move(_o.tournFlags2))
{
}

Lobby::cli::SingleTournamentBody& Lobby::cli::SingleTournamentBody::operator=(SingleTournamentBody&& _o)
{
	if(this != &_o)
	{
		tournamentId = std::move(_o.tournamentId);
		status = std::move(_o.status);
		tournFlags = std::move(_o.tournFlags);
		whenStart = std::move(_o.whenStart);
		entrants = std::move(_o.entrants);
		minPlayers = std::move(_o.minPlayers);
		buyIn = std::move(_o.buyIn);
		game = std::move(_o.game);
		isHiLo = std::move(_o.isHiLo);
		structure = std::move(_o.structure);
		isPlayMoney = std::move(_o.isPlayMoney);
		server = std::move(_o.server);
		rake = std::move(_o.rake);
		knockout = std::move(_o.knockout);
		fppBuyIn = std::move(_o.fppBuyIn);
		isRestricted = std::move(_o.isRestricted);
		currency = std::move(_o.currency);
		statusBits = std::move(_o.statusBits);
		name = std::move(_o.name);
		tournFlags2 = std::move(_o.tournFlags2);
	}
	return *this;
}

#endif

void Lobby::cli::SingleTournamentBody::clear()
{
	tournamentId = 0;
	status = 0;
	tournFlags = 0;
	whenStart.setNull();
	entrants = 0;
	minPlayers = 0;
	buyIn = 0;
	game = 0;
	isHiLo = 0;
	structure = 0;
	isPlayMoney = 0;
	server.clear();
	rake = 0;
	knockout = 0;
	fppBuyIn = 0;
	isRestricted = 0;
	currency.clear();
	statusBits = 0;
	name.clear();
	tournFlags2 = 0;
}

bool Lobby::cli::SingleTournamentBody::equals(const SingleTournamentBody& _o) const
{
	return tournamentId == _o.tournamentId &&
		status == _o.status &&
		tournFlags == _o.tournFlags &&
		whenStart.equals(_o.whenStart) &&
		entrants == _o.entrants &&
		minPlayers == _o.minPlayers &&
		buyIn == _o.buyIn &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		structure == _o.structure &&
		isPlayMoney == _o.isPlayMoney &&
		Atf::atfPStringEquals(server, _o.server) &&
		rake == _o.rake &&
		knockout == _o.knockout &&
		fppBuyIn == _o.fppBuyIn &&
		isRestricted == _o.isRestricted &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		statusBits == _o.statusBits &&
		name.equals(_o.name) &&
		tournFlags2 == _o.tournFlags2;
}

const char *Lobby::cli::SingleTournamentBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournamentId=");
	_buf.appendUint(tournamentId);
	_buf.append(',');
	_buf.append("status=");
	_buf.appendUint(status);
	_buf.append(',');
	_buf.append("tournFlags=");
	_buf.appendUint(tournFlags);
	_buf.append(',');
	_buf.append("whenStart=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, whenStart);
	_buf.append(',');
	_buf.append("entrants=");
	_buf.appendUint(entrants);
	_buf.append(',');
	_buf.append("minPlayers=");
	_buf.appendUint(minPlayers);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendUint(buyIn);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendUint(rake);
	_buf.append(',');
	_buf.append("knockout=");
	_buf.appendUint(knockout);
	_buf.append(',');
	_buf.append("fppBuyIn=");
	_buf.appendUint(fppBuyIn);
	_buf.append(',');
	_buf.append("isRestricted=");
	_buf.appendUint(isRestricted);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("statusBits=");
	_buf.appendUint(statusBits);
	_buf.append(',');
	_buf.append("name=");
	Atf::AtfTempl<I18nPString>::ToTraceString(_buf, name);
	_buf.append(',');
	_buf.append("tournFlags2=");
	_buf.appendUint64(tournFlags2);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::SingleTournamentBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("tournamentId", tournamentId, _buf);
	Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournFlags", tournFlags, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "whenStart", whenStart);
	Atf::XmlElement::encodeAsXmlElement("entrants", entrants, _buf);
	Atf::XmlElement::encodeAsXmlElement("minPlayers", minPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyIn", buyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("server", server, _buf);
	Atf::XmlElement::encodeAsXmlElement("rake", rake, _buf);
	Atf::XmlElement::encodeAsXmlElement("knockout", knockout, _buf);
	Atf::XmlElement::encodeAsXmlElement("fppBuyIn", fppBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("isRestricted", isRestricted, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("statusBits", statusBits, _buf);
	Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "name", name);
	Atf::XmlElement::encodeAsXmlElement("tournFlags2", tournFlags2, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::SingleTournamentBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("tournamentId"))
		{
			tournamentId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("status"))
		{
			status = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournFlags"))
		{
			tournFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("whenStart"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, whenStart);
		}
		else if (_element.equals("entrants"))
		{
			entrants = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minPlayers"))
		{
			minPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("buyIn"))
		{
			buyIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("game"))
		{
			game = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("structure"))
		{
			structure = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isPlayMoney"))
		{
			isPlayMoney = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("server"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, server)) return false;
		}
		else if (_element.equals("rake"))
		{
			rake = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("knockout"))
		{
			knockout = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("fppBuyIn"))
		{
			fppBuyIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isRestricted"))
		{
			isRestricted = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("statusBits"))
		{
			statusBits = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("name"))
		{
			Atf::AtfTempl<I18nPString>::FromXmlString(_value, name);
		}
		else if (_element.equals("tournFlags2"))
		{
			tournFlags2 = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::SingleTournamentBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(SingleTournamentBody())) // not empty
	{
		_body.composeUINT32(tournamentId);
		_body.composeUINT32(status);
		_body.composeUINT32(tournFlags);
		_body.composeSrvTime(whenStart);
		_body.composeUINT32(entrants);
		_body.composeUINT32(minPlayers);
		_body.composeUINT32(buyIn);
		_body.composeBYTE(game);
		_body.composeBYTE(isHiLo);
		_body.composeBYTE(structure);
		_body.composeBYTE(isPlayMoney);
		_body.composeString(server);
		_body.composeUINT32(rake);
		_body.composeUINT32(knockout);
		_body.composeUINT32(fppBuyIn);
		_body.composeBYTE(isRestricted);
		_body.composeString(currency);
		_body.composeUINT32(statusBits);
		name.compose(_body);
		_body.composeUINT64(tournFlags2);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::cli::SingleTournamentBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(tournamentId);
	_parser0.parseUINT32(status);
	_parser0.parseUINT32(tournFlags);
	_parser0.parseSrvTime(whenStart);
	_parser0.parseUINT32(entrants);
	_parser0.parseUINT32(minPlayers);
	_parser0.parseUINT32(buyIn);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(isHiLo);
	_parser0.parseBYTE(structure);
	_parser0.parseBYTE(isPlayMoney);
	_parser0.parseStringP(server);
	_parser0.parseUINT32(rake);
	_parser0.parseUINT32(knockout);
	_parser0.parseUINT32(fppBuyIn);
	_parser0.parseBYTE(isRestricted);
	_parser0.parseStringP(currency);
	_parser0.parseUINT32(statusBits);
	name.parse(_parser0);
	_parser0.parseUINT64(tournFlags2);
}

const char *Lobby::cli::SingleTournamentBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tournamentId", tournamentId);
	_jsonstr.compose("status", status);
	_jsonstr.compose("tournFlags", tournFlags);
	_jsonstr.compose("whenStart", whenStart);
	_jsonstr.compose("entrants", entrants);
	_jsonstr.compose("minPlayers", minPlayers);
	_jsonstr.compose("buyIn", buyIn);
	_jsonstr.compose("game", game);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("server", server);
	_jsonstr.compose("rake", rake);
	_jsonstr.compose("knockout", knockout);
	_jsonstr.compose("fppBuyIn", fppBuyIn);
	_jsonstr.compose("isRestricted", isRestricted);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("statusBits", statusBits);
	_jsonstr.compose("name", name);
	_jsonstr.compose("tournFlags2", tournFlags2);
	return _buf.c_str();
}

void Lobby::cli::SingleTournamentBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tournamentId", tournamentId);
	_jparser.parseByNameThrow("status", status);
	_jparser.parseByNameThrow("tournFlags", tournFlags);
	_jparser.parseByNameThrow("whenStart", whenStart);
	_jparser.parseByNameThrow("entrants", entrants);
	_jparser.parseByNameThrow("minPlayers", minPlayers);
	_jparser.parseByNameThrow("buyIn", buyIn);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("server", server);
	_jparser.parseByNameThrow("rake", rake);
	_jparser.parseByNameThrow("knockout", knockout);
	_jparser.parseByNameThrow("fppBuyIn", fppBuyIn);
	_jparser.parseByNameThrow("isRestricted", isRestricted);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("statusBits", statusBits);
	_jparser.parseByNameThrow("name", name);
	_jparser.parseByNameThrow("tournFlags2", tournFlags2);
}

/* static */ void Lobby::cli::SingleTournamentBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tournamentId; _jparser.validateByNameThrow("tournamentId", tournamentId);
	AtfValidator::validateInt(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
	UINT32 status; _jparser.validateByNameThrow("status", status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	UINT32 tournFlags; _jparser.validateByNameThrow("tournFlags", tournFlags);
	AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
	CommSrvTime whenStart; _jparser.validateByNameThrow("whenStart", whenStart);
	AtfValidator::validateSrvDateTime(_descr, "whenStart", whenStart, _checker, __FILE__, __LINE__);
	UINT32 entrants; _jparser.validateByNameThrow("entrants", entrants);
	AtfValidator::validateInt(_descr, "entrants", entrants, _checker, __FILE__, __LINE__);
	UINT32 minPlayers; _jparser.validateByNameThrow("minPlayers", minPlayers);
	AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
	UINT32 buyIn; _jparser.validateByNameThrow("buyIn", buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	PString server; _jparser.validateByNameThrow("server", server);
	AtfValidator::validateInt(_descr, "server", server.length(), _checker, __FILE__, __LINE__);
	UINT32 rake; _jparser.validateByNameThrow("rake", rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	UINT32 knockout; _jparser.validateByNameThrow("knockout", knockout);
	AtfValidator::validateInt(_descr, "knockout", knockout, _checker, __FILE__, __LINE__);
	UINT32 fppBuyIn; _jparser.validateByNameThrow("fppBuyIn", fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	BYTE isRestricted; _jparser.validateByNameThrow("isRestricted", isRestricted);
	AtfValidator::validateInt(_descr, "isRestricted", isRestricted, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	UINT32 statusBits; _jparser.validateByNameThrow("statusBits", statusBits);
	AtfValidator::validateInt(_descr, "statusBits", statusBits, _checker, __FILE__, __LINE__);
	I18nPString name; _jparser.validateByNameThrow("name", name);
	UINT64 tournFlags2; _jparser.validateByNameThrow("tournFlags2", tournFlags2);
	AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::SingleTournamentBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 tournamentId; _parser0.parseUINT32(tournamentId);
	AtfValidator::validateInt(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
	UINT32 status; _parser0.parseUINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	UINT32 tournFlags; _parser0.parseUINT32(tournFlags);
	AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
	CommSrvTime whenStart; _parser0.parseSrvTime(whenStart);
	AtfValidator::validateSrvDateTime(_descr, "whenStart", whenStart, _checker, __FILE__, __LINE__);
	UINT32 entrants; _parser0.parseUINT32(entrants);
	AtfValidator::validateInt(_descr, "entrants", entrants, _checker, __FILE__, __LINE__);
	UINT32 minPlayers; _parser0.parseUINT32(minPlayers);
	AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
	UINT32 buyIn; _parser0.parseUINT32(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser0.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser0.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	UINT32 rake; _parser0.parseUINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	UINT32 knockout; _parser0.parseUINT32(knockout);
	AtfValidator::validateInt(_descr, "knockout", knockout, _checker, __FILE__, __LINE__);
	UINT32 fppBuyIn; _parser0.parseUINT32(fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	BYTE isRestricted; _parser0.parseBYTE(isRestricted);
	AtfValidator::validateInt(_descr, "isRestricted", isRestricted, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 statusBits; _parser0.parseUINT32(statusBits);
	AtfValidator::validateInt(_descr, "statusBits", statusBits, _checker, __FILE__, __LINE__);
	I18nPString name; name.parse(_parser0);
	UINT64 tournFlags2; _parser0.parseUINT64(tournFlags2);
	AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBY_TICKET_TOURNTIDS
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS::Protocol_MSG_LOBBY_TICKET_TOURNTIDS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS::Protocol_MSG_LOBBY_TICKET_TOURNTIDS(Protocol_MSG_LOBBY_TICKET_TOURNTIDS&& _o)
	: unusedStr(std::move(_o.unusedStr))
	, ticketId(std::move(_o.ticketId))
{
}

Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS& Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS::operator=(Protocol_MSG_LOBBY_TICKET_TOURNTIDS&& _o)
{
	if(this != &_o)
	{
		unusedStr = std::move(_o.unusedStr);
		ticketId = std::move(_o.ticketId);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS::clear()
{
	unusedStr.clear();
	ticketId = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS::equals(const Protocol_MSG_LOBBY_TICKET_TOURNTIDS& _o) const
{
	return Atf::atfPStringEquals(unusedStr, _o.unusedStr) &&
		ticketId == _o.ticketId;
}

bool Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_TICKET_TOURNTIDS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_TICKET_TOURNTIDS*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_TICKET_TOURNTIDS).append(")");
	_buf.append(',');
	_buf.append("unusedStr=");
	_buf.append(unusedStr);
	_buf.append(',');
	_buf.append("ticketId=");
	_buf.appendUint(ticketId);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_TICKET_TOURNTIDS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("unusedStr", unusedStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("ticketId", ticketId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("unusedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, unusedStr)) return false;
			}
			else if (_element.equals("ticketId"))
			{
				ticketId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(unusedStr);
	_msg.composeUINT32(ticketId);
}

void Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseStringP(unusedStr);
	_parser.parseUINT32(ticketId);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("unusedStr", unusedStr);
	_jsonstr.compose("ticketId", ticketId);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("unusedStr", unusedStr);
	_jparser.parseByNameThrow("ticketId", ticketId);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TICKET_TOURNTIDS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	PString unusedStr; _jparser.validateByNameThrow("unusedStr", unusedStr);
	AtfValidator::validateIntMax(_descr, "unusedStr", unusedStr.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT32 ticketId; _jparser.validateByNameThrow("ticketId", ticketId);
	AtfValidator::validateInt(_descr, "ticketId", ticketId, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TICKET_TOURNTIDS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "unusedStr"); size_t szUnusedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "unusedStr", szUnusedStr, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT32 ticketId; _parser.parseUINT32(ticketId);
	AtfValidator::validateInt(_descr, "ticketId", ticketId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY::Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY::Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY(Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, ticketId(std::move(_o.ticketId))
	, tournaments(std::move(_o.tournaments))
{
}

Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY& Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY::operator=(Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		ticketId = std::move(_o.ticketId);
		tournaments = std::move(_o.tournaments);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	ticketId = 0;
	tournaments.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY::equals(const Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		ticketId == _o.ticketId &&
		tournaments.equals(_o.tournaments);
}

bool Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_TICKET_TOURNTIDS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_TICKET_TOURNTIDS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("ticketId=");
		_buf.appendUint(ticketId);
		_buf.append(',');
		_buf.append("tournaments=");
		tournaments.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_TICKET_TOURNTIDS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("ticketId", ticketId, _buf);
		tournaments.toXmlString("tournaments", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("ticketId"))
			{
				ticketId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournaments"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SingleTournamentBody, 4 > >::FromXmlString(_value, tournaments)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(ticketId);
		tournaments.composeMsg(_msg, _ignoreJSON);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(ticketId);
		tournaments.parseMsg(_parser);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("ticketId", ticketId);
		_jsonstr.compose("tournaments", tournaments);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("ticketId", ticketId);
		_jparser.parseByNameThrow("tournaments", tournaments);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TICKET_TOURNTIDS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 ticketId; _jparser.validateByNameThrow("ticketId", ticketId);
		AtfValidator::validateInt(_descr, "ticketId", ticketId, _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< SingleTournamentBody > tournaments; _jparser.validateByNameThrow("tournaments", tournaments);
		AtfValidator::validateInt(_descr, "tournaments", tournaments.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TICKET_TOURNTIDS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 ticketId; _parser.parseUINT32(ticketId);
		AtfValidator::validateInt(_descr, "ticketId", ticketId, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szTournaments = Atf::LAtfVector< SingleTournamentBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournaments"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tournaments", szTournaments, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    TeamOnlineBody
//=================================================================

Lobby::cli::TeamOnlineBody::TeamOnlineBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::TeamOnlineBody::TeamOnlineBody(TeamOnlineBody&& _o)
	: isPlay(std::move(_o.isPlay))
	, userId(std::move(_o.userId))
	, name(std::move(_o.name))
	, country(std::move(_o.country))
	, displayCountry(std::move(_o.displayCountry))
{
}

Lobby::cli::TeamOnlineBody& Lobby::cli::TeamOnlineBody::operator=(TeamOnlineBody&& _o)
{
	if(this != &_o)
	{
		isPlay = std::move(_o.isPlay);
		userId = std::move(_o.userId);
		name = std::move(_o.name);
		country = std::move(_o.country);
		displayCountry = std::move(_o.displayCountry);
	}
	return *this;
}

#endif

void Lobby::cli::TeamOnlineBody::clear()
{
	isPlay = false;
	userId.clear();
	name.clear();
	country.clear();
	displayCountry.clear();
}

bool Lobby::cli::TeamOnlineBody::equals(const TeamOnlineBody& _o) const
{
	return isPlay == _o.isPlay &&
		Atf::atfPStringEquals(userId, _o.userId) &&
		Atf::atfPStringEquals(name, _o.name) &&
		Atf::atfPStringEquals(country, _o.country) &&
		Atf::atfPStringEquals(displayCountry, _o.displayCountry);
}

const char *Lobby::cli::TeamOnlineBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("isPlay=");
	_buf.appendUint(isPlay);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("displayCountry=");
	_buf.append(displayCountry);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::TeamOnlineBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("isPlay", isPlay, _buf);
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::encodeAsXmlElement("displayCountry", displayCountry, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::TeamOnlineBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("isPlay"))
		{
			isPlay = (*_value.ptr() == '1');
		}
		else if (_element.equals("userId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
		}
		else if (_element.equals("name"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
		}
		else if (_element.equals("country"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
		}
		else if (_element.equals("displayCountry"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, displayCountry)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::TeamOnlineBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(TeamOnlineBody())) // not empty
	{
		_body.composeBOOL(isPlay);
		_body.composeString(userId);
		_body.composeString(name);
		_body.composeString(country);
		_body.composeString(displayCountry);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::cli::TeamOnlineBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(isPlay);
	_parser0.parseStringP(userId);
	_parser0.parseStringP(name);
	_parser0.parseStringP(country);
	_parser0.parseStringP(displayCountry);
}

const char *Lobby::cli::TeamOnlineBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("isPlay", isPlay);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("name", name);
	_jsonstr.compose("country", country);
	_jsonstr.compose("displayCountry", displayCountry);
	return _buf.c_str();
}

void Lobby::cli::TeamOnlineBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("isPlay", isPlay);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("name", name);
	_jparser.parseByNameThrow("country", country);
	_jparser.parseByNameThrow("displayCountry", displayCountry);
}

/* static */ void Lobby::cli::TeamOnlineBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool isPlay; _jparser.validateByNameThrow("isPlay", isPlay);
	AtfValidator::validateInt(_descr, "isPlay", isPlay, _checker, __FILE__, __LINE__);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateInt(_descr, "userId", userId.length(), _checker, __FILE__, __LINE__);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateInt(_descr, "name", name.length(), _checker, __FILE__, __LINE__);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateInt(_descr, "country", country.length(), _checker, __FILE__, __LINE__);
	PString displayCountry; _jparser.validateByNameThrow("displayCountry", displayCountry);
	AtfValidator::validateInt(_descr, "displayCountry", displayCountry.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::TeamOnlineBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	bool isPlay; _parser0.parseBOOL(isPlay);
	AtfValidator::validateInt(_descr, "isPlay", isPlay, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "displayCountry"); size_t szDisplayCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "displayCountry", szDisplayCountry, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE::clear()
{
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE::equals(const Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE& _o) const
{
	return true;
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_CLI_TEAM_PS_ONLINE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CLI_TEAM_PS_ONLINE).append(")");
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_CLI_TEAM_PS_ONLINE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE::parseMsg(CommMsgParser& _parser)
{
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLI_TEAM_PS_ONLINE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLI_TEAM_PS_ONLINE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY(Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, teams(std::move(_o.teams))
{
}

Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY& Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY::operator=(Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		teams = std::move(_o.teams);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	teams.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY::equals(const Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		teams.equals(_o.teams);
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("teams=");
		teams.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		teams.toXmlString("teams", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("teams"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TeamOnlineBody, 4 > >::FromXmlString(_value, teams)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		teams.composeMsg(_msg, _ignoreJSON);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		teams.parseMsg(_parser);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("teams", teams);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("teams", teams);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< TeamOnlineBody > teams; _jparser.validateByNameThrow("teams", teams);
		AtfValidator::validateInt(_descr, "teams", teams.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szTeams = Atf::LAtfVector< TeamOnlineBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("teams"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "teams", szTeams, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_TIMEZONE_SET
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET::Protocol_MSG_LOBBY_TIMEZONE_SET()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET::Protocol_MSG_LOBBY_TIMEZONE_SET(Protocol_MSG_LOBBY_TIMEZONE_SET&& _o)
	: unusedStr(std::move(_o.unusedStr))
	, timezone(std::move(_o.timezone))
	, tzName(std::move(_o.tzName))
{
}

Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET& Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET::operator=(Protocol_MSG_LOBBY_TIMEZONE_SET&& _o)
{
	if(this != &_o)
	{
		unusedStr = std::move(_o.unusedStr);
		timezone = std::move(_o.timezone);
		tzName = std::move(_o.tzName);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET::clear()
{
	unusedStr.clear();
	timezone = 0;
	tzName.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET::equals(const Protocol_MSG_LOBBY_TIMEZONE_SET& _o) const
{
	return Atf::atfPStringEquals(unusedStr, _o.unusedStr) &&
		timezone == _o.timezone &&
		Atf::atfPStringEquals(tzName, _o.tzName);
}

bool Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_TIMEZONE_SET != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_TIMEZONE_SET*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_TIMEZONE_SET).append(")");
	_buf.append(',');
	_buf.append("unusedStr=");
	_buf.append(unusedStr);
	_buf.append(',');
	_buf.append("timezone=");
	_buf.appendUint(timezone);
	_buf.append(',');
	_buf.append("tzName=");
	_buf.append(tzName);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_TIMEZONE_SET).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("unusedStr", unusedStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("timezone", timezone, _buf);
	Atf::XmlElement::encodeAsXmlElement("tzName", tzName, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("unusedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, unusedStr)) return false;
			}
			else if (_element.equals("timezone"))
			{
				timezone = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tzName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tzName)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(unusedStr);
	_msg.composeUINT32(timezone);
	_msg.composeString(tzName);
}

void Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(unusedStr);
	_parser.parseUINT32(timezone);
	_parser.parseStringP(tzName);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("unusedStr", unusedStr);
	_jsonstr.compose("timezone", timezone);
	_jsonstr.compose("tzName", tzName);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("unusedStr", unusedStr);
	_jparser.parseByNameThrow("timezone", timezone);
	_jparser.parseByNameThrow("tzName", tzName);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TIMEZONE_SET";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString unusedStr; _jparser.validateByNameThrow("unusedStr", unusedStr);
	AtfValidator::validateIntMax(_descr, "unusedStr", unusedStr.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT32 timezone; _jparser.validateByNameThrow("timezone", timezone);
	AtfValidator::validateIntRange(_descr, "timezone", timezone, eTzUTC, 65537, _checker, __FILE__, __LINE__);
	PString tzName; _jparser.validateByNameThrow("tzName", tzName);
	AtfValidator::validateIntMax(_descr, "tzName", tzName.length(), 100, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TIMEZONE_SET";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "unusedStr"); size_t szUnusedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "unusedStr", szUnusedStr, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	UINT32 timezone; _parser.parseUINT32(timezone);
	AtfValidator::validateIntRange(_descr, "timezone", timezone, eTzUTC, 65537, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "tzName"); size_t szTzName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "tzName", szTzName, 100, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY::Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY::Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY(Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, timeZone(std::move(_o.timeZone))
{
}

Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY& Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY::operator=(Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		timeZone = std::move(_o.timeZone);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	timeZone = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY::equals(const Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		timeZone == _o.timeZone;
}

bool Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_TIMEZONE_SET_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_TIMEZONE_SET_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("timeZone=");
		_buf.appendUint(timeZone);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_TIMEZONE_SET_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("timeZone", timeZone, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("timeZone"))
			{
				timeZone = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(timeZone);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(timeZone);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("timeZone", timeZone);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("timeZone", timeZone);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TIMEZONE_SET_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 timeZone; _jparser.validateByNameThrow("timeZone", timeZone);
		AtfValidator::validateInt(_descr, "timeZone", timeZone, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TIMEZONE_SET_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 timeZone; _parser.parseUINT32(timeZone);
		AtfValidator::validateInt(_descr, "timeZone", timeZone, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_EXCLUDE_PLAYER
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER::Protocol_MSG_LOBBY_EXCLUDE_PLAYER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER::Protocol_MSG_LOBBY_EXCLUDE_PLAYER(Protocol_MSG_LOBBY_EXCLUDE_PLAYER&& _o)
	: unusedStr(std::move(_o.unusedStr))
	, days(std::move(_o.days))
	, dummyFlags(std::move(_o.dummyFlags))
	, dummyFlags2(std::move(_o.dummyFlags2))
	, groupSelfExclusion(std::move(_o.groupSelfExclusion))
	, version(std::move(_o.version))
{
}

Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER& Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER::operator=(Protocol_MSG_LOBBY_EXCLUDE_PLAYER&& _o)
{
	if(this != &_o)
	{
		unusedStr = std::move(_o.unusedStr);
		days = std::move(_o.days);
		dummyFlags = std::move(_o.dummyFlags);
		dummyFlags2 = std::move(_o.dummyFlags2);
		groupSelfExclusion = std::move(_o.groupSelfExclusion);
		version = std::move(_o.version);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER::clear()
{
	unusedStr.clear();
	days = 0;
	dummyFlags = 0;
	dummyFlags2 = 0;
	groupSelfExclusion = false;
	version = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER::equals(const Protocol_MSG_LOBBY_EXCLUDE_PLAYER& _o) const
{
	return Atf::atfPStringEquals(unusedStr, _o.unusedStr) &&
		days == _o.days &&
		dummyFlags == _o.dummyFlags &&
		dummyFlags2 == _o.dummyFlags2 &&
		groupSelfExclusion == _o.groupSelfExclusion &&
		version == _o.version;
}

bool Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_EXCLUDE_PLAYER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_EXCLUDE_PLAYER*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_EXCLUDE_PLAYER).append(")");
	_buf.append(',');
	_buf.append("unusedStr=");
	_buf.append(unusedStr);
	_buf.append(',');
	_buf.append("days=");
	_buf.appendInt(days);
	_buf.append(',');
	_buf.append("dummyFlags=");
	_buf.appendUint(dummyFlags);
	_buf.append(',');
	_buf.append("dummyFlags2=");
	_buf.appendUint64(dummyFlags2);
	_buf.append(',');
	_buf.append("groupSelfExclusion=");
	_buf.appendUint(groupSelfExclusion);
	_buf.append(',');
	_buf.append("version=");
	_buf.appendUint(version);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_EXCLUDE_PLAYER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("unusedStr", unusedStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("days", days, _buf);
	Atf::XmlElement::encodeAsXmlElement("dummyFlags", dummyFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("dummyFlags2", dummyFlags2, _buf);
	Atf::XmlElement::encodeAsXmlElement("groupSelfExclusion", groupSelfExclusion, _buf);
	Atf::XmlElement::encodeAsXmlElement("version", version, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("unusedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, unusedStr)) return false;
			}
			else if (_element.equals("days"))
			{
				days = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("dummyFlags"))
			{
				dummyFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("dummyFlags2"))
			{
				dummyFlags2 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("groupSelfExclusion"))
			{
				groupSelfExclusion = (*_value.ptr() == '1');
			}
			else if (_element.equals("version"))
			{
				version = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(unusedStr);
	_msg.composeINT32(days);
	_msg.composeUINT32(dummyFlags);
	_msg.composeUINT64(dummyFlags2);
	_msg.composeBOOL(groupSelfExclusion);
	_msg.composeBYTE(version);
}

void Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(unusedStr);
	_parser.parseINT32(days);
	_parser.parseUINT32(dummyFlags);
	_parser.parseUINT64(dummyFlags2);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(groupSelfExclusion);
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(version);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("unusedStr", unusedStr);
	_jsonstr.compose("days", days);
	_jsonstr.compose("dummyFlags", dummyFlags);
	_jsonstr.compose("dummyFlags2", dummyFlags2);
	_jsonstr.compose("groupSelfExclusion", groupSelfExclusion);
	_jsonstr.compose("version", version);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("unusedStr", unusedStr);
	_jparser.parseByNameThrow("days", days);
	_jparser.parseByNameThrow("dummyFlags", dummyFlags);
	_jparser.parseByNameThrow("dummyFlags2", dummyFlags2);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("groupSelfExclusion", groupSelfExclusion);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("version", version);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_EXCLUDE_PLAYER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString unusedStr; _jparser.validateByNameThrow("unusedStr", unusedStr);
	AtfValidator::validateIntMax(_descr, "unusedStr", unusedStr.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	INT32 days; _jparser.validateByNameThrow("days", days);
	AtfValidator::validateIntRange(_descr, "days", days, -12, 36500, _checker, __FILE__, __LINE__);
	UINT32 dummyFlags; _jparser.validateByNameThrow("dummyFlags", dummyFlags);
	AtfValidator::validateInt(_descr, "dummyFlags", dummyFlags, _checker, __FILE__, __LINE__);
	UINT64 dummyFlags2; _jparser.validateByNameThrow("dummyFlags2", dummyFlags2);
	AtfValidator::validateUint(_descr, "dummyFlags2", dummyFlags2, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool groupSelfExclusion; _jparser.validateByNameThrow("groupSelfExclusion", groupSelfExclusion);
	AtfValidator::validateInt(_descr, "groupSelfExclusion", groupSelfExclusion, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	BYTE version; _jparser.validateByNameThrow("version", version);
	AtfValidator::validateInt(_descr, "version", version, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_EXCLUDE_PLAYER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "unusedStr"); size_t szUnusedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "unusedStr", szUnusedStr, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	INT32 days; _parser.parseINT32(days);
	AtfValidator::validateIntRange(_descr, "days", days, -12, 36500, _checker, __FILE__, __LINE__);
	UINT32 dummyFlags; _parser.parseUINT32(dummyFlags);
	AtfValidator::validateInt(_descr, "dummyFlags", dummyFlags, _checker, __FILE__, __LINE__);
	UINT64 dummyFlags2; _parser.parseUINT64(dummyFlags2);
	AtfValidator::validateUint(_descr, "dummyFlags2", dummyFlags2, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool groupSelfExclusion; _parser.parseBOOL(groupSelfExclusion);
	AtfValidator::validateInt(_descr, "groupSelfExclusion", groupSelfExclusion, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	BYTE version; _parser.parseBYTE(version);
	AtfValidator::validateInt(_descr, "version", version, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY::Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY::Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY(Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, days(std::move(_o.days))
	, until(std::move(_o.until))
	, requestedDays(std::move(_o.requestedDays))
	, seFlags(std::move(_o.seFlags))
{
}

Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY& Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY::operator=(Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		days = std::move(_o.days);
		until = std::move(_o.until);
		requestedDays = std::move(_o.requestedDays);
		seFlags = std::move(_o.seFlags);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	days = 0;
	until.setNull();
	requestedDays = 0;
	seFlags = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY::equals(const Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		days == _o.days &&
		until.equals(_o.until) &&
		requestedDays == _o.requestedDays &&
		seFlags == _o.seFlags;
}

bool Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_EXCLUDE_PLAYER_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_EXCLUDE_PLAYER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("days=");
		_buf.appendInt(days);
		_buf.append(',');
		_buf.append("until=");
		Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, until);
		_buf.append(',');
		_buf.append("requestedDays=");
		_buf.appendInt(requestedDays);
		_buf.append(',');
		_buf.append("seFlags=");
		_buf.appendUint(seFlags);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_EXCLUDE_PLAYER_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("days", days, _buf);
		Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "until", until);
		Atf::XmlElement::encodeAsXmlElement("requestedDays", requestedDays, _buf);
		Atf::XmlElement::encodeAsXmlElement("seFlags", seFlags, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("days"))
			{
				days = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("until"))
			{
				Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, until);
			}
			else if (_element.equals("requestedDays"))
			{
				requestedDays = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("seFlags"))
			{
				seFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(days);
		_msg.composeSrvTime(until);
		_msg.composeINT32(requestedDays);
		_msg.composeUINT32(seFlags);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(days);
		_parser.parseSrvTime(until);
		_parser.parseINT32(requestedDays);
		_parser.parseUINT32(seFlags);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("days", days);
		_jsonstr.compose("until", until);
		_jsonstr.compose("requestedDays", requestedDays);
		_jsonstr.compose("seFlags", seFlags);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("days", days);
		_jparser.parseByNameThrow("until", until);
		_jparser.parseByNameThrow("requestedDays", requestedDays);
		_jparser.parseByNameThrow("seFlags", seFlags);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_EXCLUDE_PLAYER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 days; _jparser.validateByNameThrow("days", days);
		AtfValidator::validateInt(_descr, "days", days, _checker, __FILE__, __LINE__);
		CommSrvTime until; _jparser.validateByNameThrow("until", until);
		AtfValidator::validateSrvDateTime(_descr, "until", until, _checker, __FILE__, __LINE__);
		INT32 requestedDays; _jparser.validateByNameThrow("requestedDays", requestedDays);
		AtfValidator::validateInt(_descr, "requestedDays", requestedDays, _checker, __FILE__, __LINE__);
		UINT32 seFlags; _jparser.validateByNameThrow("seFlags", seFlags);
		AtfValidator::validateInt(_descr, "seFlags", seFlags, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_EXCLUDE_PLAYER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 days; _parser.parseINT32(days);
		AtfValidator::validateInt(_descr, "days", days, _checker, __FILE__, __LINE__);
		CommSrvTime until; _parser.parseSrvTime(until);
		AtfValidator::validateSrvDateTime(_descr, "until", until, _checker, __FILE__, __LINE__);
		INT32 requestedDays; _parser.parseINT32(requestedDays);
		AtfValidator::validateInt(_descr, "requestedDays", requestedDays, _checker, __FILE__, __LINE__);
		UINT32 seFlags; _parser.parseUINT32(seFlags);
		AtfValidator::validateInt(_descr, "seFlags", seFlags, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP(Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP&& _o)
	: unusedStr(std::move(_o.unusedStr))
	, pwd(std::move(_o.pwd))
	, language(std::move(_o.language))
{
}

Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP& Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP::operator=(Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP&& _o)
{
	if(this != &_o)
	{
		unusedStr = std::move(_o.unusedStr);
		pwd = std::move(_o.pwd);
		language = std::move(_o.language);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP::clear()
{
	unusedStr.clear();
	pwd.clear();
	language.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP::equals(const Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP& _o) const
{
	return Atf::atfPStringEquals(unusedStr, _o.unusedStr) &&
		Atf::atfPStringEquals(pwd, _o.pwd) &&
		Atf::atfPStringEquals(language, _o.language);
}

bool Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_INTELLIPOKER_SIGNUP != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_INTELLIPOKER_SIGNUP).append(")");
	_buf.append(',');
	_buf.append("unusedStr=");
	_buf.append(unusedStr);
	_buf.append(',');
	_buf.append("pwd=");
	_buf.append(pwd);
	_buf.append(',');
	_buf.append("language=");
	_buf.append(language);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_INTELLIPOKER_SIGNUP).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("unusedStr", unusedStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("pwd", pwd, _buf);
	Atf::XmlElement::encodeAsXmlElement("language", language, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("unusedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, unusedStr)) return false;
			}
			else if (_element.equals("pwd"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, pwd)) return false;
			}
			else if (_element.equals("language"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, language)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(unusedStr);
	_msg.composeString(pwd);
	_msg.composeString(language);
}

void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(unusedStr);
	_parser.parseStringP(pwd);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(language);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("unusedStr", unusedStr);
	_jsonstr.compose("pwd", pwd);
	_jsonstr.compose("language", language);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("unusedStr", unusedStr);
	_jparser.parseByNameThrow("pwd", pwd);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("language", language);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_INTELLIPOKER_SIGNUP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString unusedStr; _jparser.validateByNameThrow("unusedStr", unusedStr);
	AtfValidator::validateIntMax(_descr, "unusedStr", unusedStr.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	PString pwd; _jparser.validateByNameThrow("pwd", pwd);
	AtfValidator::validateIntMax(_descr, "pwd", pwd.length(), 100, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString language; _jparser.validateByNameThrow("language", language);
	AtfValidator::validateIntMax(_descr, "language", language.length(), 100, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_INTELLIPOKER_SIGNUP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "unusedStr"); size_t szUnusedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "unusedStr", szUnusedStr, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "pwd"); size_t szPwd = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "pwd", szPwd, 100, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "language"); size_t szLanguage = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "language", szLanguage, 100, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY(Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, code(std::move(_o.code))
	, info(std::move(_o.info))
	, url(std::move(_o.url))
	, urlCaption(std::move(_o.urlCaption))
{
}

Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY& Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY::operator=(Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		code = std::move(_o.code);
		info = std::move(_o.info);
		url = std::move(_o.url);
		urlCaption = std::move(_o.urlCaption);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	code = 0;
	info.clear();
	url.clear();
	urlCaption.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY::equals(const Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		code == _o.code &&
		Atf::atfPStringEquals(info, _o.info) &&
		Atf::atfPStringEquals(url, _o.url) &&
		Atf::atfPStringEquals(urlCaption, _o.urlCaption);
}

bool Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("code=");
		_buf.appendUint(code);
		_buf.append(',');
		_buf.append("info=");
		_buf.append(info);
		_buf.append(',');
		_buf.append("url=");
		_buf.append(url);
		_buf.append(',');
		_buf.append("urlCaption=");
		_buf.append(urlCaption);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("code", code, _buf);
		Atf::XmlElement::encodeAsXmlElement("info", info, _buf);
		Atf::XmlElement::encodeAsXmlElement("url", url, _buf);
		Atf::XmlElement::encodeAsXmlElement("urlCaption", urlCaption, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("code"))
			{
				code = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("info"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, info)) return false;
			}
			else if (_element.equals("url"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, url)) return false;
			}
			else if (_element.equals("urlCaption"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, urlCaption)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(code);
		_msg.composeString(info);
		_msg.composeString(url);
		_msg.composeString(urlCaption);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(code);
		_parser.parseStringP(info);
		_parser.parseStringP(url);
		_parser.parseStringP(urlCaption);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("code", code);
		_jsonstr.compose("info", info);
		_jsonstr.compose("url", url);
		_jsonstr.compose("urlCaption", urlCaption);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("code", code);
		_jparser.parseByNameThrow("info", info);
		_jparser.parseByNameThrow("url", url);
		_jparser.parseByNameThrow("urlCaption", urlCaption);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 code; _jparser.validateByNameThrow("code", code);
		AtfValidator::validateInt(_descr, "code", code, _checker, __FILE__, __LINE__);
		PString info; _jparser.validateByNameThrow("info", info);
		AtfValidator::validateInt(_descr, "info", info.length(), _checker, __FILE__, __LINE__);
		PString url; _jparser.validateByNameThrow("url", url);
		AtfValidator::validateInt(_descr, "url", url.length(), _checker, __FILE__, __LINE__);
		PString urlCaption; _jparser.validateByNameThrow("urlCaption", urlCaption);
		AtfValidator::validateInt(_descr, "urlCaption", urlCaption.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 code; _parser.parseUINT32(code);
		AtfValidator::validateInt(_descr, "code", code, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "info"); size_t szInfo = strlen(_dummy);
		AtfValidator::validateInt(_descr, "info", szInfo, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "url"); size_t szUrl = strlen(_dummy);
		AtfValidator::validateInt(_descr, "url", szUrl, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "urlCaption"); size_t szUrlCaption = strlen(_dummy);
		AtfValidator::validateInt(_descr, "urlCaption", szUrlCaption, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_INTELLIPOKER_PWD
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD::Protocol_MSG_LOBBY_INTELLIPOKER_PWD()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD::Protocol_MSG_LOBBY_INTELLIPOKER_PWD(Protocol_MSG_LOBBY_INTELLIPOKER_PWD&& _o)
	: unusedStr(std::move(_o.unusedStr))
	, pwd(std::move(_o.pwd))
{
}

Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD& Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD::operator=(Protocol_MSG_LOBBY_INTELLIPOKER_PWD&& _o)
{
	if(this != &_o)
	{
		unusedStr = std::move(_o.unusedStr);
		pwd = std::move(_o.pwd);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD::clear()
{
	unusedStr.clear();
	pwd.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD::equals(const Protocol_MSG_LOBBY_INTELLIPOKER_PWD& _o) const
{
	return Atf::atfPStringEquals(unusedStr, _o.unusedStr) &&
		Atf::atfPStringEquals(pwd, _o.pwd);
}

bool Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_INTELLIPOKER_PWD != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_INTELLIPOKER_PWD*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_INTELLIPOKER_PWD).append(")");
	_buf.append(',');
	_buf.append("unusedStr=");
	_buf.append(unusedStr);
	_buf.append(',');
	_buf.append("pwd=");
	_buf.append(pwd);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_INTELLIPOKER_PWD).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("unusedStr", unusedStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("pwd", pwd, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("unusedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, unusedStr)) return false;
			}
			else if (_element.equals("pwd"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, pwd)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(unusedStr);
	_msg.composeString(pwd);
}

void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(unusedStr);
	_parser.parseStringP(pwd);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("unusedStr", unusedStr);
	_jsonstr.compose("pwd", pwd);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("unusedStr", unusedStr);
	_jparser.parseByNameThrow("pwd", pwd);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_INTELLIPOKER_PWD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString unusedStr; _jparser.validateByNameThrow("unusedStr", unusedStr);
	AtfValidator::validateIntMax(_descr, "unusedStr", unusedStr.length(), USER_NAME_LEN, _checker, __FILE__, __LINE__);
	PString pwd; _jparser.validateByNameThrow("pwd", pwd);
	AtfValidator::validateIntMax(_descr, "pwd", pwd.length(), 100, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_INTELLIPOKER_PWD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "unusedStr"); size_t szUnusedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "unusedStr", szUnusedStr, USER_NAME_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "pwd"); size_t szPwd = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "pwd", szPwd, 100, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY::Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY::Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY(Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, code(std::move(_o.code))
	, info(std::move(_o.info))
	, url(std::move(_o.url))
	, urlCaption(std::move(_o.urlCaption))
{
}

Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY& Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY::operator=(Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		code = std::move(_o.code);
		info = std::move(_o.info);
		url = std::move(_o.url);
		urlCaption = std::move(_o.urlCaption);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	code = 0;
	info.clear();
	url.clear();
	urlCaption.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY::equals(const Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		code == _o.code &&
		Atf::atfPStringEquals(info, _o.info) &&
		Atf::atfPStringEquals(url, _o.url) &&
		Atf::atfPStringEquals(urlCaption, _o.urlCaption);
}

bool Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_INTELLIPOKER_PWD_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_INTELLIPOKER_PWD_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("code=");
		_buf.appendUint(code);
		_buf.append(',');
		_buf.append("info=");
		_buf.append(info);
		_buf.append(',');
		_buf.append("url=");
		_buf.append(url);
		_buf.append(',');
		_buf.append("urlCaption=");
		_buf.append(urlCaption);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_INTELLIPOKER_PWD_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("code", code, _buf);
		Atf::XmlElement::encodeAsXmlElement("info", info, _buf);
		Atf::XmlElement::encodeAsXmlElement("url", url, _buf);
		Atf::XmlElement::encodeAsXmlElement("urlCaption", urlCaption, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("code"))
			{
				code = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("info"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, info)) return false;
			}
			else if (_element.equals("url"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, url)) return false;
			}
			else if (_element.equals("urlCaption"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, urlCaption)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(code);
		_msg.composeString(info);
		_msg.composeString(url);
		_msg.composeString(urlCaption);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(code);
		_parser.parseStringP(info);
		_parser.parseStringP(url);
		_parser.parseStringP(urlCaption);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("code", code);
		_jsonstr.compose("info", info);
		_jsonstr.compose("url", url);
		_jsonstr.compose("urlCaption", urlCaption);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("code", code);
		_jparser.parseByNameThrow("info", info);
		_jparser.parseByNameThrow("url", url);
		_jparser.parseByNameThrow("urlCaption", urlCaption);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_INTELLIPOKER_PWD_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 code; _jparser.validateByNameThrow("code", code);
		AtfValidator::validateInt(_descr, "code", code, _checker, __FILE__, __LINE__);
		PString info; _jparser.validateByNameThrow("info", info);
		AtfValidator::validateInt(_descr, "info", info.length(), _checker, __FILE__, __LINE__);
		PString url; _jparser.validateByNameThrow("url", url);
		AtfValidator::validateInt(_descr, "url", url.length(), _checker, __FILE__, __LINE__);
		PString urlCaption; _jparser.validateByNameThrow("urlCaption", urlCaption);
		AtfValidator::validateInt(_descr, "urlCaption", urlCaption.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_INTELLIPOKER_PWD_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 code; _parser.parseUINT32(code);
		AtfValidator::validateInt(_descr, "code", code, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "info"); size_t szInfo = strlen(_dummy);
		AtfValidator::validateInt(_descr, "info", szInfo, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "url"); size_t szUrl = strlen(_dummy);
		AtfValidator::validateInt(_descr, "url", szUrl, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "urlCaption"); size_t szUrlCaption = strlen(_dummy);
		AtfValidator::validateInt(_descr, "urlCaption", szUrlCaption, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    ConsentBody
//=================================================================

Lobby::cli::ConsentBody::ConsentBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::ConsentBody::ConsentBody(ConsentBody&& _o)
	: id(std::move(_o.id))
	, status(std::move(_o.status))
	, empty(std::move(_o.empty))
	, empty2(std::move(_o.empty2))
{
}

Lobby::cli::ConsentBody& Lobby::cli::ConsentBody::operator=(ConsentBody&& _o)
{
	if(this != &_o)
	{
		id = std::move(_o.id);
		status = std::move(_o.status);
		empty = std::move(_o.empty);
		empty2 = std::move(_o.empty2);
	}
	return *this;
}

#endif

void Lobby::cli::ConsentBody::clear()
{
	id = 0;
	status = 0;
	empty.clear();
	empty2.clear();
}

bool Lobby::cli::ConsentBody::equals(const ConsentBody& _o) const
{
	return id == _o.id &&
		status == _o.status &&
		Atf::atfPStringEquals(empty, _o.empty) &&
		Atf::atfPStringEquals(empty2, _o.empty2);
}

const char *Lobby::cli::ConsentBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("id=");
	_buf.appendUint(id);
	_buf.append(',');
	_buf.append("status=");
	_buf.appendUint(status);
	_buf.append(',');
	_buf.append("empty=");
	_buf.append(empty);
	_buf.append(',');
	_buf.append("empty2=");
	_buf.append(empty2);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::ConsentBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("id", id, _buf);
	Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
	Atf::XmlElement::encodeAsXmlElement("empty", empty, _buf);
	Atf::XmlElement::encodeAsXmlElement("empty2", empty2, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::ConsentBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("id"))
		{
			id = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("status"))
		{
			status = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("empty"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, empty)) return false;
		}
		else if (_element.equals("empty2"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, empty2)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::ConsentBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ConsentBody())) // not empty
	{
		_body.composeUINT32(id);
		_body.composeUINT32(status);
		_body.composeString(empty);
		_body.composeString(empty2);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::cli::ConsentBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(id);
	_parser0.parseUINT32(status);
	_parser0.parseStringP(empty);
	_parser0.parseStringP(empty2);
}

const char *Lobby::cli::ConsentBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("id", id);
	_jsonstr.compose("status", status);
	_jsonstr.compose("empty", empty);
	_jsonstr.compose("empty2", empty2);
	return _buf.c_str();
}

void Lobby::cli::ConsentBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("id", id);
	_jparser.parseByNameThrow("status", status);
	_jparser.parseByNameThrow("empty", empty);
	_jparser.parseByNameThrow("empty2", empty2);
}

/* static */ void Lobby::cli::ConsentBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 id; _jparser.validateByNameThrow("id", id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	UINT32 status; _jparser.validateByNameThrow("status", status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	PString empty; _jparser.validateByNameThrow("empty", empty);
	AtfValidator::validateInt(_descr, "empty", empty.length(), _checker, __FILE__, __LINE__);
	PString empty2; _jparser.validateByNameThrow("empty2", empty2);
	AtfValidator::validateInt(_descr, "empty2", empty2.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::ConsentBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 id; _parser0.parseUINT32(id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	UINT32 status; _parser0.parseUINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "empty"); size_t szEmpty = strlen(_dummy);
	AtfValidator::validateInt(_descr, "empty", szEmpty, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "empty2"); size_t szEmpty2 = strlen(_dummy);
	AtfValidator::validateInt(_descr, "empty2", szEmpty2, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_CONSENTS
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS::Protocol_MSG_LOBBY_GET_CONSENTS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS::Protocol_MSG_LOBBY_GET_CONSENTS(Protocol_MSG_LOBBY_GET_CONSENTS&& _o)
	: unusedStr(std::move(_o.unusedStr))
{
}

Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS& Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS::operator=(Protocol_MSG_LOBBY_GET_CONSENTS&& _o)
{
	if(this != &_o)
	{
		unusedStr = std::move(_o.unusedStr);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS::clear()
{
	unusedStr.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS::equals(const Protocol_MSG_LOBBY_GET_CONSENTS& _o) const
{
	return Atf::atfPStringEquals(unusedStr, _o.unusedStr);
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_CONSENTS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_CONSENTS*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_CONSENTS).append(")");
	_buf.append(',');
	_buf.append("unusedStr=");
	_buf.append(unusedStr);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_CONSENTS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("unusedStr", unusedStr, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("unusedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, unusedStr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(unusedStr);
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseStringP(unusedStr);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("unusedStr", unusedStr);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("unusedStr", unusedStr);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_CONSENTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	PString unusedStr; _jparser.validateByNameThrow("unusedStr", unusedStr);
	AtfValidator::validateIntMax(_descr, "unusedStr", unusedStr.length(), 20, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_CONSENTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "unusedStr"); size_t szUnusedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "unusedStr", szUnusedStr, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_CONSENTS_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS_REPLY::Protocol_MSG_LOBBY_GET_CONSENTS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS_REPLY::Protocol_MSG_LOBBY_GET_CONSENTS_REPLY(Protocol_MSG_LOBBY_GET_CONSENTS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, consents(std::move(_o.consents))
{
}

Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS_REPLY& Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS_REPLY::operator=(Protocol_MSG_LOBBY_GET_CONSENTS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		consents = std::move(_o.consents);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	consents.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS_REPLY::equals(const Protocol_MSG_LOBBY_GET_CONSENTS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		consents.equals(_o.consents);
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_CONSENTS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_CONSENTS_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_CONSENTS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("consents=");
		consents.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_CONSENTS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		consents.toXmlString("consents", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("consents"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ConsentBody, 4 > >::FromXmlString(_value, consents)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		consents.composeMsg(_msg, _ignoreJSON);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		consents.parseMsg(_parser);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("consents", consents);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("consents", consents);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_CONSENTS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< ConsentBody > consents; _jparser.validateByNameThrow("consents", consents);
		AtfValidator::validateInt(_descr, "consents", consents.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_CONSENTS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_CONSENTS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szConsents = Atf::LAtfVector< ConsentBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("consents"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "consents", szConsents, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_USER_STATS
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_USER_STATS::Protocol_MSG_LOBBY_USER_STATS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_USER_STATS::Protocol_MSG_LOBBY_USER_STATS(Protocol_MSG_LOBBY_USER_STATS&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, numHands(std::move(_o.numHands))
{
}

Lobby::cli::Protocol_MSG_LOBBY_USER_STATS& Lobby::cli::Protocol_MSG_LOBBY_USER_STATS::operator=(Protocol_MSG_LOBBY_USER_STATS&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		numHands = std::move(_o.numHands);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_USER_STATS::clear()
{
	notUsedStr.clear();
	numHands = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_USER_STATS::equals(const Protocol_MSG_LOBBY_USER_STATS& _o) const
{
	return Atf::atfPStringEquals(notUsedStr, _o.notUsedStr) &&
		numHands == _o.numHands;
}

bool Lobby::cli::Protocol_MSG_LOBBY_USER_STATS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_USER_STATS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_USER_STATS*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_USER_STATS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_USER_STATS).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("numHands=");
	_buf.appendInt(numHands);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_USER_STATS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_USER_STATS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_USER_STATS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsedStr", notUsedStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("numHands", numHands, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_USER_STATS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedStr)) return false;
			}
			else if (_element.equals("numHands"))
			{
				numHands = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_USER_STATS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsedStr);
	_msg.composeINT32(numHands);
}

void Lobby::cli::Protocol_MSG_LOBBY_USER_STATS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseINT32(numHands);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_USER_STATS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsedStr", notUsedStr);
	_jsonstr.compose("numHands", numHands);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_USER_STATS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsedStr", notUsedStr);
	_jparser.parseByNameThrow("numHands", numHands);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_USER_STATS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_USER_STATS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsedStr; _jparser.validateByNameThrow("notUsedStr", notUsedStr);
	AtfValidator::validateIntMax(_descr, "notUsedStr", notUsedStr.length(), 20, _checker, __FILE__, __LINE__);
	INT32 numHands; _jparser.validateByNameThrow("numHands", numHands);
	AtfValidator::validateIntRange(_descr, "numHands", numHands, 1, 2000, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_USER_STATS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_USER_STATS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	INT32 numHands; _parser.parseINT32(numHands);
	AtfValidator::validateIntRange(_descr, "numHands", numHands, 1, 2000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_USER_STATS_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_USER_STATS_REPLY::Protocol_MSG_LOBBY_USER_STATS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_USER_STATS_REPLY::Protocol_MSG_LOBBY_USER_STATS_REPLY(Protocol_MSG_LOBBY_USER_STATS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, email(std::move(_o.email))
{
}

Lobby::cli::Protocol_MSG_LOBBY_USER_STATS_REPLY& Lobby::cli::Protocol_MSG_LOBBY_USER_STATS_REPLY::operator=(Protocol_MSG_LOBBY_USER_STATS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		email = std::move(_o.email);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_USER_STATS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	email.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_USER_STATS_REPLY::equals(const Protocol_MSG_LOBBY_USER_STATS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(email, _o.email);
}

bool Lobby::cli::Protocol_MSG_LOBBY_USER_STATS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_USER_STATS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_USER_STATS_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_USER_STATS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_USER_STATS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("email=");
		_buf.append(email);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_USER_STATS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_USER_STATS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_USER_STATS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("email", email, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_USER_STATS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("email"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, email)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_USER_STATS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(email);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_USER_STATS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(email);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_USER_STATS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("email", email);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_USER_STATS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("email", email);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_USER_STATS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_USER_STATS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString email; _jparser.validateByNameThrow("email", email);
		AtfValidator::validateInt(_descr, "email", email.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_USER_STATS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_USER_STATS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
		AtfValidator::validateInt(_descr, "email", szEmail, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_TOURN_STATS
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS::Protocol_MSG_LOBBY_TOURN_STATS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS::Protocol_MSG_LOBBY_TOURN_STATS(Protocol_MSG_LOBBY_TOURN_STATS&& _o)
	: requestType(std::move(_o.requestType))
	, notUsedStr(std::move(_o.notUsedStr))
	, tournIdOrCount(std::move(_o.tournIdOrCount))
{
}

Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS& Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS::operator=(Protocol_MSG_LOBBY_TOURN_STATS&& _o)
{
	if(this != &_o)
	{
		requestType = std::move(_o.requestType);
		notUsedStr = std::move(_o.notUsedStr);
		tournIdOrCount = std::move(_o.tournIdOrCount);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS::clear()
{
	requestType = 0;
	notUsedStr.clear();
	tournIdOrCount = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS::equals(const Protocol_MSG_LOBBY_TOURN_STATS& _o) const
{
	return requestType == _o.requestType &&
		Atf::atfPStringEquals(notUsedStr, _o.notUsedStr) &&
		tournIdOrCount == _o.tournIdOrCount;
}

bool Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_TOURN_STATS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_TOURN_STATS*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_TOURN_STATS).append(")");
	_buf.append(',');
	_buf.append("requestType=");
	_buf.appendUint(requestType);
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("tournIdOrCount=");
	_buf.appendUint(tournIdOrCount);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_TOURN_STATS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestType", requestType, _buf);
	Atf::XmlElement::encodeAsXmlElement("notUsedStr", notUsedStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournIdOrCount", tournIdOrCount, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestType"))
			{
				requestType = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("notUsedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedStr)) return false;
			}
			else if (_element.equals("tournIdOrCount"))
			{
				tournIdOrCount = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(requestType);
	_msg.composeString(notUsedStr);
	_msg.composeUINT32(tournIdOrCount);
}

void Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(requestType);
	_parser.parseStringP(notUsedStr);
	_parser.parseUINT32(tournIdOrCount);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestType", requestType);
	_jsonstr.compose("notUsedStr", notUsedStr);
	_jsonstr.compose("tournIdOrCount", tournIdOrCount);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestType", requestType);
	_jparser.parseByNameThrow("notUsedStr", notUsedStr);
	_jparser.parseByNameThrow("tournIdOrCount", tournIdOrCount);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TOURN_STATS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE requestType; _jparser.validateByNameThrow("requestType", requestType);
	AtfValidator::validateIntRange(_descr, "requestType", requestType, TOURN_STATS_TOURN_ID, TOURN_STATS_TOURN_ID_NOSTAT, _checker, __FILE__, __LINE__);
	PString notUsedStr; _jparser.validateByNameThrow("notUsedStr", notUsedStr);
	AtfValidator::validateIntMax(_descr, "notUsedStr", notUsedStr.length(), 20, _checker, __FILE__, __LINE__);
	UINT32 tournIdOrCount; _jparser.validateByNameThrow("tournIdOrCount", tournIdOrCount);
	AtfValidator::validateInt(_descr, "tournIdOrCount", tournIdOrCount, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TOURN_STATS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE requestType; _parser.parseBYTE(requestType);
	AtfValidator::validateIntRange(_descr, "requestType", requestType, TOURN_STATS_TOURN_ID, TOURN_STATS_TOURN_ID_NOSTAT, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	UINT32 tournIdOrCount; _parser.parseUINT32(tournIdOrCount);
	AtfValidator::validateInt(_descr, "tournIdOrCount", tournIdOrCount, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_TOURN_STATS_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS_REPLY::Protocol_MSG_LOBBY_TOURN_STATS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS_REPLY::Protocol_MSG_LOBBY_TOURN_STATS_REPLY(Protocol_MSG_LOBBY_TOURN_STATS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, email(std::move(_o.email))
{
}

Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS_REPLY& Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS_REPLY::operator=(Protocol_MSG_LOBBY_TOURN_STATS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		email = std::move(_o.email);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	email.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS_REPLY::equals(const Protocol_MSG_LOBBY_TOURN_STATS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(email, _o.email);
}

bool Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_TOURN_STATS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_TOURN_STATS_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_TOURN_STATS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("email=");
		_buf.append(email);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_TOURN_STATS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("email", email, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("email"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, email)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(email);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(email);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("email", email);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("email", email);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TOURN_STATS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString email; _jparser.validateByNameThrow("email", email);
		AtfValidator::validateInt(_descr, "email", email.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_TOURN_STATS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TOURN_STATS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
		AtfValidator::validateInt(_descr, "email", szEmail, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_LOGOUT
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_LOGOUT::Protocol_MSG_LOBBY_LOGOUT()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_LOGOUT::clear()
{
	flags = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_LOGOUT::equals(const Protocol_MSG_LOBBY_LOGOUT& _o) const
{
	return flags == _o.flags;
}

bool Lobby::cli::Protocol_MSG_LOBBY_LOGOUT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_LOGOUT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_LOGOUT*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_LOGOUT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_LOGOUT).append(")");
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_LOGOUT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_LOGOUT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_LOGOUT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_LOGOUT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("flags"))
			{
				flags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_LOGOUT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(flags);
}

void Lobby::cli::Protocol_MSG_LOBBY_LOGOUT::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(flags);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_LOGOUT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("flags", flags);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_LOGOUT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("flags", flags);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_LOGOUT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_LOGOUT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	UINT32 flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_LOGOUT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_LOGOUT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(_parser.parseEnded()) return;
	UINT32 flags; _parser.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_LOGOUT_CONFIRM
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_LOGOUT_CONFIRM::Protocol_MSG_LOBBY_LOGOUT_CONFIRM()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_LOGOUT_CONFIRM::clear()
{
}

bool Lobby::cli::Protocol_MSG_LOBBY_LOGOUT_CONFIRM::equals(const Protocol_MSG_LOBBY_LOGOUT_CONFIRM& _o) const
{
	return true;
}

bool Lobby::cli::Protocol_MSG_LOBBY_LOGOUT_CONFIRM::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_LOGOUT_CONFIRM != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_LOGOUT_CONFIRM*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_LOGOUT_CONFIRM::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_LOGOUT_CONFIRM).append(")");
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_LOGOUT_CONFIRM::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_LOGOUT_CONFIRM::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_LOGOUT_CONFIRM).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_LOGOUT_CONFIRM::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_LOGOUT_CONFIRM::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void Lobby::cli::Protocol_MSG_LOBBY_LOGOUT_CONFIRM::parseMsg(CommMsgParser& _parser)
{
}

const char *Lobby::cli::Protocol_MSG_LOBBY_LOGOUT_CONFIRM::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_LOGOUT_CONFIRM::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_LOGOUT_CONFIRM::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_LOGOUT_CONFIRM";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_LOGOUT_CONFIRM::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_LOGOUT_CONFIRM";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_ADMIN_INFO
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO::Protocol_MSG_LOBBY_ADMIN_INFO()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO::Protocol_MSG_LOBBY_ADMIN_INFO(Protocol_MSG_LOBBY_ADMIN_INFO&& _o)
	: message(std::move(_o.message))
{
}

Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO& Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO::operator=(Protocol_MSG_LOBBY_ADMIN_INFO&& _o)
{
	if(this != &_o)
	{
		message = std::move(_o.message);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO::clear()
{
	message.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO::equals(const Protocol_MSG_LOBBY_ADMIN_INFO& _o) const
{
	return Atf::atfPStringEquals(message, _o.message);
}

bool Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_ADMIN_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_ADMIN_INFO*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_ADMIN_INFO).append(")");
	_buf.append(',');
	_buf.append("message=");
	_buf.append(message);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_ADMIN_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("message", message, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("message"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, message)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(message);
}

void Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(message);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("message", message);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("message", message);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_ADMIN_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString message; _jparser.validateByNameThrow("message", message);
	AtfValidator::validateIntMax(_descr, "message", message.length(), 10000, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_ADMIN_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "message"); size_t szMessage = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "message", szMessage, 10000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_ADMIN_INFO_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::clear()
{
}

bool Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::equals(const Protocol_MSG_LOBBY_ADMIN_INFO_REPLY& _o) const
{
	return true;
}

bool Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_ADMIN_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_ADMIN_INFO_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_ADMIN_INFO_REPLY).append(")");
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_ADMIN_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
}

const char *Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_ADMIN_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_ADMIN_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_TLB
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_TLB::Protocol_MSG_LOBBY_GET_TLB()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_GET_TLB::Protocol_MSG_LOBBY_GET_TLB(Protocol_MSG_LOBBY_GET_TLB&& _o)
	: notUsed(std::move(_o.notUsed))
	, dateFrom(std::move(_o.dateFrom))
	, dateTo(std::move(_o.dateTo))
{
}

Lobby::cli::Protocol_MSG_LOBBY_GET_TLB& Lobby::cli::Protocol_MSG_LOBBY_GET_TLB::operator=(Protocol_MSG_LOBBY_GET_TLB&& _o)
{
	if(this != &_o)
	{
		notUsed = std::move(_o.notUsed);
		dateFrom = std::move(_o.dateFrom);
		dateTo = std::move(_o.dateTo);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_GET_TLB::clear()
{
	notUsed.clear();
	dateFrom.setNull();
	dateTo.setNull();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_TLB::equals(const Protocol_MSG_LOBBY_GET_TLB& _o) const
{
	return Atf::atfPStringEquals(notUsed, _o.notUsed) &&
		dateFrom.equals(_o.dateFrom) &&
		dateTo.equals(_o.dateTo);
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_TLB::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_TLB != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_TLB*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_TLB::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_TLB).append(")");
	_buf.append(',');
	_buf.append("notUsed=");
	_buf.append(notUsed);
	_buf.append(',');
	_buf.append("dateFrom=");
	Atf::AtfTempl<SrvDate>::ToTraceString(_buf, dateFrom);
	_buf.append(',');
	_buf.append("dateTo=");
	Atf::AtfTempl<SrvDate>::ToTraceString(_buf, dateTo);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_TLB::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_TLB::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_TLB).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsed", notUsed, _buf);
	Atf::AtfTempl<SrvDate>::ToXmlString(_buf, "dateFrom", dateFrom);
	Atf::AtfTempl<SrvDate>::ToXmlString(_buf, "dateTo", dateTo);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_TLB::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsed"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsed)) return false;
			}
			else if (_element.equals("dateFrom"))
			{
				Atf::AtfTempl<SrvDate>::FromXmlString(_value, dateFrom);
			}
			else if (_element.equals("dateTo"))
			{
				Atf::AtfTempl<SrvDate>::FromXmlString(_value, dateTo);
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_TLB::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsed);
	_msg.composeSrvDate(dateFrom);
	_msg.composeSrvDate(dateTo);
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_TLB::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsed);
	_parser.parseSrvDate(dateFrom);
	_parser.parseSrvDate(dateTo);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_TLB::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsed", notUsed);
	_jsonstr.compose("dateFrom", dateFrom);
	_jsonstr.compose("dateTo", dateTo);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_TLB::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsed", notUsed);
	_jparser.parseByNameThrow("dateFrom", dateFrom);
	_jparser.parseByNameThrow("dateTo", dateTo);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_TLB::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_TLB";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsed; _jparser.validateByNameThrow("notUsed", notUsed);
	AtfValidator::validateIntMax(_descr, "notUsed", notUsed.length(), 20, _checker, __FILE__, __LINE__);
	SrvDate dateFrom; _jparser.validateByNameThrow("dateFrom", dateFrom);
	AtfValidator::validateSrvDateTime(_descr, "dateFrom", dateFrom, _checker, __FILE__, __LINE__);
	SrvDate dateTo; _jparser.validateByNameThrow("dateTo", dateTo);
	AtfValidator::validateSrvDateTime(_descr, "dateTo", dateTo, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_TLB::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_TLB";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsed"); size_t szNotUsed = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsed", szNotUsed, 20, _checker, __FILE__, __LINE__);
	SrvDate dateFrom; _parser.parseSrvDate(dateFrom);
	AtfValidator::validateSrvDateTime(_descr, "dateFrom", dateFrom, _checker, __FILE__, __LINE__);
	SrvDate dateTo; _parser.parseSrvDate(dateTo);
	AtfValidator::validateSrvDateTime(_descr, "dateTo", dateTo, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_TLB_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_TLB_REPLY::Protocol_MSG_LOBBY_GET_TLB_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_GET_TLB_REPLY::Protocol_MSG_LOBBY_GET_TLB_REPLY(Protocol_MSG_LOBBY_GET_TLB_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, email(std::move(_o.email))
{
}

Lobby::cli::Protocol_MSG_LOBBY_GET_TLB_REPLY& Lobby::cli::Protocol_MSG_LOBBY_GET_TLB_REPLY::operator=(Protocol_MSG_LOBBY_GET_TLB_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		email = std::move(_o.email);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_GET_TLB_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	email.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_TLB_REPLY::equals(const Protocol_MSG_LOBBY_GET_TLB_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(email, _o.email);
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_TLB_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_TLB_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_TLB_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_TLB_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_TLB_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("email=");
		_buf.append(email);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_TLB_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_TLB_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_TLB_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("email", email, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_TLB_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("email"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, email)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_TLB_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(email);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_TLB_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(email);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_TLB_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("email", email);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_TLB_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("email", email);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_TLB_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_TLB_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString email; _jparser.validateByNameThrow("email", email);
		AtfValidator::validateInt(_descr, "email", email.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_TLB_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_TLB_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
		AtfValidator::validateInt(_descr, "email", szEmail, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_USER_PROPS
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS::Protocol_MSG_LOBBY_USER_PROPS()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS::clear()
{
}

bool Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS::equals(const Protocol_MSG_LOBBY_USER_PROPS& _o) const
{
	return true;
}

bool Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_USER_PROPS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_USER_PROPS*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_USER_PROPS).append(")");
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_USER_PROPS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS::parseMsg(CommMsgParser& _parser)
{
}

const char *Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_USER_PROPS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_USER_PROPS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    StellarBonus
//=================================================================

Lobby::cli::StellarBonus::StellarBonus()
{
	clear();
}

void Lobby::cli::StellarBonus::clear()
{
	vppThreshold = 0;
	amount = 0;
}

bool Lobby::cli::StellarBonus::equals(const StellarBonus& _o) const
{
	return vppThreshold == _o.vppThreshold &&
		amount == _o.amount;
}

const char *Lobby::cli::StellarBonus::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("vppThreshold=");
	_buf.appendUint(vppThreshold);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendUint(amount);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::StellarBonus::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("vppThreshold", vppThreshold, _buf);
	Atf::XmlElement::encodeAsXmlElement("amount", amount, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::StellarBonus::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("vppThreshold"))
		{
			vppThreshold = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("amount"))
		{
			amount = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::StellarBonus::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(vppThreshold);
	_msg.composeUINT32(amount);
}

void Lobby::cli::StellarBonus::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(vppThreshold);
	_parser.parseUINT32(amount);
}

const char *Lobby::cli::StellarBonus::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("vppThreshold", vppThreshold);
	_jsonstr.compose("amount", amount);
	return _buf.c_str();
}

void Lobby::cli::StellarBonus::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("vppThreshold", vppThreshold);
	_jparser.parseByNameThrow("amount", amount);
}

/* static */ void Lobby::cli::StellarBonus::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 vppThreshold; _jparser.validateByNameThrow("vppThreshold", vppThreshold);
	AtfValidator::validateInt(_descr, "vppThreshold", vppThreshold, _checker, __FILE__, __LINE__);
	UINT32 amount; _jparser.validateByNameThrow("amount", amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::StellarBonus::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 vppThreshold; _parser.parseUINT32(vppThreshold);
	AtfValidator::validateInt(_descr, "vppThreshold", vppThreshold, _checker, __FILE__, __LINE__);
	UINT32 amount; _parser.parseUINT32(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    MilestoneBonusOld
//=================================================================

Lobby::cli::MilestoneBonusOld::MilestoneBonusOld()
{
	clear();
}

void Lobby::cli::MilestoneBonusOld::clear()
{
	vppThreshold = 0;
}

bool Lobby::cli::MilestoneBonusOld::equals(const MilestoneBonusOld& _o) const
{
	return vppThreshold == _o.vppThreshold;
}

const char *Lobby::cli::MilestoneBonusOld::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("vppThreshold=");
	_buf.appendUint(vppThreshold);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::MilestoneBonusOld::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("vppThreshold", vppThreshold, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::MilestoneBonusOld::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("vppThreshold"))
		{
			vppThreshold = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::MilestoneBonusOld::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(vppThreshold);
}

void Lobby::cli::MilestoneBonusOld::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(vppThreshold);
}

const char *Lobby::cli::MilestoneBonusOld::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("vppThreshold", vppThreshold);
	return _buf.c_str();
}

void Lobby::cli::MilestoneBonusOld::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("vppThreshold", vppThreshold);
}

/* static */ void Lobby::cli::MilestoneBonusOld::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 vppThreshold; _jparser.validateByNameThrow("vppThreshold", vppThreshold);
	AtfValidator::validateInt(_descr, "vppThreshold", vppThreshold, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::MilestoneBonusOld::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 vppThreshold; _parser.parseUINT32(vppThreshold);
	AtfValidator::validateInt(_descr, "vppThreshold", vppThreshold, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    MilestoneBonusNew
//=================================================================

Lobby::cli::MilestoneBonusNew::MilestoneBonusNew()
{
	clear();
}

void Lobby::cli::MilestoneBonusNew::clear()
{
	license = 0;
	vppThreshold = 0;
	amount = 0;
}

bool Lobby::cli::MilestoneBonusNew::equals(const MilestoneBonusNew& _o) const
{
	return license == _o.license &&
		vppThreshold == _o.vppThreshold &&
		amount == _o.amount;
}

const char *Lobby::cli::MilestoneBonusNew::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("license=");
	_buf.appendUint(license);
	_buf.append(',');
	_buf.append("vppThreshold=");
	_buf.appendUint(vppThreshold);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendUint(amount);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::MilestoneBonusNew::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("license", license, _buf);
	Atf::XmlElement::encodeAsXmlElement("vppThreshold", vppThreshold, _buf);
	Atf::XmlElement::encodeAsXmlElement("amount", amount, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::MilestoneBonusNew::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("license"))
		{
			license = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("vppThreshold"))
		{
			vppThreshold = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("amount"))
		{
			amount = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::MilestoneBonusNew::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(MilestoneBonusNew())) // not empty
	{
		CommMsgBody _body0;
		_body0.composeUINT32(license);
		_body0.composeUINT32(vppThreshold);
		_body0.composeUINT32(amount);
		_body.composeMsgBody(_body0);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::cli::MilestoneBonusNew::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	parseAnonymousMsgBody0(_parser0);
}

const char *Lobby::cli::MilestoneBonusNew::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("license", license);
	_jsonstr.compose("vppThreshold", vppThreshold);
	_jsonstr.compose("amount", amount);
	return _buf.c_str();
}

void Lobby::cli::MilestoneBonusNew::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("license", license);
	_jparser.parseByNameThrow("vppThreshold", vppThreshold);
	_jparser.parseByNameThrow("amount", amount);
}

/* static */ void Lobby::cli::MilestoneBonusNew::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 license; _jparser.validateByNameThrow("license", license);
	AtfValidator::validateInt(_descr, "license", license, _checker, __FILE__, __LINE__);
	UINT32 vppThreshold; _jparser.validateByNameThrow("vppThreshold", vppThreshold);
	AtfValidator::validateInt(_descr, "vppThreshold", vppThreshold, _checker, __FILE__, __LINE__);
	UINT32 amount; _jparser.validateByNameThrow("amount", amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::MilestoneBonusNew::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	validateAnonymousMsgBody0(_parser0, _checker, _descr, _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void Lobby::cli::MilestoneBonusNew::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(license);
	_parser0.parseUINT32(vppThreshold);
	_parser0.parseUINT32(amount);
}

/*static*/ void Lobby::cli::MilestoneBonusNew::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 license; _parser0.parseUINT32(license);
	AtfValidator::validateInt(_descr, "license", license, _checker, __FILE__, __LINE__);
	UINT32 vppThreshold; _parser0.parseUINT32(vppThreshold);
	AtfValidator::validateInt(_descr, "vppThreshold", vppThreshold, _checker, __FILE__, __LINE__);
	UINT32 amount; _parser0.parseUINT32(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    VIPLevel
//=================================================================

Lobby::cli::VIPLevel::VIPLevel()
{
	clear();
}

void Lobby::cli::VIPLevel::clear()
{
	statusId = 0;
	minFpp = 0;
	fppBonusRate = 0;
	vipToKeepYearlyStatus = 0;
}

bool Lobby::cli::VIPLevel::equals(const VIPLevel& _o) const
{
	return statusId == _o.statusId &&
		minFpp == _o.minFpp &&
		fppBonusRate == _o.fppBonusRate &&
		vipToKeepYearlyStatus == _o.vipToKeepYearlyStatus;
}

const char *Lobby::cli::VIPLevel::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("statusId=");
	_buf.appendUint(statusId);
	_buf.append(',');
	_buf.append("minFpp=");
	_buf.appendUint(minFpp);
	_buf.append(',');
	_buf.append("fppBonusRate=");
	_buf.appendUint(fppBonusRate);
	_buf.append(',');
	_buf.append("vipToKeepYearlyStatus=");
	_buf.appendUint(vipToKeepYearlyStatus);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::VIPLevel::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("statusId", statusId, _buf);
	Atf::XmlElement::encodeAsXmlElement("minFpp", minFpp, _buf);
	Atf::XmlElement::encodeAsXmlElement("fppBonusRate", fppBonusRate, _buf);
	Atf::XmlElement::encodeAsXmlElement("vipToKeepYearlyStatus", vipToKeepYearlyStatus, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::VIPLevel::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("statusId"))
		{
			statusId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minFpp"))
		{
			minFpp = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("fppBonusRate"))
		{
			fppBonusRate = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("vipToKeepYearlyStatus"))
		{
			vipToKeepYearlyStatus = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::VIPLevel::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(statusId);
	_msg.composeUINT32(minFpp);
	_msg.composeUINT32(fppBonusRate);
	_msg.composeUINT32(vipToKeepYearlyStatus);
}

void Lobby::cli::VIPLevel::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(statusId);
	_parser.parseUINT32(minFpp);
	_parser.parseUINT32(fppBonusRate);
	_parser.parseUINT32(vipToKeepYearlyStatus);
}

const char *Lobby::cli::VIPLevel::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("statusId", statusId);
	_jsonstr.compose("minFpp", minFpp);
	_jsonstr.compose("fppBonusRate", fppBonusRate);
	_jsonstr.compose("vipToKeepYearlyStatus", vipToKeepYearlyStatus);
	return _buf.c_str();
}

void Lobby::cli::VIPLevel::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("statusId", statusId);
	_jparser.parseByNameThrow("minFpp", minFpp);
	_jparser.parseByNameThrow("fppBonusRate", fppBonusRate);
	_jparser.parseByNameThrow("vipToKeepYearlyStatus", vipToKeepYearlyStatus);
}

/* static */ void Lobby::cli::VIPLevel::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 statusId; _jparser.validateByNameThrow("statusId", statusId);
	AtfValidator::validateInt(_descr, "statusId", statusId, _checker, __FILE__, __LINE__);
	UINT32 minFpp; _jparser.validateByNameThrow("minFpp", minFpp);
	AtfValidator::validateInt(_descr, "minFpp", minFpp, _checker, __FILE__, __LINE__);
	UINT32 fppBonusRate; _jparser.validateByNameThrow("fppBonusRate", fppBonusRate);
	AtfValidator::validateInt(_descr, "fppBonusRate", fppBonusRate, _checker, __FILE__, __LINE__);
	UINT32 vipToKeepYearlyStatus; _jparser.validateByNameThrow("vipToKeepYearlyStatus", vipToKeepYearlyStatus);
	AtfValidator::validateInt(_descr, "vipToKeepYearlyStatus", vipToKeepYearlyStatus, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::VIPLevel::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 statusId; _parser.parseUINT32(statusId);
	AtfValidator::validateInt(_descr, "statusId", statusId, _checker, __FILE__, __LINE__);
	UINT32 minFpp; _parser.parseUINT32(minFpp);
	AtfValidator::validateInt(_descr, "minFpp", minFpp, _checker, __FILE__, __LINE__);
	UINT32 fppBonusRate; _parser.parseUINT32(fppBonusRate);
	AtfValidator::validateInt(_descr, "fppBonusRate", fppBonusRate, _checker, __FILE__, __LINE__);
	UINT32 vipToKeepYearlyStatus; _parser.parseUINT32(vipToKeepYearlyStatus);
	AtfValidator::validateInt(_descr, "vipToKeepYearlyStatus", vipToKeepYearlyStatus, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    RawVIPLevel
//=================================================================

Lobby::cli::RawVIPLevel::RawVIPLevel()
{
	clear();
}

void Lobby::cli::RawVIPLevel::clear()
{
	statusId = 0;
	type = 0;
	minFpp = 0;
	fppBonusRate = 0;
	vipToKeepYearlyStatus = 0;
	lastMonthForYearly = 0;
	missableMonthsYearly = 0;
}

bool Lobby::cli::RawVIPLevel::equals(const RawVIPLevel& _o) const
{
	return statusId == _o.statusId &&
		type == _o.type &&
		minFpp == _o.minFpp &&
		fppBonusRate == _o.fppBonusRate &&
		vipToKeepYearlyStatus == _o.vipToKeepYearlyStatus &&
		lastMonthForYearly == _o.lastMonthForYearly &&
		missableMonthsYearly == _o.missableMonthsYearly;
}

const char *Lobby::cli::RawVIPLevel::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("statusId=");
	_buf.appendUint(statusId);
	_buf.append(',');
	_buf.append("type=");
	_buf.appendUint(type);
	_buf.append(',');
	_buf.append("minFpp=");
	_buf.appendUint(minFpp);
	_buf.append(',');
	_buf.append("fppBonusRate=");
	_buf.appendUint(fppBonusRate);
	_buf.append(',');
	_buf.append("vipToKeepYearlyStatus=");
	_buf.appendUint(vipToKeepYearlyStatus);
	_buf.append(',');
	_buf.append("lastMonthForYearly=");
	_buf.appendUint(lastMonthForYearly);
	_buf.append(',');
	_buf.append("missableMonthsYearly=");
	_buf.appendUint(missableMonthsYearly);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::RawVIPLevel::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("statusId", statusId, _buf);
	Atf::XmlElement::encodeAsXmlElement("type", type, _buf);
	Atf::XmlElement::encodeAsXmlElement("minFpp", minFpp, _buf);
	Atf::XmlElement::encodeAsXmlElement("fppBonusRate", fppBonusRate, _buf);
	Atf::XmlElement::encodeAsXmlElement("vipToKeepYearlyStatus", vipToKeepYearlyStatus, _buf);
	Atf::XmlElement::encodeAsXmlElement("lastMonthForYearly", lastMonthForYearly, _buf);
	Atf::XmlElement::encodeAsXmlElement("missableMonthsYearly", missableMonthsYearly, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::RawVIPLevel::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("statusId"))
		{
			statusId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("type"))
		{
			type = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minFpp"))
		{
			minFpp = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("fppBonusRate"))
		{
			fppBonusRate = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("vipToKeepYearlyStatus"))
		{
			vipToKeepYearlyStatus = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("lastMonthForYearly"))
		{
			lastMonthForYearly = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("missableMonthsYearly"))
		{
			missableMonthsYearly = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::RawVIPLevel::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	_msg0.composeUINT32(statusId);
	_msg0.composeUINT32(type);
	_msg0.composeUINT32(minFpp);
	_msg0.composeUINT32(fppBonusRate);
	_msg0.composeUINT32(vipToKeepYearlyStatus);
	_msg0.composeUINT32(lastMonthForYearly);
	_msg0.composeUINT32(missableMonthsYearly);
	_msg.composeMsgBody(_msg0);
}

void Lobby::cli::RawVIPLevel::parseMsg(CommMsgParser& _parser)
{
	parseAnonymousMsgBody0(_parser);
}

const char *Lobby::cli::RawVIPLevel::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("statusId", statusId);
	_jsonstr.compose("type", type);
	_jsonstr.compose("minFpp", minFpp);
	_jsonstr.compose("fppBonusRate", fppBonusRate);
	_jsonstr.compose("vipToKeepYearlyStatus", vipToKeepYearlyStatus);
	_jsonstr.compose("lastMonthForYearly", lastMonthForYearly);
	_jsonstr.compose("missableMonthsYearly", missableMonthsYearly);
	return _buf.c_str();
}

void Lobby::cli::RawVIPLevel::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("statusId", statusId);
	_jparser.parseByNameThrow("type", type);
	_jparser.parseByNameThrow("minFpp", minFpp);
	_jparser.parseByNameThrow("fppBonusRate", fppBonusRate);
	_jparser.parseByNameThrow("vipToKeepYearlyStatus", vipToKeepYearlyStatus);
	_jparser.parseByNameThrow("lastMonthForYearly", lastMonthForYearly);
	_jparser.parseByNameThrow("missableMonthsYearly", missableMonthsYearly);
}

/* static */ void Lobby::cli::RawVIPLevel::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 statusId; _jparser.validateByNameThrow("statusId", statusId);
	AtfValidator::validateInt(_descr, "statusId", statusId, _checker, __FILE__, __LINE__);
	UINT32 type; _jparser.validateByNameThrow("type", type);
	AtfValidator::validateInt(_descr, "type", type, _checker, __FILE__, __LINE__);
	UINT32 minFpp; _jparser.validateByNameThrow("minFpp", minFpp);
	AtfValidator::validateInt(_descr, "minFpp", minFpp, _checker, __FILE__, __LINE__);
	UINT32 fppBonusRate; _jparser.validateByNameThrow("fppBonusRate", fppBonusRate);
	AtfValidator::validateInt(_descr, "fppBonusRate", fppBonusRate, _checker, __FILE__, __LINE__);
	UINT32 vipToKeepYearlyStatus; _jparser.validateByNameThrow("vipToKeepYearlyStatus", vipToKeepYearlyStatus);
	AtfValidator::validateInt(_descr, "vipToKeepYearlyStatus", vipToKeepYearlyStatus, _checker, __FILE__, __LINE__);
	UINT32 lastMonthForYearly; _jparser.validateByNameThrow("lastMonthForYearly", lastMonthForYearly);
	AtfValidator::validateInt(_descr, "lastMonthForYearly", lastMonthForYearly, _checker, __FILE__, __LINE__);
	UINT32 missableMonthsYearly; _jparser.validateByNameThrow("missableMonthsYearly", missableMonthsYearly);
	AtfValidator::validateInt(_descr, "missableMonthsYearly", missableMonthsYearly, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::RawVIPLevel::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
}

void Lobby::cli::RawVIPLevel::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(statusId);
	_parser0.parseUINT32(type);
	_parser0.parseUINT32(minFpp);
	_parser0.parseUINT32(fppBonusRate);
	_parser0.parseUINT32(vipToKeepYearlyStatus);
	_parser0.parseUINT32(lastMonthForYearly);
	_parser0.parseUINT32(missableMonthsYearly);
}

/*static*/ void Lobby::cli::RawVIPLevel::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 statusId; _parser0.parseUINT32(statusId);
	AtfValidator::validateInt(_descr, "statusId", statusId, _checker, __FILE__, __LINE__);
	UINT32 type; _parser0.parseUINT32(type);
	AtfValidator::validateInt(_descr, "type", type, _checker, __FILE__, __LINE__);
	UINT32 minFpp; _parser0.parseUINT32(minFpp);
	AtfValidator::validateInt(_descr, "minFpp", minFpp, _checker, __FILE__, __LINE__);
	UINT32 fppBonusRate; _parser0.parseUINT32(fppBonusRate);
	AtfValidator::validateInt(_descr, "fppBonusRate", fppBonusRate, _checker, __FILE__, __LINE__);
	UINT32 vipToKeepYearlyStatus; _parser0.parseUINT32(vipToKeepYearlyStatus);
	AtfValidator::validateInt(_descr, "vipToKeepYearlyStatus", vipToKeepYearlyStatus, _checker, __FILE__, __LINE__);
	UINT32 lastMonthForYearly; _parser0.parseUINT32(lastMonthForYearly);
	AtfValidator::validateInt(_descr, "lastMonthForYearly", lastMonthForYearly, _checker, __FILE__, __LINE__);
	UINT32 missableMonthsYearly; _parser0.parseUINT32(missableMonthsYearly);
	AtfValidator::validateInt(_descr, "missableMonthsYearly", missableMonthsYearly, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CountryData
//=================================================================

Lobby::cli::CountryData::CountryData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::CountryData::CountryData(CountryData&& _o)
	: country(std::move(_o.country))
	, prefixes(std::move(_o.prefixes))
{
}

Lobby::cli::CountryData& Lobby::cli::CountryData::operator=(CountryData&& _o)
{
	if(this != &_o)
	{
		country = std::move(_o.country);
		prefixes = std::move(_o.prefixes);
	}
	return *this;
}

#endif

void Lobby::cli::CountryData::clear()
{
	country.clear();
	prefixes.clear();
}

bool Lobby::cli::CountryData::equals(const CountryData& _o) const
{
	return Atf::atfPStringEquals(country, _o.country) &&
		prefixes.equals(_o.prefixes);
}

const char *Lobby::cli::CountryData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("prefixes=");
	prefixes.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::CountryData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	prefixes.toXmlString("prefixes", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::CountryData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("country"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
		}
		else if (_element.equals("prefixes"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PString, 4 > >::FromXmlString(_value, prefixes)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::CountryData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(country);
	prefixes.composeMsg(_msg, _ignoreJSON);
}

void Lobby::cli::CountryData::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(country);
	prefixes.parseMsg(_parser);
}

const char *Lobby::cli::CountryData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("country", country);
	_jsonstr.compose("prefixes", prefixes);
	return _buf.c_str();
}

void Lobby::cli::CountryData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("country", country);
	_jparser.parseByNameThrow("prefixes", prefixes);
}

/* static */ void Lobby::cli::CountryData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateInt(_descr, "country", country.length(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PString > prefixes; _jparser.validateByNameThrow("prefixes", prefixes);
	AtfValidator::validateInt(_descr, "prefixes", prefixes.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::CountryData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szPrefixes = Atf::LAtfVector< PString, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("prefixes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "prefixes", szPrefixes, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    CountriesMsgBody
//=================================================================

Lobby::cli::CountriesMsgBody::CountriesMsgBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::CountriesMsgBody::CountriesMsgBody(CountriesMsgBody&& _o)
	: countries(std::move(_o.countries))
{
}

Lobby::cli::CountriesMsgBody& Lobby::cli::CountriesMsgBody::operator=(CountriesMsgBody&& _o)
{
	if(this != &_o)
	{
		countries = std::move(_o.countries);
	}
	return *this;
}

#endif

void Lobby::cli::CountriesMsgBody::clear()
{
	countries.clear();
}

bool Lobby::cli::CountriesMsgBody::equals(const CountriesMsgBody& _o) const
{
	return countries.equals(_o.countries);
}

const char *Lobby::cli::CountriesMsgBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("countries=");
	countries.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::CountriesMsgBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	countries.toXmlString("countries", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::CountriesMsgBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("countries"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< CountryData, 4 > >::FromXmlString(_value, countries)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::CountriesMsgBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CountriesMsgBody())) // not empty
	{
		countries.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::cli::CountriesMsgBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	countries.parseMsg(_parser0);
}

const char *Lobby::cli::CountriesMsgBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("countries", countries);
	return _buf.c_str();
}

void Lobby::cli::CountriesMsgBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("countries", countries);
}

/* static */ void Lobby::cli::CountriesMsgBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< CountryData > countries; _jparser.validateByNameThrow("countries", countries);
	AtfValidator::validateInt(_descr, "countries", countries.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::CountriesMsgBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szCountries = Atf::LAtfVector< CountryData, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("countries"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "countries", szCountries, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ClientFeatureVisibility
//=================================================================

Lobby::cli::ClientFeatureVisibility::ClientFeatureVisibility()
{
	clear();
}

void Lobby::cli::ClientFeatureVisibility::clear()
{
	clientFeatureVisibilityOnMask = 0;
	clientFeatureVisibilityOffMask = 0;
	clientFeatureVisibilityOnMask2 = 0;
	clientFeatureVisibilityOffMask2 = 0;
}

bool Lobby::cli::ClientFeatureVisibility::equals(const ClientFeatureVisibility& _o) const
{
	return clientFeatureVisibilityOnMask == _o.clientFeatureVisibilityOnMask &&
		clientFeatureVisibilityOffMask == _o.clientFeatureVisibilityOffMask &&
		clientFeatureVisibilityOnMask2 == _o.clientFeatureVisibilityOnMask2 &&
		clientFeatureVisibilityOffMask2 == _o.clientFeatureVisibilityOffMask2;
}

const char *Lobby::cli::ClientFeatureVisibility::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("clientFeatureVisibilityOnMask=");
	_buf.appendUint64(clientFeatureVisibilityOnMask);
	_buf.append(',');
	_buf.append("clientFeatureVisibilityOffMask=");
	_buf.appendUint64(clientFeatureVisibilityOffMask);
	_buf.append(',');
	_buf.append("clientFeatureVisibilityOnMask2=");
	_buf.appendUint64(clientFeatureVisibilityOnMask2);
	_buf.append(',');
	_buf.append("clientFeatureVisibilityOffMask2=");
	_buf.appendUint64(clientFeatureVisibilityOffMask2);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::ClientFeatureVisibility::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("clientFeatureVisibilityOnMask", clientFeatureVisibilityOnMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientFeatureVisibilityOffMask", clientFeatureVisibilityOffMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientFeatureVisibilityOnMask2", clientFeatureVisibilityOnMask2, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientFeatureVisibilityOffMask2", clientFeatureVisibilityOffMask2, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::ClientFeatureVisibility::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("clientFeatureVisibilityOnMask"))
		{
			clientFeatureVisibilityOnMask = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("clientFeatureVisibilityOffMask"))
		{
			clientFeatureVisibilityOffMask = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("clientFeatureVisibilityOnMask2"))
		{
			clientFeatureVisibilityOnMask2 = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("clientFeatureVisibilityOffMask2"))
		{
			clientFeatureVisibilityOffMask2 = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::ClientFeatureVisibility::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ClientFeatureVisibility())) // not empty
	{
		_body.composeUINT64(clientFeatureVisibilityOnMask);
		_body.composeUINT64(clientFeatureVisibilityOffMask);
		_body.composeUINT64(clientFeatureVisibilityOnMask2);
		_body.composeUINT64(clientFeatureVisibilityOffMask2);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::cli::ClientFeatureVisibility::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT64(clientFeatureVisibilityOnMask);
	_parser0.parseUINT64(clientFeatureVisibilityOffMask);
	_parser0.parseUINT64(clientFeatureVisibilityOnMask2);
	_parser0.parseUINT64(clientFeatureVisibilityOffMask2);
}

const char *Lobby::cli::ClientFeatureVisibility::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clientFeatureVisibilityOnMask", clientFeatureVisibilityOnMask);
	_jsonstr.compose("clientFeatureVisibilityOffMask", clientFeatureVisibilityOffMask);
	_jsonstr.compose("clientFeatureVisibilityOnMask2", clientFeatureVisibilityOnMask2);
	_jsonstr.compose("clientFeatureVisibilityOffMask2", clientFeatureVisibilityOffMask2);
	return _buf.c_str();
}

void Lobby::cli::ClientFeatureVisibility::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clientFeatureVisibilityOnMask", clientFeatureVisibilityOnMask);
	_jparser.parseByNameThrow("clientFeatureVisibilityOffMask", clientFeatureVisibilityOffMask);
	_jparser.parseByNameThrow("clientFeatureVisibilityOnMask2", clientFeatureVisibilityOnMask2);
	_jparser.parseByNameThrow("clientFeatureVisibilityOffMask2", clientFeatureVisibilityOffMask2);
}

/* static */ void Lobby::cli::ClientFeatureVisibility::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT64 clientFeatureVisibilityOnMask; _jparser.validateByNameThrow("clientFeatureVisibilityOnMask", clientFeatureVisibilityOnMask);
	AtfValidator::validateUint(_descr, "clientFeatureVisibilityOnMask", clientFeatureVisibilityOnMask, _checker, __FILE__, __LINE__);
	UINT64 clientFeatureVisibilityOffMask; _jparser.validateByNameThrow("clientFeatureVisibilityOffMask", clientFeatureVisibilityOffMask);
	AtfValidator::validateUint(_descr, "clientFeatureVisibilityOffMask", clientFeatureVisibilityOffMask, _checker, __FILE__, __LINE__);
	UINT64 clientFeatureVisibilityOnMask2; _jparser.validateByNameThrow("clientFeatureVisibilityOnMask2", clientFeatureVisibilityOnMask2);
	AtfValidator::validateUint(_descr, "clientFeatureVisibilityOnMask2", clientFeatureVisibilityOnMask2, _checker, __FILE__, __LINE__);
	UINT64 clientFeatureVisibilityOffMask2; _jparser.validateByNameThrow("clientFeatureVisibilityOffMask2", clientFeatureVisibilityOffMask2);
	AtfValidator::validateUint(_descr, "clientFeatureVisibilityOffMask2", clientFeatureVisibilityOffMask2, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::ClientFeatureVisibility::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT64 clientFeatureVisibilityOnMask; _parser0.parseUINT64(clientFeatureVisibilityOnMask);
	AtfValidator::validateUint(_descr, "clientFeatureVisibilityOnMask", clientFeatureVisibilityOnMask, _checker, __FILE__, __LINE__);
	UINT64 clientFeatureVisibilityOffMask; _parser0.parseUINT64(clientFeatureVisibilityOffMask);
	AtfValidator::validateUint(_descr, "clientFeatureVisibilityOffMask", clientFeatureVisibilityOffMask, _checker, __FILE__, __LINE__);
	UINT64 clientFeatureVisibilityOnMask2; _parser0.parseUINT64(clientFeatureVisibilityOnMask2);
	AtfValidator::validateUint(_descr, "clientFeatureVisibilityOnMask2", clientFeatureVisibilityOnMask2, _checker, __FILE__, __LINE__);
	UINT64 clientFeatureVisibilityOffMask2; _parser0.parseUINT64(clientFeatureVisibilityOffMask2);
	AtfValidator::validateUint(_descr, "clientFeatureVisibilityOffMask2", clientFeatureVisibilityOffMask2, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    HallOfFameLevel
//=================================================================

Lobby::cli::HallOfFameLevel::HallOfFameLevel()
{
	clear();
}

void Lobby::cli::HallOfFameLevel::clear()
{
	levelId = 0;
	ltVppThreshold = 0;
	flags = 0;
}

bool Lobby::cli::HallOfFameLevel::equals(const HallOfFameLevel& _o) const
{
	return levelId == _o.levelId &&
		ltVppThreshold == _o.ltVppThreshold &&
		flags == _o.flags;
}

const char *Lobby::cli::HallOfFameLevel::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("levelId=");
	_buf.appendUint(levelId);
	_buf.append(',');
	_buf.append("ltVppThreshold=");
	_buf.appendUint(ltVppThreshold);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::HallOfFameLevel::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("levelId", levelId, _buf);
	Atf::XmlElement::encodeAsXmlElement("ltVppThreshold", ltVppThreshold, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::HallOfFameLevel::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("levelId"))
		{
			levelId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("ltVppThreshold"))
		{
			ltVppThreshold = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("flags"))
		{
			flags = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::HallOfFameLevel::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(levelId);
	_msg.composeUINT32(ltVppThreshold);
	_msg.composeBYTE(flags);
}

void Lobby::cli::HallOfFameLevel::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(levelId);
	_parser.parseUINT32(ltVppThreshold);
	_parser.parseBYTE(flags);
}

const char *Lobby::cli::HallOfFameLevel::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("levelId", levelId);
	_jsonstr.compose("ltVppThreshold", ltVppThreshold);
	_jsonstr.compose("flags", flags);
	return _buf.c_str();
}

void Lobby::cli::HallOfFameLevel::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("levelId", levelId);
	_jparser.parseByNameThrow("ltVppThreshold", ltVppThreshold);
	_jparser.parseByNameThrow("flags", flags);
}

/* static */ void Lobby::cli::HallOfFameLevel::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 levelId; _jparser.validateByNameThrow("levelId", levelId);
	AtfValidator::validateInt(_descr, "levelId", levelId, _checker, __FILE__, __LINE__);
	UINT32 ltVppThreshold; _jparser.validateByNameThrow("ltVppThreshold", ltVppThreshold);
	AtfValidator::validateInt(_descr, "ltVppThreshold", ltVppThreshold, _checker, __FILE__, __LINE__);
	BYTE flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::HallOfFameLevel::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 levelId; _parser.parseUINT32(levelId);
	AtfValidator::validateInt(_descr, "levelId", levelId, _checker, __FILE__, __LINE__);
	UINT32 ltVppThreshold; _parser.parseUINT32(ltVppThreshold);
	AtfValidator::validateInt(_descr, "ltVppThreshold", ltVppThreshold, _checker, __FILE__, __LINE__);
	BYTE flags; _parser.parseBYTE(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    HallOfFameLevels
//=================================================================

Lobby::cli::HallOfFameLevels::HallOfFameLevels()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::HallOfFameLevels::HallOfFameLevels(HallOfFameLevels&& _o)
	: levels(std::move(_o.levels))
{
}

Lobby::cli::HallOfFameLevels& Lobby::cli::HallOfFameLevels::operator=(HallOfFameLevels&& _o)
{
	if(this != &_o)
	{
		levels = std::move(_o.levels);
	}
	return *this;
}

#endif

void Lobby::cli::HallOfFameLevels::clear()
{
	levels.clear();
}

bool Lobby::cli::HallOfFameLevels::equals(const HallOfFameLevels& _o) const
{
	return levels.equals(_o.levels);
}

const char *Lobby::cli::HallOfFameLevels::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("levels=");
	levels.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::HallOfFameLevels::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	levels.toXmlString("levels", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::HallOfFameLevels::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("levels"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< HallOfFameLevel, 4 > >::FromXmlString(_value, levels)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::HallOfFameLevels::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(HallOfFameLevels())) // not empty
	{
		levels.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::cli::HallOfFameLevels::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	levels.parseMsg(_parser0);
}

const char *Lobby::cli::HallOfFameLevels::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("levels", levels);
	return _buf.c_str();
}

void Lobby::cli::HallOfFameLevels::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("levels", levels);
}

/* static */ void Lobby::cli::HallOfFameLevels::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< HallOfFameLevel > levels; _jparser.validateByNameThrow("levels", levels);
	AtfValidator::validateInt(_descr, "levels", levels.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::HallOfFameLevels::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szLevels = Atf::LAtfVector< HallOfFameLevel, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("levels"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "levels", szLevels, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBY_USER_PROPS_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS_REPLY::Protocol_MSG_LOBBY_USER_PROPS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS_REPLY::Protocol_MSG_LOBBY_USER_PROPS_REPLY(Protocol_MSG_LOBBY_USER_PROPS_REPLY&& _o)
	: privs(std::move(_o.privs))
	, flags(std::move(_o.flags))
	, locale(std::move(_o.locale))
	, country(std::move(_o.country))
	, emLocale(std::move(_o.emLocale))
	, privs2(std::move(_o.privs2))
	, vipStatus(std::move(_o.vipStatus))
	, timeZone(std::move(_o.timeZone))
	, origUserIntId(std::move(_o.origUserIntId))
	, userIntId(std::move(_o.userIntId))
	, flags2(std::move(_o.flags2))
	, vppCounter1(std::move(_o.vppCounter1))
	, vppCounter2(std::move(_o.vppCounter2))
	, stellarBonuses(std::move(_o.stellarBonuses))
	, uiStatsAllowed(std::move(_o.uiStatsAllowed))
	, rmTransersAllowed(std::move(_o.rmTransersAllowed))
	, obsolete(std::move(_o.obsolete))
	, findSimilarTableFlag(std::move(_o.findSimilarTableFlag))
	, milestoneBonusesOld(std::move(_o.milestoneBonusesOld))
	, vipLevels(std::move(_o.vipLevels))
	, hgEnabled(std::move(_o.hgEnabled))
	, cppCountr3(std::move(_o.cppCountr3))
	, fastDepositEnabled(std::move(_o.fastDepositEnabled))
	, countries(std::move(_o.countries))
	, handSharingEnabledForSiteAndBrand(std::move(_o.handSharingEnabledForSiteAndBrand))
	, itAccVerificationOpen(std::move(_o.itAccVerificationOpen))
	, allowSmsValidationForNewInstallId(std::move(_o.allowSmsValidationForNewInstallId))
	, userWebId(std::move(_o.userWebId))
	, rawVIPLevels(std::move(_o.rawVIPLevels))
	, chatModeratorRestrictions(std::move(_o.chatModeratorRestrictions))
	, milestoneBonusesNew(std::move(_o.milestoneBonusesNew))
	, allowSmsPwdReset(std::move(_o.allowSmsPwdReset))
	, hallOfFameLevels(std::move(_o.hallOfFameLevels))
	, lifetimeFpp(std::move(_o.lifetimeFpp))
	, otherFlags(std::move(_o.otherFlags))
	, clientFeatureVisibility(std::move(_o.clientFeatureVisibility))
	, privs3(std::move(_o.privs3))
	, registered(std::move(_o.registered))
	, state(std::move(_o.state))
	, licenseId(std::move(_o.licenseId))
{
}

Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS_REPLY& Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS_REPLY::operator=(Protocol_MSG_LOBBY_USER_PROPS_REPLY&& _o)
{
	if(this != &_o)
	{
		privs = std::move(_o.privs);
		flags = std::move(_o.flags);
		locale = std::move(_o.locale);
		country = std::move(_o.country);
		emLocale = std::move(_o.emLocale);
		privs2 = std::move(_o.privs2);
		vipStatus = std::move(_o.vipStatus);
		timeZone = std::move(_o.timeZone);
		origUserIntId = std::move(_o.origUserIntId);
		userIntId = std::move(_o.userIntId);
		flags2 = std::move(_o.flags2);
		vppCounter1 = std::move(_o.vppCounter1);
		vppCounter2 = std::move(_o.vppCounter2);
		stellarBonuses = std::move(_o.stellarBonuses);
		uiStatsAllowed = std::move(_o.uiStatsAllowed);
		rmTransersAllowed = std::move(_o.rmTransersAllowed);
		obsolete = std::move(_o.obsolete);
		findSimilarTableFlag = std::move(_o.findSimilarTableFlag);
		milestoneBonusesOld = std::move(_o.milestoneBonusesOld);
		vipLevels = std::move(_o.vipLevels);
		hgEnabled = std::move(_o.hgEnabled);
		cppCountr3 = std::move(_o.cppCountr3);
		fastDepositEnabled = std::move(_o.fastDepositEnabled);
		countries = std::move(_o.countries);
		handSharingEnabledForSiteAndBrand = std::move(_o.handSharingEnabledForSiteAndBrand);
		itAccVerificationOpen = std::move(_o.itAccVerificationOpen);
		allowSmsValidationForNewInstallId = std::move(_o.allowSmsValidationForNewInstallId);
		userWebId = std::move(_o.userWebId);
		rawVIPLevels = std::move(_o.rawVIPLevels);
		chatModeratorRestrictions = std::move(_o.chatModeratorRestrictions);
		milestoneBonusesNew = std::move(_o.milestoneBonusesNew);
		allowSmsPwdReset = std::move(_o.allowSmsPwdReset);
		hallOfFameLevels = std::move(_o.hallOfFameLevels);
		lifetimeFpp = std::move(_o.lifetimeFpp);
		otherFlags = std::move(_o.otherFlags);
		clientFeatureVisibility = std::move(_o.clientFeatureVisibility);
		privs3 = std::move(_o.privs3);
		registered = std::move(_o.registered);
		state = std::move(_o.state);
		licenseId = std::move(_o.licenseId);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS_REPLY::clear()
{
	privs = 0;
	flags = 0;
	locale = 0;
	country.clear();
	emLocale = 0;
	privs2 = 0;
	vipStatus = 0;
	timeZone = 0;
	origUserIntId = 0;
	userIntId = 0;
	flags2 = 0;
	vppCounter1 = 0;
	vppCounter2 = 0;
	stellarBonuses.clear();
	uiStatsAllowed = false;
	rmTransersAllowed = false;
	obsolete = 0;
	findSimilarTableFlag = 0;
	milestoneBonusesOld.clear();
	vipLevels.clear();
	hgEnabled = false;
	cppCountr3 = 0;
	fastDepositEnabled = false;
	countries.clear();
	handSharingEnabledForSiteAndBrand = false;
	itAccVerificationOpen = false;
	allowSmsValidationForNewInstallId = false;
	userWebId.clear();
	rawVIPLevels.clear();
	chatModeratorRestrictions = 0;
	milestoneBonusesNew.clear();
	allowSmsPwdReset = false;
	hallOfFameLevels.clear();
	lifetimeFpp = 0;
	otherFlags = 0;
	clientFeatureVisibility.clear();
	privs3 = 0;
	registered.setNull();
	state.clear();
	licenseId = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS_REPLY::equals(const Protocol_MSG_LOBBY_USER_PROPS_REPLY& _o) const
{
	return privs == _o.privs &&
		flags == _o.flags &&
		locale == _o.locale &&
		Atf::atfPStringEquals(country, _o.country) &&
		emLocale == _o.emLocale &&
		privs2 == _o.privs2 &&
		vipStatus == _o.vipStatus &&
		timeZone == _o.timeZone &&
		origUserIntId == _o.origUserIntId &&
		userIntId == _o.userIntId &&
		flags2 == _o.flags2 &&
		vppCounter1 == _o.vppCounter1 &&
		vppCounter2 == _o.vppCounter2 &&
		stellarBonuses.equals(_o.stellarBonuses) &&
		uiStatsAllowed == _o.uiStatsAllowed &&
		rmTransersAllowed == _o.rmTransersAllowed &&
		obsolete == _o.obsolete &&
		findSimilarTableFlag == _o.findSimilarTableFlag &&
		milestoneBonusesOld.equals(_o.milestoneBonusesOld) &&
		vipLevels.equals(_o.vipLevels) &&
		hgEnabled == _o.hgEnabled &&
		cppCountr3 == _o.cppCountr3 &&
		fastDepositEnabled == _o.fastDepositEnabled &&
		countries.equals(_o.countries) &&
		handSharingEnabledForSiteAndBrand == _o.handSharingEnabledForSiteAndBrand &&
		itAccVerificationOpen == _o.itAccVerificationOpen &&
		allowSmsValidationForNewInstallId == _o.allowSmsValidationForNewInstallId &&
		Atf::atfPStringEquals(userWebId, _o.userWebId) &&
		rawVIPLevels.equals(_o.rawVIPLevels) &&
		chatModeratorRestrictions == _o.chatModeratorRestrictions &&
		milestoneBonusesNew.equals(_o.milestoneBonusesNew) &&
		allowSmsPwdReset == _o.allowSmsPwdReset &&
		hallOfFameLevels.equals(_o.hallOfFameLevels) &&
		lifetimeFpp == _o.lifetimeFpp &&
		otherFlags == _o.otherFlags &&
		clientFeatureVisibility.equals(_o.clientFeatureVisibility) &&
		privs3 == _o.privs3 &&
		registered.equals(_o.registered) &&
		Atf::atfPStringEquals(state, _o.state) &&
		licenseId == _o.licenseId;
}

bool Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_USER_PROPS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_USER_PROPS_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_USER_PROPS_REPLY).append(")");
	_buf.append(',');
	_buf.append("privs=");
	_buf.appendUint(privs);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("emLocale=");
	_buf.appendUint(emLocale);
	_buf.append(',');
	_buf.append("privs2=");
	_buf.appendUint64(privs2);
	_buf.append(',');
	_buf.append("vipStatus=");
	_buf.appendUint(vipStatus);
	_buf.append(',');
	_buf.append("timeZone=");
	_buf.appendUint(timeZone);
	_buf.append(',');
	_buf.append("origUserIntId=");
	_buf.appendUint(origUserIntId);
	_buf.append(',');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	_buf.append(',');
	_buf.append("flags2=");
	_buf.appendUint64(flags2);
	_buf.append(',');
	_buf.append("vppCounter1=");
	_buf.appendUint(vppCounter1);
	_buf.append(',');
	_buf.append("vppCounter2=");
	_buf.appendUint(vppCounter2);
	_buf.append(',');
	_buf.append("stellarBonuses=");
	stellarBonuses.toTraceString(_buf);
	_buf.append(',');
	_buf.append("uiStatsAllowed=");
	_buf.appendUint(uiStatsAllowed);
	_buf.append(',');
	_buf.append("rmTransersAllowed=");
	_buf.appendUint(rmTransersAllowed);
	_buf.append(',');
	_buf.append("obsolete=");
	_buf.appendUint(obsolete);
	_buf.append(',');
	_buf.append("findSimilarTableFlag=");
	_buf.appendUint(findSimilarTableFlag);
	_buf.append(',');
	_buf.append("milestoneBonusesOld=");
	milestoneBonusesOld.toTraceString(_buf);
	_buf.append(',');
	_buf.append("vipLevels=");
	vipLevels.toTraceString(_buf);
	_buf.append(',');
	_buf.append("hgEnabled=");
	_buf.appendUint(hgEnabled);
	_buf.append(',');
	_buf.append("cppCountr3=");
	_buf.appendUint(cppCountr3);
	_buf.append(',');
	_buf.append("fastDepositEnabled=");
	_buf.appendUint(fastDepositEnabled);
	_buf.append(',');
	_buf.append("countries=");
	countries.toTraceString(_buf);
	_buf.append(',');
	_buf.append("handSharingEnabledForSiteAndBrand=");
	_buf.appendUint(handSharingEnabledForSiteAndBrand);
	_buf.append(',');
	_buf.append("itAccVerificationOpen=");
	_buf.appendUint(itAccVerificationOpen);
	_buf.append(',');
	_buf.append("allowSmsValidationForNewInstallId=");
	_buf.appendUint(allowSmsValidationForNewInstallId);
	_buf.append(',');
	_buf.append("userWebId=");
	_buf.append(userWebId);
	_buf.append(',');
	_buf.append("rawVIPLevels=");
	rawVIPLevels.toTraceString(_buf);
	_buf.append(',');
	_buf.append("chatModeratorRestrictions=");
	_buf.appendUint(chatModeratorRestrictions);
	_buf.append(',');
	_buf.append("milestoneBonusesNew=");
	milestoneBonusesNew.toTraceString(_buf);
	_buf.append(',');
	_buf.append("allowSmsPwdReset=");
	_buf.appendUint(allowSmsPwdReset);
	_buf.append(',');
	_buf.append("hallOfFameLevels=");
	hallOfFameLevels.toTraceString(_buf);
	_buf.append(',');
	_buf.append("lifetimeFpp=");
	_buf.appendUint(lifetimeFpp);
	_buf.append(',');
	_buf.append("otherFlags=");
	_buf.appendUint(otherFlags);
	_buf.append(',');
	_buf.append("clientFeatureVisibility=");
	clientFeatureVisibility.toTraceString(_buf);
	_buf.append(',');
	_buf.append("privs3=");
	_buf.appendUint64(privs3);
	_buf.append(',');
	_buf.append("registered=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, registered);
	_buf.append(',');
	_buf.append("state=");
	_buf.append(state);
	_buf.append(',');
	_buf.append("licenseId=");
	_buf.appendUint(licenseId);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_USER_PROPS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("privs", privs, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::encodeAsXmlElement("emLocale", emLocale, _buf);
	Atf::XmlElement::encodeAsXmlElement("privs2", privs2, _buf);
	Atf::XmlElement::encodeAsXmlElement("vipStatus", vipStatus, _buf);
	Atf::XmlElement::encodeAsXmlElement("timeZone", timeZone, _buf);
	Atf::XmlElement::encodeAsXmlElement("origUserIntId", origUserIntId, _buf);
	Atf::XmlElement::encodeAsXmlElement("userIntId", userIntId, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags2", flags2, _buf);
	Atf::XmlElement::encodeAsXmlElement("vppCounter1", vppCounter1, _buf);
	Atf::XmlElement::encodeAsXmlElement("vppCounter2", vppCounter2, _buf);
	stellarBonuses.toXmlString("stellarBonuses", _buf);
	Atf::XmlElement::encodeAsXmlElement("uiStatsAllowed", uiStatsAllowed, _buf);
	Atf::XmlElement::encodeAsXmlElement("rmTransersAllowed", rmTransersAllowed, _buf);
	Atf::XmlElement::encodeAsXmlElement("obsolete", obsolete, _buf);
	Atf::XmlElement::encodeAsXmlElement("findSimilarTableFlag", findSimilarTableFlag, _buf);
	milestoneBonusesOld.toXmlString("milestoneBonusesOld", _buf);
	vipLevels.toXmlString("vipLevels", _buf);
	Atf::XmlElement::encodeAsXmlElement("hgEnabled", hgEnabled, _buf);
	Atf::XmlElement::encodeAsXmlElement("cppCountr3", cppCountr3, _buf);
	Atf::XmlElement::encodeAsXmlElement("fastDepositEnabled", fastDepositEnabled, _buf);
	countries.toXmlString("countries", _buf);
	Atf::XmlElement::encodeAsXmlElement("handSharingEnabledForSiteAndBrand", handSharingEnabledForSiteAndBrand, _buf);
	Atf::XmlElement::encodeAsXmlElement("itAccVerificationOpen", itAccVerificationOpen, _buf);
	Atf::XmlElement::encodeAsXmlElement("allowSmsValidationForNewInstallId", allowSmsValidationForNewInstallId, _buf);
	Atf::XmlElement::encodeAsXmlElement("userWebId", userWebId, _buf);
	rawVIPLevels.toXmlString("rawVIPLevels", _buf);
	Atf::XmlElement::encodeAsXmlElement("chatModeratorRestrictions", chatModeratorRestrictions, _buf);
	milestoneBonusesNew.toXmlString("milestoneBonusesNew", _buf);
	Atf::XmlElement::encodeAsXmlElement("allowSmsPwdReset", allowSmsPwdReset, _buf);
	hallOfFameLevels.toXmlString("hallOfFameLevels", _buf);
	Atf::XmlElement::encodeAsXmlElement("lifetimeFpp", lifetimeFpp, _buf);
	Atf::XmlElement::encodeAsXmlElement("otherFlags", otherFlags, _buf);
	clientFeatureVisibility.toXmlString("clientFeatureVisibility", _buf);
	Atf::XmlElement::encodeAsXmlElement("privs3", privs3, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "registered", registered);
	Atf::XmlElement::encodeAsXmlElement("state", state, _buf);
	Atf::XmlElement::encodeAsXmlElement("licenseId", licenseId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("privs"))
			{
				privs = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("flags"))
			{
				flags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("locale"))
			{
				locale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("country"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
			}
			else if (_element.equals("emLocale"))
			{
				emLocale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("privs2"))
			{
				privs2 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("vipStatus"))
			{
				vipStatus = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("timeZone"))
			{
				timeZone = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("origUserIntId"))
			{
				origUserIntId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userIntId"))
			{
				userIntId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("flags2"))
			{
				flags2 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("vppCounter1"))
			{
				vppCounter1 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("vppCounter2"))
			{
				vppCounter2 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("stellarBonuses"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< StellarBonus, 4 > >::FromXmlString(_value, stellarBonuses)) return false;
			}
			else if (_element.equals("uiStatsAllowed"))
			{
				uiStatsAllowed = (*_value.ptr() == '1');
			}
			else if (_element.equals("rmTransersAllowed"))
			{
				rmTransersAllowed = (*_value.ptr() == '1');
			}
			else if (_element.equals("obsolete"))
			{
				obsolete = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("findSimilarTableFlag"))
			{
				findSimilarTableFlag = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("milestoneBonusesOld"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MilestoneBonusOld, 4 > >::FromXmlString(_value, milestoneBonusesOld)) return false;
			}
			else if (_element.equals("vipLevels"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< VIPLevel, 4 > >::FromXmlString(_value, vipLevels)) return false;
			}
			else if (_element.equals("hgEnabled"))
			{
				hgEnabled = (*_value.ptr() == '1');
			}
			else if (_element.equals("cppCountr3"))
			{
				cppCountr3 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("fastDepositEnabled"))
			{
				fastDepositEnabled = (*_value.ptr() == '1');
			}
			else if (_element.equals("countries"))
			{
				if(!Atf::AtfTempl< CountriesMsgBody >::FromXmlString(_value, countries)) return false;
			}
			else if (_element.equals("handSharingEnabledForSiteAndBrand"))
			{
				handSharingEnabledForSiteAndBrand = (*_value.ptr() == '1');
			}
			else if (_element.equals("itAccVerificationOpen"))
			{
				itAccVerificationOpen = (*_value.ptr() == '1');
			}
			else if (_element.equals("allowSmsValidationForNewInstallId"))
			{
				allowSmsValidationForNewInstallId = (*_value.ptr() == '1');
			}
			else if (_element.equals("userWebId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userWebId)) return false;
			}
			else if (_element.equals("rawVIPLevels"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< RawVIPLevel, 4 > >::FromXmlString(_value, rawVIPLevels)) return false;
			}
			else if (_element.equals("chatModeratorRestrictions"))
			{
				chatModeratorRestrictions = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("milestoneBonusesNew"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MilestoneBonusNew, 4 > >::FromXmlString(_value, milestoneBonusesNew)) return false;
			}
			else if (_element.equals("allowSmsPwdReset"))
			{
				allowSmsPwdReset = (*_value.ptr() == '1');
			}
			else if (_element.equals("hallOfFameLevels"))
			{
				if(!Atf::AtfTempl< HallOfFameLevels >::FromXmlString(_value, hallOfFameLevels)) return false;
			}
			else if (_element.equals("lifetimeFpp"))
			{
				lifetimeFpp = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("otherFlags"))
			{
				otherFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientFeatureVisibility"))
			{
				if(!Atf::AtfTempl< ClientFeatureVisibility >::FromXmlString(_value, clientFeatureVisibility)) return false;
			}
			else if (_element.equals("privs3"))
			{
				privs3 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("registered"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, registered);
			}
			else if (_element.equals("state"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, state)) return false;
			}
			else if (_element.equals("licenseId"))
			{
				licenseId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(privs);
	_msg.composeUINT32(flags);
	_msg.composeUINT32(locale);
	_msg.composeString(country);
	_msg.composeUINT32(emLocale);
	_msg.composeUINT64(privs2);
	_msg.composeUINT32(vipStatus);
	_msg.composeUINT32(timeZone);
	_msg.composeUINT32(origUserIntId);
	_msg.composeUINT32(userIntId);
	_msg.composeUINT64(flags2);
	_msg.composeUINT32(vppCounter1);
	_msg.composeUINT32(vppCounter2);
	stellarBonuses.composeMsg(_msg, _ignoreJSON);
	_msg.composeBOOL(uiStatsAllowed);
	_msg.composeBOOL(rmTransersAllowed);
	_msg.composeUINT32(obsolete);
	_msg.composeBYTE(findSimilarTableFlag);
	milestoneBonusesOld.composeMsg(_msg, _ignoreJSON);
	vipLevels.composeMsg(_msg, _ignoreJSON);
	_msg.composeBOOL(hgEnabled);
	_msg.composeUINT32(cppCountr3);
	_msg.composeBOOL(fastDepositEnabled);
	countries.composeMsg(_msg, _ignoreJSON);
	_msg.composeBOOL(handSharingEnabledForSiteAndBrand);
	_msg.composeBOOL(itAccVerificationOpen);
	_msg.composeBOOL(allowSmsValidationForNewInstallId);
	_msg.composeString(userWebId);
	rawVIPLevels.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(chatModeratorRestrictions);
	milestoneBonusesNew.composeMsg(_msg, _ignoreJSON);
	_msg.composeBOOL(allowSmsPwdReset);
	hallOfFameLevels.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(lifetimeFpp);
	_msg.composeUINT32(otherFlags);
	clientFeatureVisibility.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT64(privs3);
	_msg.composeSrvTime(registered);
	_msg.composeString(state);
	_msg.composeUINT32(licenseId);
}

void Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(privs);
	_parser.parseUINT32(flags);
	_parser.parseUINT32(locale);
	_parser.parseStringP(country);
	_parser.parseUINT32(emLocale);
	_parser.parseUINT64(privs2);
	_parser.parseUINT32(vipStatus);
	_parser.parseUINT32(timeZone);
	_parser.parseUINT32(origUserIntId);
	_parser.parseUINT32(userIntId);
	_parser.parseUINT64(flags2);
	_parser.parseUINT32(vppCounter1);
	_parser.parseUINT32(vppCounter2);
	stellarBonuses.parseMsg(_parser);
	_parser.parseBOOL(uiStatsAllowed);
	_parser.parseBOOL(rmTransersAllowed);
	_parser.parseUINT32(obsolete);
	_parser.parseBYTE(findSimilarTableFlag);
	milestoneBonusesOld.parseMsg(_parser);
	vipLevels.parseMsg(_parser);
	_parser.parseBOOL(hgEnabled);
	_parser.parseUINT32(cppCountr3);
	_parser.parseBOOL(fastDepositEnabled);
	countries.parseMsg(_parser);
	_parser.parseBOOL(handSharingEnabledForSiteAndBrand);
	_parser.parseBOOL(itAccVerificationOpen);
	_parser.parseBOOL(allowSmsValidationForNewInstallId);
	_parser.parseStringP(userWebId);
	rawVIPLevels.parseMsg(_parser);
	_parser.parseUINT32(chatModeratorRestrictions);
	milestoneBonusesNew.parseMsg(_parser);
	_parser.parseBOOL(allowSmsPwdReset);
	hallOfFameLevels.parseMsg(_parser);
	_parser.parseUINT32(lifetimeFpp);
	_parser.parseUINT32(otherFlags);
	clientFeatureVisibility.parseMsg(_parser);
	_parser.parseUINT64(privs3);
	_parser.parseSrvTime(registered);
	_parser.parseStringP(state);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(licenseId);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("privs", privs);
	_jsonstr.compose("flags", flags);
	_jsonstr.compose("locale", locale);
	_jsonstr.compose("country", country);
	_jsonstr.compose("emLocale", emLocale);
	_jsonstr.compose("privs2", privs2);
	_jsonstr.compose("vipStatus", vipStatus);
	_jsonstr.compose("timeZone", timeZone);
	_jsonstr.compose("origUserIntId", origUserIntId);
	_jsonstr.compose("userIntId", userIntId);
	_jsonstr.compose("flags2", flags2);
	_jsonstr.compose("vppCounter1", vppCounter1);
	_jsonstr.compose("vppCounter2", vppCounter2);
	_jsonstr.compose("stellarBonuses", stellarBonuses);
	_jsonstr.compose("uiStatsAllowed", uiStatsAllowed);
	_jsonstr.compose("rmTransersAllowed", rmTransersAllowed);
	_jsonstr.compose("obsolete", obsolete);
	_jsonstr.compose("findSimilarTableFlag", findSimilarTableFlag);
	_jsonstr.compose("milestoneBonusesOld", milestoneBonusesOld);
	_jsonstr.compose("vipLevels", vipLevels);
	_jsonstr.compose("hgEnabled", hgEnabled);
	_jsonstr.compose("cppCountr3", cppCountr3);
	_jsonstr.compose("fastDepositEnabled", fastDepositEnabled);
	_jsonstr.compose("countries", countries);
	_jsonstr.compose("handSharingEnabledForSiteAndBrand", handSharingEnabledForSiteAndBrand);
	_jsonstr.compose("itAccVerificationOpen", itAccVerificationOpen);
	_jsonstr.compose("allowSmsValidationForNewInstallId", allowSmsValidationForNewInstallId);
	_jsonstr.compose("userWebId", userWebId);
	_jsonstr.compose("rawVIPLevels", rawVIPLevels);
	_jsonstr.compose("chatModeratorRestrictions", chatModeratorRestrictions);
	_jsonstr.compose("milestoneBonusesNew", milestoneBonusesNew);
	_jsonstr.compose("allowSmsPwdReset", allowSmsPwdReset);
	_jsonstr.compose("hallOfFameLevels", hallOfFameLevels);
	_jsonstr.compose("lifetimeFpp", lifetimeFpp);
	_jsonstr.compose("otherFlags", otherFlags);
	_jsonstr.compose("clientFeatureVisibility", clientFeatureVisibility);
	_jsonstr.compose("privs3", privs3);
	_jsonstr.compose("registered", registered);
	_jsonstr.compose("state", state);
	_jsonstr.compose("licenseId", licenseId);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("privs", privs);
	_jparser.parseByNameThrow("flags", flags);
	_jparser.parseByNameThrow("locale", locale);
	_jparser.parseByNameThrow("country", country);
	_jparser.parseByNameThrow("emLocale", emLocale);
	_jparser.parseByNameThrow("privs2", privs2);
	_jparser.parseByNameThrow("vipStatus", vipStatus);
	_jparser.parseByNameThrow("timeZone", timeZone);
	_jparser.parseByNameThrow("origUserIntId", origUserIntId);
	_jparser.parseByNameThrow("userIntId", userIntId);
	_jparser.parseByNameThrow("flags2", flags2);
	_jparser.parseByNameThrow("vppCounter1", vppCounter1);
	_jparser.parseByNameThrow("vppCounter2", vppCounter2);
	_jparser.parseByNameThrow("stellarBonuses", stellarBonuses);
	_jparser.parseByNameThrow("uiStatsAllowed", uiStatsAllowed);
	_jparser.parseByNameThrow("rmTransersAllowed", rmTransersAllowed);
	_jparser.parseByNameThrow("obsolete", obsolete);
	_jparser.parseByNameThrow("findSimilarTableFlag", findSimilarTableFlag);
	_jparser.parseByNameThrow("milestoneBonusesOld", milestoneBonusesOld);
	_jparser.parseByNameThrow("vipLevels", vipLevels);
	_jparser.parseByNameThrow("hgEnabled", hgEnabled);
	_jparser.parseByNameThrow("cppCountr3", cppCountr3);
	_jparser.parseByNameThrow("fastDepositEnabled", fastDepositEnabled);
	_jparser.parseByNameThrow("countries", countries);
	_jparser.parseByNameThrow("handSharingEnabledForSiteAndBrand", handSharingEnabledForSiteAndBrand);
	_jparser.parseByNameThrow("itAccVerificationOpen", itAccVerificationOpen);
	_jparser.parseByNameThrow("allowSmsValidationForNewInstallId", allowSmsValidationForNewInstallId);
	_jparser.parseByNameThrow("userWebId", userWebId);
	_jparser.parseByNameThrow("rawVIPLevels", rawVIPLevels);
	_jparser.parseByNameThrow("chatModeratorRestrictions", chatModeratorRestrictions);
	_jparser.parseByNameThrow("milestoneBonusesNew", milestoneBonusesNew);
	_jparser.parseByNameThrow("allowSmsPwdReset", allowSmsPwdReset);
	_jparser.parseByNameThrow("hallOfFameLevels", hallOfFameLevels);
	_jparser.parseByNameThrow("lifetimeFpp", lifetimeFpp);
	_jparser.parseByNameThrow("otherFlags", otherFlags);
	_jparser.parseByNameThrow("clientFeatureVisibility", clientFeatureVisibility);
	_jparser.parseByNameThrow("privs3", privs3);
	_jparser.parseByNameThrow("registered", registered);
	_jparser.parseByNameThrow("state", state);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("licenseId", licenseId);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_USER_PROPS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 privs; _jparser.validateByNameThrow("privs", privs);
	AtfValidator::validateInt(_descr, "privs", privs, _checker, __FILE__, __LINE__);
	UINT32 flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateInt(_descr, "locale", locale, _checker, __FILE__, __LINE__);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateInt(_descr, "country", country.length(), _checker, __FILE__, __LINE__);
	UINT32 emLocale; _jparser.validateByNameThrow("emLocale", emLocale);
	AtfValidator::validateInt(_descr, "emLocale", emLocale, _checker, __FILE__, __LINE__);
	UINT64 privs2; _jparser.validateByNameThrow("privs2", privs2);
	AtfValidator::validateUint(_descr, "privs2", privs2, _checker, __FILE__, __LINE__);
	UINT32 vipStatus; _jparser.validateByNameThrow("vipStatus", vipStatus);
	AtfValidator::validateInt(_descr, "vipStatus", vipStatus, _checker, __FILE__, __LINE__);
	UINT32 timeZone; _jparser.validateByNameThrow("timeZone", timeZone);
	AtfValidator::validateInt(_descr, "timeZone", timeZone, _checker, __FILE__, __LINE__);
	UINT32 origUserIntId; _jparser.validateByNameThrow("origUserIntId", origUserIntId);
	AtfValidator::validateInt(_descr, "origUserIntId", origUserIntId, _checker, __FILE__, __LINE__);
	UINT32 userIntId; _jparser.validateByNameThrow("userIntId", userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	UINT64 flags2; _jparser.validateByNameThrow("flags2", flags2);
	AtfValidator::validateUint(_descr, "flags2", flags2, _checker, __FILE__, __LINE__);
	UINT32 vppCounter1; _jparser.validateByNameThrow("vppCounter1", vppCounter1);
	AtfValidator::validateInt(_descr, "vppCounter1", vppCounter1, _checker, __FILE__, __LINE__);
	UINT32 vppCounter2; _jparser.validateByNameThrow("vppCounter2", vppCounter2);
	AtfValidator::validateInt(_descr, "vppCounter2", vppCounter2, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< StellarBonus > stellarBonuses; _jparser.validateByNameThrow("stellarBonuses", stellarBonuses);
	AtfValidator::validateInt(_descr, "stellarBonuses", stellarBonuses.size(), _checker, __FILE__, __LINE__);
	bool uiStatsAllowed; _jparser.validateByNameThrow("uiStatsAllowed", uiStatsAllowed);
	AtfValidator::validateInt(_descr, "uiStatsAllowed", uiStatsAllowed, _checker, __FILE__, __LINE__);
	bool rmTransersAllowed; _jparser.validateByNameThrow("rmTransersAllowed", rmTransersAllowed);
	AtfValidator::validateInt(_descr, "rmTransersAllowed", rmTransersAllowed, _checker, __FILE__, __LINE__);
	UINT32 obsolete; _jparser.validateByNameThrow("obsolete", obsolete);
	AtfValidator::validateInt(_descr, "obsolete", obsolete, _checker, __FILE__, __LINE__);
	BYTE findSimilarTableFlag; _jparser.validateByNameThrow("findSimilarTableFlag", findSimilarTableFlag);
	AtfValidator::validateInt(_descr, "findSimilarTableFlag", findSimilarTableFlag, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< MilestoneBonusOld > milestoneBonusesOld; _jparser.validateByNameThrow("milestoneBonusesOld", milestoneBonusesOld);
	AtfValidator::validateInt(_descr, "milestoneBonusesOld", milestoneBonusesOld.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< VIPLevel > vipLevels; _jparser.validateByNameThrow("vipLevels", vipLevels);
	AtfValidator::validateInt(_descr, "vipLevels", vipLevels.size(), _checker, __FILE__, __LINE__);
	bool hgEnabled; _jparser.validateByNameThrow("hgEnabled", hgEnabled);
	AtfValidator::validateInt(_descr, "hgEnabled", hgEnabled, _checker, __FILE__, __LINE__);
	UINT32 cppCountr3; _jparser.validateByNameThrow("cppCountr3", cppCountr3);
	AtfValidator::validateInt(_descr, "cppCountr3", cppCountr3, _checker, __FILE__, __LINE__);
	bool fastDepositEnabled; _jparser.validateByNameThrow("fastDepositEnabled", fastDepositEnabled);
	AtfValidator::validateInt(_descr, "fastDepositEnabled", fastDepositEnabled, _checker, __FILE__, __LINE__);
	CountriesMsgBody countries; _jparser.validateByNameThrow("countries", countries);
	bool handSharingEnabledForSiteAndBrand; _jparser.validateByNameThrow("handSharingEnabledForSiteAndBrand", handSharingEnabledForSiteAndBrand);
	AtfValidator::validateInt(_descr, "handSharingEnabledForSiteAndBrand", handSharingEnabledForSiteAndBrand, _checker, __FILE__, __LINE__);
	bool itAccVerificationOpen; _jparser.validateByNameThrow("itAccVerificationOpen", itAccVerificationOpen);
	AtfValidator::validateInt(_descr, "itAccVerificationOpen", itAccVerificationOpen, _checker, __FILE__, __LINE__);
	bool allowSmsValidationForNewInstallId; _jparser.validateByNameThrow("allowSmsValidationForNewInstallId", allowSmsValidationForNewInstallId);
	AtfValidator::validateInt(_descr, "allowSmsValidationForNewInstallId", allowSmsValidationForNewInstallId, _checker, __FILE__, __LINE__);
	PString userWebId; _jparser.validateByNameThrow("userWebId", userWebId);
	AtfValidator::validateInt(_descr, "userWebId", userWebId.length(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< RawVIPLevel > rawVIPLevels; _jparser.validateByNameThrow("rawVIPLevels", rawVIPLevels);
	AtfValidator::validateInt(_descr, "rawVIPLevels", rawVIPLevels.size(), _checker, __FILE__, __LINE__);
	UINT32 chatModeratorRestrictions; _jparser.validateByNameThrow("chatModeratorRestrictions", chatModeratorRestrictions);
	AtfValidator::validateInt(_descr, "chatModeratorRestrictions", chatModeratorRestrictions, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< MilestoneBonusNew > milestoneBonusesNew; _jparser.validateByNameThrow("milestoneBonusesNew", milestoneBonusesNew);
	AtfValidator::validateInt(_descr, "milestoneBonusesNew", milestoneBonusesNew.size(), _checker, __FILE__, __LINE__);
	bool allowSmsPwdReset; _jparser.validateByNameThrow("allowSmsPwdReset", allowSmsPwdReset);
	AtfValidator::validateInt(_descr, "allowSmsPwdReset", allowSmsPwdReset, _checker, __FILE__, __LINE__);
	HallOfFameLevels hallOfFameLevels; _jparser.validateByNameThrow("hallOfFameLevels", hallOfFameLevels);
	UINT32 lifetimeFpp; _jparser.validateByNameThrow("lifetimeFpp", lifetimeFpp);
	AtfValidator::validateInt(_descr, "lifetimeFpp", lifetimeFpp, _checker, __FILE__, __LINE__);
	UINT32 otherFlags; _jparser.validateByNameThrow("otherFlags", otherFlags);
	AtfValidator::validateInt(_descr, "otherFlags", otherFlags, _checker, __FILE__, __LINE__);
	ClientFeatureVisibility clientFeatureVisibility; _jparser.validateByNameThrow("clientFeatureVisibility", clientFeatureVisibility);
	UINT64 privs3; _jparser.validateByNameThrow("privs3", privs3);
	AtfValidator::validateUint(_descr, "privs3", privs3, _checker, __FILE__, __LINE__);
	SrvTime registered; _jparser.validateByNameThrow("registered", registered);
	AtfValidator::validateSrvDateTime(_descr, "registered", registered, _checker, __FILE__, __LINE__);
	PString state; _jparser.validateByNameThrow("state", state);
	AtfValidator::validateInt(_descr, "state", state.length(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 licenseId; _jparser.validateByNameThrow("licenseId", licenseId);
	AtfValidator::validateInt(_descr, "licenseId", licenseId, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_USER_PROPS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_USER_PROPS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 privs; _parser.parseUINT32(privs);
	AtfValidator::validateInt(_descr, "privs", privs, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateInt(_descr, "locale", locale, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	UINT32 emLocale; _parser.parseUINT32(emLocale);
	AtfValidator::validateInt(_descr, "emLocale", emLocale, _checker, __FILE__, __LINE__);
	UINT64 privs2; _parser.parseUINT64(privs2);
	AtfValidator::validateUint(_descr, "privs2", privs2, _checker, __FILE__, __LINE__);
	UINT32 vipStatus; _parser.parseUINT32(vipStatus);
	AtfValidator::validateInt(_descr, "vipStatus", vipStatus, _checker, __FILE__, __LINE__);
	UINT32 timeZone; _parser.parseUINT32(timeZone);
	AtfValidator::validateInt(_descr, "timeZone", timeZone, _checker, __FILE__, __LINE__);
	UINT32 origUserIntId; _parser.parseUINT32(origUserIntId);
	AtfValidator::validateInt(_descr, "origUserIntId", origUserIntId, _checker, __FILE__, __LINE__);
	UINT32 userIntId; _parser.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	UINT64 flags2; _parser.parseUINT64(flags2);
	AtfValidator::validateUint(_descr, "flags2", flags2, _checker, __FILE__, __LINE__);
	UINT32 vppCounter1; _parser.parseUINT32(vppCounter1);
	AtfValidator::validateInt(_descr, "vppCounter1", vppCounter1, _checker, __FILE__, __LINE__);
	UINT32 vppCounter2; _parser.parseUINT32(vppCounter2);
	AtfValidator::validateInt(_descr, "vppCounter2", vppCounter2, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szStellarBonuses = Atf::LAtfVector< StellarBonus, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("stellarBonuses"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "stellarBonuses", szStellarBonuses, _checker, __FILE__, __LINE__);
	bool uiStatsAllowed; _parser.parseBOOL(uiStatsAllowed);
	AtfValidator::validateInt(_descr, "uiStatsAllowed", uiStatsAllowed, _checker, __FILE__, __LINE__);
	bool rmTransersAllowed; _parser.parseBOOL(rmTransersAllowed);
	AtfValidator::validateInt(_descr, "rmTransersAllowed", rmTransersAllowed, _checker, __FILE__, __LINE__);
	UINT32 obsolete; _parser.parseUINT32(obsolete);
	AtfValidator::validateInt(_descr, "obsolete", obsolete, _checker, __FILE__, __LINE__);
	BYTE findSimilarTableFlag; _parser.parseBYTE(findSimilarTableFlag);
	AtfValidator::validateInt(_descr, "findSimilarTableFlag", findSimilarTableFlag, _checker, __FILE__, __LINE__);
	int szMilestoneBonusesOld = Atf::LAtfVector< MilestoneBonusOld, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("milestoneBonusesOld"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "milestoneBonusesOld", szMilestoneBonusesOld, _checker, __FILE__, __LINE__);
	int szVipLevels = Atf::LAtfVector< VIPLevel, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("vipLevels"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "vipLevels", szVipLevels, _checker, __FILE__, __LINE__);
	bool hgEnabled; _parser.parseBOOL(hgEnabled);
	AtfValidator::validateInt(_descr, "hgEnabled", hgEnabled, _checker, __FILE__, __LINE__);
	UINT32 cppCountr3; _parser.parseUINT32(cppCountr3);
	AtfValidator::validateInt(_descr, "cppCountr3", cppCountr3, _checker, __FILE__, __LINE__);
	bool fastDepositEnabled; _parser.parseBOOL(fastDepositEnabled);
	AtfValidator::validateInt(_descr, "fastDepositEnabled", fastDepositEnabled, _checker, __FILE__, __LINE__);
	CountriesMsgBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("countries"), _fieldsWithUnparsedContent);
	bool handSharingEnabledForSiteAndBrand; _parser.parseBOOL(handSharingEnabledForSiteAndBrand);
	AtfValidator::validateInt(_descr, "handSharingEnabledForSiteAndBrand", handSharingEnabledForSiteAndBrand, _checker, __FILE__, __LINE__);
	bool itAccVerificationOpen; _parser.parseBOOL(itAccVerificationOpen);
	AtfValidator::validateInt(_descr, "itAccVerificationOpen", itAccVerificationOpen, _checker, __FILE__, __LINE__);
	bool allowSmsValidationForNewInstallId; _parser.parseBOOL(allowSmsValidationForNewInstallId);
	AtfValidator::validateInt(_descr, "allowSmsValidationForNewInstallId", allowSmsValidationForNewInstallId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userWebId"); size_t szUserWebId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userWebId", szUserWebId, _checker, __FILE__, __LINE__);
	int szRawVIPLevels = Atf::LAtfVector< RawVIPLevel, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("rawVIPLevels"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "rawVIPLevels", szRawVIPLevels, _checker, __FILE__, __LINE__);
	UINT32 chatModeratorRestrictions; _parser.parseUINT32(chatModeratorRestrictions);
	AtfValidator::validateInt(_descr, "chatModeratorRestrictions", chatModeratorRestrictions, _checker, __FILE__, __LINE__);
	int szMilestoneBonusesNew = Atf::LAtfVector< MilestoneBonusNew, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("milestoneBonusesNew"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "milestoneBonusesNew", szMilestoneBonusesNew, _checker, __FILE__, __LINE__);
	bool allowSmsPwdReset; _parser.parseBOOL(allowSmsPwdReset);
	AtfValidator::validateInt(_descr, "allowSmsPwdReset", allowSmsPwdReset, _checker, __FILE__, __LINE__);
	HallOfFameLevels::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("hallOfFameLevels"), _fieldsWithUnparsedContent);
	UINT32 lifetimeFpp; _parser.parseUINT32(lifetimeFpp);
	AtfValidator::validateInt(_descr, "lifetimeFpp", lifetimeFpp, _checker, __FILE__, __LINE__);
	UINT32 otherFlags; _parser.parseUINT32(otherFlags);
	AtfValidator::validateInt(_descr, "otherFlags", otherFlags, _checker, __FILE__, __LINE__);
	ClientFeatureVisibility::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientFeatureVisibility"), _fieldsWithUnparsedContent);
	UINT64 privs3; _parser.parseUINT64(privs3);
	AtfValidator::validateUint(_descr, "privs3", privs3, _checker, __FILE__, __LINE__);
	SrvTime registered; _parser.parseSrvTime(registered);
	AtfValidator::validateSrvDateTime(_descr, "registered", registered, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "state"); size_t szState = strlen(_dummy);
	AtfValidator::validateInt(_descr, "state", szState, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 licenseId; _parser.parseUINT32(licenseId);
	AtfValidator::validateInt(_descr, "licenseId", licenseId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    TournInfo
//=================================================================

Lobby::cli::TournInfo::TournInfo()
{
	clear();
}

void Lobby::cli::TournInfo::clear()
{
	startTime.setNull();
	tournId = 0;
	buyIn = 0;
	fppBuyIn = 0;
	rake = 0;
	game = 0;
	isHiLo = 0;
	structure = 0;
	isPlayMoney = 0;
	isSitAndGo = 0;
	isRunning = 0;
}

bool Lobby::cli::TournInfo::equals(const TournInfo& _o) const
{
	return startTime.equals(_o.startTime) &&
		tournId == _o.tournId &&
		buyIn == _o.buyIn &&
		fppBuyIn == _o.fppBuyIn &&
		rake == _o.rake &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		structure == _o.structure &&
		isPlayMoney == _o.isPlayMoney &&
		isSitAndGo == _o.isSitAndGo &&
		isRunning == _o.isRunning;
}

const char *Lobby::cli::TournInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("startTime=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, startTime);
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendUint(buyIn);
	_buf.append(',');
	_buf.append("fppBuyIn=");
	_buf.appendUint(fppBuyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendUint(rake);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("isSitAndGo=");
	_buf.appendUint(isSitAndGo);
	_buf.append(',');
	_buf.append("isRunning=");
	_buf.appendUint(isRunning);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::TournInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "startTime", startTime);
	Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyIn", buyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("fppBuyIn", fppBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("rake", rake, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("isSitAndGo", isSitAndGo, _buf);
	Atf::XmlElement::encodeAsXmlElement("isRunning", isRunning, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::TournInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("startTime"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, startTime);
		}
		else if (_element.equals("tournId"))
		{
			tournId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("buyIn"))
		{
			buyIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("fppBuyIn"))
		{
			fppBuyIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rake"))
		{
			rake = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("game"))
		{
			game = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("structure"))
		{
			structure = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isPlayMoney"))
		{
			isPlayMoney = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isSitAndGo"))
		{
			isSitAndGo = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isRunning"))
		{
			isRunning = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::TournInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeSrvTime(startTime);
	_msg.composeUINT32(tournId);
	_msg.composeUINT32(buyIn);
	_msg.composeUINT32(fppBuyIn);
	_msg.composeUINT32(rake);
	_msg.composeBYTE(game);
	_msg.composeBYTE(isHiLo);
	_msg.composeBYTE(structure);
	_msg.composeBYTE(isPlayMoney);
	_msg.composeBYTE(isSitAndGo);
	_msg.composeBYTE(isRunning);
}

void Lobby::cli::TournInfo::parseMsg(CommMsgParser& _parser)
{
	_parser.parseSrvTime(startTime);
	_parser.parseUINT32(tournId);
	_parser.parseUINT32(buyIn);
	_parser.parseUINT32(fppBuyIn);
	_parser.parseUINT32(rake);
	_parser.parseBYTE(game);
	_parser.parseBYTE(isHiLo);
	_parser.parseBYTE(structure);
	_parser.parseBYTE(isPlayMoney);
	_parser.parseBYTE(isSitAndGo);
	_parser.parseBYTE(isRunning);
}

const char *Lobby::cli::TournInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("startTime", startTime);
	_jsonstr.compose("tournId", tournId);
	_jsonstr.compose("buyIn", buyIn);
	_jsonstr.compose("fppBuyIn", fppBuyIn);
	_jsonstr.compose("rake", rake);
	_jsonstr.compose("game", game);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("isSitAndGo", isSitAndGo);
	_jsonstr.compose("isRunning", isRunning);
	return _buf.c_str();
}

void Lobby::cli::TournInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("startTime", startTime);
	_jparser.parseByNameThrow("tournId", tournId);
	_jparser.parseByNameThrow("buyIn", buyIn);
	_jparser.parseByNameThrow("fppBuyIn", fppBuyIn);
	_jparser.parseByNameThrow("rake", rake);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("isSitAndGo", isSitAndGo);
	_jparser.parseByNameThrow("isRunning", isRunning);
}

/* static */ void Lobby::cli::TournInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	SrvTime startTime; _jparser.validateByNameThrow("startTime", startTime);
	AtfValidator::validateSrvDateTime(_descr, "startTime", startTime, _checker, __FILE__, __LINE__);
	UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	UINT32 buyIn; _jparser.validateByNameThrow("buyIn", buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT32 fppBuyIn; _jparser.validateByNameThrow("fppBuyIn", fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	UINT32 rake; _jparser.validateByNameThrow("rake", rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	BYTE isSitAndGo; _jparser.validateByNameThrow("isSitAndGo", isSitAndGo);
	AtfValidator::validateInt(_descr, "isSitAndGo", isSitAndGo, _checker, __FILE__, __LINE__);
	BYTE isRunning; _jparser.validateByNameThrow("isRunning", isRunning);
	AtfValidator::validateInt(_descr, "isRunning", isRunning, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::TournInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	SrvTime startTime; _parser.parseSrvTime(startTime);
	AtfValidator::validateSrvDateTime(_descr, "startTime", startTime, _checker, __FILE__, __LINE__);
	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	UINT32 buyIn; _parser.parseUINT32(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT32 fppBuyIn; _parser.parseUINT32(fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	UINT32 rake; _parser.parseUINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	BYTE isSitAndGo; _parser.parseBYTE(isSitAndGo);
	AtfValidator::validateInt(_descr, "isSitAndGo", isSitAndGo, _checker, __FILE__, __LINE__);
	BYTE isRunning; _parser.parseBYTE(isRunning);
	AtfValidator::validateInt(_descr, "isRunning", isRunning, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_TOURN_REG
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG::Protocol_MSG_LOBBY_FIND_TOURN_REG()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG::Protocol_MSG_LOBBY_FIND_TOURN_REG(Protocol_MSG_LOBBY_FIND_TOURN_REG&& _o)
	: notUsed(std::move(_o.notUsed))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG& Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG::operator=(Protocol_MSG_LOBBY_FIND_TOURN_REG&& _o)
{
	if(this != &_o)
	{
		notUsed = std::move(_o.notUsed);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG::clear()
{
	notUsed.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG::equals(const Protocol_MSG_LOBBY_FIND_TOURN_REG& _o) const
{
	return Atf::atfPStringEquals(notUsed, _o.notUsed);
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_FIND_TOURN_REG != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_FIND_TOURN_REG*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_TOURN_REG).append(")");
	_buf.append(',');
	_buf.append("notUsed=");
	_buf.append(notUsed);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_FIND_TOURN_REG).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsed", notUsed, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsed"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsed)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsed);
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsed);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsed", notUsed);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsed", notUsed);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TOURN_REG";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsed; _jparser.validateByNameThrow("notUsed", notUsed);
	AtfValidator::validateIntMax(_descr, "notUsed", notUsed.length(), 20, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TOURN_REG";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsed"); size_t szNotUsed = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsed", szNotUsed, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY::Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY::Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY(Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, tournInfo(std::move(_o.tournInfo))
	, serverName(std::move(_o.serverName))
	, currency(std::move(_o.currency))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY& Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY::operator=(Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		tournInfo = std::move(_o.tournInfo);
		serverName = std::move(_o.serverName);
		currency = std::move(_o.currency);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY::clear()
{
	errCode = 0;
	tournInfo.clear();
	serverName.clear();
	currency.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY::equals(const Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY& _o) const
{
	return errCode == _o.errCode &&
		tournInfo.equals(_o.tournInfo) &&
		serverName.equals(_o.serverName) &&
		currency.equals(_o.currency);
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_FIND_TOURN_REG_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_TOURN_REG_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("tournInfo=");
	tournInfo.toTraceString(_buf);
	_buf.append(',');
	_buf.append("serverName=");
	serverName.toTraceString(_buf);
	_buf.append(',');
	_buf.append("currency=");
	currency.toTraceString(_buf);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_FIND_TOURN_REG_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	tournInfo.toXmlString("tournInfo", _buf);
	serverName.toXmlString("serverName", _buf);
	currency.toXmlString("currency", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournInfo"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TournInfo, 4 > >::FromXmlString(_value, tournInfo)) return false;
			}
			else if (_element.equals("serverName"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< PString, 4 > >::FromXmlString(_value, serverName)) return false;
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< PString, 4 > >::FromXmlString(_value, currency)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	tournInfo.composeMsg(_msg, _ignoreJSON);
	serverName.composeMsg(_msg, _ignoreJSON);
	currency.composeMsg(_msg, _ignoreJSON);
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	tournInfo.parseMsg(_parser);
	serverName.parseMsg(_parser);
	currency.parseMsg(_parser);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("tournInfo", tournInfo);
	_jsonstr.compose("serverName", serverName);
	_jsonstr.compose("currency", currency);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("tournInfo", tournInfo);
	_jparser.parseByNameThrow("serverName", serverName);
	_jparser.parseByNameThrow("currency", currency);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TOURN_REG_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TournInfo > tournInfo; _jparser.validateByNameThrow("tournInfo", tournInfo);
	AtfValidator::validateInt(_descr, "tournInfo", tournInfo.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PString > serverName; _jparser.validateByNameThrow("serverName", serverName);
	AtfValidator::validateInt(_descr, "serverName", serverName.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PString > currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TOURN_REG_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTournInfo = Atf::LAtfVector< TournInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournInfo"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tournInfo", szTournInfo, _checker, __FILE__, __LINE__);
	int szServerName = Atf::LAtfVector< PString, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("serverName"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "serverName", szServerName, _checker, __FILE__, __LINE__);
	int szCurrency = Atf::LAtfVector< PString, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("currency"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    TournInfo2
//=================================================================

Lobby::cli::TournInfo2::TournInfo2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::TournInfo2::TournInfo2(TournInfo2&& _o)
	: tournInfo(std::move(_o.tournInfo))
	, serverAddress(std::move(_o.serverAddress))
	, currency(std::move(_o.currency))
	, clubId(std::move(_o.clubId))
	, scalePm(std::move(_o.scalePm))
	, flags2(std::move(_o.flags2))
{
}

Lobby::cli::TournInfo2& Lobby::cli::TournInfo2::operator=(TournInfo2&& _o)
{
	if(this != &_o)
	{
		tournInfo = std::move(_o.tournInfo);
		serverAddress = std::move(_o.serverAddress);
		currency = std::move(_o.currency);
		clubId = std::move(_o.clubId);
		scalePm = std::move(_o.scalePm);
		flags2 = std::move(_o.flags2);
	}
	return *this;
}

#endif

void Lobby::cli::TournInfo2::clear()
{
	tournInfo.clear();
	serverAddress.clear();
	currency.clear();
	clubId = 0;
	scalePm = 0;
	flags2 = 0;
}

bool Lobby::cli::TournInfo2::equals(const TournInfo2& _o) const
{
	return tournInfo.equals(_o.tournInfo) &&
		Atf::atfPStringEquals(serverAddress, _o.serverAddress) &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		clubId == _o.clubId &&
		scalePm == _o.scalePm &&
		flags2 == _o.flags2;
}

const char *Lobby::cli::TournInfo2::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournInfo=");
	tournInfo.toTraceString(_buf);
	_buf.append(',');
	_buf.append("serverAddress=");
	_buf.append(serverAddress);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("scalePm=");
	_buf.appendUint(scalePm);
	_buf.append(',');
	_buf.append("flags2=");
	_buf.appendUint64(flags2);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::TournInfo2::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	tournInfo.toXmlString("tournInfo", _buf);
	Atf::XmlElement::encodeAsXmlElement("serverAddress", serverAddress, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	Atf::XmlElement::encodeAsXmlElement("scalePm", scalePm, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags2", flags2, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::TournInfo2::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("tournInfo"))
		{
			if(!Atf::AtfTempl< TournInfo >::FromXmlString(_value, tournInfo)) return false;
		}
		else if (_element.equals("serverAddress"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, serverAddress)) return false;
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("clubId"))
		{
			clubId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("scalePm"))
		{
			scalePm = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("flags2"))
		{
			flags2 = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::TournInfo2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(TournInfo2())) // not empty
	{
		CommMsgBody _body0;
		tournInfo.composeMsg(_body0, _ignoreJSON);
		_body0.composeString(serverAddress);
		_body0.composeString(currency);
		_body0.composeUINT32(clubId);
		_body.composeMsgBody(_body0);
		_body.composeUINT32(scalePm);
		_body.composeUINT64(flags2);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::cli::TournInfo2::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	parseAnonymousMsgBody0(_parser0);
	_parser0.parseUINT32(scalePm);
	_parser0.parseUINT64(flags2);
}

const char *Lobby::cli::TournInfo2::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tournInfo", tournInfo);
	_jsonstr.compose("serverAddress", serverAddress);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("clubId", clubId);
	_jsonstr.compose("scalePm", scalePm);
	_jsonstr.compose("flags2", flags2);
	return _buf.c_str();
}

void Lobby::cli::TournInfo2::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tournInfo", tournInfo);
	_jparser.parseByNameThrow("serverAddress", serverAddress);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("clubId", clubId);
	_jparser.parseByNameThrow("scalePm", scalePm);
	_jparser.parseByNameThrow("flags2", flags2);
}

/* static */ void Lobby::cli::TournInfo2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TournInfo tournInfo; _jparser.validateByNameThrow("tournInfo", tournInfo);
	PString serverAddress; _jparser.validateByNameThrow("serverAddress", serverAddress);
	AtfValidator::validateInt(_descr, "serverAddress", serverAddress.length(), _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 scalePm; _jparser.validateByNameThrow("scalePm", scalePm);
	AtfValidator::validateInt(_descr, "scalePm", scalePm, _checker, __FILE__, __LINE__);
	UINT64 flags2; _jparser.validateByNameThrow("flags2", flags2);
	AtfValidator::validateUint(_descr, "flags2", flags2, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::TournInfo2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	validateAnonymousMsgBody0(_parser0, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 scalePm; _parser0.parseUINT32(scalePm);
	AtfValidator::validateInt(_descr, "scalePm", scalePm, _checker, __FILE__, __LINE__);
	UINT64 flags2; _parser0.parseUINT64(flags2);
	AtfValidator::validateUint(_descr, "flags2", flags2, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void Lobby::cli::TournInfo2::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	tournInfo.parseMsg(_parser0);
	_parser0.parseStringP(serverAddress);
	_parser0.parseStringP(currency);
	_parser0.parseUINT32(clubId);
}

/*static*/ void Lobby::cli::TournInfo2::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	PString _descbuf;
	TournInfo::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tournInfo"), _fieldsWithUnparsedContent);
	_parser0.parseStringN(_dummy, 0, "serverAddress"); size_t szServerAddress = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverAddress", szServerAddress, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 clubId; _parser0.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_TOURN_REG2
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2::Protocol_MSG_LOBBY_FIND_TOURN_REG2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2::Protocol_MSG_LOBBY_FIND_TOURN_REG2(Protocol_MSG_LOBBY_FIND_TOURN_REG2&& _o)
	: notUsed(std::move(_o.notUsed))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2& Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2::operator=(Protocol_MSG_LOBBY_FIND_TOURN_REG2&& _o)
{
	if(this != &_o)
	{
		notUsed = std::move(_o.notUsed);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2::clear()
{
	notUsed.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2::equals(const Protocol_MSG_LOBBY_FIND_TOURN_REG2& _o) const
{
	return Atf::atfPStringEquals(notUsed, _o.notUsed);
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_FIND_TOURN_REG2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_FIND_TOURN_REG2*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_TOURN_REG2).append(")");
	_buf.append(',');
	_buf.append("notUsed=");
	_buf.append(notUsed);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_FIND_TOURN_REG2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsed", notUsed, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsed"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsed)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsed);
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsed);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsed", notUsed);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsed", notUsed);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TOURN_REG2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsed; _jparser.validateByNameThrow("notUsed", notUsed);
	AtfValidator::validateIntMax(_descr, "notUsed", notUsed.length(), 20, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TOURN_REG2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsed"); size_t szNotUsed = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsed", szNotUsed, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY::Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY::Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY(Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, tournInfo(std::move(_o.tournInfo))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY& Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY::operator=(Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		tournInfo = std::move(_o.tournInfo);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY::clear()
{
	errCode = 0;
	tournInfo.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY::equals(const Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		tournInfo.equals(_o.tournInfo);
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_FIND_TOURN_REG2_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_TOURN_REG2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("tournInfo=");
	tournInfo.toTraceString(_buf);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_FIND_TOURN_REG2_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	tournInfo.toXmlString("tournInfo", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournInfo"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TournInfo2, 4 > >::FromXmlString(_value, tournInfo)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	tournInfo.composeMsg(_msg, _ignoreJSON);
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	tournInfo.parseMsg(_parser);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("tournInfo", tournInfo);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("tournInfo", tournInfo);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TOURN_REG2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TournInfo2 > tournInfo; _jparser.validateByNameThrow("tournInfo", tournInfo);
	AtfValidator::validateInt(_descr, "tournInfo", tournInfo.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TOURN_REG2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTournInfo = Atf::LAtfVector< TournInfo2, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournInfo"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tournInfo", szTournInfo, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_WAIT
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT::Protocol_MSG_LOBBY_FIND_WAIT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT::Protocol_MSG_LOBBY_FIND_WAIT(Protocol_MSG_LOBBY_FIND_WAIT&& _o)
	: notUsed(std::move(_o.notUsed))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT& Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT::operator=(Protocol_MSG_LOBBY_FIND_WAIT&& _o)
{
	if(this != &_o)
	{
		notUsed = std::move(_o.notUsed);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT::clear()
{
	notUsed.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT::equals(const Protocol_MSG_LOBBY_FIND_WAIT& _o) const
{
	return Atf::atfPStringEquals(notUsed, _o.notUsed);
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_FIND_WAIT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_FIND_WAIT*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_WAIT).append(")");
	_buf.append(',');
	_buf.append("notUsed=");
	_buf.append(notUsed);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_FIND_WAIT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsed", notUsed, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsed"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsed)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsed);
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsed);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsed", notUsed);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsed", notUsed);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_WAIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsed; _jparser.validateByNameThrow("notUsed", notUsed);
	AtfValidator::validateIntMax(_descr, "notUsed", notUsed.length(), 20, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_WAIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsed"); size_t szNotUsed = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsed", szNotUsed, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    TableInfo
//=================================================================

Lobby::cli::TableInfo::TableInfo()
{
	clear();
}

void Lobby::cli::TableInfo::clear()
{
	tableId = 0;
	order = 0;
}

bool Lobby::cli::TableInfo::equals(const TableInfo& _o) const
{
	return tableId == _o.tableId &&
		order == _o.order;
}

const char *Lobby::cli::TableInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tableId=");
	_buf.appendUint(tableId);
	_buf.append(',');
	_buf.append("order=");
	_buf.appendUint(order);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::TableInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("tableId", tableId, _buf);
	Atf::XmlElement::encodeAsXmlElement("order", order, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::TableInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("tableId"))
		{
			tableId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("order"))
		{
			order = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::TableInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(tableId);
	_msg.composeUINT32(order);
}

void Lobby::cli::TableInfo::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tableId);
	_parser.parseUINT32(order);
}

const char *Lobby::cli::TableInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tableId", tableId);
	_jsonstr.compose("order", order);
	return _buf.c_str();
}

void Lobby::cli::TableInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tableId", tableId);
	_jparser.parseByNameThrow("order", order);
}

/* static */ void Lobby::cli::TableInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tableId; _jparser.validateByNameThrow("tableId", tableId);
	AtfValidator::validateInt(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	UINT32 order; _jparser.validateByNameThrow("order", order);
	AtfValidator::validateInt(_descr, "order", order, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::TableInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 tableId; _parser.parseUINT32(tableId);
	AtfValidator::validateInt(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	UINT32 order; _parser.parseUINT32(order);
	AtfValidator::validateInt(_descr, "order", order, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    ServerInfo
//=================================================================

Lobby::cli::ServerInfo::ServerInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::ServerInfo::ServerInfo(ServerInfo&& _o)
	: serverName(std::move(_o.serverName))
	, serverObject(std::move(_o.serverObject))
{
}

Lobby::cli::ServerInfo& Lobby::cli::ServerInfo::operator=(ServerInfo&& _o)
{
	if(this != &_o)
	{
		serverName = std::move(_o.serverName);
		serverObject = std::move(_o.serverObject);
	}
	return *this;
}

#endif

void Lobby::cli::ServerInfo::clear()
{
	serverName.clear();
	serverObject.clear();
}

bool Lobby::cli::ServerInfo::equals(const ServerInfo& _o) const
{
	return Atf::atfPStringEquals(serverName, _o.serverName) &&
		Atf::atfPStringEquals(serverObject, _o.serverObject);
}

const char *Lobby::cli::ServerInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("serverName=");
	_buf.append(serverName);
	_buf.append(',');
	_buf.append("serverObject=");
	_buf.append(serverObject);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::ServerInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("serverName", serverName, _buf);
	Atf::XmlElement::encodeAsXmlElement("serverObject", serverObject, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::ServerInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("serverName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, serverName)) return false;
		}
		else if (_element.equals("serverObject"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, serverObject)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::ServerInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(serverName);
	_msg.composeString(serverObject);
}

void Lobby::cli::ServerInfo::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(serverName);
	_parser.parseStringP(serverObject);
}

const char *Lobby::cli::ServerInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("serverName", serverName);
	_jsonstr.compose("serverObject", serverObject);
	return _buf.c_str();
}

void Lobby::cli::ServerInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("serverName", serverName);
	_jparser.parseByNameThrow("serverObject", serverObject);
}

/* static */ void Lobby::cli::ServerInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString serverName; _jparser.validateByNameThrow("serverName", serverName);
	AtfValidator::validateInt(_descr, "serverName", serverName.length(), _checker, __FILE__, __LINE__);
	PString serverObject; _jparser.validateByNameThrow("serverObject", serverObject);
	AtfValidator::validateInt(_descr, "serverObject", serverObject.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::ServerInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "serverName"); size_t szServerName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverName", szServerName, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "serverObject"); size_t szServerObject = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObject", szServerObject, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_WAIT_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT_REPLY::Protocol_MSG_LOBBY_FIND_WAIT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT_REPLY::Protocol_MSG_LOBBY_FIND_WAIT_REPLY(Protocol_MSG_LOBBY_FIND_WAIT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, tables(std::move(_o.tables))
	, servers(std::move(_o.servers))
	, totals(std::move(_o.totals))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT_REPLY& Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT_REPLY::operator=(Protocol_MSG_LOBBY_FIND_WAIT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		tables = std::move(_o.tables);
		servers = std::move(_o.servers);
		totals = std::move(_o.totals);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT_REPLY::clear()
{
	errCode = 0;
	tables.clear();
	servers.clear();
	totals.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT_REPLY::equals(const Protocol_MSG_LOBBY_FIND_WAIT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		tables.equals(_o.tables) &&
		servers.equals(_o.servers) &&
		totals.equals(_o.totals);
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_FIND_WAIT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_FIND_WAIT_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_WAIT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("tables=");
	tables.toTraceString(_buf);
	_buf.append(',');
	_buf.append("servers=");
	servers.toTraceString(_buf);
	_buf.append(',');
	_buf.append("totals=");
	totals.toTraceString(_buf);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_FIND_WAIT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	tables.toXmlString("tables", _buf);
	servers.toXmlString("servers", _buf);
	totals.toXmlString("totals", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tables"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TableInfo, 4 > >::FromXmlString(_value, tables)) return false;
			}
			else if (_element.equals("servers"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ServerInfo, 4 > >::FromXmlString(_value, servers)) return false;
			}
			else if (_element.equals("totals"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, totals)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	tables.composeMsg(_msg, _ignoreJSON);
	servers.composeMsg(_msg, _ignoreJSON);
	totals.composeMsg(_msg, _ignoreJSON);
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	tables.parseMsg(_parser);
	servers.parseMsg(_parser);
	totals.parseMsg(_parser);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("tables", tables);
	_jsonstr.compose("servers", servers);
	_jsonstr.compose("totals", totals);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("tables", tables);
	_jparser.parseByNameThrow("servers", servers);
	_jparser.parseByNameThrow("totals", totals);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_WAIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TableInfo > tables; _jparser.validateByNameThrow("tables", tables);
	AtfValidator::validateInt(_descr, "tables", tables.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< ServerInfo > servers; _jparser.validateByNameThrow("servers", servers);
	AtfValidator::validateInt(_descr, "servers", servers.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT32 > totals; _jparser.validateByNameThrow("totals", totals);
	AtfValidator::validateInt(_descr, "totals", totals.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_WAIT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_WAIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTables = Atf::LAtfVector< TableInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tables"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tables", szTables, _checker, __FILE__, __LINE__);
	int szServers = Atf::LAtfVector< ServerInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("servers"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "servers", szServers, _checker, __FILE__, __LINE__);
	int szTotals = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("totals"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "totals", szTotals, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    LeaderPoints
//=================================================================

Lobby::cli::LeaderPoints::LeaderPoints()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::LeaderPoints::LeaderPoints(LeaderPoints&& _o)
	: player(std::move(_o.player))
	, points(std::move(_o.points))
{
}

Lobby::cli::LeaderPoints& Lobby::cli::LeaderPoints::operator=(LeaderPoints&& _o)
{
	if(this != &_o)
	{
		player = std::move(_o.player);
		points = std::move(_o.points);
	}
	return *this;
}

#endif

void Lobby::cli::LeaderPoints::clear()
{
	player.clear();
	points = 0;
}

bool Lobby::cli::LeaderPoints::equals(const LeaderPoints& _o) const
{
	return Atf::atfPStringEquals(player, _o.player) &&
		points == _o.points;
}

const char *Lobby::cli::LeaderPoints::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("player=");
	_buf.append(player);
	_buf.append(',');
	_buf.append("points=");
	_buf.appendUint(points);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::LeaderPoints::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("player", player, _buf);
	Atf::XmlElement::encodeAsXmlElement("points", points, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::LeaderPoints::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("player"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, player)) return false;
		}
		else if (_element.equals("points"))
		{
			points = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::LeaderPoints::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(player);
	_msg.composeUINT32(points);
}

void Lobby::cli::LeaderPoints::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(player);
	_parser.parseUINT32(points);
}

const char *Lobby::cli::LeaderPoints::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("player", player);
	_jsonstr.compose("points", points);
	return _buf.c_str();
}

void Lobby::cli::LeaderPoints::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("player", player);
	_jparser.parseByNameThrow("points", points);
}

/* static */ void Lobby::cli::LeaderPoints::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString player; _jparser.validateByNameThrow("player", player);
	AtfValidator::validateInt(_descr, "player", player.length(), _checker, __FILE__, __LINE__);
	UINT32 points; _jparser.validateByNameThrow("points", points);
	AtfValidator::validateInt(_descr, "points", points, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::LeaderPoints::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "player"); size_t szPlayer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "player", szPlayer, _checker, __FILE__, __LINE__);
	UINT32 points; _parser.parseUINT32(points);
	AtfValidator::validateInt(_descr, "points", points, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TlbVector
//=================================================================

Lobby::cli::TlbVector::TlbVector()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::TlbVector::TlbVector(TlbVector&& _o)
	: lastTimestamp(std::move(_o.lastTimestamp))
	, tlbType(std::move(_o.tlbType))
	, timeFrom(std::move(_o.timeFrom))
	, timeTo(std::move(_o.timeTo))
	, leaderPoints(std::move(_o.leaderPoints))
	, userPlace(std::move(_o.userPlace))
	, userPoints(std::move(_o.userPoints))
{
}

Lobby::cli::TlbVector& Lobby::cli::TlbVector::operator=(TlbVector&& _o)
{
	if(this != &_o)
	{
		lastTimestamp = std::move(_o.lastTimestamp);
		tlbType = std::move(_o.tlbType);
		timeFrom = std::move(_o.timeFrom);
		timeTo = std::move(_o.timeTo);
		leaderPoints = std::move(_o.leaderPoints);
		userPlace = std::move(_o.userPlace);
		userPoints = std::move(_o.userPoints);
	}
	return *this;
}

#endif

void Lobby::cli::TlbVector::clear()
{
	lastTimestamp.clear();
	tlbType = 0;
	timeFrom.setNull();
	timeTo.setNull();
	leaderPoints.clear();
	userPlace = 0;
	userPoints = 0;
}

bool Lobby::cli::TlbVector::equals(const TlbVector& _o) const
{
	return Atf::atfPStringEquals(lastTimestamp, _o.lastTimestamp) &&
		tlbType == _o.tlbType &&
		timeFrom.equals(_o.timeFrom) &&
		timeTo.equals(_o.timeTo) &&
		leaderPoints.equals(_o.leaderPoints) &&
		userPlace == _o.userPlace &&
		userPoints == _o.userPoints;
}

const char *Lobby::cli::TlbVector::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("lastTimestamp=");
	_buf.append(lastTimestamp);
	_buf.append(',');
	_buf.append("tlbType=");
	_buf.appendUint(tlbType);
	_buf.append(',');
	_buf.append("timeFrom=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, timeFrom);
	_buf.append(',');
	_buf.append("timeTo=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, timeTo);
	_buf.append(',');
	_buf.append("leaderPoints=");
	leaderPoints.toTraceString(_buf);
	_buf.append(',');
	_buf.append("userPlace=");
	_buf.appendUint(userPlace);
	_buf.append(',');
	_buf.append("userPoints=");
	_buf.appendUint(userPoints);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::TlbVector::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("lastTimestamp", lastTimestamp, _buf);
	Atf::XmlElement::encodeAsXmlElement("tlbType", tlbType, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "timeFrom", timeFrom);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "timeTo", timeTo);
	leaderPoints.toXmlString("leaderPoints", _buf);
	Atf::XmlElement::encodeAsXmlElement("userPlace", userPlace, _buf);
	Atf::XmlElement::encodeAsXmlElement("userPoints", userPoints, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::TlbVector::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("lastTimestamp"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, lastTimestamp)) return false;
		}
		else if (_element.equals("tlbType"))
		{
			tlbType = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("timeFrom"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, timeFrom);
		}
		else if (_element.equals("timeTo"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, timeTo);
		}
		else if (_element.equals("leaderPoints"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< LeaderPoints, 4 > >::FromXmlString(_value, leaderPoints)) return false;
		}
		else if (_element.equals("userPlace"))
		{
			userPlace = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("userPoints"))
		{
			userPoints = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::TlbVector::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(lastTimestamp);
	_msg.composeBYTE(tlbType);
	_msg.composeSrvTime(timeFrom);
	_msg.composeSrvTime(timeTo);
	leaderPoints.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(userPlace);
	_msg.composeUINT32(userPoints);
}

void Lobby::cli::TlbVector::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(lastTimestamp);
	_parser.parseBYTE(tlbType);
	_parser.parseSrvTime(timeFrom);
	_parser.parseSrvTime(timeTo);
	leaderPoints.parseMsg(_parser);
	_parser.parseUINT32(userPlace);
	_parser.parseUINT32(userPoints);
}

const char *Lobby::cli::TlbVector::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("lastTimestamp", lastTimestamp);
	_jsonstr.compose("tlbType", tlbType);
	_jsonstr.compose("timeFrom", timeFrom);
	_jsonstr.compose("timeTo", timeTo);
	_jsonstr.compose("leaderPoints", leaderPoints);
	_jsonstr.compose("userPlace", userPlace);
	_jsonstr.compose("userPoints", userPoints);
	return _buf.c_str();
}

void Lobby::cli::TlbVector::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("lastTimestamp", lastTimestamp);
	_jparser.parseByNameThrow("tlbType", tlbType);
	_jparser.parseByNameThrow("timeFrom", timeFrom);
	_jparser.parseByNameThrow("timeTo", timeTo);
	_jparser.parseByNameThrow("leaderPoints", leaderPoints);
	_jparser.parseByNameThrow("userPlace", userPlace);
	_jparser.parseByNameThrow("userPoints", userPoints);
}

/* static */ void Lobby::cli::TlbVector::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString lastTimestamp; _jparser.validateByNameThrow("lastTimestamp", lastTimestamp);
	AtfValidator::validateInt(_descr, "lastTimestamp", lastTimestamp.length(), _checker, __FILE__, __LINE__);
	BYTE tlbType; _jparser.validateByNameThrow("tlbType", tlbType);
	AtfValidator::validateInt(_descr, "tlbType", tlbType, _checker, __FILE__, __LINE__);
	SrvTime timeFrom; _jparser.validateByNameThrow("timeFrom", timeFrom);
	AtfValidator::validateSrvDateTime(_descr, "timeFrom", timeFrom, _checker, __FILE__, __LINE__);
	SrvTime timeTo; _jparser.validateByNameThrow("timeTo", timeTo);
	AtfValidator::validateSrvDateTime(_descr, "timeTo", timeTo, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< LeaderPoints > leaderPoints; _jparser.validateByNameThrow("leaderPoints", leaderPoints);
	AtfValidator::validateInt(_descr, "leaderPoints", leaderPoints.size(), _checker, __FILE__, __LINE__);
	UINT32 userPlace; _jparser.validateByNameThrow("userPlace", userPlace);
	AtfValidator::validateInt(_descr, "userPlace", userPlace, _checker, __FILE__, __LINE__);
	UINT32 userPoints; _jparser.validateByNameThrow("userPoints", userPoints);
	AtfValidator::validateInt(_descr, "userPoints", userPoints, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::TlbVector::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "lastTimestamp"); size_t szLastTimestamp = strlen(_dummy);
	AtfValidator::validateInt(_descr, "lastTimestamp", szLastTimestamp, _checker, __FILE__, __LINE__);
	BYTE tlbType; _parser.parseBYTE(tlbType);
	AtfValidator::validateInt(_descr, "tlbType", tlbType, _checker, __FILE__, __LINE__);
	SrvTime timeFrom; _parser.parseSrvTime(timeFrom);
	AtfValidator::validateSrvDateTime(_descr, "timeFrom", timeFrom, _checker, __FILE__, __LINE__);
	SrvTime timeTo; _parser.parseSrvTime(timeTo);
	AtfValidator::validateSrvDateTime(_descr, "timeTo", timeTo, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szLeaderPoints = Atf::LAtfVector< LeaderPoints, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("leaderPoints"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "leaderPoints", szLeaderPoints, _checker, __FILE__, __LINE__);
	UINT32 userPlace; _parser.parseUINT32(userPlace);
	AtfValidator::validateInt(_descr, "userPlace", userPlace, _checker, __FILE__, __LINE__);
	UINT32 userPoints; _parser.parseUINT32(userPoints);
	AtfValidator::validateInt(_descr, "userPoints", userPoints, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2(Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2&& _o)
	: notUsed(std::move(_o.notUsed))
	, tlbListType(std::move(_o.tlbListType))
	, uniqueIdStr(std::move(_o.uniqueIdStr))
{
}

Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2& Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2::operator=(Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2&& _o)
{
	if(this != &_o)
	{
		notUsed = std::move(_o.notUsed);
		tlbListType = std::move(_o.tlbListType);
		uniqueIdStr = std::move(_o.uniqueIdStr);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2::clear()
{
	notUsed.clear();
	tlbListType = 0;
	uniqueIdStr.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2::equals(const Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2& _o) const
{
	return Atf::atfPStringEquals(notUsed, _o.notUsed) &&
		tlbListType == _o.tlbListType &&
		Atf::atfPStringEquals(uniqueIdStr, _o.uniqueIdStr);
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_CLI_GET_TLB_STANDIDNS2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CLI_GET_TLB_STANDIDNS2).append(")");
	_buf.append(',');
	_buf.append("notUsed=");
	_buf.append(notUsed);
	_buf.append(',');
	_buf.append("tlbListType=");
	_buf.appendUint(tlbListType);
	_buf.append(',');
	_buf.append("uniqueIdStr=");
	_buf.append(uniqueIdStr);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_CLI_GET_TLB_STANDIDNS2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsed", notUsed, _buf);
	Atf::XmlElement::encodeAsXmlElement("tlbListType", tlbListType, _buf);
	Atf::XmlElement::encodeAsXmlElement("uniqueIdStr", uniqueIdStr, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsed"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsed)) return false;
			}
			else if (_element.equals("tlbListType"))
			{
				tlbListType = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("uniqueIdStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, uniqueIdStr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsed);
	_msg.composeBYTE(tlbListType);
	_msg.composeString(uniqueIdStr);
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsed);
	_parser.parseBYTE(tlbListType);
	_parser.parseStringP(uniqueIdStr);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsed", notUsed);
	_jsonstr.compose("tlbListType", tlbListType);
	_jsonstr.compose("uniqueIdStr", uniqueIdStr);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsed", notUsed);
	_jparser.parseByNameThrow("tlbListType", tlbListType);
	_jparser.parseByNameThrow("uniqueIdStr", uniqueIdStr);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLI_GET_TLB_STANDIDNS2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsed; _jparser.validateByNameThrow("notUsed", notUsed);
	AtfValidator::validateIntMax(_descr, "notUsed", notUsed.length(), 20, _checker, __FILE__, __LINE__);
	BYTE tlbListType; _jparser.validateByNameThrow("tlbListType", tlbListType);
	AtfValidator::validateIntRange(_descr, "tlbListType", tlbListType, eTlbYear, TlbStandingsListType_last, _checker, __FILE__, __LINE__);
	PString uniqueIdStr; _jparser.validateByNameThrow("uniqueIdStr", uniqueIdStr);
	AtfValidator::validateIntMax(_descr, "uniqueIdStr", uniqueIdStr.length(), 30, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLI_GET_TLB_STANDIDNS2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsed"); size_t szNotUsed = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsed", szNotUsed, 20, _checker, __FILE__, __LINE__);
	BYTE tlbListType; _parser.parseBYTE(tlbListType);
	AtfValidator::validateIntRange(_descr, "tlbListType", tlbListType, eTlbYear, TlbStandingsListType_last, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "uniqueIdStr"); size_t szUniqueIdStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "uniqueIdStr", szUniqueIdStr, 30, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY(Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, tableVector(std::move(_o.tableVector))
	, lastUpdated(std::move(_o.lastUpdated))
{
}

Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY& Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY::operator=(Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		tableVector = std::move(_o.tableVector);
		lastUpdated = std::move(_o.lastUpdated);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	tableVector.clear();
	lastUpdated.setNull();
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY::equals(const Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		tableVector.equals(_o.tableVector) &&
		lastUpdated.equals(_o.lastUpdated);
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("tableVector=");
		tableVector.toTraceString(_buf);
		_buf.append(',');
		_buf.append("lastUpdated=");
		Atf::AtfTempl<SrvTime>::ToTraceString(_buf, lastUpdated);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		tableVector.toXmlString("tableVector", _buf);
		Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "lastUpdated", lastUpdated);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("tableVector"))
			{
				if(!Atf::AtfTempl< TlbVector >::FromXmlString(_value, tableVector)) return false;
			}
			else if (_element.equals("lastUpdated"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, lastUpdated);
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		tableVector.composeMsg(_msg, _ignoreJSON);
		_msg.composeSrvTime(lastUpdated);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		tableVector.parseMsg(_parser);
		_parser.parseSrvTime(lastUpdated);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("tableVector", tableVector);
		_jsonstr.compose("lastUpdated", lastUpdated);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("tableVector", tableVector);
		_jparser.parseByNameThrow("lastUpdated", lastUpdated);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		TlbVector tableVector; _jparser.validateByNameThrow("tableVector", tableVector);
		SrvTime lastUpdated; _jparser.validateByNameThrow("lastUpdated", lastUpdated);
		AtfValidator::validateSrvDateTime(_descr, "lastUpdated", lastUpdated, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		TlbVector::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableVector"), _fieldsWithUnparsedContent);
		SrvTime lastUpdated; _parser.parseSrvTime(lastUpdated);
		AtfValidator::validateSrvDateTime(_descr, "lastUpdated", lastUpdated, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    PlayerTableData
//=================================================================

Lobby::cli::PlayerTableData::PlayerTableData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::PlayerTableData::PlayerTableData(PlayerTableData&& _o)
	: serverAddress(std::move(_o.serverAddress))
	, serverInstance(std::move(_o.serverInstance))
	, tableIdOld(std::move(_o.tableIdOld))
	, tableName(std::move(_o.tableName))
	, tableSpecialSuffix(std::move(_o.tableSpecialSuffix))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, loBet(std::move(_o.loBet))
	, hiBet(std::move(_o.hiBet))
	, game(std::move(_o.game))
	, structure(std::move(_o.structure))
	, isHiLo(std::move(_o.isHiLo))
	, currency(std::move(_o.currency))
	, scalePm(std::move(_o.scalePm))
	, tableId(std::move(_o.tableId))
	, maxPlayers(std::move(_o.maxPlayers))
{
}

Lobby::cli::PlayerTableData& Lobby::cli::PlayerTableData::operator=(PlayerTableData&& _o)
{
	if(this != &_o)
	{
		serverAddress = std::move(_o.serverAddress);
		serverInstance = std::move(_o.serverInstance);
		tableIdOld = std::move(_o.tableIdOld);
		tableName = std::move(_o.tableName);
		tableSpecialSuffix = std::move(_o.tableSpecialSuffix);
		isPlayMoney = std::move(_o.isPlayMoney);
		loBet = std::move(_o.loBet);
		hiBet = std::move(_o.hiBet);
		game = std::move(_o.game);
		structure = std::move(_o.structure);
		isHiLo = std::move(_o.isHiLo);
		currency = std::move(_o.currency);
		scalePm = std::move(_o.scalePm);
		tableId = std::move(_o.tableId);
		maxPlayers = std::move(_o.maxPlayers);
	}
	return *this;
}

#endif

void Lobby::cli::PlayerTableData::clear()
{
	serverAddress.clear();
	serverInstance.clear();
	tableIdOld = 0;
	tableName.clear();
	tableSpecialSuffix.clear();
	isPlayMoney = false;
	loBet = 0;
	hiBet = 0;
	game = 0;
	structure = 0;
	isHiLo = false;
	currency.clear();
	scalePm = 0;
	tableId = 0;
	maxPlayers = 0;
}

bool Lobby::cli::PlayerTableData::equals(const PlayerTableData& _o) const
{
	return Atf::atfPStringEquals(serverAddress, _o.serverAddress) &&
		Atf::atfPStringEquals(serverInstance, _o.serverInstance) &&
		tableIdOld == _o.tableIdOld &&
		Atf::atfPStringEquals(tableName, _o.tableName) &&
		Atf::atfPStringEquals(tableSpecialSuffix, _o.tableSpecialSuffix) &&
		isPlayMoney == _o.isPlayMoney &&
		loBet == _o.loBet &&
		hiBet == _o.hiBet &&
		game == _o.game &&
		structure == _o.structure &&
		isHiLo == _o.isHiLo &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		scalePm == _o.scalePm &&
		tableId == _o.tableId &&
		maxPlayers == _o.maxPlayers;
}

const char *Lobby::cli::PlayerTableData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("serverAddress=");
	_buf.append(serverAddress);
	_buf.append(',');
	_buf.append("serverInstance=");
	_buf.append(serverInstance);
	_buf.append(',');
	_buf.append("tableIdOld=");
	_buf.appendUint(tableIdOld);
	_buf.append(',');
	_buf.append("tableName=");
	_buf.append(tableName);
	_buf.append(',');
	_buf.append("tableSpecialSuffix=");
	_buf.append(tableSpecialSuffix);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("loBet=");
	_buf.appendUint(loBet);
	_buf.append(',');
	_buf.append("hiBet=");
	_buf.appendUint(hiBet);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("scalePm=");
	_buf.appendUint(scalePm);
	_buf.append(',');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendUint(maxPlayers);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::PlayerTableData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("serverAddress", serverAddress, _buf);
	Atf::XmlElement::encodeAsXmlElement("serverInstance", serverInstance, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableIdOld", tableIdOld, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableName", tableName, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableSpecialSuffix", tableSpecialSuffix, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("loBet", loBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("hiBet", hiBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("scalePm", scalePm, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableId", tableId, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPlayers", maxPlayers, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::PlayerTableData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("serverAddress"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, serverAddress)) return false;
		}
		else if (_element.equals("serverInstance"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, serverInstance)) return false;
		}
		else if (_element.equals("tableIdOld"))
		{
			tableIdOld = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, tableName)) return false;
		}
		else if (_element.equals("tableSpecialSuffix"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, tableSpecialSuffix)) return false;
		}
		else if (_element.equals("isPlayMoney"))
		{
			isPlayMoney = (*_value.ptr() == '1');
		}
		else if (_element.equals("loBet"))
		{
			loBet = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("hiBet"))
		{
			hiBet = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("game"))
		{
			game = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("structure"))
		{
			structure = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (*_value.ptr() == '1');
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("scalePm"))
		{
			scalePm = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableId"))
		{
			tableId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxPlayers"))
		{
			maxPlayers = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::PlayerTableData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(serverAddress);
	_msg.composeString(serverInstance);
	_msg.composeUINT32(tableIdOld);
	_msg.composeString(tableName);
	_msg.composeString(tableSpecialSuffix);
	_msg.composeBOOL(isPlayMoney);
	_msg.composeUINT32(loBet);
	_msg.composeUINT32(hiBet);
	_msg.composeBYTE(game);
	_msg.composeBYTE(structure);
	_msg.composeBOOL(isHiLo);
	_msg.composeString(currency);
	_msg.composeUINT32(scalePm);
	_msg.composeUINT64(tableId);
	_msg.composeBYTE(maxPlayers);
}

void Lobby::cli::PlayerTableData::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(serverAddress);
	_parser.parseStringP(serverInstance);
	_parser.parseUINT32(tableIdOld);
	_parser.parseStringP(tableName);
	_parser.parseStringP(tableSpecialSuffix);
	_parser.parseBOOL(isPlayMoney);
	_parser.parseUINT32(loBet);
	_parser.parseUINT32(hiBet);
	_parser.parseBYTE(game);
	_parser.parseBYTE(structure);
	_parser.parseBOOL(isHiLo);
	_parser.parseStringP(currency);
	_parser.parseUINT32(scalePm);
	_parser.parseUINT64(tableId);
	_parser.parseBYTE(maxPlayers);
}

const char *Lobby::cli::PlayerTableData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("serverAddress", serverAddress);
	_jsonstr.compose("serverInstance", serverInstance);
	_jsonstr.compose("tableIdOld", tableIdOld);
	_jsonstr.compose("tableName", tableName);
	_jsonstr.compose("tableSpecialSuffix", tableSpecialSuffix);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("loBet", loBet);
	_jsonstr.compose("hiBet", hiBet);
	_jsonstr.compose("game", game);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("scalePm", scalePm);
	_jsonstr.compose("tableId", tableId);
	_jsonstr.compose("maxPlayers", maxPlayers);
	return _buf.c_str();
}

void Lobby::cli::PlayerTableData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("serverAddress", serverAddress);
	_jparser.parseByNameThrow("serverInstance", serverInstance);
	_jparser.parseByNameThrow("tableIdOld", tableIdOld);
	_jparser.parseByNameThrow("tableName", tableName);
	_jparser.parseByNameThrow("tableSpecialSuffix", tableSpecialSuffix);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("loBet", loBet);
	_jparser.parseByNameThrow("hiBet", hiBet);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("scalePm", scalePm);
	_jparser.parseByNameThrow("tableId", tableId);
	_jparser.parseByNameThrow("maxPlayers", maxPlayers);
}

/* static */ void Lobby::cli::PlayerTableData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString serverAddress; _jparser.validateByNameThrow("serverAddress", serverAddress);
	AtfValidator::validateInt(_descr, "serverAddress", serverAddress.length(), _checker, __FILE__, __LINE__);
	PString serverInstance; _jparser.validateByNameThrow("serverInstance", serverInstance);
	AtfValidator::validateInt(_descr, "serverInstance", serverInstance.length(), _checker, __FILE__, __LINE__);
	UINT32 tableIdOld; _jparser.validateByNameThrow("tableIdOld", tableIdOld);
	AtfValidator::validateInt(_descr, "tableIdOld", tableIdOld, _checker, __FILE__, __LINE__);
	PString tableName; _jparser.validateByNameThrow("tableName", tableName);
	AtfValidator::validateInt(_descr, "tableName", tableName.length(), _checker, __FILE__, __LINE__);
	PString tableSpecialSuffix; _jparser.validateByNameThrow("tableSpecialSuffix", tableSpecialSuffix);
	AtfValidator::validateInt(_descr, "tableSpecialSuffix", tableSpecialSuffix.length(), _checker, __FILE__, __LINE__);
	bool isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 loBet; _jparser.validateByNameThrow("loBet", loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	UINT32 hiBet; _jparser.validateByNameThrow("hiBet", hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	bool isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	UINT32 scalePm; _jparser.validateByNameThrow("scalePm", scalePm);
	AtfValidator::validateInt(_descr, "scalePm", scalePm, _checker, __FILE__, __LINE__);
	UINT64 tableId; _jparser.validateByNameThrow("tableId", tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	BYTE maxPlayers; _jparser.validateByNameThrow("maxPlayers", maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::PlayerTableData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "serverAddress"); size_t szServerAddress = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverAddress", szServerAddress, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "serverInstance"); size_t szServerInstance = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverInstance", szServerInstance, _checker, __FILE__, __LINE__);
	UINT32 tableIdOld; _parser.parseUINT32(tableIdOld);
	AtfValidator::validateInt(_descr, "tableIdOld", tableIdOld, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "tableName"); size_t szTableName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tableName", szTableName, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "tableSpecialSuffix"); size_t szTableSpecialSuffix = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tableSpecialSuffix", szTableSpecialSuffix, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 loBet; _parser.parseUINT32(loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	UINT32 hiBet; _parser.parseUINT32(hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	bool isHiLo; _parser.parseBOOL(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 scalePm; _parser.parseUINT32(scalePm);
	AtfValidator::validateInt(_descr, "scalePm", scalePm, _checker, __FILE__, __LINE__);
	UINT64 tableId; _parser.parseUINT64(tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	BYTE maxPlayers; _parser.parseBYTE(maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    PlayerTournData
//=================================================================

Lobby::cli::PlayerTournData::PlayerTournData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::PlayerTournData::PlayerTournData(PlayerTournData&& _o)
	: serverAddress(std::move(_o.serverAddress))
	, tournId(std::move(_o.tournId))
	, isSitAndGo(std::move(_o.isSitAndGo))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, buyIn(std::move(_o.buyIn))
	, rake(std::move(_o.rake))
	, fppBuyIn(std::move(_o.fppBuyIn))
	, game(std::move(_o.game))
	, structure(std::move(_o.structure))
	, isHiLo(std::move(_o.isHiLo))
	, status(std::move(_o.status))
	, currency(std::move(_o.currency))
	, scalePm(std::move(_o.scalePm))
	, needAdmission(std::move(_o.needAdmission))
	, admissionPrice(std::move(_o.admissionPrice))
	, isPrivate(std::move(_o.isPrivate))
{
}

Lobby::cli::PlayerTournData& Lobby::cli::PlayerTournData::operator=(PlayerTournData&& _o)
{
	if(this != &_o)
	{
		serverAddress = std::move(_o.serverAddress);
		tournId = std::move(_o.tournId);
		isSitAndGo = std::move(_o.isSitAndGo);
		isPlayMoney = std::move(_o.isPlayMoney);
		buyIn = std::move(_o.buyIn);
		rake = std::move(_o.rake);
		fppBuyIn = std::move(_o.fppBuyIn);
		game = std::move(_o.game);
		structure = std::move(_o.structure);
		isHiLo = std::move(_o.isHiLo);
		status = std::move(_o.status);
		currency = std::move(_o.currency);
		scalePm = std::move(_o.scalePm);
		needAdmission = std::move(_o.needAdmission);
		admissionPrice = std::move(_o.admissionPrice);
		isPrivate = std::move(_o.isPrivate);
	}
	return *this;
}

#endif

void Lobby::cli::PlayerTournData::clear()
{
	serverAddress.clear();
	tournId = 0;
	isSitAndGo = false;
	isPlayMoney = false;
	buyIn = 0;
	rake = 0;
	fppBuyIn = 0;
	game = 0;
	structure = 0;
	isHiLo = false;
	status = 0;
	currency.clear();
	scalePm = 0;
	needAdmission = false;
	admissionPrice = 0;
	isPrivate = false;
}

bool Lobby::cli::PlayerTournData::equals(const PlayerTournData& _o) const
{
	return Atf::atfPStringEquals(serverAddress, _o.serverAddress) &&
		tournId == _o.tournId &&
		isSitAndGo == _o.isSitAndGo &&
		isPlayMoney == _o.isPlayMoney &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		fppBuyIn == _o.fppBuyIn &&
		game == _o.game &&
		structure == _o.structure &&
		isHiLo == _o.isHiLo &&
		status == _o.status &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		scalePm == _o.scalePm &&
		needAdmission == _o.needAdmission &&
		admissionPrice == _o.admissionPrice &&
		isPrivate == _o.isPrivate;
}

const char *Lobby::cli::PlayerTournData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("serverAddress=");
	_buf.append(serverAddress);
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("isSitAndGo=");
	_buf.appendUint(isSitAndGo);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendUint(buyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendUint(rake);
	_buf.append(',');
	_buf.append("fppBuyIn=");
	_buf.appendUint(fppBuyIn);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("status=");
	_buf.appendUint(status);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("scalePm=");
	_buf.appendUint(scalePm);
	_buf.append(',');
	_buf.append("needAdmission=");
	_buf.appendUint(needAdmission);
	_buf.append(',');
	_buf.append("admissionPrice=");
	_buf.appendInt64(admissionPrice);
	_buf.append(',');
	_buf.append("isPrivate=");
	_buf.appendUint(isPrivate);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::PlayerTournData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("serverAddress", serverAddress, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
	Atf::XmlElement::encodeAsXmlElement("isSitAndGo", isSitAndGo, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyIn", buyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("rake", rake, _buf);
	Atf::XmlElement::encodeAsXmlElement("fppBuyIn", fppBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("scalePm", scalePm, _buf);
	Atf::XmlElement::encodeAsXmlElement("needAdmission", needAdmission, _buf);
	Atf::XmlElement::encodeAsXmlElement("admissionPrice", admissionPrice, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPrivate", isPrivate, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::PlayerTournData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("serverAddress"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, serverAddress)) return false;
		}
		else if (_element.equals("tournId"))
		{
			tournId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isSitAndGo"))
		{
			isSitAndGo = (*_value.ptr() == '1');
		}
		else if (_element.equals("isPlayMoney"))
		{
			isPlayMoney = (*_value.ptr() == '1');
		}
		else if (_element.equals("buyIn"))
		{
			buyIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rake"))
		{
			rake = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("fppBuyIn"))
		{
			fppBuyIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("game"))
		{
			game = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("structure"))
		{
			structure = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (*_value.ptr() == '1');
		}
		else if (_element.equals("status"))
		{
			status = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("scalePm"))
		{
			scalePm = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("needAdmission"))
		{
			needAdmission = (*_value.ptr() == '1');
		}
		else if (_element.equals("admissionPrice"))
		{
			admissionPrice = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isPrivate"))
		{
			isPrivate = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::PlayerTournData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(serverAddress);
	_msg.composeUINT32(tournId);
	_msg.composeBOOL(isSitAndGo);
	_msg.composeBOOL(isPlayMoney);
	_msg.composeUINT32(buyIn);
	_msg.composeUINT32(rake);
	_msg.composeUINT32(fppBuyIn);
	_msg.composeBYTE(game);
	_msg.composeBYTE(structure);
	_msg.composeBOOL(isHiLo);
	_msg.composeUINT32(status);
	_msg.composeString(currency);
	_msg.composeUINT32(scalePm);
	_msg.composeBOOL(needAdmission);
	_msg.composeINT64(admissionPrice);
	_msg.composeBOOL(isPrivate);
}

void Lobby::cli::PlayerTournData::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(serverAddress);
	_parser.parseUINT32(tournId);
	_parser.parseBOOL(isSitAndGo);
	_parser.parseBOOL(isPlayMoney);
	_parser.parseUINT32(buyIn);
	_parser.parseUINT32(rake);
	_parser.parseUINT32(fppBuyIn);
	_parser.parseBYTE(game);
	_parser.parseBYTE(structure);
	_parser.parseBOOL(isHiLo);
	_parser.parseUINT32(status);
	_parser.parseStringP(currency);
	_parser.parseUINT32(scalePm);
	_parser.parseBOOL(needAdmission);
	_parser.parseINT64(admissionPrice);
	_parser.parseBOOL(isPrivate);
}

const char *Lobby::cli::PlayerTournData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("serverAddress", serverAddress);
	_jsonstr.compose("tournId", tournId);
	_jsonstr.compose("isSitAndGo", isSitAndGo);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("buyIn", buyIn);
	_jsonstr.compose("rake", rake);
	_jsonstr.compose("fppBuyIn", fppBuyIn);
	_jsonstr.compose("game", game);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("status", status);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("scalePm", scalePm);
	_jsonstr.compose("needAdmission", needAdmission);
	_jsonstr.compose("admissionPrice", admissionPrice);
	_jsonstr.compose("isPrivate", isPrivate);
	return _buf.c_str();
}

void Lobby::cli::PlayerTournData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("serverAddress", serverAddress);
	_jparser.parseByNameThrow("tournId", tournId);
	_jparser.parseByNameThrow("isSitAndGo", isSitAndGo);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("buyIn", buyIn);
	_jparser.parseByNameThrow("rake", rake);
	_jparser.parseByNameThrow("fppBuyIn", fppBuyIn);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("status", status);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("scalePm", scalePm);
	_jparser.parseByNameThrow("needAdmission", needAdmission);
	_jparser.parseByNameThrow("admissionPrice", admissionPrice);
	_jparser.parseByNameThrow("isPrivate", isPrivate);
}

/* static */ void Lobby::cli::PlayerTournData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString serverAddress; _jparser.validateByNameThrow("serverAddress", serverAddress);
	AtfValidator::validateInt(_descr, "serverAddress", serverAddress.length(), _checker, __FILE__, __LINE__);
	UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	bool isSitAndGo; _jparser.validateByNameThrow("isSitAndGo", isSitAndGo);
	AtfValidator::validateInt(_descr, "isSitAndGo", isSitAndGo, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 buyIn; _jparser.validateByNameThrow("buyIn", buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT32 rake; _jparser.validateByNameThrow("rake", rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	UINT32 fppBuyIn; _jparser.validateByNameThrow("fppBuyIn", fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	bool isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	UINT32 status; _jparser.validateByNameThrow("status", status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	UINT32 scalePm; _jparser.validateByNameThrow("scalePm", scalePm);
	AtfValidator::validateInt(_descr, "scalePm", scalePm, _checker, __FILE__, __LINE__);
	bool needAdmission; _jparser.validateByNameThrow("needAdmission", needAdmission);
	AtfValidator::validateInt(_descr, "needAdmission", needAdmission, _checker, __FILE__, __LINE__);
	INT64 admissionPrice; _jparser.validateByNameThrow("admissionPrice", admissionPrice);
	AtfValidator::validateInt(_descr, "admissionPrice", admissionPrice, _checker, __FILE__, __LINE__);
	bool isPrivate; _jparser.validateByNameThrow("isPrivate", isPrivate);
	AtfValidator::validateInt(_descr, "isPrivate", isPrivate, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::PlayerTournData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "serverAddress"); size_t szServerAddress = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverAddress", szServerAddress, _checker, __FILE__, __LINE__);
	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	bool isSitAndGo; _parser.parseBOOL(isSitAndGo);
	AtfValidator::validateInt(_descr, "isSitAndGo", isSitAndGo, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 buyIn; _parser.parseUINT32(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT32 rake; _parser.parseUINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	UINT32 fppBuyIn; _parser.parseUINT32(fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	bool isHiLo; _parser.parseBOOL(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	UINT32 status; _parser.parseUINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 scalePm; _parser.parseUINT32(scalePm);
	AtfValidator::validateInt(_descr, "scalePm", scalePm, _checker, __FILE__, __LINE__);
	bool needAdmission; _parser.parseBOOL(needAdmission);
	AtfValidator::validateInt(_descr, "needAdmission", needAdmission, _checker, __FILE__, __LINE__);
	INT64 admissionPrice; _parser.parseINT64(admissionPrice);
	AtfValidator::validateInt(_descr, "admissionPrice", admissionPrice, _checker, __FILE__, __LINE__);
	bool isPrivate; _parser.parseBOOL(isPrivate);
	AtfValidator::validateInt(_descr, "isPrivate", isPrivate, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    PlayerBlitzData
//=================================================================

Lobby::cli::PlayerBlitzData::PlayerBlitzData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::PlayerBlitzData::PlayerBlitzData(PlayerBlitzData&& _o)
	: serverAddress(std::move(_o.serverAddress))
	, serverInstance(std::move(_o.serverInstance))
	, blitzId(std::move(_o.blitzId))
	, blitzName(std::move(_o.blitzName))
	, blitzSpecialSuffix(std::move(_o.blitzSpecialSuffix))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, loBet(std::move(_o.loBet))
	, hiBet(std::move(_o.hiBet))
	, game(std::move(_o.game))
	, structure(std::move(_o.structure))
	, isHiLo(std::move(_o.isHiLo))
	, currency(std::move(_o.currency))
	, scalePm(std::move(_o.scalePm))
{
}

Lobby::cli::PlayerBlitzData& Lobby::cli::PlayerBlitzData::operator=(PlayerBlitzData&& _o)
{
	if(this != &_o)
	{
		serverAddress = std::move(_o.serverAddress);
		serverInstance = std::move(_o.serverInstance);
		blitzId = std::move(_o.blitzId);
		blitzName = std::move(_o.blitzName);
		blitzSpecialSuffix = std::move(_o.blitzSpecialSuffix);
		isPlayMoney = std::move(_o.isPlayMoney);
		loBet = std::move(_o.loBet);
		hiBet = std::move(_o.hiBet);
		game = std::move(_o.game);
		structure = std::move(_o.structure);
		isHiLo = std::move(_o.isHiLo);
		currency = std::move(_o.currency);
		scalePm = std::move(_o.scalePm);
	}
	return *this;
}

#endif

void Lobby::cli::PlayerBlitzData::clear()
{
	serverAddress.clear();
	serverInstance.clear();
	blitzId = 0;
	blitzName.clear();
	blitzSpecialSuffix.clear();
	isPlayMoney = false;
	loBet = 0;
	hiBet = 0;
	game = 0;
	structure = 0;
	isHiLo = false;
	currency.clear();
	scalePm = 0;
}

bool Lobby::cli::PlayerBlitzData::equals(const PlayerBlitzData& _o) const
{
	return Atf::atfPStringEquals(serverAddress, _o.serverAddress) &&
		Atf::atfPStringEquals(serverInstance, _o.serverInstance) &&
		blitzId == _o.blitzId &&
		Atf::atfPStringEquals(blitzName, _o.blitzName) &&
		Atf::atfPStringEquals(blitzSpecialSuffix, _o.blitzSpecialSuffix) &&
		isPlayMoney == _o.isPlayMoney &&
		loBet == _o.loBet &&
		hiBet == _o.hiBet &&
		game == _o.game &&
		structure == _o.structure &&
		isHiLo == _o.isHiLo &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		scalePm == _o.scalePm;
}

const char *Lobby::cli::PlayerBlitzData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("serverAddress=");
	_buf.append(serverAddress);
	_buf.append(',');
	_buf.append("serverInstance=");
	_buf.append(serverInstance);
	_buf.append(',');
	_buf.append("blitzId=");
	_buf.appendUint(blitzId);
	_buf.append(',');
	_buf.append("blitzName=");
	_buf.append(blitzName);
	_buf.append(',');
	_buf.append("blitzSpecialSuffix=");
	_buf.append(blitzSpecialSuffix);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("loBet=");
	_buf.appendUint(loBet);
	_buf.append(',');
	_buf.append("hiBet=");
	_buf.appendUint(hiBet);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("scalePm=");
	_buf.appendUint(scalePm);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::PlayerBlitzData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("serverAddress", serverAddress, _buf);
	Atf::XmlElement::encodeAsXmlElement("serverInstance", serverInstance, _buf);
	Atf::XmlElement::encodeAsXmlElement("blitzId", blitzId, _buf);
	Atf::XmlElement::encodeAsXmlElement("blitzName", blitzName, _buf);
	Atf::XmlElement::encodeAsXmlElement("blitzSpecialSuffix", blitzSpecialSuffix, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("loBet", loBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("hiBet", hiBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("scalePm", scalePm, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::PlayerBlitzData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("serverAddress"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, serverAddress)) return false;
		}
		else if (_element.equals("serverInstance"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, serverInstance)) return false;
		}
		else if (_element.equals("blitzId"))
		{
			blitzId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("blitzName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, blitzName)) return false;
		}
		else if (_element.equals("blitzSpecialSuffix"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, blitzSpecialSuffix)) return false;
		}
		else if (_element.equals("isPlayMoney"))
		{
			isPlayMoney = (*_value.ptr() == '1');
		}
		else if (_element.equals("loBet"))
		{
			loBet = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("hiBet"))
		{
			hiBet = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("game"))
		{
			game = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("structure"))
		{
			structure = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (*_value.ptr() == '1');
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("scalePm"))
		{
			scalePm = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::PlayerBlitzData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(serverAddress);
	_msg.composeString(serverInstance);
	_msg.composeUINT32(blitzId);
	_msg.composeString(blitzName);
	_msg.composeString(blitzSpecialSuffix);
	_msg.composeBOOL(isPlayMoney);
	_msg.composeUINT32(loBet);
	_msg.composeUINT32(hiBet);
	_msg.composeBYTE(game);
	_msg.composeBYTE(structure);
	_msg.composeBOOL(isHiLo);
	_msg.composeString(currency);
	_msg.composeUINT32(scalePm);
}

void Lobby::cli::PlayerBlitzData::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(serverAddress);
	_parser.parseStringP(serverInstance);
	_parser.parseUINT32(blitzId);
	_parser.parseStringP(blitzName);
	_parser.parseStringP(blitzSpecialSuffix);
	_parser.parseBOOL(isPlayMoney);
	_parser.parseUINT32(loBet);
	_parser.parseUINT32(hiBet);
	_parser.parseBYTE(game);
	_parser.parseBYTE(structure);
	_parser.parseBOOL(isHiLo);
	_parser.parseStringP(currency);
	_parser.parseUINT32(scalePm);
}

const char *Lobby::cli::PlayerBlitzData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("serverAddress", serverAddress);
	_jsonstr.compose("serverInstance", serverInstance);
	_jsonstr.compose("blitzId", blitzId);
	_jsonstr.compose("blitzName", blitzName);
	_jsonstr.compose("blitzSpecialSuffix", blitzSpecialSuffix);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("loBet", loBet);
	_jsonstr.compose("hiBet", hiBet);
	_jsonstr.compose("game", game);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("scalePm", scalePm);
	return _buf.c_str();
}

void Lobby::cli::PlayerBlitzData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("serverAddress", serverAddress);
	_jparser.parseByNameThrow("serverInstance", serverInstance);
	_jparser.parseByNameThrow("blitzId", blitzId);
	_jparser.parseByNameThrow("blitzName", blitzName);
	_jparser.parseByNameThrow("blitzSpecialSuffix", blitzSpecialSuffix);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("loBet", loBet);
	_jparser.parseByNameThrow("hiBet", hiBet);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("scalePm", scalePm);
}

/* static */ void Lobby::cli::PlayerBlitzData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString serverAddress; _jparser.validateByNameThrow("serverAddress", serverAddress);
	AtfValidator::validateInt(_descr, "serverAddress", serverAddress.length(), _checker, __FILE__, __LINE__);
	PString serverInstance; _jparser.validateByNameThrow("serverInstance", serverInstance);
	AtfValidator::validateInt(_descr, "serverInstance", serverInstance.length(), _checker, __FILE__, __LINE__);
	UINT32 blitzId; _jparser.validateByNameThrow("blitzId", blitzId);
	AtfValidator::validateInt(_descr, "blitzId", blitzId, _checker, __FILE__, __LINE__);
	PString blitzName; _jparser.validateByNameThrow("blitzName", blitzName);
	AtfValidator::validateInt(_descr, "blitzName", blitzName.length(), _checker, __FILE__, __LINE__);
	PString blitzSpecialSuffix; _jparser.validateByNameThrow("blitzSpecialSuffix", blitzSpecialSuffix);
	AtfValidator::validateInt(_descr, "blitzSpecialSuffix", blitzSpecialSuffix.length(), _checker, __FILE__, __LINE__);
	bool isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 loBet; _jparser.validateByNameThrow("loBet", loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	UINT32 hiBet; _jparser.validateByNameThrow("hiBet", hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	bool isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	UINT32 scalePm; _jparser.validateByNameThrow("scalePm", scalePm);
	AtfValidator::validateInt(_descr, "scalePm", scalePm, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::PlayerBlitzData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "serverAddress"); size_t szServerAddress = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverAddress", szServerAddress, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "serverInstance"); size_t szServerInstance = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverInstance", szServerInstance, _checker, __FILE__, __LINE__);
	UINT32 blitzId; _parser.parseUINT32(blitzId);
	AtfValidator::validateInt(_descr, "blitzId", blitzId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "blitzName"); size_t szBlitzName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "blitzName", szBlitzName, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "blitzSpecialSuffix"); size_t szBlitzSpecialSuffix = strlen(_dummy);
	AtfValidator::validateInt(_descr, "blitzSpecialSuffix", szBlitzSpecialSuffix, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 loBet; _parser.parseUINT32(loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	UINT32 hiBet; _parser.parseUINT32(hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	bool isHiLo; _parser.parseBOOL(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 scalePm; _parser.parseUINT32(scalePm);
	AtfValidator::validateInt(_descr, "scalePm", scalePm, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_PLAYER2
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2::Protocol_MSG_LOBBY_FIND_PLAYER2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2::Protocol_MSG_LOBBY_FIND_PLAYER2(Protocol_MSG_LOBBY_FIND_PLAYER2&& _o)
	: notUsed(std::move(_o.notUsed))
	, playerName(std::move(_o.playerName))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2& Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2::operator=(Protocol_MSG_LOBBY_FIND_PLAYER2&& _o)
{
	if(this != &_o)
	{
		notUsed = std::move(_o.notUsed);
		playerName = std::move(_o.playerName);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2::clear()
{
	notUsed.clear();
	playerName.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2::equals(const Protocol_MSG_LOBBY_FIND_PLAYER2& _o) const
{
	return Atf::atfPStringEquals(notUsed, _o.notUsed) &&
		Atf::atfPStringEquals(playerName, _o.playerName);
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_FIND_PLAYER2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_FIND_PLAYER2*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_PLAYER2).append(")");
	_buf.append(',');
	_buf.append("notUsed=");
	_buf.append(notUsed);
	_buf.append(',');
	_buf.append("playerName=");
	_buf.append(playerName);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_FIND_PLAYER2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsed", notUsed, _buf);
	Atf::XmlElement::encodeAsXmlElement("playerName", playerName, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsed"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsed)) return false;
			}
			else if (_element.equals("playerName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, playerName)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsed);
	_msg.composeString(playerName);
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsed);
	_parser.parseStringP(playerName);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsed", notUsed);
	_jsonstr.compose("playerName", playerName);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsed", notUsed);
	_jparser.parseByNameThrow("playerName", playerName);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_PLAYER2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsed; _jparser.validateByNameThrow("notUsed", notUsed);
	AtfValidator::validateIntMax(_descr, "notUsed", notUsed.length(), 20, _checker, __FILE__, __LINE__);
	PString playerName; _jparser.validateByNameThrow("playerName", playerName);
	AtfValidator::validateIntMax(_descr, "playerName", playerName.length(), 20, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_PLAYER2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsed"); size_t szNotUsed = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsed", szNotUsed, 20, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "playerName"); size_t szPlayerName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "playerName", szPlayerName, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY::Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY::Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY(Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY&& _o)
	: playerName(std::move(_o.playerName))
	, playerTables(std::move(_o.playerTables))
	, playerTourns(std::move(_o.playerTourns))
	, playerBlitz(std::move(_o.playerBlitz))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY& Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY::operator=(Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY&& _o)
{
	if(this != &_o)
	{
		playerName = std::move(_o.playerName);
		playerTables = std::move(_o.playerTables);
		playerTourns = std::move(_o.playerTourns);
		playerBlitz = std::move(_o.playerBlitz);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY::clear()
{
	playerName.clear();
	playerTables.clear();
	playerTourns.clear();
	playerBlitz.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY::equals(const Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY& _o) const
{
	return Atf::atfPStringEquals(playerName, _o.playerName) &&
		playerTables.equals(_o.playerTables) &&
		playerTourns.equals(_o.playerTourns) &&
		playerBlitz.equals(_o.playerBlitz);
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_FIND_PLAYER2_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_PLAYER2_REPLY).append(")");
	_buf.append(',');
	_buf.append("playerName=");
	_buf.append(playerName);
	_buf.append(',');
	_buf.append("playerTables=");
	playerTables.toTraceString(_buf);
	_buf.append(',');
	_buf.append("playerTourns=");
	playerTourns.toTraceString(_buf);
	_buf.append(',');
	_buf.append("playerBlitz=");
	playerBlitz.toTraceString(_buf);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_FIND_PLAYER2_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("playerName", playerName, _buf);
	playerTables.toXmlString("playerTables", _buf);
	playerTourns.toXmlString("playerTourns", _buf);
	playerBlitz.toXmlString("playerBlitz", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("playerName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, playerName)) return false;
			}
			else if (_element.equals("playerTables"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< PlayerTableData, 4 > >::FromXmlString(_value, playerTables)) return false;
			}
			else if (_element.equals("playerTourns"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< PlayerTournData, 4 > >::FromXmlString(_value, playerTourns)) return false;
			}
			else if (_element.equals("playerBlitz"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< PlayerBlitzData, 4 > >::FromXmlString(_value, playerBlitz)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(playerName);
	playerTables.composeMsg(_msg, _ignoreJSON);
	playerTourns.composeMsg(_msg, _ignoreJSON);
	playerBlitz.composeMsg(_msg, _ignoreJSON);
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(playerName);
	playerTables.parseMsg(_parser);
	playerTourns.parseMsg(_parser);
	playerBlitz.parseMsg(_parser);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("playerName", playerName);
	_jsonstr.compose("playerTables", playerTables);
	_jsonstr.compose("playerTourns", playerTourns);
	_jsonstr.compose("playerBlitz", playerBlitz);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("playerName", playerName);
	_jparser.parseByNameThrow("playerTables", playerTables);
	_jparser.parseByNameThrow("playerTourns", playerTourns);
	_jparser.parseByNameThrow("playerBlitz", playerBlitz);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_PLAYER2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString playerName; _jparser.validateByNameThrow("playerName", playerName);
	AtfValidator::validateInt(_descr, "playerName", playerName.length(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PlayerTableData > playerTables; _jparser.validateByNameThrow("playerTables", playerTables);
	AtfValidator::validateInt(_descr, "playerTables", playerTables.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PlayerTournData > playerTourns; _jparser.validateByNameThrow("playerTourns", playerTourns);
	AtfValidator::validateInt(_descr, "playerTourns", playerTourns.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PlayerBlitzData > playerBlitz; _jparser.validateByNameThrow("playerBlitz", playerBlitz);
	AtfValidator::validateInt(_descr, "playerBlitz", playerBlitz.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_PLAYER2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "playerName"); size_t szPlayerName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "playerName", szPlayerName, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szPlayerTables = Atf::LAtfVector< PlayerTableData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("playerTables"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "playerTables", szPlayerTables, _checker, __FILE__, __LINE__);
	int szPlayerTourns = Atf::LAtfVector< PlayerTournData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("playerTourns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "playerTourns", szPlayerTourns, _checker, __FILE__, __LINE__);
	int szPlayerBlitz = Atf::LAtfVector< PlayerBlitzData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("playerBlitz"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "playerBlitz", szPlayerBlitz, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_PLAYER3
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3::Protocol_MSG_LOBBY_FIND_PLAYER3()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3::Protocol_MSG_LOBBY_FIND_PLAYER3(Protocol_MSG_LOBBY_FIND_PLAYER3&& _o)
	: playerName(std::move(_o.playerName))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3& Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3::operator=(Protocol_MSG_LOBBY_FIND_PLAYER3&& _o)
{
	if(this != &_o)
	{
		playerName = std::move(_o.playerName);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3::clear()
{
	playerName.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3::equals(const Protocol_MSG_LOBBY_FIND_PLAYER3& _o) const
{
	return Atf::atfPStringEquals(playerName, _o.playerName);
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_FIND_PLAYER3 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_FIND_PLAYER3*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_PLAYER3).append(")");
	_buf.append(',');
	_buf.append("playerName=");
	_buf.append(playerName);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_FIND_PLAYER3).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("playerName", playerName, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("playerName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, playerName)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(playerName);
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(playerName);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("playerName", playerName);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("playerName", playerName);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_PLAYER3";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString playerName; _jparser.validateByNameThrow("playerName", playerName);
	AtfValidator::validateIntMax(_descr, "playerName", playerName.length(), 1000, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_PLAYER3";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "playerName"); size_t szPlayerName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "playerName", szPlayerName, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY::Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY::Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY(Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, playerName(std::move(_o.playerName))
	, playerTables(std::move(_o.playerTables))
	, playerTourns(std::move(_o.playerTourns))
	, playerBlitz(std::move(_o.playerBlitz))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY& Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY::operator=(Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		playerName = std::move(_o.playerName);
		playerTables = std::move(_o.playerTables);
		playerTourns = std::move(_o.playerTourns);
		playerBlitz = std::move(_o.playerBlitz);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	playerName.clear();
	playerTables.clear();
	playerTourns.clear();
	playerBlitz.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY::equals(const Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(playerName, _o.playerName) &&
		playerTables.equals(_o.playerTables) &&
		playerTourns.equals(_o.playerTourns) &&
		playerBlitz.equals(_o.playerBlitz);
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_FIND_PLAYER3_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_PLAYER3_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("playerName=");
		_buf.append(playerName);
		_buf.append(',');
		_buf.append("playerTables=");
		playerTables.toTraceString(_buf);
		_buf.append(',');
		_buf.append("playerTourns=");
		playerTourns.toTraceString(_buf);
		_buf.append(',');
		_buf.append("playerBlitz=");
		playerBlitz.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_FIND_PLAYER3_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("playerName", playerName, _buf);
		playerTables.toXmlString("playerTables", _buf);
		playerTourns.toXmlString("playerTourns", _buf);
		playerBlitz.toXmlString("playerBlitz", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("playerName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, playerName)) return false;
			}
			else if (_element.equals("playerTables"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< PlayerTableData, 4 > >::FromXmlString(_value, playerTables)) return false;
			}
			else if (_element.equals("playerTourns"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< PlayerTournData, 4 > >::FromXmlString(_value, playerTourns)) return false;
			}
			else if (_element.equals("playerBlitz"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< PlayerBlitzData, 4 > >::FromXmlString(_value, playerBlitz)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(playerName);
		playerTables.composeMsg(_msg, _ignoreJSON);
		playerTourns.composeMsg(_msg, _ignoreJSON);
		playerBlitz.composeMsg(_msg, _ignoreJSON);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(playerName);
		playerTables.parseMsg(_parser);
		playerTourns.parseMsg(_parser);
		playerBlitz.parseMsg(_parser);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("playerName", playerName);
		_jsonstr.compose("playerTables", playerTables);
		_jsonstr.compose("playerTourns", playerTourns);
		_jsonstr.compose("playerBlitz", playerBlitz);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("playerName", playerName);
		_jparser.parseByNameThrow("playerTables", playerTables);
		_jparser.parseByNameThrow("playerTourns", playerTourns);
		_jparser.parseByNameThrow("playerBlitz", playerBlitz);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_PLAYER3_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString playerName; _jparser.validateByNameThrow("playerName", playerName);
		AtfValidator::validateInt(_descr, "playerName", playerName.length(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< PlayerTableData > playerTables; _jparser.validateByNameThrow("playerTables", playerTables);
		AtfValidator::validateInt(_descr, "playerTables", playerTables.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< PlayerTournData > playerTourns; _jparser.validateByNameThrow("playerTourns", playerTourns);
		AtfValidator::validateInt(_descr, "playerTourns", playerTourns.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< PlayerBlitzData > playerBlitz; _jparser.validateByNameThrow("playerBlitz", playerBlitz);
		AtfValidator::validateInt(_descr, "playerBlitz", playerBlitz.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_PLAYER3_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "playerName"); size_t szPlayerName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "playerName", szPlayerName, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szPlayerTables = Atf::LAtfVector< PlayerTableData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("playerTables"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "playerTables", szPlayerTables, _checker, __FILE__, __LINE__);
		int szPlayerTourns = Atf::LAtfVector< PlayerTournData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("playerTourns"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "playerTourns", szPlayerTourns, _checker, __FILE__, __LINE__);
		int szPlayerBlitz = Atf::LAtfVector< PlayerBlitzData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("playerBlitz"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "playerBlitz", szPlayerBlitz, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_WEB_FIND_PLAYER2
//=================================================================

Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2::Protocol_MSG_WEB_FIND_PLAYER2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2::Protocol_MSG_WEB_FIND_PLAYER2(Protocol_MSG_WEB_FIND_PLAYER2&& _o)
	: notUsed(std::move(_o.notUsed))
	, playerName(std::move(_o.playerName))
{
}

Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2& Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2::operator=(Protocol_MSG_WEB_FIND_PLAYER2&& _o)
{
	if(this != &_o)
	{
		notUsed = std::move(_o.notUsed);
		playerName = std::move(_o.playerName);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2::clear()
{
	notUsed.clear();
	playerName.clear();
}

bool Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2::equals(const Protocol_MSG_WEB_FIND_PLAYER2& _o) const
{
	return Atf::atfPStringEquals(notUsed, _o.notUsed) &&
		Atf::atfPStringEquals(playerName, _o.playerName);
}

bool Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_WEB_FIND_PLAYER2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_WEB_FIND_PLAYER2*)_other));
}

const char *Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_WEB_FIND_PLAYER2).append(")");
	_buf.append(',');
	_buf.append("notUsed=");
	_buf.append(notUsed);
	_buf.append(',');
	_buf.append("playerName=");
	_buf.append(playerName);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_WEB_FIND_PLAYER2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsed", notUsed, _buf);
	Atf::XmlElement::encodeAsXmlElement("playerName", playerName, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsed"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsed)) return false;
			}
			else if (_element.equals("playerName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, playerName)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsed);
	_msg.composeString(playerName);
}

void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsed);
	_parser.parseStringP(playerName);
}

const char *Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsed", notUsed);
	_jsonstr.compose("playerName", playerName);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsed", notUsed);
	_jparser.parseByNameThrow("playerName", playerName);
}

/*static*/ void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_WEB_FIND_PLAYER2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsed; _jparser.validateByNameThrow("notUsed", notUsed);
	AtfValidator::validateIntMax(_descr, "notUsed", notUsed.length(), 20, _checker, __FILE__, __LINE__);
	PString playerName; _jparser.validateByNameThrow("playerName", playerName);
	AtfValidator::validateIntMax(_descr, "playerName", playerName.length(), 20, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_WEB_FIND_PLAYER2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsed"); size_t szNotUsed = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsed", szNotUsed, 20, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "playerName"); size_t szPlayerName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "playerName", szPlayerName, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_WEB_FIND_PLAYER2_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2_REPLY::Protocol_MSG_WEB_FIND_PLAYER2_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2_REPLY::Protocol_MSG_WEB_FIND_PLAYER2_REPLY(Protocol_MSG_WEB_FIND_PLAYER2_REPLY&& _o)
	: playerName(std::move(_o.playerName))
	, playerTables(std::move(_o.playerTables))
	, playerTourns(std::move(_o.playerTourns))
	, playerBlitz(std::move(_o.playerBlitz))
{
}

Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2_REPLY& Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2_REPLY::operator=(Protocol_MSG_WEB_FIND_PLAYER2_REPLY&& _o)
{
	if(this != &_o)
	{
		playerName = std::move(_o.playerName);
		playerTables = std::move(_o.playerTables);
		playerTourns = std::move(_o.playerTourns);
		playerBlitz = std::move(_o.playerBlitz);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2_REPLY::clear()
{
	playerName.clear();
	playerTables.clear();
	playerTourns.clear();
	playerBlitz.clear();
}

bool Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2_REPLY::equals(const Protocol_MSG_WEB_FIND_PLAYER2_REPLY& _o) const
{
	return Atf::atfPStringEquals(playerName, _o.playerName) &&
		playerTables.equals(_o.playerTables) &&
		playerTourns.equals(_o.playerTourns) &&
		playerBlitz.equals(_o.playerBlitz);
}

bool Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_WEB_FIND_PLAYER2_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_WEB_FIND_PLAYER2_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_WEB_FIND_PLAYER2_REPLY).append(")");
	_buf.append(',');
	_buf.append("playerName=");
	_buf.append(playerName);
	_buf.append(',');
	_buf.append("playerTables=");
	playerTables.toTraceString(_buf);
	_buf.append(',');
	_buf.append("playerTourns=");
	playerTourns.toTraceString(_buf);
	_buf.append(',');
	_buf.append("playerBlitz=");
	playerBlitz.toTraceString(_buf);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_WEB_FIND_PLAYER2_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("playerName", playerName, _buf);
	playerTables.toXmlString("playerTables", _buf);
	playerTourns.toXmlString("playerTourns", _buf);
	playerBlitz.toXmlString("playerBlitz", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("playerName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, playerName)) return false;
			}
			else if (_element.equals("playerTables"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< PlayerTableData, 4 > >::FromXmlString(_value, playerTables)) return false;
			}
			else if (_element.equals("playerTourns"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< PlayerTournData, 4 > >::FromXmlString(_value, playerTourns)) return false;
			}
			else if (_element.equals("playerBlitz"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< PlayerBlitzData, 4 > >::FromXmlString(_value, playerBlitz)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(playerName);
	playerTables.composeMsg(_msg, _ignoreJSON);
	playerTourns.composeMsg(_msg, _ignoreJSON);
	playerBlitz.composeMsg(_msg, _ignoreJSON);
}

void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(playerName);
	playerTables.parseMsg(_parser);
	playerTourns.parseMsg(_parser);
	playerBlitz.parseMsg(_parser);
}

const char *Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("playerName", playerName);
	_jsonstr.compose("playerTables", playerTables);
	_jsonstr.compose("playerTourns", playerTourns);
	_jsonstr.compose("playerBlitz", playerBlitz);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("playerName", playerName);
	_jparser.parseByNameThrow("playerTables", playerTables);
	_jparser.parseByNameThrow("playerTourns", playerTourns);
	_jparser.parseByNameThrow("playerBlitz", playerBlitz);
}

/*static*/ void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_WEB_FIND_PLAYER2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString playerName; _jparser.validateByNameThrow("playerName", playerName);
	AtfValidator::validateInt(_descr, "playerName", playerName.length(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PlayerTableData > playerTables; _jparser.validateByNameThrow("playerTables", playerTables);
	AtfValidator::validateInt(_descr, "playerTables", playerTables.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PlayerTournData > playerTourns; _jparser.validateByNameThrow("playerTourns", playerTourns);
	AtfValidator::validateInt(_descr, "playerTourns", playerTourns.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PlayerBlitzData > playerBlitz; _jparser.validateByNameThrow("playerBlitz", playerBlitz);
	AtfValidator::validateInt(_descr, "playerBlitz", playerBlitz.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_WEB_FIND_PLAYER2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "playerName"); size_t szPlayerName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "playerName", szPlayerName, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szPlayerTables = Atf::LAtfVector< PlayerTableData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("playerTables"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "playerTables", szPlayerTables, _checker, __FILE__, __LINE__);
	int szPlayerTourns = Atf::LAtfVector< PlayerTournData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("playerTourns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "playerTourns", szPlayerTourns, _checker, __FILE__, __LINE__);
	int szPlayerBlitz = Atf::LAtfVector< PlayerBlitzData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("playerBlitz"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "playerBlitz", szPlayerBlitz, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_WEB_FIND_PLAYER3
//=================================================================

Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3::Protocol_MSG_WEB_FIND_PLAYER3()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3::Protocol_MSG_WEB_FIND_PLAYER3(Protocol_MSG_WEB_FIND_PLAYER3&& _o)
	: playerName(std::move(_o.playerName))
{
}

Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3& Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3::operator=(Protocol_MSG_WEB_FIND_PLAYER3&& _o)
{
	if(this != &_o)
	{
		playerName = std::move(_o.playerName);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3::clear()
{
	playerName.clear();
}

bool Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3::equals(const Protocol_MSG_WEB_FIND_PLAYER3& _o) const
{
	return Atf::atfPStringEquals(playerName, _o.playerName);
}

bool Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_WEB_FIND_PLAYER3 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_WEB_FIND_PLAYER3*)_other));
}

const char *Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_WEB_FIND_PLAYER3).append(")");
	_buf.append(',');
	_buf.append("playerName=");
	_buf.append(playerName);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_WEB_FIND_PLAYER3).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("playerName", playerName, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("playerName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, playerName)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(playerName);
}

void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(playerName);
}

const char *Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("playerName", playerName);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("playerName", playerName);
}

/*static*/ void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_WEB_FIND_PLAYER3";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString playerName; _jparser.validateByNameThrow("playerName", playerName);
	AtfValidator::validateIntMax(_descr, "playerName", playerName.length(), 20, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_WEB_FIND_PLAYER3";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "playerName"); size_t szPlayerName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "playerName", szPlayerName, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_WEB_FIND_PLAYER3_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3_REPLY::Protocol_MSG_WEB_FIND_PLAYER3_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3_REPLY::Protocol_MSG_WEB_FIND_PLAYER3_REPLY(Protocol_MSG_WEB_FIND_PLAYER3_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, playerName(std::move(_o.playerName))
	, playerTables(std::move(_o.playerTables))
	, playerTourns(std::move(_o.playerTourns))
	, playerBlitz(std::move(_o.playerBlitz))
{
}

Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3_REPLY& Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3_REPLY::operator=(Protocol_MSG_WEB_FIND_PLAYER3_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		playerName = std::move(_o.playerName);
		playerTables = std::move(_o.playerTables);
		playerTourns = std::move(_o.playerTourns);
		playerBlitz = std::move(_o.playerBlitz);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	playerName.clear();
	playerTables.clear();
	playerTourns.clear();
	playerBlitz.clear();
}

bool Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3_REPLY::equals(const Protocol_MSG_WEB_FIND_PLAYER3_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(playerName, _o.playerName) &&
		playerTables.equals(_o.playerTables) &&
		playerTourns.equals(_o.playerTourns) &&
		playerBlitz.equals(_o.playerBlitz);
}

bool Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_WEB_FIND_PLAYER3_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_WEB_FIND_PLAYER3_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_WEB_FIND_PLAYER3_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("playerName=");
		_buf.append(playerName);
		_buf.append(',');
		_buf.append("playerTables=");
		playerTables.toTraceString(_buf);
		_buf.append(',');
		_buf.append("playerTourns=");
		playerTourns.toTraceString(_buf);
		_buf.append(',');
		_buf.append("playerBlitz=");
		playerBlitz.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_WEB_FIND_PLAYER3_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("playerName", playerName, _buf);
		playerTables.toXmlString("playerTables", _buf);
		playerTourns.toXmlString("playerTourns", _buf);
		playerBlitz.toXmlString("playerBlitz", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("playerName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, playerName)) return false;
			}
			else if (_element.equals("playerTables"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< PlayerTableData, 4 > >::FromXmlString(_value, playerTables)) return false;
			}
			else if (_element.equals("playerTourns"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< PlayerTournData, 4 > >::FromXmlString(_value, playerTourns)) return false;
			}
			else if (_element.equals("playerBlitz"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< PlayerBlitzData, 4 > >::FromXmlString(_value, playerBlitz)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(playerName);
		playerTables.composeMsg(_msg, _ignoreJSON);
		playerTourns.composeMsg(_msg, _ignoreJSON);
		playerBlitz.composeMsg(_msg, _ignoreJSON);
	}
}

void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(playerName);
		playerTables.parseMsg(_parser);
		playerTourns.parseMsg(_parser);
		playerBlitz.parseMsg(_parser);
	}
}

const char *Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("playerName", playerName);
		_jsonstr.compose("playerTables", playerTables);
		_jsonstr.compose("playerTourns", playerTourns);
		_jsonstr.compose("playerBlitz", playerBlitz);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("playerName", playerName);
		_jparser.parseByNameThrow("playerTables", playerTables);
		_jparser.parseByNameThrow("playerTourns", playerTourns);
		_jparser.parseByNameThrow("playerBlitz", playerBlitz);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_WEB_FIND_PLAYER3_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString playerName; _jparser.validateByNameThrow("playerName", playerName);
		AtfValidator::validateInt(_descr, "playerName", playerName.length(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< PlayerTableData > playerTables; _jparser.validateByNameThrow("playerTables", playerTables);
		AtfValidator::validateInt(_descr, "playerTables", playerTables.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< PlayerTournData > playerTourns; _jparser.validateByNameThrow("playerTourns", playerTourns);
		AtfValidator::validateInt(_descr, "playerTourns", playerTourns.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< PlayerBlitzData > playerBlitz; _jparser.validateByNameThrow("playerBlitz", playerBlitz);
		AtfValidator::validateInt(_descr, "playerBlitz", playerBlitz.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_WEB_FIND_PLAYER3_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_WEB_FIND_PLAYER3_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "playerName"); size_t szPlayerName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "playerName", szPlayerName, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szPlayerTables = Atf::LAtfVector< PlayerTableData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("playerTables"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "playerTables", szPlayerTables, _checker, __FILE__, __LINE__);
		int szPlayerTourns = Atf::LAtfVector< PlayerTournData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("playerTourns"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "playerTourns", szPlayerTourns, _checker, __FILE__, __LINE__);
		int szPlayerBlitz = Atf::LAtfVector< PlayerBlitzData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("playerBlitz"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "playerBlitz", szPlayerBlitz, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    Reacquisition
//=================================================================

Lobby::cli::Reacquisition::Reacquisition()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Reacquisition::Reacquisition(Reacquisition&& _o)
	: ticketId(std::move(_o.ticketId))
	, when(std::move(_o.when))
	, reacquisition(std::move(_o.reacquisition))
	, cost(std::move(_o.cost))
{
}

Lobby::cli::Reacquisition& Lobby::cli::Reacquisition::operator=(Reacquisition&& _o)
{
	if(this != &_o)
	{
		ticketId = std::move(_o.ticketId);
		when = std::move(_o.when);
		reacquisition = std::move(_o.reacquisition);
		cost = std::move(_o.cost);
	}
	return *this;
}

#endif

void Lobby::cli::Reacquisition::clear()
{
	ticketId.clear();
	when.setNull();
	reacquisition = 0;
	cost = 0;
}

bool Lobby::cli::Reacquisition::equals(const Reacquisition& _o) const
{
	return Atf::atfPStringEquals(ticketId, _o.ticketId) &&
		when.equals(_o.when) &&
		reacquisition == _o.reacquisition &&
		cost == _o.cost;
}

const char *Lobby::cli::Reacquisition::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("ticketId=");
	_buf.append(ticketId);
	_buf.append(',');
	_buf.append("when=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, when);
	_buf.append(',');
	_buf.append("reacquisition=");
	_buf.appendUint(reacquisition);
	_buf.append(',');
	_buf.append("cost=");
	_buf.appendUint(cost);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::Reacquisition::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("ticketId", ticketId, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "when", when);
	Atf::XmlElement::encodeAsXmlElement("reacquisition", reacquisition, _buf);
	Atf::XmlElement::encodeAsXmlElement("cost", cost, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::Reacquisition::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("ticketId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, ticketId)) return false;
		}
		else if (_element.equals("when"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, when);
		}
		else if (_element.equals("reacquisition"))
		{
			reacquisition = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("cost"))
		{
			cost = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::Reacquisition::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(Reacquisition())) // not empty
	{
		_body.composeString(ticketId);
		_body.composeSrvTime(when);
		_body.composeUINT32(reacquisition);
		_body.composeUINT32(cost);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::cli::Reacquisition::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(ticketId);
	_parser0.parseSrvTime(when);
	_parser0.parseUINT32(reacquisition);
	_parser0.parseUINT32(cost);
}

const char *Lobby::cli::Reacquisition::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("ticketId", ticketId);
	_jsonstr.compose("when", when);
	_jsonstr.compose("reacquisition", reacquisition);
	_jsonstr.compose("cost", cost);
	return _buf.c_str();
}

void Lobby::cli::Reacquisition::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("ticketId", ticketId);
	_jparser.parseByNameThrow("when", when);
	_jparser.parseByNameThrow("reacquisition", reacquisition);
	_jparser.parseByNameThrow("cost", cost);
}

/* static */ void Lobby::cli::Reacquisition::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString ticketId; _jparser.validateByNameThrow("ticketId", ticketId);
	AtfValidator::validateInt(_descr, "ticketId", ticketId.length(), _checker, __FILE__, __LINE__);
	SrvTime when; _jparser.validateByNameThrow("when", when);
	AtfValidator::validateSrvDateTime(_descr, "when", when, _checker, __FILE__, __LINE__);
	UINT32 reacquisition; _jparser.validateByNameThrow("reacquisition", reacquisition);
	AtfValidator::validateInt(_descr, "reacquisition", reacquisition, _checker, __FILE__, __LINE__);
	UINT32 cost; _jparser.validateByNameThrow("cost", cost);
	AtfValidator::validateInt(_descr, "cost", cost, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Reacquisition::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "ticketId"); size_t szTicketId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "ticketId", szTicketId, _checker, __FILE__, __LINE__);
	SrvTime when; _parser0.parseSrvTime(when);
	AtfValidator::validateSrvDateTime(_descr, "when", when, _checker, __FILE__, __LINE__);
	UINT32 reacquisition; _parser0.parseUINT32(reacquisition);
	AtfValidator::validateInt(_descr, "reacquisition", reacquisition, _checker, __FILE__, __LINE__);
	UINT32 cost; _parser0.parseUINT32(cost);
	AtfValidator::validateInt(_descr, "cost", cost, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ITTournData
//=================================================================

Lobby::cli::ITTournData::ITTournData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::ITTournData::ITTournData(ITTournData&& _o)
	: itId(std::move(_o.itId))
	, ticketId(std::move(_o.ticketId))
	, cost(std::move(_o.cost))
	, status(std::move(_o.status))
	, reacquisitions(std::move(_o.reacquisitions))
{
}

Lobby::cli::ITTournData& Lobby::cli::ITTournData::operator=(ITTournData&& _o)
{
	if(this != &_o)
	{
		itId = std::move(_o.itId);
		ticketId = std::move(_o.ticketId);
		cost = std::move(_o.cost);
		status = std::move(_o.status);
		reacquisitions = std::move(_o.reacquisitions);
	}
	return *this;
}

#endif

void Lobby::cli::ITTournData::clear()
{
	itId.clear();
	ticketId.clear();
	cost = 0;
	status = 0;
	reacquisitions.clear();
}

bool Lobby::cli::ITTournData::equals(const ITTournData& _o) const
{
	return Atf::atfPStringEquals(itId, _o.itId) &&
		Atf::atfPStringEquals(ticketId, _o.ticketId) &&
		cost == _o.cost &&
		status == _o.status &&
		reacquisitions.equals(_o.reacquisitions);
}

const char *Lobby::cli::ITTournData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("itId=");
	_buf.append(itId);
	_buf.append(',');
	_buf.append("ticketId=");
	_buf.append(ticketId);
	_buf.append(',');
	_buf.append("cost=");
	_buf.appendUint(cost);
	_buf.append(',');
	_buf.append("status=");
	_buf.appendUint(status);
	_buf.append(',');
	_buf.append("reacquisitions=");
	reacquisitions.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::ITTournData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("itId", itId, _buf);
	Atf::XmlElement::encodeAsXmlElement("ticketId", ticketId, _buf);
	Atf::XmlElement::encodeAsXmlElement("cost", cost, _buf);
	Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
	reacquisitions.toXmlString("reacquisitions", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::ITTournData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("itId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, itId)) return false;
		}
		else if (_element.equals("ticketId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, ticketId)) return false;
		}
		else if (_element.equals("cost"))
		{
			cost = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("status"))
		{
			status = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("reacquisitions"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< Reacquisition, 4 > >::FromXmlString(_value, reacquisitions)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::ITTournData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ITTournData())) // not empty
	{
		_body.composeString(itId);
		_body.composeString(ticketId);
		_body.composeUINT32(cost);
		_body.composeUINT32(status);
		reacquisitions.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::cli::ITTournData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(itId);
	_parser0.parseStringP(ticketId);
	_parser0.parseUINT32(cost);
	_parser0.parseUINT32(status);
	reacquisitions.parseMsg(_parser0);
}

const char *Lobby::cli::ITTournData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("itId", itId);
	_jsonstr.compose("ticketId", ticketId);
	_jsonstr.compose("cost", cost);
	_jsonstr.compose("status", status);
	_jsonstr.compose("reacquisitions", reacquisitions);
	return _buf.c_str();
}

void Lobby::cli::ITTournData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("itId", itId);
	_jparser.parseByNameThrow("ticketId", ticketId);
	_jparser.parseByNameThrow("cost", cost);
	_jparser.parseByNameThrow("status", status);
	_jparser.parseByNameThrow("reacquisitions", reacquisitions);
}

/* static */ void Lobby::cli::ITTournData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString itId; _jparser.validateByNameThrow("itId", itId);
	AtfValidator::validateInt(_descr, "itId", itId.length(), _checker, __FILE__, __LINE__);
	PString ticketId; _jparser.validateByNameThrow("ticketId", ticketId);
	AtfValidator::validateInt(_descr, "ticketId", ticketId.length(), _checker, __FILE__, __LINE__);
	UINT32 cost; _jparser.validateByNameThrow("cost", cost);
	AtfValidator::validateInt(_descr, "cost", cost, _checker, __FILE__, __LINE__);
	UINT32 status; _jparser.validateByNameThrow("status", status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< Reacquisition > reacquisitions; _jparser.validateByNameThrow("reacquisitions", reacquisitions);
	AtfValidator::validateInt(_descr, "reacquisitions", reacquisitions.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::ITTournData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "itId"); size_t szItId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "itId", szItId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "ticketId"); size_t szTicketId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "ticketId", szTicketId, _checker, __FILE__, __LINE__);
	UINT32 cost; _parser0.parseUINT32(cost);
	AtfValidator::validateInt(_descr, "cost", cost, _checker, __FILE__, __LINE__);
	UINT32 status; _parser0.parseUINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szReacquisitions = Atf::LAtfVector< Reacquisition, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("reacquisitions"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "reacquisitions", szReacquisitions, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ITTournVectorData
//=================================================================

Lobby::cli::ITTournVectorData::ITTournVectorData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::ITTournVectorData::ITTournVectorData(ITTournVectorData&& _o)
	: tournId(std::move(_o.tournId))
	, tournData(std::move(_o.tournData))
{
}

Lobby::cli::ITTournVectorData& Lobby::cli::ITTournVectorData::operator=(ITTournVectorData&& _o)
{
	if(this != &_o)
	{
		tournId = std::move(_o.tournId);
		tournData = std::move(_o.tournData);
	}
	return *this;
}

#endif

void Lobby::cli::ITTournVectorData::clear()
{
	tournId = 0;
	tournData.clear();
}

bool Lobby::cli::ITTournVectorData::equals(const ITTournVectorData& _o) const
{
	return tournId == _o.tournId &&
		tournData.equals(_o.tournData);
}

const char *Lobby::cli::ITTournVectorData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("tournData=");
	tournData.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::ITTournVectorData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
	tournData.toXmlString("tournData", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::ITTournVectorData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("tournId"))
		{
			tournId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournData"))
		{
			if(!Atf::AtfTempl< ITTournData >::FromXmlString(_value, tournData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::ITTournVectorData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(tournId);
	tournData.composeMsg(_msg, _ignoreJSON);
}

void Lobby::cli::ITTournVectorData::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tournId);
	tournData.parseMsg(_parser);
}

const char *Lobby::cli::ITTournVectorData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tournId", tournId);
	_jsonstr.compose("tournData", tournData);
	return _buf.c_str();
}

void Lobby::cli::ITTournVectorData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tournId", tournId);
	_jparser.parseByNameThrow("tournData", tournData);
}

/* static */ void Lobby::cli::ITTournVectorData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	ITTournData tournData; _jparser.validateByNameThrow("tournData", tournData);
}

/*static*/ void Lobby::cli::ITTournVectorData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	ITTournData::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournData"), _fieldsWithUnparsedContent);
}

//=================================================================
//                    ITAddOn
//=================================================================

Lobby::cli::ITAddOn::ITAddOn()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::ITAddOn::ITAddOn(ITAddOn&& _o)
	: ticketId(std::move(_o.ticketId))
	, when(std::move(_o.when))
	, reacquisition(std::move(_o.reacquisition))
	, addOn(std::move(_o.addOn))
{
}

Lobby::cli::ITAddOn& Lobby::cli::ITAddOn::operator=(ITAddOn&& _o)
{
	if(this != &_o)
	{
		ticketId = std::move(_o.ticketId);
		when = std::move(_o.when);
		reacquisition = std::move(_o.reacquisition);
		addOn = std::move(_o.addOn);
	}
	return *this;
}

#endif

void Lobby::cli::ITAddOn::clear()
{
	ticketId.clear();
	when.setNull();
	reacquisition = 0;
	addOn = 0;
}

bool Lobby::cli::ITAddOn::equals(const ITAddOn& _o) const
{
	return Atf::atfPStringEquals(ticketId, _o.ticketId) &&
		when.equals(_o.when) &&
		reacquisition == _o.reacquisition &&
		addOn == _o.addOn;
}

const char *Lobby::cli::ITAddOn::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("ticketId=");
	_buf.append(ticketId);
	_buf.append(',');
	_buf.append("when=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, when);
	_buf.append(',');
	_buf.append("reacquisition=");
	_buf.appendUint(reacquisition);
	_buf.append(',');
	_buf.append("addOn=");
	_buf.appendUint(addOn);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::ITAddOn::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("ticketId", ticketId, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "when", when);
	Atf::XmlElement::encodeAsXmlElement("reacquisition", reacquisition, _buf);
	Atf::XmlElement::encodeAsXmlElement("addOn", addOn, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::ITAddOn::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("ticketId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, ticketId)) return false;
		}
		else if (_element.equals("when"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, when);
		}
		else if (_element.equals("reacquisition"))
		{
			reacquisition = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("addOn"))
		{
			addOn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::ITAddOn::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ITAddOn())) // not empty
	{
		_body.composeString(ticketId);
		_body.composeSrvTime(when);
		_body.composeUINT32(reacquisition);
		_body.composeUINT32(addOn);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::cli::ITAddOn::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(ticketId);
	_parser0.parseSrvTime(when);
	_parser0.parseUINT32(reacquisition);
	_parser0.parseUINT32(addOn);
}

const char *Lobby::cli::ITAddOn::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("ticketId", ticketId);
	_jsonstr.compose("when", when);
	_jsonstr.compose("reacquisition", reacquisition);
	_jsonstr.compose("addOn", addOn);
	return _buf.c_str();
}

void Lobby::cli::ITAddOn::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("ticketId", ticketId);
	_jparser.parseByNameThrow("when", when);
	_jparser.parseByNameThrow("reacquisition", reacquisition);
	_jparser.parseByNameThrow("addOn", addOn);
}

/* static */ void Lobby::cli::ITAddOn::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString ticketId; _jparser.validateByNameThrow("ticketId", ticketId);
	AtfValidator::validateInt(_descr, "ticketId", ticketId.length(), _checker, __FILE__, __LINE__);
	SrvTime when; _jparser.validateByNameThrow("when", when);
	AtfValidator::validateSrvDateTime(_descr, "when", when, _checker, __FILE__, __LINE__);
	UINT32 reacquisition; _jparser.validateByNameThrow("reacquisition", reacquisition);
	AtfValidator::validateInt(_descr, "reacquisition", reacquisition, _checker, __FILE__, __LINE__);
	UINT32 addOn; _jparser.validateByNameThrow("addOn", addOn);
	AtfValidator::validateInt(_descr, "addOn", addOn, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::ITAddOn::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "ticketId"); size_t szTicketId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "ticketId", szTicketId, _checker, __FILE__, __LINE__);
	SrvTime when; _parser0.parseSrvTime(when);
	AtfValidator::validateSrvDateTime(_descr, "when", when, _checker, __FILE__, __LINE__);
	UINT32 reacquisition; _parser0.parseUINT32(reacquisition);
	AtfValidator::validateInt(_descr, "reacquisition", reacquisition, _checker, __FILE__, __LINE__);
	UINT32 addOn; _parser0.parseUINT32(addOn);
	AtfValidator::validateInt(_descr, "addOn", addOn, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ITTableData
//=================================================================

Lobby::cli::ITTableData::ITTableData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::ITTableData::ITTableData(ITTableData&& _o)
	: addOns(std::move(_o.addOns))
	, tableId(std::move(_o.tableId))
{
}

Lobby::cli::ITTableData& Lobby::cli::ITTableData::operator=(ITTableData&& _o)
{
	if(this != &_o)
	{
		addOns = std::move(_o.addOns);
		tableId = std::move(_o.tableId);
	}
	return *this;
}

#endif

void Lobby::cli::ITTableData::clear()
{
	addOns.clear();
	tableId = 0;
}

bool Lobby::cli::ITTableData::equals(const ITTableData& _o) const
{
	return addOns.equals(_o.addOns) &&
		tableId == _o.tableId;
}

const char *Lobby::cli::ITTableData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("addOns=");
	addOns.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::ITTableData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	addOns.toXmlString("addOns", _buf);
	Atf::XmlElement::encodeAsXmlElement("tableId", tableId, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::ITTableData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("addOns"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< ITAddOn, 4 > >::FromXmlString(_value, addOns)) return false;
		}
		else if (_element.equals("tableId"))
		{
			tableId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::ITTableData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ITTableData())) // not empty
	{
		addOns.composeMsg(_body, _ignoreJSON);
		_body.composeUINT64(tableId);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::cli::ITTableData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	addOns.parseMsg(_parser0);
	_parser0.parseUINT64(tableId);
}

const char *Lobby::cli::ITTableData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("addOns", addOns);
	_jsonstr.compose("tableId", tableId);
	return _buf.c_str();
}

void Lobby::cli::ITTableData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("addOns", addOns);
	_jparser.parseByNameThrow("tableId", tableId);
}

/* static */ void Lobby::cli::ITTableData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< ITAddOn > addOns; _jparser.validateByNameThrow("addOns", addOns);
	AtfValidator::validateInt(_descr, "addOns", addOns.size(), _checker, __FILE__, __LINE__);
	UINT64 tableId; _jparser.validateByNameThrow("tableId", tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::ITTableData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szAddOns = Atf::LAtfVector< ITAddOn, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("addOns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "addOns", szAddOns, _checker, __FILE__, __LINE__);
	UINT64 tableId; _parser0.parseUINT64(tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ITTableVectorData
//=================================================================

Lobby::cli::ITTableVectorData::ITTableVectorData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::ITTableVectorData::ITTableVectorData(ITTableVectorData&& _o)
	: tableId(std::move(_o.tableId))
	, tableData(std::move(_o.tableData))
{
}

Lobby::cli::ITTableVectorData& Lobby::cli::ITTableVectorData::operator=(ITTableVectorData&& _o)
{
	if(this != &_o)
	{
		tableId = std::move(_o.tableId);
		tableData = std::move(_o.tableData);
	}
	return *this;
}

#endif

void Lobby::cli::ITTableVectorData::clear()
{
	tableId = 0;
	tableData.clear();
}

bool Lobby::cli::ITTableVectorData::equals(const ITTableVectorData& _o) const
{
	return tableId == _o.tableId &&
		tableData.equals(_o.tableData);
}

const char *Lobby::cli::ITTableVectorData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tableId=");
	_buf.appendUint(tableId);
	_buf.append(',');
	_buf.append("tableData=");
	tableData.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::ITTableVectorData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("tableId", tableId, _buf);
	tableData.toXmlString("tableData", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::ITTableVectorData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("tableId"))
		{
			tableId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableData"))
		{
			if(!Atf::AtfTempl< ITTableData >::FromXmlString(_value, tableData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::ITTableVectorData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(tableId);
	tableData.composeMsg(_msg, _ignoreJSON);
}

void Lobby::cli::ITTableVectorData::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tableId);
	tableData.parseMsg(_parser);
}

const char *Lobby::cli::ITTableVectorData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tableId", tableId);
	_jsonstr.compose("tableData", tableData);
	return _buf.c_str();
}

void Lobby::cli::ITTableVectorData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tableId", tableId);
	_jparser.parseByNameThrow("tableData", tableData);
}

/* static */ void Lobby::cli::ITTableVectorData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tableId; _jparser.validateByNameThrow("tableId", tableId);
	AtfValidator::validateInt(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	ITTableData tableData; _jparser.validateByNameThrow("tableData", tableData);
}

/*static*/ void Lobby::cli::ITTableVectorData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 tableId; _parser.parseUINT32(tableId);
	AtfValidator::validateInt(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	ITTableData::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableData"), _fieldsWithUnparsedContent);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_TOURN_REG_IT
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT(Protocol_MSG_LOBBY_FIND_TOURN_REG_IT&& _o)
	: notUsed(std::move(_o.notUsed))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT& Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT::operator=(Protocol_MSG_LOBBY_FIND_TOURN_REG_IT&& _o)
{
	if(this != &_o)
	{
		notUsed = std::move(_o.notUsed);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT::clear()
{
	notUsed.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT::equals(const Protocol_MSG_LOBBY_FIND_TOURN_REG_IT& _o) const
{
	return Atf::atfPStringEquals(notUsed, _o.notUsed);
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_FIND_TOURN_REG_IT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_FIND_TOURN_REG_IT*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_TOURN_REG_IT).append(")");
	_buf.append(',');
	_buf.append("notUsed=");
	_buf.append(notUsed);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_FIND_TOURN_REG_IT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsed", notUsed, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsed"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsed)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsed);
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsed);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsed", notUsed);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsed", notUsed);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TOURN_REG_IT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsed; _jparser.validateByNameThrow("notUsed", notUsed);
	AtfValidator::validateIntMax(_descr, "notUsed", notUsed.length(), 20, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TOURN_REG_IT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsed"); size_t szNotUsed = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsed", szNotUsed, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY(Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, tournVectorData(std::move(_o.tournVectorData))
	, tableVectorData(std::move(_o.tableVectorData))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY& Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY::operator=(Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		tournVectorData = std::move(_o.tournVectorData);
		tableVectorData = std::move(_o.tableVectorData);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	tournVectorData.clear();
	tableVectorData.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY::equals(const Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		tournVectorData.equals(_o.tournVectorData) &&
		tableVectorData.equals(_o.tableVectorData);
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_FIND_TOURN_REG_IT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_TOURN_REG_IT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("tournVectorData=");
		tournVectorData.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tableVectorData=");
		tableVectorData.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_FIND_TOURN_REG_IT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		tournVectorData.toXmlString("tournVectorData", _buf);
		tableVectorData.toXmlString("tableVectorData", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("tournVectorData"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ITTournVectorData, 4 > >::FromXmlString(_value, tournVectorData)) return false;
			}
			else if (_element.equals("tableVectorData"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ITTableVectorData, 4 > >::FromXmlString(_value, tableVectorData)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		tournVectorData.composeMsg(_msg, _ignoreJSON);
		tableVectorData.composeMsg(_msg, _ignoreJSON);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		tournVectorData.parseMsg(_parser);
		tableVectorData.parseMsg(_parser);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("tournVectorData", tournVectorData);
		_jsonstr.compose("tableVectorData", tableVectorData);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("tournVectorData", tournVectorData);
		_jparser.parseByNameThrow("tableVectorData", tableVectorData);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TOURN_REG_IT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< ITTournVectorData > tournVectorData; _jparser.validateByNameThrow("tournVectorData", tournVectorData);
		AtfValidator::validateInt(_descr, "tournVectorData", tournVectorData.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< ITTableVectorData > tableVectorData; _jparser.validateByNameThrow("tableVectorData", tableVectorData);
		AtfValidator::validateInt(_descr, "tableVectorData", tableVectorData.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TOURN_REG_IT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szTournVectorData = Atf::LAtfVector< ITTournVectorData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournVectorData"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tournVectorData", szTournVectorData, _checker, __FILE__, __LINE__);
		int szTableVectorData = Atf::LAtfVector< ITTableVectorData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableVectorData"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tableVectorData", szTableVectorData, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_TOURN_IT
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT::Protocol_MSG_LOBBY_FIND_TOURN_IT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT::Protocol_MSG_LOBBY_FIND_TOURN_IT(Protocol_MSG_LOBBY_FIND_TOURN_IT&& _o)
	: notUsed(std::move(_o.notUsed))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT& Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT::operator=(Protocol_MSG_LOBBY_FIND_TOURN_IT&& _o)
{
	if(this != &_o)
	{
		notUsed = std::move(_o.notUsed);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT::clear()
{
	notUsed.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT::equals(const Protocol_MSG_LOBBY_FIND_TOURN_IT& _o) const
{
	return Atf::atfPStringEquals(notUsed, _o.notUsed);
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_FIND_TOURN_IT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_FIND_TOURN_IT*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_TOURN_IT).append(")");
	_buf.append(',');
	_buf.append("notUsed=");
	_buf.append(notUsed);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_FIND_TOURN_IT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsed", notUsed, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsed"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsed)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsed);
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsed);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsed", notUsed);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsed", notUsed);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TOURN_IT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsed; _jparser.validateByNameThrow("notUsed", notUsed);
	AtfValidator::validateIntMax(_descr, "notUsed", notUsed.length(), 20, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TOURN_IT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsed"); size_t szNotUsed = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsed", szNotUsed, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY::Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY::Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY(Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, tournVectorData(std::move(_o.tournVectorData))
	, tableVectorData(std::move(_o.tableVectorData))
{
}

Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY& Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY::operator=(Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		tournVectorData = std::move(_o.tournVectorData);
		tableVectorData = std::move(_o.tableVectorData);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	tournVectorData.clear();
	tableVectorData.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY::equals(const Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		tournVectorData.equals(_o.tournVectorData) &&
		tableVectorData.equals(_o.tableVectorData);
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_FIND_TOURN_IT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_TOURN_IT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("tournVectorData=");
		tournVectorData.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tableVectorData=");
		tableVectorData.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_FIND_TOURN_IT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		tournVectorData.toXmlString("tournVectorData", _buf);
		tableVectorData.toXmlString("tableVectorData", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("tournVectorData"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ITTournVectorData, 4 > >::FromXmlString(_value, tournVectorData)) return false;
			}
			else if (_element.equals("tableVectorData"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ITTableVectorData, 4 > >::FromXmlString(_value, tableVectorData)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		tournVectorData.composeMsg(_msg, _ignoreJSON);
		tableVectorData.composeMsg(_msg, _ignoreJSON);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		tournVectorData.parseMsg(_parser);
		tableVectorData.parseMsg(_parser);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("tournVectorData", tournVectorData);
		_jsonstr.compose("tableVectorData", tableVectorData);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("tournVectorData", tournVectorData);
		_jparser.parseByNameThrow("tableVectorData", tableVectorData);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TOURN_IT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< ITTournVectorData > tournVectorData; _jparser.validateByNameThrow("tournVectorData", tournVectorData);
		AtfValidator::validateInt(_descr, "tournVectorData", tournVectorData.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< ITTableVectorData > tableVectorData; _jparser.validateByNameThrow("tableVectorData", tableVectorData);
		AtfValidator::validateInt(_descr, "tableVectorData", tableVectorData.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TOURN_IT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szTournVectorData = Atf::LAtfVector< ITTournVectorData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournVectorData"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tournVectorData", szTournVectorData, _checker, __FILE__, __LINE__);
		int szTableVectorData = Atf::LAtfVector< ITTableVectorData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableVectorData"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tableVectorData", szTableVectorData, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_VALIDATE_MOBILE
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE::Protocol_MSG_LOBBY_VALIDATE_MOBILE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE::Protocol_MSG_LOBBY_VALIDATE_MOBILE(Protocol_MSG_LOBBY_VALIDATE_MOBILE&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, unique(std::move(_o.unique))
{
}

Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE& Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE::operator=(Protocol_MSG_LOBBY_VALIDATE_MOBILE&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		unique = std::move(_o.unique);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE::clear()
{
	notUsedStr.clear();
	unique = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE::equals(const Protocol_MSG_LOBBY_VALIDATE_MOBILE& _o) const
{
	return Atf::atfPStringEquals(notUsedStr, _o.notUsedStr) &&
		unique == _o.unique;
}

bool Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_VALIDATE_MOBILE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_VALIDATE_MOBILE*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_VALIDATE_MOBILE).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("unique=");
	_buf.appendUint(unique);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_VALIDATE_MOBILE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsedStr", notUsedStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("unique", unique, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedStr)) return false;
			}
			else if (_element.equals("unique"))
			{
				unique = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsedStr);
	_msg.composeUINT32(unique);
}

void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseUINT32(unique);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsedStr", notUsedStr);
	_jsonstr.compose("unique", unique);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsedStr", notUsedStr);
	_jparser.parseByNameThrow("unique", unique);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_VALIDATE_MOBILE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsedStr; _jparser.validateByNameThrow("notUsedStr", notUsedStr);
	AtfValidator::validateIntMax(_descr, "notUsedStr", notUsedStr.length(), 20, _checker, __FILE__, __LINE__);
	UINT32 unique; _jparser.validateByNameThrow("unique", unique);
	AtfValidator::validateInt(_descr, "unique", unique, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_VALIDATE_MOBILE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	UINT32 unique; _parser.parseUINT32(unique);
	AtfValidator::validateInt(_descr, "unique", unique, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY::Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY::Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY(Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY& Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY::operator=(Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY::equals(const Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_VALIDATE_MOBILE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_VALIDATE_MOBILE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_VALIDATE_MOBILE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_VALIDATE_MOBILE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_VALIDATE_MOBILE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR(Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR&& _o)
	: originalError(std::move(_o.originalError))
{
}

Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR& Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR::operator=(Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR&& _o)
{
	if(this != &_o)
	{
		originalError = std::move(_o.originalError);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR::clear()
{
	originalError.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR::equals(const Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR& _o) const
{
	return Atf::atfPStringEquals(originalError, _o.originalError);
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_SELFEXCLUDED_STR != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_SELFEXCLUDED_STR).append(")");
	_buf.append(',');
	_buf.append("originalError=");
	_buf.append(originalError);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_SELFEXCLUDED_STR).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("originalError", originalError, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("originalError"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, originalError)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(originalError);
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseStringP(originalError);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("originalError", originalError);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("originalError", originalError);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_SELFEXCLUDED_STR";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	PString originalError; _jparser.validateByNameThrow("originalError", originalError);
	AtfValidator::validateIntMax(_descr, "originalError", originalError.length(), 1000, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_SELFEXCLUDED_STR";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "originalError"); size_t szOriginalError = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "originalError", szOriginalError, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY(Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY& Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY::operator=(Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY::equals(const Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc);
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errDesc=");
	_buf.append(errDesc);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errDesc);
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(errDesc);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errDesc", errDesc);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errDesc", errDesc);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
	AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL::clear()
{
	validationCode = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL::equals(const Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL& _o) const
{
	return validationCode == _o.validationCode;
}

bool Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_VALIDATE_NEWINSTALL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_VALIDATE_NEWINSTALL).append(")");
	_buf.append(',');
	_buf.append("validationCode=");
	_buf.appendUint(validationCode);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_VALIDATE_NEWINSTALL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("validationCode", validationCode, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("validationCode"))
			{
				validationCode = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(validationCode);
}

void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(validationCode);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("validationCode", validationCode);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("validationCode", validationCode);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_VALIDATE_NEWINSTALL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 validationCode; _jparser.validateByNameThrow("validationCode", validationCode);
	AtfValidator::validateInt(_descr, "validationCode", validationCode, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_VALIDATE_NEWINSTALL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 validationCode; _parser.parseUINT32(validationCode);
	AtfValidator::validateInt(_descr, "validationCode", validationCode, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY(Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY& Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY::operator=(Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY::equals(const Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc);
}

bool Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE::clear()
{
}

bool Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE::equals(const Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE& _o) const
{
	return true;
}

bool Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE).append(")");
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE::parseMsg(CommMsgParser& _parser)
{
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY(Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY& Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY::operator=(Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY::equals(const Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc);
}

bool Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    UserProperties
//=================================================================

Lobby::cli::UserProperties::UserProperties()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::UserProperties::UserProperties(UserProperties&& _o)
	: propType(std::move(_o.propType))
	, propInt(std::move(_o.propInt))
	, propStr(std::move(_o.propStr))
	, when(std::move(_o.when))
{
}

Lobby::cli::UserProperties& Lobby::cli::UserProperties::operator=(UserProperties&& _o)
{
	if(this != &_o)
	{
		propType = std::move(_o.propType);
		propInt = std::move(_o.propInt);
		propStr = std::move(_o.propStr);
		when = std::move(_o.when);
	}
	return *this;
}

#endif

void Lobby::cli::UserProperties::clear()
{
	propType = 0;
	propInt = 0;
	propStr.clear();
	when.setNull();
}

bool Lobby::cli::UserProperties::equals(const UserProperties& _o) const
{
	return propType == _o.propType &&
		propInt == _o.propInt &&
		Atf::atfPStringEquals(propStr, _o.propStr) &&
		when.equals(_o.when);
}

const char *Lobby::cli::UserProperties::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("propType=");
	_buf.appendInt(propType);
	_buf.append(',');
	_buf.append("propInt=");
	_buf.appendInt(propInt);
	_buf.append(',');
	_buf.append("propStr=");
	_buf.append(propStr);
	_buf.append(',');
	_buf.append("when=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, when);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::UserProperties::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("propType", propType, _buf);
	Atf::XmlElement::encodeAsXmlElement("propInt", propInt, _buf);
	Atf::XmlElement::encodeAsXmlElement("propStr", propStr, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "when", when);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::UserProperties::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("propType"))
		{
			propType = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("propInt"))
		{
			propInt = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("propStr"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, propStr)) return false;
		}
		else if (_element.equals("when"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, when);
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::UserProperties::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(propType);
	_msg.composeINT32(propInt);
	_msg.composeString(propStr);
	_msg.composeSrvTime(when);
}

void Lobby::cli::UserProperties::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(propType);
	_parser.parseINT32(propInt);
	_parser.parseStringP(propStr);
	_parser.parseSrvTime(when);
}

const char *Lobby::cli::UserProperties::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("propType", propType);
	_jsonstr.compose("propInt", propInt);
	_jsonstr.compose("propStr", propStr);
	_jsonstr.compose("when", when);
	return _buf.c_str();
}

void Lobby::cli::UserProperties::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("propType", propType);
	_jparser.parseByNameThrow("propInt", propInt);
	_jparser.parseByNameThrow("propStr", propStr);
	_jparser.parseByNameThrow("when", when);
}

/* static */ void Lobby::cli::UserProperties::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 propType; _jparser.validateByNameThrow("propType", propType);
	AtfValidator::validateInt(_descr, "propType", propType, _checker, __FILE__, __LINE__);
	INT32 propInt; _jparser.validateByNameThrow("propInt", propInt);
	AtfValidator::validateInt(_descr, "propInt", propInt, _checker, __FILE__, __LINE__);
	PString propStr; _jparser.validateByNameThrow("propStr", propStr);
	AtfValidator::validateInt(_descr, "propStr", propStr.length(), _checker, __FILE__, __LINE__);
	SrvTime when; _jparser.validateByNameThrow("when", when);
	AtfValidator::validateSrvDateTime(_descr, "when", when, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::UserProperties::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	INT32 propType; _parser.parseINT32(propType);
	AtfValidator::validateInt(_descr, "propType", propType, _checker, __FILE__, __LINE__);
	INT32 propInt; _parser.parseINT32(propInt);
	AtfValidator::validateInt(_descr, "propInt", propInt, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "propStr"); size_t szPropStr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "propStr", szPropStr, _checker, __FILE__, __LINE__);
	SrvTime when; _parser.parseSrvTime(when);
	AtfValidator::validateSrvDateTime(_descr, "when", when, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    PhoneValidationInfo
//=================================================================

Lobby::cli::PhoneValidationInfo::PhoneValidationInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::PhoneValidationInfo::PhoneValidationInfo(PhoneValidationInfo&& _o)
	: validation(std::move(_o.validation))
	, countryCode(std::move(_o.countryCode))
	, verifiedNumber(std::move(_o.verifiedNumber))
	, dialingInfo(std::move(_o.dialingInfo))
	, phone(std::move(_o.phone))
{
}

Lobby::cli::PhoneValidationInfo& Lobby::cli::PhoneValidationInfo::operator=(PhoneValidationInfo&& _o)
{
	if(this != &_o)
	{
		validation = std::move(_o.validation);
		countryCode = std::move(_o.countryCode);
		verifiedNumber = std::move(_o.verifiedNumber);
		dialingInfo = std::move(_o.dialingInfo);
		phone = std::move(_o.phone);
	}
	return *this;
}

#endif

void Lobby::cli::PhoneValidationInfo::clear()
{
	validation = 0;
	countryCode.clear();
	verifiedNumber.clear();
	dialingInfo.clear();
	phone.clear();
}

bool Lobby::cli::PhoneValidationInfo::equals(const PhoneValidationInfo& _o) const
{
	return validation == _o.validation &&
		Atf::atfPStringEquals(countryCode, _o.countryCode) &&
		Atf::atfPStringEquals(verifiedNumber, _o.verifiedNumber) &&
		Atf::atfPStringEquals(dialingInfo, _o.dialingInfo) &&
		Atf::atfPStringEquals(phone, _o.phone);
}

const char *Lobby::cli::PhoneValidationInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("validation=");
	_buf.appendUint(validation);
	_buf.append(',');
	_buf.append("countryCode=");
	_buf.append(countryCode);
	_buf.append(',');
	_buf.append("verifiedNumber=");
	_buf.append(verifiedNumber);
	_buf.append(',');
	_buf.append("dialingInfo=");
	_buf.append(dialingInfo);
	_buf.append(',');
	_buf.append("phone=");
	_buf.append(phone);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::cli::PhoneValidationInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("validation", validation, _buf);
	Atf::XmlElement::encodeAsXmlElement("countryCode", countryCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("verifiedNumber", verifiedNumber, _buf);
	Atf::XmlElement::encodeAsXmlElement("dialingInfo", dialingInfo, _buf);
	Atf::XmlElement::encodeAsXmlElement("phone", phone, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::cli::PhoneValidationInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("validation"))
		{
			validation = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("countryCode"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, countryCode)) return false;
		}
		else if (_element.equals("verifiedNumber"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, verifiedNumber)) return false;
		}
		else if (_element.equals("dialingInfo"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, dialingInfo)) return false;
		}
		else if (_element.equals("phone"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, phone)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::cli::PhoneValidationInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(PhoneValidationInfo())) // not empty
	{
		_body.composeBYTE(validation);
		_body.composeString(countryCode);
		_body.composeString(verifiedNumber);
		_body.composeString(dialingInfo);
		_body.composeString(phone);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::cli::PhoneValidationInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(validation);
	_parser0.parseStringP(countryCode);
	_parser0.parseStringP(verifiedNumber);
	_parser0.parseStringP(dialingInfo);
	_parser0.parseStringP(phone);
}

const char *Lobby::cli::PhoneValidationInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("validation", validation);
	_jsonstr.compose("countryCode", countryCode);
	_jsonstr.compose("verifiedNumber", verifiedNumber);
	_jsonstr.compose("dialingInfo", dialingInfo);
	_jsonstr.compose("phone", phone);
	return _buf.c_str();
}

void Lobby::cli::PhoneValidationInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("validation", validation);
	_jparser.parseByNameThrow("countryCode", countryCode);
	_jparser.parseByNameThrow("verifiedNumber", verifiedNumber);
	_jparser.parseByNameThrow("dialingInfo", dialingInfo);
	_jparser.parseByNameThrow("phone", phone);
}

/* static */ void Lobby::cli::PhoneValidationInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE validation; _jparser.validateByNameThrow("validation", validation);
	AtfValidator::validateInt(_descr, "validation", validation, _checker, __FILE__, __LINE__);
	PString countryCode; _jparser.validateByNameThrow("countryCode", countryCode);
	AtfValidator::validateInt(_descr, "countryCode", countryCode.length(), _checker, __FILE__, __LINE__);
	PString verifiedNumber; _jparser.validateByNameThrow("verifiedNumber", verifiedNumber);
	AtfValidator::validateInt(_descr, "verifiedNumber", verifiedNumber.length(), _checker, __FILE__, __LINE__);
	PString dialingInfo; _jparser.validateByNameThrow("dialingInfo", dialingInfo);
	AtfValidator::validateInt(_descr, "dialingInfo", dialingInfo.length(), _checker, __FILE__, __LINE__);
	PString phone; _jparser.validateByNameThrow("phone", phone);
	AtfValidator::validateInt(_descr, "phone", phone.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::PhoneValidationInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	BYTE validation; _parser0.parseBYTE(validation);
	AtfValidator::validateInt(_descr, "validation", validation, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "countryCode"); size_t szCountryCode = strlen(_dummy);
	AtfValidator::validateInt(_descr, "countryCode", szCountryCode, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "verifiedNumber"); size_t szVerifiedNumber = strlen(_dummy);
	AtfValidator::validateInt(_descr, "verifiedNumber", szVerifiedNumber, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "dialingInfo"); size_t szDialingInfo = strlen(_dummy);
	AtfValidator::validateInt(_descr, "dialingInfo", szDialingInfo, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "phone"); size_t szPhone = strlen(_dummy);
	AtfValidator::validateInt(_descr, "phone", szPhone, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_USER_INFO
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO::Protocol_MSG_LOBBY_GET_USER_INFO()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO::Protocol_MSG_LOBBY_GET_USER_INFO(Protocol_MSG_LOBBY_GET_USER_INFO&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, needImage(std::move(_o.needImage))
	, needPwdUpdate(std::move(_o.needPwdUpdate))
{
}

Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO& Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO::operator=(Protocol_MSG_LOBBY_GET_USER_INFO&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		needImage = std::move(_o.needImage);
		needPwdUpdate = std::move(_o.needPwdUpdate);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO::clear()
{
	notUsedStr.clear();
	needImage = false;
	needPwdUpdate = false;
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO::equals(const Protocol_MSG_LOBBY_GET_USER_INFO& _o) const
{
	return Atf::atfPStringEquals(notUsedStr, _o.notUsedStr) &&
		needImage == _o.needImage &&
		needPwdUpdate == _o.needPwdUpdate;
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_USER_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_USER_INFO*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_USER_INFO).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("needImage=");
	_buf.appendUint(needImage);
	_buf.append(',');
	_buf.append("needPwdUpdate=");
	_buf.appendUint(needPwdUpdate);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_USER_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsedStr", notUsedStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("needImage", needImage, _buf);
	Atf::XmlElement::encodeAsXmlElement("needPwdUpdate", needPwdUpdate, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedStr)) return false;
			}
			else if (_element.equals("needImage"))
			{
				needImage = (*_value.ptr() == '1');
			}
			else if (_element.equals("needPwdUpdate"))
			{
				needPwdUpdate = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsedStr);
	_msg.composeBOOL(needImage);
	_msg.composeBOOL(needPwdUpdate);
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(needImage);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(needPwdUpdate);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsedStr", notUsedStr);
	_jsonstr.compose("needImage", needImage);
	_jsonstr.compose("needPwdUpdate", needPwdUpdate);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsedStr", notUsedStr);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("needImage", needImage);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("needPwdUpdate", needPwdUpdate);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_USER_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsedStr; _jparser.validateByNameThrow("notUsedStr", notUsedStr);
	AtfValidator::validateIntMax(_descr, "notUsedStr", notUsedStr.length(), 20, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool needImage; _jparser.validateByNameThrow("needImage", needImage);
	AtfValidator::validateInt(_descr, "needImage", needImage, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool needPwdUpdate; _jparser.validateByNameThrow("needPwdUpdate", needPwdUpdate);
	AtfValidator::validateInt(_descr, "needPwdUpdate", needPwdUpdate, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_USER_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool needImage; _parser.parseBOOL(needImage);
	AtfValidator::validateInt(_descr, "needImage", needImage, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool needPwdUpdate; _parser.parseBOOL(needPwdUpdate);
	AtfValidator::validateInt(_descr, "needPwdUpdate", needPwdUpdate, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_USER_INFO_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO_REPLY::Protocol_MSG_LOBBY_GET_USER_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO_REPLY::Protocol_MSG_LOBBY_GET_USER_INFO_REPLY(Protocol_MSG_LOBBY_GET_USER_INFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, fullName1(std::move(_o.fullName1))
	, fullName2(std::move(_o.fullName2))
	, fullName3(std::move(_o.fullName3))
	, fullName4(std::move(_o.fullName4))
	, fullName5(std::move(_o.fullName5))
	, fullName6(std::move(_o.fullName6))
	, fullName7(std::move(_o.fullName7))
	, fullName8(std::move(_o.fullName8))
	, imgData(std::move(_o.imgData))
	, priv1(std::move(_o.priv1))
	, priv2(std::move(_o.priv2))
	, priv3(std::move(_o.priv3))
	, priv4(std::move(_o.priv4))
	, priv5(std::move(_o.priv5))
	, priv6(std::move(_o.priv6))
	, priv7(std::move(_o.priv7))
	, dob(std::move(_o.dob))
	, phoneNum(std::move(_o.phoneNum))
	, phoneValidation(std::move(_o.phoneValidation))
	, firstName(std::move(_o.firstName))
	, onlyLastName(std::move(_o.onlyLastName))
	, fiscalCode(std::move(_o.fiscalCode))
	, userProps(std::move(_o.userProps))
	, flags2(std::move(_o.flags2))
	, imgId(std::move(_o.imgId))
	, sex(std::move(_o.sex))
	, mobile(std::move(_o.mobile))
	, addressStateLocked(std::move(_o.addressStateLocked))
	, registered(std::move(_o.registered))
	, mobilePhoneValidation(std::move(_o.mobilePhoneValidation))
	, promoImgCode(std::move(_o.promoImgCode))
	, pwdUpdateTime(std::move(_o.pwdUpdateTime))
	, privileges3(std::move(_o.privileges3))
	, missedMonths(std::move(_o.missedMonths))
	, vipStatusUntil(std::move(_o.vipStatusUntil))
	, missableMonthsYearly(std::move(_o.missableMonthsYearly))
	, gameAvatars(std::move(_o.gameAvatars))
{
}

Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO_REPLY& Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO_REPLY::operator=(Protocol_MSG_LOBBY_GET_USER_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		fullName1 = std::move(_o.fullName1);
		fullName2 = std::move(_o.fullName2);
		fullName3 = std::move(_o.fullName3);
		fullName4 = std::move(_o.fullName4);
		fullName5 = std::move(_o.fullName5);
		fullName6 = std::move(_o.fullName6);
		fullName7 = std::move(_o.fullName7);
		fullName8 = std::move(_o.fullName8);
		imgData = std::move(_o.imgData);
		priv1 = std::move(_o.priv1);
		priv2 = std::move(_o.priv2);
		priv3 = std::move(_o.priv3);
		priv4 = std::move(_o.priv4);
		priv5 = std::move(_o.priv5);
		priv6 = std::move(_o.priv6);
		priv7 = std::move(_o.priv7);
		dob = std::move(_o.dob);
		phoneNum = std::move(_o.phoneNum);
		phoneValidation = std::move(_o.phoneValidation);
		firstName = std::move(_o.firstName);
		onlyLastName = std::move(_o.onlyLastName);
		fiscalCode = std::move(_o.fiscalCode);
		userProps = std::move(_o.userProps);
		flags2 = std::move(_o.flags2);
		imgId = std::move(_o.imgId);
		sex = std::move(_o.sex);
		mobile = std::move(_o.mobile);
		addressStateLocked = std::move(_o.addressStateLocked);
		registered = std::move(_o.registered);
		mobilePhoneValidation = std::move(_o.mobilePhoneValidation);
		promoImgCode = std::move(_o.promoImgCode);
		pwdUpdateTime = std::move(_o.pwdUpdateTime);
		privileges3 = std::move(_o.privileges3);
		missedMonths = std::move(_o.missedMonths);
		vipStatusUntil = std::move(_o.vipStatusUntil);
		missableMonthsYearly = std::move(_o.missableMonthsYearly);
		gameAvatars = std::move(_o.gameAvatars);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	fullName1.clear();
	fullName2.clear();
	fullName3.clear();
	fullName4.clear();
	fullName5.clear();
	fullName6.clear();
	fullName7.clear();
	fullName8.clear();
	imgData.clear();
	priv1 = 0;
	priv2 = 0;
	priv3 = 0;
	priv4 = 0;
	priv5 = 0;
	priv6 = 0;
	priv7 = 0;
	dob.setNull();
	phoneNum.clear();
	phoneValidation.clear();
	firstName.clear();
	onlyLastName.clear();
	fiscalCode.clear();
	userProps.clear();
	flags2 = 0;
	imgId = 0;
	sex.clear();
	mobile.clear();
	addressStateLocked = false;
	registered.setNull();
	mobilePhoneValidation.clear();
	promoImgCode.clear();
	pwdUpdateTime = 0;
	privileges3 = 0;
	missedMonths = 0;
	vipStatusUntil.setNull();
	missableMonthsYearly = 0;
	gameAvatars.clear();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO_REPLY::equals(const Protocol_MSG_LOBBY_GET_USER_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(fullName1, _o.fullName1) &&
		Atf::atfPStringEquals(fullName2, _o.fullName2) &&
		Atf::atfPStringEquals(fullName3, _o.fullName3) &&
		Atf::atfPStringEquals(fullName4, _o.fullName4) &&
		Atf::atfPStringEquals(fullName5, _o.fullName5) &&
		Atf::atfPStringEquals(fullName6, _o.fullName6) &&
		Atf::atfPStringEquals(fullName7, _o.fullName7) &&
		Atf::atfPStringEquals(fullName8, _o.fullName8) &&
		imgData.size() == _o.imgData.size() && memcmp(imgData.ptr(), _o.imgData.ptr(), imgData.size()) == 0 &&
		priv1 == _o.priv1 &&
		priv2 == _o.priv2 &&
		priv3 == _o.priv3 &&
		priv4 == _o.priv4 &&
		priv5 == _o.priv5 &&
		priv6 == _o.priv6 &&
		priv7 == _o.priv7 &&
		dob.equals(_o.dob) &&
		Atf::atfPStringEquals(phoneNum, _o.phoneNum) &&
		phoneValidation.equals(_o.phoneValidation) &&
		Atf::atfPStringEquals(firstName, _o.firstName) &&
		Atf::atfPStringEquals(onlyLastName, _o.onlyLastName) &&
		Atf::atfPStringEquals(fiscalCode, _o.fiscalCode) &&
		userProps.equals(_o.userProps) &&
		flags2 == _o.flags2 &&
		imgId == _o.imgId &&
		Atf::atfPStringEquals(sex, _o.sex) &&
		Atf::atfPStringEquals(mobile, _o.mobile) &&
		addressStateLocked == _o.addressStateLocked &&
		registered.equals(_o.registered) &&
		mobilePhoneValidation.equals(_o.mobilePhoneValidation) &&
		Atf::atfPStringEquals(promoImgCode, _o.promoImgCode) &&
		pwdUpdateTime == _o.pwdUpdateTime &&
		privileges3 == _o.privileges3 &&
		missedMonths == _o.missedMonths &&
		vipStatusUntil.equals(_o.vipStatusUntil) &&
		missableMonthsYearly == _o.missableMonthsYearly &&
		gameAvatars.equals(_o.gameAvatars);
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_USER_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_USER_INFO_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_USER_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("fullName1=");
		_buf.append(fullName1);
		_buf.append(',');
		_buf.append("fullName2=");
		_buf.append(fullName2);
		_buf.append(',');
		_buf.append("fullName3=");
		_buf.append(fullName3);
		_buf.append(',');
		_buf.append("fullName4=");
		_buf.append(fullName4);
		_buf.append(',');
		_buf.append("fullName5=");
		_buf.append(fullName5);
		_buf.append(',');
		_buf.append("fullName6=");
		_buf.append(fullName6);
		_buf.append(',');
		_buf.append("fullName7=");
		_buf.append(fullName7);
		_buf.append(',');
		_buf.append("fullName8=");
		_buf.append(fullName8);
		_buf.append(',');
		_buf.append("imgData=");
		Atf::AtfTempl<PBlock>::ToTraceString(_buf, imgData);
		_buf.append(',');
		_buf.append("priv1=");
		_buf.appendUint(priv1);
		_buf.append(',');
		_buf.append("priv2=");
		_buf.appendUint(priv2);
		_buf.append(',');
		_buf.append("priv3=");
		_buf.appendUint(priv3);
		_buf.append(',');
		_buf.append("priv4=");
		_buf.appendUint(priv4);
		_buf.append(',');
		_buf.append("priv5=");
		_buf.appendUint(priv5);
		_buf.append(',');
		_buf.append("priv6=");
		_buf.appendUint(priv6);
		_buf.append(',');
		_buf.append("priv7=");
		_buf.appendUint(priv7);
		_buf.append(',');
		_buf.append("dob=");
		Atf::AtfTempl<SrvDate>::ToTraceString(_buf, dob);
		_buf.append(',');
		_buf.append("phoneNum=");
		_buf.append(phoneNum);
		_buf.append(',');
		_buf.append("phoneValidation=");
		phoneValidation.toTraceString(_buf);
		_buf.append(',');
		_buf.append("firstName=");
		_buf.append(firstName);
		_buf.append(',');
		_buf.append("onlyLastName=");
		_buf.append(onlyLastName);
		_buf.append(',');
		_buf.append("fiscalCode=");
		_buf.append(fiscalCode);
		_buf.append(',');
		_buf.append("userProps=");
		userProps.toTraceString(_buf);
		_buf.append(',');
		_buf.append("flags2=");
		_buf.appendUint64(flags2);
		_buf.append(',');
		_buf.append("imgId=");
		_buf.appendUint(imgId);
		_buf.append(',');
		_buf.append("sex=");
		_buf.append(sex);
		_buf.append(',');
		_buf.append("mobile=");
		_buf.append(mobile);
		_buf.append(',');
		_buf.append("addressStateLocked=");
		_buf.appendUint(addressStateLocked);
		_buf.append(',');
		_buf.append("registered=");
		Atf::AtfTempl<SrvTime>::ToTraceString(_buf, registered);
		_buf.append(',');
		_buf.append("mobilePhoneValidation=");
		mobilePhoneValidation.toTraceString(_buf);
		_buf.append(',');
		_buf.append("promoImgCode=");
		_buf.append(promoImgCode);
		_buf.append(',');
		_buf.append("pwdUpdateTime=");
		_buf.appendUint(pwdUpdateTime);
		_buf.append(',');
		_buf.append("privileges3=");
		_buf.appendUint64(privileges3);
		_buf.append(',');
		_buf.append("missedMonths=");
		_buf.appendInt(missedMonths);
		_buf.append(',');
		_buf.append("vipStatusUntil=");
		Atf::AtfTempl<SrvDate>::ToTraceString(_buf, vipStatusUntil);
		_buf.append(',');
		_buf.append("missableMonthsYearly=");
		_buf.appendInt(missableMonthsYearly);
		_buf.append(',');
		_buf.append("gameAvatars=");
		gameAvatars.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_USER_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("fullName1", fullName1, _buf);
		Atf::XmlElement::encodeAsXmlElement("fullName2", fullName2, _buf);
		Atf::XmlElement::encodeAsXmlElement("fullName3", fullName3, _buf);
		Atf::XmlElement::encodeAsXmlElement("fullName4", fullName4, _buf);
		Atf::XmlElement::encodeAsXmlElement("fullName5", fullName5, _buf);
		Atf::XmlElement::encodeAsXmlElement("fullName6", fullName6, _buf);
		Atf::XmlElement::encodeAsXmlElement("fullName7", fullName7, _buf);
		Atf::XmlElement::encodeAsXmlElement("fullName8", fullName8, _buf);
		Atf::XmlElement::encodeAsXmlElement("imgData", imgData, _buf);
		Atf::XmlElement::encodeAsXmlElement("priv1", priv1, _buf);
		Atf::XmlElement::encodeAsXmlElement("priv2", priv2, _buf);
		Atf::XmlElement::encodeAsXmlElement("priv3", priv3, _buf);
		Atf::XmlElement::encodeAsXmlElement("priv4", priv4, _buf);
		Atf::XmlElement::encodeAsXmlElement("priv5", priv5, _buf);
		Atf::XmlElement::encodeAsXmlElement("priv6", priv6, _buf);
		Atf::XmlElement::encodeAsXmlElement("priv7", priv7, _buf);
		Atf::AtfTempl<SrvDate>::ToXmlString(_buf, "dob", dob);
		Atf::XmlElement::encodeAsXmlElement("phoneNum", phoneNum, _buf);
		phoneValidation.toXmlString("phoneValidation", _buf);
		Atf::XmlElement::encodeAsXmlElement("firstName", firstName, _buf);
		Atf::XmlElement::encodeAsXmlElement("onlyLastName", onlyLastName, _buf);
		Atf::XmlElement::encodeAsXmlElement("fiscalCode", fiscalCode, _buf);
		userProps.toXmlString("userProps", _buf);
		Atf::XmlElement::encodeAsXmlElement("flags2", flags2, _buf);
		Atf::XmlElement::encodeAsXmlElement("imgId", imgId, _buf);
		Atf::XmlElement::encodeAsXmlElement("sex", sex, _buf);
		Atf::XmlElement::encodeAsXmlElement("mobile", mobile, _buf);
		Atf::XmlElement::encodeAsXmlElement("addressStateLocked", addressStateLocked, _buf);
		Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "registered", registered);
		mobilePhoneValidation.toXmlString("mobilePhoneValidation", _buf);
		Atf::XmlElement::encodeAsXmlElement("promoImgCode", promoImgCode, _buf);
		Atf::XmlElement::encodeAsXmlElement("pwdUpdateTime", pwdUpdateTime, _buf);
		Atf::XmlElement::encodeAsXmlElement("privileges3", privileges3, _buf);
		Atf::XmlElement::encodeAsXmlElement("missedMonths", missedMonths, _buf);
		Atf::AtfTempl<SrvDate>::ToXmlString(_buf, "vipStatusUntil", vipStatusUntil);
		Atf::XmlElement::encodeAsXmlElement("missableMonthsYearly", missableMonthsYearly, _buf);
		gameAvatars.toXmlString("gameAvatars", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("fullName1"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, fullName1)) return false;
			}
			else if (_element.equals("fullName2"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, fullName2)) return false;
			}
			else if (_element.equals("fullName3"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, fullName3)) return false;
			}
			else if (_element.equals("fullName4"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, fullName4)) return false;
			}
			else if (_element.equals("fullName5"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, fullName5)) return false;
			}
			else if (_element.equals("fullName6"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, fullName6)) return false;
			}
			else if (_element.equals("fullName7"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, fullName7)) return false;
			}
			else if (_element.equals("fullName8"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, fullName8)) return false;
			}
			else if (_element.equals("imgData"))
			{
				Atf::XmlElement::_movePBlockWithNullStrip(_value, imgData);
			}
			else if (_element.equals("priv1"))
			{
				priv1 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("priv2"))
			{
				priv2 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("priv3"))
			{
				priv3 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("priv4"))
			{
				priv4 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("priv5"))
			{
				priv5 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("priv6"))
			{
				priv6 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("priv7"))
			{
				priv7 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("dob"))
			{
				Atf::AtfTempl<SrvDate>::FromXmlString(_value, dob);
			}
			else if (_element.equals("phoneNum"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, phoneNum)) return false;
			}
			else if (_element.equals("phoneValidation"))
			{
				if(!Atf::AtfTempl< PhoneValidationInfo >::FromXmlString(_value, phoneValidation)) return false;
			}
			else if (_element.equals("firstName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, firstName)) return false;
			}
			else if (_element.equals("onlyLastName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, onlyLastName)) return false;
			}
			else if (_element.equals("fiscalCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, fiscalCode)) return false;
			}
			else if (_element.equals("userProps"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UserProperties, 4 > >::FromXmlString(_value, userProps)) return false;
			}
			else if (_element.equals("flags2"))
			{
				flags2 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("imgId"))
			{
				imgId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("sex"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, sex)) return false;
			}
			else if (_element.equals("mobile"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, mobile)) return false;
			}
			else if (_element.equals("addressStateLocked"))
			{
				addressStateLocked = (*_value.ptr() == '1');
			}
			else if (_element.equals("registered"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, registered);
			}
			else if (_element.equals("mobilePhoneValidation"))
			{
				if(!Atf::AtfTempl< PhoneValidationInfo >::FromXmlString(_value, mobilePhoneValidation)) return false;
			}
			else if (_element.equals("promoImgCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, promoImgCode)) return false;
			}
			else if (_element.equals("pwdUpdateTime"))
			{
				pwdUpdateTime = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("privileges3"))
			{
				privileges3 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("missedMonths"))
			{
				missedMonths = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("vipStatusUntil"))
			{
				Atf::AtfTempl<SrvDate>::FromXmlString(_value, vipStatusUntil);
			}
			else if (_element.equals("missableMonthsYearly"))
			{
				missableMonthsYearly = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("gameAvatars"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< BrandProt::AvatarImg, 4 > >::FromXmlString(_value, gameAvatars)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(fullName1);
		_msg.composeString(fullName2);
		_msg.composeString(fullName3);
		_msg.composeString(fullName4);
		_msg.composeString(fullName5);
		_msg.composeString(fullName6);
		_msg.composeString(fullName7);
		_msg.composeString(fullName8);
		_msg._composeVarBlock(imgData.ptr(), imgData.size());
		_msg.composeUINT32(priv1);
		_msg.composeUINT32(priv2);
		_msg.composeUINT32(priv3);
		_msg.composeUINT32(priv4);
		_msg.composeUINT32(priv5);
		_msg.composeUINT32(priv6);
		_msg.composeUINT32(priv7);
		_msg.composeSrvDate(dob);
		_msg.composeString(phoneNum);
		phoneValidation.composeMsg(_msg, _ignoreJSON);
		_msg.composeString(firstName);
		_msg.composeString(onlyLastName);
		_msg.composeString(fiscalCode);
		userProps.composeMsg(_msg, _ignoreJSON);
		_msg.composeUINT64(flags2);
		_msg.composeUINT32(imgId);
		_msg.composeString(sex);
		_msg.composeString(mobile);
		_msg.composeBOOL(addressStateLocked);
		_msg.composeSrvTime(registered);
		mobilePhoneValidation.composeMsg(_msg, _ignoreJSON);
		_msg.composeString(promoImgCode);
		_msg.composeUINT32(pwdUpdateTime);
		_msg.composeUINT64(privileges3);
		_msg.composeINT8(missedMonths);
		_msg.composeSrvDate(vipStatusUntil);
		_msg.composeINT8(missableMonthsYearly);
		gameAvatars.composeMsg(_msg, _ignoreJSON);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(fullName1);
		_parser.parseStringP(fullName2);
		_parser.parseStringP(fullName3);
		_parser.parseStringP(fullName4);
		_parser.parseStringP(fullName5);
		_parser.parseStringP(fullName6);
		_parser.parseStringP(fullName7);
		_parser.parseStringP(fullName8);
		_parser.parsePBlock(imgData);
		_parser.parseUINT32(priv1);
		_parser.parseUINT32(priv2);
		_parser.parseUINT32(priv3);
		_parser.parseUINT32(priv4);
		_parser.parseUINT32(priv5);
		_parser.parseUINT32(priv6);
		_parser.parseUINT32(priv7);
		_parser.parseSrvDate(dob);
		_parser.parseStringP(phoneNum);
		phoneValidation.parseMsg(_parser);
		_parser.parseStringP(firstName);
		_parser.parseStringP(onlyLastName);
		_parser.parseStringP(fiscalCode);
		userProps.parseMsg(_parser);
		_parser.parseUINT64(flags2);
		_parser.parseUINT32(imgId);
		_parser.parseStringP(sex);
		_parser.parseStringP(mobile);
		_parser.parseBOOL(addressStateLocked);
		_parser.parseSrvTime(registered);
		mobilePhoneValidation.parseMsg(_parser);
		_parser.parseStringP(promoImgCode);
		_parser.parseUINT32(pwdUpdateTime);
		_parser.parseUINT64(privileges3);
		_parser.parseINT8(missedMonths);
		_parser.parseSrvDate(vipStatusUntil);
		_parser.parseINT8(missableMonthsYearly);
		gameAvatars.parseMsg(_parser);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("fullName1", fullName1);
		_jsonstr.compose("fullName2", fullName2);
		_jsonstr.compose("fullName3", fullName3);
		_jsonstr.compose("fullName4", fullName4);
		_jsonstr.compose("fullName5", fullName5);
		_jsonstr.compose("fullName6", fullName6);
		_jsonstr.compose("fullName7", fullName7);
		_jsonstr.compose("fullName8", fullName8);
		_jsonstr.compose("imgData", imgData);
		_jsonstr.compose("priv1", priv1);
		_jsonstr.compose("priv2", priv2);
		_jsonstr.compose("priv3", priv3);
		_jsonstr.compose("priv4", priv4);
		_jsonstr.compose("priv5", priv5);
		_jsonstr.compose("priv6", priv6);
		_jsonstr.compose("priv7", priv7);
		_jsonstr.compose("dob", dob);
		_jsonstr.compose("phoneNum", phoneNum);
		_jsonstr.compose("phoneValidation", phoneValidation);
		_jsonstr.compose("firstName", firstName);
		_jsonstr.compose("onlyLastName", onlyLastName);
		_jsonstr.compose("fiscalCode", fiscalCode);
		_jsonstr.compose("userProps", userProps);
		_jsonstr.compose("flags2", flags2);
		_jsonstr.compose("imgId", imgId);
		_jsonstr.compose("sex", sex);
		_jsonstr.compose("mobile", mobile);
		_jsonstr.compose("addressStateLocked", addressStateLocked);
		_jsonstr.compose("registered", registered);
		_jsonstr.compose("mobilePhoneValidation", mobilePhoneValidation);
		_jsonstr.compose("promoImgCode", promoImgCode);
		_jsonstr.compose("pwdUpdateTime", pwdUpdateTime);
		_jsonstr.compose("privileges3", privileges3);
		_jsonstr.compose("missedMonths", missedMonths);
		_jsonstr.compose("vipStatusUntil", vipStatusUntil);
		_jsonstr.compose("missableMonthsYearly", missableMonthsYearly);
		_jsonstr.compose("gameAvatars", gameAvatars);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("fullName1", fullName1);
		_jparser.parseByNameThrow("fullName2", fullName2);
		_jparser.parseByNameThrow("fullName3", fullName3);
		_jparser.parseByNameThrow("fullName4", fullName4);
		_jparser.parseByNameThrow("fullName5", fullName5);
		_jparser.parseByNameThrow("fullName6", fullName6);
		_jparser.parseByNameThrow("fullName7", fullName7);
		_jparser.parseByNameThrow("fullName8", fullName8);
		_jparser.parseByNameThrow("imgData", imgData);
		_jparser.parseByNameThrow("priv1", priv1);
		_jparser.parseByNameThrow("priv2", priv2);
		_jparser.parseByNameThrow("priv3", priv3);
		_jparser.parseByNameThrow("priv4", priv4);
		_jparser.parseByNameThrow("priv5", priv5);
		_jparser.parseByNameThrow("priv6", priv6);
		_jparser.parseByNameThrow("priv7", priv7);
		_jparser.parseByNameThrow("dob", dob);
		_jparser.parseByNameThrow("phoneNum", phoneNum);
		_jparser.parseByNameThrow("phoneValidation", phoneValidation);
		_jparser.parseByNameThrow("firstName", firstName);
		_jparser.parseByNameThrow("onlyLastName", onlyLastName);
		_jparser.parseByNameThrow("fiscalCode", fiscalCode);
		_jparser.parseByNameThrow("userProps", userProps);
		_jparser.parseByNameThrow("flags2", flags2);
		_jparser.parseByNameThrow("imgId", imgId);
		_jparser.parseByNameThrow("sex", sex);
		_jparser.parseByNameThrow("mobile", mobile);
		_jparser.parseByNameThrow("addressStateLocked", addressStateLocked);
		_jparser.parseByNameThrow("registered", registered);
		_jparser.parseByNameThrow("mobilePhoneValidation", mobilePhoneValidation);
		_jparser.parseByNameThrow("promoImgCode", promoImgCode);
		_jparser.parseByNameThrow("pwdUpdateTime", pwdUpdateTime);
		_jparser.parseByNameThrow("privileges3", privileges3);
		_jparser.parseByNameThrow("missedMonths", missedMonths);
		_jparser.parseByNameThrow("vipStatusUntil", vipStatusUntil);
		_jparser.parseByNameThrow("missableMonthsYearly", missableMonthsYearly);
		_jparser.parseByNameThrow("gameAvatars", gameAvatars);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_USER_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString fullName1; _jparser.validateByNameThrow("fullName1", fullName1);
		AtfValidator::validateInt(_descr, "fullName1", fullName1.length(), _checker, __FILE__, __LINE__);
		PString fullName2; _jparser.validateByNameThrow("fullName2", fullName2);
		AtfValidator::validateInt(_descr, "fullName2", fullName2.length(), _checker, __FILE__, __LINE__);
		PString fullName3; _jparser.validateByNameThrow("fullName3", fullName3);
		AtfValidator::validateInt(_descr, "fullName3", fullName3.length(), _checker, __FILE__, __LINE__);
		PString fullName4; _jparser.validateByNameThrow("fullName4", fullName4);
		AtfValidator::validateInt(_descr, "fullName4", fullName4.length(), _checker, __FILE__, __LINE__);
		PString fullName5; _jparser.validateByNameThrow("fullName5", fullName5);
		AtfValidator::validateInt(_descr, "fullName5", fullName5.length(), _checker, __FILE__, __LINE__);
		PString fullName6; _jparser.validateByNameThrow("fullName6", fullName6);
		AtfValidator::validateInt(_descr, "fullName6", fullName6.length(), _checker, __FILE__, __LINE__);
		PString fullName7; _jparser.validateByNameThrow("fullName7", fullName7);
		AtfValidator::validateInt(_descr, "fullName7", fullName7.length(), _checker, __FILE__, __LINE__);
		PString fullName8; _jparser.validateByNameThrow("fullName8", fullName8);
		AtfValidator::validateInt(_descr, "fullName8", fullName8.length(), _checker, __FILE__, __LINE__);
		PBlock imgData; _jparser.validateByNameThrow("imgData", imgData);
		AtfValidator::validateInt(_descr, "imgData", imgData.size(), _checker, __FILE__, __LINE__);
		UINT32 priv1; _jparser.validateByNameThrow("priv1", priv1);
		AtfValidator::validateInt(_descr, "priv1", priv1, _checker, __FILE__, __LINE__);
		UINT32 priv2; _jparser.validateByNameThrow("priv2", priv2);
		AtfValidator::validateInt(_descr, "priv2", priv2, _checker, __FILE__, __LINE__);
		UINT32 priv3; _jparser.validateByNameThrow("priv3", priv3);
		AtfValidator::validateInt(_descr, "priv3", priv3, _checker, __FILE__, __LINE__);
		UINT32 priv4; _jparser.validateByNameThrow("priv4", priv4);
		AtfValidator::validateInt(_descr, "priv4", priv4, _checker, __FILE__, __LINE__);
		UINT32 priv5; _jparser.validateByNameThrow("priv5", priv5);
		AtfValidator::validateInt(_descr, "priv5", priv5, _checker, __FILE__, __LINE__);
		UINT32 priv6; _jparser.validateByNameThrow("priv6", priv6);
		AtfValidator::validateInt(_descr, "priv6", priv6, _checker, __FILE__, __LINE__);
		UINT32 priv7; _jparser.validateByNameThrow("priv7", priv7);
		AtfValidator::validateInt(_descr, "priv7", priv7, _checker, __FILE__, __LINE__);
		SrvDate dob; _jparser.validateByNameThrow("dob", dob);
		AtfValidator::validateSrvDateTime(_descr, "dob", dob, _checker, __FILE__, __LINE__);
		PString phoneNum; _jparser.validateByNameThrow("phoneNum", phoneNum);
		AtfValidator::validateInt(_descr, "phoneNum", phoneNum.length(), _checker, __FILE__, __LINE__);
		PhoneValidationInfo phoneValidation; _jparser.validateByNameThrow("phoneValidation", phoneValidation);
		PString firstName; _jparser.validateByNameThrow("firstName", firstName);
		AtfValidator::validateInt(_descr, "firstName", firstName.length(), _checker, __FILE__, __LINE__);
		PString onlyLastName; _jparser.validateByNameThrow("onlyLastName", onlyLastName);
		AtfValidator::validateInt(_descr, "onlyLastName", onlyLastName.length(), _checker, __FILE__, __LINE__);
		PString fiscalCode; _jparser.validateByNameThrow("fiscalCode", fiscalCode);
		AtfValidator::validateInt(_descr, "fiscalCode", fiscalCode.length(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< UserProperties > userProps; _jparser.validateByNameThrow("userProps", userProps);
		AtfValidator::validateInt(_descr, "userProps", userProps.size(), _checker, __FILE__, __LINE__);
		UINT64 flags2; _jparser.validateByNameThrow("flags2", flags2);
		AtfValidator::validateUint(_descr, "flags2", flags2, _checker, __FILE__, __LINE__);
		UINT32 imgId; _jparser.validateByNameThrow("imgId", imgId);
		AtfValidator::validateInt(_descr, "imgId", imgId, _checker, __FILE__, __LINE__);
		PString sex; _jparser.validateByNameThrow("sex", sex);
		AtfValidator::validateInt(_descr, "sex", sex.length(), _checker, __FILE__, __LINE__);
		PString mobile; _jparser.validateByNameThrow("mobile", mobile);
		AtfValidator::validateInt(_descr, "mobile", mobile.length(), _checker, __FILE__, __LINE__);
		bool addressStateLocked; _jparser.validateByNameThrow("addressStateLocked", addressStateLocked);
		AtfValidator::validateInt(_descr, "addressStateLocked", addressStateLocked, _checker, __FILE__, __LINE__);
		SrvTime registered; _jparser.validateByNameThrow("registered", registered);
		AtfValidator::validateSrvDateTime(_descr, "registered", registered, _checker, __FILE__, __LINE__);
		PhoneValidationInfo mobilePhoneValidation; _jparser.validateByNameThrow("mobilePhoneValidation", mobilePhoneValidation);
		PString promoImgCode; _jparser.validateByNameThrow("promoImgCode", promoImgCode);
		AtfValidator::validateInt(_descr, "promoImgCode", promoImgCode.length(), _checker, __FILE__, __LINE__);
		UINT32 pwdUpdateTime; _jparser.validateByNameThrow("pwdUpdateTime", pwdUpdateTime);
		AtfValidator::validateInt(_descr, "pwdUpdateTime", pwdUpdateTime, _checker, __FILE__, __LINE__);
		UINT64 privileges3; _jparser.validateByNameThrow("privileges3", privileges3);
		AtfValidator::validateUint(_descr, "privileges3", privileges3, _checker, __FILE__, __LINE__);
		INT8 missedMonths; _jparser.validateByNameThrow("missedMonths", missedMonths);
		AtfValidator::validateInt(_descr, "missedMonths", missedMonths, _checker, __FILE__, __LINE__);
		SrvDate vipStatusUntil; _jparser.validateByNameThrow("vipStatusUntil", vipStatusUntil);
		AtfValidator::validateSrvDateTime(_descr, "vipStatusUntil", vipStatusUntil, _checker, __FILE__, __LINE__);
		INT8 missableMonthsYearly; _jparser.validateByNameThrow("missableMonthsYearly", missableMonthsYearly);
		AtfValidator::validateInt(_descr, "missableMonthsYearly", missableMonthsYearly, _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< BrandProt::AvatarImg > gameAvatars; _jparser.validateByNameThrow("gameAvatars", gameAvatars);
		AtfValidator::validateInt(_descr, "gameAvatars", gameAvatars.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_GET_USER_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_USER_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "fullName1"); size_t szFullName1 = strlen(_dummy);
		AtfValidator::validateInt(_descr, "fullName1", szFullName1, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "fullName2"); size_t szFullName2 = strlen(_dummy);
		AtfValidator::validateInt(_descr, "fullName2", szFullName2, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "fullName3"); size_t szFullName3 = strlen(_dummy);
		AtfValidator::validateInt(_descr, "fullName3", szFullName3, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "fullName4"); size_t szFullName4 = strlen(_dummy);
		AtfValidator::validateInt(_descr, "fullName4", szFullName4, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "fullName5"); size_t szFullName5 = strlen(_dummy);
		AtfValidator::validateInt(_descr, "fullName5", szFullName5, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "fullName6"); size_t szFullName6 = strlen(_dummy);
		AtfValidator::validateInt(_descr, "fullName6", szFullName6, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "fullName7"); size_t szFullName7 = strlen(_dummy);
		AtfValidator::validateInt(_descr, "fullName7", szFullName7, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "fullName8"); size_t szFullName8 = strlen(_dummy);
		AtfValidator::validateInt(_descr, "fullName8", szFullName8, _checker, __FILE__, __LINE__);
		const BYTE* imgData; size_t szImgData; _parser._parseVarBlock(imgData, szImgData);  /*imgData*/
		AtfValidator::validateInt(_descr, "imgData", szImgData, _checker, __FILE__, __LINE__);
		UINT32 priv1; _parser.parseUINT32(priv1);
		AtfValidator::validateInt(_descr, "priv1", priv1, _checker, __FILE__, __LINE__);
		UINT32 priv2; _parser.parseUINT32(priv2);
		AtfValidator::validateInt(_descr, "priv2", priv2, _checker, __FILE__, __LINE__);
		UINT32 priv3; _parser.parseUINT32(priv3);
		AtfValidator::validateInt(_descr, "priv3", priv3, _checker, __FILE__, __LINE__);
		UINT32 priv4; _parser.parseUINT32(priv4);
		AtfValidator::validateInt(_descr, "priv4", priv4, _checker, __FILE__, __LINE__);
		UINT32 priv5; _parser.parseUINT32(priv5);
		AtfValidator::validateInt(_descr, "priv5", priv5, _checker, __FILE__, __LINE__);
		UINT32 priv6; _parser.parseUINT32(priv6);
		AtfValidator::validateInt(_descr, "priv6", priv6, _checker, __FILE__, __LINE__);
		UINT32 priv7; _parser.parseUINT32(priv7);
		AtfValidator::validateInt(_descr, "priv7", priv7, _checker, __FILE__, __LINE__);
		SrvDate dob; _parser.parseSrvDate(dob);
		AtfValidator::validateSrvDateTime(_descr, "dob", dob, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "phoneNum"); size_t szPhoneNum = strlen(_dummy);
		AtfValidator::validateInt(_descr, "phoneNum", szPhoneNum, _checker, __FILE__, __LINE__);
		PString _descbuf;
		PhoneValidationInfo::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("phoneValidation"), _fieldsWithUnparsedContent);
		_parser.parseStringN(_dummy, 0, "firstName"); size_t szFirstName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "firstName", szFirstName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "onlyLastName"); size_t szOnlyLastName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "onlyLastName", szOnlyLastName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "fiscalCode"); size_t szFiscalCode = strlen(_dummy);
		AtfValidator::validateInt(_descr, "fiscalCode", szFiscalCode, _checker, __FILE__, __LINE__);
		int szUserProps = Atf::LAtfVector< UserProperties, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("userProps"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "userProps", szUserProps, _checker, __FILE__, __LINE__);
		UINT64 flags2; _parser.parseUINT64(flags2);
		AtfValidator::validateUint(_descr, "flags2", flags2, _checker, __FILE__, __LINE__);
		UINT32 imgId; _parser.parseUINT32(imgId);
		AtfValidator::validateInt(_descr, "imgId", imgId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "sex"); size_t szSex = strlen(_dummy);
		AtfValidator::validateInt(_descr, "sex", szSex, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "mobile"); size_t szMobile = strlen(_dummy);
		AtfValidator::validateInt(_descr, "mobile", szMobile, _checker, __FILE__, __LINE__);
		bool addressStateLocked; _parser.parseBOOL(addressStateLocked);
		AtfValidator::validateInt(_descr, "addressStateLocked", addressStateLocked, _checker, __FILE__, __LINE__);
		SrvTime registered; _parser.parseSrvTime(registered);
		AtfValidator::validateSrvDateTime(_descr, "registered", registered, _checker, __FILE__, __LINE__);
		PhoneValidationInfo::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("mobilePhoneValidation"), _fieldsWithUnparsedContent);
		_parser.parseStringN(_dummy, 0, "promoImgCode"); size_t szPromoImgCode = strlen(_dummy);
		AtfValidator::validateInt(_descr, "promoImgCode", szPromoImgCode, _checker, __FILE__, __LINE__);
		UINT32 pwdUpdateTime; _parser.parseUINT32(pwdUpdateTime);
		AtfValidator::validateInt(_descr, "pwdUpdateTime", pwdUpdateTime, _checker, __FILE__, __LINE__);
		UINT64 privileges3; _parser.parseUINT64(privileges3);
		AtfValidator::validateUint(_descr, "privileges3", privileges3, _checker, __FILE__, __LINE__);
		INT8 missedMonths; _parser.parseINT8(missedMonths);
		AtfValidator::validateInt(_descr, "missedMonths", missedMonths, _checker, __FILE__, __LINE__);
		SrvDate vipStatusUntil; _parser.parseSrvDate(vipStatusUntil);
		AtfValidator::validateSrvDateTime(_descr, "vipStatusUntil", vipStatusUntil, _checker, __FILE__, __LINE__);
		INT8 missableMonthsYearly; _parser.parseINT8(missableMonthsYearly);
		AtfValidator::validateInt(_descr, "missableMonthsYearly", missableMonthsYearly, _checker, __FILE__, __LINE__);
		int szGameAvatars = Atf::LAtfVector< BrandProt::AvatarImg, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("gameAvatars"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "gameAvatars", szGameAvatars, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_WAITING_LIST
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST::Protocol_MSG_LOBBY_WAITING_LIST()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST::Protocol_MSG_LOBBY_WAITING_LIST(Protocol_MSG_LOBBY_WAITING_LIST&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, listType(std::move(_o.listType))
	, tableId32(std::move(_o.tableId32))
	, tableId64(std::move(_o.tableId64))
{
}

Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST& Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST::operator=(Protocol_MSG_LOBBY_WAITING_LIST&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		listType = std::move(_o.listType);
		tableId32 = std::move(_o.tableId32);
		tableId64 = std::move(_o.tableId64);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST::clear()
{
	notUsedStr.clear();
	listType = 0;
	tableId32 = 0;
	tableId64 = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST::equals(const Protocol_MSG_LOBBY_WAITING_LIST& _o) const
{
	return Atf::atfPStringEquals(notUsedStr, _o.notUsedStr) &&
		listType == _o.listType &&
		tableId32 == _o.tableId32 &&
		tableId64 == _o.tableId64;
}

bool Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_WAITING_LIST != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_WAITING_LIST*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_WAITING_LIST).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("listType=");
	_buf.appendUint(listType);
	_buf.append(',');
	_buf.append("tableId32=");
	_buf.appendUint(tableId32);
	_buf.append(',');
	_buf.append("tableId64=");
	_buf.appendUint64(tableId64);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_WAITING_LIST).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsedStr", notUsedStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("listType", listType, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableId32", tableId32, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableId64", tableId64, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedStr)) return false;
			}
			else if (_element.equals("listType"))
			{
				listType = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tableId32"))
			{
				tableId32 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tableId64"))
			{
				tableId64 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsedStr);
	_msg.composeBYTE(listType);
	_msg.composeUINT32(tableId32);
	_msg.composeUINT64(tableId64);
}

void Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseBYTE(listType);
	_parser.parseUINT32(tableId32);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(tableId64);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsedStr", notUsedStr);
	_jsonstr.compose("listType", listType);
	_jsonstr.compose("tableId32", tableId32);
	_jsonstr.compose("tableId64", tableId64);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsedStr", notUsedStr);
	_jparser.parseByNameThrow("listType", listType);
	_jparser.parseByNameThrow("tableId32", tableId32);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tableId64", tableId64);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_WAITING_LIST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsedStr; _jparser.validateByNameThrow("notUsedStr", notUsedStr);
	AtfValidator::validateIntMax(_descr, "notUsedStr", notUsedStr.length(), 20, _checker, __FILE__, __LINE__);
	BYTE listType; _jparser.validateByNameThrow("listType", listType);
	AtfValidator::validateInt(_descr, "listType", listType, _checker, __FILE__, __LINE__);
	UINT32 tableId32; _jparser.validateByNameThrow("tableId32", tableId32);
	AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT64 tableId64; _jparser.validateByNameThrow("tableId64", tableId64);
	AtfValidator::validateUint(_descr, "tableId64", tableId64, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_WAITING_LIST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	BYTE listType; _parser.parseBYTE(listType);
	AtfValidator::validateInt(_descr, "listType", listType, _checker, __FILE__, __LINE__);
	UINT32 tableId32; _parser.parseUINT32(tableId32);
	AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 tableId64; _parser.parseUINT64(tableId64);
	AtfValidator::validateUint(_descr, "tableId64", tableId64, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_WAITING_LIST_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST_REPLY::Protocol_MSG_LOBBY_WAITING_LIST_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST_REPLY::Protocol_MSG_LOBBY_WAITING_LIST_REPLY(Protocol_MSG_LOBBY_WAITING_LIST_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, tableId32(std::move(_o.tableId32))
	, tableId64(std::move(_o.tableId64))
{
}

Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST_REPLY& Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST_REPLY::operator=(Protocol_MSG_LOBBY_WAITING_LIST_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		tableId32 = std::move(_o.tableId32);
		tableId64 = std::move(_o.tableId64);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	tableId32 = 0;
	tableId64 = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST_REPLY::equals(const Protocol_MSG_LOBBY_WAITING_LIST_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		tableId32 == _o.tableId32 &&
		tableId64 == _o.tableId64;
}

bool Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_WAITING_LIST_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_WAITING_LIST_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_WAITING_LIST_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("tableId32=");
		_buf.appendUint(tableId32);
		_buf.append(',');
		_buf.append("tableId64=");
		_buf.appendUint64(tableId64);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_WAITING_LIST_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("tableId32", tableId32, _buf);
		Atf::XmlElement::encodeAsXmlElement("tableId64", tableId64, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("tableId32"))
			{
				tableId32 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tableId64"))
			{
				tableId64 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(tableId32);
		_msg.composeUINT64(tableId64);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(tableId32);
		_parser.parseUINT64(tableId64);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("tableId32", tableId32);
		_jsonstr.compose("tableId64", tableId64);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("tableId32", tableId32);
		_jparser.parseByNameThrow("tableId64", tableId64);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_WAITING_LIST_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 tableId32; _jparser.validateByNameThrow("tableId32", tableId32);
		AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
		UINT64 tableId64; _jparser.validateByNameThrow("tableId64", tableId64);
		AtfValidator::validateUint(_descr, "tableId64", tableId64, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_WAITING_LIST_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_WAITING_LIST_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 tableId32; _parser.parseUINT32(tableId32);
		AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
		UINT64 tableId64; _parser.parseUINT64(tableId64);
		AtfValidator::validateUint(_descr, "tableId64", tableId64, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_LIST_REMOVE
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_LIST_REMOVE::Protocol_MSG_LOBBY_LIST_REMOVE()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_LIST_REMOVE::clear()
{
}

bool Lobby::cli::Protocol_MSG_LOBBY_LIST_REMOVE::equals(const Protocol_MSG_LOBBY_LIST_REMOVE& _o) const
{
	return true;
}

bool Lobby::cli::Protocol_MSG_LOBBY_LIST_REMOVE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_LIST_REMOVE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_LIST_REMOVE*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_LIST_REMOVE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_LIST_REMOVE).append(")");
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_LIST_REMOVE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_LIST_REMOVE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_LIST_REMOVE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_LIST_REMOVE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_LIST_REMOVE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void Lobby::cli::Protocol_MSG_LOBBY_LIST_REMOVE::parseMsg(CommMsgParser& _parser)
{
}

const char *Lobby::cli::Protocol_MSG_LOBBY_LIST_REMOVE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_LIST_REMOVE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_LIST_REMOVE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_LIST_REMOVE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_LIST_REMOVE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_LIST_REMOVE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_LEAVE_WAITING_LIST
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST(Protocol_MSG_LOBBY_LEAVE_WAITING_LIST&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, listType(std::move(_o.listType))
	, tableId32(std::move(_o.tableId32))
	, tableId64(std::move(_o.tableId64))
{
}

Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST& Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST::operator=(Protocol_MSG_LOBBY_LEAVE_WAITING_LIST&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		listType = std::move(_o.listType);
		tableId32 = std::move(_o.tableId32);
		tableId64 = std::move(_o.tableId64);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST::clear()
{
	notUsedStr.clear();
	listType = 0;
	tableId32 = 0;
	tableId64 = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST::equals(const Protocol_MSG_LOBBY_LEAVE_WAITING_LIST& _o) const
{
	return Atf::atfPStringEquals(notUsedStr, _o.notUsedStr) &&
		listType == _o.listType &&
		tableId32 == _o.tableId32 &&
		tableId64 == _o.tableId64;
}

bool Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_LEAVE_WAITING_LIST != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_LEAVE_WAITING_LIST*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_LEAVE_WAITING_LIST).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("listType=");
	_buf.appendUint(listType);
	_buf.append(',');
	_buf.append("tableId32=");
	_buf.appendUint(tableId32);
	_buf.append(',');
	_buf.append("tableId64=");
	_buf.appendUint64(tableId64);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_LEAVE_WAITING_LIST).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsedStr", notUsedStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("listType", listType, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableId32", tableId32, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableId64", tableId64, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedStr)) return false;
			}
			else if (_element.equals("listType"))
			{
				listType = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tableId32"))
			{
				tableId32 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tableId64"))
			{
				tableId64 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsedStr);
	_msg.composeBYTE(listType);
	_msg.composeUINT32(tableId32);
	_msg.composeUINT64(tableId64);
}

void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseBYTE(listType);
	_parser.parseUINT32(tableId32);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(tableId64);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsedStr", notUsedStr);
	_jsonstr.compose("listType", listType);
	_jsonstr.compose("tableId32", tableId32);
	_jsonstr.compose("tableId64", tableId64);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsedStr", notUsedStr);
	_jparser.parseByNameThrow("listType", listType);
	_jparser.parseByNameThrow("tableId32", tableId32);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tableId64", tableId64);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_LEAVE_WAITING_LIST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsedStr; _jparser.validateByNameThrow("notUsedStr", notUsedStr);
	AtfValidator::validateIntMax(_descr, "notUsedStr", notUsedStr.length(), 20, _checker, __FILE__, __LINE__);
	BYTE listType; _jparser.validateByNameThrow("listType", listType);
	AtfValidator::validateInt(_descr, "listType", listType, _checker, __FILE__, __LINE__);
	UINT32 tableId32; _jparser.validateByNameThrow("tableId32", tableId32);
	AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT64 tableId64; _jparser.validateByNameThrow("tableId64", tableId64);
	AtfValidator::validateUint(_descr, "tableId64", tableId64, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_LEAVE_WAITING_LIST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	BYTE listType; _parser.parseBYTE(listType);
	AtfValidator::validateInt(_descr, "listType", listType, _checker, __FILE__, __LINE__);
	UINT32 tableId32; _parser.parseUINT32(tableId32);
	AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 tableId64; _parser.parseUINT64(tableId64);
	AtfValidator::validateUint(_descr, "tableId64", tableId64, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY(Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, tableId32(std::move(_o.tableId32))
	, tableId(std::move(_o.tableId))
{
}

Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY& Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY::operator=(Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		tableId32 = std::move(_o.tableId32);
		tableId = std::move(_o.tableId);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	tableId32 = 0;
	tableId = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY::equals(const Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		tableId32 == _o.tableId32 &&
		tableId == _o.tableId;
}

bool Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_LEAVE_WAITING_LIST_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_LEAVE_WAITING_LIST_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("tableId32=");
		_buf.appendUint(tableId32);
		_buf.append(',');
		_buf.append("tableId=");
		_buf.appendUint64(tableId);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_LEAVE_WAITING_LIST_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("tableId32", tableId32, _buf);
		Atf::XmlElement::encodeAsXmlElement("tableId", tableId, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("tableId32"))
			{
				tableId32 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tableId"))
			{
				tableId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(tableId32);
		_msg.composeUINT64(tableId);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(tableId32);
		_parser.parseUINT64(tableId);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("tableId32", tableId32);
		_jsonstr.compose("tableId", tableId);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("tableId32", tableId32);
		_jparser.parseByNameThrow("tableId", tableId);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_LEAVE_WAITING_LIST_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 tableId32; _jparser.validateByNameThrow("tableId32", tableId32);
		AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
		UINT64 tableId; _jparser.validateByNameThrow("tableId", tableId);
		AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_LEAVE_WAITING_LIST_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 tableId32; _parser.parseUINT32(tableId32);
		AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
		UINT64 tableId; _parser.parseUINT64(tableId);
		AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS()
{
	clear();
}

void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS::clear()
{
	flags = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS::equals(const Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS& _o) const
{
	return flags == _o.flags;
}

bool Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_LEAVE_ALL_WAITING_LISTS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_LEAVE_ALL_WAITING_LISTS).append(")");
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendInt(flags);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_LEAVE_ALL_WAITING_LISTS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("flags"))
			{
				flags = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(flags);
}

void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseINT32(flags);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("flags", flags);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("flags", flags);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_LEAVE_ALL_WAITING_LISTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	INT32 flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_LEAVE_ALL_WAITING_LISTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(_parser.parseEnded()) return;
	INT32 flags; _parser.parseINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY(Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, numTables(std::move(_o.numTables))
	, flags(std::move(_o.flags))
{
}

Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY& Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY::operator=(Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		numTables = std::move(_o.numTables);
		flags = std::move(_o.flags);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	numTables = 0;
	flags = 0;
}

bool Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY::equals(const Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		numTables == _o.numTables &&
		flags == _o.flags;
}

bool Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("numTables=");
		_buf.appendUint(numTables);
		_buf.append(',');
		_buf.append("flags=");
		_buf.appendUint(flags);
	}
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("numTables", numTables, _buf);
		Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("numTables"))
			{
				numTables = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("flags"))
			{
				flags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(numTables);
		_msg.composeUINT32(flags);
	}
}

void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(numTables);
		_parser.parseUINT32(flags);
	}
}

const char *Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("numTables", numTables);
		_jsonstr.compose("flags", flags);
	}
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("numTables", numTables);
		_jparser.parseByNameThrow("flags", flags);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 numTables; _jparser.validateByNameThrow("numTables", numTables);
		AtfValidator::validateInt(_descr, "numTables", numTables, _checker, __FILE__, __LINE__);
		UINT32 flags; _jparser.validateByNameThrow("flags", flags);
		AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 numTables; _parser.parseUINT32(numTables);
		AtfValidator::validateInt(_descr, "numTables", numTables, _checker, __FILE__, __LINE__);
		UINT32 flags; _parser.parseUINT32(flags);
		AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_WAITING_INVITED_REPLY
//=================================================================

Lobby::cli::Protocol_MSG_WAITING_INVITED_REPLY::Protocol_MSG_WAITING_INVITED_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::cli::Protocol_MSG_WAITING_INVITED_REPLY::Protocol_MSG_WAITING_INVITED_REPLY(Protocol_MSG_WAITING_INVITED_REPLY&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, tableId32(std::move(_o.tableId32))
	, answer(std::move(_o.answer))
	, leaveLists(std::move(_o.leaveLists))
	, tableId64(std::move(_o.tableId64))
{
}

Lobby::cli::Protocol_MSG_WAITING_INVITED_REPLY& Lobby::cli::Protocol_MSG_WAITING_INVITED_REPLY::operator=(Protocol_MSG_WAITING_INVITED_REPLY&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		tableId32 = std::move(_o.tableId32);
		answer = std::move(_o.answer);
		leaveLists = std::move(_o.leaveLists);
		tableId64 = std::move(_o.tableId64);
	}
	return *this;
}

#endif

void Lobby::cli::Protocol_MSG_WAITING_INVITED_REPLY::clear()
{
	notUsedStr.clear();
	tableId32 = 0;
	answer = 0;
	leaveLists = false;
	tableId64 = 0;
}

bool Lobby::cli::Protocol_MSG_WAITING_INVITED_REPLY::equals(const Protocol_MSG_WAITING_INVITED_REPLY& _o) const
{
	return Atf::atfPStringEquals(notUsedStr, _o.notUsedStr) &&
		tableId32 == _o.tableId32 &&
		answer == _o.answer &&
		leaveLists == _o.leaveLists &&
		tableId64 == _o.tableId64;
}

bool Lobby::cli::Protocol_MSG_WAITING_INVITED_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_WAITING_INVITED_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_WAITING_INVITED_REPLY*)_other));
}

const char *Lobby::cli::Protocol_MSG_WAITING_INVITED_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_WAITING_INVITED_REPLY).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("tableId32=");
	_buf.appendUint(tableId32);
	_buf.append(',');
	_buf.append("answer=");
	_buf.appendUint(answer);
	_buf.append(',');
	_buf.append("leaveLists=");
	_buf.appendUint(leaveLists);
	_buf.append(',');
	_buf.append("tableId64=");
	_buf.appendUint64(tableId64);
	return _buf.c_str();
}

const char *Lobby::cli::Protocol_MSG_WAITING_INVITED_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::cli::Protocol_MSG_WAITING_INVITED_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_WAITING_INVITED_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsedStr", notUsedStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableId32", tableId32, _buf);
	Atf::XmlElement::encodeAsXmlElement("answer", answer, _buf);
	Atf::XmlElement::encodeAsXmlElement("leaveLists", leaveLists, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableId64", tableId64, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::cli::Protocol_MSG_WAITING_INVITED_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedStr)) return false;
			}
			else if (_element.equals("tableId32"))
			{
				tableId32 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("answer"))
			{
				answer = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("leaveLists"))
			{
				leaveLists = (*_value.ptr() == '1');
			}
			else if (_element.equals("tableId64"))
			{
				tableId64 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::cli::Protocol_MSG_WAITING_INVITED_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsedStr);
	_msg.composeUINT32(tableId32);
	_msg.composeBYTE(answer);
	_msg.composeBOOL(leaveLists);
	_msg.composeUINT64(tableId64);
}

void Lobby::cli::Protocol_MSG_WAITING_INVITED_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseUINT32(tableId32);
	_parser.parseBYTE(answer);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(leaveLists);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(tableId64);
}

const char *Lobby::cli::Protocol_MSG_WAITING_INVITED_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsedStr", notUsedStr);
	_jsonstr.compose("tableId32", tableId32);
	_jsonstr.compose("answer", answer);
	_jsonstr.compose("leaveLists", leaveLists);
	_jsonstr.compose("tableId64", tableId64);
	return _buf.c_str();
}

void Lobby::cli::Protocol_MSG_WAITING_INVITED_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsedStr", notUsedStr);
	_jparser.parseByNameThrow("tableId32", tableId32);
	_jparser.parseByNameThrow("answer", answer);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("leaveLists", leaveLists);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tableId64", tableId64);
}

/*static*/ void Lobby::cli::Protocol_MSG_WAITING_INVITED_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_WAITING_INVITED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsedStr; _jparser.validateByNameThrow("notUsedStr", notUsedStr);
	AtfValidator::validateIntMax(_descr, "notUsedStr", notUsedStr.length(), 20, _checker, __FILE__, __LINE__);
	UINT32 tableId32; _jparser.validateByNameThrow("tableId32", tableId32);
	AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
	BYTE answer; _jparser.validateByNameThrow("answer", answer);
	AtfValidator::validateIntMax(_descr, "answer", answer, 1, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool leaveLists; _jparser.validateByNameThrow("leaveLists", leaveLists);
	AtfValidator::validateInt(_descr, "leaveLists", leaveLists, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT64 tableId64; _jparser.validateByNameThrow("tableId64", tableId64);
	AtfValidator::validateUint(_descr, "tableId64", tableId64, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::cli::Protocol_MSG_WAITING_INVITED_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_WAITING_INVITED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	UINT32 tableId32; _parser.parseUINT32(tableId32);
	AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
	BYTE answer; _parser.parseBYTE(answer);
	AtfValidator::validateIntMax(_descr, "answer", answer, 1, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool leaveLists; _parser.parseBOOL(leaveLists);
	AtfValidator::validateInt(_descr, "leaveLists", leaveLists, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 tableId64; _parser.parseUINT64(tableId64);
	AtfValidator::validateUint(_descr, "tableId64", tableId64, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CLIENT_ERROR
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR::Protocol_MSG_LOBBY_CLIENT_ERROR()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR::Protocol_MSG_LOBBY_CLIENT_ERROR(Protocol_MSG_LOBBY_CLIENT_ERROR&& _o)
	: userId(std::move(_o.userId))
	, info(std::move(_o.info))
{
}

Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR& Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR::operator=(Protocol_MSG_LOBBY_CLIENT_ERROR&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		info = std::move(_o.info);
	}
	return *this;
}

#endif

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR::clear()
{
	userId.clear();
	info.clear();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR::equals(const Protocol_MSG_LOBBY_CLIENT_ERROR& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		Atf::atfPStringEquals(info, _o.info);
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_CLIENT_ERROR != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_CLIENT_ERROR*)_other));
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CLIENT_ERROR).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("info=");
	_buf.append(info);
	return _buf.c_str();
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_CLIENT_ERROR).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("info", info, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("info"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, info)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeString(info);
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseStringP(info);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("info", info);
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("info", info);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLIENT_ERROR";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), 20, _checker, __FILE__, __LINE__);
	PString info; _jparser.validateByNameThrow("info", info);
	AtfValidator::validateIntMax(_descr, "info", info.length(), 100000, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLIENT_ERROR";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, 20, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "info"); size_t szInfo = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "info", szInfo, 100000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CLIENT_ERROR_REPLY
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR_REPLY::Protocol_MSG_LOBBY_CLIENT_ERROR_REPLY()
{
	clear();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR_REPLY::clear()
{
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR_REPLY::equals(const Protocol_MSG_LOBBY_CLIENT_ERROR_REPLY& _o) const
{
	return true;
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_CLIENT_ERROR_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_CLIENT_ERROR_REPLY*)_other));
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CLIENT_ERROR_REPLY).append(")");
	return _buf.c_str();
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_CLIENT_ERROR_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR_REPLY::parseMsg(CommMsgParser& _parser)
{
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLIENT_ERROR_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CLIENT_ERROR_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_REPORT_INSTALL
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_REPORT_INSTALL::Protocol_MSG_LOBBY_REPORT_INSTALL()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::lobby_unauth::Protocol_MSG_LOBBY_REPORT_INSTALL::Protocol_MSG_LOBBY_REPORT_INSTALL(Protocol_MSG_LOBBY_REPORT_INSTALL&& _o)
	: installId(std::move(_o.installId))
	, wuid(std::move(_o.wuid))
	, promo(std::move(_o.promo))
	, whenStr(std::move(_o.whenStr))
	, siteId(std::move(_o.siteId))
	, platformId(std::move(_o.platformId))
	, extraData(std::move(_o.extraData))
{
}

Lobby::lobby_unauth::Protocol_MSG_LOBBY_REPORT_INSTALL& Lobby::lobby_unauth::Protocol_MSG_LOBBY_REPORT_INSTALL::operator=(Protocol_MSG_LOBBY_REPORT_INSTALL&& _o)
{
	if(this != &_o)
	{
		installId = std::move(_o.installId);
		wuid = std::move(_o.wuid);
		promo = std::move(_o.promo);
		whenStr = std::move(_o.whenStr);
		siteId = std::move(_o.siteId);
		platformId = std::move(_o.platformId);
		extraData = std::move(_o.extraData);
	}
	return *this;
}

#endif

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_REPORT_INSTALL::clear()
{
	installId.clear();
	wuid.clear();
	promo.clear();
	whenStr.clear();
	siteId = 0;
	platformId = 0;
	extraData.clear();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_REPORT_INSTALL::equals(const Protocol_MSG_LOBBY_REPORT_INSTALL& _o) const
{
	return Atf::atfPStringEquals(installId, _o.installId) &&
		Atf::atfPStringEquals(wuid, _o.wuid) &&
		Atf::atfPStringEquals(promo, _o.promo) &&
		Atf::atfPStringEquals(whenStr, _o.whenStr) &&
		siteId == _o.siteId &&
		platformId == _o.platformId &&
		extraData.equals(_o.extraData);
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_REPORT_INSTALL::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_REPORT_INSTALL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_REPORT_INSTALL*)_other));
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_REPORT_INSTALL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_REPORT_INSTALL).append(")");
	_buf.append(',');
	_buf.append("installId=");
	_buf.append(installId);
	_buf.append(',');
	_buf.append("wuid=");
	_buf.append(wuid);
	_buf.append(',');
	_buf.append("promo=");
	_buf.append(promo);
	_buf.append(',');
	_buf.append("whenStr=");
	_buf.append(whenStr);
	_buf.append(',');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("platformId=");
	_buf.appendUint(platformId);
	_buf.append(',');
	_buf.append("extraData=");
	extraData.toTraceString(_buf);
	return _buf.c_str();
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_REPORT_INSTALL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_REPORT_INSTALL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_REPORT_INSTALL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("installId", installId, _buf);
	Atf::XmlElement::encodeAsXmlElement("wuid", wuid, _buf);
	Atf::XmlElement::encodeAsXmlElement("promo", promo, _buf);
	Atf::XmlElement::encodeAsXmlElement("whenStr", whenStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("siteId", siteId, _buf);
	Atf::XmlElement::encodeAsXmlElement("platformId", platformId, _buf);
	extraData.toXmlString("extraData", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_REPORT_INSTALL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("installId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, installId)) return false;
			}
			else if (_element.equals("wuid"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, wuid)) return false;
			}
			else if (_element.equals("promo"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, promo)) return false;
			}
			else if (_element.equals("whenStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, whenStr)) return false;
			}
			else if (_element.equals("siteId"))
			{
				siteId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("platformId"))
			{
				platformId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("extraData"))
			{
				if(!Atf::AtfTempl< Common::AtfShared::LoginExtra >::FromXmlString(_value, extraData)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_REPORT_INSTALL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(installId);
	_msg.composeString(wuid);
	_msg.composeString(promo);
	_msg.composeString(whenStr);
	_msg.composeUINT32(siteId);
	_msg.composeUINT32(platformId);
	extraData.composeMsg(_msg, _ignoreJSON);
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_REPORT_INSTALL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(installId);
	_parser.parseStringP(wuid);
	_parser.parseStringP(promo);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(whenStr);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(siteId);
	_parser.parseUINT32(platformId);
	if(_parser.parseEnded()) return;
	extraData.parseMsg(_parser);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_REPORT_INSTALL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("installId", installId);
	_jsonstr.compose("wuid", wuid);
	_jsonstr.compose("promo", promo);
	_jsonstr.compose("whenStr", whenStr);
	_jsonstr.compose("siteId", siteId);
	_jsonstr.compose("platformId", platformId);
	_jsonstr.compose("extraData", extraData);
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_REPORT_INSTALL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("installId", installId);
	_jparser.parseByNameThrow("wuid", wuid);
	_jparser.parseByNameThrow("promo", promo);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("whenStr", whenStr);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("siteId", siteId);
	_jparser.parseByNameThrow("platformId", platformId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("extraData", extraData);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_REPORT_INSTALL::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_REPORT_INSTALL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString installId; _jparser.validateByNameThrow("installId", installId);
	AtfValidator::validateIntMax(_descr, "installId", installId.length(), 100, _checker, __FILE__, __LINE__);
	PString wuid; _jparser.validateByNameThrow("wuid", wuid);
	AtfValidator::validateIntMax(_descr, "wuid", wuid.length(), 1000, _checker, __FILE__, __LINE__);
	PString promo; _jparser.validateByNameThrow("promo", promo);
	AtfValidator::validateIntMax(_descr, "promo", promo.length(), 1000, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString whenStr; _jparser.validateByNameThrow("whenStr", whenStr);
	AtfValidator::validateIntMax(_descr, "whenStr", whenStr.length(), 100, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 siteId; _jparser.validateByNameThrow("siteId", siteId);
	AtfValidator::validateIntMax(_descr, "siteId", siteId, PokerStars_Last, _checker, __FILE__, __LINE__);
	UINT32 platformId; _jparser.validateByNameThrow("platformId", platformId);
	AtfValidator::validateIntMax(_descr, "platformId", platformId, Client_Last, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	Common::AtfShared::LoginExtra extraData; _jparser.validateByNameThrow("extraData", extraData);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_REPORT_INSTALL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_REPORT_INSTALL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "installId"); size_t szInstallId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "installId", szInstallId, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "wuid"); size_t szWuid = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "wuid", szWuid, 1000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "promo"); size_t szPromo = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "promo", szPromo, 1000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "whenStr"); size_t szWhenStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "whenStr", szWhenStr, 100, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 siteId; _parser.parseUINT32(siteId);
	AtfValidator::validateIntMax(_descr, "siteId", siteId, PokerStars_Last, _checker, __FILE__, __LINE__);
	UINT32 platformId; _parser.parseUINT32(platformId);
	AtfValidator::validateIntMax(_descr, "platformId", platformId, Client_Last, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PString _descbuf;
	Common::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("extraData"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_PROMO_COUNTRY
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY::Protocol_MSG_LOBBY_PROMO_COUNTRY()
{
	clear();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY::clear()
{
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY::equals(const Protocol_MSG_LOBBY_PROMO_COUNTRY& _o) const
{
	return true;
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_PROMO_COUNTRY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_PROMO_COUNTRY*)_other));
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_PROMO_COUNTRY).append(")");
	return _buf.c_str();
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_PROMO_COUNTRY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY::parseMsg(CommMsgParser& _parser)
{
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_PROMO_COUNTRY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_PROMO_COUNTRY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_PROMO_COUNTRY_REPLY
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY_REPLY::Protocol_MSG_LOBBY_PROMO_COUNTRY_REPLY()
{
	clear();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY_REPLY::clear()
{
	uint32Val = 0;
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY_REPLY::equals(const Protocol_MSG_LOBBY_PROMO_COUNTRY_REPLY& _o) const
{
	return uint32Val == _o.uint32Val;
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_PROMO_COUNTRY_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_PROMO_COUNTRY_REPLY*)_other));
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_PROMO_COUNTRY_REPLY).append(")");
	_buf.append(',');
	_buf.append("uint32Val=");
	_buf.appendUint(uint32Val);
	return _buf.c_str();
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_PROMO_COUNTRY_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("uint32Val", uint32Val, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("uint32Val"))
			{
				uint32Val = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(uint32Val);
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(uint32Val);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("uint32Val", uint32Val);
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("uint32Val", uint32Val);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_PROMO_COUNTRY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 uint32Val; _jparser.validateByNameThrow("uint32Val", uint32Val);
	AtfValidator::validateInt(_descr, "uint32Val", uint32Val, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_PROMO_COUNTRY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 uint32Val; _parser.parseUINT32(uint32Val);
	AtfValidator::validateInt(_descr, "uint32Val", uint32Val, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN()
{
	clear();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN::clear()
{
	id = 0;
	locale = 0;
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN::equals(const Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN& _o) const
{
	return id == _o.id &&
		locale == _o.locale;
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_SATELLITES_TO_TOURN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN*)_other));
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_SATELLITES_TO_TOURN).append(")");
	_buf.append(',');
	_buf.append("id=");
	_buf.appendUint(id);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	return _buf.c_str();
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_SATELLITES_TO_TOURN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("id", id, _buf);
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("id"))
			{
				id = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("locale"))
			{
				locale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(id);
	_msg.composeUINT32(locale);
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(id);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(locale);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("id", id);
	_jsonstr.compose("locale", locale);
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("id", id);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("locale", locale);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_SATELLITES_TO_TOURN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 id; _jparser.validateByNameThrow("id", id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_SATELLITES_TO_TOURN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 id; _parser.parseUINT32(id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    SatelliteStruct
//=================================================================

Lobby::lobby_unauth::SatelliteStruct::SatelliteStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::lobby_unauth::SatelliteStruct::SatelliteStruct(SatelliteStruct&& _o)
	: tournamentId(std::move(_o.tournamentId))
	, server(std::move(_o.server))
	, serverObj(std::move(_o.serverObj))
	, publisherName(std::move(_o.publisherName))
	, whenStart(std::move(_o.whenStart))
	, buyIn(std::move(_o.buyIn))
	, rake(std::move(_o.rake))
	, fppBuyIn(std::move(_o.fppBuyIn))
	, isRestricted(std::move(_o.isRestricted))
	, isPwdProtected(std::move(_o.isPwdProtected))
	, localeStr(std::move(_o.localeStr))
	, admissionId(std::move(_o.admissionId))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, satelliteTarget(std::move(_o.satelliteTarget))
	, minPlayers(std::move(_o.minPlayers))
	, tournFlags(std::move(_o.tournFlags))
	, game(std::move(_o.game))
	, isHiLo(std::move(_o.isHiLo))
	, structure(std::move(_o.structure))
	, tournMask(std::move(_o.tournMask))
	, tournSites(std::move(_o.tournSites))
	, whenStartEncode(std::move(_o.whenStartEncode))
	, tournMask2(std::move(_o.tournMask2))
	, status(std::move(_o.status))
	, entrants(std::move(_o.entrants))
{
}

Lobby::lobby_unauth::SatelliteStruct& Lobby::lobby_unauth::SatelliteStruct::operator=(SatelliteStruct&& _o)
{
	if(this != &_o)
	{
		tournamentId = std::move(_o.tournamentId);
		server = std::move(_o.server);
		serverObj = std::move(_o.serverObj);
		publisherName = std::move(_o.publisherName);
		whenStart = std::move(_o.whenStart);
		buyIn = std::move(_o.buyIn);
		rake = std::move(_o.rake);
		fppBuyIn = std::move(_o.fppBuyIn);
		isRestricted = std::move(_o.isRestricted);
		isPwdProtected = std::move(_o.isPwdProtected);
		localeStr = std::move(_o.localeStr);
		admissionId = std::move(_o.admissionId);
		isPlayMoney = std::move(_o.isPlayMoney);
		satelliteTarget = std::move(_o.satelliteTarget);
		minPlayers = std::move(_o.minPlayers);
		tournFlags = std::move(_o.tournFlags);
		game = std::move(_o.game);
		isHiLo = std::move(_o.isHiLo);
		structure = std::move(_o.structure);
		tournMask = std::move(_o.tournMask);
		tournSites = std::move(_o.tournSites);
		whenStartEncode = std::move(_o.whenStartEncode);
		tournMask2 = std::move(_o.tournMask2);
		status = std::move(_o.status);
		entrants = std::move(_o.entrants);
	}
	return *this;
}

#endif

void Lobby::lobby_unauth::SatelliteStruct::clear()
{
	tournamentId = 0;
	server.clear();
	serverObj.clear();
	publisherName.clear();
	whenStart.setNull();
	buyIn = 0;
	rake = 0;
	fppBuyIn = 0;
	isRestricted = 0;
	isPwdProtected = 0;
	localeStr.clear();
	admissionId.clear();
	isPlayMoney = 0;
	satelliteTarget = 0;
	minPlayers = 0;
	tournFlags = 0;
	game = 0;
	isHiLo = 0;
	structure = 0;
	tournMask = 0;
	tournSites = 0;
	whenStartEncode = 0;
	tournMask2 = 0;
	status = 0;
	entrants = 0;
}

bool Lobby::lobby_unauth::SatelliteStruct::equals(const SatelliteStruct& _o) const
{
	return tournamentId == _o.tournamentId &&
		Atf::atfPStringEquals(server, _o.server) &&
		Atf::atfPStringEquals(serverObj, _o.serverObj) &&
		Atf::atfPStringEquals(publisherName, _o.publisherName) &&
		whenStart.equals(_o.whenStart) &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		fppBuyIn == _o.fppBuyIn &&
		isRestricted == _o.isRestricted &&
		isPwdProtected == _o.isPwdProtected &&
		Atf::atfPStringEquals(localeStr, _o.localeStr) &&
		Atf::atfPStringEquals(admissionId, _o.admissionId) &&
		isPlayMoney == _o.isPlayMoney &&
		satelliteTarget == _o.satelliteTarget &&
		minPlayers == _o.minPlayers &&
		tournFlags == _o.tournFlags &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		structure == _o.structure &&
		tournMask == _o.tournMask &&
		tournSites == _o.tournSites &&
		whenStartEncode == _o.whenStartEncode &&
		tournMask2 == _o.tournMask2 &&
		status == _o.status &&
		entrants == _o.entrants;
}

const char *Lobby::lobby_unauth::SatelliteStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournamentId=");
	_buf.appendUint(tournamentId);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("serverObj=");
	_buf.append(serverObj);
	_buf.append(',');
	_buf.append("publisherName=");
	_buf.append(publisherName);
	_buf.append(',');
	_buf.append("whenStart=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, whenStart);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendUint(buyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendUint(rake);
	_buf.append(',');
	_buf.append("fppBuyIn=");
	_buf.appendUint(fppBuyIn);
	_buf.append(',');
	_buf.append("isRestricted=");
	_buf.appendUint(isRestricted);
	_buf.append(',');
	_buf.append("isPwdProtected=");
	_buf.appendUint(isPwdProtected);
	_buf.append(',');
	_buf.append("localeStr=");
	_buf.append(localeStr);
	_buf.append(',');
	_buf.append("admissionId=");
	_buf.append(admissionId);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("satelliteTarget=");
	_buf.appendUint(satelliteTarget);
	_buf.append(',');
	_buf.append("minPlayers=");
	_buf.appendUint(minPlayers);
	_buf.append(',');
	_buf.append("tournFlags=");
	_buf.appendUint(tournFlags);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("tournMask=");
	_buf.appendUint(tournMask);
	_buf.append(',');
	_buf.append("tournSites=");
	_buf.appendUint(tournSites);
	_buf.append(',');
	_buf.append("whenStartEncode=");
	_buf.appendUint(whenStartEncode);
	_buf.append(',');
	_buf.append("tournMask2=");
	_buf.appendUint(tournMask2);
	_buf.append(',');
	_buf.append("status=");
	_buf.appendUint(status);
	_buf.append(',');
	_buf.append("entrants=");
	_buf.appendUint(entrants);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::lobby_unauth::SatelliteStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("tournamentId", tournamentId, _buf);
	Atf::XmlElement::encodeAsXmlElement("server", server, _buf);
	Atf::XmlElement::encodeAsXmlElement("serverObj", serverObj, _buf);
	Atf::XmlElement::encodeAsXmlElement("publisherName", publisherName, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "whenStart", whenStart);
	Atf::XmlElement::encodeAsXmlElement("buyIn", buyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("rake", rake, _buf);
	Atf::XmlElement::encodeAsXmlElement("fppBuyIn", fppBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("isRestricted", isRestricted, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPwdProtected", isPwdProtected, _buf);
	Atf::XmlElement::encodeAsXmlElement("localeStr", localeStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("admissionId", admissionId, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("satelliteTarget", satelliteTarget, _buf);
	Atf::XmlElement::encodeAsXmlElement("minPlayers", minPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournFlags", tournFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMask", tournMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournSites", tournSites, _buf);
	Atf::XmlElement::encodeAsXmlElement("whenStartEncode", whenStartEncode, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMask2", tournMask2, _buf);
	Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
	Atf::XmlElement::encodeAsXmlElement("entrants", entrants, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::lobby_unauth::SatelliteStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("tournamentId"))
		{
			tournamentId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("server"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, server)) return false;
		}
		else if (_element.equals("serverObj"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, serverObj)) return false;
		}
		else if (_element.equals("publisherName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, publisherName)) return false;
		}
		else if (_element.equals("whenStart"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, whenStart);
		}
		else if (_element.equals("buyIn"))
		{
			buyIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rake"))
		{
			rake = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("fppBuyIn"))
		{
			fppBuyIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isRestricted"))
		{
			isRestricted = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isPwdProtected"))
		{
			isPwdProtected = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("localeStr"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, localeStr)) return false;
		}
		else if (_element.equals("admissionId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, admissionId)) return false;
		}
		else if (_element.equals("isPlayMoney"))
		{
			isPlayMoney = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("satelliteTarget"))
		{
			satelliteTarget = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minPlayers"))
		{
			minPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournFlags"))
		{
			tournFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("game"))
		{
			game = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("structure"))
		{
			structure = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournMask"))
		{
			tournMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournSites"))
		{
			tournSites = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("whenStartEncode"))
		{
			whenStartEncode = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournMask2"))
		{
			tournMask2 = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("status"))
		{
			status = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("entrants"))
		{
			entrants = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::lobby_unauth::SatelliteStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(tournamentId);
	_msg.composeString(server);
	_msg.composeString(serverObj);
	_msg.composeString(publisherName);
	_msg.composeSrvTime(whenStart);
	_msg.composeUINT32(buyIn);
	_msg.composeUINT32(rake);
	_msg.composeUINT32(fppBuyIn);
	_msg.composeBYTE(isRestricted);
	_msg.composeBYTE(isPwdProtected);
	_msg.composeString(localeStr);
	_msg.composeString(admissionId);
	_msg.composeBYTE(isPlayMoney);
	_msg.composeUINT32(satelliteTarget);
	_msg.composeUINT32(minPlayers);
	_msg.composeUINT32(tournFlags);
	_msg.composeBYTE(game);
	_msg.composeBYTE(isHiLo);
	_msg.composeBYTE(structure);
	_msg.composeUINT32(tournMask);
	_msg.composeUINT32(tournSites);
	_msg.composeUINT32(whenStartEncode);
	_msg.composeUINT32(tournMask2);
	_msg.composeUINT32(status);
	_msg.composeUINT32(entrants);
}

void Lobby::lobby_unauth::SatelliteStruct::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tournamentId);
	_parser.parseStringP(server);
	_parser.parseStringP(serverObj);
	_parser.parseStringP(publisherName);
	_parser.parseSrvTime(whenStart);
	_parser.parseUINT32(buyIn);
	_parser.parseUINT32(rake);
	_parser.parseUINT32(fppBuyIn);
	_parser.parseBYTE(isRestricted);
	_parser.parseBYTE(isPwdProtected);
	_parser.parseStringP(localeStr);
	_parser.parseStringP(admissionId);
	_parser.parseBYTE(isPlayMoney);
	_parser.parseUINT32(satelliteTarget);
	_parser.parseUINT32(minPlayers);
	_parser.parseUINT32(tournFlags);
	_parser.parseBYTE(game);
	_parser.parseBYTE(isHiLo);
	_parser.parseBYTE(structure);
	_parser.parseUINT32(tournMask);
	_parser.parseUINT32(tournSites);
	_parser.parseUINT32(whenStartEncode);
	_parser.parseUINT32(tournMask2);
	_parser.parseUINT32(status);
	_parser.parseUINT32(entrants);
}

const char *Lobby::lobby_unauth::SatelliteStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tournamentId", tournamentId);
	_jsonstr.compose("server", server);
	_jsonstr.compose("serverObj", serverObj);
	_jsonstr.compose("publisherName", publisherName);
	_jsonstr.compose("whenStart", whenStart);
	_jsonstr.compose("buyIn", buyIn);
	_jsonstr.compose("rake", rake);
	_jsonstr.compose("fppBuyIn", fppBuyIn);
	_jsonstr.compose("isRestricted", isRestricted);
	_jsonstr.compose("isPwdProtected", isPwdProtected);
	_jsonstr.compose("localeStr", localeStr);
	_jsonstr.compose("admissionId", admissionId);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("satelliteTarget", satelliteTarget);
	_jsonstr.compose("minPlayers", minPlayers);
	_jsonstr.compose("tournFlags", tournFlags);
	_jsonstr.compose("game", game);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("tournMask", tournMask);
	_jsonstr.compose("tournSites", tournSites);
	_jsonstr.compose("whenStartEncode", whenStartEncode);
	_jsonstr.compose("tournMask2", tournMask2);
	_jsonstr.compose("status", status);
	_jsonstr.compose("entrants", entrants);
	return _buf.c_str();
}

void Lobby::lobby_unauth::SatelliteStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tournamentId", tournamentId);
	_jparser.parseByNameThrow("server", server);
	_jparser.parseByNameThrow("serverObj", serverObj);
	_jparser.parseByNameThrow("publisherName", publisherName);
	_jparser.parseByNameThrow("whenStart", whenStart);
	_jparser.parseByNameThrow("buyIn", buyIn);
	_jparser.parseByNameThrow("rake", rake);
	_jparser.parseByNameThrow("fppBuyIn", fppBuyIn);
	_jparser.parseByNameThrow("isRestricted", isRestricted);
	_jparser.parseByNameThrow("isPwdProtected", isPwdProtected);
	_jparser.parseByNameThrow("localeStr", localeStr);
	_jparser.parseByNameThrow("admissionId", admissionId);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("satelliteTarget", satelliteTarget);
	_jparser.parseByNameThrow("minPlayers", minPlayers);
	_jparser.parseByNameThrow("tournFlags", tournFlags);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("tournMask", tournMask);
	_jparser.parseByNameThrow("tournSites", tournSites);
	_jparser.parseByNameThrow("whenStartEncode", whenStartEncode);
	_jparser.parseByNameThrow("tournMask2", tournMask2);
	_jparser.parseByNameThrow("status", status);
	_jparser.parseByNameThrow("entrants", entrants);
}

/* static */ void Lobby::lobby_unauth::SatelliteStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tournamentId; _jparser.validateByNameThrow("tournamentId", tournamentId);
	AtfValidator::validateInt(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
	PString server; _jparser.validateByNameThrow("server", server);
	AtfValidator::validateInt(_descr, "server", server.length(), _checker, __FILE__, __LINE__);
	PString serverObj; _jparser.validateByNameThrow("serverObj", serverObj);
	AtfValidator::validateInt(_descr, "serverObj", serverObj.length(), _checker, __FILE__, __LINE__);
	PString publisherName; _jparser.validateByNameThrow("publisherName", publisherName);
	AtfValidator::validateInt(_descr, "publisherName", publisherName.length(), _checker, __FILE__, __LINE__);
	CommSrvTime whenStart; _jparser.validateByNameThrow("whenStart", whenStart);
	AtfValidator::validateSrvDateTime(_descr, "whenStart", whenStart, _checker, __FILE__, __LINE__);
	UINT32 buyIn; _jparser.validateByNameThrow("buyIn", buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT32 rake; _jparser.validateByNameThrow("rake", rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	UINT32 fppBuyIn; _jparser.validateByNameThrow("fppBuyIn", fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	BYTE isRestricted; _jparser.validateByNameThrow("isRestricted", isRestricted);
	AtfValidator::validateInt(_descr, "isRestricted", isRestricted, _checker, __FILE__, __LINE__);
	BYTE isPwdProtected; _jparser.validateByNameThrow("isPwdProtected", isPwdProtected);
	AtfValidator::validateInt(_descr, "isPwdProtected", isPwdProtected, _checker, __FILE__, __LINE__);
	PString localeStr; _jparser.validateByNameThrow("localeStr", localeStr);
	AtfValidator::validateInt(_descr, "localeStr", localeStr.length(), _checker, __FILE__, __LINE__);
	PString admissionId; _jparser.validateByNameThrow("admissionId", admissionId);
	AtfValidator::validateInt(_descr, "admissionId", admissionId.length(), _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 satelliteTarget; _jparser.validateByNameThrow("satelliteTarget", satelliteTarget);
	AtfValidator::validateInt(_descr, "satelliteTarget", satelliteTarget, _checker, __FILE__, __LINE__);
	UINT32 minPlayers; _jparser.validateByNameThrow("minPlayers", minPlayers);
	AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
	UINT32 tournFlags; _jparser.validateByNameThrow("tournFlags", tournFlags);
	AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	UINT32 tournMask; _jparser.validateByNameThrow("tournMask", tournMask);
	AtfValidator::validateInt(_descr, "tournMask", tournMask, _checker, __FILE__, __LINE__);
	UINT32 tournSites; _jparser.validateByNameThrow("tournSites", tournSites);
	AtfValidator::validateInt(_descr, "tournSites", tournSites, _checker, __FILE__, __LINE__);
	UINT32 whenStartEncode; _jparser.validateByNameThrow("whenStartEncode", whenStartEncode);
	AtfValidator::validateInt(_descr, "whenStartEncode", whenStartEncode, _checker, __FILE__, __LINE__);
	UINT32 tournMask2; _jparser.validateByNameThrow("tournMask2", tournMask2);
	AtfValidator::validateInt(_descr, "tournMask2", tournMask2, _checker, __FILE__, __LINE__);
	UINT32 status; _jparser.validateByNameThrow("status", status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	UINT32 entrants; _jparser.validateByNameThrow("entrants", entrants);
	AtfValidator::validateInt(_descr, "entrants", entrants, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::lobby_unauth::SatelliteStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 tournamentId; _parser.parseUINT32(tournamentId);
	AtfValidator::validateInt(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "serverObj"); size_t szServerObj = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObj", szServerObj, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "publisherName"); size_t szPublisherName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "publisherName", szPublisherName, _checker, __FILE__, __LINE__);
	CommSrvTime whenStart; _parser.parseSrvTime(whenStart);
	AtfValidator::validateSrvDateTime(_descr, "whenStart", whenStart, _checker, __FILE__, __LINE__);
	UINT32 buyIn; _parser.parseUINT32(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT32 rake; _parser.parseUINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	UINT32 fppBuyIn; _parser.parseUINT32(fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	BYTE isRestricted; _parser.parseBYTE(isRestricted);
	AtfValidator::validateInt(_descr, "isRestricted", isRestricted, _checker, __FILE__, __LINE__);
	BYTE isPwdProtected; _parser.parseBYTE(isPwdProtected);
	AtfValidator::validateInt(_descr, "isPwdProtected", isPwdProtected, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "localeStr"); size_t szLocaleStr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "localeStr", szLocaleStr, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "admissionId"); size_t szAdmissionId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "admissionId", szAdmissionId, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 satelliteTarget; _parser.parseUINT32(satelliteTarget);
	AtfValidator::validateInt(_descr, "satelliteTarget", satelliteTarget, _checker, __FILE__, __LINE__);
	UINT32 minPlayers; _parser.parseUINT32(minPlayers);
	AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
	UINT32 tournFlags; _parser.parseUINT32(tournFlags);
	AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	UINT32 tournMask; _parser.parseUINT32(tournMask);
	AtfValidator::validateInt(_descr, "tournMask", tournMask, _checker, __FILE__, __LINE__);
	UINT32 tournSites; _parser.parseUINT32(tournSites);
	AtfValidator::validateInt(_descr, "tournSites", tournSites, _checker, __FILE__, __LINE__);
	UINT32 whenStartEncode; _parser.parseUINT32(whenStartEncode);
	AtfValidator::validateInt(_descr, "whenStartEncode", whenStartEncode, _checker, __FILE__, __LINE__);
	UINT32 tournMask2; _parser.parseUINT32(tournMask2);
	AtfValidator::validateInt(_descr, "tournMask2", tournMask2, _checker, __FILE__, __LINE__);
	UINT32 status; _parser.parseUINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	UINT32 entrants; _parser.parseUINT32(entrants);
	AtfValidator::validateInt(_descr, "entrants", entrants, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY(Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY&& _o)
	: id(std::move(_o.id))
	, satellites(std::move(_o.satellites))
{
}

Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY& Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY::operator=(Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY&& _o)
{
	if(this != &_o)
	{
		id = std::move(_o.id);
		satellites = std::move(_o.satellites);
	}
	return *this;
}

#endif

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY::clear()
{
	id = 0;
	satellites.clear();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY::equals(const Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY& _o) const
{
	return id == _o.id &&
		satellites.equals(_o.satellites);
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY*)_other));
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY).append(")");
	_buf.append(',');
	_buf.append("id=");
	_buf.appendUint(id);
	_buf.append(',');
	_buf.append("satellites=");
	satellites.toTraceString(_buf);
	return _buf.c_str();
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("id", id, _buf);
	satellites.toXmlString("satellites", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("id"))
			{
				id = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("satellites"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SatelliteStruct, 4 > >::FromXmlString(_value, satellites)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(id);
	satellites.composeMsg(_msg, _ignoreJSON);
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(id);
	satellites.parseMsg(_parser);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("id", id);
	_jsonstr.compose("satellites", satellites);
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("id", id);
	_jparser.parseByNameThrow("satellites", satellites);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 id; _jparser.validateByNameThrow("id", id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SatelliteStruct > satellites; _jparser.validateByNameThrow("satellites", satellites);
	AtfValidator::validateInt(_descr, "satellites", satellites.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 id; _parser.parseUINT32(id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szSatellites = Atf::LAtfVector< SatelliteStruct, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("satellites"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "satellites", szSatellites, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX()
{
	clear();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX::clear()
{
	id = 0;
	locale = 0;
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX::equals(const Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX& _o) const
{
	return id == _o.id &&
		locale == _o.locale;
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX*)_other));
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX).append(")");
	_buf.append(',');
	_buf.append("id=");
	_buf.appendUint(id);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	return _buf.c_str();
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("id", id, _buf);
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("id"))
			{
				id = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("locale"))
			{
				locale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(id);
	_msg.composeUINT32(locale);
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(id);
	_parser.parseUINT32(locale);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("id", id);
	_jsonstr.compose("locale", locale);
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("id", id);
	_jparser.parseByNameThrow("locale", locale);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 id; _jparser.validateByNameThrow("id", id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 id; _parser.parseUINT32(id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    SatelliteStructEx
//=================================================================

Lobby::lobby_unauth::SatelliteStructEx::SatelliteStructEx()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::lobby_unauth::SatelliteStructEx::SatelliteStructEx(SatelliteStructEx&& _o)
	: tournamentId(std::move(_o.tournamentId))
	, server(std::move(_o.server))
	, serverObj(std::move(_o.serverObj))
	, publisherName(std::move(_o.publisherName))
	, whenStart(std::move(_o.whenStart))
	, buyIn(std::move(_o.buyIn))
	, rake(std::move(_o.rake))
	, fppBuyIn(std::move(_o.fppBuyIn))
	, isRestricted(std::move(_o.isRestricted))
	, isPwdProtected(std::move(_o.isPwdProtected))
	, localeStr(std::move(_o.localeStr))
	, admissionId(std::move(_o.admissionId))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, satelliteTarget(std::move(_o.satelliteTarget))
	, minPlayers(std::move(_o.minPlayers))
	, tournFlags(std::move(_o.tournFlags))
	, game(std::move(_o.game))
	, isHiLo(std::move(_o.isHiLo))
	, structure(std::move(_o.structure))
	, tournMask(std::move(_o.tournMask))
	, tournSites(std::move(_o.tournSites))
	, whenStartEncode(std::move(_o.whenStartEncode))
	, tournMask2(std::move(_o.tournMask2))
	, status(std::move(_o.status))
	, entrants(std::move(_o.entrants))
{
}

Lobby::lobby_unauth::SatelliteStructEx& Lobby::lobby_unauth::SatelliteStructEx::operator=(SatelliteStructEx&& _o)
{
	if(this != &_o)
	{
		tournamentId = std::move(_o.tournamentId);
		server = std::move(_o.server);
		serverObj = std::move(_o.serverObj);
		publisherName = std::move(_o.publisherName);
		whenStart = std::move(_o.whenStart);
		buyIn = std::move(_o.buyIn);
		rake = std::move(_o.rake);
		fppBuyIn = std::move(_o.fppBuyIn);
		isRestricted = std::move(_o.isRestricted);
		isPwdProtected = std::move(_o.isPwdProtected);
		localeStr = std::move(_o.localeStr);
		admissionId = std::move(_o.admissionId);
		isPlayMoney = std::move(_o.isPlayMoney);
		satelliteTarget = std::move(_o.satelliteTarget);
		minPlayers = std::move(_o.minPlayers);
		tournFlags = std::move(_o.tournFlags);
		game = std::move(_o.game);
		isHiLo = std::move(_o.isHiLo);
		structure = std::move(_o.structure);
		tournMask = std::move(_o.tournMask);
		tournSites = std::move(_o.tournSites);
		whenStartEncode = std::move(_o.whenStartEncode);
		tournMask2 = std::move(_o.tournMask2);
		status = std::move(_o.status);
		entrants = std::move(_o.entrants);
	}
	return *this;
}

#endif

void Lobby::lobby_unauth::SatelliteStructEx::clear()
{
	tournamentId = 0;
	server.clear();
	serverObj.clear();
	publisherName.clear();
	whenStart.setNull();
	buyIn = 0;
	rake = 0;
	fppBuyIn = 0;
	isRestricted = 0;
	isPwdProtected = 0;
	localeStr.clear();
	admissionId.clear();
	isPlayMoney = 0;
	satelliteTarget = 0;
	minPlayers = 0;
	tournFlags = 0;
	game = 0;
	isHiLo = 0;
	structure = 0;
	tournMask = 0;
	tournSites.clear();
	whenStartEncode = 0;
	tournMask2 = 0;
	status = 0;
	entrants = 0;
}

bool Lobby::lobby_unauth::SatelliteStructEx::equals(const SatelliteStructEx& _o) const
{
	return tournamentId == _o.tournamentId &&
		Atf::atfPStringEquals(server, _o.server) &&
		Atf::atfPStringEquals(serverObj, _o.serverObj) &&
		Atf::atfPStringEquals(publisherName, _o.publisherName) &&
		whenStart.equals(_o.whenStart) &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		fppBuyIn == _o.fppBuyIn &&
		isRestricted == _o.isRestricted &&
		isPwdProtected == _o.isPwdProtected &&
		Atf::atfPStringEquals(localeStr, _o.localeStr) &&
		Atf::atfPStringEquals(admissionId, _o.admissionId) &&
		isPlayMoney == _o.isPlayMoney &&
		satelliteTarget == _o.satelliteTarget &&
		minPlayers == _o.minPlayers &&
		tournFlags == _o.tournFlags &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		structure == _o.structure &&
		tournMask == _o.tournMask &&
		tournSites.equals(_o.tournSites) &&
		whenStartEncode == _o.whenStartEncode &&
		tournMask2 == _o.tournMask2 &&
		status == _o.status &&
		entrants == _o.entrants;
}

const char *Lobby::lobby_unauth::SatelliteStructEx::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournamentId=");
	_buf.appendUint(tournamentId);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("serverObj=");
	_buf.append(serverObj);
	_buf.append(',');
	_buf.append("publisherName=");
	_buf.append(publisherName);
	_buf.append(',');
	_buf.append("whenStart=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, whenStart);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendUint(buyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendUint(rake);
	_buf.append(',');
	_buf.append("fppBuyIn=");
	_buf.appendUint(fppBuyIn);
	_buf.append(',');
	_buf.append("isRestricted=");
	_buf.appendUint(isRestricted);
	_buf.append(',');
	_buf.append("isPwdProtected=");
	_buf.appendUint(isPwdProtected);
	_buf.append(',');
	_buf.append("localeStr=");
	_buf.append(localeStr);
	_buf.append(',');
	_buf.append("admissionId=");
	_buf.append(admissionId);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("satelliteTarget=");
	_buf.appendUint(satelliteTarget);
	_buf.append(',');
	_buf.append("minPlayers=");
	_buf.appendUint(minPlayers);
	_buf.append(',');
	_buf.append("tournFlags=");
	_buf.appendUint(tournFlags);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("tournMask=");
	_buf.appendUint(tournMask);
	_buf.append(',');
	_buf.append("tournSites=");
	tournSites.toTraceString(_buf);
	_buf.append(',');
	_buf.append("whenStartEncode=");
	_buf.appendUint(whenStartEncode);
	_buf.append(',');
	_buf.append("tournMask2=");
	_buf.appendUint(tournMask2);
	_buf.append(',');
	_buf.append("status=");
	_buf.appendUint(status);
	_buf.append(',');
	_buf.append("entrants=");
	_buf.appendUint(entrants);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::lobby_unauth::SatelliteStructEx::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("tournamentId", tournamentId, _buf);
	Atf::XmlElement::encodeAsXmlElement("server", server, _buf);
	Atf::XmlElement::encodeAsXmlElement("serverObj", serverObj, _buf);
	Atf::XmlElement::encodeAsXmlElement("publisherName", publisherName, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "whenStart", whenStart);
	Atf::XmlElement::encodeAsXmlElement("buyIn", buyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("rake", rake, _buf);
	Atf::XmlElement::encodeAsXmlElement("fppBuyIn", fppBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("isRestricted", isRestricted, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPwdProtected", isPwdProtected, _buf);
	Atf::XmlElement::encodeAsXmlElement("localeStr", localeStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("admissionId", admissionId, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("satelliteTarget", satelliteTarget, _buf);
	Atf::XmlElement::encodeAsXmlElement("minPlayers", minPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournFlags", tournFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMask", tournMask, _buf);
	tournSites.toXmlString("tournSites", _buf);
	Atf::XmlElement::encodeAsXmlElement("whenStartEncode", whenStartEncode, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMask2", tournMask2, _buf);
	Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
	Atf::XmlElement::encodeAsXmlElement("entrants", entrants, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::lobby_unauth::SatelliteStructEx::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("tournamentId"))
		{
			tournamentId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("server"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, server)) return false;
		}
		else if (_element.equals("serverObj"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, serverObj)) return false;
		}
		else if (_element.equals("publisherName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, publisherName)) return false;
		}
		else if (_element.equals("whenStart"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, whenStart);
		}
		else if (_element.equals("buyIn"))
		{
			buyIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rake"))
		{
			rake = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("fppBuyIn"))
		{
			fppBuyIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isRestricted"))
		{
			isRestricted = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isPwdProtected"))
		{
			isPwdProtected = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("localeStr"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, localeStr)) return false;
		}
		else if (_element.equals("admissionId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, admissionId)) return false;
		}
		else if (_element.equals("isPlayMoney"))
		{
			isPlayMoney = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("satelliteTarget"))
		{
			satelliteTarget = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minPlayers"))
		{
			minPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournFlags"))
		{
			tournFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("game"))
		{
			game = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("structure"))
		{
			structure = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournMask"))
		{
			tournMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournSites"))
		{
			if(!Atf::AtfTempl< PSiteMask >::FromXmlString(_value, tournSites)) return false;
		}
		else if (_element.equals("whenStartEncode"))
		{
			whenStartEncode = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournMask2"))
		{
			tournMask2 = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("status"))
		{
			status = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("entrants"))
		{
			entrants = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::lobby_unauth::SatelliteStructEx::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(SatelliteStructEx())) // not empty
	{
		_body.composeUINT32(tournamentId);
		_body.composeString(server);
		_body.composeString(serverObj);
		_body.composeString(publisherName);
		_body.composeSrvTime(whenStart);
		_body.composeUINT32(buyIn);
		_body.composeUINT32(rake);
		_body.composeUINT32(fppBuyIn);
		_body.composeBYTE(isRestricted);
		_body.composeBYTE(isPwdProtected);
		_body.composeString(localeStr);
		_body.composeString(admissionId);
		_body.composeBYTE(isPlayMoney);
		_body.composeUINT32(satelliteTarget);
		_body.composeUINT32(minPlayers);
		_body.composeUINT32(tournFlags);
		_body.composeBYTE(game);
		_body.composeBYTE(isHiLo);
		_body.composeBYTE(structure);
		_body.composeUINT32(tournMask);
		tournSites.composeMsg(_body, _ignoreJSON);
		_body.composeUINT32(whenStartEncode);
		_body.composeUINT32(tournMask2);
		_body.composeUINT32(status);
		_body.composeUINT32(entrants);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::lobby_unauth::SatelliteStructEx::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(tournamentId);
	_parser0.parseStringP(server);
	_parser0.parseStringP(serverObj);
	_parser0.parseStringP(publisherName);
	_parser0.parseSrvTime(whenStart);
	_parser0.parseUINT32(buyIn);
	_parser0.parseUINT32(rake);
	_parser0.parseUINT32(fppBuyIn);
	_parser0.parseBYTE(isRestricted);
	_parser0.parseBYTE(isPwdProtected);
	_parser0.parseStringP(localeStr);
	_parser0.parseStringP(admissionId);
	_parser0.parseBYTE(isPlayMoney);
	_parser0.parseUINT32(satelliteTarget);
	_parser0.parseUINT32(minPlayers);
	_parser0.parseUINT32(tournFlags);
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(isHiLo);
	_parser0.parseBYTE(structure);
	_parser0.parseUINT32(tournMask);
	tournSites.parseMsg(_parser0);
	_parser0.parseUINT32(whenStartEncode);
	_parser0.parseUINT32(tournMask2);
	_parser0.parseUINT32(status);
	_parser0.parseUINT32(entrants);
}

const char *Lobby::lobby_unauth::SatelliteStructEx::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tournamentId", tournamentId);
	_jsonstr.compose("server", server);
	_jsonstr.compose("serverObj", serverObj);
	_jsonstr.compose("publisherName", publisherName);
	_jsonstr.compose("whenStart", whenStart);
	_jsonstr.compose("buyIn", buyIn);
	_jsonstr.compose("rake", rake);
	_jsonstr.compose("fppBuyIn", fppBuyIn);
	_jsonstr.compose("isRestricted", isRestricted);
	_jsonstr.compose("isPwdProtected", isPwdProtected);
	_jsonstr.compose("localeStr", localeStr);
	_jsonstr.compose("admissionId", admissionId);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("satelliteTarget", satelliteTarget);
	_jsonstr.compose("minPlayers", minPlayers);
	_jsonstr.compose("tournFlags", tournFlags);
	_jsonstr.compose("game", game);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("tournMask", tournMask);
	_jsonstr.compose("tournSites", tournSites);
	_jsonstr.compose("whenStartEncode", whenStartEncode);
	_jsonstr.compose("tournMask2", tournMask2);
	_jsonstr.compose("status", status);
	_jsonstr.compose("entrants", entrants);
	return _buf.c_str();
}

void Lobby::lobby_unauth::SatelliteStructEx::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tournamentId", tournamentId);
	_jparser.parseByNameThrow("server", server);
	_jparser.parseByNameThrow("serverObj", serverObj);
	_jparser.parseByNameThrow("publisherName", publisherName);
	_jparser.parseByNameThrow("whenStart", whenStart);
	_jparser.parseByNameThrow("buyIn", buyIn);
	_jparser.parseByNameThrow("rake", rake);
	_jparser.parseByNameThrow("fppBuyIn", fppBuyIn);
	_jparser.parseByNameThrow("isRestricted", isRestricted);
	_jparser.parseByNameThrow("isPwdProtected", isPwdProtected);
	_jparser.parseByNameThrow("localeStr", localeStr);
	_jparser.parseByNameThrow("admissionId", admissionId);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("satelliteTarget", satelliteTarget);
	_jparser.parseByNameThrow("minPlayers", minPlayers);
	_jparser.parseByNameThrow("tournFlags", tournFlags);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("tournMask", tournMask);
	_jparser.parseByNameThrow("tournSites", tournSites);
	_jparser.parseByNameThrow("whenStartEncode", whenStartEncode);
	_jparser.parseByNameThrow("tournMask2", tournMask2);
	_jparser.parseByNameThrow("status", status);
	_jparser.parseByNameThrow("entrants", entrants);
}

/* static */ void Lobby::lobby_unauth::SatelliteStructEx::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tournamentId; _jparser.validateByNameThrow("tournamentId", tournamentId);
	AtfValidator::validateInt(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
	PString server; _jparser.validateByNameThrow("server", server);
	AtfValidator::validateInt(_descr, "server", server.length(), _checker, __FILE__, __LINE__);
	PString serverObj; _jparser.validateByNameThrow("serverObj", serverObj);
	AtfValidator::validateInt(_descr, "serverObj", serverObj.length(), _checker, __FILE__, __LINE__);
	PString publisherName; _jparser.validateByNameThrow("publisherName", publisherName);
	AtfValidator::validateInt(_descr, "publisherName", publisherName.length(), _checker, __FILE__, __LINE__);
	CommSrvTime whenStart; _jparser.validateByNameThrow("whenStart", whenStart);
	AtfValidator::validateSrvDateTime(_descr, "whenStart", whenStart, _checker, __FILE__, __LINE__);
	UINT32 buyIn; _jparser.validateByNameThrow("buyIn", buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT32 rake; _jparser.validateByNameThrow("rake", rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	UINT32 fppBuyIn; _jparser.validateByNameThrow("fppBuyIn", fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	BYTE isRestricted; _jparser.validateByNameThrow("isRestricted", isRestricted);
	AtfValidator::validateInt(_descr, "isRestricted", isRestricted, _checker, __FILE__, __LINE__);
	BYTE isPwdProtected; _jparser.validateByNameThrow("isPwdProtected", isPwdProtected);
	AtfValidator::validateInt(_descr, "isPwdProtected", isPwdProtected, _checker, __FILE__, __LINE__);
	PString localeStr; _jparser.validateByNameThrow("localeStr", localeStr);
	AtfValidator::validateInt(_descr, "localeStr", localeStr.length(), _checker, __FILE__, __LINE__);
	PString admissionId; _jparser.validateByNameThrow("admissionId", admissionId);
	AtfValidator::validateInt(_descr, "admissionId", admissionId.length(), _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 satelliteTarget; _jparser.validateByNameThrow("satelliteTarget", satelliteTarget);
	AtfValidator::validateInt(_descr, "satelliteTarget", satelliteTarget, _checker, __FILE__, __LINE__);
	UINT32 minPlayers; _jparser.validateByNameThrow("minPlayers", minPlayers);
	AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
	UINT32 tournFlags; _jparser.validateByNameThrow("tournFlags", tournFlags);
	AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	UINT32 tournMask; _jparser.validateByNameThrow("tournMask", tournMask);
	AtfValidator::validateInt(_descr, "tournMask", tournMask, _checker, __FILE__, __LINE__);
	PSiteMask tournSites; _jparser.validateByNameThrow("tournSites", tournSites);
	UINT32 whenStartEncode; _jparser.validateByNameThrow("whenStartEncode", whenStartEncode);
	AtfValidator::validateInt(_descr, "whenStartEncode", whenStartEncode, _checker, __FILE__, __LINE__);
	UINT32 tournMask2; _jparser.validateByNameThrow("tournMask2", tournMask2);
	AtfValidator::validateInt(_descr, "tournMask2", tournMask2, _checker, __FILE__, __LINE__);
	UINT32 status; _jparser.validateByNameThrow("status", status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	UINT32 entrants; _jparser.validateByNameThrow("entrants", entrants);
	AtfValidator::validateInt(_descr, "entrants", entrants, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::lobby_unauth::SatelliteStructEx::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 tournamentId; _parser0.parseUINT32(tournamentId);
	AtfValidator::validateInt(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "serverObj"); size_t szServerObj = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObj", szServerObj, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "publisherName"); size_t szPublisherName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "publisherName", szPublisherName, _checker, __FILE__, __LINE__);
	CommSrvTime whenStart; _parser0.parseSrvTime(whenStart);
	AtfValidator::validateSrvDateTime(_descr, "whenStart", whenStart, _checker, __FILE__, __LINE__);
	UINT32 buyIn; _parser0.parseUINT32(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT32 rake; _parser0.parseUINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	UINT32 fppBuyIn; _parser0.parseUINT32(fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	BYTE isRestricted; _parser0.parseBYTE(isRestricted);
	AtfValidator::validateInt(_descr, "isRestricted", isRestricted, _checker, __FILE__, __LINE__);
	BYTE isPwdProtected; _parser0.parseBYTE(isPwdProtected);
	AtfValidator::validateInt(_descr, "isPwdProtected", isPwdProtected, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "localeStr"); size_t szLocaleStr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "localeStr", szLocaleStr, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "admissionId"); size_t szAdmissionId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "admissionId", szAdmissionId, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser0.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 satelliteTarget; _parser0.parseUINT32(satelliteTarget);
	AtfValidator::validateInt(_descr, "satelliteTarget", satelliteTarget, _checker, __FILE__, __LINE__);
	UINT32 minPlayers; _parser0.parseUINT32(minPlayers);
	AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
	UINT32 tournFlags; _parser0.parseUINT32(tournFlags);
	AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
	BYTE game; _parser0.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser0.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	UINT32 tournMask; _parser0.parseUINT32(tournMask);
	AtfValidator::validateInt(_descr, "tournMask", tournMask, _checker, __FILE__, __LINE__);
	PString _descbuf;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tournSites"), _fieldsWithUnparsedContent);
	UINT32 whenStartEncode; _parser0.parseUINT32(whenStartEncode);
	AtfValidator::validateInt(_descr, "whenStartEncode", whenStartEncode, _checker, __FILE__, __LINE__);
	UINT32 tournMask2; _parser0.parseUINT32(tournMask2);
	AtfValidator::validateInt(_descr, "tournMask2", tournMask2, _checker, __FILE__, __LINE__);
	UINT32 status; _parser0.parseUINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	UINT32 entrants; _parser0.parseUINT32(entrants);
	AtfValidator::validateInt(_descr, "entrants", entrants, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY(Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY&& _o)
	: id(std::move(_o.id))
	, satellites(std::move(_o.satellites))
{
}

Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY& Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY::operator=(Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY&& _o)
{
	if(this != &_o)
	{
		id = std::move(_o.id);
		satellites = std::move(_o.satellites);
	}
	return *this;
}

#endif

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY::clear()
{
	id = 0;
	satellites.clear();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY::equals(const Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY& _o) const
{
	return id == _o.id &&
		satellites.equals(_o.satellites);
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY*)_other));
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY).append(")");
	_buf.append(',');
	_buf.append("id=");
	_buf.appendUint(id);
	_buf.append(',');
	_buf.append("satellites=");
	satellites.toTraceString(_buf);
	return _buf.c_str();
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("id", id, _buf);
	satellites.toXmlString("satellites", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("id"))
			{
				id = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("satellites"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SatelliteStructEx, 4 > >::FromXmlString(_value, satellites)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(id);
	satellites.composeMsg(_msg, _ignoreJSON);
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(id);
	satellites.parseMsg(_parser);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("id", id);
	_jsonstr.compose("satellites", satellites);
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("id", id);
	_jparser.parseByNameThrow("satellites", satellites);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 id; _jparser.validateByNameThrow("id", id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SatelliteStructEx > satellites; _jparser.validateByNameThrow("satellites", satellites);
	AtfValidator::validateInt(_descr, "satellites", satellites.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 id; _parser.parseUINT32(id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szSatellites = Atf::LAtfVector< SatelliteStructEx, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("satellites"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "satellites", szSatellites, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_TABLE_BY_ID
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID::Protocol_MSG_LOBBY_GET_TABLE_BY_ID()
{
	clear();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID::clear()
{
	tableId32 = 0;
	tournId = 0;
	tableId = tableId32;
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID::equals(const Protocol_MSG_LOBBY_GET_TABLE_BY_ID& _o) const
{
	return tableId32 == _o.tableId32 &&
		tournId == _o.tournId &&
		tableId == _o.tableId;
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_TABLE_BY_ID != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_TABLE_BY_ID*)_other));
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_TABLE_BY_ID).append(")");
	_buf.append(',');
	_buf.append("tableId32=");
	_buf.appendUint(tableId32);
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	return _buf.c_str();
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_TABLE_BY_ID).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("tableId32", tableId32, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableId", tableId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tableId32"))
			{
				tableId32 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournId"))
			{
				tournId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tableId"))
			{
				tableId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(tableId32);
	_msg.composeUINT32(tournId);
	_msg.composeUINT64(tableId);
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tableId32);
	_parser.parseUINT32(tournId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(tableId);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tableId32", tableId32);
	_jsonstr.compose("tournId", tournId);
	_jsonstr.compose("tableId", tableId);
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tableId32", tableId32);
	_jparser.parseByNameThrow("tournId", tournId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tableId", tableId);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_TABLE_BY_ID";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tableId32; _jparser.validateByNameThrow("tableId32", tableId32);
	AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
	UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT64 tableId; _jparser.validateByNameThrow("tableId", tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_TABLE_BY_ID";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 tableId32; _parser.parseUINT32(tableId32);
	AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 tableId; _parser.parseUINT64(tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY::Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY::Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY(Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, server(std::move(_o.server))
	, serverObj(std::move(_o.serverObj))
{
}

Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY& Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY::operator=(Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		server = std::move(_o.server);
		serverObj = std::move(_o.serverObj);
	}
	return *this;
}

#endif

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	server.clear();
	serverObj.clear();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY::equals(const Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(server, _o.server) &&
		Atf::atfPStringEquals(serverObj, _o.serverObj);
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_TABLE_BY_ID_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY*)_other));
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_TABLE_BY_ID_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("server=");
		_buf.append(server);
		_buf.append(',');
		_buf.append("serverObj=");
		_buf.append(serverObj);
	}
	return _buf.c_str();
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_TABLE_BY_ID_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("server", server, _buf);
		Atf::XmlElement::encodeAsXmlElement("serverObj", serverObj, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("server"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, server)) return false;
			}
			else if (_element.equals("serverObj"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, serverObj)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(server);
		_msg.composeString(serverObj);
	}
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(server);
		_parser.parseStringP(serverObj);
	}
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("server", server);
		_jsonstr.compose("serverObj", serverObj);
	}
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("server", server);
		_jparser.parseByNameThrow("serverObj", serverObj);
	}
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_TABLE_BY_ID_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString server; _jparser.validateByNameThrow("server", server);
		AtfValidator::validateInt(_descr, "server", server.length(), _checker, __FILE__, __LINE__);
		PString serverObj; _jparser.validateByNameThrow("serverObj", serverObj);
		AtfValidator::validateInt(_descr, "serverObj", serverObj.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_TABLE_BY_ID_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "serverObj"); size_t szServerObj = strlen(_dummy);
		AtfValidator::validateInt(_descr, "serverObj", szServerObj, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_CAPTCHA
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA::Protocol_MSG_LOBBY_GET_CAPTCHA()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA::Protocol_MSG_LOBBY_GET_CAPTCHA(Protocol_MSG_LOBBY_GET_CAPTCHA&& _o)
	: userId(std::move(_o.userId))
{
}

Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA& Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA::operator=(Protocol_MSG_LOBBY_GET_CAPTCHA&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
	}
	return *this;
}

#endif

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA::clear()
{
	userId.clear();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA::equals(const Protocol_MSG_LOBBY_GET_CAPTCHA& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId);
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_CAPTCHA != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_CAPTCHA*)_other));
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_CAPTCHA).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	return _buf.c_str();
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_CAPTCHA).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_CAPTCHA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), 20, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_CAPTCHA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY::Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY::Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY(Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, image(std::move(_o.image))
	, checksum(std::move(_o.checksum))
{
}

Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY& Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY::operator=(Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		image = std::move(_o.image);
		checksum = std::move(_o.checksum);
	}
	return *this;
}

#endif

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	image.clear();
	checksum.clear();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY::equals(const Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		image.size() == _o.image.size() && memcmp(image.ptr(), _o.image.ptr(), image.size()) == 0 &&
		checksum.size() == _o.checksum.size() && memcmp(checksum.ptr(), _o.checksum.ptr(), checksum.size()) == 0;
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_CAPTCHA_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY*)_other));
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_CAPTCHA_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("image=");
		Atf::AtfTempl<PBlock>::ToTraceString(_buf, image);
		_buf.append(',');
		_buf.append("checksum=");
		Atf::AtfTempl<PBlock>::ToTraceString(_buf, checksum);
	}
	return _buf.c_str();
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_CAPTCHA_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("image", image, _buf);
		Atf::XmlElement::encodeAsXmlElement("checksum", checksum, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("image"))
			{
				Atf::XmlElement::_movePBlockWithNullStrip(_value, image);
			}
			else if (_element.equals("checksum"))
			{
				Atf::XmlElement::_movePBlockWithNullStrip(_value, checksum);
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg._composeVarBlock(image.ptr(), image.size());
		_msg._composeVarBlock(checksum.ptr(), checksum.size());
	}
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parsePBlock(image);
		_parser.parsePBlock(checksum);
	}
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("image", image);
		_jsonstr.compose("checksum", checksum);
	}
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("image", image);
		_jparser.parseByNameThrow("checksum", checksum);
	}
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_CAPTCHA_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PBlock image; _jparser.validateByNameThrow("image", image);
		AtfValidator::validateInt(_descr, "image", image.size(), _checker, __FILE__, __LINE__);
		PBlock checksum; _jparser.validateByNameThrow("checksum", checksum);
		AtfValidator::validateInt(_descr, "checksum", checksum.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_CAPTCHA_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		const BYTE* image; size_t szImage; _parser._parseVarBlock(image, szImage);  /*image*/
		AtfValidator::validateInt(_descr, "image", szImage, _checker, __FILE__, __LINE__);
		const BYTE* checksum; size_t szChecksum; _parser._parseVarBlock(checksum, szChecksum);  /*checksum*/
		AtfValidator::validateInt(_descr, "checksum", szChecksum, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CHALLENGE_QUESTION
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::Protocol_MSG_LOBBY_CHALLENGE_QUESTION()
{
	clear();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::clear()
{
	locale = 0;
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::equals(const Protocol_MSG_LOBBY_CHALLENGE_QUESTION& _o) const
{
	return locale == _o.locale;
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_CHALLENGE_QUESTION != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_CHALLENGE_QUESTION*)_other));
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CHALLENGE_QUESTION).append(")");
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	return _buf.c_str();
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_CHALLENGE_QUESTION).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("locale"))
			{
				locale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(locale);
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(locale);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("locale", locale);
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("locale", locale);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CHALLENGE_QUESTION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CHALLENGE_QUESTION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    ChallengeQuestion
//=================================================================

Lobby::lobby_unauth::ChallengeQuestion::ChallengeQuestion()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::lobby_unauth::ChallengeQuestion::ChallengeQuestion(ChallengeQuestion&& _o)
	: id(std::move(_o.id))
	, txt(std::move(_o.txt))
{
}

Lobby::lobby_unauth::ChallengeQuestion& Lobby::lobby_unauth::ChallengeQuestion::operator=(ChallengeQuestion&& _o)
{
	if(this != &_o)
	{
		id = std::move(_o.id);
		txt = std::move(_o.txt);
	}
	return *this;
}

#endif

void Lobby::lobby_unauth::ChallengeQuestion::clear()
{
	id = 0;
	txt.clear();
}

bool Lobby::lobby_unauth::ChallengeQuestion::equals(const ChallengeQuestion& _o) const
{
	return id == _o.id &&
		Atf::atfPStringEquals(txt, _o.txt);
}

const char *Lobby::lobby_unauth::ChallengeQuestion::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("id=");
	_buf.appendUint(id);
	_buf.append(',');
	_buf.append("txt=");
	_buf.append(txt);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::lobby_unauth::ChallengeQuestion::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("id", id, _buf);
	Atf::XmlElement::encodeAsXmlElement("txt", txt, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::lobby_unauth::ChallengeQuestion::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("id"))
		{
			id = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("txt"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, txt)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::lobby_unauth::ChallengeQuestion::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(id);
	_msg.composeString(txt);
}

void Lobby::lobby_unauth::ChallengeQuestion::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(id);
	_parser.parseStringP(txt);
}

const char *Lobby::lobby_unauth::ChallengeQuestion::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("id", id);
	_jsonstr.compose("txt", txt);
	return _buf.c_str();
}

void Lobby::lobby_unauth::ChallengeQuestion::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("id", id);
	_jparser.parseByNameThrow("txt", txt);
}

/* static */ void Lobby::lobby_unauth::ChallengeQuestion::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 id; _jparser.validateByNameThrow("id", id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	PString txt; _jparser.validateByNameThrow("txt", txt);
	AtfValidator::validateInt(_descr, "txt", txt.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::lobby_unauth::ChallengeQuestion::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 id; _parser.parseUINT32(id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "txt"); size_t szTxt = strlen(_dummy);
	AtfValidator::validateInt(_descr, "txt", szTxt, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY(Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, challenges(std::move(_o.challenges))
{
}

Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY& Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::operator=(Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		challenges = std::move(_o.challenges);
	}
	return *this;
}

#endif

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	challenges.clear();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::equals(const Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		challenges.equals(_o.challenges);
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_CHALLENGE_QUESTION_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY*)_other));
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CHALLENGE_QUESTION_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("challenges=");
		challenges.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_CHALLENGE_QUESTION_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		challenges.toXmlString("challenges", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("challenges"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ChallengeQuestion, 2 > >::FromXmlString(_value, challenges)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		challenges.composeMsg(_msg, _ignoreJSON);
	}
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		challenges.parseMsg(_parser);
	}
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("challenges", challenges);
	}
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("challenges", challenges);
	}
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CHALLENGE_QUESTION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< ChallengeQuestion > challenges; _jparser.validateByNameThrow("challenges", challenges);
		AtfValidator::validateInt(_descr, "challenges", challenges.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CHALLENGE_QUESTION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szChallenges = Atf::LAtfVector< ChallengeQuestion, 2 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("challenges"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "challenges", szChallenges, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_UPDATE_BY_LICENSE
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE()
{
	clear();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE::clear()
{
	platform = 0;
	license = 0;
	site = 0;
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE::equals(const Protocol_MSG_LOBBY_UPDATE_BY_LICENSE& _o) const
{
	return platform == _o.platform &&
		license == _o.license &&
		site == _o.site;
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_UPDATE_BY_LICENSE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_UPDATE_BY_LICENSE*)_other));
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_UPDATE_BY_LICENSE).append(")");
	_buf.append(',');
	_buf.append("platform=");
	_buf.appendUint(platform);
	_buf.append(',');
	_buf.append("license=");
	_buf.appendUint(license);
	_buf.append(',');
	_buf.append("site=");
	_buf.appendUint(site);
	return _buf.c_str();
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_UPDATE_BY_LICENSE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("platform", platform, _buf);
	Atf::XmlElement::encodeAsXmlElement("license", license, _buf);
	Atf::XmlElement::encodeAsXmlElement("site", site, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("platform"))
			{
				platform = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("license"))
			{
				license = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("site"))
			{
				site = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(platform);
	_msg.composeUINT32(license);
	_msg.composeUINT32(site);
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(platform);
	_parser.parseUINT32(license);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(site);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("platform", platform);
	_jsonstr.compose("license", license);
	_jsonstr.compose("site", site);
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("platform", platform);
	_jparser.parseByNameThrow("license", license);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("site", site);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_UPDATE_BY_LICENSE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 platform; _jparser.validateByNameThrow("platform", platform);
	AtfValidator::validateIntMax(_descr, "platform", platform, Client_Last, _checker, __FILE__, __LINE__);
	UINT32 license; _jparser.validateByNameThrow("license", license);
	AtfValidator::validateIntMax(_descr, "license", license, eLicenceLast, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 site; _jparser.validateByNameThrow("site", site);
	AtfValidator::validateIntMax(_descr, "site", site, PokerStars_Last, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_UPDATE_BY_LICENSE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 platform; _parser.parseUINT32(platform);
	AtfValidator::validateIntMax(_descr, "platform", platform, Client_Last, _checker, __FILE__, __LINE__);
	UINT32 license; _parser.parseUINT32(license);
	AtfValidator::validateIntMax(_descr, "license", license, eLicenceLast, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 site; _parser.parseUINT32(site);
	AtfValidator::validateIntMax(_descr, "site", site, PokerStars_Last, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY(Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, updateFolder(std::move(_o.updateFolder))
{
}

Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY& Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY::operator=(Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		updateFolder = std::move(_o.updateFolder);
	}
	return *this;
}

#endif

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	updateFolder.clear();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY::equals(const Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		Atf::atfPStringEquals(updateFolder, _o.updateFolder);
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_UPDATE_BY_LICENSE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY*)_other));
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_UPDATE_BY_LICENSE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("updateFolder=");
		_buf.append(updateFolder);
	}
	return _buf.c_str();
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_UPDATE_BY_LICENSE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("updateFolder", updateFolder, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("updateFolder"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, updateFolder)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeString(updateFolder);
	}
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseStringP(updateFolder);
	}
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("updateFolder", updateFolder);
	}
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("updateFolder", updateFolder);
	}
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_UPDATE_BY_LICENSE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString updateFolder; _jparser.validateByNameThrow("updateFolder", updateFolder);
		AtfValidator::validateInt(_descr, "updateFolder", updateFolder.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_UPDATE_BY_LICENSE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "updateFolder"); size_t szUpdateFolder = strlen(_dummy);
		AtfValidator::validateInt(_descr, "updateFolder", szUpdateFolder, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE()
{
	clear();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::clear()
{
	typeId = 0;
	clientReqId = 0;
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::equals(const Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE& _o) const
{
	return typeId == _o.typeId &&
		clientReqId == _o.clientReqId;
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_FIND_TABLE_TO_OBSERVE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE*)_other));
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_TABLE_TO_OBSERVE).append(")");
	_buf.append(',');
	_buf.append("typeId=");
	_buf.appendUint(typeId);
	_buf.append(',');
	_buf.append("clientReqId=");
	_buf.appendUint(clientReqId);
	return _buf.c_str();
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_FIND_TABLE_TO_OBSERVE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("typeId", typeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientReqId", clientReqId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("typeId"))
			{
				typeId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientReqId"))
			{
				clientReqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(typeId);
	_msg.composeUINT32(clientReqId);
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(typeId);
	_parser.parseUINT32(clientReqId);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("typeId", typeId);
	_jsonstr.compose("clientReqId", clientReqId);
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("typeId", typeId);
	_jparser.parseByNameThrow("clientReqId", clientReqId);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TABLE_TO_OBSERVE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 typeId; _jparser.validateByNameThrow("typeId", typeId);
	AtfValidator::validateInt(_descr, "typeId", typeId, _checker, __FILE__, __LINE__);
	UINT32 clientReqId; _jparser.validateByNameThrow("clientReqId", clientReqId);
	AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TABLE_TO_OBSERVE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 typeId; _parser.parseUINT32(typeId);
	AtfValidator::validateInt(_descr, "typeId", typeId, _checker, __FILE__, __LINE__);
	UINT32 clientReqId; _parser.parseUINT32(clientReqId);
	AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY(Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, clientReqId(std::move(_o.clientReqId))
	, server(std::move(_o.server))
	, tableId(std::move(_o.tableId))
	, tableId64(std::move(_o.tableId64))
	, serverObject(std::move(_o.serverObject))
{
}

Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY& Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::operator=(Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		clientReqId = std::move(_o.clientReqId);
		server = std::move(_o.server);
		tableId = std::move(_o.tableId);
		tableId64 = std::move(_o.tableId64);
		serverObject = std::move(_o.serverObject);
	}
	return *this;
}

#endif

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	clientReqId = 0;
	server.clear();
	tableId = 0;
	tableId64 = 0;
	serverObject.clear();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::equals(const Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		clientReqId == _o.clientReqId &&
		Atf::atfPStringEquals(server, _o.server) &&
		tableId == _o.tableId &&
		tableId64 == _o.tableId64 &&
		Atf::atfPStringEquals(serverObject, _o.serverObject);
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY*)_other));
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
		_buf.append(',');
		_buf.append("clientReqId=");
		_buf.appendUint(clientReqId);
	}
	else
	{
		_buf.append(',');
		_buf.append("server=");
		_buf.append(server);
		_buf.append(',');
		_buf.append("tableId=");
		_buf.appendUint(tableId);
		_buf.append(',');
		_buf.append("clientReqId=");
		_buf.appendUint(clientReqId);
		_buf.append(',');
		_buf.append("tableId64=");
		_buf.appendUint64(tableId64);
		_buf.append(',');
		_buf.append("serverObject=");
		_buf.append(serverObject);
	}
	return _buf.c_str();
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
		Atf::XmlElement::encodeAsXmlElement("clientReqId", clientReqId, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("server", server, _buf);
		Atf::XmlElement::encodeAsXmlElement("tableId", tableId, _buf);
		Atf::XmlElement::encodeAsXmlElement("clientReqId", clientReqId, _buf);
		Atf::XmlElement::encodeAsXmlElement("tableId64", tableId64, _buf);
		Atf::XmlElement::encodeAsXmlElement("serverObject", serverObject, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("clientReqId"))
			{
				clientReqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("server"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, server)) return false;
			}
			else if (_element.equals("tableId"))
			{
				tableId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tableId64"))
			{
				tableId64 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("serverObject"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, serverObject)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
		_msg.composeUINT32(clientReqId);
	}
	else
	{
		_msg.composeString(server);
		_msg.composeUINT32(tableId);
		_msg.composeUINT32(clientReqId);
		_msg.composeUINT64(tableId64);
		_msg.composeString(serverObject);
	}
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
		_parser.parseUINT32(clientReqId);
	}
	else
	{
		_parser.parseStringP(server);
		_parser.parseUINT32(tableId);
		_parser.parseUINT32(clientReqId);
		_parser.parseUINT64(tableId64);
		_parser.parseStringP(serverObject);
	}
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
		_jsonstr.compose("clientReqId", clientReqId);
	}
	else
	{
		_jsonstr.compose("server", server);
		_jsonstr.compose("tableId", tableId);
		_jsonstr.compose("clientReqId", clientReqId);
		_jsonstr.compose("tableId64", tableId64);
		_jsonstr.compose("serverObject", serverObject);
	}
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
		_jparser.parseByNameThrow("clientReqId", clientReqId);
	}
	else
	{
		_jparser.parseByNameThrow("server", server);
		_jparser.parseByNameThrow("tableId", tableId);
		_jparser.parseByNameThrow("clientReqId", clientReqId);
		_jparser.parseByNameThrow("tableId64", tableId64);
		_jparser.parseByNameThrow("serverObject", serverObject);
	}
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
		UINT32 clientReqId; _jparser.validateByNameThrow("clientReqId", clientReqId);
		AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString server; _jparser.validateByNameThrow("server", server);
		AtfValidator::validateInt(_descr, "server", server.length(), _checker, __FILE__, __LINE__);
		UINT32 tableId; _jparser.validateByNameThrow("tableId", tableId);
		AtfValidator::validateInt(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
		UINT32 clientReqId; _jparser.validateByNameThrow("clientReqId", clientReqId);
		AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
		UINT64 tableId64; _jparser.validateByNameThrow("tableId64", tableId64);
		AtfValidator::validateUint(_descr, "tableId64", tableId64, _checker, __FILE__, __LINE__);
		PString serverObject; _jparser.validateByNameThrow("serverObject", serverObject);
		AtfValidator::validateInt(_descr, "serverObject", serverObject.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
		UINT32 clientReqId; _parser.parseUINT32(clientReqId);
		AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
		UINT32 tableId; _parser.parseUINT32(tableId);
		AtfValidator::validateInt(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
		UINT32 clientReqId; _parser.parseUINT32(clientReqId);
		AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
		UINT64 tableId64; _parser.parseUINT64(tableId64);
		AtfValidator::validateUint(_descr, "tableId64", tableId64, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "serverObject"); size_t szServerObject = strlen(_dummy);
		AtfValidator::validateInt(_descr, "serverObject", szServerObject, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    Publication
//=================================================================

Lobby::lobby_unauth::Publication::Publication()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::lobby_unauth::Publication::Publication(Publication&& _o)
	: name(std::move(_o.name))
{
}

Lobby::lobby_unauth::Publication& Lobby::lobby_unauth::Publication::operator=(Publication&& _o)
{
	if(this != &_o)
	{
		name = std::move(_o.name);
	}
	return *this;
}

#endif

void Lobby::lobby_unauth::Publication::clear()
{
	name.clear();
}

bool Lobby::lobby_unauth::Publication::equals(const Publication& _o) const
{
	return Atf::atfPStringEquals(name, _o.name);
}

const char *Lobby::lobby_unauth::Publication::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("name=");
	_buf.append(name);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::lobby_unauth::Publication::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::lobby_unauth::Publication::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("name"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::lobby_unauth::Publication::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(name);
}

void Lobby::lobby_unauth::Publication::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(name);
}

const char *Lobby::lobby_unauth::Publication::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("name", name);
	return _buf.c_str();
}

void Lobby::lobby_unauth::Publication::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("name", name);
}

/* static */ void Lobby::lobby_unauth::Publication::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateIntMax(_descr, "name", name.length(), 1000, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::lobby_unauth::Publication::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "name", szName, 1000, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_CHECK_PUBLICATIONS
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS(Protocol_MSG_LOBBY_CHECK_PUBLICATIONS&& _o)
	: publications(std::move(_o.publications))
{
}

Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS& Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::operator=(Protocol_MSG_LOBBY_CHECK_PUBLICATIONS&& _o)
{
	if(this != &_o)
	{
		publications = std::move(_o.publications);
	}
	return *this;
}

#endif

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::clear()
{
	publications.clear();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::equals(const Protocol_MSG_LOBBY_CHECK_PUBLICATIONS& _o) const
{
	return publications.equals(_o.publications);
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_CHECK_PUBLICATIONS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_CHECK_PUBLICATIONS*)_other));
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CHECK_PUBLICATIONS).append(")");
	_buf.append(',');
	_buf.append("publications=");
	publications.toTraceString(_buf);
	return _buf.c_str();
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_CHECK_PUBLICATIONS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	publications.toXmlString("publications", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("publications"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< Publication, 4 > >::FromXmlString(_value, publications)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	publications.composeMsg(_msg, _ignoreJSON);
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	publications.parseMsg(_parser);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("publications", publications);
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("publications", publications);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CHECK_PUBLICATIONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	Atf::AtfVectorBase< Publication > publications; _jparser.validateByNameThrow("publications", publications);
	AtfValidator::validateIntMax(_descr, "publications", publications.size(), 1000, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CHECK_PUBLICATIONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(_parser.parseEnded()) return;
	PString _descbuf;
	int szPublications = Atf::LAtfVector< Publication, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("publications"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "publications", szPublications, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY
//=================================================================

Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY(Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY&& _o)
	: publicationExist(std::move(_o.publicationExist))
{
}

Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY& Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::operator=(Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY&& _o)
{
	if(this != &_o)
	{
		publicationExist = std::move(_o.publicationExist);
	}
	return *this;
}

#endif

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::clear()
{
	publicationExist.clear();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::equals(const Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY& _o) const
{
	return publicationExist.equals(_o.publicationExist);
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_CHECK_PUBLICATIONS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY*)_other));
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CHECK_PUBLICATIONS_REPLY).append(")");
	_buf.append(',');
	_buf.append("publicationExist=");
	publicationExist.toTraceString(_buf);
	return _buf.c_str();
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_CHECK_PUBLICATIONS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	publicationExist.toXmlString("publicationExist", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("publicationExist"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< bool, 4 > >::FromXmlString(_value, publicationExist)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	publicationExist.composeMsg(_msg, _ignoreJSON);
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::parseMsg(CommMsgParser& _parser)
{
	publicationExist.parseMsg(_parser);
}

const char *Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("publicationExist", publicationExist);
	return _buf.c_str();
}

void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("publicationExist", publicationExist);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CHECK_PUBLICATIONS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< bool > publicationExist; _jparser.validateByNameThrow("publicationExist", publicationExist);
	AtfValidator::validateInt(_descr, "publicationExist", publicationExist.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CHECK_PUBLICATIONS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szPublicationExist = Atf::LAtfVector< bool, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("publicationExist"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "publicationExist", szPublicationExist, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    GameConnectInfo
//=================================================================

Lobby::Personalization::GameConnectInfo::GameConnectInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::Personalization::GameConnectInfo::GameConnectInfo(GameConnectInfo&& _o)
	: gameId(std::move(_o.gameId))
	, server(std::move(_o.server))
	, serverObject(std::move(_o.serverObject))
	, scriptId(std::move(_o.scriptId))
	, category(std::move(_o.category))
	, shouldOpen(std::move(_o.shouldOpen))
{
}

Lobby::Personalization::GameConnectInfo& Lobby::Personalization::GameConnectInfo::operator=(GameConnectInfo&& _o)
{
	if(this != &_o)
	{
		gameId = std::move(_o.gameId);
		server = std::move(_o.server);
		serverObject = std::move(_o.serverObject);
		scriptId = std::move(_o.scriptId);
		category = std::move(_o.category);
		shouldOpen = std::move(_o.shouldOpen);
	}
	return *this;
}

#endif

void Lobby::Personalization::GameConnectInfo::clear()
{
	gameId = 0;
	server.clear();
	serverObject.clear();
	scriptId = 0;
	category = 0;
	shouldOpen = false;
}

bool Lobby::Personalization::GameConnectInfo::equals(const GameConnectInfo& _o) const
{
	return gameId == _o.gameId &&
		Atf::atfPStringEquals(server, _o.server) &&
		Atf::atfPStringEquals(serverObject, _o.serverObject) &&
		scriptId == _o.scriptId &&
		category == _o.category &&
		shouldOpen == _o.shouldOpen;
}

const char *Lobby::Personalization::GameConnectInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("gameId=");
	_buf.appendUint64(gameId);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("serverObject=");
	_buf.append(serverObject);
	_buf.append(',');
	_buf.append("scriptId=");
	_buf.appendUint(scriptId);
	_buf.append(',');
	_buf.append("category=");
	_buf.appendUint(category);
	_buf.append(',');
	_buf.append("shouldOpen=");
	_buf.appendUint(shouldOpen);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::Personalization::GameConnectInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("gameId", gameId, _buf);
	Atf::XmlElement::encodeAsXmlElement("server", server, _buf);
	Atf::XmlElement::encodeAsXmlElement("serverObject", serverObject, _buf);
	Atf::XmlElement::encodeAsXmlElement("scriptId", scriptId, _buf);
	Atf::XmlElement::encodeAsXmlElement("category", category, _buf);
	Atf::XmlElement::encodeAsXmlElement("shouldOpen", shouldOpen, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::Personalization::GameConnectInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("gameId"))
		{
			gameId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("server"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, server)) return false;
		}
		else if (_element.equals("serverObject"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, serverObject)) return false;
		}
		else if (_element.equals("scriptId"))
		{
			scriptId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("category"))
		{
			category = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("shouldOpen"))
		{
			shouldOpen = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::Personalization::GameConnectInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(GameConnectInfo())) // not empty
	{
		_body.composeUINT64(gameId);
		_body.composeString(server);
		_body.composeString(serverObject);
		_body.composeUINT32(scriptId);
		_body.composeUINT32(category);
		_body.composeBOOL(shouldOpen);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::Personalization::GameConnectInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT64(gameId);
	_parser0.parseStringP(server);
	_parser0.parseStringP(serverObject);
	_parser0.parseUINT32(scriptId);
	_parser0.parseUINT32(category);
	_parser0.parseBOOL(shouldOpen);
}

const char *Lobby::Personalization::GameConnectInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("gameId", gameId);
	_jsonstr.compose("server", server);
	_jsonstr.compose("serverObject", serverObject);
	_jsonstr.compose("scriptId", scriptId);
	_jsonstr.compose("category", category);
	_jsonstr.compose("shouldOpen", shouldOpen);
	return _buf.c_str();
}

void Lobby::Personalization::GameConnectInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("gameId", gameId);
	_jparser.parseByNameThrow("server", server);
	_jparser.parseByNameThrow("serverObject", serverObject);
	_jparser.parseByNameThrow("scriptId", scriptId);
	_jparser.parseByNameThrow("category", category);
	_jparser.parseByNameThrow("shouldOpen", shouldOpen);
}

/* static */ void Lobby::Personalization::GameConnectInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT64 gameId; _jparser.validateByNameThrow("gameId", gameId);
	AtfValidator::validateUint(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
	PString server; _jparser.validateByNameThrow("server", server);
	AtfValidator::validateInt(_descr, "server", server.length(), _checker, __FILE__, __LINE__);
	PString serverObject; _jparser.validateByNameThrow("serverObject", serverObject);
	AtfValidator::validateInt(_descr, "serverObject", serverObject.length(), _checker, __FILE__, __LINE__);
	UINT32 scriptId; _jparser.validateByNameThrow("scriptId", scriptId);
	AtfValidator::validateInt(_descr, "scriptId", scriptId, _checker, __FILE__, __LINE__);
	UINT32 category; _jparser.validateByNameThrow("category", category);
	AtfValidator::validateInt(_descr, "category", category, _checker, __FILE__, __LINE__);
	bool shouldOpen; _jparser.validateByNameThrow("shouldOpen", shouldOpen);
	AtfValidator::validateInt(_descr, "shouldOpen", shouldOpen, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::Personalization::GameConnectInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT64 gameId; _parser0.parseUINT64(gameId);
	AtfValidator::validateUint(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "serverObject"); size_t szServerObject = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObject", szServerObject, _checker, __FILE__, __LINE__);
	UINT32 scriptId; _parser0.parseUINT32(scriptId);
	AtfValidator::validateInt(_descr, "scriptId", scriptId, _checker, __FILE__, __LINE__);
	UINT32 category; _parser0.parseUINT32(category);
	AtfValidator::validateInt(_descr, "category", category, _checker, __FILE__, __LINE__);
	bool shouldOpen; _parser0.parseBOOL(shouldOpen);
	AtfValidator::validateInt(_descr, "shouldOpen", shouldOpen, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBY_PS_USER_AT
//=================================================================

Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT::Protocol_MSG_LOBBY_PS_USER_AT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT::Protocol_MSG_LOBBY_PS_USER_AT(Protocol_MSG_LOBBY_PS_USER_AT&& _o)
	: userId(std::move(_o.userId))
{
}

Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT& Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT::operator=(Protocol_MSG_LOBBY_PS_USER_AT&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
	}
	return *this;
}

#endif

void Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT::clear()
{
	userId.clear();
}

bool Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT::equals(const Protocol_MSG_LOBBY_PS_USER_AT& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId);
}

bool Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_PS_USER_AT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_PS_USER_AT*)_other));
}

const char *Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_PS_USER_AT).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	return _buf.c_str();
}

const char *Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_PS_USER_AT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
}

void Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
}

const char *Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	return _buf.c_str();
}

void Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
}

/*static*/ void Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_PS_USER_AT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), 200, _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_PS_USER_AT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, 200, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_PS_USER_AT_REPLY
//=================================================================

Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT_REPLY::Protocol_MSG_LOBBY_PS_USER_AT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT_REPLY::Protocol_MSG_LOBBY_PS_USER_AT_REPLY(Protocol_MSG_LOBBY_PS_USER_AT_REPLY&& _o)
	: tableConnInfo(std::move(_o.tableConnInfo))
	, tournConnInfo(std::move(_o.tournConnInfo))
	, blitzTournConnInfo(std::move(_o.blitzTournConnInfo))
	, blitzConnInfo(std::move(_o.blitzConnInfo))
{
}

Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT_REPLY& Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT_REPLY::operator=(Protocol_MSG_LOBBY_PS_USER_AT_REPLY&& _o)
{
	if(this != &_o)
	{
		tableConnInfo = std::move(_o.tableConnInfo);
		tournConnInfo = std::move(_o.tournConnInfo);
		blitzTournConnInfo = std::move(_o.blitzTournConnInfo);
		blitzConnInfo = std::move(_o.blitzConnInfo);
	}
	return *this;
}

#endif

void Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT_REPLY::clear()
{
	tableConnInfo.clear();
	tournConnInfo.clear();
	blitzTournConnInfo.clear();
	blitzConnInfo.clear();
}

bool Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT_REPLY::equals(const Protocol_MSG_LOBBY_PS_USER_AT_REPLY& _o) const
{
	return tableConnInfo.equals(_o.tableConnInfo) &&
		tournConnInfo.equals(_o.tournConnInfo) &&
		blitzTournConnInfo.equals(_o.blitzTournConnInfo) &&
		blitzConnInfo.equals(_o.blitzConnInfo);
}

bool Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_PS_USER_AT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_PS_USER_AT_REPLY*)_other));
}

const char *Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_PS_USER_AT_REPLY).append(")");
	_buf.append(',');
	_buf.append("tableConnInfo=");
	tableConnInfo.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tournConnInfo=");
	tournConnInfo.toTraceString(_buf);
	_buf.append(',');
	_buf.append("blitzTournConnInfo=");
	blitzTournConnInfo.toTraceString(_buf);
	_buf.append(',');
	_buf.append("blitzConnInfo=");
	blitzConnInfo.toTraceString(_buf);
	return _buf.c_str();
}

const char *Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_PS_USER_AT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	tableConnInfo.toXmlString("tableConnInfo", _buf);
	tournConnInfo.toXmlString("tournConnInfo", _buf);
	blitzTournConnInfo.toXmlString("blitzTournConnInfo", _buf);
	blitzConnInfo.toXmlString("blitzConnInfo", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tableConnInfo"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< GameConnectInfo, 4 > >::FromXmlString(_value, tableConnInfo)) return false;
			}
			else if (_element.equals("tournConnInfo"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< GameConnectInfo, 4 > >::FromXmlString(_value, tournConnInfo)) return false;
			}
			else if (_element.equals("blitzTournConnInfo"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< GameConnectInfo, 4 > >::FromXmlString(_value, blitzTournConnInfo)) return false;
			}
			else if (_element.equals("blitzConnInfo"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< GameConnectInfo, 4 > >::FromXmlString(_value, blitzConnInfo)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	tableConnInfo.composeMsg(_msg, _ignoreJSON);
	tournConnInfo.composeMsg(_msg, _ignoreJSON);
	blitzTournConnInfo.composeMsg(_msg, _ignoreJSON);
	blitzConnInfo.composeMsg(_msg, _ignoreJSON);
}

void Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT_REPLY::parseMsg(CommMsgParser& _parser)
{
	tableConnInfo.parseMsg(_parser);
	tournConnInfo.parseMsg(_parser);
	blitzTournConnInfo.parseMsg(_parser);
	blitzConnInfo.parseMsg(_parser);
}

const char *Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tableConnInfo", tableConnInfo);
	_jsonstr.compose("tournConnInfo", tournConnInfo);
	_jsonstr.compose("blitzTournConnInfo", blitzTournConnInfo);
	_jsonstr.compose("blitzConnInfo", blitzConnInfo);
	return _buf.c_str();
}

void Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tableConnInfo", tableConnInfo);
	_jparser.parseByNameThrow("tournConnInfo", tournConnInfo);
	_jparser.parseByNameThrow("blitzTournConnInfo", blitzTournConnInfo);
	_jparser.parseByNameThrow("blitzConnInfo", blitzConnInfo);
}

/*static*/ void Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_PS_USER_AT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< GameConnectInfo > tableConnInfo; _jparser.validateByNameThrow("tableConnInfo", tableConnInfo);
	AtfValidator::validateInt(_descr, "tableConnInfo", tableConnInfo.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< GameConnectInfo > tournConnInfo; _jparser.validateByNameThrow("tournConnInfo", tournConnInfo);
	AtfValidator::validateInt(_descr, "tournConnInfo", tournConnInfo.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< GameConnectInfo > blitzTournConnInfo; _jparser.validateByNameThrow("blitzTournConnInfo", blitzTournConnInfo);
	AtfValidator::validateInt(_descr, "blitzTournConnInfo", blitzTournConnInfo.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< GameConnectInfo > blitzConnInfo; _jparser.validateByNameThrow("blitzConnInfo", blitzConnInfo);
	AtfValidator::validateInt(_descr, "blitzConnInfo", blitzConnInfo.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::Personalization::Protocol_MSG_LOBBY_PS_USER_AT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_PS_USER_AT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTableConnInfo = Atf::LAtfVector< GameConnectInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableConnInfo"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tableConnInfo", szTableConnInfo, _checker, __FILE__, __LINE__);
	int szTournConnInfo = Atf::LAtfVector< GameConnectInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournConnInfo"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tournConnInfo", szTournConnInfo, _checker, __FILE__, __LINE__);
	int szBlitzTournConnInfo = Atf::LAtfVector< GameConnectInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("blitzTournConnInfo"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "blitzTournConnInfo", szBlitzTournConnInfo, _checker, __FILE__, __LINE__);
	int szBlitzConnInfo = Atf::LAtfVector< GameConnectInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("blitzConnInfo"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "blitzConnInfo", szBlitzConnInfo, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    TableStaticDataStruct
//=================================================================

Lobby::Personalization::TableStaticDataStruct::TableStaticDataStruct()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::Personalization::TableStaticDataStruct::TableStaticDataStruct(TableStaticDataStruct&& _o)
	: tableId(std::move(_o.tableId))
	, name(std::move(_o.name))
	, serverAddress(std::move(_o.serverAddress))
	, serverInstance(std::move(_o.serverInstance))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, game(std::move(_o.game))
	, isHiLo(std::move(_o.isHiLo))
	, maxPlayers(std::move(_o.maxPlayers))
	, tableFlags(std::move(_o.tableFlags))
	, tableInstanceFlags(std::move(_o.tableInstanceFlags))
	, chatLang(std::move(_o.chatLang))
	, structure(std::move(_o.structure))
	, loBet(std::move(_o.loBet))
	, hiBet(std::move(_o.hiBet))
	, ante(std::move(_o.ante))
	, cap(std::move(_o.cap))
	, specialName(std::move(_o.specialName))
	, currency(std::move(_o.currency))
	, minChipsLimit(std::move(_o.minChipsLimit))
	, maxBuyIn(std::move(_o.maxBuyIn))
	, icon(std::move(_o.icon))
	, filter(std::move(_o.filter))
	, countryRestrictionInverted(std::move(_o.countryRestrictionInverted))
	, restrictedCountries(std::move(_o.restrictedCountries))
	, scalePM(std::move(_o.scalePM))
	, defaultBuyIn(std::move(_o.defaultBuyIn))
	, tableFlags2(std::move(_o.tableFlags2))
	, brandMask(std::move(_o.brandMask))
	, poolBlockMinHands(std::move(_o.poolBlockMinHands))
	, tableTypeId(std::move(_o.tableTypeId))
	, tableStakes(std::move(_o.tableStakes))
	, variableAntes(std::move(_o.variableAntes))
	, visibilityMaskEx(std::move(_o.visibilityMaskEx))
{
}

Lobby::Personalization::TableStaticDataStruct& Lobby::Personalization::TableStaticDataStruct::operator=(TableStaticDataStruct&& _o)
{
	if(this != &_o)
	{
		tableId = std::move(_o.tableId);
		name = std::move(_o.name);
		serverAddress = std::move(_o.serverAddress);
		serverInstance = std::move(_o.serverInstance);
		isPlayMoney = std::move(_o.isPlayMoney);
		game = std::move(_o.game);
		isHiLo = std::move(_o.isHiLo);
		maxPlayers = std::move(_o.maxPlayers);
		tableFlags = std::move(_o.tableFlags);
		tableInstanceFlags = std::move(_o.tableInstanceFlags);
		chatLang = std::move(_o.chatLang);
		structure = std::move(_o.structure);
		loBet = std::move(_o.loBet);
		hiBet = std::move(_o.hiBet);
		ante = std::move(_o.ante);
		cap = std::move(_o.cap);
		specialName = std::move(_o.specialName);
		currency = std::move(_o.currency);
		minChipsLimit = std::move(_o.minChipsLimit);
		maxBuyIn = std::move(_o.maxBuyIn);
		icon = std::move(_o.icon);
		filter = std::move(_o.filter);
		countryRestrictionInverted = std::move(_o.countryRestrictionInverted);
		restrictedCountries = std::move(_o.restrictedCountries);
		scalePM = std::move(_o.scalePM);
		defaultBuyIn = std::move(_o.defaultBuyIn);
		tableFlags2 = std::move(_o.tableFlags2);
		brandMask = std::move(_o.brandMask);
		poolBlockMinHands = std::move(_o.poolBlockMinHands);
		tableTypeId = std::move(_o.tableTypeId);
		tableStakes = std::move(_o.tableStakes);
		variableAntes = std::move(_o.variableAntes);
		visibilityMaskEx = std::move(_o.visibilityMaskEx);
	}
	return *this;
}

#endif

void Lobby::Personalization::TableStaticDataStruct::clear()
{
	tableId = 0;
	name.clear();
	serverAddress.clear();
	serverInstance.clear();
	isPlayMoney = 0;
	game = 0;
	isHiLo = 0;
	maxPlayers = 0;
	tableFlags = 0;
	tableInstanceFlags = 0;
	chatLang = 0;
	structure = 0;
	loBet = 0;
	hiBet = 0;
	ante = 0;
	cap = 0;
	specialName.clear();
	currency.clear();
	minChipsLimit = 0;
	maxBuyIn = 0;
	icon = 0;
	filter = 0;
	countryRestrictionInverted = false;
	restrictedCountries.clear();
	scalePM = 0;
	defaultBuyIn = 0;
	tableFlags2 = 0;
	brandMask = 0;
	poolBlockMinHands = 0;
	tableTypeId = 0;
	tableStakes.clear();
	variableAntes.clear();
	visibilityMaskEx.clear();
}

bool Lobby::Personalization::TableStaticDataStruct::equals(const TableStaticDataStruct& _o) const
{
	return tableId == _o.tableId &&
		Atf::atfPStringEquals(name, _o.name) &&
		Atf::atfPStringEquals(serverAddress, _o.serverAddress) &&
		Atf::atfPStringEquals(serverInstance, _o.serverInstance) &&
		isPlayMoney == _o.isPlayMoney &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		maxPlayers == _o.maxPlayers &&
		tableFlags == _o.tableFlags &&
		tableInstanceFlags == _o.tableInstanceFlags &&
		chatLang == _o.chatLang &&
		structure == _o.structure &&
		loBet == _o.loBet &&
		hiBet == _o.hiBet &&
		ante == _o.ante &&
		cap == _o.cap &&
		Atf::atfPStringEquals(specialName, _o.specialName) &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		minChipsLimit == _o.minChipsLimit &&
		maxBuyIn == _o.maxBuyIn &&
		icon == _o.icon &&
		filter == _o.filter &&
		countryRestrictionInverted == _o.countryRestrictionInverted &&
		restrictedCountries.equals(_o.restrictedCountries) &&
		scalePM == _o.scalePM &&
		defaultBuyIn == _o.defaultBuyIn &&
		tableFlags2 == _o.tableFlags2 &&
		brandMask == _o.brandMask &&
		poolBlockMinHands == _o.poolBlockMinHands &&
		tableTypeId == _o.tableTypeId &&
		tableStakes.equals(_o.tableStakes) &&
		variableAntes.equals(_o.variableAntes) &&
		visibilityMaskEx.equals(_o.visibilityMaskEx);
}

const char *Lobby::Personalization::TableStaticDataStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("serverAddress=");
	_buf.append(serverAddress);
	_buf.append(',');
	_buf.append("serverInstance=");
	_buf.append(serverInstance);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendUint(maxPlayers);
	_buf.append(',');
	_buf.append("tableFlags=");
	_buf.appendUint(tableFlags);
	_buf.append(',');
	_buf.append("tableInstanceFlags=");
	_buf.appendUint(tableInstanceFlags);
	_buf.append(',');
	_buf.append("chatLang=");
	_buf.appendUint(chatLang);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("loBet=");
	_buf.appendUint(loBet);
	_buf.append(',');
	_buf.append("hiBet=");
	_buf.appendUint(hiBet);
	_buf.append(',');
	_buf.append("ante=");
	_buf.appendUint(ante);
	_buf.append(',');
	_buf.append("cap=");
	_buf.appendUint(cap);
	_buf.append(',');
	_buf.append("specialName=");
	_buf.append(specialName);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("minChipsLimit=");
	_buf.appendUint(minChipsLimit);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendUint(maxBuyIn);
	_buf.append(',');
	_buf.append("icon=");
	_buf.appendUint(icon);
	_buf.append(',');
	_buf.append("filter=");
	_buf.appendUint(filter);
	_buf.append(',');
	_buf.append("countryRestrictionInverted=");
	_buf.appendUint(countryRestrictionInverted);
	_buf.append(',');
	_buf.append("restrictedCountries=");
	restrictedCountries.toTraceString(_buf);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("defaultBuyIn=");
	_buf.appendUint(defaultBuyIn);
	_buf.append(',');
	_buf.append("tableFlags2=");
	_buf.appendUint64(tableFlags2);
	_buf.append(',');
	_buf.append("brandMask=");
	_buf.appendUint(brandMask);
	_buf.append(',');
	_buf.append("poolBlockMinHands=");
	_buf.appendInt(poolBlockMinHands);
	_buf.append(',');
	_buf.append("tableTypeId=");
	_buf.appendUint(tableTypeId);
	_buf.append(',');
	_buf.append("tableStakes=");
	tableStakes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("variableAntes=");
	variableAntes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("visibilityMaskEx=");
	visibilityMaskEx.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::Personalization::TableStaticDataStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("tableId", tableId, _buf);
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	Atf::XmlElement::encodeAsXmlElement("serverAddress", serverAddress, _buf);
	Atf::XmlElement::encodeAsXmlElement("serverInstance", serverInstance, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPlayers", maxPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableFlags", tableFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableInstanceFlags", tableInstanceFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("chatLang", chatLang, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("loBet", loBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("hiBet", hiBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("ante", ante, _buf);
	Atf::XmlElement::encodeAsXmlElement("cap", cap, _buf);
	Atf::XmlElement::encodeAsXmlElement("specialName", specialName, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("minChipsLimit", minChipsLimit, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxBuyIn", maxBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("icon", icon, _buf);
	Atf::XmlElement::encodeAsXmlElement("filter", filter, _buf);
	Atf::XmlElement::encodeAsXmlElement("countryRestrictionInverted", countryRestrictionInverted, _buf);
	restrictedCountries.toXmlString("restrictedCountries", _buf);
	Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
	Atf::XmlElement::encodeAsXmlElement("defaultBuyIn", defaultBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableFlags2", tableFlags2, _buf);
	Atf::XmlElement::encodeAsXmlElement("brandMask", brandMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("poolBlockMinHands", poolBlockMinHands, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableTypeId", tableTypeId, _buf);
	tableStakes.toXmlString("tableStakes", _buf);
	variableAntes.toXmlString("variableAntes", _buf);
	visibilityMaskEx.toXmlString("visibilityMaskEx", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::Personalization::TableStaticDataStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("tableId"))
		{
			tableId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("name"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
		}
		else if (_element.equals("serverAddress"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, serverAddress)) return false;
		}
		else if (_element.equals("serverInstance"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, serverInstance)) return false;
		}
		else if (_element.equals("isPlayMoney"))
		{
			isPlayMoney = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("game"))
		{
			game = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxPlayers"))
		{
			maxPlayers = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableFlags"))
		{
			tableFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableInstanceFlags"))
		{
			tableInstanceFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("chatLang"))
		{
			chatLang = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("structure"))
		{
			structure = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("loBet"))
		{
			loBet = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("hiBet"))
		{
			hiBet = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("ante"))
		{
			ante = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("cap"))
		{
			cap = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("specialName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, specialName)) return false;
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("minChipsLimit"))
		{
			minChipsLimit = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxBuyIn"))
		{
			maxBuyIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("icon"))
		{
			icon = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("filter"))
		{
			filter = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("countryRestrictionInverted"))
		{
			countryRestrictionInverted = (*_value.ptr() == '1');
		}
		else if (_element.equals("restrictedCountries"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PString, 4 > >::FromXmlString(_value, restrictedCountries)) return false;
		}
		else if (_element.equals("scalePM"))
		{
			scalePM = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("defaultBuyIn"))
		{
			defaultBuyIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableFlags2"))
		{
			tableFlags2 = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("brandMask"))
		{
			brandMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("poolBlockMinHands"))
		{
			poolBlockMinHands = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableTypeId"))
		{
			tableTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableStakes"))
		{
			if(!Atf::AtfTempl< TableCommon::TableStakes >::FromXmlString(_value, tableStakes)) return false;
		}
		else if (_element.equals("variableAntes"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT64, 4 > >::FromXmlString(_value, variableAntes)) return false;
		}
		else if (_element.equals("visibilityMaskEx"))
		{
			if(!Atf::AtfTempl< PSiteMask >::FromXmlString(_value, visibilityMaskEx)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::Personalization::TableStaticDataStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(tableId);
	_msg.composeString(name);
	_msg.composeString(serverAddress);
	_msg.composeString(serverInstance);
	_msg.composeBYTE(isPlayMoney);
	_msg.composeBYTE(game);
	_msg.composeBYTE(isHiLo);
	_msg.composeBYTE(maxPlayers);
	_msg.composeUINT32(tableFlags);
	_msg.composeUINT32(tableInstanceFlags);
	_msg.composeUINT16(chatLang);
	_msg.composeBYTE(structure);
	_msg.composeUINT32(loBet);
	_msg.composeUINT32(hiBet);
	_msg.composeUINT32(ante);
	_msg.composeUINT32(cap);
	_msg.composeString(specialName);
	_msg.composeString(currency);
	_msg.composeUINT32(minChipsLimit);
	_msg.composeUINT32(maxBuyIn);
	_msg.composeBYTE(icon);
	_msg.composeBYTE(filter);
	_msg.composeBOOL(countryRestrictionInverted);
	restrictedCountries.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(scalePM);
	_msg.composeUINT32(defaultBuyIn);
	_msg.composeUINT64(tableFlags2);
	_msg.composeUINT32(brandMask);
	_msg.composeINT32(poolBlockMinHands);
	_msg.composeUINT32(tableTypeId);
	tableStakes.composeMsg(_msg, _ignoreJSON);
	variableAntes.composeMsg(_msg, _ignoreJSON);
	visibilityMaskEx.composeMsg(_msg, _ignoreJSON);
}

void Lobby::Personalization::TableStaticDataStruct::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(tableId);
	_parser.parseStringP(name);
	_parser.parseStringP(serverAddress);
	_parser.parseStringP(serverInstance);
	_parser.parseBYTE(isPlayMoney);
	_parser.parseBYTE(game);
	_parser.parseBYTE(isHiLo);
	_parser.parseBYTE(maxPlayers);
	_parser.parseUINT32(tableFlags);
	_parser.parseUINT32(tableInstanceFlags);
	_parser.parseUINT16(chatLang);
	_parser.parseBYTE(structure);
	_parser.parseUINT32(loBet);
	_parser.parseUINT32(hiBet);
	_parser.parseUINT32(ante);
	_parser.parseUINT32(cap);
	_parser.parseStringP(specialName);
	_parser.parseStringP(currency);
	_parser.parseUINT32(minChipsLimit);
	_parser.parseUINT32(maxBuyIn);
	_parser.parseBYTE(icon);
	_parser.parseBYTE(filter);
	_parser.parseBOOL(countryRestrictionInverted);
	restrictedCountries.parseMsg(_parser);
	_parser.parseUINT32(scalePM);
	_parser.parseUINT32(defaultBuyIn);
	_parser.parseUINT64(tableFlags2);
	_parser.parseUINT32(brandMask);
	_parser.parseINT32(poolBlockMinHands);
	_parser.parseUINT32(tableTypeId);
	tableStakes.parseMsg(_parser);
	variableAntes.parseMsg(_parser);
	visibilityMaskEx.parseMsg(_parser);
}

const char *Lobby::Personalization::TableStaticDataStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tableId", tableId);
	_jsonstr.compose("name", name);
	_jsonstr.compose("serverAddress", serverAddress);
	_jsonstr.compose("serverInstance", serverInstance);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("game", game);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("maxPlayers", maxPlayers);
	_jsonstr.compose("tableFlags", tableFlags);
	_jsonstr.compose("tableInstanceFlags", tableInstanceFlags);
	_jsonstr.compose("chatLang", chatLang);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("loBet", loBet);
	_jsonstr.compose("hiBet", hiBet);
	_jsonstr.compose("ante", ante);
	_jsonstr.compose("cap", cap);
	_jsonstr.compose("specialName", specialName);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("minChipsLimit", minChipsLimit);
	_jsonstr.compose("maxBuyIn", maxBuyIn);
	_jsonstr.compose("icon", icon);
	_jsonstr.compose("filter", filter);
	_jsonstr.compose("countryRestrictionInverted", countryRestrictionInverted);
	_jsonstr.compose("restrictedCountries", restrictedCountries);
	_jsonstr.compose("scalePM", scalePM);
	_jsonstr.compose("defaultBuyIn", defaultBuyIn);
	_jsonstr.compose("tableFlags2", tableFlags2);
	_jsonstr.compose("brandMask", brandMask);
	_jsonstr.compose("poolBlockMinHands", poolBlockMinHands);
	_jsonstr.compose("tableTypeId", tableTypeId);
	_jsonstr.compose("tableStakes", tableStakes);
	_jsonstr.compose("variableAntes", variableAntes);
	_jsonstr.compose("visibilityMaskEx", visibilityMaskEx);
	return _buf.c_str();
}

void Lobby::Personalization::TableStaticDataStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tableId", tableId);
	_jparser.parseByNameThrow("name", name);
	_jparser.parseByNameThrow("serverAddress", serverAddress);
	_jparser.parseByNameThrow("serverInstance", serverInstance);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("maxPlayers", maxPlayers);
	_jparser.parseByNameThrow("tableFlags", tableFlags);
	_jparser.parseByNameThrow("tableInstanceFlags", tableInstanceFlags);
	_jparser.parseByNameThrow("chatLang", chatLang);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("loBet", loBet);
	_jparser.parseByNameThrow("hiBet", hiBet);
	_jparser.parseByNameThrow("ante", ante);
	_jparser.parseByNameThrow("cap", cap);
	_jparser.parseByNameThrow("specialName", specialName);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("minChipsLimit", minChipsLimit);
	_jparser.parseByNameThrow("maxBuyIn", maxBuyIn);
	_jparser.parseByNameThrow("icon", icon);
	_jparser.parseByNameThrow("filter", filter);
	_jparser.parseByNameThrow("countryRestrictionInverted", countryRestrictionInverted);
	_jparser.parseByNameThrow("restrictedCountries", restrictedCountries);
	_jparser.parseByNameThrow("scalePM", scalePM);
	_jparser.parseByNameThrow("defaultBuyIn", defaultBuyIn);
	_jparser.parseByNameThrow("tableFlags2", tableFlags2);
	_jparser.parseByNameThrow("brandMask", brandMask);
	_jparser.parseByNameThrow("poolBlockMinHands", poolBlockMinHands);
	_jparser.parseByNameThrow("tableTypeId", tableTypeId);
	_jparser.parseByNameThrow("tableStakes", tableStakes);
	_jparser.parseByNameThrow("variableAntes", variableAntes);
	_jparser.parseByNameThrow("visibilityMaskEx", visibilityMaskEx);
}

/* static */ void Lobby::Personalization::TableStaticDataStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT64 tableId; _jparser.validateByNameThrow("tableId", tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateInt(_descr, "name", name.length(), _checker, __FILE__, __LINE__);
	PString serverAddress; _jparser.validateByNameThrow("serverAddress", serverAddress);
	AtfValidator::validateInt(_descr, "serverAddress", serverAddress.length(), _checker, __FILE__, __LINE__);
	PString serverInstance; _jparser.validateByNameThrow("serverInstance", serverInstance);
	AtfValidator::validateInt(_descr, "serverInstance", serverInstance.length(), _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE maxPlayers; _jparser.validateByNameThrow("maxPlayers", maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	UINT32 tableFlags; _jparser.validateByNameThrow("tableFlags", tableFlags);
	AtfValidator::validateInt(_descr, "tableFlags", tableFlags, _checker, __FILE__, __LINE__);
	UINT32 tableInstanceFlags; _jparser.validateByNameThrow("tableInstanceFlags", tableInstanceFlags);
	AtfValidator::validateInt(_descr, "tableInstanceFlags", tableInstanceFlags, _checker, __FILE__, __LINE__);
	UINT16 chatLang; _jparser.validateByNameThrow("chatLang", chatLang);
	AtfValidator::validateInt(_descr, "chatLang", chatLang, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	UINT32 loBet; _jparser.validateByNameThrow("loBet", loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	UINT32 hiBet; _jparser.validateByNameThrow("hiBet", hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	UINT32 ante; _jparser.validateByNameThrow("ante", ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	UINT32 cap; _jparser.validateByNameThrow("cap", cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	PString specialName; _jparser.validateByNameThrow("specialName", specialName);
	AtfValidator::validateInt(_descr, "specialName", specialName.length(), _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	UINT32 minChipsLimit; _jparser.validateByNameThrow("minChipsLimit", minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	UINT32 maxBuyIn; _jparser.validateByNameThrow("maxBuyIn", maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	BYTE icon; _jparser.validateByNameThrow("icon", icon);
	AtfValidator::validateInt(_descr, "icon", icon, _checker, __FILE__, __LINE__);
	BYTE filter; _jparser.validateByNameThrow("filter", filter);
	AtfValidator::validateInt(_descr, "filter", filter, _checker, __FILE__, __LINE__);
	bool countryRestrictionInverted; _jparser.validateByNameThrow("countryRestrictionInverted", countryRestrictionInverted);
	AtfValidator::validateInt(_descr, "countryRestrictionInverted", countryRestrictionInverted, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PString > restrictedCountries; _jparser.validateByNameThrow("restrictedCountries", restrictedCountries);
	AtfValidator::validateInt(_descr, "restrictedCountries", restrictedCountries.size(), _checker, __FILE__, __LINE__);
	UINT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT32 defaultBuyIn; _jparser.validateByNameThrow("defaultBuyIn", defaultBuyIn);
	AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	UINT64 tableFlags2; _jparser.validateByNameThrow("tableFlags2", tableFlags2);
	AtfValidator::validateUint(_descr, "tableFlags2", tableFlags2, _checker, __FILE__, __LINE__);
	UINT32 brandMask; _jparser.validateByNameThrow("brandMask", brandMask);
	AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
	INT32 poolBlockMinHands; _jparser.validateByNameThrow("poolBlockMinHands", poolBlockMinHands);
	AtfValidator::validateInt(_descr, "poolBlockMinHands", poolBlockMinHands, _checker, __FILE__, __LINE__);
	UINT32 tableTypeId; _jparser.validateByNameThrow("tableTypeId", tableTypeId);
	AtfValidator::validateInt(_descr, "tableTypeId", tableTypeId, _checker, __FILE__, __LINE__);
	TableCommon::TableStakes tableStakes; _jparser.validateByNameThrow("tableStakes", tableStakes);
	Atf::AtfVectorBase< INT64 > variableAntes; _jparser.validateByNameThrow("variableAntes", variableAntes);
	AtfValidator::validateInt(_descr, "variableAntes", variableAntes.size(), _checker, __FILE__, __LINE__);
	PSiteMask visibilityMaskEx; _jparser.validateByNameThrow("visibilityMaskEx", visibilityMaskEx);
}

/*static*/ void Lobby::Personalization::TableStaticDataStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT64 tableId; _parser.parseUINT64(tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "serverAddress"); size_t szServerAddress = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverAddress", szServerAddress, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "serverInstance"); size_t szServerInstance = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverInstance", szServerInstance, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE maxPlayers; _parser.parseBYTE(maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	UINT32 tableFlags; _parser.parseUINT32(tableFlags);
	AtfValidator::validateInt(_descr, "tableFlags", tableFlags, _checker, __FILE__, __LINE__);
	UINT32 tableInstanceFlags; _parser.parseUINT32(tableInstanceFlags);
	AtfValidator::validateInt(_descr, "tableInstanceFlags", tableInstanceFlags, _checker, __FILE__, __LINE__);
	UINT16 chatLang; _parser.parseUINT16(chatLang);
	AtfValidator::validateInt(_descr, "chatLang", chatLang, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	UINT32 loBet; _parser.parseUINT32(loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	UINT32 hiBet; _parser.parseUINT32(hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	UINT32 ante; _parser.parseUINT32(ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	UINT32 cap; _parser.parseUINT32(cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "specialName"); size_t szSpecialName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "specialName", szSpecialName, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 minChipsLimit; _parser.parseUINT32(minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	UINT32 maxBuyIn; _parser.parseUINT32(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	BYTE icon; _parser.parseBYTE(icon);
	AtfValidator::validateInt(_descr, "icon", icon, _checker, __FILE__, __LINE__);
	BYTE filter; _parser.parseBYTE(filter);
	AtfValidator::validateInt(_descr, "filter", filter, _checker, __FILE__, __LINE__);
	bool countryRestrictionInverted; _parser.parseBOOL(countryRestrictionInverted);
	AtfValidator::validateInt(_descr, "countryRestrictionInverted", countryRestrictionInverted, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szRestrictedCountries = Atf::LAtfVector< PString, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("restrictedCountries"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "restrictedCountries", szRestrictedCountries, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT32 defaultBuyIn; _parser.parseUINT32(defaultBuyIn);
	AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	UINT64 tableFlags2; _parser.parseUINT64(tableFlags2);
	AtfValidator::validateUint(_descr, "tableFlags2", tableFlags2, _checker, __FILE__, __LINE__);
	UINT32 brandMask; _parser.parseUINT32(brandMask);
	AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
	INT32 poolBlockMinHands; _parser.parseINT32(poolBlockMinHands);
	AtfValidator::validateInt(_descr, "poolBlockMinHands", poolBlockMinHands, _checker, __FILE__, __LINE__);
	UINT32 tableTypeId; _parser.parseUINT32(tableTypeId);
	AtfValidator::validateInt(_descr, "tableTypeId", tableTypeId, _checker, __FILE__, __LINE__);
	TableCommon::TableStakes::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableStakes"), _fieldsWithUnparsedContent);
	int szVariableAntes = Atf::LAtfVector< INT64, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("variableAntes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "variableAntes", szVariableAntes, _checker, __FILE__, __LINE__);
	PSiteMask::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("visibilityMaskEx"), _fieldsWithUnparsedContent);
}

//=================================================================
//                    TableData
//=================================================================

Lobby::Personalization::TableData::TableData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::Personalization::TableData::TableData(TableData&& _o)
	: staticData(std::move(_o.staticData))
{
}

Lobby::Personalization::TableData& Lobby::Personalization::TableData::operator=(TableData&& _o)
{
	if(this != &_o)
	{
		staticData = std::move(_o.staticData);
	}
	return *this;
}

#endif

void Lobby::Personalization::TableData::clear()
{
	staticData.clear();
}

bool Lobby::Personalization::TableData::equals(const TableData& _o) const
{
	return staticData.equals(_o.staticData);
}

const char *Lobby::Personalization::TableData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("staticData=");
	staticData.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *Lobby::Personalization::TableData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	staticData.toXmlString("staticData", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool Lobby::Personalization::TableData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("staticData"))
		{
			if(!Atf::AtfTempl< TableStaticDataStruct >::FromXmlString(_value, staticData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void Lobby::Personalization::TableData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(TableData())) // not empty
	{
		staticData.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void Lobby::Personalization::TableData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	staticData.parseMsg(_parser0);
}

const char *Lobby::Personalization::TableData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("staticData", staticData);
	return _buf.c_str();
}

void Lobby::Personalization::TableData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("staticData", staticData);
}

/* static */ void Lobby::Personalization::TableData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TableStaticDataStruct staticData; _jparser.validateByNameThrow("staticData", staticData);
}

/*static*/ void Lobby::Personalization::TableData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	TableStaticDataStruct::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("staticData"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS
//=================================================================

Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS(Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS&& _o)
	: tableIds(std::move(_o.tableIds))
{
}

Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS& Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS::operator=(Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS&& _o)
{
	if(this != &_o)
	{
		tableIds = std::move(_o.tableIds);
	}
	return *this;
}

#endif

void Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS::clear()
{
	tableIds.clear();
}

bool Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS::equals(const Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS& _o) const
{
	return tableIds.equals(_o.tableIds);
}

bool Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS*)_other));
}

const char *Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS).append(")");
	_buf.append(',');
	_buf.append("tableIds=");
	tableIds.toTraceString(_buf);
	return _buf.c_str();
}

const char *Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	tableIds.toXmlString("tableIds", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tableIds"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT64, 4 > >::FromXmlString(_value, tableIds)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	tableIds.composeMsg(_msg, _ignoreJSON);
}

void Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS::parseMsg(CommMsgParser& _parser)
{
	tableIds.parseMsg(_parser);
}

const char *Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tableIds", tableIds);
	return _buf.c_str();
}

void Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tableIds", tableIds);
}

/*static*/ void Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< UINT64 > tableIds; _jparser.validateByNameThrow("tableIds", tableIds);
	AtfValidator::validateInt(_descr, "tableIds", tableIds.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTableIds = Atf::LAtfVector< UINT64, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableIds"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tableIds", szTableIds, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY
//=================================================================

Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY(Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, tables(std::move(_o.tables))
{
}

Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY& Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY::operator=(Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		tables = std::move(_o.tables);
	}
	return *this;
}

#endif

void Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	tables.clear();
}

bool Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY::equals(const Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		tables.equals(_o.tables);
}

bool Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY*)_other));
}

const char *Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("tables=");
		tables.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		tables.toXmlString("tables", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("tables"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TableData, 4 > >::FromXmlString(_value, tables)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		tables.composeMsg(_msg, _ignoreJSON);
	}
}

void Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		tables.parseMsg(_parser);
	}
}

const char *Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("tables", tables);
	}
	return _buf.c_str();
}

void Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("tables", tables);
	}
}

/*static*/ void Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< TableData > tables; _jparser.validateByNameThrow("tables", tables);
		AtfValidator::validateInt(_descr, "tables", tables.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Lobby::Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szTables = Atf::LAtfVector< TableData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tables"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tables", szTables, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ Atf::MessageProtocol* Lobby::ProtocolFactory::createMessageProtocolObject(const char *_nameSpace, UINT32 _msgId)
{
	Atf::MessageProtocol *_obj = NULL;

	if(!strcmp(_nameSpace, "Personalization"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS: _obj = new Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS(); break;
			case MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY: _obj = new Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY(); break;
			case MSG_LOBBY_PS_USER_AT: _obj = new Personalization::Protocol_MSG_LOBBY_PS_USER_AT(); break;
			case MSG_LOBBY_PS_USER_AT_REPLY: _obj = new Personalization::Protocol_MSG_LOBBY_PS_USER_AT_REPLY(); break;
		}
	}
	else if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_CLI_LOBBY_CONFIRM_POPUP: _obj = new cli::Protocol_MSG_CLI_LOBBY_CONFIRM_POPUP(); break;
			case MSG_CLI_LOBBY_FIND_QUICKSTART_SNG: _obj = new cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG(); break;
			case MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2: _obj = new cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2(); break;
			case MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY: _obj = new cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY(); break;
			case MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3: _obj = new cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3(); break;
			case MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY: _obj = new cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY(); break;
			case MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY: _obj = new cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY(); break;
			case MSG_LOBBY_ACTIVATE_ACCOUNT: _obj = new cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT(); break;
			case MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY: _obj = new cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY(); break;
			case MSG_LOBBY_ADMIN_INFO: _obj = new cli::Protocol_MSG_LOBBY_ADMIN_INFO(); break;
			case MSG_LOBBY_ADMIN_INFO_REPLY: _obj = new cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY(); break;
			case MSG_LOBBY_BE_AVC_RESEND: _obj = new cli::Protocol_MSG_LOBBY_BE_AVC_RESEND(); break;
			case MSG_LOBBY_BE_AVC_RESEND_REPLY: _obj = new cli::Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY(); break;
			case MSG_LOBBY_BE_AVC_VALIDATE: _obj = new cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE(); break;
			case MSG_LOBBY_BE_AVC_VALIDATE_REPLY: _obj = new cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY(); break;
			case MSG_LOBBY_CANCEL_RESERVED_SEAT: _obj = new cli::Protocol_MSG_LOBBY_CANCEL_RESERVED_SEAT(); break;
			case MSG_LOBBY_CANCEL_USERTOURN: _obj = new cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN(); break;
			case MSG_LOBBY_CANCEL_USERTOURN_REPLY: _obj = new cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY(); break;
			case MSG_LOBBY_CHALLENGE_QUESTION: _obj = new cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION(); break;
			case MSG_LOBBY_CHALLENGE_QUESTION_REPLY: _obj = new cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY(); break;
			case MSG_LOBBY_CHAT_COMPL: _obj = new cli::Protocol_MSG_LOBBY_CHAT_COMPL(); break;
			case MSG_LOBBY_CLIENT_CURR_CONV_OPT: _obj = new cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT(); break;
			case MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY: _obj = new cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY(); break;
			case MSG_LOBBY_CLIENT_QUEST: _obj = new cli::Protocol_MSG_LOBBY_CLIENT_QUEST(); break;
			case MSG_LOBBY_CLI_BOUNCED: _obj = new cli::Protocol_MSG_LOBBY_CLI_BOUNCED(); break;
			case MSG_LOBBY_CLI_BOUNCED_REPLY: _obj = new cli::Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY(); break;
			case MSG_LOBBY_CLI_GET_TLB_STANDIDNS2: _obj = new cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2(); break;
			case MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY: _obj = new cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY(); break;
			case MSG_LOBBY_CLI_REMATCH_ACCEPT: _obj = new cli::Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT(); break;
			case MSG_LOBBY_CLI_REMATCH_DECLINE: _obj = new cli::Protocol_MSG_LOBBY_CLI_REMATCH_DECLINE(); break;
			case MSG_LOBBY_CLI_TEAM_PS_ONLINE: _obj = new cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE(); break;
			case MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY: _obj = new cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY(); break;
			case MSG_LOBBY_CREATE_TOURNAMENT_REPLY: _obj = new cli::Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY(); break;
			case MSG_LOBBY_CREATE_USERTOURN: _obj = new cli::Protocol_MSG_LOBBY_CREATE_USERTOURN(); break;
			case MSG_LOBBY_DISABLE_SNG_AUTO_UNREG: _obj = new cli::Protocol_MSG_LOBBY_DISABLE_SNG_AUTO_UNREG(); break;
			case MSG_LOBBY_DONT_SHOW_PERSONAL_INFO: _obj = new cli::Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO(); break;
			case MSG_LOBBY_DONT_SHOW_WHERE: _obj = new cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE(); break;
			case MSG_LOBBY_DONT_SHOW_WHERE_REPLY: _obj = new cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY(); break;
			case MSG_LOBBY_EXCLUDE_PLAYER: _obj = new cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER(); break;
			case MSG_LOBBY_EXCLUDE_PLAYER_REPLY: _obj = new cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY(); break;
			case MSG_LOBBY_FIND_PLAYER2: _obj = new cli::Protocol_MSG_LOBBY_FIND_PLAYER2(); break;
			case MSG_LOBBY_FIND_PLAYER2_REPLY: _obj = new cli::Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY(); break;
			case MSG_LOBBY_FIND_PLAYER3: _obj = new cli::Protocol_MSG_LOBBY_FIND_PLAYER3(); break;
			case MSG_LOBBY_FIND_PLAYER3_REPLY: _obj = new cli::Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY(); break;
			case MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF: _obj = new cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF(); break;
			case MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY: _obj = new cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY(); break;
			case MSG_LOBBY_FIND_SEAT_MANAGER_TABLE: _obj = new cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE(); break;
			case MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2: _obj = new cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2(); break;
			case MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY: _obj = new cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY(); break;
			case MSG_LOBBY_FIND_SIMILAR_TABLE: _obj = new cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE(); break;
			case MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE: _obj = new cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE(); break;
			case MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY: _obj = new cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY(); break;
			case MSG_LOBBY_FIND_SIMILAR_TABLE_STOP: _obj = new cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_STOP(); break;
			case MSG_LOBBY_FIND_TABLE_TO_OBSERVE: _obj = new cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE(); break;
			case MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY: _obj = new cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY(); break;
			case MSG_LOBBY_FIND_TOURN: _obj = new cli::Protocol_MSG_LOBBY_FIND_TOURN(); break;
			case MSG_LOBBY_FIND_TOURN_IT: _obj = new cli::Protocol_MSG_LOBBY_FIND_TOURN_IT(); break;
			case MSG_LOBBY_FIND_TOURN_IT_REPLY: _obj = new cli::Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY(); break;
			case MSG_LOBBY_FIND_TOURN_REG: _obj = new cli::Protocol_MSG_LOBBY_FIND_TOURN_REG(); break;
			case MSG_LOBBY_FIND_TOURN_REG2: _obj = new cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2(); break;
			case MSG_LOBBY_FIND_TOURN_REG2_REPLY: _obj = new cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY(); break;
			case MSG_LOBBY_FIND_TOURN_REG_IT: _obj = new cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT(); break;
			case MSG_LOBBY_FIND_TOURN_REG_IT_REPLY: _obj = new cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY(); break;
			case MSG_LOBBY_FIND_TOURN_REG_REPLY: _obj = new cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY(); break;
			case MSG_LOBBY_FIND_TOURN_REPLY: _obj = new cli::Protocol_MSG_LOBBY_FIND_TOURN_REPLY(); break;
			case MSG_LOBBY_FIND_WAIT: _obj = new cli::Protocol_MSG_LOBBY_FIND_WAIT(); break;
			case MSG_LOBBY_FIND_WAIT_REPLY: _obj = new cli::Protocol_MSG_LOBBY_FIND_WAIT_REPLY(); break;
			case MSG_LOBBY_FR_AVC_RESEND: _obj = new cli::Protocol_MSG_LOBBY_FR_AVC_RESEND(); break;
			case MSG_LOBBY_FR_AVC_RESEND_REPLY: _obj = new cli::Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY(); break;
			case MSG_LOBBY_FR_AVC_VALIDATE: _obj = new cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE(); break;
			case MSG_LOBBY_FR_AVC_VALIDATE_REPLY: _obj = new cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY(); break;
			case MSG_LOBBY_GET_BUYIN_LIMIT: _obj = new cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT(); break;
			case MSG_LOBBY_GET_BUYIN_LIMIT_EX: _obj = new cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX(); break;
			case MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY: _obj = new cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY(); break;
			case MSG_LOBBY_GET_BUYIN_LIMIT_REPLY: _obj = new cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY(); break;
			case MSG_LOBBY_GET_CLIENT_OPTIONS: _obj = new cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS(); break;
			case MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY: _obj = new cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY(); break;
			case MSG_LOBBY_GET_CONSENTS: _obj = new cli::Protocol_MSG_LOBBY_GET_CONSENTS(); break;
			case MSG_LOBBY_GET_CONSENTS_REPLY: _obj = new cli::Protocol_MSG_LOBBY_GET_CONSENTS_REPLY(); break;
			case MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT: _obj = new cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT(); break;
			case MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY: _obj = new cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY(); break;
			case MSG_LOBBY_GET_JOINED_SEATFINDERS: _obj = new cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS(); break;
			case MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY: _obj = new cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY(); break;
			case MSG_LOBBY_GET_PLAYING_TIME_LIMIT: _obj = new cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT(); break;
			case MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY: _obj = new cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY(); break;
			case MSG_LOBBY_GET_PROMO_IMAGE: _obj = new cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE(); break;
			case MSG_LOBBY_GET_PROMO_IMAGE_REPLY: _obj = new cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY(); break;
			case MSG_LOBBY_GET_SELFEXCLUDED_STR: _obj = new cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR(); break;
			case MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY: _obj = new cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY(); break;
			case MSG_LOBBY_GET_SIMILAR_SATELLITES: _obj = new cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES(); break;
			case MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY: _obj = new cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY(); break;
			case MSG_LOBBY_GET_TLB: _obj = new cli::Protocol_MSG_LOBBY_GET_TLB(); break;
			case MSG_LOBBY_GET_TLB_REPLY: _obj = new cli::Protocol_MSG_LOBBY_GET_TLB_REPLY(); break;
			case MSG_LOBBY_GET_USER_CAPS: _obj = new cli::Protocol_MSG_LOBBY_GET_USER_CAPS(); break;
			case MSG_LOBBY_GET_USER_CAPS_REPLY: _obj = new cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY(); break;
			case MSG_LOBBY_GET_USER_INFO: _obj = new cli::Protocol_MSG_LOBBY_GET_USER_INFO(); break;
			case MSG_LOBBY_GET_USER_INFO_REPLY: _obj = new cli::Protocol_MSG_LOBBY_GET_USER_INFO_REPLY(); break;
			case MSG_LOBBY_HIDE_MOBILE_ICON: _obj = new cli::Protocol_MSG_LOBBY_HIDE_MOBILE_ICON(); break;
			case MSG_LOBBY_HISTORY_REQUEST: _obj = new cli::Protocol_MSG_LOBBY_HISTORY_REQUEST(); break;
			case MSG_LOBBY_HISTORY_REQUEST_REPLY: _obj = new cli::Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY(); break;
			case MSG_LOBBY_INIT_NETVERIFY_SESSION: _obj = new cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION(); break;
			case MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY: _obj = new cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY(); break;
			case MSG_LOBBY_INTELLIPOKER_PWD: _obj = new cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD(); break;
			case MSG_LOBBY_INTELLIPOKER_PWD_REPLY: _obj = new cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY(); break;
			case MSG_LOBBY_INTELLIPOKER_SIGNUP: _obj = new cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP(); break;
			case MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY: _obj = new cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY(); break;
			case MSG_LOBBY_IP_CHECK: _obj = new cli::Protocol_MSG_LOBBY_IP_CHECK(); break;
			case MSG_LOBBY_IT_DOCUMENT: _obj = new cli::Protocol_MSG_LOBBY_IT_DOCUMENT(); break;
			case MSG_LOBBY_IT_DOCUMENT_REPLY: _obj = new cli::Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY(); break;
			case MSG_LOBBY_JOIN_SEATFINDER: _obj = new cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER(); break;
			case MSG_LOBBY_JOIN_SEATFINDER_REPLY: _obj = new cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY(); break;
			case MSG_LOBBY_LEAVE_ALL_WAITING_LISTS: _obj = new cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS(); break;
			case MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY: _obj = new cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY(); break;
			case MSG_LOBBY_LEAVE_WAITING_LIST: _obj = new cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST(); break;
			case MSG_LOBBY_LEAVE_WAITING_LIST_REPLY: _obj = new cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY(); break;
			case MSG_LOBBY_LIST_REMOVE: _obj = new cli::Protocol_MSG_LOBBY_LIST_REMOVE(); break;
			case MSG_LOBBY_LOGOUT: _obj = new cli::Protocol_MSG_LOBBY_LOGOUT(); break;
			case MSG_LOBBY_LOGOUT_CONFIRM: _obj = new cli::Protocol_MSG_LOBBY_LOGOUT_CONFIRM(); break;
			case MSG_LOBBY_MIGRATION_CONVERT: _obj = new cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT(); break;
			case MSG_LOBBY_MIGRATION_CONVERT_REPLY: _obj = new cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY(); break;
			case MSG_LOBBY_MIGRATION_GET_INFO: _obj = new cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO(); break;
			case MSG_LOBBY_MIGRATION_GET_INFO_REPLY: _obj = new cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY(); break;
			case MSG_LOBBY_MIGRATION_LINK: _obj = new cli::Protocol_MSG_LOBBY_MIGRATION_LINK(); break;
			case MSG_LOBBY_MIGRATION_LINK_REPLY: _obj = new cli::Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY(); break;
			case MSG_LOBBY_MIGRATION_TRANSFER: _obj = new cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER(); break;
			case MSG_LOBBY_MIGRATION_TRANSFER_REPLY: _obj = new cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY(); break;
			case MSG_LOBBY_PLAYING_HISTORY_AUDIT: _obj = new cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT(); break;
			case MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY: _obj = new cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY(); break;
			case MSG_LOBBY_PUBLISH_VIP_STATUS: _obj = new cli::Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS(); break;
			case MSG_LOBBY_REGISTER_TOURN_USER: _obj = new cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER(); break;
			case MSG_LOBBY_REGISTER_TOURN_USER_REPLY: _obj = new cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY(); break;
			case MSG_LOBBY_REPORT_FIRST_LOGIN: _obj = new cli::Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN(); break;
			case MSG_LOBBY_RESEND_ACTIVATION_EMAIL: _obj = new cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL(); break;
			case MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY: _obj = new cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY(); break;
			case MSG_LOBBY_RESEND_MOBILE_VALIDATION: _obj = new cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION(); break;
			case MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY: _obj = new cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY(); break;
			case MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE: _obj = new cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE(); break;
			case MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY: _obj = new cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY(); break;
			case MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT: _obj = new cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT(); break;
			case MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY: _obj = new cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY(); break;
			case MSG_LOBBY_SEATFINDER_CHECK_CHIPS: _obj = new cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS(); break;
			case MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY: _obj = new cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY(); break;
			case MSG_LOBBY_SET_BUYIN_LIMIT: _obj = new cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT(); break;
			case MSG_LOBBY_SET_BUYIN_LIMIT_EX: _obj = new cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX(); break;
			case MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY: _obj = new cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY(); break;
			case MSG_LOBBY_SET_BUYIN_LIMIT_REPLY: _obj = new cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY(); break;
			case MSG_LOBBY_SET_CLIENT_OPTIONS: _obj = new cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS(); break;
			case MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY: _obj = new cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY(); break;
			case MSG_LOBBY_SET_PLAYING_TIME_LIMIT: _obj = new cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT(); break;
			case MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY: _obj = new cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY(); break;
			case MSG_LOBBY_SET_PROMO_IMAGE: _obj = new cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE(); break;
			case MSG_LOBBY_SET_PROMO_IMAGE_REPLY: _obj = new cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY(); break;
			case MSG_LOBBY_SET_TABLE_LIMITS2: _obj = new cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2(); break;
			case MSG_LOBBY_SET_TABLE_LIMITS2_REPLY: _obj = new cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY(); break;
			case MSG_LOBBY_SET_TOURN_EMAIL_FLAGS: _obj = new cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS(); break;
			case MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY: _obj = new cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY(); break;
			case MSG_LOBBY_SET_TOURN_LIMITS: _obj = new cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS(); break;
			case MSG_LOBBY_SET_TOURN_LIMITS_REPLY: _obj = new cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY(); break;
			case MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP: _obj = new cli::Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP(); break;
			case MSG_LOBBY_SOCIAL_SHARE_HAND: _obj = new cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND(); break;
			case MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY: _obj = new cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY(); break;
			case MSG_LOBBY_SUBMIT_STARCODE: _obj = new cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE(); break;
			case MSG_LOBBY_SUBMIT_STARCODE_REPLY: _obj = new cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY(); break;
			case MSG_LOBBY_TARGET_NEWS_DESKTOP: _obj = new cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP(); break;
			case MSG_LOBBY_TARGET_NEWS_MOBILE: _obj = new cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE(); break;
			case MSG_LOBBY_TICKET_TOURNTIDS: _obj = new cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS(); break;
			case MSG_LOBBY_TICKET_TOURNTIDS_REPLY: _obj = new cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY(); break;
			case MSG_LOBBY_TIMEZONE_SET: _obj = new cli::Protocol_MSG_LOBBY_TIMEZONE_SET(); break;
			case MSG_LOBBY_TIMEZONE_SET_REPLY: _obj = new cli::Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY(); break;
			case MSG_LOBBY_TOURN_STATS: _obj = new cli::Protocol_MSG_LOBBY_TOURN_STATS(); break;
			case MSG_LOBBY_TOURN_STATS_REPLY: _obj = new cli::Protocol_MSG_LOBBY_TOURN_STATS_REPLY(); break;
			case MSG_LOBBY_UNJOIN_SEATFINDER: _obj = new cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER(); break;
			case MSG_LOBBY_UNJOIN_SEATFINDER_REPLY: _obj = new cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY(); break;
			case MSG_LOBBY_UPDATE_DOB: _obj = new cli::Protocol_MSG_LOBBY_UPDATE_DOB(); break;
			case MSG_LOBBY_UPDATE_DOB_REPLY: _obj = new cli::Protocol_MSG_LOBBY_UPDATE_DOB_REPLY(); break;
			case MSG_LOBBY_USER_PROPS: _obj = new cli::Protocol_MSG_LOBBY_USER_PROPS(); break;
			case MSG_LOBBY_USER_PROPS_REPLY: _obj = new cli::Protocol_MSG_LOBBY_USER_PROPS_REPLY(); break;
			case MSG_LOBBY_USER_STATS: _obj = new cli::Protocol_MSG_LOBBY_USER_STATS(); break;
			case MSG_LOBBY_USER_STATS_REPLY: _obj = new cli::Protocol_MSG_LOBBY_USER_STATS_REPLY(); break;
			case MSG_LOBBY_USER_TOURNTICKETS2: _obj = new cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2(); break;
			case MSG_LOBBY_USER_TOURNTICKETS2_REPLY: _obj = new cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY(); break;
			case MSG_LOBBY_VALIDATE_MOBILE: _obj = new cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE(); break;
			case MSG_LOBBY_VALIDATE_MOBILE_REPLY: _obj = new cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY(); break;
			case MSG_LOBBY_VALIDATE_NEWINSTALL: _obj = new cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL(); break;
			case MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY: _obj = new cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY(); break;
			case MSG_LOBBY_WAITING_LIST: _obj = new cli::Protocol_MSG_LOBBY_WAITING_LIST(); break;
			case MSG_LOBBY_WAITING_LIST_REPLY: _obj = new cli::Protocol_MSG_LOBBY_WAITING_LIST_REPLY(); break;
			case MSG_LOBBY_WAIT_ON_TABLES: _obj = new cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES(); break;
			case MSG_LOBBY_WAIT_ON_TABLES_REPLY: _obj = new cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY(); break;
			case MSG_WAITING_INVITED_REPLY: _obj = new cli::Protocol_MSG_WAITING_INVITED_REPLY(); break;
			case MSG_WEB_FIND_PLAYER2: _obj = new cli::Protocol_MSG_WEB_FIND_PLAYER2(); break;
			case MSG_WEB_FIND_PLAYER2_REPLY: _obj = new cli::Protocol_MSG_WEB_FIND_PLAYER2_REPLY(); break;
			case MSG_WEB_FIND_PLAYER3: _obj = new cli::Protocol_MSG_WEB_FIND_PLAYER3(); break;
			case MSG_WEB_FIND_PLAYER3_REPLY: _obj = new cli::Protocol_MSG_WEB_FIND_PLAYER3_REPLY(); break;
			case MSG_WEB_FIND_TOURN: _obj = new cli::Protocol_MSG_WEB_FIND_TOURN(); break;
			case MSG_WEB_FIND_TOURN_REPLY: _obj = new cli::Protocol_MSG_WEB_FIND_TOURN_REPLY(); break;
		}
	}
	else if(!strcmp(_nameSpace, "lobby_unauth"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_CHALLENGE_QUESTION: _obj = new lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION(); break;
			case MSG_LOBBY_CHALLENGE_QUESTION_REPLY: _obj = new lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY(); break;
			case MSG_LOBBY_CHECK_PUBLICATIONS: _obj = new lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS(); break;
			case MSG_LOBBY_CHECK_PUBLICATIONS_REPLY: _obj = new lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY(); break;
			case MSG_LOBBY_CLIENT_ERROR: _obj = new lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR(); break;
			case MSG_LOBBY_CLIENT_ERROR_REPLY: _obj = new lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR_REPLY(); break;
			case MSG_LOBBY_FIND_TABLE_TO_OBSERVE: _obj = new lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE(); break;
			case MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY: _obj = new lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY(); break;
			case MSG_LOBBY_GET_CAPTCHA: _obj = new lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA(); break;
			case MSG_LOBBY_GET_CAPTCHA_REPLY: _obj = new lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY(); break;
			case MSG_LOBBY_GET_SATELLITES_TO_TOURN: _obj = new lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN(); break;
			case MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX: _obj = new lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX(); break;
			case MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY: _obj = new lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY(); break;
			case MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY: _obj = new lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY(); break;
			case MSG_LOBBY_GET_TABLE_BY_ID: _obj = new lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID(); break;
			case MSG_LOBBY_GET_TABLE_BY_ID_REPLY: _obj = new lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY(); break;
			case MSG_LOBBY_PROMO_COUNTRY: _obj = new lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY(); break;
			case MSG_LOBBY_PROMO_COUNTRY_REPLY: _obj = new lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY_REPLY(); break;
			case MSG_LOBBY_REPORT_INSTALL: _obj = new lobby_unauth::Protocol_MSG_LOBBY_REPORT_INSTALL(); break;
			case MSG_LOBBY_UPDATE_BY_LICENSE: _obj = new lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE(); break;
			case MSG_LOBBY_UPDATE_BY_LICENSE_REPLY: _obj = new lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY(); break;
		}
	}
	
	return _obj;
}

/* static */ bool Lobby::ProtocolFactory::validateProtocolMessageFromJSONString(const char *_nameSpace, UINT32 _msgId, const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "Personalization"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS: Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY: Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_PS_USER_AT: Personalization::Protocol_MSG_LOBBY_PS_USER_AT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_PS_USER_AT_REPLY: Personalization::Protocol_MSG_LOBBY_PS_USER_AT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_CLI_LOBBY_CONFIRM_POPUP: cli::Protocol_MSG_CLI_LOBBY_CONFIRM_POPUP::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CLI_LOBBY_FIND_QUICKSTART_SNG: cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2: cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY: cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3: cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY: cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY: cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_ACTIVATE_ACCOUNT: cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY: cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_ADMIN_INFO: cli::Protocol_MSG_LOBBY_ADMIN_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_ADMIN_INFO_REPLY: cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_BE_AVC_RESEND: cli::Protocol_MSG_LOBBY_BE_AVC_RESEND::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_BE_AVC_RESEND_REPLY: cli::Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_BE_AVC_VALIDATE: cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_BE_AVC_VALIDATE_REPLY: cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CANCEL_RESERVED_SEAT: cli::Protocol_MSG_LOBBY_CANCEL_RESERVED_SEAT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CANCEL_USERTOURN: cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CANCEL_USERTOURN_REPLY: cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CHALLENGE_QUESTION: cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CHALLENGE_QUESTION_REPLY: cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CHAT_COMPL: cli::Protocol_MSG_LOBBY_CHAT_COMPL::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLIENT_CURR_CONV_OPT: cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY: cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLIENT_QUEST: cli::Protocol_MSG_LOBBY_CLIENT_QUEST::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLI_BOUNCED: cli::Protocol_MSG_LOBBY_CLI_BOUNCED::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLI_BOUNCED_REPLY: cli::Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLI_GET_TLB_STANDIDNS2: cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY: cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLI_REMATCH_ACCEPT: cli::Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLI_REMATCH_DECLINE: cli::Protocol_MSG_LOBBY_CLI_REMATCH_DECLINE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLI_TEAM_PS_ONLINE: cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY: cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CREATE_TOURNAMENT_REPLY: cli::Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CREATE_USERTOURN: cli::Protocol_MSG_LOBBY_CREATE_USERTOURN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_DISABLE_SNG_AUTO_UNREG: cli::Protocol_MSG_LOBBY_DISABLE_SNG_AUTO_UNREG::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_DONT_SHOW_PERSONAL_INFO: cli::Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_DONT_SHOW_WHERE: cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_DONT_SHOW_WHERE_REPLY: cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_EXCLUDE_PLAYER: cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_EXCLUDE_PLAYER_REPLY: cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_PLAYER2: cli::Protocol_MSG_LOBBY_FIND_PLAYER2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_PLAYER2_REPLY: cli::Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_PLAYER3: cli::Protocol_MSG_LOBBY_FIND_PLAYER3::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_PLAYER3_REPLY: cli::Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF: cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY: cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_SEAT_MANAGER_TABLE: cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2: cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY: cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_SIMILAR_TABLE: cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE: cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY: cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_SIMILAR_TABLE_STOP: cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_STOP::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TABLE_TO_OBSERVE: cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY: cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TOURN: cli::Protocol_MSG_LOBBY_FIND_TOURN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TOURN_IT: cli::Protocol_MSG_LOBBY_FIND_TOURN_IT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TOURN_IT_REPLY: cli::Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TOURN_REG: cli::Protocol_MSG_LOBBY_FIND_TOURN_REG::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TOURN_REG2: cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TOURN_REG2_REPLY: cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TOURN_REG_IT: cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TOURN_REG_IT_REPLY: cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TOURN_REG_REPLY: cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TOURN_REPLY: cli::Protocol_MSG_LOBBY_FIND_TOURN_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_WAIT: cli::Protocol_MSG_LOBBY_FIND_WAIT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_WAIT_REPLY: cli::Protocol_MSG_LOBBY_FIND_WAIT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FR_AVC_RESEND: cli::Protocol_MSG_LOBBY_FR_AVC_RESEND::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FR_AVC_RESEND_REPLY: cli::Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FR_AVC_VALIDATE: cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FR_AVC_VALIDATE_REPLY: cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_BUYIN_LIMIT: cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_BUYIN_LIMIT_EX: cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY: cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_BUYIN_LIMIT_REPLY: cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_CLIENT_OPTIONS: cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY: cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_CONSENTS: cli::Protocol_MSG_LOBBY_GET_CONSENTS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_CONSENTS_REPLY: cli::Protocol_MSG_LOBBY_GET_CONSENTS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT: cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY: cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_JOINED_SEATFINDERS: cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY: cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_PLAYING_TIME_LIMIT: cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY: cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_PROMO_IMAGE: cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_PROMO_IMAGE_REPLY: cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_SELFEXCLUDED_STR: cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY: cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_SIMILAR_SATELLITES: cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY: cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_TLB: cli::Protocol_MSG_LOBBY_GET_TLB::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_TLB_REPLY: cli::Protocol_MSG_LOBBY_GET_TLB_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_USER_CAPS: cli::Protocol_MSG_LOBBY_GET_USER_CAPS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_USER_CAPS_REPLY: cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_USER_INFO: cli::Protocol_MSG_LOBBY_GET_USER_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_USER_INFO_REPLY: cli::Protocol_MSG_LOBBY_GET_USER_INFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_HIDE_MOBILE_ICON: cli::Protocol_MSG_LOBBY_HIDE_MOBILE_ICON::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_HISTORY_REQUEST: cli::Protocol_MSG_LOBBY_HISTORY_REQUEST::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_HISTORY_REQUEST_REPLY: cli::Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_INIT_NETVERIFY_SESSION: cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY: cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_INTELLIPOKER_PWD: cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_INTELLIPOKER_PWD_REPLY: cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_INTELLIPOKER_SIGNUP: cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY: cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_IP_CHECK: cli::Protocol_MSG_LOBBY_IP_CHECK::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_IT_DOCUMENT: cli::Protocol_MSG_LOBBY_IT_DOCUMENT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_IT_DOCUMENT_REPLY: cli::Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_JOIN_SEATFINDER: cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_JOIN_SEATFINDER_REPLY: cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_LEAVE_ALL_WAITING_LISTS: cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY: cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_LEAVE_WAITING_LIST: cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_LEAVE_WAITING_LIST_REPLY: cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_LIST_REMOVE: cli::Protocol_MSG_LOBBY_LIST_REMOVE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_LOGOUT: cli::Protocol_MSG_LOBBY_LOGOUT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_LOGOUT_CONFIRM: cli::Protocol_MSG_LOBBY_LOGOUT_CONFIRM::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_MIGRATION_CONVERT: cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_MIGRATION_CONVERT_REPLY: cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_MIGRATION_GET_INFO: cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_MIGRATION_GET_INFO_REPLY: cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_MIGRATION_LINK: cli::Protocol_MSG_LOBBY_MIGRATION_LINK::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_MIGRATION_LINK_REPLY: cli::Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_MIGRATION_TRANSFER: cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_MIGRATION_TRANSFER_REPLY: cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_PLAYING_HISTORY_AUDIT: cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY: cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_PUBLISH_VIP_STATUS: cli::Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_REGISTER_TOURN_USER: cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_REGISTER_TOURN_USER_REPLY: cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_REPORT_FIRST_LOGIN: cli::Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_RESEND_ACTIVATION_EMAIL: cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY: cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_RESEND_MOBILE_VALIDATION: cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY: cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE: cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY: cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT: cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY: cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SEATFINDER_CHECK_CHIPS: cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY: cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_BUYIN_LIMIT: cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_BUYIN_LIMIT_EX: cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY: cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_BUYIN_LIMIT_REPLY: cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_CLIENT_OPTIONS: cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY: cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_PLAYING_TIME_LIMIT: cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY: cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_PROMO_IMAGE: cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_PROMO_IMAGE_REPLY: cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_TABLE_LIMITS2: cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_TABLE_LIMITS2_REPLY: cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_TOURN_EMAIL_FLAGS: cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY: cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_TOURN_LIMITS: cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_TOURN_LIMITS_REPLY: cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP: cli::Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SOCIAL_SHARE_HAND: cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY: cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SUBMIT_STARCODE: cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SUBMIT_STARCODE_REPLY: cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_TARGET_NEWS_DESKTOP: cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_TARGET_NEWS_MOBILE: cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_TICKET_TOURNTIDS: cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_TICKET_TOURNTIDS_REPLY: cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_TIMEZONE_SET: cli::Protocol_MSG_LOBBY_TIMEZONE_SET::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_TIMEZONE_SET_REPLY: cli::Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_TOURN_STATS: cli::Protocol_MSG_LOBBY_TOURN_STATS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_TOURN_STATS_REPLY: cli::Protocol_MSG_LOBBY_TOURN_STATS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_UNJOIN_SEATFINDER: cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_UNJOIN_SEATFINDER_REPLY: cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_UPDATE_DOB: cli::Protocol_MSG_LOBBY_UPDATE_DOB::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_UPDATE_DOB_REPLY: cli::Protocol_MSG_LOBBY_UPDATE_DOB_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_USER_PROPS: cli::Protocol_MSG_LOBBY_USER_PROPS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_USER_PROPS_REPLY: cli::Protocol_MSG_LOBBY_USER_PROPS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_USER_STATS: cli::Protocol_MSG_LOBBY_USER_STATS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_USER_STATS_REPLY: cli::Protocol_MSG_LOBBY_USER_STATS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_USER_TOURNTICKETS2: cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_USER_TOURNTICKETS2_REPLY: cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_VALIDATE_MOBILE: cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_VALIDATE_MOBILE_REPLY: cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_VALIDATE_NEWINSTALL: cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY: cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_WAITING_LIST: cli::Protocol_MSG_LOBBY_WAITING_LIST::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_WAITING_LIST_REPLY: cli::Protocol_MSG_LOBBY_WAITING_LIST_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_WAIT_ON_TABLES: cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_WAIT_ON_TABLES_REPLY: cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_WAITING_INVITED_REPLY: cli::Protocol_MSG_WAITING_INVITED_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_WEB_FIND_PLAYER2: cli::Protocol_MSG_WEB_FIND_PLAYER2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_WEB_FIND_PLAYER2_REPLY: cli::Protocol_MSG_WEB_FIND_PLAYER2_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_WEB_FIND_PLAYER3: cli::Protocol_MSG_WEB_FIND_PLAYER3::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_WEB_FIND_PLAYER3_REPLY: cli::Protocol_MSG_WEB_FIND_PLAYER3_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_WEB_FIND_TOURN: cli::Protocol_MSG_WEB_FIND_TOURN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_WEB_FIND_TOURN_REPLY: cli::Protocol_MSG_WEB_FIND_TOURN_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "lobby_unauth"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_CHALLENGE_QUESTION: lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CHALLENGE_QUESTION_REPLY: lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CHECK_PUBLICATIONS: lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CHECK_PUBLICATIONS_REPLY: lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLIENT_ERROR: lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLIENT_ERROR_REPLY: lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TABLE_TO_OBSERVE: lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY: lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_CAPTCHA: lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_CAPTCHA_REPLY: lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_SATELLITES_TO_TOURN: lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX: lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY: lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY: lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_TABLE_BY_ID: lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_TABLE_BY_ID_REPLY: lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_PROMO_COUNTRY: lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_PROMO_COUNTRY_REPLY: lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_REPORT_INSTALL: lobby_unauth::Protocol_MSG_LOBBY_REPORT_INSTALL::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_UPDATE_BY_LICENSE: lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_UPDATE_BY_LICENSE_REPLY: lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

/* static */ bool Lobby::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "Personalization"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS: Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY: Personalization::Protocol_MSG_LOBBY_PS_GET_TABLES_INFO_BY_TABLE_IDS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_PS_USER_AT: Personalization::Protocol_MSG_LOBBY_PS_USER_AT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_PS_USER_AT_REPLY: Personalization::Protocol_MSG_LOBBY_PS_USER_AT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_CLI_LOBBY_CONFIRM_POPUP: cli::Protocol_MSG_CLI_LOBBY_CONFIRM_POPUP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CLI_LOBBY_FIND_QUICKSTART_SNG: cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2: cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY: cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3: cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY: cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG3_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY: cli::Protocol_MSG_CLI_LOBBY_FIND_QUICKSTART_SNG_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_ACTIVATE_ACCOUNT: cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY: cli::Protocol_MSG_LOBBY_ACTIVATE_ACCOUNT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_ADMIN_INFO: cli::Protocol_MSG_LOBBY_ADMIN_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_ADMIN_INFO_REPLY: cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_BE_AVC_RESEND: cli::Protocol_MSG_LOBBY_BE_AVC_RESEND::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_BE_AVC_RESEND_REPLY: cli::Protocol_MSG_LOBBY_BE_AVC_RESEND_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_BE_AVC_VALIDATE: cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_BE_AVC_VALIDATE_REPLY: cli::Protocol_MSG_LOBBY_BE_AVC_VALIDATE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CANCEL_RESERVED_SEAT: cli::Protocol_MSG_LOBBY_CANCEL_RESERVED_SEAT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CANCEL_USERTOURN: cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CANCEL_USERTOURN_REPLY: cli::Protocol_MSG_LOBBY_CANCEL_USERTOURN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CHALLENGE_QUESTION: cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CHALLENGE_QUESTION_REPLY: cli::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CHAT_COMPL: cli::Protocol_MSG_LOBBY_CHAT_COMPL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLIENT_CURR_CONV_OPT: cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY: cli::Protocol_MSG_LOBBY_CLIENT_CURR_CONV_OPT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLIENT_QUEST: cli::Protocol_MSG_LOBBY_CLIENT_QUEST::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLI_BOUNCED: cli::Protocol_MSG_LOBBY_CLI_BOUNCED::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLI_BOUNCED_REPLY: cli::Protocol_MSG_LOBBY_CLI_BOUNCED_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLI_GET_TLB_STANDIDNS2: cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY: cli::Protocol_MSG_LOBBY_CLI_GET_TLB_STANDIDNS2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLI_REMATCH_ACCEPT: cli::Protocol_MSG_LOBBY_CLI_REMATCH_ACCEPT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLI_REMATCH_DECLINE: cli::Protocol_MSG_LOBBY_CLI_REMATCH_DECLINE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLI_TEAM_PS_ONLINE: cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY: cli::Protocol_MSG_LOBBY_CLI_TEAM_PS_ONLINE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CREATE_TOURNAMENT_REPLY: cli::Protocol_MSG_LOBBY_CREATE_TOURNAMENT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CREATE_USERTOURN: cli::Protocol_MSG_LOBBY_CREATE_USERTOURN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_DISABLE_SNG_AUTO_UNREG: cli::Protocol_MSG_LOBBY_DISABLE_SNG_AUTO_UNREG::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_DONT_SHOW_PERSONAL_INFO: cli::Protocol_MSG_LOBBY_DONT_SHOW_PERSONAL_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_DONT_SHOW_WHERE: cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_DONT_SHOW_WHERE_REPLY: cli::Protocol_MSG_LOBBY_DONT_SHOW_WHERE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_EXCLUDE_PLAYER: cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_EXCLUDE_PLAYER_REPLY: cli::Protocol_MSG_LOBBY_EXCLUDE_PLAYER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_PLAYER2: cli::Protocol_MSG_LOBBY_FIND_PLAYER2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_PLAYER2_REPLY: cli::Protocol_MSG_LOBBY_FIND_PLAYER2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_PLAYER3: cli::Protocol_MSG_LOBBY_FIND_PLAYER3::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_PLAYER3_REPLY: cli::Protocol_MSG_LOBBY_FIND_PLAYER3_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF: cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY: cli::Protocol_MSG_LOBBY_FIND_REGISTERING_TOURN_BYREF_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_SEAT_MANAGER_TABLE: cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2: cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY: cli::Protocol_MSG_LOBBY_FIND_SEAT_MANAGER_TABLE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_SIMILAR_TABLE: cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE: cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_BY_TYPE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY: cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_SIMILAR_TABLE_STOP: cli::Protocol_MSG_LOBBY_FIND_SIMILAR_TABLE_STOP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TABLE_TO_OBSERVE: cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY: cli::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TOURN: cli::Protocol_MSG_LOBBY_FIND_TOURN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TOURN_IT: cli::Protocol_MSG_LOBBY_FIND_TOURN_IT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TOURN_IT_REPLY: cli::Protocol_MSG_LOBBY_FIND_TOURN_IT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TOURN_REG: cli::Protocol_MSG_LOBBY_FIND_TOURN_REG::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TOURN_REG2: cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TOURN_REG2_REPLY: cli::Protocol_MSG_LOBBY_FIND_TOURN_REG2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TOURN_REG_IT: cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TOURN_REG_IT_REPLY: cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_IT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TOURN_REG_REPLY: cli::Protocol_MSG_LOBBY_FIND_TOURN_REG_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TOURN_REPLY: cli::Protocol_MSG_LOBBY_FIND_TOURN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_WAIT: cli::Protocol_MSG_LOBBY_FIND_WAIT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_WAIT_REPLY: cli::Protocol_MSG_LOBBY_FIND_WAIT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FR_AVC_RESEND: cli::Protocol_MSG_LOBBY_FR_AVC_RESEND::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FR_AVC_RESEND_REPLY: cli::Protocol_MSG_LOBBY_FR_AVC_RESEND_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FR_AVC_VALIDATE: cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FR_AVC_VALIDATE_REPLY: cli::Protocol_MSG_LOBBY_FR_AVC_VALIDATE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_BUYIN_LIMIT: cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_BUYIN_LIMIT_EX: cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY: cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_EX_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_BUYIN_LIMIT_REPLY: cli::Protocol_MSG_LOBBY_GET_BUYIN_LIMIT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_CLIENT_OPTIONS: cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY: cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_CONSENTS: cli::Protocol_MSG_LOBBY_GET_CONSENTS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_CONSENTS_REPLY: cli::Protocol_MSG_LOBBY_GET_CONSENTS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT: cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY: cli::Protocol_MSG_LOBBY_GET_ES_LAST_LOGIN_REPORT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_JOINED_SEATFINDERS: cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY: cli::Protocol_MSG_LOBBY_GET_JOINED_SEATFINDERS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_PLAYING_TIME_LIMIT: cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY: cli::Protocol_MSG_LOBBY_GET_PLAYING_TIME_LIMIT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_PROMO_IMAGE: cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_PROMO_IMAGE_REPLY: cli::Protocol_MSG_LOBBY_GET_PROMO_IMAGE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_SELFEXCLUDED_STR: cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY: cli::Protocol_MSG_LOBBY_GET_SELFEXCLUDED_STR_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_SIMILAR_SATELLITES: cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY: cli::Protocol_MSG_LOBBY_GET_SIMILAR_SATELLITES_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_TLB: cli::Protocol_MSG_LOBBY_GET_TLB::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_TLB_REPLY: cli::Protocol_MSG_LOBBY_GET_TLB_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_USER_CAPS: cli::Protocol_MSG_LOBBY_GET_USER_CAPS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_USER_CAPS_REPLY: cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_USER_INFO: cli::Protocol_MSG_LOBBY_GET_USER_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_USER_INFO_REPLY: cli::Protocol_MSG_LOBBY_GET_USER_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_HIDE_MOBILE_ICON: cli::Protocol_MSG_LOBBY_HIDE_MOBILE_ICON::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_HISTORY_REQUEST: cli::Protocol_MSG_LOBBY_HISTORY_REQUEST::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_HISTORY_REQUEST_REPLY: cli::Protocol_MSG_LOBBY_HISTORY_REQUEST_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_INIT_NETVERIFY_SESSION: cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY: cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_INTELLIPOKER_PWD: cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_INTELLIPOKER_PWD_REPLY: cli::Protocol_MSG_LOBBY_INTELLIPOKER_PWD_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_INTELLIPOKER_SIGNUP: cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY: cli::Protocol_MSG_LOBBY_INTELLIPOKER_SIGNUP_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_IP_CHECK: cli::Protocol_MSG_LOBBY_IP_CHECK::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_IT_DOCUMENT: cli::Protocol_MSG_LOBBY_IT_DOCUMENT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_IT_DOCUMENT_REPLY: cli::Protocol_MSG_LOBBY_IT_DOCUMENT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_JOIN_SEATFINDER: cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_JOIN_SEATFINDER_REPLY: cli::Protocol_MSG_LOBBY_JOIN_SEATFINDER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_LEAVE_ALL_WAITING_LISTS: cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY: cli::Protocol_MSG_LOBBY_LEAVE_ALL_WAITING_LISTS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_LEAVE_WAITING_LIST: cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_LEAVE_WAITING_LIST_REPLY: cli::Protocol_MSG_LOBBY_LEAVE_WAITING_LIST_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_LIST_REMOVE: cli::Protocol_MSG_LOBBY_LIST_REMOVE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_LOGOUT: cli::Protocol_MSG_LOBBY_LOGOUT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_LOGOUT_CONFIRM: cli::Protocol_MSG_LOBBY_LOGOUT_CONFIRM::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_MIGRATION_CONVERT: cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_MIGRATION_CONVERT_REPLY: cli::Protocol_MSG_LOBBY_MIGRATION_CONVERT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_MIGRATION_GET_INFO: cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_MIGRATION_GET_INFO_REPLY: cli::Protocol_MSG_LOBBY_MIGRATION_GET_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_MIGRATION_LINK: cli::Protocol_MSG_LOBBY_MIGRATION_LINK::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_MIGRATION_LINK_REPLY: cli::Protocol_MSG_LOBBY_MIGRATION_LINK_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_MIGRATION_TRANSFER: cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_MIGRATION_TRANSFER_REPLY: cli::Protocol_MSG_LOBBY_MIGRATION_TRANSFER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_PLAYING_HISTORY_AUDIT: cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY: cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_PUBLISH_VIP_STATUS: cli::Protocol_MSG_LOBBY_PUBLISH_VIP_STATUS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_REGISTER_TOURN_USER: cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_REGISTER_TOURN_USER_REPLY: cli::Protocol_MSG_LOBBY_REGISTER_TOURN_USER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_REPORT_FIRST_LOGIN: cli::Protocol_MSG_LOBBY_REPORT_FIRST_LOGIN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_RESEND_ACTIVATION_EMAIL: cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY: cli::Protocol_MSG_LOBBY_RESEND_ACTIVATION_EMAIL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_RESEND_MOBILE_VALIDATION: cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY: cli::Protocol_MSG_LOBBY_RESEND_MOBILE_VALIDATION_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE: cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY: cli::Protocol_MSG_LOBBY_RESEND_NEWINSTALL_VALIDATIONCODE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT: cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY: cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SEATFINDER_CHECK_CHIPS: cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY: cli::Protocol_MSG_LOBBY_SEATFINDER_CHECK_CHIPS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_BUYIN_LIMIT: cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_BUYIN_LIMIT_EX: cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY: cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_EX_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_BUYIN_LIMIT_REPLY: cli::Protocol_MSG_LOBBY_SET_BUYIN_LIMIT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_CLIENT_OPTIONS: cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY: cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_PLAYING_TIME_LIMIT: cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY: cli::Protocol_MSG_LOBBY_SET_PLAYING_TIME_LIMIT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_PROMO_IMAGE: cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_PROMO_IMAGE_REPLY: cli::Protocol_MSG_LOBBY_SET_PROMO_IMAGE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_TABLE_LIMITS2: cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_TABLE_LIMITS2_REPLY: cli::Protocol_MSG_LOBBY_SET_TABLE_LIMITS2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_TOURN_EMAIL_FLAGS: cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY: cli::Protocol_MSG_LOBBY_SET_TOURN_EMAIL_FLAGS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_TOURN_LIMITS: cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_TOURN_LIMITS_REPLY: cli::Protocol_MSG_LOBBY_SET_TOURN_LIMITS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP: cli::Protocol_MSG_LOBBY_SHOW_NO_CHAT_TOOLTIP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SOCIAL_SHARE_HAND: cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY: cli::Protocol_MSG_LOBBY_SOCIAL_SHARE_HAND_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SUBMIT_STARCODE: cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SUBMIT_STARCODE_REPLY: cli::Protocol_MSG_LOBBY_SUBMIT_STARCODE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_TARGET_NEWS_DESKTOP: cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_TARGET_NEWS_MOBILE: cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_TICKET_TOURNTIDS: cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_TICKET_TOURNTIDS_REPLY: cli::Protocol_MSG_LOBBY_TICKET_TOURNTIDS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_TIMEZONE_SET: cli::Protocol_MSG_LOBBY_TIMEZONE_SET::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_TIMEZONE_SET_REPLY: cli::Protocol_MSG_LOBBY_TIMEZONE_SET_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_TOURN_STATS: cli::Protocol_MSG_LOBBY_TOURN_STATS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_TOURN_STATS_REPLY: cli::Protocol_MSG_LOBBY_TOURN_STATS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_UNJOIN_SEATFINDER: cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_UNJOIN_SEATFINDER_REPLY: cli::Protocol_MSG_LOBBY_UNJOIN_SEATFINDER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_UPDATE_DOB: cli::Protocol_MSG_LOBBY_UPDATE_DOB::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_UPDATE_DOB_REPLY: cli::Protocol_MSG_LOBBY_UPDATE_DOB_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_USER_PROPS: cli::Protocol_MSG_LOBBY_USER_PROPS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_USER_PROPS_REPLY: cli::Protocol_MSG_LOBBY_USER_PROPS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_USER_STATS: cli::Protocol_MSG_LOBBY_USER_STATS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_USER_STATS_REPLY: cli::Protocol_MSG_LOBBY_USER_STATS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_USER_TOURNTICKETS2: cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_USER_TOURNTICKETS2_REPLY: cli::Protocol_MSG_LOBBY_USER_TOURNTICKETS2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_VALIDATE_MOBILE: cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_VALIDATE_MOBILE_REPLY: cli::Protocol_MSG_LOBBY_VALIDATE_MOBILE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_VALIDATE_NEWINSTALL: cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY: cli::Protocol_MSG_LOBBY_VALIDATE_NEWINSTALL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_WAITING_LIST: cli::Protocol_MSG_LOBBY_WAITING_LIST::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_WAITING_LIST_REPLY: cli::Protocol_MSG_LOBBY_WAITING_LIST_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_WAIT_ON_TABLES: cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_WAIT_ON_TABLES_REPLY: cli::Protocol_MSG_LOBBY_WAIT_ON_TABLES_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_WAITING_INVITED_REPLY: cli::Protocol_MSG_WAITING_INVITED_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_WEB_FIND_PLAYER2: cli::Protocol_MSG_WEB_FIND_PLAYER2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_WEB_FIND_PLAYER2_REPLY: cli::Protocol_MSG_WEB_FIND_PLAYER2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_WEB_FIND_PLAYER3: cli::Protocol_MSG_WEB_FIND_PLAYER3::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_WEB_FIND_PLAYER3_REPLY: cli::Protocol_MSG_WEB_FIND_PLAYER3_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_WEB_FIND_TOURN: cli::Protocol_MSG_WEB_FIND_TOURN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_WEB_FIND_TOURN_REPLY: cli::Protocol_MSG_WEB_FIND_TOURN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "lobby_unauth"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_CHALLENGE_QUESTION: lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CHALLENGE_QUESTION_REPLY: lobby_unauth::Protocol_MSG_LOBBY_CHALLENGE_QUESTION_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CHECK_PUBLICATIONS: lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CHECK_PUBLICATIONS_REPLY: lobby_unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLIENT_ERROR: lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CLIENT_ERROR_REPLY: lobby_unauth::Protocol_MSG_LOBBY_CLIENT_ERROR_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TABLE_TO_OBSERVE: lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY: lobby_unauth::Protocol_MSG_LOBBY_FIND_TABLE_TO_OBSERVE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_CAPTCHA: lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_CAPTCHA_REPLY: lobby_unauth::Protocol_MSG_LOBBY_GET_CAPTCHA_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_SATELLITES_TO_TOURN: lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX: lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY: lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_EX_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY: lobby_unauth::Protocol_MSG_LOBBY_GET_SATELLITES_TO_TOURN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_TABLE_BY_ID: lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_TABLE_BY_ID_REPLY: lobby_unauth::Protocol_MSG_LOBBY_GET_TABLE_BY_ID_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_PROMO_COUNTRY: lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_PROMO_COUNTRY_REPLY: lobby_unauth::Protocol_MSG_LOBBY_PROMO_COUNTRY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_REPORT_INSTALL: lobby_unauth::Protocol_MSG_LOBBY_REPORT_INSTALL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_UPDATE_BY_LICENSE: lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_UPDATE_BY_LICENSE_REPLY: lobby_unauth::Protocol_MSG_LOBBY_UPDATE_BY_LICENSE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

