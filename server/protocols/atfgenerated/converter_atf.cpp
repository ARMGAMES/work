/**
 * converter_atf.cpp
 *
 * This file was auto-generated from converter_atf.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: converter_atf.txt
 */
 
#include "converter_atf.h"

//=================================================================
//                    CountryCurrency
//=================================================================

// @Override
converter::CountryCurrency::CountryCurrency(PString code, PString isoCode)
{
	countryCode = code;
	localCurrencyIsoCode = isoCode;
}

converter::CountryCurrency::CountryCurrency()
{
	clear();
}

void converter::CountryCurrency::clear()
{
	countryCode.clear();
	localCurrencyIsoCode.clear();
}

bool converter::CountryCurrency::equals(const CountryCurrency& _o) const
{
	return Atf::atfPStringEquals(countryCode, _o.countryCode) &&
		Atf::atfPStringEquals(localCurrencyIsoCode, _o.localCurrencyIsoCode);
}

const char *converter::CountryCurrency::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("countryCode=");
	_buf.append(countryCode);
	_buf.append(',');
	_buf.append("localCurrencyIsoCode=");
	_buf.append(localCurrencyIsoCode);
	_buf.append('}');
	return _buf.c_str();
}

const char *converter::CountryCurrency::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("countryCode", countryCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("localCurrencyIsoCode", localCurrencyIsoCode, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool converter::CountryCurrency::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("countryCode"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, countryCode)) return false;
		}
		else if (_element.equals("localCurrencyIsoCode"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, localCurrencyIsoCode)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void converter::CountryCurrency::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CountryCurrency())) // not empty
	{
		_body.composeString(countryCode);
		_body.composeString(localCurrencyIsoCode);
	}

	_msg.composeMsgBody(_body);
}

void converter::CountryCurrency::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(countryCode);
	_parser0.parseStringP(localCurrencyIsoCode);
}

const char *converter::CountryCurrency::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("countryCode", countryCode);
	_jsonstr.compose("localCurrencyIsoCode", localCurrencyIsoCode);
	return _buf.c_str();
}

void converter::CountryCurrency::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("countryCode", countryCode);
	_jparser.parseByNameThrow("localCurrencyIsoCode", localCurrencyIsoCode);
}

/* static */ void converter::CountryCurrency::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString countryCode; _jparser.validateByNameThrow("countryCode", countryCode);
	AtfValidator::validateIntRange(_descr, "countryCode", countryCode.length(), 2, 2, _checker, __FILE__, __LINE__);
	PString localCurrencyIsoCode; _jparser.validateByNameThrow("localCurrencyIsoCode", localCurrencyIsoCode);
	AtfValidator::validateIntRange(_descr, "localCurrencyIsoCode", localCurrencyIsoCode.length(), 3, 3, _checker, __FILE__, __LINE__);
}

/*static*/ void converter::CountryCurrency::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "countryCode"); size_t szCountryCode = strlen(_dummy);
	AtfValidator::validateIntRange(_descr, "countryCode", szCountryCode, 2, 2, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "localCurrencyIsoCode"); size_t szLocalCurrencyIsoCode = strlen(_dummy);
	AtfValidator::validateIntRange(_descr, "localCurrencyIsoCode", szLocalCurrencyIsoCode, 3, 3, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CurrencyConvertRate
//=================================================================

converter::CurrencyConvertRate::CurrencyConvertRate()
{
	clear();
}

void converter::CurrencyConvertRate::clear()
{
	currency.clear();
	rate = 0;
}

bool converter::CurrencyConvertRate::equals(const CurrencyConvertRate& _o) const
{
	return Atf::atfPStringEquals(currency, _o.currency) &&
		rate == _o.rate;
}

const char *converter::CurrencyConvertRate::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("rate=");
	_buf.appendInt(rate);
	_buf.append('}');
	return _buf.c_str();
}

const char *converter::CurrencyConvertRate::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("rate", rate, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool converter::CurrencyConvertRate::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("rate"))
		{
			rate = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void converter::CurrencyConvertRate::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CurrencyConvertRate())) // not empty
	{
		_body.composeString(currency);
		_body.composeINT32(rate);
	}

	_msg.composeMsgBody(_body);
}

void converter::CurrencyConvertRate::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(currency);
	_parser0.parseINT32(rate);
}

const char *converter::CurrencyConvertRate::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("rate", rate);
	return _buf.c_str();
}

void converter::CurrencyConvertRate::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("rate", rate);
}

/* static */ void converter::CurrencyConvertRate::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	INT32 rate; _jparser.validateByNameThrow("rate", rate);
	AtfValidator::validateInt(_descr, "rate", rate, _checker, __FILE__, __LINE__);
}

/*static*/ void converter::CurrencyConvertRate::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT32 rate; _parser0.parseINT32(rate);
	AtfValidator::validateInt(_descr, "rate", rate, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CONVERTER_GET_ALL_RATES
//=================================================================

converter::Protocol_MSG_CONVERTER_GET_ALL_RATES::Protocol_MSG_CONVERTER_GET_ALL_RATES()
{
	clear();
}

void converter::Protocol_MSG_CONVERTER_GET_ALL_RATES::clear()
{
	time.setNull();
}

bool converter::Protocol_MSG_CONVERTER_GET_ALL_RATES::equals(const Protocol_MSG_CONVERTER_GET_ALL_RATES& _o) const
{
	return time.equals(_o.time);
}

bool converter::Protocol_MSG_CONVERTER_GET_ALL_RATES::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CONVERTER_GET_ALL_RATES != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CONVERTER_GET_ALL_RATES*)_other));
}

const char *converter::Protocol_MSG_CONVERTER_GET_ALL_RATES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CONVERTER_GET_ALL_RATES).append(")");
	_buf.append(',');
	_buf.append("time=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, time);
	return _buf.c_str();
}

const char *converter::Protocol_MSG_CONVERTER_GET_ALL_RATES::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *converter::Protocol_MSG_CONVERTER_GET_ALL_RATES::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CONVERTER_GET_ALL_RATES).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "time", time);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool converter::Protocol_MSG_CONVERTER_GET_ALL_RATES::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("time"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, time);
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void converter::Protocol_MSG_CONVERTER_GET_ALL_RATES::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeSrvTime(time);
}

void converter::Protocol_MSG_CONVERTER_GET_ALL_RATES::parseMsg(CommMsgParser& _parser)
{
	_parser.parseSrvTime(time);
}

const char *converter::Protocol_MSG_CONVERTER_GET_ALL_RATES::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("time", time);
	return _buf.c_str();
}

void converter::Protocol_MSG_CONVERTER_GET_ALL_RATES::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("time", time);
}

/*static*/ void converter::Protocol_MSG_CONVERTER_GET_ALL_RATES::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CONVERTER_GET_ALL_RATES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	SrvTime time; _jparser.validateByNameThrow("time", time);
	AtfValidator::validateSrvDateTime(_descr, "time", time, _checker, __FILE__, __LINE__);
}

/*static*/ void converter::Protocol_MSG_CONVERTER_GET_ALL_RATES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CONVERTER_GET_ALL_RATES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	SrvTime time; _parser.parseSrvTime(time);
	AtfValidator::validateSrvDateTime(_descr, "time", time, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CONVERTER_GET_ALL_RATES_REPLY
//=================================================================

converter::Protocol_MSG_CONVERTER_GET_ALL_RATES_REPLY::Protocol_MSG_CONVERTER_GET_ALL_RATES_REPLY()
{
	clear();
}

void converter::Protocol_MSG_CONVERTER_GET_ALL_RATES_REPLY::clear()
{
	errCode = 0;
	errorDescription.clear();
	rates.clear();
}

bool converter::Protocol_MSG_CONVERTER_GET_ALL_RATES_REPLY::equals(const Protocol_MSG_CONVERTER_GET_ALL_RATES_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errorDescription, _o.errorDescription) &&
		rates.equals(_o.rates);
}

bool converter::Protocol_MSG_CONVERTER_GET_ALL_RATES_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CONVERTER_GET_ALL_RATES_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CONVERTER_GET_ALL_RATES_REPLY*)_other));
}

const char *converter::Protocol_MSG_CONVERTER_GET_ALL_RATES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CONVERTER_GET_ALL_RATES_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errorDescription=");
		_buf.append(errorDescription);
	}
	else
	{
		_buf.append(',');
		_buf.append("rates=");
		rates.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *converter::Protocol_MSG_CONVERTER_GET_ALL_RATES_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *converter::Protocol_MSG_CONVERTER_GET_ALL_RATES_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CONVERTER_GET_ALL_RATES_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errorDescription", errorDescription, _buf);
	}
	else
	{
		rates.toXmlString("rates", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool converter::Protocol_MSG_CONVERTER_GET_ALL_RATES_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errorDescription"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errorDescription)) return false;
			}
			else if (_element.equals("rates"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< CurrencyConvertRate, 4 > >::FromXmlString(_value, rates)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void converter::Protocol_MSG_CONVERTER_GET_ALL_RATES_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errorDescription);
	}
	else
	{
		rates.composeMsg(_msg, _ignoreJSON);
	}
}

void converter::Protocol_MSG_CONVERTER_GET_ALL_RATES_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errorDescription);
	}
	else
	{
		rates.parseMsg(_parser);
	}
}

const char *converter::Protocol_MSG_CONVERTER_GET_ALL_RATES_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errorDescription", errorDescription);
	}
	else
	{
		_jsonstr.compose("rates", rates);
	}
	return _buf.c_str();
}

void converter::Protocol_MSG_CONVERTER_GET_ALL_RATES_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errorDescription", errorDescription);
	}
	else
	{
		_jparser.parseByNameThrow("rates", rates);
	}
}

/*static*/ void converter::Protocol_MSG_CONVERTER_GET_ALL_RATES_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CONVERTER_GET_ALL_RATES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errorDescription; _jparser.validateByNameThrow("errorDescription", errorDescription);
		AtfValidator::validateInt(_descr, "errorDescription", errorDescription.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< CurrencyConvertRate > rates; _jparser.validateByNameThrow("rates", rates);
		AtfValidator::validateInt(_descr, "rates", rates.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void converter::Protocol_MSG_CONVERTER_GET_ALL_RATES_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CONVERTER_GET_ALL_RATES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errorDescription"); size_t szErrorDescription = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errorDescription", szErrorDescription, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szRates = Atf::LAtfVector< CurrencyConvertRate, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("rates"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "rates", szRates, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CONVERTER_GET_RATE
//=================================================================

converter::Protocol_MSG_CONVERTER_GET_RATE::Protocol_MSG_CONVERTER_GET_RATE()
{
	clear();
}

void converter::Protocol_MSG_CONVERTER_GET_RATE::clear()
{
	time.setNull();
	currency.clear();
}

bool converter::Protocol_MSG_CONVERTER_GET_RATE::equals(const Protocol_MSG_CONVERTER_GET_RATE& _o) const
{
	return time.equals(_o.time) &&
		Atf::atfPStringEquals(currency, _o.currency);
}

bool converter::Protocol_MSG_CONVERTER_GET_RATE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CONVERTER_GET_RATE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CONVERTER_GET_RATE*)_other));
}

const char *converter::Protocol_MSG_CONVERTER_GET_RATE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CONVERTER_GET_RATE).append(")");
	_buf.append(',');
	_buf.append("time=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, time);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	return _buf.c_str();
}

const char *converter::Protocol_MSG_CONVERTER_GET_RATE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *converter::Protocol_MSG_CONVERTER_GET_RATE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CONVERTER_GET_RATE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "time", time);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool converter::Protocol_MSG_CONVERTER_GET_RATE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("time"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, time);
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void converter::Protocol_MSG_CONVERTER_GET_RATE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeSrvTime(time);
	_msg.composeString(currency);
}

void converter::Protocol_MSG_CONVERTER_GET_RATE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseSrvTime(time);
	_parser.parseStringP(currency);
}

const char *converter::Protocol_MSG_CONVERTER_GET_RATE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("time", time);
	_jsonstr.compose("currency", currency);
	return _buf.c_str();
}

void converter::Protocol_MSG_CONVERTER_GET_RATE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("time", time);
	_jparser.parseByNameThrow("currency", currency);
}

/*static*/ void converter::Protocol_MSG_CONVERTER_GET_RATE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CONVERTER_GET_RATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	SrvTime time; _jparser.validateByNameThrow("time", time);
	AtfValidator::validateSrvDateTime(_descr, "time", time, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void converter::Protocol_MSG_CONVERTER_GET_RATE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CONVERTER_GET_RATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	SrvTime time; _parser.parseSrvTime(time);
	AtfValidator::validateSrvDateTime(_descr, "time", time, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CONVERTER_GET_RATE_REPLY
//=================================================================

converter::Protocol_MSG_CONVERTER_GET_RATE_REPLY::Protocol_MSG_CONVERTER_GET_RATE_REPLY()
{
	clear();
}

void converter::Protocol_MSG_CONVERTER_GET_RATE_REPLY::clear()
{
	errCode = 0;
	errorDescription.clear();
	rate = 0;
}

bool converter::Protocol_MSG_CONVERTER_GET_RATE_REPLY::equals(const Protocol_MSG_CONVERTER_GET_RATE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errorDescription, _o.errorDescription) &&
		rate == _o.rate;
}

bool converter::Protocol_MSG_CONVERTER_GET_RATE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CONVERTER_GET_RATE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CONVERTER_GET_RATE_REPLY*)_other));
}

const char *converter::Protocol_MSG_CONVERTER_GET_RATE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CONVERTER_GET_RATE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errorDescription=");
		_buf.append(errorDescription);
	}
	else
	{
		_buf.append(',');
		_buf.append("rate=");
		_buf.appendInt(rate);
	}
	return _buf.c_str();
}

const char *converter::Protocol_MSG_CONVERTER_GET_RATE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *converter::Protocol_MSG_CONVERTER_GET_RATE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CONVERTER_GET_RATE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errorDescription", errorDescription, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("rate", rate, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool converter::Protocol_MSG_CONVERTER_GET_RATE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errorDescription"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errorDescription)) return false;
			}
			else if (_element.equals("rate"))
			{
				rate = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void converter::Protocol_MSG_CONVERTER_GET_RATE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errorDescription);
	}
	else
	{
		_msg.composeINT32(rate);
	}
}

void converter::Protocol_MSG_CONVERTER_GET_RATE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errorDescription);
	}
	else
	{
		_parser.parseINT32(rate);
	}
}

const char *converter::Protocol_MSG_CONVERTER_GET_RATE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errorDescription", errorDescription);
	}
	else
	{
		_jsonstr.compose("rate", rate);
	}
	return _buf.c_str();
}

void converter::Protocol_MSG_CONVERTER_GET_RATE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errorDescription", errorDescription);
	}
	else
	{
		_jparser.parseByNameThrow("rate", rate);
	}
}

/*static*/ void converter::Protocol_MSG_CONVERTER_GET_RATE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CONVERTER_GET_RATE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errorDescription; _jparser.validateByNameThrow("errorDescription", errorDescription);
		AtfValidator::validateInt(_descr, "errorDescription", errorDescription.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 rate; _jparser.validateByNameThrow("rate", rate);
		AtfValidator::validateInt(_descr, "rate", rate, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void converter::Protocol_MSG_CONVERTER_GET_RATE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CONVERTER_GET_RATE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errorDescription"); size_t szErrorDescription = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errorDescription", szErrorDescription, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 rate; _parser.parseINT32(rate);
		AtfValidator::validateInt(_descr, "rate", rate, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CONVERTER_CONVERT_AMOUNT
//=================================================================

converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT::Protocol_MSG_CONVERTER_CONVERT_AMOUNT()
{
	clear();
}

void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT::clear()
{
	time.setNull();
	srcCurrencyAmount = 0;
	srcCurrencyType.clear();
	destCurrencyType.clear();
	applyRounding = false;
	roundUp = false;
}

bool converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT::equals(const Protocol_MSG_CONVERTER_CONVERT_AMOUNT& _o) const
{
	return time.equals(_o.time) &&
		srcCurrencyAmount == _o.srcCurrencyAmount &&
		Atf::atfPStringEquals(srcCurrencyType, _o.srcCurrencyType) &&
		Atf::atfPStringEquals(destCurrencyType, _o.destCurrencyType) &&
		applyRounding == _o.applyRounding &&
		roundUp == _o.roundUp;
}

bool converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CONVERTER_CONVERT_AMOUNT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CONVERTER_CONVERT_AMOUNT*)_other));
}

const char *converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CONVERTER_CONVERT_AMOUNT).append(")");
	_buf.append(',');
	_buf.append("time=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, time);
	_buf.append(',');
	_buf.append("srcCurrencyAmount=");
	_buf.appendInt64(srcCurrencyAmount);
	_buf.append(',');
	_buf.append("srcCurrencyType=");
	_buf.append(srcCurrencyType);
	_buf.append(',');
	_buf.append("destCurrencyType=");
	_buf.append(destCurrencyType);
	_buf.append(',');
	_buf.append("applyRounding=");
	_buf.appendUint(applyRounding);
	_buf.append(',');
	_buf.append("roundUp=");
	_buf.appendUint(roundUp);
	return _buf.c_str();
}

const char *converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CONVERTER_CONVERT_AMOUNT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "time", time);
	Atf::XmlElement::encodeAsXmlElement("srcCurrencyAmount", srcCurrencyAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("srcCurrencyType", srcCurrencyType, _buf);
	Atf::XmlElement::encodeAsXmlElement("destCurrencyType", destCurrencyType, _buf);
	Atf::XmlElement::encodeAsXmlElement("applyRounding", applyRounding, _buf);
	Atf::XmlElement::encodeAsXmlElement("roundUp", roundUp, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("time"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, time);
			}
			else if (_element.equals("srcCurrencyAmount"))
			{
				srcCurrencyAmount = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("srcCurrencyType"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, srcCurrencyType)) return false;
			}
			else if (_element.equals("destCurrencyType"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, destCurrencyType)) return false;
			}
			else if (_element.equals("applyRounding"))
			{
				applyRounding = (*_value.ptr() == '1');
			}
			else if (_element.equals("roundUp"))
			{
				roundUp = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeSrvTime(time);
	_msg.composeINT64(srcCurrencyAmount);
	_msg.composeString(srcCurrencyType);
	_msg.composeString(destCurrencyType);
	_msg.composeBOOL(applyRounding);
	_msg.composeBOOL(roundUp);
}

void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseSrvTime(time);
	_parser.parseINT64(srcCurrencyAmount);
	_parser.parseStringP(srcCurrencyType);
	_parser.parseStringP(destCurrencyType);
	_parser.parseBOOL(applyRounding);
	_parser.parseBOOL(roundUp);
}

const char *converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("time", time);
	_jsonstr.compose("srcCurrencyAmount", srcCurrencyAmount);
	_jsonstr.compose("srcCurrencyType", srcCurrencyType);
	_jsonstr.compose("destCurrencyType", destCurrencyType);
	_jsonstr.compose("applyRounding", applyRounding);
	_jsonstr.compose("roundUp", roundUp);
	return _buf.c_str();
}

void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("time", time);
	_jparser.parseByNameThrow("srcCurrencyAmount", srcCurrencyAmount);
	_jparser.parseByNameThrow("srcCurrencyType", srcCurrencyType);
	_jparser.parseByNameThrow("destCurrencyType", destCurrencyType);
	_jparser.parseByNameThrow("applyRounding", applyRounding);
	_jparser.parseByNameThrow("roundUp", roundUp);
}

/*static*/ void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CONVERTER_CONVERT_AMOUNT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	SrvTime time; _jparser.validateByNameThrow("time", time);
	AtfValidator::validateSrvDateTime(_descr, "time", time, _checker, __FILE__, __LINE__);
	INT64 srcCurrencyAmount; _jparser.validateByNameThrow("srcCurrencyAmount", srcCurrencyAmount);
	AtfValidator::validateInt(_descr, "srcCurrencyAmount", srcCurrencyAmount, _checker, __FILE__, __LINE__);
	PString srcCurrencyType; _jparser.validateByNameThrow("srcCurrencyType", srcCurrencyType);
	AtfValidator::validateInt(_descr, "srcCurrencyType", srcCurrencyType.length(), _checker, __FILE__, __LINE__);
	PString destCurrencyType; _jparser.validateByNameThrow("destCurrencyType", destCurrencyType);
	AtfValidator::validateInt(_descr, "destCurrencyType", destCurrencyType.length(), _checker, __FILE__, __LINE__);
	bool applyRounding; _jparser.validateByNameThrow("applyRounding", applyRounding);
	AtfValidator::validateInt(_descr, "applyRounding", applyRounding, _checker, __FILE__, __LINE__);
	bool roundUp; _jparser.validateByNameThrow("roundUp", roundUp);
	AtfValidator::validateInt(_descr, "roundUp", roundUp, _checker, __FILE__, __LINE__);
}

/*static*/ void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CONVERTER_CONVERT_AMOUNT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	SrvTime time; _parser.parseSrvTime(time);
	AtfValidator::validateSrvDateTime(_descr, "time", time, _checker, __FILE__, __LINE__);
	INT64 srcCurrencyAmount; _parser.parseINT64(srcCurrencyAmount);
	AtfValidator::validateInt(_descr, "srcCurrencyAmount", srcCurrencyAmount, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "srcCurrencyType"); size_t szSrcCurrencyType = strlen(_dummy);
	AtfValidator::validateInt(_descr, "srcCurrencyType", szSrcCurrencyType, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "destCurrencyType"); size_t szDestCurrencyType = strlen(_dummy);
	AtfValidator::validateInt(_descr, "destCurrencyType", szDestCurrencyType, _checker, __FILE__, __LINE__);
	bool applyRounding; _parser.parseBOOL(applyRounding);
	AtfValidator::validateInt(_descr, "applyRounding", applyRounding, _checker, __FILE__, __LINE__);
	bool roundUp; _parser.parseBOOL(roundUp);
	AtfValidator::validateInt(_descr, "roundUp", roundUp, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CONVERTER_CONVERT_AMOUNT_REPLY
//=================================================================

converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_REPLY::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_REPLY()
{
	clear();
}

void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_REPLY::clear()
{
	errCode = 0;
	errorDescription.clear();
	destAmount = 0;
	rate = 0;
}

bool converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_REPLY::equals(const Protocol_MSG_CONVERTER_CONVERT_AMOUNT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errorDescription, _o.errorDescription) &&
		destAmount == _o.destAmount &&
		rate == _o.rate;
}

bool converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CONVERTER_CONVERT_AMOUNT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CONVERTER_CONVERT_AMOUNT_REPLY*)_other));
}

const char *converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CONVERTER_CONVERT_AMOUNT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errorDescription=");
		_buf.append(errorDescription);
	}
	else
	{
		_buf.append(',');
		_buf.append("destAmount=");
		_buf.appendInt64(destAmount);
		_buf.append(',');
		_buf.append("rate=");
		_buf.appendInt64(rate);
	}
	return _buf.c_str();
}

const char *converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CONVERTER_CONVERT_AMOUNT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errorDescription", errorDescription, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("destAmount", destAmount, _buf);
		Atf::XmlElement::encodeAsXmlElement("rate", rate, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errorDescription"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errorDescription)) return false;
			}
			else if (_element.equals("destAmount"))
			{
				destAmount = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("rate"))
			{
				rate = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errorDescription);
	}
	else
	{
		_msg.composeINT64(destAmount);
		_msg.composeINT64(rate);
	}
}

void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errorDescription);
	}
	else
	{
		_parser.parseINT64(destAmount);
		if(_parser.parseEnded()) return;
		_parser.parseINT64(rate);
	}
}

const char *converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errorDescription", errorDescription);
	}
	else
	{
		_jsonstr.compose("destAmount", destAmount);
		_jsonstr.compose("rate", rate);
	}
	return _buf.c_str();
}

void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errorDescription", errorDescription);
	}
	else
	{
		_jparser.parseByNameThrow("destAmount", destAmount);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("rate", rate);
	}
}

/*static*/ void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CONVERTER_CONVERT_AMOUNT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errorDescription; _jparser.validateByNameThrow("errorDescription", errorDescription);
		AtfValidator::validateInt(_descr, "errorDescription", errorDescription.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT64 destAmount; _jparser.validateByNameThrow("destAmount", destAmount);
		AtfValidator::validateInt(_descr, "destAmount", destAmount, _checker, __FILE__, __LINE__);
		if(_jparser.parseEnded()) return;
		INT64 rate; _jparser.validateByNameThrow("rate", rate);
		AtfValidator::validateInt(_descr, "rate", rate, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CONVERTER_CONVERT_AMOUNT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errorDescription"); size_t szErrorDescription = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errorDescription", szErrorDescription, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT64 destAmount; _parser.parseINT64(destAmount);
		AtfValidator::validateInt(_descr, "destAmount", destAmount, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		INT64 rate; _parser.parseINT64(rate);
		AtfValidator::validateInt(_descr, "rate", rate, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CurrencyConvertBatchRequest
//=================================================================

converter::CurrencyConvertBatchRequest::CurrencyConvertBatchRequest()
{
	clear();
}

void converter::CurrencyConvertBatchRequest::clear()
{
	srcCurrencyAmount = 0;
	srcCurrencyType.clear();
	destCurrencyType.clear();
}

bool converter::CurrencyConvertBatchRequest::equals(const CurrencyConvertBatchRequest& _o) const
{
	return srcCurrencyAmount == _o.srcCurrencyAmount &&
		Atf::atfPStringEquals(srcCurrencyType, _o.srcCurrencyType) &&
		Atf::atfPStringEquals(destCurrencyType, _o.destCurrencyType);
}

const char *converter::CurrencyConvertBatchRequest::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("srcCurrencyAmount=");
	_buf.appendInt64(srcCurrencyAmount);
	_buf.append(',');
	_buf.append("srcCurrencyType=");
	_buf.append(srcCurrencyType);
	_buf.append(',');
	_buf.append("destCurrencyType=");
	_buf.append(destCurrencyType);
	_buf.append('}');
	return _buf.c_str();
}

const char *converter::CurrencyConvertBatchRequest::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("srcCurrencyAmount", srcCurrencyAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("srcCurrencyType", srcCurrencyType, _buf);
	Atf::XmlElement::encodeAsXmlElement("destCurrencyType", destCurrencyType, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool converter::CurrencyConvertBatchRequest::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("srcCurrencyAmount"))
		{
			srcCurrencyAmount = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("srcCurrencyType"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, srcCurrencyType)) return false;
		}
		else if (_element.equals("destCurrencyType"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, destCurrencyType)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void converter::CurrencyConvertBatchRequest::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CurrencyConvertBatchRequest())) // not empty
	{
		_body.composeINT64(srcCurrencyAmount);
		_body.composeString(srcCurrencyType);
		_body.composeString(destCurrencyType);
	}

	_msg.composeMsgBody(_body);
}

void converter::CurrencyConvertBatchRequest::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT64(srcCurrencyAmount);
	_parser0.parseStringP(srcCurrencyType);
	_parser0.parseStringP(destCurrencyType);
}

const char *converter::CurrencyConvertBatchRequest::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("srcCurrencyAmount", srcCurrencyAmount);
	_jsonstr.compose("srcCurrencyType", srcCurrencyType);
	_jsonstr.compose("destCurrencyType", destCurrencyType);
	return _buf.c_str();
}

void converter::CurrencyConvertBatchRequest::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("srcCurrencyAmount", srcCurrencyAmount);
	_jparser.parseByNameThrow("srcCurrencyType", srcCurrencyType);
	_jparser.parseByNameThrow("destCurrencyType", destCurrencyType);
}

/* static */ void converter::CurrencyConvertBatchRequest::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 srcCurrencyAmount; _jparser.validateByNameThrow("srcCurrencyAmount", srcCurrencyAmount);
	AtfValidator::validateInt(_descr, "srcCurrencyAmount", srcCurrencyAmount, _checker, __FILE__, __LINE__);
	PString srcCurrencyType; _jparser.validateByNameThrow("srcCurrencyType", srcCurrencyType);
	AtfValidator::validateIntRange(_descr, "srcCurrencyType", srcCurrencyType.length(), 3, 3, _checker, __FILE__, __LINE__);
	PString destCurrencyType; _jparser.validateByNameThrow("destCurrencyType", destCurrencyType);
	AtfValidator::validateIntRange(_descr, "destCurrencyType", destCurrencyType.length(), 3, 3, _checker, __FILE__, __LINE__);
}

/*static*/ void converter::CurrencyConvertBatchRequest::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	INT64 srcCurrencyAmount; _parser0.parseINT64(srcCurrencyAmount);
	AtfValidator::validateInt(_descr, "srcCurrencyAmount", srcCurrencyAmount, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "srcCurrencyType"); size_t szSrcCurrencyType = strlen(_dummy);
	AtfValidator::validateIntRange(_descr, "srcCurrencyType", szSrcCurrencyType, 3, 3, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "destCurrencyType"); size_t szDestCurrencyType = strlen(_dummy);
	AtfValidator::validateIntRange(_descr, "destCurrencyType", szDestCurrencyType, 3, 3, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS
//=================================================================

converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS()
{
	clear();
}

void converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS::clear()
{
	time.setNull();
	applyRounding = false;
	roundUp = false;
	convertRequests.clear();
}

bool converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS::equals(const Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS& _o) const
{
	return time.equals(_o.time) &&
		applyRounding == _o.applyRounding &&
		roundUp == _o.roundUp &&
		convertRequests.equals(_o.convertRequests);
}

bool converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CONVERTER_CONVERT_BATCH_AMOUNTS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS*)_other));
}

const char *converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CONVERTER_CONVERT_BATCH_AMOUNTS).append(")");
	_buf.append(',');
	_buf.append("time=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, time);
	_buf.append(',');
	_buf.append("applyRounding=");
	_buf.appendUint(applyRounding);
	_buf.append(',');
	_buf.append("roundUp=");
	_buf.appendUint(roundUp);
	_buf.append(',');
	_buf.append("convertRequests=");
	convertRequests.toTraceString(_buf);
	return _buf.c_str();
}

const char *converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CONVERTER_CONVERT_BATCH_AMOUNTS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "time", time);
	Atf::XmlElement::encodeAsXmlElement("applyRounding", applyRounding, _buf);
	Atf::XmlElement::encodeAsXmlElement("roundUp", roundUp, _buf);
	convertRequests.toXmlString("convertRequests", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("time"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, time);
			}
			else if (_element.equals("applyRounding"))
			{
				applyRounding = (*_value.ptr() == '1');
			}
			else if (_element.equals("roundUp"))
			{
				roundUp = (*_value.ptr() == '1');
			}
			else if (_element.equals("convertRequests"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< CurrencyConvertBatchRequest, 4 > >::FromXmlString(_value, convertRequests)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeSrvTime(time);
	_msg.composeBOOL(applyRounding);
	_msg.composeBOOL(roundUp);
	convertRequests.composeMsg(_msg, _ignoreJSON);
}

void converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseSrvTime(time);
	_parser.parseBOOL(applyRounding);
	_parser.parseBOOL(roundUp);
	convertRequests.parseMsg(_parser);
}

const char *converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("time", time);
	_jsonstr.compose("applyRounding", applyRounding);
	_jsonstr.compose("roundUp", roundUp);
	_jsonstr.compose("convertRequests", convertRequests);
	return _buf.c_str();
}

void converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("time", time);
	_jparser.parseByNameThrow("applyRounding", applyRounding);
	_jparser.parseByNameThrow("roundUp", roundUp);
	_jparser.parseByNameThrow("convertRequests", convertRequests);
}

/*static*/ void converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CONVERTER_CONVERT_BATCH_AMOUNTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	SrvTime time; _jparser.validateByNameThrow("time", time);
	AtfValidator::validateSrvDateTime(_descr, "time", time, _checker, __FILE__, __LINE__);
	bool applyRounding; _jparser.validateByNameThrow("applyRounding", applyRounding);
	AtfValidator::validateInt(_descr, "applyRounding", applyRounding, _checker, __FILE__, __LINE__);
	bool roundUp; _jparser.validateByNameThrow("roundUp", roundUp);
	AtfValidator::validateInt(_descr, "roundUp", roundUp, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< CurrencyConvertBatchRequest > convertRequests; _jparser.validateByNameThrow("convertRequests", convertRequests);
	AtfValidator::validateInt(_descr, "convertRequests", convertRequests.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CONVERTER_CONVERT_BATCH_AMOUNTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	SrvTime time; _parser.parseSrvTime(time);
	AtfValidator::validateSrvDateTime(_descr, "time", time, _checker, __FILE__, __LINE__);
	bool applyRounding; _parser.parseBOOL(applyRounding);
	AtfValidator::validateInt(_descr, "applyRounding", applyRounding, _checker, __FILE__, __LINE__);
	bool roundUp; _parser.parseBOOL(roundUp);
	AtfValidator::validateInt(_descr, "roundUp", roundUp, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szConvertRequests = Atf::LAtfVector< CurrencyConvertBatchRequest, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("convertRequests"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "convertRequests", szConvertRequests, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CurrencyConvertBatchReply
//=================================================================

converter::CurrencyConvertBatchReply::CurrencyConvertBatchReply()
{
	clear();
}

void converter::CurrencyConvertBatchReply::clear()
{
	errCode = 0;
	errorDescription.clear();
	destAmount = 0;
	rate = 0;
}

bool converter::CurrencyConvertBatchReply::equals(const CurrencyConvertBatchReply& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errorDescription, _o.errorDescription) &&
		destAmount == _o.destAmount &&
		rate == _o.rate;
}

const char *converter::CurrencyConvertBatchReply::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errorDescription=");
		_buf.append(errorDescription);
	}
	else
	{
		_buf.append(',');
		_buf.append("destAmount=");
		_buf.appendInt64(destAmount);
		_buf.append(',');
		_buf.append("rate=");
		_buf.appendInt64(rate);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *converter::CurrencyConvertBatchReply::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errorDescription", errorDescription, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("destAmount", destAmount, _buf);
		Atf::XmlElement::encodeAsXmlElement("rate", rate, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool converter::CurrencyConvertBatchReply::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("errCode"))
		{
			errCode = (INT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("errorDescription"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, errorDescription)) return false;
		}
		else if (_element.equals("destAmount"))
		{
			destAmount = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rate"))
		{
			rate = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void converter::CurrencyConvertBatchReply::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CurrencyConvertBatchReply())) // not empty
	{
		_body.composeINT16(errCode);
		if(errCode)
		{
			_body.composeString(errorDescription);
		}
		else
		{
			_body.composeINT64(destAmount);
			_body.composeINT64(rate);
		}
	}

	_msg.composeMsgBody(_body);
}

void converter::CurrencyConvertBatchReply::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT16(errCode);
	if(errCode)
	{
		_parser0.parseStringP(errorDescription);
	}
	else
	{
		_parser0.parseINT64(destAmount);
		if(_parser0.parseEnded()) return;
		_parser0.parseINT64(rate);
	}
}

const char *converter::CurrencyConvertBatchReply::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errorDescription", errorDescription);
	}
	else
	{
		_jsonstr.compose("destAmount", destAmount);
		_jsonstr.compose("rate", rate);
	}
	return _buf.c_str();
}

void converter::CurrencyConvertBatchReply::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errorDescription", errorDescription);
	}
	else
	{
		_jparser.parseByNameThrow("destAmount", destAmount);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("rate", rate);
	}
}

/* static */ void converter::CurrencyConvertBatchReply::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errorDescription; _jparser.validateByNameThrow("errorDescription", errorDescription);
		AtfValidator::validateInt(_descr, "errorDescription", errorDescription.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT64 destAmount; _jparser.validateByNameThrow("destAmount", destAmount);
		AtfValidator::validateInt(_descr, "destAmount", destAmount, _checker, __FILE__, __LINE__);
		if(_jparser.parseEnded()) return;
		INT64 rate; _jparser.validateByNameThrow("rate", rate);
		AtfValidator::validateInt(_descr, "rate", rate, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void converter::CurrencyConvertBatchReply::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	INT16 errCode = 0;
	_parser0.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser0.parseStringN(_dummy, 0, "errorDescription"); size_t szErrorDescription = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errorDescription", szErrorDescription, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT64 destAmount; _parser0.parseINT64(destAmount);
		AtfValidator::validateInt(_descr, "destAmount", destAmount, _checker, __FILE__, __LINE__);
		if(_parser0.parseEnded()) return;
		INT64 rate; _parser0.parseINT64(rate);
		AtfValidator::validateInt(_descr, "rate", rate, _checker, __FILE__, __LINE__);
	}
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY
//=================================================================

converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY()
{
	clear();
}

void converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY::clear()
{
	errCode = 0;
	errorDescription.clear();
	conversionResults.clear();
}

bool converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY::equals(const Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errorDescription, _o.errorDescription) &&
		conversionResults.equals(_o.conversionResults);
}

bool converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY*)_other));
}

const char *converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errorDescription=");
		_buf.append(errorDescription);
	}
	else
	{
		_buf.append(',');
		_buf.append("conversionResults=");
		conversionResults.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errorDescription", errorDescription, _buf);
	}
	else
	{
		conversionResults.toXmlString("conversionResults", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errorDescription"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errorDescription)) return false;
			}
			else if (_element.equals("conversionResults"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< CurrencyConvertBatchReply, 4 > >::FromXmlString(_value, conversionResults)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errorDescription);
	}
	else
	{
		conversionResults.composeMsg(_msg, _ignoreJSON);
	}
}

void converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errorDescription);
	}
	else
	{
		conversionResults.parseMsg(_parser);
	}
}

const char *converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errorDescription", errorDescription);
	}
	else
	{
		_jsonstr.compose("conversionResults", conversionResults);
	}
	return _buf.c_str();
}

void converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errorDescription", errorDescription);
	}
	else
	{
		_jparser.parseByNameThrow("conversionResults", conversionResults);
	}
}

/*static*/ void converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errorDescription; _jparser.validateByNameThrow("errorDescription", errorDescription);
		AtfValidator::validateInt(_descr, "errorDescription", errorDescription.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< CurrencyConvertBatchReply > conversionResults; _jparser.validateByNameThrow("conversionResults", conversionResults);
		AtfValidator::validateInt(_descr, "conversionResults", conversionResults.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void converter::Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errorDescription"); size_t szErrorDescription = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errorDescription", szErrorDescription, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szConversionResults = Atf::LAtfVector< CurrencyConvertBatchReply, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("conversionResults"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "conversionResults", szConversionResults, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS
//=================================================================

converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS()
{
	clear();
}

void converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS::clear()
{
	time.setNull();
}

bool converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS::equals(const Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS& _o) const
{
	return time.equals(_o.time);
}

bool converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS*)_other));
}

const char *converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS).append(")");
	_buf.append(',');
	_buf.append("time=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, time);
	return _buf.c_str();
}

const char *converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "time", time);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("time"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, time);
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeSrvTime(time);
}

void converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseSrvTime(time);
}

const char *converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("time", time);
	return _buf.c_str();
}

void converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("time", time);
}

/*static*/ void converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	SrvTime time; _jparser.validateByNameThrow("time", time);
	AtfValidator::validateSrvDateTime(_descr, "time", time, _checker, __FILE__, __LINE__);
}

/*static*/ void converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	SrvTime time; _parser.parseSrvTime(time);
	AtfValidator::validateSrvDateTime(_descr, "time", time, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CurrencyConvertData
//=================================================================

converter::CurrencyConvertData::CurrencyConvertData()
{
	clear();
}

void converter::CurrencyConvertData::clear()
{
	roundingFactorsCommonRatio = 0;
	roundingFactors.clear();
	rates.clear();
}

bool converter::CurrencyConvertData::equals(const CurrencyConvertData& _o) const
{
	return roundingFactorsCommonRatio == _o.roundingFactorsCommonRatio &&
		roundingFactors.equals(_o.roundingFactors) &&
		rates.equals(_o.rates);
}

const char *converter::CurrencyConvertData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("roundingFactorsCommonRatio=");
	_buf.appendInt64(roundingFactorsCommonRatio);
	_buf.append(',');
	_buf.append("roundingFactors=");
	roundingFactors.toTraceString(_buf);
	_buf.append(',');
	_buf.append("rates=");
	rates.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *converter::CurrencyConvertData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("roundingFactorsCommonRatio", roundingFactorsCommonRatio, _buf);
	roundingFactors.toXmlString("roundingFactors", _buf);
	rates.toXmlString("rates", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool converter::CurrencyConvertData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("roundingFactorsCommonRatio"))
		{
			roundingFactorsCommonRatio = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("roundingFactors"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT64, 4 > >::FromXmlString(_value, roundingFactors)) return false;
		}
		else if (_element.equals("rates"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< CurrencyConvertRate, 4 > >::FromXmlString(_value, rates)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void converter::CurrencyConvertData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CurrencyConvertData())) // not empty
	{
		_body.composeINT64(roundingFactorsCommonRatio);
		roundingFactors.composeMsg(_body, _ignoreJSON);
		rates.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void converter::CurrencyConvertData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT64(roundingFactorsCommonRatio);
	roundingFactors.parseMsg(_parser0);
	rates.parseMsg(_parser0);
}

const char *converter::CurrencyConvertData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("roundingFactorsCommonRatio", roundingFactorsCommonRatio);
	_jsonstr.compose("roundingFactors", roundingFactors);
	_jsonstr.compose("rates", rates);
	return _buf.c_str();
}

void converter::CurrencyConvertData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("roundingFactorsCommonRatio", roundingFactorsCommonRatio);
	_jparser.parseByNameThrow("roundingFactors", roundingFactors);
	_jparser.parseByNameThrow("rates", rates);
}

/* static */ void converter::CurrencyConvertData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 roundingFactorsCommonRatio; _jparser.validateByNameThrow("roundingFactorsCommonRatio", roundingFactorsCommonRatio);
	AtfValidator::validateInt(_descr, "roundingFactorsCommonRatio", roundingFactorsCommonRatio, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< INT64 > roundingFactors; _jparser.validateByNameThrow("roundingFactors", roundingFactors);
	AtfValidator::validateInt(_descr, "roundingFactors", roundingFactors.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< CurrencyConvertRate > rates; _jparser.validateByNameThrow("rates", rates);
	AtfValidator::validateInt(_descr, "rates", rates.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void converter::CurrencyConvertData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT64 roundingFactorsCommonRatio; _parser0.parseINT64(roundingFactorsCommonRatio);
	AtfValidator::validateInt(_descr, "roundingFactorsCommonRatio", roundingFactorsCommonRatio, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szRoundingFactors = Atf::LAtfVector< INT64, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("roundingFactors"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "roundingFactors", szRoundingFactors, _checker, __FILE__, __LINE__);
	int szRates = Atf::LAtfVector< CurrencyConvertRate, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("rates"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "rates", szRates, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY
//=================================================================

converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY()
{
	clear();
}

void converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY::clear()
{
	errCode = 0;
	errorDescription.clear();
	payload.clear();
}

bool converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY::equals(const Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errorDescription, _o.errorDescription) &&
		payload.equals(_o.payload);
}

bool converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY*)_other));
}

const char *converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errorDescription=");
		_buf.append(errorDescription);
	}
	else
	{
		_buf.append(',');
		_buf.append("payload=");
		payload.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errorDescription", errorDescription, _buf);
	}
	else
	{
		payload.toXmlString("payload", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errorDescription"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errorDescription)) return false;
			}
			else if (_element.equals("payload"))
			{
				if(!Atf::AtfTempl< CurrencyConvertData >::FromXmlString(_value, payload)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errorDescription);
	}
	else
	{
		payload.composeMsg(_msg, _ignoreJSON);
	}
}

void converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errorDescription);
	}
	else
	{
		payload.parseMsg(_parser);
	}
}

const char *converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errorDescription", errorDescription);
	}
	else
	{
		_jsonstr.compose("payload", payload);
	}
	return _buf.c_str();
}

void converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errorDescription", errorDescription);
	}
	else
	{
		_jparser.parseByNameThrow("payload", payload);
	}
}

/*static*/ void converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errorDescription; _jparser.validateByNameThrow("errorDescription", errorDescription);
		AtfValidator::validateInt(_descr, "errorDescription", errorDescription.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		CurrencyConvertData payload; _jparser.validateByNameThrow("payload", payload);
	}
}

/*static*/ void converter::Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errorDescription"); size_t szErrorDescription = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errorDescription", szErrorDescription, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		CurrencyConvertData::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("payload"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE
//=================================================================

converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE()
{
	clear();
}

void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE::clear()
{
	time.setNull();
	srcCurrencyAmount = 0;
	srcCurrencyType.clear();
	destCountryCode.clear();
	applyRounding = false;
	roundUp = false;
}

bool converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE::equals(const Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE& _o) const
{
	return time.equals(_o.time) &&
		srcCurrencyAmount == _o.srcCurrencyAmount &&
		Atf::atfPStringEquals(srcCurrencyType, _o.srcCurrencyType) &&
		Atf::atfPStringEquals(destCountryCode, _o.destCountryCode) &&
		applyRounding == _o.applyRounding &&
		roundUp == _o.roundUp;
}

bool converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE*)_other));
}

const char *converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE).append(")");
	_buf.append(',');
	_buf.append("time=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, time);
	_buf.append(',');
	_buf.append("srcCurrencyAmount=");
	_buf.appendInt64(srcCurrencyAmount);
	_buf.append(',');
	_buf.append("srcCurrencyType=");
	_buf.append(srcCurrencyType);
	_buf.append(',');
	_buf.append("destCountryCode=");
	_buf.append(destCountryCode);
	_buf.append(',');
	_buf.append("applyRounding=");
	_buf.appendUint(applyRounding);
	_buf.append(',');
	_buf.append("roundUp=");
	_buf.appendUint(roundUp);
	return _buf.c_str();
}

const char *converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "time", time);
	Atf::XmlElement::encodeAsXmlElement("srcCurrencyAmount", srcCurrencyAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("srcCurrencyType", srcCurrencyType, _buf);
	Atf::XmlElement::encodeAsXmlElement("destCountryCode", destCountryCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("applyRounding", applyRounding, _buf);
	Atf::XmlElement::encodeAsXmlElement("roundUp", roundUp, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("time"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, time);
			}
			else if (_element.equals("srcCurrencyAmount"))
			{
				srcCurrencyAmount = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("srcCurrencyType"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, srcCurrencyType)) return false;
			}
			else if (_element.equals("destCountryCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, destCountryCode)) return false;
			}
			else if (_element.equals("applyRounding"))
			{
				applyRounding = (*_value.ptr() == '1');
			}
			else if (_element.equals("roundUp"))
			{
				roundUp = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeSrvTime(time);
	_msg.composeINT64(srcCurrencyAmount);
	_msg.composeString(srcCurrencyType);
	_msg.composeString(destCountryCode);
	_msg.composeBOOL(applyRounding);
	_msg.composeBOOL(roundUp);
}

void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseSrvTime(time);
	_parser.parseINT64(srcCurrencyAmount);
	_parser.parseStringP(srcCurrencyType);
	_parser.parseStringP(destCountryCode);
	_parser.parseBOOL(applyRounding);
	_parser.parseBOOL(roundUp);
}

const char *converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("time", time);
	_jsonstr.compose("srcCurrencyAmount", srcCurrencyAmount);
	_jsonstr.compose("srcCurrencyType", srcCurrencyType);
	_jsonstr.compose("destCountryCode", destCountryCode);
	_jsonstr.compose("applyRounding", applyRounding);
	_jsonstr.compose("roundUp", roundUp);
	return _buf.c_str();
}

void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("time", time);
	_jparser.parseByNameThrow("srcCurrencyAmount", srcCurrencyAmount);
	_jparser.parseByNameThrow("srcCurrencyType", srcCurrencyType);
	_jparser.parseByNameThrow("destCountryCode", destCountryCode);
	_jparser.parseByNameThrow("applyRounding", applyRounding);
	_jparser.parseByNameThrow("roundUp", roundUp);
}

/*static*/ void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	SrvTime time; _jparser.validateByNameThrow("time", time);
	AtfValidator::validateSrvDateTime(_descr, "time", time, _checker, __FILE__, __LINE__);
	INT64 srcCurrencyAmount; _jparser.validateByNameThrow("srcCurrencyAmount", srcCurrencyAmount);
	AtfValidator::validateInt(_descr, "srcCurrencyAmount", srcCurrencyAmount, _checker, __FILE__, __LINE__);
	PString srcCurrencyType; _jparser.validateByNameThrow("srcCurrencyType", srcCurrencyType);
	AtfValidator::validateIntRange(_descr, "srcCurrencyType", srcCurrencyType.length(), 3, 3, _checker, __FILE__, __LINE__);
	PString destCountryCode; _jparser.validateByNameThrow("destCountryCode", destCountryCode);
	AtfValidator::validateIntRange(_descr, "destCountryCode", destCountryCode.length(), 2, 2, _checker, __FILE__, __LINE__);
	bool applyRounding; _jparser.validateByNameThrow("applyRounding", applyRounding);
	AtfValidator::validateInt(_descr, "applyRounding", applyRounding, _checker, __FILE__, __LINE__);
	bool roundUp; _jparser.validateByNameThrow("roundUp", roundUp);
	AtfValidator::validateInt(_descr, "roundUp", roundUp, _checker, __FILE__, __LINE__);
}

/*static*/ void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	SrvTime time; _parser.parseSrvTime(time);
	AtfValidator::validateSrvDateTime(_descr, "time", time, _checker, __FILE__, __LINE__);
	INT64 srcCurrencyAmount; _parser.parseINT64(srcCurrencyAmount);
	AtfValidator::validateInt(_descr, "srcCurrencyAmount", srcCurrencyAmount, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "srcCurrencyType"); size_t szSrcCurrencyType = strlen(_dummy);
	AtfValidator::validateIntRange(_descr, "srcCurrencyType", szSrcCurrencyType, 3, 3, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "destCountryCode"); size_t szDestCountryCode = strlen(_dummy);
	AtfValidator::validateIntRange(_descr, "destCountryCode", szDestCountryCode, 2, 2, _checker, __FILE__, __LINE__);
	bool applyRounding; _parser.parseBOOL(applyRounding);
	AtfValidator::validateInt(_descr, "applyRounding", applyRounding, _checker, __FILE__, __LINE__);
	bool roundUp; _parser.parseBOOL(roundUp);
	AtfValidator::validateInt(_descr, "roundUp", roundUp, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY
//=================================================================

converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY()
{
	clear();
}

void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY::clear()
{
	errCode = 0;
	errorDescription.clear();
	destAmount = 0;
	destCurrencyType.clear();
	rate = 0;
}

bool converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY::equals(const Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errorDescription, _o.errorDescription) &&
		destAmount == _o.destAmount &&
		Atf::atfPStringEquals(destCurrencyType, _o.destCurrencyType) &&
		rate == _o.rate;
}

bool converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY*)_other));
}

const char *converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errorDescription=");
		_buf.append(errorDescription);
	}
	else
	{
		_buf.append(',');
		_buf.append("destAmount=");
		_buf.appendInt64(destAmount);
		_buf.append(',');
		_buf.append("destCurrencyType=");
		_buf.append(destCurrencyType);
		_buf.append(',');
		_buf.append("rate=");
		_buf.appendInt64(rate);
	}
	return _buf.c_str();
}

const char *converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errorDescription", errorDescription, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("destAmount", destAmount, _buf);
		Atf::XmlElement::encodeAsXmlElement("destCurrencyType", destCurrencyType, _buf);
		Atf::XmlElement::encodeAsXmlElement("rate", rate, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errorDescription"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errorDescription)) return false;
			}
			else if (_element.equals("destAmount"))
			{
				destAmount = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("destCurrencyType"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, destCurrencyType)) return false;
			}
			else if (_element.equals("rate"))
			{
				rate = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errorDescription);
	}
	else
	{
		_msg.composeINT64(destAmount);
		_msg.composeString(destCurrencyType);
		_msg.composeINT64(rate);
	}
}

void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errorDescription);
	}
	else
	{
		_parser.parseINT64(destAmount);
		_parser.parseStringP(destCurrencyType);
		if(_parser.parseEnded()) return;
		_parser.parseINT64(rate);
	}
}

const char *converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errorDescription", errorDescription);
	}
	else
	{
		_jsonstr.compose("destAmount", destAmount);
		_jsonstr.compose("destCurrencyType", destCurrencyType);
		_jsonstr.compose("rate", rate);
	}
	return _buf.c_str();
}

void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errorDescription", errorDescription);
	}
	else
	{
		_jparser.parseByNameThrow("destAmount", destAmount);
		_jparser.parseByNameThrow("destCurrencyType", destCurrencyType);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("rate", rate);
	}
}

/*static*/ void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errorDescription; _jparser.validateByNameThrow("errorDescription", errorDescription);
		AtfValidator::validateInt(_descr, "errorDescription", errorDescription.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT64 destAmount; _jparser.validateByNameThrow("destAmount", destAmount);
		AtfValidator::validateInt(_descr, "destAmount", destAmount, _checker, __FILE__, __LINE__);
		PString destCurrencyType; _jparser.validateByNameThrow("destCurrencyType", destCurrencyType);
		AtfValidator::validateIntRange(_descr, "destCurrencyType", destCurrencyType.length(), 3, 3, _checker, __FILE__, __LINE__);
		if(_jparser.parseEnded()) return;
		INT64 rate; _jparser.validateByNameThrow("rate", rate);
		AtfValidator::validateInt(_descr, "rate", rate, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void converter::Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errorDescription"); size_t szErrorDescription = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errorDescription", szErrorDescription, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT64 destAmount; _parser.parseINT64(destAmount);
		AtfValidator::validateInt(_descr, "destAmount", destAmount, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "destCurrencyType"); size_t szDestCurrencyType = strlen(_dummy);
		AtfValidator::validateIntRange(_descr, "destCurrencyType", szDestCurrencyType, 3, 3, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		INT64 rate; _parser.parseINT64(rate);
		AtfValidator::validateInt(_descr, "rate", rate, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ Atf::MessageProtocol* converter::ProtocolFactory::createMessageProtocolObject(const char *_nameSpace, UINT32 _msgId)
{
	Atf::MessageProtocol *_obj = NULL;

	if(!strcmp(_nameSpace, ""))
	{
		switch(_msgId)
		{
			case MSG_CONVERTER_CONVERT_AMOUNT: _obj = new Protocol_MSG_CONVERTER_CONVERT_AMOUNT(); break;
			case MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE: _obj = new Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE(); break;
			case MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY: _obj = new Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY(); break;
			case MSG_CONVERTER_CONVERT_AMOUNT_REPLY: _obj = new Protocol_MSG_CONVERTER_CONVERT_AMOUNT_REPLY(); break;
			case MSG_CONVERTER_CONVERT_BATCH_AMOUNTS: _obj = new Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS(); break;
			case MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY: _obj = new Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY(); break;
			case MSG_CONVERTER_GET_ALL_RATES: _obj = new Protocol_MSG_CONVERTER_GET_ALL_RATES(); break;
			case MSG_CONVERTER_GET_ALL_RATES_REPLY: _obj = new Protocol_MSG_CONVERTER_GET_ALL_RATES_REPLY(); break;
			case MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS: _obj = new Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS(); break;
			case MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY: _obj = new Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY(); break;
			case MSG_CONVERTER_GET_RATE: _obj = new Protocol_MSG_CONVERTER_GET_RATE(); break;
			case MSG_CONVERTER_GET_RATE_REPLY: _obj = new Protocol_MSG_CONVERTER_GET_RATE_REPLY(); break;
		}
	}
	
	return _obj;
}

/* static */ bool converter::ProtocolFactory::validateProtocolMessageFromJSONString(const char *_nameSpace, UINT32 _msgId, const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, ""))
	{
		switch(_msgId)
		{
			case MSG_CONVERTER_CONVERT_AMOUNT: Protocol_MSG_CONVERTER_CONVERT_AMOUNT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE: Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY: Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CONVERTER_CONVERT_AMOUNT_REPLY: Protocol_MSG_CONVERTER_CONVERT_AMOUNT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CONVERTER_CONVERT_BATCH_AMOUNTS: Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY: Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CONVERTER_GET_ALL_RATES: Protocol_MSG_CONVERTER_GET_ALL_RATES::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CONVERTER_GET_ALL_RATES_REPLY: Protocol_MSG_CONVERTER_GET_ALL_RATES_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS: Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY: Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CONVERTER_GET_RATE: Protocol_MSG_CONVERTER_GET_RATE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_CONVERTER_GET_RATE_REPLY: Protocol_MSG_CONVERTER_GET_RATE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

/* static */ bool converter::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, ""))
	{
		switch(_msgId)
		{
			case MSG_CONVERTER_CONVERT_AMOUNT: Protocol_MSG_CONVERTER_CONVERT_AMOUNT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE: Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY: Protocol_MSG_CONVERTER_CONVERT_AMOUNT_BY_COUNTRY_CODE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CONVERTER_CONVERT_AMOUNT_REPLY: Protocol_MSG_CONVERTER_CONVERT_AMOUNT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CONVERTER_CONVERT_BATCH_AMOUNTS: Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY: Protocol_MSG_CONVERTER_CONVERT_BATCH_AMOUNTS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CONVERTER_GET_ALL_RATES: Protocol_MSG_CONVERTER_GET_ALL_RATES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CONVERTER_GET_ALL_RATES_REPLY: Protocol_MSG_CONVERTER_GET_ALL_RATES_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS: Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY: Protocol_MSG_CONVERTER_GET_DATA_FOR_CLIENT_CONVERSIONS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CONVERTER_GET_RATE: Protocol_MSG_CONVERTER_GET_RATE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_CONVERTER_GET_RATE_REPLY: Protocol_MSG_CONVERTER_GET_RATE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

