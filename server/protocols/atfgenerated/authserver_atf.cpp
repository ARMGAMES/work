/**
 * authserver_atf.cpp
 *
 * This file was auto-generated from authserver_atf.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: authserver_atf.txt
 */
 
#include "authserver_atf.h"

//=================================================================
//                Protocol_AUTH_Q_LOGIN_RSA
//=================================================================

Authserver::cli::Protocol_AUTH_Q_LOGIN_RSA::Protocol_AUTH_Q_LOGIN_RSA()
{
	clear();
}

void Authserver::cli::Protocol_AUTH_Q_LOGIN_RSA::clear()
{
	rsaPin.clear();
	rsaCode.clear();
}

bool Authserver::cli::Protocol_AUTH_Q_LOGIN_RSA::equals(const Protocol_AUTH_Q_LOGIN_RSA& _o) const
{
	return Atf::atfPStringEquals(rsaPin, _o.rsaPin) &&
		Atf::atfPStringEquals(rsaCode, _o.rsaCode);
}

bool Authserver::cli::Protocol_AUTH_Q_LOGIN_RSA::equals(Atf::MessageProtocol* _other) const
{
	if (AUTH_Q_LOGIN_RSA != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_AUTH_Q_LOGIN_RSA*)_other));
}

const char *Authserver::cli::Protocol_AUTH_Q_LOGIN_RSA::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_Q_LOGIN_RSA).append(")");
	_buf.append(',');
	_buf.append("rsaPin=");
	_buf.append(rsaPin);
	_buf.append(',');
	_buf.append("rsaCode=");
	_buf.append(rsaCode);
	return _buf.c_str();
}

const char *Authserver::cli::Protocol_AUTH_Q_LOGIN_RSA::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Authserver::cli::Protocol_AUTH_Q_LOGIN_RSA::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(AUTH_Q_LOGIN_RSA).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("rsaPin", rsaPin, _buf);
	Atf::XmlElement::encodeAsXmlElement("rsaCode", rsaCode, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Authserver::cli::Protocol_AUTH_Q_LOGIN_RSA::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("rsaPin"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, rsaPin)) return false;
			}
			else if (_element.equals("rsaCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, rsaCode)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Authserver::cli::Protocol_AUTH_Q_LOGIN_RSA::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(rsaPin);
	_msg.composeString(rsaCode);
}

void Authserver::cli::Protocol_AUTH_Q_LOGIN_RSA::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(rsaPin);
	_parser.parseStringP(rsaCode);
}

const char *Authserver::cli::Protocol_AUTH_Q_LOGIN_RSA::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("rsaPin", rsaPin);
	_jsonstr.compose("rsaCode", rsaCode);
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_Q_LOGIN_RSA::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("rsaPin", rsaPin);
	_jparser.parseByNameThrow("rsaCode", rsaCode);
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_LOGIN_RSA::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_LOGIN_RSA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString rsaPin; _jparser.validateByNameThrow("rsaPin", rsaPin);
	AtfValidator::validateIntMax(_descr, "rsaPin", rsaPin.length(), 10, _checker, __FILE__, __LINE__);
	PString rsaCode; _jparser.validateByNameThrow("rsaCode", rsaCode);
	AtfValidator::validateIntMax(_descr, "rsaCode", rsaCode.length(), 10, _checker, __FILE__, __LINE__);
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_LOGIN_RSA::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_LOGIN_RSA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "rsaPin"); size_t szRsaPin = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "rsaPin", szRsaPin, 10, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "rsaCode"); size_t szRsaCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "rsaCode", szRsaCode, 10, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_A_LOGIN_RSA
//=================================================================

Authserver::cli::Protocol_AUTH_A_LOGIN_RSA::Protocol_AUTH_A_LOGIN_RSA()
{
	clear();
}

void Authserver::cli::Protocol_AUTH_A_LOGIN_RSA::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool Authserver::cli::Protocol_AUTH_A_LOGIN_RSA::equals(const Protocol_AUTH_A_LOGIN_RSA& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool Authserver::cli::Protocol_AUTH_A_LOGIN_RSA::equals(Atf::MessageProtocol* _other) const
{
	if (AUTH_A_LOGIN_RSA != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_AUTH_A_LOGIN_RSA*)_other));
}

const char *Authserver::cli::Protocol_AUTH_A_LOGIN_RSA::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_A_LOGIN_RSA).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *Authserver::cli::Protocol_AUTH_A_LOGIN_RSA::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Authserver::cli::Protocol_AUTH_A_LOGIN_RSA::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(AUTH_A_LOGIN_RSA).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Authserver::cli::Protocol_AUTH_A_LOGIN_RSA::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Authserver::cli::Protocol_AUTH_A_LOGIN_RSA::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void Authserver::cli::Protocol_AUTH_A_LOGIN_RSA::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *Authserver::cli::Protocol_AUTH_A_LOGIN_RSA::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_A_LOGIN_RSA::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void Authserver::cli::Protocol_AUTH_A_LOGIN_RSA::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_A_LOGIN_RSA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Authserver::cli::Protocol_AUTH_A_LOGIN_RSA::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_A_LOGIN_RSA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_Q_LOGIN_OTP
//=================================================================

Authserver::cli::Protocol_AUTH_Q_LOGIN_OTP::Protocol_AUTH_Q_LOGIN_OTP()
{
	clear();
}

void Authserver::cli::Protocol_AUTH_Q_LOGIN_OTP::clear()
{
	otp.clear();
	pin.clear();
}

bool Authserver::cli::Protocol_AUTH_Q_LOGIN_OTP::equals(const Protocol_AUTH_Q_LOGIN_OTP& _o) const
{
	return Atf::atfPStringEquals(otp, _o.otp) &&
		Atf::atfPStringEquals(pin, _o.pin);
}

bool Authserver::cli::Protocol_AUTH_Q_LOGIN_OTP::equals(Atf::MessageProtocol* _other) const
{
	if (AUTH_Q_LOGIN_OTP != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_AUTH_Q_LOGIN_OTP*)_other));
}

const char *Authserver::cli::Protocol_AUTH_Q_LOGIN_OTP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_Q_LOGIN_OTP).append(")");
	_buf.append(',');
	_buf.append("otp=");
	_buf.append(otp);
	_buf.append(',');
	_buf.append("pin=");
	_buf.append(pin);
	return _buf.c_str();
}

const char *Authserver::cli::Protocol_AUTH_Q_LOGIN_OTP::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Authserver::cli::Protocol_AUTH_Q_LOGIN_OTP::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(AUTH_Q_LOGIN_OTP).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("otp", otp, _buf);
	Atf::XmlElement::encodeAsXmlElement("pin", pin, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Authserver::cli::Protocol_AUTH_Q_LOGIN_OTP::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("otp"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, otp)) return false;
			}
			else if (_element.equals("pin"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, pin)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Authserver::cli::Protocol_AUTH_Q_LOGIN_OTP::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(otp);
	_msg.composeString(pin);
}

void Authserver::cli::Protocol_AUTH_Q_LOGIN_OTP::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(otp);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(pin);
}

const char *Authserver::cli::Protocol_AUTH_Q_LOGIN_OTP::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("otp", otp);
	_jsonstr.compose("pin", pin);
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_Q_LOGIN_OTP::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("otp", otp);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("pin", pin);
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_LOGIN_OTP::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_LOGIN_OTP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString otp; _jparser.validateByNameThrow("otp", otp);
	AtfValidator::validateIntMax(_descr, "otp", otp.length(), 100, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString pin; _jparser.validateByNameThrow("pin", pin);
	AtfValidator::validateIntMax(_descr, "pin", pin.length(), 10, _checker, __FILE__, __LINE__);
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_LOGIN_OTP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_LOGIN_OTP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "otp"); size_t szOtp = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "otp", szOtp, 100, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "pin"); size_t szPin = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "pin", szPin, 10, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_A_LOGIN_OTP
//=================================================================

Authserver::cli::Protocol_AUTH_A_LOGIN_OTP::Protocol_AUTH_A_LOGIN_OTP()
{
	clear();
}

void Authserver::cli::Protocol_AUTH_A_LOGIN_OTP::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool Authserver::cli::Protocol_AUTH_A_LOGIN_OTP::equals(const Protocol_AUTH_A_LOGIN_OTP& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool Authserver::cli::Protocol_AUTH_A_LOGIN_OTP::equals(Atf::MessageProtocol* _other) const
{
	if (AUTH_A_LOGIN_OTP != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_AUTH_A_LOGIN_OTP*)_other));
}

const char *Authserver::cli::Protocol_AUTH_A_LOGIN_OTP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_A_LOGIN_OTP).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *Authserver::cli::Protocol_AUTH_A_LOGIN_OTP::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Authserver::cli::Protocol_AUTH_A_LOGIN_OTP::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(AUTH_A_LOGIN_OTP).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Authserver::cli::Protocol_AUTH_A_LOGIN_OTP::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Authserver::cli::Protocol_AUTH_A_LOGIN_OTP::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void Authserver::cli::Protocol_AUTH_A_LOGIN_OTP::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *Authserver::cli::Protocol_AUTH_A_LOGIN_OTP::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_A_LOGIN_OTP::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void Authserver::cli::Protocol_AUTH_A_LOGIN_OTP::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_A_LOGIN_OTP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Authserver::cli::Protocol_AUTH_A_LOGIN_OTP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_A_LOGIN_OTP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_Q_LOGIN_LTD
//=================================================================

Authserver::cli::Protocol_AUTH_Q_LOGIN_LTD::Protocol_AUTH_Q_LOGIN_LTD()
{
	clear();
}

void Authserver::cli::Protocol_AUTH_Q_LOGIN_LTD::clear()
{
}

bool Authserver::cli::Protocol_AUTH_Q_LOGIN_LTD::equals(const Protocol_AUTH_Q_LOGIN_LTD& _o) const
{
	return true;
}

bool Authserver::cli::Protocol_AUTH_Q_LOGIN_LTD::equals(Atf::MessageProtocol* _other) const
{
	if (AUTH_Q_LOGIN_LTD != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_AUTH_Q_LOGIN_LTD*)_other));
}

const char *Authserver::cli::Protocol_AUTH_Q_LOGIN_LTD::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_Q_LOGIN_LTD).append(")");
	return _buf.c_str();
}

const char *Authserver::cli::Protocol_AUTH_Q_LOGIN_LTD::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Authserver::cli::Protocol_AUTH_Q_LOGIN_LTD::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(AUTH_Q_LOGIN_LTD).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Authserver::cli::Protocol_AUTH_Q_LOGIN_LTD::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Authserver::cli::Protocol_AUTH_Q_LOGIN_LTD::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void Authserver::cli::Protocol_AUTH_Q_LOGIN_LTD::parseMsg(CommMsgParser& _parser)
{
}

const char *Authserver::cli::Protocol_AUTH_Q_LOGIN_LTD::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_Q_LOGIN_LTD::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_LOGIN_LTD::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_LOGIN_LTD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_LOGIN_LTD::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_LOGIN_LTD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_A_LOGIN_LTD
//=================================================================

Authserver::cli::Protocol_AUTH_A_LOGIN_LTD::Protocol_AUTH_A_LOGIN_LTD()
{
	clear();
}

void Authserver::cli::Protocol_AUTH_A_LOGIN_LTD::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool Authserver::cli::Protocol_AUTH_A_LOGIN_LTD::equals(const Protocol_AUTH_A_LOGIN_LTD& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool Authserver::cli::Protocol_AUTH_A_LOGIN_LTD::equals(Atf::MessageProtocol* _other) const
{
	if (AUTH_A_LOGIN_LTD != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_AUTH_A_LOGIN_LTD*)_other));
}

const char *Authserver::cli::Protocol_AUTH_A_LOGIN_LTD::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_A_LOGIN_LTD).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *Authserver::cli::Protocol_AUTH_A_LOGIN_LTD::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Authserver::cli::Protocol_AUTH_A_LOGIN_LTD::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(AUTH_A_LOGIN_LTD).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Authserver::cli::Protocol_AUTH_A_LOGIN_LTD::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Authserver::cli::Protocol_AUTH_A_LOGIN_LTD::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void Authserver::cli::Protocol_AUTH_A_LOGIN_LTD::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *Authserver::cli::Protocol_AUTH_A_LOGIN_LTD::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_A_LOGIN_LTD::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void Authserver::cli::Protocol_AUTH_A_LOGIN_LTD::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_A_LOGIN_LTD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Authserver::cli::Protocol_AUTH_A_LOGIN_LTD::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_A_LOGIN_LTD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_U_LOGOUT_NOW
//=================================================================

Authserver::cli::Protocol_AUTH_U_LOGOUT_NOW::Protocol_AUTH_U_LOGOUT_NOW()
{
	clear();
}

void Authserver::cli::Protocol_AUTH_U_LOGOUT_NOW::clear()
{
}

bool Authserver::cli::Protocol_AUTH_U_LOGOUT_NOW::equals(const Protocol_AUTH_U_LOGOUT_NOW& _o) const
{
	return true;
}

bool Authserver::cli::Protocol_AUTH_U_LOGOUT_NOW::equals(Atf::MessageProtocol* _other) const
{
	if (AUTH_U_LOGOUT_NOW != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_AUTH_U_LOGOUT_NOW*)_other));
}

const char *Authserver::cli::Protocol_AUTH_U_LOGOUT_NOW::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_U_LOGOUT_NOW).append(")");
	return _buf.c_str();
}

const char *Authserver::cli::Protocol_AUTH_U_LOGOUT_NOW::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Authserver::cli::Protocol_AUTH_U_LOGOUT_NOW::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(AUTH_U_LOGOUT_NOW).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Authserver::cli::Protocol_AUTH_U_LOGOUT_NOW::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Authserver::cli::Protocol_AUTH_U_LOGOUT_NOW::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void Authserver::cli::Protocol_AUTH_U_LOGOUT_NOW::parseMsg(CommMsgParser& _parser)
{
}

const char *Authserver::cli::Protocol_AUTH_U_LOGOUT_NOW::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_U_LOGOUT_NOW::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void Authserver::cli::Protocol_AUTH_U_LOGOUT_NOW::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_U_LOGOUT_NOW";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void Authserver::cli::Protocol_AUTH_U_LOGOUT_NOW::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_U_LOGOUT_NOW";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_Q_GET_LOGIN_METHOD
//=================================================================

Authserver::cli::Protocol_AUTH_Q_GET_LOGIN_METHOD::Protocol_AUTH_Q_GET_LOGIN_METHOD()
{
	clear();
}

void Authserver::cli::Protocol_AUTH_Q_GET_LOGIN_METHOD::clear()
{
}

bool Authserver::cli::Protocol_AUTH_Q_GET_LOGIN_METHOD::equals(const Protocol_AUTH_Q_GET_LOGIN_METHOD& _o) const
{
	return true;
}

bool Authserver::cli::Protocol_AUTH_Q_GET_LOGIN_METHOD::equals(Atf::MessageProtocol* _other) const
{
	if (AUTH_Q_GET_LOGIN_METHOD != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_AUTH_Q_GET_LOGIN_METHOD*)_other));
}

const char *Authserver::cli::Protocol_AUTH_Q_GET_LOGIN_METHOD::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_Q_GET_LOGIN_METHOD).append(")");
	return _buf.c_str();
}

const char *Authserver::cli::Protocol_AUTH_Q_GET_LOGIN_METHOD::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Authserver::cli::Protocol_AUTH_Q_GET_LOGIN_METHOD::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(AUTH_Q_GET_LOGIN_METHOD).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Authserver::cli::Protocol_AUTH_Q_GET_LOGIN_METHOD::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Authserver::cli::Protocol_AUTH_Q_GET_LOGIN_METHOD::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void Authserver::cli::Protocol_AUTH_Q_GET_LOGIN_METHOD::parseMsg(CommMsgParser& _parser)
{
}

const char *Authserver::cli::Protocol_AUTH_Q_GET_LOGIN_METHOD::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_Q_GET_LOGIN_METHOD::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_GET_LOGIN_METHOD::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_GET_LOGIN_METHOD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_GET_LOGIN_METHOD::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_GET_LOGIN_METHOD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_A_GET_LOGIN_METHOD
//=================================================================

Authserver::cli::Protocol_AUTH_A_GET_LOGIN_METHOD::Protocol_AUTH_A_GET_LOGIN_METHOD()
{
	clear();
}

void Authserver::cli::Protocol_AUTH_A_GET_LOGIN_METHOD::clear()
{
	errCode = 0;
	errDescr.clear();
	loginMethod = 0;
	loginPriv = 0;
}

bool Authserver::cli::Protocol_AUTH_A_GET_LOGIN_METHOD::equals(const Protocol_AUTH_A_GET_LOGIN_METHOD& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		loginMethod == _o.loginMethod &&
		loginPriv == _o.loginPriv;
}

bool Authserver::cli::Protocol_AUTH_A_GET_LOGIN_METHOD::equals(Atf::MessageProtocol* _other) const
{
	if (AUTH_A_GET_LOGIN_METHOD != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_AUTH_A_GET_LOGIN_METHOD*)_other));
}

const char *Authserver::cli::Protocol_AUTH_A_GET_LOGIN_METHOD::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_A_GET_LOGIN_METHOD).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("loginMethod=");
		_buf.appendUint(loginMethod);
		_buf.append(',');
		_buf.append("loginPriv=");
		_buf.appendUint(loginPriv);
	}
	return _buf.c_str();
}

const char *Authserver::cli::Protocol_AUTH_A_GET_LOGIN_METHOD::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Authserver::cli::Protocol_AUTH_A_GET_LOGIN_METHOD::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(AUTH_A_GET_LOGIN_METHOD).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("loginMethod", loginMethod, _buf);
		Atf::XmlElement::encodeAsXmlElement("loginPriv", loginPriv, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Authserver::cli::Protocol_AUTH_A_GET_LOGIN_METHOD::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("loginMethod"))
			{
				loginMethod = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("loginPriv"))
			{
				loginPriv = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Authserver::cli::Protocol_AUTH_A_GET_LOGIN_METHOD::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(loginMethod);
		_msg.composeUINT32(loginPriv);
	}
}

void Authserver::cli::Protocol_AUTH_A_GET_LOGIN_METHOD::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(loginMethod);
		_parser.parseUINT32(loginPriv);
	}
}

const char *Authserver::cli::Protocol_AUTH_A_GET_LOGIN_METHOD::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("loginMethod", loginMethod);
		_jsonstr.compose("loginPriv", loginPriv);
	}
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_A_GET_LOGIN_METHOD::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("loginMethod", loginMethod);
		_jparser.parseByNameThrow("loginPriv", loginPriv);
	}
}

/*static*/ void Authserver::cli::Protocol_AUTH_A_GET_LOGIN_METHOD::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_A_GET_LOGIN_METHOD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 loginMethod; _jparser.validateByNameThrow("loginMethod", loginMethod);
		AtfValidator::validateInt(_descr, "loginMethod", loginMethod, _checker, __FILE__, __LINE__);
		UINT32 loginPriv; _jparser.validateByNameThrow("loginPriv", loginPriv);
		AtfValidator::validateInt(_descr, "loginPriv", loginPriv, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Authserver::cli::Protocol_AUTH_A_GET_LOGIN_METHOD::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_A_GET_LOGIN_METHOD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 loginMethod; _parser.parseUINT32(loginMethod);
		AtfValidator::validateInt(_descr, "loginMethod", loginMethod, _checker, __FILE__, __LINE__);
		UINT32 loginPriv; _parser.parseUINT32(loginPriv);
		AtfValidator::validateInt(_descr, "loginPriv", loginPriv, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_Q_SET_LOGIN_METHOD
//=================================================================

Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD::Protocol_AUTH_Q_SET_LOGIN_METHOD()
{
	clear();
}

void Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD::clear()
{
	loginMethod = 0;
	password.clear();
	sid.clear();
	rsaPin.clear();
	rsaCode.clear();
}

bool Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD::equals(const Protocol_AUTH_Q_SET_LOGIN_METHOD& _o) const
{
	return loginMethod == _o.loginMethod &&
		Atf::atfPStringEquals(password, _o.password) &&
		Atf::atfPStringEquals(sid, _o.sid) &&
		Atf::atfPStringEquals(rsaPin, _o.rsaPin) &&
		Atf::atfPStringEquals(rsaCode, _o.rsaCode);
}

bool Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD::equals(Atf::MessageProtocol* _other) const
{
	if (AUTH_Q_SET_LOGIN_METHOD != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_AUTH_Q_SET_LOGIN_METHOD*)_other));
}

const char *Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_Q_SET_LOGIN_METHOD).append(")");
	_buf.append(',');
	_buf.append("loginMethod=");
	_buf.appendUint(loginMethod);
	_buf.append(',');
	_buf.append("password=");
	_buf.append(password);
	_buf.append(',');
	_buf.append("sid=");
	_buf.append(sid);
	_buf.append(',');
	_buf.append("rsaPin=");
	_buf.append(rsaPin);
	_buf.append(',');
	_buf.append("rsaCode=");
	_buf.append(rsaCode);
	return _buf.c_str();
}

const char *Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(AUTH_Q_SET_LOGIN_METHOD).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("loginMethod", loginMethod, _buf);
	Atf::XmlElement::encodeAsXmlElement("password", password, _buf);
	Atf::XmlElement::encodeAsXmlElement("sid", sid, _buf);
	Atf::XmlElement::encodeAsXmlElement("rsaPin", rsaPin, _buf);
	Atf::XmlElement::encodeAsXmlElement("rsaCode", rsaCode, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("loginMethod"))
			{
				loginMethod = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("password"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, password)) return false;
			}
			else if (_element.equals("sid"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, sid)) return false;
			}
			else if (_element.equals("rsaPin"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, rsaPin)) return false;
			}
			else if (_element.equals("rsaCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, rsaCode)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(loginMethod);
	_msg.composeString(password);
	_msg.composeString(sid);
	_msg.composeString(rsaPin);
	_msg.composeString(rsaCode);
}

void Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(loginMethod);
	_parser.parseStringP(password);
	_parser.parseStringP(sid);
	_parser.parseStringP(rsaPin);
	_parser.parseStringP(rsaCode);
}

const char *Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("loginMethod", loginMethod);
	_jsonstr.compose("password", password);
	_jsonstr.compose("sid", sid);
	_jsonstr.compose("rsaPin", rsaPin);
	_jsonstr.compose("rsaCode", rsaCode);
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("loginMethod", loginMethod);
	_jparser.parseByNameThrow("password", password);
	_jparser.parseByNameThrow("sid", sid);
	_jparser.parseByNameThrow("rsaPin", rsaPin);
	_jparser.parseByNameThrow("rsaCode", rsaCode);
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_SET_LOGIN_METHOD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 loginMethod; _jparser.validateByNameThrow("loginMethod", loginMethod);
	AtfValidator::validateIntMax(_descr, "loginMethod", loginMethod, AUTH_LOGINTYPE_MAX, _checker, __FILE__, __LINE__);
	PString password; _jparser.validateByNameThrow("password", password);
	AtfValidator::validateIntMax(_descr, "password", password.length(), 50, _checker, __FILE__, __LINE__);
	PString sid; _jparser.validateByNameThrow("sid", sid);
	AtfValidator::validateIntMax(_descr, "sid", sid.length(), 20, _checker, __FILE__, __LINE__);
	PString rsaPin; _jparser.validateByNameThrow("rsaPin", rsaPin);
	AtfValidator::validateIntMax(_descr, "rsaPin", rsaPin.length(), 10, _checker, __FILE__, __LINE__);
	PString rsaCode; _jparser.validateByNameThrow("rsaCode", rsaCode);
	AtfValidator::validateIntMax(_descr, "rsaCode", rsaCode.length(), 10, _checker, __FILE__, __LINE__);
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_SET_LOGIN_METHOD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 loginMethod; _parser.parseUINT32(loginMethod);
	AtfValidator::validateIntMax(_descr, "loginMethod", loginMethod, AUTH_LOGINTYPE_MAX, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "password"); size_t szPassword = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "password", szPassword, 50, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "sid"); size_t szSid = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "sid", szSid, 20, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "rsaPin"); size_t szRsaPin = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "rsaPin", szRsaPin, 10, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "rsaCode"); size_t szRsaCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "rsaCode", szRsaCode, 10, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_A_SET_LOGIN_METHOD
//=================================================================

Authserver::cli::Protocol_AUTH_A_SET_LOGIN_METHOD::Protocol_AUTH_A_SET_LOGIN_METHOD()
{
	clear();
}

void Authserver::cli::Protocol_AUTH_A_SET_LOGIN_METHOD::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool Authserver::cli::Protocol_AUTH_A_SET_LOGIN_METHOD::equals(const Protocol_AUTH_A_SET_LOGIN_METHOD& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool Authserver::cli::Protocol_AUTH_A_SET_LOGIN_METHOD::equals(Atf::MessageProtocol* _other) const
{
	if (AUTH_A_SET_LOGIN_METHOD != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_AUTH_A_SET_LOGIN_METHOD*)_other));
}

const char *Authserver::cli::Protocol_AUTH_A_SET_LOGIN_METHOD::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_A_SET_LOGIN_METHOD).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *Authserver::cli::Protocol_AUTH_A_SET_LOGIN_METHOD::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Authserver::cli::Protocol_AUTH_A_SET_LOGIN_METHOD::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(AUTH_A_SET_LOGIN_METHOD).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Authserver::cli::Protocol_AUTH_A_SET_LOGIN_METHOD::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Authserver::cli::Protocol_AUTH_A_SET_LOGIN_METHOD::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void Authserver::cli::Protocol_AUTH_A_SET_LOGIN_METHOD::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *Authserver::cli::Protocol_AUTH_A_SET_LOGIN_METHOD::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_A_SET_LOGIN_METHOD::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void Authserver::cli::Protocol_AUTH_A_SET_LOGIN_METHOD::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_A_SET_LOGIN_METHOD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Authserver::cli::Protocol_AUTH_A_SET_LOGIN_METHOD::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_A_SET_LOGIN_METHOD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_Q_SET_LOGIN_METHOD_EX
//=================================================================

Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD_EX::Protocol_AUTH_Q_SET_LOGIN_METHOD_EX()
{
	clear();
}

void Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD_EX::clear()
{
	loginMethod = 0;
	password.clear();
	sid.clear();
	rsaPin.clear();
	rsaCode.clear();
}

bool Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD_EX::equals(const Protocol_AUTH_Q_SET_LOGIN_METHOD_EX& _o) const
{
	return loginMethod == _o.loginMethod &&
		Atf::atfPStringEquals(password, _o.password) &&
		Atf::atfPStringEquals(sid, _o.sid) &&
		Atf::atfPStringEquals(rsaPin, _o.rsaPin) &&
		Atf::atfPStringEquals(rsaCode, _o.rsaCode);
}

bool Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD_EX::equals(Atf::MessageProtocol* _other) const
{
	if (AUTH_Q_SET_LOGIN_METHOD_EX != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_AUTH_Q_SET_LOGIN_METHOD_EX*)_other));
}

const char *Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD_EX::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_Q_SET_LOGIN_METHOD_EX).append(")");
	_buf.append(',');
	_buf.append("loginMethod=");
	_buf.appendUint(loginMethod);
	_buf.append(',');
	_buf.append("password=");
	_buf.append(password);
	_buf.append(',');
	_buf.append("sid=");
	_buf.append(sid);
	_buf.append(',');
	_buf.append("rsaPin=");
	_buf.append(rsaPin);
	_buf.append(',');
	_buf.append("rsaCode=");
	_buf.append(rsaCode);
	return _buf.c_str();
}

const char *Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD_EX::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD_EX::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(AUTH_Q_SET_LOGIN_METHOD_EX).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("loginMethod", loginMethod, _buf);
	Atf::XmlElement::encodeAsXmlElement("password", password, _buf);
	Atf::XmlElement::encodeAsXmlElement("sid", sid, _buf);
	Atf::XmlElement::encodeAsXmlElement("rsaPin", rsaPin, _buf);
	Atf::XmlElement::encodeAsXmlElement("rsaCode", rsaCode, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD_EX::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("loginMethod"))
			{
				loginMethod = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("password"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, password)) return false;
			}
			else if (_element.equals("sid"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, sid)) return false;
			}
			else if (_element.equals("rsaPin"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, rsaPin)) return false;
			}
			else if (_element.equals("rsaCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, rsaCode)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD_EX::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(loginMethod);
	_msg.composeString(password);
	_msg.composeString(sid);
	_msg.composeString(rsaPin);
	_msg.composeString(rsaCode);
}

void Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD_EX::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(loginMethod);
	_parser.parseStringP(password);
	_parser.parseStringP(sid);
	_parser.parseStringP(rsaPin);
	_parser.parseStringP(rsaCode);
}

const char *Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD_EX::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("loginMethod", loginMethod);
	_jsonstr.compose("password", password);
	_jsonstr.compose("sid", sid);
	_jsonstr.compose("rsaPin", rsaPin);
	_jsonstr.compose("rsaCode", rsaCode);
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD_EX::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("loginMethod", loginMethod);
	_jparser.parseByNameThrow("password", password);
	_jparser.parseByNameThrow("sid", sid);
	_jparser.parseByNameThrow("rsaPin", rsaPin);
	_jparser.parseByNameThrow("rsaCode", rsaCode);
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD_EX::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_SET_LOGIN_METHOD_EX";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 loginMethod; _jparser.validateByNameThrow("loginMethod", loginMethod);
	AtfValidator::validateIntMax(_descr, "loginMethod", loginMethod, AUTH_LOGINTYPE_MAX, _checker, __FILE__, __LINE__);
	PString password; _jparser.validateByNameThrow("password", password);
	AtfValidator::validateIntMax(_descr, "password", password.length(), 200, _checker, __FILE__, __LINE__);
	PString sid; _jparser.validateByNameThrow("sid", sid);
	AtfValidator::validateIntMax(_descr, "sid", sid.length(), 20, _checker, __FILE__, __LINE__);
	PString rsaPin; _jparser.validateByNameThrow("rsaPin", rsaPin);
	AtfValidator::validateIntMax(_descr, "rsaPin", rsaPin.length(), 10, _checker, __FILE__, __LINE__);
	PString rsaCode; _jparser.validateByNameThrow("rsaCode", rsaCode);
	AtfValidator::validateIntMax(_descr, "rsaCode", rsaCode.length(), 10, _checker, __FILE__, __LINE__);
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_SET_LOGIN_METHOD_EX::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_SET_LOGIN_METHOD_EX";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 loginMethod; _parser.parseUINT32(loginMethod);
	AtfValidator::validateIntMax(_descr, "loginMethod", loginMethod, AUTH_LOGINTYPE_MAX, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "password"); size_t szPassword = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "password", szPassword, 200, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "sid"); size_t szSid = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "sid", szSid, 20, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "rsaPin"); size_t szRsaPin = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "rsaPin", szRsaPin, 10, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "rsaCode"); size_t szRsaCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "rsaCode", szRsaCode, 10, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_Q_SET_NEWINSTALL_VALIDATION
//=================================================================

Authserver::cli::Protocol_AUTH_Q_SET_NEWINSTALL_VALIDATION::Protocol_AUTH_Q_SET_NEWINSTALL_VALIDATION()
{
	clear();
}

void Authserver::cli::Protocol_AUTH_Q_SET_NEWINSTALL_VALIDATION::clear()
{
	enable = false;
}

bool Authserver::cli::Protocol_AUTH_Q_SET_NEWINSTALL_VALIDATION::equals(const Protocol_AUTH_Q_SET_NEWINSTALL_VALIDATION& _o) const
{
	return enable == _o.enable;
}

bool Authserver::cli::Protocol_AUTH_Q_SET_NEWINSTALL_VALIDATION::equals(Atf::MessageProtocol* _other) const
{
	if (AUTH_Q_SET_NEWINSTALL_VALIDATION != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_AUTH_Q_SET_NEWINSTALL_VALIDATION*)_other));
}

const char *Authserver::cli::Protocol_AUTH_Q_SET_NEWINSTALL_VALIDATION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_Q_SET_NEWINSTALL_VALIDATION).append(")");
	_buf.append(',');
	_buf.append("enable=");
	_buf.appendUint(enable);
	return _buf.c_str();
}

const char *Authserver::cli::Protocol_AUTH_Q_SET_NEWINSTALL_VALIDATION::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Authserver::cli::Protocol_AUTH_Q_SET_NEWINSTALL_VALIDATION::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(AUTH_Q_SET_NEWINSTALL_VALIDATION).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("enable", enable, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Authserver::cli::Protocol_AUTH_Q_SET_NEWINSTALL_VALIDATION::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("enable"))
			{
				enable = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Authserver::cli::Protocol_AUTH_Q_SET_NEWINSTALL_VALIDATION::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(enable);
}

void Authserver::cli::Protocol_AUTH_Q_SET_NEWINSTALL_VALIDATION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(enable);
}

const char *Authserver::cli::Protocol_AUTH_Q_SET_NEWINSTALL_VALIDATION::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("enable", enable);
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_Q_SET_NEWINSTALL_VALIDATION::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("enable", enable);
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_SET_NEWINSTALL_VALIDATION::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_SET_NEWINSTALL_VALIDATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool enable; _jparser.validateByNameThrow("enable", enable);
	AtfValidator::validateInt(_descr, "enable", enable, _checker, __FILE__, __LINE__);
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_SET_NEWINSTALL_VALIDATION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_SET_NEWINSTALL_VALIDATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	bool enable; _parser.parseBOOL(enable);
	AtfValidator::validateInt(_descr, "enable", enable, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_A_SET_NEWINSTALL_VALIDATION
//=================================================================

Authserver::cli::Protocol_AUTH_A_SET_NEWINSTALL_VALIDATION::Protocol_AUTH_A_SET_NEWINSTALL_VALIDATION()
{
	clear();
}

void Authserver::cli::Protocol_AUTH_A_SET_NEWINSTALL_VALIDATION::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool Authserver::cli::Protocol_AUTH_A_SET_NEWINSTALL_VALIDATION::equals(const Protocol_AUTH_A_SET_NEWINSTALL_VALIDATION& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool Authserver::cli::Protocol_AUTH_A_SET_NEWINSTALL_VALIDATION::equals(Atf::MessageProtocol* _other) const
{
	if (AUTH_A_SET_NEWINSTALL_VALIDATION != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_AUTH_A_SET_NEWINSTALL_VALIDATION*)_other));
}

const char *Authserver::cli::Protocol_AUTH_A_SET_NEWINSTALL_VALIDATION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_A_SET_NEWINSTALL_VALIDATION).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *Authserver::cli::Protocol_AUTH_A_SET_NEWINSTALL_VALIDATION::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Authserver::cli::Protocol_AUTH_A_SET_NEWINSTALL_VALIDATION::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(AUTH_A_SET_NEWINSTALL_VALIDATION).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Authserver::cli::Protocol_AUTH_A_SET_NEWINSTALL_VALIDATION::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Authserver::cli::Protocol_AUTH_A_SET_NEWINSTALL_VALIDATION::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void Authserver::cli::Protocol_AUTH_A_SET_NEWINSTALL_VALIDATION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *Authserver::cli::Protocol_AUTH_A_SET_NEWINSTALL_VALIDATION::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_A_SET_NEWINSTALL_VALIDATION::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void Authserver::cli::Protocol_AUTH_A_SET_NEWINSTALL_VALIDATION::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_A_SET_NEWINSTALL_VALIDATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Authserver::cli::Protocol_AUTH_A_SET_NEWINSTALL_VALIDATION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_A_SET_NEWINSTALL_VALIDATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_Q_GENERATE_PSP
//=================================================================

Authserver::cli::Protocol_AUTH_Q_GENERATE_PSP::Protocol_AUTH_Q_GENERATE_PSP()
{
	clear();
}

void Authserver::cli::Protocol_AUTH_Q_GENERATE_PSP::clear()
{
}

bool Authserver::cli::Protocol_AUTH_Q_GENERATE_PSP::equals(const Protocol_AUTH_Q_GENERATE_PSP& _o) const
{
	return true;
}

bool Authserver::cli::Protocol_AUTH_Q_GENERATE_PSP::equals(Atf::MessageProtocol* _other) const
{
	if (AUTH_Q_GENERATE_PSP != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_AUTH_Q_GENERATE_PSP*)_other));
}

const char *Authserver::cli::Protocol_AUTH_Q_GENERATE_PSP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_Q_GENERATE_PSP).append(")");
	return _buf.c_str();
}

const char *Authserver::cli::Protocol_AUTH_Q_GENERATE_PSP::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Authserver::cli::Protocol_AUTH_Q_GENERATE_PSP::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(AUTH_Q_GENERATE_PSP).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Authserver::cli::Protocol_AUTH_Q_GENERATE_PSP::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Authserver::cli::Protocol_AUTH_Q_GENERATE_PSP::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void Authserver::cli::Protocol_AUTH_Q_GENERATE_PSP::parseMsg(CommMsgParser& _parser)
{
}

const char *Authserver::cli::Protocol_AUTH_Q_GENERATE_PSP::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_Q_GENERATE_PSP::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_GENERATE_PSP::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_GENERATE_PSP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_GENERATE_PSP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_GENERATE_PSP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_A_GENERATE_PSP
//=================================================================

Authserver::cli::Protocol_AUTH_A_GENERATE_PSP::Protocol_AUTH_A_GENERATE_PSP()
{
	clear();
}

void Authserver::cli::Protocol_AUTH_A_GENERATE_PSP::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool Authserver::cli::Protocol_AUTH_A_GENERATE_PSP::equals(const Protocol_AUTH_A_GENERATE_PSP& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool Authserver::cli::Protocol_AUTH_A_GENERATE_PSP::equals(Atf::MessageProtocol* _other) const
{
	if (AUTH_A_GENERATE_PSP != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_AUTH_A_GENERATE_PSP*)_other));
}

const char *Authserver::cli::Protocol_AUTH_A_GENERATE_PSP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_A_GENERATE_PSP).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *Authserver::cli::Protocol_AUTH_A_GENERATE_PSP::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Authserver::cli::Protocol_AUTH_A_GENERATE_PSP::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(AUTH_A_GENERATE_PSP).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Authserver::cli::Protocol_AUTH_A_GENERATE_PSP::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Authserver::cli::Protocol_AUTH_A_GENERATE_PSP::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void Authserver::cli::Protocol_AUTH_A_GENERATE_PSP::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *Authserver::cli::Protocol_AUTH_A_GENERATE_PSP::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_A_GENERATE_PSP::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void Authserver::cli::Protocol_AUTH_A_GENERATE_PSP::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_A_GENERATE_PSP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Authserver::cli::Protocol_AUTH_A_GENERATE_PSP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_A_GENERATE_PSP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_Q_SET_PSP
//=================================================================

Authserver::cli::Protocol_AUTH_Q_SET_PSP::Protocol_AUTH_Q_SET_PSP()
{
	clear();
}

void Authserver::cli::Protocol_AUTH_Q_SET_PSP::clear()
{
	newPsp.clear();
}

bool Authserver::cli::Protocol_AUTH_Q_SET_PSP::equals(const Protocol_AUTH_Q_SET_PSP& _o) const
{
	return Atf::atfPStringEquals(newPsp, _o.newPsp);
}

bool Authserver::cli::Protocol_AUTH_Q_SET_PSP::equals(Atf::MessageProtocol* _other) const
{
	if (AUTH_Q_SET_PSP != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_AUTH_Q_SET_PSP*)_other));
}

const char *Authserver::cli::Protocol_AUTH_Q_SET_PSP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_Q_SET_PSP).append(")");
	_buf.append(',');
	_buf.append("newPsp=");
	_buf.append(newPsp);
	return _buf.c_str();
}

const char *Authserver::cli::Protocol_AUTH_Q_SET_PSP::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Authserver::cli::Protocol_AUTH_Q_SET_PSP::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(AUTH_Q_SET_PSP).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("newPsp", newPsp, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Authserver::cli::Protocol_AUTH_Q_SET_PSP::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("newPsp"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, newPsp)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Authserver::cli::Protocol_AUTH_Q_SET_PSP::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(newPsp);
}

void Authserver::cli::Protocol_AUTH_Q_SET_PSP::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(newPsp);
}

const char *Authserver::cli::Protocol_AUTH_Q_SET_PSP::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("newPsp", newPsp);
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_Q_SET_PSP::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("newPsp", newPsp);
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_SET_PSP::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_SET_PSP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString newPsp; _jparser.validateByNameThrow("newPsp", newPsp);
	AtfValidator::validateIntRange(_descr, "newPsp", newPsp.length(), PSP_MIN_LENGTH, PSP_MAX_LENGTH, _checker, __FILE__, __LINE__);
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_SET_PSP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_SET_PSP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "newPsp"); size_t szNewPsp = strlen(_dummy);
	AtfValidator::validateIntRange(_descr, "newPsp", szNewPsp, PSP_MIN_LENGTH, PSP_MAX_LENGTH, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_A_SET_PSP
//=================================================================

Authserver::cli::Protocol_AUTH_A_SET_PSP::Protocol_AUTH_A_SET_PSP()
{
	clear();
}

void Authserver::cli::Protocol_AUTH_A_SET_PSP::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool Authserver::cli::Protocol_AUTH_A_SET_PSP::equals(const Protocol_AUTH_A_SET_PSP& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool Authserver::cli::Protocol_AUTH_A_SET_PSP::equals(Atf::MessageProtocol* _other) const
{
	if (AUTH_A_SET_PSP != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_AUTH_A_SET_PSP*)_other));
}

const char *Authserver::cli::Protocol_AUTH_A_SET_PSP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_A_SET_PSP).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *Authserver::cli::Protocol_AUTH_A_SET_PSP::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Authserver::cli::Protocol_AUTH_A_SET_PSP::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(AUTH_A_SET_PSP).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Authserver::cli::Protocol_AUTH_A_SET_PSP::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Authserver::cli::Protocol_AUTH_A_SET_PSP::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void Authserver::cli::Protocol_AUTH_A_SET_PSP::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *Authserver::cli::Protocol_AUTH_A_SET_PSP::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_A_SET_PSP::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void Authserver::cli::Protocol_AUTH_A_SET_PSP::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_A_SET_PSP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Authserver::cli::Protocol_AUTH_A_SET_PSP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_A_SET_PSP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_Q_CHANGE_PSP
//=================================================================

Authserver::cli::Protocol_AUTH_Q_CHANGE_PSP::Protocol_AUTH_Q_CHANGE_PSP()
{
	clear();
}

void Authserver::cli::Protocol_AUTH_Q_CHANGE_PSP::clear()
{
	oldPsp.clear();
	newPsp.clear();
}

bool Authserver::cli::Protocol_AUTH_Q_CHANGE_PSP::equals(const Protocol_AUTH_Q_CHANGE_PSP& _o) const
{
	return Atf::atfPStringEquals(oldPsp, _o.oldPsp) &&
		Atf::atfPStringEquals(newPsp, _o.newPsp);
}

bool Authserver::cli::Protocol_AUTH_Q_CHANGE_PSP::equals(Atf::MessageProtocol* _other) const
{
	if (AUTH_Q_CHANGE_PSP != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_AUTH_Q_CHANGE_PSP*)_other));
}

const char *Authserver::cli::Protocol_AUTH_Q_CHANGE_PSP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_Q_CHANGE_PSP).append(")");
	_buf.append(',');
	_buf.append("oldPsp=");
	_buf.append(oldPsp);
	_buf.append(',');
	_buf.append("newPsp=");
	_buf.append(newPsp);
	return _buf.c_str();
}

const char *Authserver::cli::Protocol_AUTH_Q_CHANGE_PSP::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Authserver::cli::Protocol_AUTH_Q_CHANGE_PSP::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(AUTH_Q_CHANGE_PSP).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("oldPsp", oldPsp, _buf);
	Atf::XmlElement::encodeAsXmlElement("newPsp", newPsp, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Authserver::cli::Protocol_AUTH_Q_CHANGE_PSP::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("oldPsp"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, oldPsp)) return false;
			}
			else if (_element.equals("newPsp"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, newPsp)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Authserver::cli::Protocol_AUTH_Q_CHANGE_PSP::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(oldPsp);
	_msg.composeString(newPsp);
}

void Authserver::cli::Protocol_AUTH_Q_CHANGE_PSP::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(oldPsp);
	_parser.parseStringP(newPsp);
}

const char *Authserver::cli::Protocol_AUTH_Q_CHANGE_PSP::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("oldPsp", oldPsp);
	_jsonstr.compose("newPsp", newPsp);
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_Q_CHANGE_PSP::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("oldPsp", oldPsp);
	_jparser.parseByNameThrow("newPsp", newPsp);
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_CHANGE_PSP::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_CHANGE_PSP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString oldPsp; _jparser.validateByNameThrow("oldPsp", oldPsp);
	AtfValidator::validateIntRange(_descr, "oldPsp", oldPsp.length(), PSP_MIN_LENGTH, PSP_MAX_LENGTH, _checker, __FILE__, __LINE__);
	PString newPsp; _jparser.validateByNameThrow("newPsp", newPsp);
	AtfValidator::validateIntRange(_descr, "newPsp", newPsp.length(), PSP_MIN_LENGTH, PSP_MAX_LENGTH, _checker, __FILE__, __LINE__);
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_CHANGE_PSP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_CHANGE_PSP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "oldPsp"); size_t szOldPsp = strlen(_dummy);
	AtfValidator::validateIntRange(_descr, "oldPsp", szOldPsp, PSP_MIN_LENGTH, PSP_MAX_LENGTH, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "newPsp"); size_t szNewPsp = strlen(_dummy);
	AtfValidator::validateIntRange(_descr, "newPsp", szNewPsp, PSP_MIN_LENGTH, PSP_MAX_LENGTH, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_A_CHANGE_PSP
//=================================================================

Authserver::cli::Protocol_AUTH_A_CHANGE_PSP::Protocol_AUTH_A_CHANGE_PSP()
{
	clear();
}

void Authserver::cli::Protocol_AUTH_A_CHANGE_PSP::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool Authserver::cli::Protocol_AUTH_A_CHANGE_PSP::equals(const Protocol_AUTH_A_CHANGE_PSP& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool Authserver::cli::Protocol_AUTH_A_CHANGE_PSP::equals(Atf::MessageProtocol* _other) const
{
	if (AUTH_A_CHANGE_PSP != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_AUTH_A_CHANGE_PSP*)_other));
}

const char *Authserver::cli::Protocol_AUTH_A_CHANGE_PSP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_A_CHANGE_PSP).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *Authserver::cli::Protocol_AUTH_A_CHANGE_PSP::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Authserver::cli::Protocol_AUTH_A_CHANGE_PSP::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(AUTH_A_CHANGE_PSP).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Authserver::cli::Protocol_AUTH_A_CHANGE_PSP::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Authserver::cli::Protocol_AUTH_A_CHANGE_PSP::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void Authserver::cli::Protocol_AUTH_A_CHANGE_PSP::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *Authserver::cli::Protocol_AUTH_A_CHANGE_PSP::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_A_CHANGE_PSP::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void Authserver::cli::Protocol_AUTH_A_CHANGE_PSP::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_A_CHANGE_PSP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Authserver::cli::Protocol_AUTH_A_CHANGE_PSP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_A_CHANGE_PSP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_Q_ACTIVATE_RSA
//=================================================================

Authserver::cli::Protocol_AUTH_Q_ACTIVATE_RSA::Protocol_AUTH_Q_ACTIVATE_RSA()
{
	clear();
}

void Authserver::cli::Protocol_AUTH_Q_ACTIVATE_RSA::clear()
{
	serialNumber = 0;
	rsaPin.clear();
	rsaCode.clear();
}

bool Authserver::cli::Protocol_AUTH_Q_ACTIVATE_RSA::equals(const Protocol_AUTH_Q_ACTIVATE_RSA& _o) const
{
	return serialNumber == _o.serialNumber &&
		Atf::atfPStringEquals(rsaPin, _o.rsaPin) &&
		Atf::atfPStringEquals(rsaCode, _o.rsaCode);
}

bool Authserver::cli::Protocol_AUTH_Q_ACTIVATE_RSA::equals(Atf::MessageProtocol* _other) const
{
	if (AUTH_Q_ACTIVATE_RSA != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_AUTH_Q_ACTIVATE_RSA*)_other));
}

const char *Authserver::cli::Protocol_AUTH_Q_ACTIVATE_RSA::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_Q_ACTIVATE_RSA).append(")");
	_buf.append(',');
	_buf.append("serialNumber=");
	_buf.appendUint(serialNumber);
	_buf.append(',');
	_buf.append("rsaPin=");
	_buf.append(rsaPin);
	_buf.append(',');
	_buf.append("rsaCode=");
	_buf.append(rsaCode);
	return _buf.c_str();
}

const char *Authserver::cli::Protocol_AUTH_Q_ACTIVATE_RSA::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Authserver::cli::Protocol_AUTH_Q_ACTIVATE_RSA::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(AUTH_Q_ACTIVATE_RSA).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("serialNumber", serialNumber, _buf);
	Atf::XmlElement::encodeAsXmlElement("rsaPin", rsaPin, _buf);
	Atf::XmlElement::encodeAsXmlElement("rsaCode", rsaCode, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Authserver::cli::Protocol_AUTH_Q_ACTIVATE_RSA::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("serialNumber"))
			{
				serialNumber = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("rsaPin"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, rsaPin)) return false;
			}
			else if (_element.equals("rsaCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, rsaCode)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Authserver::cli::Protocol_AUTH_Q_ACTIVATE_RSA::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(serialNumber);
	_msg.composeString(rsaPin);
	_msg.composeString(rsaCode);
}

void Authserver::cli::Protocol_AUTH_Q_ACTIVATE_RSA::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(serialNumber);
	_parser.parseStringP(rsaPin);
	_parser.parseStringP(rsaCode);
}

const char *Authserver::cli::Protocol_AUTH_Q_ACTIVATE_RSA::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("serialNumber", serialNumber);
	_jsonstr.compose("rsaPin", rsaPin);
	_jsonstr.compose("rsaCode", rsaCode);
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_Q_ACTIVATE_RSA::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("serialNumber", serialNumber);
	_jparser.parseByNameThrow("rsaPin", rsaPin);
	_jparser.parseByNameThrow("rsaCode", rsaCode);
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_ACTIVATE_RSA::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_ACTIVATE_RSA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 serialNumber; _jparser.validateByNameThrow("serialNumber", serialNumber);
	AtfValidator::validateInt(_descr, "serialNumber", serialNumber, _checker, __FILE__, __LINE__);
	PString rsaPin; _jparser.validateByNameThrow("rsaPin", rsaPin);
	AtfValidator::validateIntMax(_descr, "rsaPin", rsaPin.length(), 10, _checker, __FILE__, __LINE__);
	PString rsaCode; _jparser.validateByNameThrow("rsaCode", rsaCode);
	AtfValidator::validateIntMax(_descr, "rsaCode", rsaCode.length(), 10, _checker, __FILE__, __LINE__);
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_ACTIVATE_RSA::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_ACTIVATE_RSA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 serialNumber; _parser.parseUINT32(serialNumber);
	AtfValidator::validateInt(_descr, "serialNumber", serialNumber, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "rsaPin"); size_t szRsaPin = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "rsaPin", szRsaPin, 10, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "rsaCode"); size_t szRsaCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "rsaCode", szRsaCode, 10, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_A_ACTIVATE_RSA
//=================================================================

Authserver::cli::Protocol_AUTH_A_ACTIVATE_RSA::Protocol_AUTH_A_ACTIVATE_RSA()
{
	clear();
}

void Authserver::cli::Protocol_AUTH_A_ACTIVATE_RSA::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool Authserver::cli::Protocol_AUTH_A_ACTIVATE_RSA::equals(const Protocol_AUTH_A_ACTIVATE_RSA& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool Authserver::cli::Protocol_AUTH_A_ACTIVATE_RSA::equals(Atf::MessageProtocol* _other) const
{
	if (AUTH_A_ACTIVATE_RSA != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_AUTH_A_ACTIVATE_RSA*)_other));
}

const char *Authserver::cli::Protocol_AUTH_A_ACTIVATE_RSA::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_A_ACTIVATE_RSA).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *Authserver::cli::Protocol_AUTH_A_ACTIVATE_RSA::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Authserver::cli::Protocol_AUTH_A_ACTIVATE_RSA::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(AUTH_A_ACTIVATE_RSA).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Authserver::cli::Protocol_AUTH_A_ACTIVATE_RSA::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Authserver::cli::Protocol_AUTH_A_ACTIVATE_RSA::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void Authserver::cli::Protocol_AUTH_A_ACTIVATE_RSA::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *Authserver::cli::Protocol_AUTH_A_ACTIVATE_RSA::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_A_ACTIVATE_RSA::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void Authserver::cli::Protocol_AUTH_A_ACTIVATE_RSA::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_A_ACTIVATE_RSA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Authserver::cli::Protocol_AUTH_A_ACTIVATE_RSA::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_A_ACTIVATE_RSA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_Q_CHECK_RSA
//=================================================================

Authserver::cli::Protocol_AUTH_Q_CHECK_RSA::Protocol_AUTH_Q_CHECK_RSA()
{
	clear();
}

void Authserver::cli::Protocol_AUTH_Q_CHECK_RSA::clear()
{
	serialNumber = 0;
}

bool Authserver::cli::Protocol_AUTH_Q_CHECK_RSA::equals(const Protocol_AUTH_Q_CHECK_RSA& _o) const
{
	return serialNumber == _o.serialNumber;
}

bool Authserver::cli::Protocol_AUTH_Q_CHECK_RSA::equals(Atf::MessageProtocol* _other) const
{
	if (AUTH_Q_CHECK_RSA != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_AUTH_Q_CHECK_RSA*)_other));
}

const char *Authserver::cli::Protocol_AUTH_Q_CHECK_RSA::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_Q_CHECK_RSA).append(")");
	_buf.append(',');
	_buf.append("serialNumber=");
	_buf.appendUint(serialNumber);
	return _buf.c_str();
}

const char *Authserver::cli::Protocol_AUTH_Q_CHECK_RSA::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Authserver::cli::Protocol_AUTH_Q_CHECK_RSA::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(AUTH_Q_CHECK_RSA).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("serialNumber", serialNumber, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Authserver::cli::Protocol_AUTH_Q_CHECK_RSA::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("serialNumber"))
			{
				serialNumber = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Authserver::cli::Protocol_AUTH_Q_CHECK_RSA::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(serialNumber);
}

void Authserver::cli::Protocol_AUTH_Q_CHECK_RSA::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(serialNumber);
}

const char *Authserver::cli::Protocol_AUTH_Q_CHECK_RSA::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("serialNumber", serialNumber);
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_Q_CHECK_RSA::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("serialNumber", serialNumber);
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_CHECK_RSA::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_CHECK_RSA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 serialNumber; _jparser.validateByNameThrow("serialNumber", serialNumber);
	AtfValidator::validateInt(_descr, "serialNumber", serialNumber, _checker, __FILE__, __LINE__);
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_CHECK_RSA::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_CHECK_RSA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 serialNumber; _parser.parseUINT32(serialNumber);
	AtfValidator::validateInt(_descr, "serialNumber", serialNumber, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_A_CHECK_RSA
//=================================================================

Authserver::cli::Protocol_AUTH_A_CHECK_RSA::Protocol_AUTH_A_CHECK_RSA()
{
	clear();
}

void Authserver::cli::Protocol_AUTH_A_CHECK_RSA::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool Authserver::cli::Protocol_AUTH_A_CHECK_RSA::equals(const Protocol_AUTH_A_CHECK_RSA& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool Authserver::cli::Protocol_AUTH_A_CHECK_RSA::equals(Atf::MessageProtocol* _other) const
{
	if (AUTH_A_CHECK_RSA != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_AUTH_A_CHECK_RSA*)_other));
}

const char *Authserver::cli::Protocol_AUTH_A_CHECK_RSA::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_A_CHECK_RSA).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *Authserver::cli::Protocol_AUTH_A_CHECK_RSA::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Authserver::cli::Protocol_AUTH_A_CHECK_RSA::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(AUTH_A_CHECK_RSA).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Authserver::cli::Protocol_AUTH_A_CHECK_RSA::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Authserver::cli::Protocol_AUTH_A_CHECK_RSA::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void Authserver::cli::Protocol_AUTH_A_CHECK_RSA::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *Authserver::cli::Protocol_AUTH_A_CHECK_RSA::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_A_CHECK_RSA::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void Authserver::cli::Protocol_AUTH_A_CHECK_RSA::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_A_CHECK_RSA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Authserver::cli::Protocol_AUTH_A_CHECK_RSA::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_A_CHECK_RSA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_Q_GENERATE_OTP
//=================================================================

Authserver::cli::Protocol_AUTH_Q_GENERATE_OTP::Protocol_AUTH_Q_GENERATE_OTP()
{
	clear();
}

void Authserver::cli::Protocol_AUTH_Q_GENERATE_OTP::clear()
{
}

bool Authserver::cli::Protocol_AUTH_Q_GENERATE_OTP::equals(const Protocol_AUTH_Q_GENERATE_OTP& _o) const
{
	return true;
}

bool Authserver::cli::Protocol_AUTH_Q_GENERATE_OTP::equals(Atf::MessageProtocol* _other) const
{
	if (AUTH_Q_GENERATE_OTP != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_AUTH_Q_GENERATE_OTP*)_other));
}

const char *Authserver::cli::Protocol_AUTH_Q_GENERATE_OTP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_Q_GENERATE_OTP).append(")");
	return _buf.c_str();
}

const char *Authserver::cli::Protocol_AUTH_Q_GENERATE_OTP::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Authserver::cli::Protocol_AUTH_Q_GENERATE_OTP::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(AUTH_Q_GENERATE_OTP).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Authserver::cli::Protocol_AUTH_Q_GENERATE_OTP::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Authserver::cli::Protocol_AUTH_Q_GENERATE_OTP::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void Authserver::cli::Protocol_AUTH_Q_GENERATE_OTP::parseMsg(CommMsgParser& _parser)
{
}

const char *Authserver::cli::Protocol_AUTH_Q_GENERATE_OTP::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_Q_GENERATE_OTP::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_GENERATE_OTP::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_GENERATE_OTP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_GENERATE_OTP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_GENERATE_OTP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_A_GENERATE_OTP
//=================================================================

Authserver::cli::Protocol_AUTH_A_GENERATE_OTP::Protocol_AUTH_A_GENERATE_OTP()
{
	clear();
}

void Authserver::cli::Protocol_AUTH_A_GENERATE_OTP::clear()
{
	errCode = 0;
	errDescr.clear();
	mobileNum.clear();
}

bool Authserver::cli::Protocol_AUTH_A_GENERATE_OTP::equals(const Protocol_AUTH_A_GENERATE_OTP& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(mobileNum, _o.mobileNum);
}

bool Authserver::cli::Protocol_AUTH_A_GENERATE_OTP::equals(Atf::MessageProtocol* _other) const
{
	if (AUTH_A_GENERATE_OTP != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_AUTH_A_GENERATE_OTP*)_other));
}

const char *Authserver::cli::Protocol_AUTH_A_GENERATE_OTP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_A_GENERATE_OTP).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("mobileNum=");
		_buf.append(mobileNum);
	}
	return _buf.c_str();
}

const char *Authserver::cli::Protocol_AUTH_A_GENERATE_OTP::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Authserver::cli::Protocol_AUTH_A_GENERATE_OTP::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(AUTH_A_GENERATE_OTP).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("mobileNum", mobileNum, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Authserver::cli::Protocol_AUTH_A_GENERATE_OTP::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("mobileNum"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, mobileNum)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Authserver::cli::Protocol_AUTH_A_GENERATE_OTP::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(mobileNum);
	}
}

void Authserver::cli::Protocol_AUTH_A_GENERATE_OTP::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(mobileNum);
	}
}

const char *Authserver::cli::Protocol_AUTH_A_GENERATE_OTP::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("mobileNum", mobileNum);
	}
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_A_GENERATE_OTP::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("mobileNum", mobileNum);
	}
}

/*static*/ void Authserver::cli::Protocol_AUTH_A_GENERATE_OTP::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_A_GENERATE_OTP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString mobileNum; _jparser.validateByNameThrow("mobileNum", mobileNum);
		AtfValidator::validateInt(_descr, "mobileNum", mobileNum.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Authserver::cli::Protocol_AUTH_A_GENERATE_OTP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_A_GENERATE_OTP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "mobileNum"); size_t szMobileNum = strlen(_dummy);
		AtfValidator::validateInt(_descr, "mobileNum", szMobileNum, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_Q_LOGIN_EMAIL_NOTIFICATION
//=================================================================

Authserver::cli::Protocol_AUTH_Q_LOGIN_EMAIL_NOTIFICATION::Protocol_AUTH_Q_LOGIN_EMAIL_NOTIFICATION()
{
	clear();
}

void Authserver::cli::Protocol_AUTH_Q_LOGIN_EMAIL_NOTIFICATION::clear()
{
	setOrRemove = false;
}

bool Authserver::cli::Protocol_AUTH_Q_LOGIN_EMAIL_NOTIFICATION::equals(const Protocol_AUTH_Q_LOGIN_EMAIL_NOTIFICATION& _o) const
{
	return setOrRemove == _o.setOrRemove;
}

bool Authserver::cli::Protocol_AUTH_Q_LOGIN_EMAIL_NOTIFICATION::equals(Atf::MessageProtocol* _other) const
{
	if (AUTH_Q_LOGIN_EMAIL_NOTIFICATION != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_AUTH_Q_LOGIN_EMAIL_NOTIFICATION*)_other));
}

const char *Authserver::cli::Protocol_AUTH_Q_LOGIN_EMAIL_NOTIFICATION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_Q_LOGIN_EMAIL_NOTIFICATION).append(")");
	_buf.append(',');
	_buf.append("setOrRemove=");
	_buf.appendUint(setOrRemove);
	return _buf.c_str();
}

const char *Authserver::cli::Protocol_AUTH_Q_LOGIN_EMAIL_NOTIFICATION::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Authserver::cli::Protocol_AUTH_Q_LOGIN_EMAIL_NOTIFICATION::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(AUTH_Q_LOGIN_EMAIL_NOTIFICATION).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("setOrRemove", setOrRemove, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Authserver::cli::Protocol_AUTH_Q_LOGIN_EMAIL_NOTIFICATION::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("setOrRemove"))
			{
				setOrRemove = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Authserver::cli::Protocol_AUTH_Q_LOGIN_EMAIL_NOTIFICATION::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(setOrRemove);
}

void Authserver::cli::Protocol_AUTH_Q_LOGIN_EMAIL_NOTIFICATION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(setOrRemove);
}

const char *Authserver::cli::Protocol_AUTH_Q_LOGIN_EMAIL_NOTIFICATION::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("setOrRemove", setOrRemove);
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_Q_LOGIN_EMAIL_NOTIFICATION::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("setOrRemove", setOrRemove);
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_LOGIN_EMAIL_NOTIFICATION::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_LOGIN_EMAIL_NOTIFICATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool setOrRemove; _jparser.validateByNameThrow("setOrRemove", setOrRemove);
	AtfValidator::validateInt(_descr, "setOrRemove", setOrRemove, _checker, __FILE__, __LINE__);
}

/*static*/ void Authserver::cli::Protocol_AUTH_Q_LOGIN_EMAIL_NOTIFICATION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_Q_LOGIN_EMAIL_NOTIFICATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	bool setOrRemove; _parser.parseBOOL(setOrRemove);
	AtfValidator::validateInt(_descr, "setOrRemove", setOrRemove, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_AUTH_A_LOGIN_EMAIL_NOTIFICATION
//=================================================================

Authserver::cli::Protocol_AUTH_A_LOGIN_EMAIL_NOTIFICATION::Protocol_AUTH_A_LOGIN_EMAIL_NOTIFICATION()
{
	clear();
}

void Authserver::cli::Protocol_AUTH_A_LOGIN_EMAIL_NOTIFICATION::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool Authserver::cli::Protocol_AUTH_A_LOGIN_EMAIL_NOTIFICATION::equals(const Protocol_AUTH_A_LOGIN_EMAIL_NOTIFICATION& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool Authserver::cli::Protocol_AUTH_A_LOGIN_EMAIL_NOTIFICATION::equals(Atf::MessageProtocol* _other) const
{
	if (AUTH_A_LOGIN_EMAIL_NOTIFICATION != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_AUTH_A_LOGIN_EMAIL_NOTIFICATION*)_other));
}

const char *Authserver::cli::Protocol_AUTH_A_LOGIN_EMAIL_NOTIFICATION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(AUTH_A_LOGIN_EMAIL_NOTIFICATION).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *Authserver::cli::Protocol_AUTH_A_LOGIN_EMAIL_NOTIFICATION::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Authserver::cli::Protocol_AUTH_A_LOGIN_EMAIL_NOTIFICATION::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(AUTH_A_LOGIN_EMAIL_NOTIFICATION).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Authserver::cli::Protocol_AUTH_A_LOGIN_EMAIL_NOTIFICATION::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Authserver::cli::Protocol_AUTH_A_LOGIN_EMAIL_NOTIFICATION::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errDescr);
	}
}

void Authserver::cli::Protocol_AUTH_A_LOGIN_EMAIL_NOTIFICATION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *Authserver::cli::Protocol_AUTH_A_LOGIN_EMAIL_NOTIFICATION::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void Authserver::cli::Protocol_AUTH_A_LOGIN_EMAIL_NOTIFICATION::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void Authserver::cli::Protocol_AUTH_A_LOGIN_EMAIL_NOTIFICATION::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_A_LOGIN_EMAIL_NOTIFICATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Authserver::cli::Protocol_AUTH_A_LOGIN_EMAIL_NOTIFICATION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "AUTH_A_LOGIN_EMAIL_NOTIFICATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ Atf::MessageProtocol* Authserver::ProtocolFactory::createMessageProtocolObject(const char *_nameSpace, UINT32 _msgId)
{
	Atf::MessageProtocol *_obj = NULL;

	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case AUTH_A_ACTIVATE_RSA: _obj = new cli::Protocol_AUTH_A_ACTIVATE_RSA(); break;
			case AUTH_A_CHANGE_PSP: _obj = new cli::Protocol_AUTH_A_CHANGE_PSP(); break;
			case AUTH_A_CHECK_RSA: _obj = new cli::Protocol_AUTH_A_CHECK_RSA(); break;
			case AUTH_A_GENERATE_OTP: _obj = new cli::Protocol_AUTH_A_GENERATE_OTP(); break;
			case AUTH_A_GENERATE_PSP: _obj = new cli::Protocol_AUTH_A_GENERATE_PSP(); break;
			case AUTH_A_GET_LOGIN_METHOD: _obj = new cli::Protocol_AUTH_A_GET_LOGIN_METHOD(); break;
			case AUTH_A_LOGIN_EMAIL_NOTIFICATION: _obj = new cli::Protocol_AUTH_A_LOGIN_EMAIL_NOTIFICATION(); break;
			case AUTH_A_LOGIN_LTD: _obj = new cli::Protocol_AUTH_A_LOGIN_LTD(); break;
			case AUTH_A_LOGIN_OTP: _obj = new cli::Protocol_AUTH_A_LOGIN_OTP(); break;
			case AUTH_A_LOGIN_RSA: _obj = new cli::Protocol_AUTH_A_LOGIN_RSA(); break;
			case AUTH_A_SET_LOGIN_METHOD: _obj = new cli::Protocol_AUTH_A_SET_LOGIN_METHOD(); break;
			case AUTH_A_SET_NEWINSTALL_VALIDATION: _obj = new cli::Protocol_AUTH_A_SET_NEWINSTALL_VALIDATION(); break;
			case AUTH_A_SET_PSP: _obj = new cli::Protocol_AUTH_A_SET_PSP(); break;
			case AUTH_Q_ACTIVATE_RSA: _obj = new cli::Protocol_AUTH_Q_ACTIVATE_RSA(); break;
			case AUTH_Q_CHANGE_PSP: _obj = new cli::Protocol_AUTH_Q_CHANGE_PSP(); break;
			case AUTH_Q_CHECK_RSA: _obj = new cli::Protocol_AUTH_Q_CHECK_RSA(); break;
			case AUTH_Q_GENERATE_OTP: _obj = new cli::Protocol_AUTH_Q_GENERATE_OTP(); break;
			case AUTH_Q_GENERATE_PSP: _obj = new cli::Protocol_AUTH_Q_GENERATE_PSP(); break;
			case AUTH_Q_GET_LOGIN_METHOD: _obj = new cli::Protocol_AUTH_Q_GET_LOGIN_METHOD(); break;
			case AUTH_Q_LOGIN_EMAIL_NOTIFICATION: _obj = new cli::Protocol_AUTH_Q_LOGIN_EMAIL_NOTIFICATION(); break;
			case AUTH_Q_LOGIN_LTD: _obj = new cli::Protocol_AUTH_Q_LOGIN_LTD(); break;
			case AUTH_Q_LOGIN_OTP: _obj = new cli::Protocol_AUTH_Q_LOGIN_OTP(); break;
			case AUTH_Q_LOGIN_RSA: _obj = new cli::Protocol_AUTH_Q_LOGIN_RSA(); break;
			case AUTH_Q_SET_LOGIN_METHOD: _obj = new cli::Protocol_AUTH_Q_SET_LOGIN_METHOD(); break;
			case AUTH_Q_SET_LOGIN_METHOD_EX: _obj = new cli::Protocol_AUTH_Q_SET_LOGIN_METHOD_EX(); break;
			case AUTH_Q_SET_NEWINSTALL_VALIDATION: _obj = new cli::Protocol_AUTH_Q_SET_NEWINSTALL_VALIDATION(); break;
			case AUTH_Q_SET_PSP: _obj = new cli::Protocol_AUTH_Q_SET_PSP(); break;
			case AUTH_U_LOGOUT_NOW: _obj = new cli::Protocol_AUTH_U_LOGOUT_NOW(); break;
		}
	}
	
	return _obj;
}

/* static */ bool Authserver::ProtocolFactory::validateProtocolMessageFromJSONString(const char *_nameSpace, UINT32 _msgId, const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case AUTH_A_ACTIVATE_RSA: cli::Protocol_AUTH_A_ACTIVATE_RSA::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case AUTH_A_CHANGE_PSP: cli::Protocol_AUTH_A_CHANGE_PSP::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case AUTH_A_CHECK_RSA: cli::Protocol_AUTH_A_CHECK_RSA::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case AUTH_A_GENERATE_OTP: cli::Protocol_AUTH_A_GENERATE_OTP::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case AUTH_A_GENERATE_PSP: cli::Protocol_AUTH_A_GENERATE_PSP::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case AUTH_A_GET_LOGIN_METHOD: cli::Protocol_AUTH_A_GET_LOGIN_METHOD::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case AUTH_A_LOGIN_EMAIL_NOTIFICATION: cli::Protocol_AUTH_A_LOGIN_EMAIL_NOTIFICATION::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case AUTH_A_LOGIN_LTD: cli::Protocol_AUTH_A_LOGIN_LTD::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case AUTH_A_LOGIN_OTP: cli::Protocol_AUTH_A_LOGIN_OTP::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case AUTH_A_LOGIN_RSA: cli::Protocol_AUTH_A_LOGIN_RSA::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case AUTH_A_SET_LOGIN_METHOD: cli::Protocol_AUTH_A_SET_LOGIN_METHOD::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case AUTH_A_SET_NEWINSTALL_VALIDATION: cli::Protocol_AUTH_A_SET_NEWINSTALL_VALIDATION::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case AUTH_A_SET_PSP: cli::Protocol_AUTH_A_SET_PSP::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_ACTIVATE_RSA: cli::Protocol_AUTH_Q_ACTIVATE_RSA::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_CHANGE_PSP: cli::Protocol_AUTH_Q_CHANGE_PSP::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_CHECK_RSA: cli::Protocol_AUTH_Q_CHECK_RSA::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_GENERATE_OTP: cli::Protocol_AUTH_Q_GENERATE_OTP::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_GENERATE_PSP: cli::Protocol_AUTH_Q_GENERATE_PSP::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_GET_LOGIN_METHOD: cli::Protocol_AUTH_Q_GET_LOGIN_METHOD::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_LOGIN_EMAIL_NOTIFICATION: cli::Protocol_AUTH_Q_LOGIN_EMAIL_NOTIFICATION::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_LOGIN_LTD: cli::Protocol_AUTH_Q_LOGIN_LTD::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_LOGIN_OTP: cli::Protocol_AUTH_Q_LOGIN_OTP::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_LOGIN_RSA: cli::Protocol_AUTH_Q_LOGIN_RSA::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_SET_LOGIN_METHOD: cli::Protocol_AUTH_Q_SET_LOGIN_METHOD::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_SET_LOGIN_METHOD_EX: cli::Protocol_AUTH_Q_SET_LOGIN_METHOD_EX::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_SET_NEWINSTALL_VALIDATION: cli::Protocol_AUTH_Q_SET_NEWINSTALL_VALIDATION::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_SET_PSP: cli::Protocol_AUTH_Q_SET_PSP::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case AUTH_U_LOGOUT_NOW: cli::Protocol_AUTH_U_LOGOUT_NOW::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

/* static */ bool Authserver::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case AUTH_A_ACTIVATE_RSA: cli::Protocol_AUTH_A_ACTIVATE_RSA::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_A_CHANGE_PSP: cli::Protocol_AUTH_A_CHANGE_PSP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_A_CHECK_RSA: cli::Protocol_AUTH_A_CHECK_RSA::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_A_GENERATE_OTP: cli::Protocol_AUTH_A_GENERATE_OTP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_A_GENERATE_PSP: cli::Protocol_AUTH_A_GENERATE_PSP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_A_GET_LOGIN_METHOD: cli::Protocol_AUTH_A_GET_LOGIN_METHOD::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_A_LOGIN_EMAIL_NOTIFICATION: cli::Protocol_AUTH_A_LOGIN_EMAIL_NOTIFICATION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_A_LOGIN_LTD: cli::Protocol_AUTH_A_LOGIN_LTD::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_A_LOGIN_OTP: cli::Protocol_AUTH_A_LOGIN_OTP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_A_LOGIN_RSA: cli::Protocol_AUTH_A_LOGIN_RSA::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_A_SET_LOGIN_METHOD: cli::Protocol_AUTH_A_SET_LOGIN_METHOD::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_A_SET_NEWINSTALL_VALIDATION: cli::Protocol_AUTH_A_SET_NEWINSTALL_VALIDATION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_A_SET_PSP: cli::Protocol_AUTH_A_SET_PSP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_ACTIVATE_RSA: cli::Protocol_AUTH_Q_ACTIVATE_RSA::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_CHANGE_PSP: cli::Protocol_AUTH_Q_CHANGE_PSP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_CHECK_RSA: cli::Protocol_AUTH_Q_CHECK_RSA::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_GENERATE_OTP: cli::Protocol_AUTH_Q_GENERATE_OTP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_GENERATE_PSP: cli::Protocol_AUTH_Q_GENERATE_PSP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_GET_LOGIN_METHOD: cli::Protocol_AUTH_Q_GET_LOGIN_METHOD::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_LOGIN_EMAIL_NOTIFICATION: cli::Protocol_AUTH_Q_LOGIN_EMAIL_NOTIFICATION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_LOGIN_LTD: cli::Protocol_AUTH_Q_LOGIN_LTD::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_LOGIN_OTP: cli::Protocol_AUTH_Q_LOGIN_OTP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_LOGIN_RSA: cli::Protocol_AUTH_Q_LOGIN_RSA::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_SET_LOGIN_METHOD: cli::Protocol_AUTH_Q_SET_LOGIN_METHOD::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_SET_LOGIN_METHOD_EX: cli::Protocol_AUTH_Q_SET_LOGIN_METHOD_EX::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_SET_NEWINSTALL_VALIDATION: cli::Protocol_AUTH_Q_SET_NEWINSTALL_VALIDATION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_Q_SET_PSP: cli::Protocol_AUTH_Q_SET_PSP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case AUTH_U_LOGOUT_NOW: cli::Protocol_AUTH_U_LOGOUT_NOW::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

